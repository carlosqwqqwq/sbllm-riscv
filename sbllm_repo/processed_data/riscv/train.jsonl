{"id": 1, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "位模式识别：利用立即数中常见的尾随零模式，将加载操作分解为更高效的序列。\n\n指令组合优化：将昂贵的宽立即数加载替换为便宜的移位操作组合。\n\n渐进式检测：从字节（8位）到半字节（4位）再到比特级别的尾随零检测，确保检测效率。\n\n架构特性利用：充分利用RISC-V的移位指令和压缩指令集特性。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 检测立即数中的尾随零，计算移位值\nhigh = imm;\nshift = 0;\nwhile ((high & 0xff) == 0) {\n    high >>= 8;\n    shift += 8;\n}\nif ((high & 0xf) == 0) {\n    high >>= 4;\n    shift += 4;\n}\nif ((high & 0x3) == 0) {\n    high >>= 2;\n    shift += 2;\n}\nif ((high & 0x1) == 0) {\n    high >>= 1;\n    shift += 1;\n}\nif (high <= 0x7fffffffl && high >= S32_MIN) {\n    // 先加载高位有效部分\n    load_immediate(compiler, dst_r, high, tmp_r);\n    // 然后左移恢复原始值\n    if (RISCV_HAS_COMPRESSED(200))\n        return push_inst16(compiler, C_SLLI | C_RD(dst_r) | C_IMM_I(shift));\n    return push_inst(compiler, SLLI | RD(dst_r) | RS1(dst_r) | IMM_I(shift));\n}\n// 简化条件检查，用断言替代运行时检查\nSLJIT_ASSERT((imm & 0xfff) != 0);\nreturn push_inst(compiler, XORI | RD(dst_r) | RS1(dst_r) | IMM_I(imm));", "source_url": "https://github.com/zherczeg/sljit/commit/a96da7a863938b58735457ab989d0e54ddffd21e", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 检测立即数中的尾随零，计算移位值\nhigh = imm;\nshift = 0;\nwhile ((high & 0xff) == 0) {\n    high >>= 8;\n    shift += 8;\n}\nif ((high & 0xf) == 0) {\n    high >>= 4;\n    shift += 4;\n}\nif ((high & 0x3) == 0) {\n    high >>= 2;\n    shift += 2;\n}\nif ((high & 0x1) == 0) {\n    high >>= 1;\n    shift += 1;\n}\nif (high <= 0x7fffffffl && high >= S32_MIN) {\n    // 先加载高位有效部分\n    load_immediate(compiler, dst_r, high, tmp_r);\n    // 然后左移恢复原始值\n    if (RISCV_HAS_COMPRESSED(200))\n        return push_inst16(compiler, C_SLLI | C_RD(dst_r) | C_IMM_I(shift));\n    return push_inst(compiler, SLLI | RD(dst_r) | RS1(dst_r) | IMM_I(shift));\n}\n// 简化条件检查，用断言替代运行时检查\nSLJIT_ASSERT((imm & 0xfff) != 0);\nreturn push_inst(compiler, XORI | RD(dst_r) | RS1(dst_r) | IMM_I(imm));", "target": "// 检测立即数中的尾随零，计算移位值\nhigh = imm;\nshift = 0;\nwhile ((high & 0xff) == 0) {\n    high >>= 8;\n    shift += 8;\n}\nif ((high & 0xf) == 0) {\n    high >>= 4;\n    shift += 4;\n}\nif ((high & 0x3) == 0) {\n    high >>= 2;\n    shift += 2;\n}\nif ((high & 0x1) == 0) {\n    high >>= 1;\n    shift += 1;\n}\nif (high <= 0x7fffffffl && high >= S32_MIN) {\n    // 先加载高位有效部分\n    load_immediate(compiler, dst_r, high, tmp_r);\n    // 然后左移恢复原始值\n    if (RISCV_HAS_COMPRESSED(200))\n        return push_inst16(compiler, C_SLLI | C_RD(dst_r) | C_IMM_I(shift));\n    return push_inst(compiler, SLLI | RD(dst_r) | RS1(dst_r) | IMM_I(shift));\n}\n// 简化条件检查，用断言替代运行时检查\nSLJIT_ASSERT((imm & 0xfff) != 0);\nreturn push_inst(compiler, XORI | RD(dst_r) | RS1(dst_r) | IMM_I(imm));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "位模式识别：利用立即数中常见的尾随零模式，将加载操作分解为更高效的序列。\n\n指令组合优化：将昂贵的宽立即数加载替换为便宜的移位操作组合。\n\n渐进式检测：从字节（8位）到半字节（4位）再到比特级别的尾随零检测，确保检测效率。\n\n架构特性利用：充分利用RISC-V的移位指令和压缩指令集特性。"}
{"id": 2, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+编译器优化", "optimization_description": "该优化实现了对RISC-V架构位操作函数的优化，将软件算法替换为硬件指令实现，减少指令占用量", "original_code": "// No original code extracted from description\n", "optimized_code": "Zbb指令的内联汇编实现：\n\n\n// 使用ctz指令实现__ffs\nasm volatile(\".option push\\n\"\n             \".option arch,+zbb\\n\"\n             \"ctz %0, %1\\n\"\n             \".option pop\\n\"\n             : \"=r\"(word) : \"r\"(word) :);\n\nAlternative动态选择机制：\n\n\nasm_volatile_goto(ALTERNATIVE(\"j %l[legacy]\", \"nop\", 0,\n                    RISCV_ISA_EXT_ZBB, 1)\n                    : : : : legacy);\n// Zbb优化路径\n// ...\nlegacy:\n// 软件回退实现\n\n编译时常数优化：\n\n#define __ffs(word) \\\n    (__builtin_constant_p(word) ? \\\n     (unsigned long)__builtin_ctzl(word) : \\\n     variable__ffs(word))\n\n优化的软件回退实现（保持高效）：\n\n// 传统的分层位扫描算法\nnum = 0;\n#if BITS_PER_LONG == 64\nif ((word & 0xffffffff) == 0) {\n    num += 32;\n    word >>= 32;\n}\n#endif\nif ((word & 0xffff) == 0) {\n    num += 16;\n    word >>= 16;\n}\n// ... 继续8位、4位、2位、1位的检查\n\nEFI stub的特殊处理：\n\ndiff\n\n- cflags-$(CONFIG_RISCV) += -fpic\n+ cflags-$(CONFIG_RISCV) += -fpic -DNO_ALTERNATIVE", "source_url": "https://github.com/torvalds/linux/commit/457926b253200bd9bdfae9a016a3b1d1dc661d55", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "Zbb指令的内联汇编实现：\n\n\n// 使用ctz指令实现__ffs\nasm volatile(\".option push\\n\"\n             \".option arch,+zbb\\n\"\n             \"ctz %0, %1\\n\"\n             \".option pop\\n\"\n             : \"=r\"(word) : \"r\"(word) :);\n\nAlternative动态选择机制：\n\n\nasm_volatile_goto(ALTERNATIVE(\"j %l[legacy]\", \"nop\", 0,\n                    RISCV_ISA_EXT_ZBB, 1)\n                    : : : : legacy);\n// Zbb优化路径\n// ...\nlegacy:\n// 软件回退实现\n\n编译时常数优化：\n\n#define __ffs(word) \\\n    (__builtin_constant_p(word) ? \\\n     (unsigned long)__builtin_ctzl(word) : \\\n     variable__ffs(word))\n\n优化的软件回退实现（保持高效）：\n\n// 传统的分层位扫描算法\nnum = 0;\n#if BITS_PER_LONG == 64\nif ((word & 0xffffffff) == 0) {\n    num += 32;\n    word >>= 32;\n}\n#endif\nif ((word & 0xffff) == 0) {\n    num += 16;\n    word >>= 16;\n}\n// ... 继续8位、4位、2位、1位的检查\n\nEFI stub的特殊处理：\n\ndiff\n\n- cflags-$(CONFIG_RISCV) += -fpic\n+ cflags-$(CONFIG_RISCV) += -fpic -DNO_ALTERNATIVE", "target": "Zbb指令的内联汇编实现：\n\n\n// 使用ctz指令实现__ffs\nasm volatile(\".option push\\n\"\n             \".option arch,+zbb\\n\"\n             \"ctz %0, %1\\n\"\n             \".option pop\\n\"\n             : \"=r\"(word) : \"r\"(word) :);\n\nAlternative动态选择机制：\n\n\nasm_volatile_goto(ALTERNATIVE(\"j %l[legacy]\", \"nop\", 0,\n                    RISCV_ISA_EXT_ZBB, 1)\n                    : : : : legacy);\n// Zbb优化路径\n// ...\nlegacy:\n// 软件回退实现\n\n编译时常数优化：\n\n#define __ffs(word) \\\n    (__builtin_constant_p(word) ? \\\n     (unsigned long)__builtin_ctzl(word) : \\\n     variable__ffs(word))\n\n优化的软件回退实现（保持高效）：\n\n// 传统的分层位扫描算法\nnum = 0;\n#if BITS_PER_LONG == 64\nif ((word & 0xffffffff) == 0) {\n    num += 32;\n    word >>= 32;\n}\n#endif\nif ((word & 0xffff) == 0) {\n    num += 16;\n    word >>= 16;\n}\n// ... 继续8位、4位、2位、1位的检查\n\nEFI stub的特殊处理：\n\ndiff\n\n- cflags-$(CONFIG_RISCV) += -fpic\n+ cflags-$(CONFIG_RISCV) += -fpic -DNO_ALTERNATIVE", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "该优化实现了对RISC-V架构位操作函数的优化，将软件算法替换为硬件指令实现，减少指令占用量"}
{"id": 3, "source": "riscv-dataset-excel", "optimization_type": "条件分支优化-尽量和0比较", "optimization_description": "优化后使用了指令beqz，可直接检测arg+1与0的大小关系，无需像优化前比较arg和-1时这两个数都需要存寄存器，节省了空间；\n优化后省了一步立即数加载（源代码第10行），且beq指令（11行）需要等待a1写入的流水线停顿，修改后bnez指令直接检测a0和0的大小关系，优化了流水线。\nbnez指令无需显式加载比较常量，计算操作不再受分支条件约束 → ​​避免因分支预测错误导致的计算指令作废​​，优化后指令数量减少，且优化了流水线。\n", "original_code": "// No original code extracted from description\n", "optimized_code": "; RV32-NEXT:    li a1, -1\n; RV32-NEXT:    beq a0, a1, .LBB0_2\n; RV32-NEXT:  # %bb.1: # %bb3\n; RV32-NEXT:    addi a0, a0, 1\n; RV32-NEXT:    ret\n; RV32-NEXT:  .LBB0_2: # %bb2\n\n; RV32-NEXT:    bnez a0, .LBB0_2\n; RV32-NEXT:  # %bb.1: # %bb2\n; RV32-NEXT:    li a0, -1\n; RV32-NEXT:  .LBB0_2: # %bb3", "source_url": "https://reviews.llvm.org/D142071", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "; RV32-NEXT:    li a1, -1\n; RV32-NEXT:    beq a0, a1, .LBB0_2\n; RV32-NEXT:  # %bb.1: # %bb3\n; RV32-NEXT:    addi a0, a0, 1\n; RV32-NEXT:    ret\n; RV32-NEXT:  .LBB0_2: # %bb2\n\n; RV32-NEXT:    bnez a0, .LBB0_2\n; RV32-NEXT:  # %bb.1: # %bb2\n; RV32-NEXT:    li a0, -1\n; RV32-NEXT:  .LBB0_2: # %bb3", "target": "; RV32-NEXT:    li a1, -1\n; RV32-NEXT:    beq a0, a1, .LBB0_2\n; RV32-NEXT:  # %bb.1: # %bb3\n; RV32-NEXT:    addi a0, a0, 1\n; RV32-NEXT:    ret\n; RV32-NEXT:  .LBB0_2: # %bb2\n\n; RV32-NEXT:    bnez a0, .LBB0_2\n; RV32-NEXT:  # %bb.1: # %bb2\n; RV32-NEXT:    li a0, -1\n; RV32-NEXT:  .LBB0_2: # %bb3", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化后使用了指令beqz，可直接检测arg+1与0的大小关系，无需像优化前比较arg和-1时这两个数都需要存寄存器，节省了空间；\n优化后省了一步立即数加载（源代码第10行），且beq指令（11行）需要等待a1写入的流水线停顿，修改后bnez指令直接检测a0和0的大小关系，优化了流水线。\nbnez指令无需显式加载比较常量，计算操作不再受分支条件约束 → ​​避免因分支预测错误导致的计算指令作废​​，优化后指令数量减少，且优化了流水线。\n"}
{"id": 4, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：targetShrinkDemandedConstant中的shrinkdemandedconstant优化对RISC-V不友好，会破坏(and X, 0xffff)模式，导致无法生成高效的zext.h指令或SLLI+SRLI序列。优化后：无条件保留(and X, 0xffff)模式，让后续指令选择阶段根据目标架构特性（是否支持zext.h扩展）选择最优指令序列。优化思路：避免过早的通用优化破坏特定架构的优化机会，将优化决策推迟到指令选择阶段。", "original_code": "targetShrinkDemandedConstant中的shrinkdemandedconstant优化对RISC-V不友好，会破坏(and X, 0xffff)模式，导致无法生成高效的zext.h指令或SLLI+SRLI序列。", "optimized_code": "-    // Preserve (and X, 0xffff) when zext.h is supported.\n-    if (Subtarget.hasStdExtZbb() || Subtarget.hasStdExtZbp()) {\n-      APInt NewMask = APInt(Mask.getBitWidth(), 0xffff);\n-      if (IsLegalMask(NewMask))\n-        return UseMask(NewMask);\n-    }\n+    // Preserve (and X, 0xffff), if zext.h exists use zext.h,\n+    // otherwise use SLLI + SRLI.\n+    APInt NewMask = APInt(Mask.getBitWidth(), 0xffff);\n+    if (IsLegalMask(NewMask))\n+      return UseMask(NewMask);", "source_url": "https://github.com/llvm/llvm-project/commit/2e74157ad47b18959ac03e0e5000cd0a15fe76e0", "code_v0_no_empty_lines": "targetShrinkDemandedConstant中的shrinkdemandedconstant优化对RISC-V不友好，会破坏(and X, 0xffff)模式，导致无法生成高效的zext.h指令或SLLI+SRLI序列。", "code_v1_no_empty_lines": "-    // Preserve (and X, 0xffff) when zext.h is supported.\n-    if (Subtarget.hasStdExtZbb() || Subtarget.hasStdExtZbp()) {\n-      APInt NewMask = APInt(Mask.getBitWidth(), 0xffff);\n-      if (IsLegalMask(NewMask))\n-        return UseMask(NewMask);\n-    }\n+    // Preserve (and X, 0xffff), if zext.h exists use zext.h,\n+    // otherwise use SLLI + SRLI.\n+    APInt NewMask = APInt(Mask.getBitWidth(), 0xffff);\n+    if (IsLegalMask(NewMask))\n+      return UseMask(NewMask);", "target": "-    // Preserve (and X, 0xffff) when zext.h is supported.\n-    if (Subtarget.hasStdExtZbb() || Subtarget.hasStdExtZbp()) {\n-      APInt NewMask = APInt(Mask.getBitWidth(), 0xffff);\n-      if (IsLegalMask(NewMask))\n-        return UseMask(NewMask);\n-    }\n+    // Preserve (and X, 0xffff), if zext.h exists use zext.h,\n+    // otherwise use SLLI + SRLI.\n+    APInt NewMask = APInt(Mask.getBitWidth(), 0xffff);\n+    if (IsLegalMask(NewMask))\n+      return UseMask(NewMask);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：targetShrinkDemandedConstant中的shrinkdemandedconstant优化对RISC-V不友好，会破坏(and X, 0xffff)模式，导致无法生成高效的zext.h指令或SLLI+SRLI序列。优化后：无条件保留(and X, 0xffff)模式，让后续指令选择阶段根据目标架构特性（是否支持zext.h扩展）选择最优指令序列。优化思路：避免过早的通用优化破坏特定架构的优化机会，将优化决策推迟到指令选择阶段。"}
{"id": 5, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：在DAG合并阶段，对于形如(select c, 0/-1, X)的模式，会立即转换为or/and指令，可能错过后续lowerSelect阶段的优化机会。优化后：当目标平台支持短前向分支优化时，保留(select c, 0/-1, X)模式，延迟到lowerSelect阶段处理。优化思路：利用lowerSelect将select转换为条件移动指令，避免生成分支指令，提高代码执行效率，特别是在支持短前向分支优化的RISC-V平台上。", "original_code": "在DAG合并阶段，对于形如(select c, 0/-1, X)的模式，会立即转换为or/and指令，可能错过后续lowerSelect阶段的优化机会。", "optimized_code": "-static SDValue combineSelectAndUse(SDNode *N, SDValue Slct, SDValue OtherOp,\n-                                   SelectionDAG &DAG, bool AllOnes) {\n+static SDValue combineSelectAndUse(SDNode *N, SDValue Slct, SDValue OtherOp,\n+                                   SelectionDAG &DAG, bool AllOnes,\n+                                   const RISCVSubtarget &Subtarget) {\n   EVT VT = N->getValueType(0);\n \n   // Skip vectors.\n   if (VT.isVector())\n     return SDValue();\n \n-  if ((Slct.getOpcode() != ISD::SELECT &&\n+  if (!Subtarget.hasShortForwardBranchOpt() ||\n+      (Slct.getOpcode() != ISD::SELECT &&\n        Slct.getOpcode() != RISCVISD::SELECT_CC) ||\n       !Slct.hasOneUse())\n     return SDValue();", "source_url": "https://github.com/llvm/llvm-project/commit/85834d8685c12dea2cf054a5cf138395cb1f8d9f", "code_v0_no_empty_lines": "在DAG合并阶段，对于形如(select c, 0/-1, X)的模式，会立即转换为or/and指令，可能错过后续lowerSelect阶段的优化机会。", "code_v1_no_empty_lines": "-static SDValue combineSelectAndUse(SDNode *N, SDValue Slct, SDValue OtherOp,\n-                                   SelectionDAG &DAG, bool AllOnes) {\n+static SDValue combineSelectAndUse(SDNode *N, SDValue Slct, SDValue OtherOp,\n+                                   SelectionDAG &DAG, bool AllOnes,\n+                                   const RISCVSubtarget &Subtarget) {\n   EVT VT = N->getValueType(0);\n \n   // Skip vectors.\n   if (VT.isVector())\n     return SDValue();\n \n-  if ((Slct.getOpcode() != ISD::SELECT &&\n+  if (!Subtarget.hasShortForwardBranchOpt() ||\n+      (Slct.getOpcode() != ISD::SELECT &&\n        Slct.getOpcode() != RISCVISD::SELECT_CC) ||\n       !Slct.hasOneUse())\n     return SDValue();", "target": "-static SDValue combineSelectAndUse(SDNode *N, SDValue Slct, SDValue OtherOp,\n-                                   SelectionDAG &DAG, bool AllOnes) {\n+static SDValue combineSelectAndUse(SDNode *N, SDValue Slct, SDValue OtherOp,\n+                                   SelectionDAG &DAG, bool AllOnes,\n+                                   const RISCVSubtarget &Subtarget) {\n   EVT VT = N->getValueType(0);\n \n   // Skip vectors.\n   if (VT.isVector())\n     return SDValue();\n \n-  if ((Slct.getOpcode() != ISD::SELECT &&\n+  if (!Subtarget.hasShortForwardBranchOpt() ||\n+      (Slct.getOpcode() != ISD::SELECT &&\n        Slct.getOpcode() != RISCVISD::SELECT_CC) ||\n       !Slct.hasOneUse())\n     return SDValue();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在DAG合并阶段，对于形如(select c, 0/-1, X)的模式，会立即转换为or/and指令，可能错过后续lowerSelect阶段的优化机会。优化后：当目标平台支持短前向分支优化时，保留(select c, 0/-1, X)模式，延迟到lowerSelect阶段处理。优化思路：利用lowerSelect将select转换为条件移动指令，避免生成分支指令，提高代码执行效率，特别是在支持短前向分支优化的RISC-V平台上。"}
{"id": 6, "source": "riscv-dataset-excel", "optimization_type": "分支消除优化", "optimization_description": "优化前：对于(select (x < 0), TrueConstant, FalseConstant)和(select (x >= 0), TrueConstant, FalseConstant)模式，编译器会生成基于条件分支的代码，导致不可预测的分支开销。优化后：将条件选择转换为无分支的算术运算序列：(x >> (XLEN-1)) & (y-z) + z 或 (x >> (XLEN-1)) & (z-y) + y。优化思路：利用符号位扩展特性（x<0时符号位全1，x>=0时符号位全0），通过算术右移、按位与和加法运算替代条件分支，消除分支预测失败的开销，提高代码执行效率。", "original_code": "对于(select (x < 0), TrueConstant, FalseConstant)和(select (x >= 0), TrueConstant, FalseConstant)模式，编译器会生成基于条件分支的代码，导致不可预测的分支开销。", "optimized_code": "if (!Subtarget.hasShortForwardBranchOpt() && isa<ConstantSDNode>(TrueV) && isa<ConstantSDNode>(FalseV) && isNullConstant(RHS) && (CCVal == ISD::CondCode::SETLT || CCVal == ISD::CondCode::SETGE)) {\n  if (CCVal == ISD::CondCode::SETGE)\n    std::swap(TrueV, FalseV);\n\n  int64_t TrueSImm = cast<ConstantSDNode>(TrueV)->getSExtValue();\n  int64_t FalseSImm = cast<ConstantSDNode>(FalseV)->getSExtValue();\n  // Only handle simm12, if it is not in this range, it can be considered as\n  // register.\n  if (isInt<12>(TrueSImm) && isInt<12>(FalseSImm) &&\n      isInt<12>(TrueSImm - FalseSImm)) {\n    SDValue SRA =\n        DAG.getNode(ISD::SRA, DL, VT, LHS,\n                    DAG.getConstant(Subtarget.getXLen() - 1, DL, VT));\n    SDValue AND =\n        DAG.getNode(ISD::AND, DL, VT, SRA,\n                    DAG.getConstant(TrueSImm - FalseSImm, DL, VT));\n    return DAG.getNode(ISD::ADD, DL, VT, AND, FalseV);\n  }\n\n  if (CCVal == ISD::CondCode::SETGE)\n    std::swap(TrueV, FalseV);\n}", "source_url": "https://github.com/llvm/llvm-project/commit/aa14f002d57b8b3cf30f07c782d2d93f358e51fd", "code_v0_no_empty_lines": "对于(select (x < 0), TrueConstant, FalseConstant)和(select (x >= 0), TrueConstant, FalseConstant)模式，编译器会生成基于条件分支的代码，导致不可预测的分支开销。", "code_v1_no_empty_lines": "if (!Subtarget.hasShortForwardBranchOpt() && isa<ConstantSDNode>(TrueV) && isa<ConstantSDNode>(FalseV) && isNullConstant(RHS) && (CCVal == ISD::CondCode::SETLT || CCVal == ISD::CondCode::SETGE)) {\n  if (CCVal == ISD::CondCode::SETGE)\n    std::swap(TrueV, FalseV);\n\n  int64_t TrueSImm = cast<ConstantSDNode>(TrueV)->getSExtValue();\n  int64_t FalseSImm = cast<ConstantSDNode>(FalseV)->getSExtValue();\n  // Only handle simm12, if it is not in this range, it can be considered as\n  // register.\n  if (isInt<12>(TrueSImm) && isInt<12>(FalseSImm) &&\n      isInt<12>(TrueSImm - FalseSImm)) {\n    SDValue SRA =\n        DAG.getNode(ISD::SRA, DL, VT, LHS,\n                    DAG.getConstant(Subtarget.getXLen() - 1, DL, VT));\n    SDValue AND =\n        DAG.getNode(ISD::AND, DL, VT, SRA,\n                    DAG.getConstant(TrueSImm - FalseSImm, DL, VT));\n    return DAG.getNode(ISD::ADD, DL, VT, AND, FalseV);\n  }\n\n  if (CCVal == ISD::CondCode::SETGE)\n    std::swap(TrueV, FalseV);\n}", "target": "if (!Subtarget.hasShortForwardBranchOpt() && isa<ConstantSDNode>(TrueV) && isa<ConstantSDNode>(FalseV) && isNullConstant(RHS) && (CCVal == ISD::CondCode::SETLT || CCVal == ISD::CondCode::SETGE)) {\n  if (CCVal == ISD::CondCode::SETGE)\n    std::swap(TrueV, FalseV);\n\n  int64_t TrueSImm = cast<ConstantSDNode>(TrueV)->getSExtValue();\n  int64_t FalseSImm = cast<ConstantSDNode>(FalseV)->getSExtValue();\n  // Only handle simm12, if it is not in this range, it can be considered as\n  // register.\n  if (isInt<12>(TrueSImm) && isInt<12>(FalseSImm) &&\n      isInt<12>(TrueSImm - FalseSImm)) {\n    SDValue SRA =\n        DAG.getNode(ISD::SRA, DL, VT, LHS,\n                    DAG.getConstant(Subtarget.getXLen() - 1, DL, VT));\n    SDValue AND =\n        DAG.getNode(ISD::AND, DL, VT, SRA,\n                    DAG.getConstant(TrueSImm - FalseSImm, DL, VT));\n    return DAG.getNode(ISD::ADD, DL, VT, AND, FalseV);\n  }\n\n  if (CCVal == ISD::CondCode::SETGE)\n    std::swap(TrueV, FalseV);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于(select (x < 0), TrueConstant, FalseConstant)和(select (x >= 0), TrueConstant, FalseConstant)模式，编译器会生成基于条件分支的代码，导致不可预测的分支开销。优化后：将条件选择转换为无分支的算术运算序列：(x >> (XLEN-1)) & (y-z) + z 或 (x >> (XLEN-1)) & (z-y) + y。优化思路：利用符号位扩展特性（x<0时符号位全1，x>=0时符号位全0），通过算术右移、按位与和加法运算替代条件分支，消除分支预测失败的开销，提高代码执行效率。"}
{"id": 7, "source": "riscv-dataset-excel", "optimization_type": "尾调用优化", "optimization_description": "优化前：RISCV后端禁止对具有弱链接的外部定义函数进行尾调用优化，认为分支指令行为是implementation-defined，不能依赖链接器替换尾调用为返回。优化后：移除了对弱链接外部函数的尾调用限制，允许对这类函数进行尾调用优化。优化思路：参考ARM的尾调用优化实现，发现RISCV ABI没有对弱符号的限制，且GCC也支持这种优化，因此移除不必要的限制以提高代码生成性能。", "original_code": "RISCV后端禁止对具有弱链接的外部定义函数进行尾调用优化，认为分支指令行为是implementation-defined，不能依赖链接器替换尾调用为返回。", "optimized_code": "-  // Externally-defined functions with weak linkage should not be\n-  // tail-called. The behaviour of branch instructions in this situation (as\n-  // used for tail calls) is implementation-defined, so we cannot rely on the\n-  // linker replacing the tail call with a return.\n-  if (GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(Callee)) {\n-    const GlobalValue *GV = G->getGlobal();\n-    if (GV->hasExternalWeakLinkage())\n-      return false;\n-  }", "source_url": "https://github.com/llvm/llvm-project/commit/41fdb4c53f44281e4c7e26c2571395b9fc692cc4", "code_v0_no_empty_lines": "RISCV后端禁止对具有弱链接的外部定义函数进行尾调用优化，认为分支指令行为是implementation-defined，不能依赖链接器替换尾调用为返回。", "code_v1_no_empty_lines": "-  // Externally-defined functions with weak linkage should not be\n-  // tail-called. The behaviour of branch instructions in this situation (as\n-  // used for tail calls) is implementation-defined, so we cannot rely on the\n-  // linker replacing the tail call with a return.\n-  if (GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(Callee)) {\n-    const GlobalValue *GV = G->getGlobal();\n-    if (GV->hasExternalWeakLinkage())\n-      return false;\n-  }", "target": "-  // Externally-defined functions with weak linkage should not be\n-  // tail-called. The behaviour of branch instructions in this situation (as\n-  // used for tail calls) is implementation-defined, so we cannot rely on the\n-  // linker replacing the tail call with a return.\n-  if (GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(Callee)) {\n-    const GlobalValue *GV = G->getGlobal();\n-    if (GV->hasExternalWeakLinkage())\n-      return false;\n-  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISCV后端禁止对具有弱链接的外部定义函数进行尾调用优化，认为分支指令行为是implementation-defined，不能依赖链接器替换尾调用为返回。优化后：移除了对弱链接外部函数的尾调用限制，允许对这类函数进行尾调用优化。优化思路：参考ARM的尾调用优化实现，发现RISCV ABI没有对弱符号的限制，且GCC也支持这种优化，因此移除不必要的限制以提高代码生成性能。"}
{"id": 8, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：当函数带有minsize属性时，编译器仍会将常量除法展开为乘法序列（使用魔术常量），这会生成更大的代码。优化后：新增isIntDivCheap方法，当检测到minsize属性时，认为整数除法指令比展开序列更廉价（代码更小），从而保留除法指令。优化思路：针对代码大小优化场景，优先使用硬件除法指令而非展开序列，减少生成的指令数量。", "original_code": "当函数带有minsize属性时，编译器仍会将常量除法展开为乘法序列（使用魔术常量），这会生成更大的代码。", "optimized_code": "-    if (N->getOperand(1).getOpcode() == ISD::Constant)\n+    AttributeList Attr = DAG.getMachineFunction().getFunction().getAttributes();\n+    if (N->getOperand(1).getOpcode() == ISD::Constant &&\n+        !isIntDivCheap(N->getValueType(0), Attr))\n       return;\n\n+bool RISCVTargetLowering::isIntDivCheap(EVT VT, AttributeList Attr) const {\n+  // When aggressively optimizing for code size, we prefer to use a div\n+  // instruction, as it is usually smaller than the alternative sequence.\n+  // TODO: Add vector division?\n+  bool OptSize = Attr.hasFnAttr(Attribute::MinSize);\n+  return OptSize && !VT.isVector();\n+}", "source_url": "https://github.com/llvm/llvm-project/commit/bf4f9a468a3fe5f26c2d420949edc481527c67bd", "code_v0_no_empty_lines": "当函数带有minsize属性时，编译器仍会将常量除法展开为乘法序列（使用魔术常量），这会生成更大的代码。", "code_v1_no_empty_lines": "-    if (N->getOperand(1).getOpcode() == ISD::Constant)\n+    AttributeList Attr = DAG.getMachineFunction().getFunction().getAttributes();\n+    if (N->getOperand(1).getOpcode() == ISD::Constant &&\n+        !isIntDivCheap(N->getValueType(0), Attr))\n       return;\n\n+bool RISCVTargetLowering::isIntDivCheap(EVT VT, AttributeList Attr) const {\n+  // When aggressively optimizing for code size, we prefer to use a div\n+  // instruction, as it is usually smaller than the alternative sequence.\n+  // TODO: Add vector division?\n+  bool OptSize = Attr.hasFnAttr(Attribute::MinSize);\n+  return OptSize && !VT.isVector();\n+}", "target": "-    if (N->getOperand(1).getOpcode() == ISD::Constant)\n+    AttributeList Attr = DAG.getMachineFunction().getFunction().getAttributes();\n+    if (N->getOperand(1).getOpcode() == ISD::Constant &&\n+        !isIntDivCheap(N->getValueType(0), Attr))\n       return;\n\n+bool RISCVTargetLowering::isIntDivCheap(EVT VT, AttributeList Attr) const {\n+  // When aggressively optimizing for code size, we prefer to use a div\n+  // instruction, as it is usually smaller than the alternative sequence.\n+  // TODO: Add vector division?\n+  bool OptSize = Attr.hasFnAttr(Attribute::MinSize);\n+  return OptSize && !VT.isVector();\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当函数带有minsize属性时，编译器仍会将常量除法展开为乘法序列（使用魔术常量），这会生成更大的代码。优化后：新增isIntDivCheap方法，当检测到minsize属性时，认为整数除法指令比展开序列更廉价（代码更小），从而保留除法指令。优化思路：针对代码大小优化场景，优先使用硬件除法指令而非展开序列，减少生成的指令数量。"}
{"id": 9, "source": "riscv-dataset-excel", "optimization_type": "nan", "optimization_description": "优化前：对于i8和i16类型的溢出操作，LLVM会生成专门的溢出检测指令序列，导致代码冗余。优化后：通过重写shouldFormOverflowOp方法，禁止为i8/i16类型生成专门的溢出操作指令，让编译器使用更简单的算术和比较指令组合。优化思路：针对RISC-V架构，i8/i16的溢出检测可以通过更高效的位操作和比较指令实现，避免生成复杂的溢出指令序列，减少指令数量和寄存器压力。", "original_code": "对于i8和i16类型的溢出操作，LLVM会生成专门的溢出检测指令序列，导致代码冗余。", "optimized_code": "bool shouldFormOverflowOp(unsigned Opcode, EVT VT, bool MathUsed) const override {\n    if (VT == MVT::i8 || VT == MVT::i16)\n      return false;\n\n    return TargetLowering::shouldFormOverflowOp(Opcode, VT, MathUsed);\n  }", "source_url": "https://reviews.llvm.org/D143646", "code_v0_no_empty_lines": "对于i8和i16类型的溢出操作，LLVM会生成专门的溢出检测指令序列，导致代码冗余。", "code_v1_no_empty_lines": "bool shouldFormOverflowOp(unsigned Opcode, EVT VT, bool MathUsed) const override {\n    if (VT == MVT::i8 || VT == MVT::i16)\n      return false;\n\n    return TargetLowering::shouldFormOverflowOp(Opcode, VT, MathUsed);\n  }", "target": "bool shouldFormOverflowOp(unsigned Opcode, EVT VT, bool MathUsed) const override {\n    if (VT == MVT::i8 || VT == MVT::i16)\n      return false;\n\n    return TargetLowering::shouldFormOverflowOp(Opcode, VT, MathUsed);\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于i8和i16类型的溢出操作，LLVM会生成专门的溢出检测指令序列，导致代码冗余。优化后：通过重写shouldFormOverflowOp方法，禁止为i8/i16类型生成专门的溢出操作指令，让编译器使用更简单的算术和比较指令组合。优化思路：针对RISC-V架构，i8/i16的溢出检测可以通过更高效的位操作和比较指令实现，避免生成复杂的溢出指令序列，减少指令数量和寄存器压力。"}
{"id": 10, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化+控制流优化", "optimization_description": "优化前：对于连续的浮点SELECT指令（如Select_FPR16_Using_CC_GPR等），编译器会为每个SELECT生成独立的基本块和控制流，导致控制流图复杂，产生多个空基本块和PHI节点，增加分支开销。优化后：新增EmitLoweredCascadedSelect函数，检测到连续的SELECT指令时，将它们合并处理，生成更简化的控制流图，减少基本块数量和PHI节点，优化思路是通过合并相邻的SELECT指令来减少控制流复杂度，提高指令执行效率。", "original_code": "对于连续的浮点SELECT指令（如Select_FPR16_Using_CC_GPR等），编译器会为每个SELECT生成独立的基本块和控制流，导致控制流图复杂，产生多个空基本块和PHI节点，增加分支开销。", "optimized_code": "+static MachineBasicBlock *\n+EmitLoweredCascadedSelect(MachineInstr &First, MachineInstr &Second,\n+                          MachineBasicBlock *ThisMBB,\n+                          const RISCVSubtarget &Subtarget) {\n+  // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)\n+  // Without this, custom-inserter would have generated:\n+  //\n+  //   A\n+  //   | \\\n+  //   |  B\n+  //   | /\n+  //   C\n+  //   | \\\n+  //   |  D\n+  //   | /\n+  //   E\n+  //\n+  // If we lower both Select_FPRX_ in a single step, we can instead generate:\n+  //\n+  //   A\n+  //   | \\\n+  //   |  C\n+  //   | /|\n+  //   |/ |\n+  //   |  |\n+  //   |  D\n+  //   | /\n+  //   E\n+  // ...\n+  auto Next = next_nodbg(MI.getIterator(), BB->instr_end());\n+  if (MI.getOpcode() != RISCV::Select_GPR_Using_CC_GPR && Next != BB->end() &&\n+      Next->getOpcode() == MI.getOpcode() &&\n+      Next->getOperand(5).getReg() == MI.getOperand(0).getReg() &&\n+      Next->getOperand(5).isKill()) {\n+    return EmitLoweredCascadedSelect(MI, *Next, BB, Subtarget);\n+  }", "source_url": "https://github.com/llvm/llvm-project/commit/3f68f0f8160e4f17528669978baf1471073b90d3", "code_v0_no_empty_lines": "对于连续的浮点SELECT指令（如Select_FPR16_Using_CC_GPR等），编译器会为每个SELECT生成独立的基本块和控制流，导致控制流图复杂，产生多个空基本块和PHI节点，增加分支开销。", "code_v1_no_empty_lines": "+static MachineBasicBlock *\n+EmitLoweredCascadedSelect(MachineInstr &First, MachineInstr &Second,\n+                          MachineBasicBlock *ThisMBB,\n+                          const RISCVSubtarget &Subtarget) {\n+  // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)\n+  // Without this, custom-inserter would have generated:\n+  //\n+  //   A\n+  //   | \\\n+  //   |  B\n+  //   | /\n+  //   C\n+  //   | \\\n+  //   |  D\n+  //   | /\n+  //   E\n+  //\n+  // If we lower both Select_FPRX_ in a single step, we can instead generate:\n+  //\n+  //   A\n+  //   | \\\n+  //   |  C\n+  //   | /|\n+  //   |/ |\n+  //   |  |\n+  //   |  D\n+  //   | /\n+  //   E\n+  // ...\n+  auto Next = next_nodbg(MI.getIterator(), BB->instr_end());\n+  if (MI.getOpcode() != RISCV::Select_GPR_Using_CC_GPR && Next != BB->end() &&\n+      Next->getOpcode() == MI.getOpcode() &&\n+      Next->getOperand(5).getReg() == MI.getOperand(0).getReg() &&\n+      Next->getOperand(5).isKill()) {\n+    return EmitLoweredCascadedSelect(MI, *Next, BB, Subtarget);\n+  }", "target": "+static MachineBasicBlock *\n+EmitLoweredCascadedSelect(MachineInstr &First, MachineInstr &Second,\n+                          MachineBasicBlock *ThisMBB,\n+                          const RISCVSubtarget &Subtarget) {\n+  // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)\n+  // Without this, custom-inserter would have generated:\n+  //\n+  //   A\n+  //   | \\\n+  //   |  B\n+  //   | /\n+  //   C\n+  //   | \\\n+  //   |  D\n+  //   | /\n+  //   E\n+  //\n+  // If we lower both Select_FPRX_ in a single step, we can instead generate:\n+  //\n+  //   A\n+  //   | \\\n+  //   |  C\n+  //   | /|\n+  //   |/ |\n+  //   |  |\n+  //   |  D\n+  //   | /\n+  //   E\n+  // ...\n+  auto Next = next_nodbg(MI.getIterator(), BB->instr_end());\n+  if (MI.getOpcode() != RISCV::Select_GPR_Using_CC_GPR && Next != BB->end() &&\n+      Next->getOpcode() == MI.getOpcode() &&\n+      Next->getOperand(5).getReg() == MI.getOperand(0).getReg() &&\n+      Next->getOperand(5).isKill()) {\n+    return EmitLoweredCascadedSelect(MI, *Next, BB, Subtarget);\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于连续的浮点SELECT指令（如Select_FPR16_Using_CC_GPR等），编译器会为每个SELECT生成独立的基本块和控制流，导致控制流图复杂，产生多个空基本块和PHI节点，增加分支开销。优化后：新增EmitLoweredCascadedSelect函数，检测到连续的SELECT指令时，将它们合并处理，生成更简化的控制流图，减少基本块数量和PHI节点，优化思路是通过合并相邻的SELECT指令来减少控制流复杂度，提高指令执行效率。"}
{"id": 11, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：对于(add X, -1)操作，在没有ADDCARRY/ADDE指令的目标架构上，编译器生成低半部比较和高半部加法序列，产生额外指令开销。优化后：识别RHS为-1的特殊情况，将高半部计算从(add LHSHi, (setult Lo, LHSLo), -1)优化为(sub LHSHi, (seteq LHSLo, 0))，减少指令数量。优化思路：利用数学特性简化进位计算，当加数为-1时，进位逻辑可简化为对低半部是否为0的判断，从而生成更高效的指令序列。", "original_code": "对于(add X, -1)操作，在没有ADDCARRY/ADDE指令的目标架构上，编译器生成低半部比较和高半部加法序列，产生额外指令开销。", "optimized_code": "if (isOneConstant(LoOps[1]))\n      Cmp = DAG.getSetCC(dl, getSetCCResultType(NVT), Lo,\n                         DAG.getConstant(0, dl, NVT), ISD::SETEQ);\n-    else\n+    else if (isAllOnesConstant(LoOps[1])) {\n+      if (isAllOnesConstant(HiOps[1]))\n+        Cmp = DAG.getSetCC(dl, getSetCCResultType(NVT), LoOps[0],\n+                           DAG.getConstant(0, dl, NVT), ISD::SETEQ);\n+      else\n+        Cmp = DAG.getSetCC(dl, getSetCCResultType(NVT), LoOps[0],\n+                           DAG.getConstant(0, dl, NVT), ISD::SETNE);\n+    } else\n       Cmp = DAG.getSetCC(dl, getSetCCResultType(NVT), Lo, LoOps[0],\n                          ISD::SETULT);\n \n@@ -3037,7 +3044,10 @@ void DAGTypeLegalizer::ExpandIntRes_ADDSUB(SDNode *N,\n       Carry = DAG.getSelect(dl, NVT, Cmp, DAG.getConstant(1, dl, NVT),\n                              DAG.getConstant(0, dl, NVT));\n \n-    Hi = DAG.getNode(ISD::ADD, dl, NVT, Hi, Carry);\n+    if (isAllOnesConstant(LoOps[1]) && isAllOnesConstant(HiOps[1]))\n+      Hi = DAG.getNode(ISD::SUB, dl, NVT, HiOps[0], Carry);\n+    else\n+      Hi = DAG.getNode(ISD::ADD, dl, NVT, Hi, Carry);", "source_url": "https://github.com/llvm/llvm-project/commit/24847a90aaf5842041a2cfa977a4167997307b50", "code_v0_no_empty_lines": "对于(add X, -1)操作，在没有ADDCARRY/ADDE指令的目标架构上，编译器生成低半部比较和高半部加法序列，产生额外指令开销。", "code_v1_no_empty_lines": "if (isOneConstant(LoOps[1]))\n      Cmp = DAG.getSetCC(dl, getSetCCResultType(NVT), Lo,\n                         DAG.getConstant(0, dl, NVT), ISD::SETEQ);\n-    else\n+    else if (isAllOnesConstant(LoOps[1])) {\n+      if (isAllOnesConstant(HiOps[1]))\n+        Cmp = DAG.getSetCC(dl, getSetCCResultType(NVT), LoOps[0],\n+                           DAG.getConstant(0, dl, NVT), ISD::SETEQ);\n+      else\n+        Cmp = DAG.getSetCC(dl, getSetCCResultType(NVT), LoOps[0],\n+                           DAG.getConstant(0, dl, NVT), ISD::SETNE);\n+    } else\n       Cmp = DAG.getSetCC(dl, getSetCCResultType(NVT), Lo, LoOps[0],\n                          ISD::SETULT);\n \n@@ -3037,7 +3044,10 @@ void DAGTypeLegalizer::ExpandIntRes_ADDSUB(SDNode *N,\n       Carry = DAG.getSelect(dl, NVT, Cmp, DAG.getConstant(1, dl, NVT),\n                              DAG.getConstant(0, dl, NVT));\n \n-    Hi = DAG.getNode(ISD::ADD, dl, NVT, Hi, Carry);\n+    if (isAllOnesConstant(LoOps[1]) && isAllOnesConstant(HiOps[1]))\n+      Hi = DAG.getNode(ISD::SUB, dl, NVT, HiOps[0], Carry);\n+    else\n+      Hi = DAG.getNode(ISD::ADD, dl, NVT, Hi, Carry);", "target": "if (isOneConstant(LoOps[1]))\n      Cmp = DAG.getSetCC(dl, getSetCCResultType(NVT), Lo,\n                         DAG.getConstant(0, dl, NVT), ISD::SETEQ);\n-    else\n+    else if (isAllOnesConstant(LoOps[1])) {\n+      if (isAllOnesConstant(HiOps[1]))\n+        Cmp = DAG.getSetCC(dl, getSetCCResultType(NVT), LoOps[0],\n+                           DAG.getConstant(0, dl, NVT), ISD::SETEQ);\n+      else\n+        Cmp = DAG.getSetCC(dl, getSetCCResultType(NVT), LoOps[0],\n+                           DAG.getConstant(0, dl, NVT), ISD::SETNE);\n+    } else\n       Cmp = DAG.getSetCC(dl, getSetCCResultType(NVT), Lo, LoOps[0],\n                          ISD::SETULT);\n \n@@ -3037,7 +3044,10 @@ void DAGTypeLegalizer::ExpandIntRes_ADDSUB(SDNode *N,\n       Carry = DAG.getSelect(dl, NVT, Cmp, DAG.getConstant(1, dl, NVT),\n                              DAG.getConstant(0, dl, NVT));\n \n-    Hi = DAG.getNode(ISD::ADD, dl, NVT, Hi, Carry);\n+    if (isAllOnesConstant(LoOps[1]) && isAllOnesConstant(HiOps[1]))\n+      Hi = DAG.getNode(ISD::SUB, dl, NVT, HiOps[0], Carry);\n+    else\n+      Hi = DAG.getNode(ISD::ADD, dl, NVT, Hi, Carry);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于(add X, -1)操作，在没有ADDCARRY/ADDE指令的目标架构上，编译器生成低半部比较和高半部加法序列，产生额外指令开销。优化后：识别RHS为-1的特殊情况，将高半部计算从(add LHSHi, (setult Lo, LHSLo), -1)优化为(sub LHSHi, (seteq LHSLo, 0))，减少指令数量。优化思路：利用数学特性简化进位计算，当加数为-1时，进位逻辑可简化为对低半部是否为0的判断，从而生成更高效的指令序列。"}
{"id": 12, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+编译器优化", "optimization_description": "将仅支持标准Zbs拓展的位测试指令BEXTI，拓展支持平头哥定制指令集XTHeadBs，优化嵌入式系统或低功耗处理器中的位级操作效率", "original_code": "// No original code extracted from description\n", "optimized_code": "- // If C2 is (1 << ShAmt) use bexti if possible.\n- if (Subtarget->hasStdExtZbs() && ShAmt + 1 == TrailingOnes) {\n+ // If C2 is (1 << ShAmt) use bexti or th.tst if possible.\n+ bool HasBitTest = Subtarget->hasStdExtZbs() || Subtarget->hasVendorXTHeadBs();\n+ if (HasBitTest && ShAmt + 1 == TrailingOnes) {\n+   SDNode *BEXTI = CurDAG->getMachineNode(\n+     Subtarget->hasStdExtZbs() ? RISCV::BEXTI : RISCV::TH_TST, DL, VT,\n+     N0->getOperand(0), CurDAG->getTargetConstant(ShAmt, DL, VT));\n\n- if (!Subtarget.hasStdExtZbs())\n+ if (!Subtarget.hasStdExtZbs() && !Subtarget.hasVendorXTHeadBs())\n   return false;", "source_url": "https://github.com/llvm/llvm-project/commit/656188ddc4075eb50260607b3497589873f373d2", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- // If C2 is (1 << ShAmt) use bexti if possible.\n- if (Subtarget->hasStdExtZbs() && ShAmt + 1 == TrailingOnes) {\n+ // If C2 is (1 << ShAmt) use bexti or th.tst if possible.\n+ bool HasBitTest = Subtarget->hasStdExtZbs() || Subtarget->hasVendorXTHeadBs();\n+ if (HasBitTest && ShAmt + 1 == TrailingOnes) {\n+   SDNode *BEXTI = CurDAG->getMachineNode(\n+     Subtarget->hasStdExtZbs() ? RISCV::BEXTI : RISCV::TH_TST, DL, VT,\n+     N0->getOperand(0), CurDAG->getTargetConstant(ShAmt, DL, VT));\n\n- if (!Subtarget.hasStdExtZbs())\n+ if (!Subtarget.hasStdExtZbs() && !Subtarget.hasVendorXTHeadBs())\n   return false;", "target": "- // If C2 is (1 << ShAmt) use bexti if possible.\n- if (Subtarget->hasStdExtZbs() && ShAmt + 1 == TrailingOnes) {\n+ // If C2 is (1 << ShAmt) use bexti or th.tst if possible.\n+ bool HasBitTest = Subtarget->hasStdExtZbs() || Subtarget->hasVendorXTHeadBs();\n+ if (HasBitTest && ShAmt + 1 == TrailingOnes) {\n+   SDNode *BEXTI = CurDAG->getMachineNode(\n+     Subtarget->hasStdExtZbs() ? RISCV::BEXTI : RISCV::TH_TST, DL, VT,\n+     N0->getOperand(0), CurDAG->getTargetConstant(ShAmt, DL, VT));\n\n- if (!Subtarget.hasStdExtZbs())\n+ if (!Subtarget.hasStdExtZbs() && !Subtarget.hasVendorXTHeadBs())\n   return false;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "将仅支持标准Zbs拓展的位测试指令BEXTI，拓展支持平头哥定制指令集XTHeadBs，优化嵌入式系统或低功耗处理器中的位级操作效率"}
{"id": 13, "source": "riscv-dataset-excel", "optimization_type": "指令集扩展+代码生成优化", "optimization_description": "优化前：RISCV架构加载浮点立即数需要通过内存加载指令从常量池加载，产生额外的内存访问开销。优化后：为实验性Zfa扩展添加FLI指令的代码生成模式，支持fli.s/fli.d/fli.h指令直接加载特定浮点立即数。优化思路：通过添加SDNodeXForm转换和指令模式匹配，当检测到支持的浮点立即数值时，直接生成单条FLI指令替代内存加载序列，减少指令数量和内存访问，提高浮点常量加载性能。", "original_code": "RISCV架构加载浮点立即数需要通过内存加载指令从常量池加载，产生额外的内存访问开销。", "optimized_code": "def : Pat<(f32 fpimm:$imm), (FLI_S (fp32imm_to_loadfpimm fpimm:$imm))>;\ndef : Pat<(f64 fpimm:$imm), (FLI_D (fp64imm_to_loadfpimm fpimm:$imm))>;\ndef : Pat<(f16 fpimm:$imm), (FLI_H (fp16imm_to_loadfpimm fpimm:$imm))>;", "source_url": "https://github.com/llvm/llvm-project/commit/ada2641460672ed888df9e2791d3d4635f06e2ae", "code_v0_no_empty_lines": "RISCV架构加载浮点立即数需要通过内存加载指令从常量池加载，产生额外的内存访问开销。", "code_v1_no_empty_lines": "def : Pat<(f32 fpimm:$imm), (FLI_S (fp32imm_to_loadfpimm fpimm:$imm))>;\ndef : Pat<(f64 fpimm:$imm), (FLI_D (fp64imm_to_loadfpimm fpimm:$imm))>;\ndef : Pat<(f16 fpimm:$imm), (FLI_H (fp16imm_to_loadfpimm fpimm:$imm))>;", "target": "def : Pat<(f32 fpimm:$imm), (FLI_S (fp32imm_to_loadfpimm fpimm:$imm))>;\ndef : Pat<(f64 fpimm:$imm), (FLI_D (fp64imm_to_loadfpimm fpimm:$imm))>;\ndef : Pat<(f16 fpimm:$imm), (FLI_H (fp16imm_to_loadfpimm fpimm:$imm))>;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISCV架构加载浮点立即数需要通过内存加载指令从常量池加载，产生额外的内存访问开销。优化后：为实验性Zfa扩展添加FLI指令的代码生成模式，支持fli.s/fli.d/fli.h指令直接加载特定浮点立即数。优化思路：通过添加SDNodeXForm转换和指令模式匹配，当检测到支持的浮点立即数值时，直接生成单条FLI指令替代内存加载序列，减少指令数量和内存访问，提高浮点常量加载性能。"}
{"id": 14, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化+窥孔优化", "optimization_description": "优化前：当遇到未掩码的TU（Tail Undisturbed）vmerge指令与掩码的MU（Mask Undisturbed）TA（Tail Agnostic）操作组合时，无法进行合并优化，导致生成冗余的vmerge指令。优化后：扩展performCombineVMergeAndVOps函数，支持将未掩码的TU vmerge指令与掩码的MU TA操作合并为一个掩码的TU操作，前提是它们使用相同的合并值。优化思路：通过检查操作数匹配条件（相同合并操作数、vmerge使用全1掩码），在指令选择阶段消除冗余的vmerge指令，减少生成的指令数量，提高RISC-V向量代码性能。", "original_code": "当遇到未掩码的TU（Tail Undisturbed）vmerge指令与掩码的MU（Mask Undisturbed）TA（Tail Agnostic）操作组合时，无法进行合并优化，导致生成冗余的vmerge指令。", "optimized_code": "bool HasMergeOp = RISCVII::hasMergeOp(TrueTSFlags);\n\nif (HasMergeOp) {\n  // The vmerge instruction must be TU.\n  if (IsTA)\n    return false;\n  SDValue MergeOpN = N->getOperand(0);\n  SDValue MergeOpTrue = True->getOperand(0);\n  // Both the vmerge instruction and the True instruction must have the same\n  // merge operand. The vmerge instruction must have an all 1s mask since\n  // we're going to keep the mask from the True instruction.\n  // FIXME: Support mask agnostic True instruction which would have an\n  // undef merge operand.\n  if (MergeOpN != MergeOpTrue || !usesAllOnesMask(N, /* MaskOpIdx */ 3))\n    return false;\n}", "source_url": "https://github.com/llvm/llvm-project/commit/8fa1e5e673f9b13ec3d060975c01b07e827f16dc", "code_v0_no_empty_lines": "当遇到未掩码的TU（Tail Undisturbed）vmerge指令与掩码的MU（Mask Undisturbed）TA（Tail Agnostic）操作组合时，无法进行合并优化，导致生成冗余的vmerge指令。", "code_v1_no_empty_lines": "bool HasMergeOp = RISCVII::hasMergeOp(TrueTSFlags);\n\nif (HasMergeOp) {\n  // The vmerge instruction must be TU.\n  if (IsTA)\n    return false;\n  SDValue MergeOpN = N->getOperand(0);\n  SDValue MergeOpTrue = True->getOperand(0);\n  // Both the vmerge instruction and the True instruction must have the same\n  // merge operand. The vmerge instruction must have an all 1s mask since\n  // we're going to keep the mask from the True instruction.\n  // FIXME: Support mask agnostic True instruction which would have an\n  // undef merge operand.\n  if (MergeOpN != MergeOpTrue || !usesAllOnesMask(N, /* MaskOpIdx */ 3))\n    return false;\n}", "target": "bool HasMergeOp = RISCVII::hasMergeOp(TrueTSFlags);\n\nif (HasMergeOp) {\n  // The vmerge instruction must be TU.\n  if (IsTA)\n    return false;\n  SDValue MergeOpN = N->getOperand(0);\n  SDValue MergeOpTrue = True->getOperand(0);\n  // Both the vmerge instruction and the True instruction must have the same\n  // merge operand. The vmerge instruction must have an all 1s mask since\n  // we're going to keep the mask from the True instruction.\n  // FIXME: Support mask agnostic True instruction which would have an\n  // undef merge operand.\n  if (MergeOpN != MergeOpTrue || !usesAllOnesMask(N, /* MaskOpIdx */ 3))\n    return false;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当遇到未掩码的TU（Tail Undisturbed）vmerge指令与掩码的MU（Mask Undisturbed）TA（Tail Agnostic）操作组合时，无法进行合并优化，导致生成冗余的vmerge指令。优化后：扩展performCombineVMergeAndVOps函数，支持将未掩码的TU vmerge指令与掩码的MU TA操作合并为一个掩码的TU操作，前提是它们使用相同的合并值。优化思路：通过检查操作数匹配条件（相同合并操作数、vmerge使用全1掩码），在指令选择阶段消除冗余的vmerge指令，减少生成的指令数量，提高RISC-V向量代码性能。"}
{"id": 15, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化+模式匹配优化", "optimization_description": "优化前：XVentanaCondOps指令需要大量重复的模式匹配规则来处理seteq/setne操作，每个条件比较都需要单独的匹配模式，导致模式表膨胀和编译时间增加。优化后：引入ComplexPattern机制，通过selectCondOp函数统一处理条件操作数比较零值的各种情况，包括直接比较零值、比较特定常数（如-2048）和比较范围内的常数。优化思路：利用RISC-V没有seteq/setne指令的特性，通过xor/xori/addi等指令生成零值比较结果，避免后续的seqz/snez指令，同时通过ComplexPattern减少模式数量，提高指令选择效率并支持未来扩展。", "original_code": "XVentanaCondOps指令需要大量重复的模式匹配规则来处理seteq/setne操作，每个条件比较都需要单独的匹配模式，导致模式表膨胀和编译时间增加。", "optimized_code": "diff --git a/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp b/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp\n@@ -2423,6 +2423,72 @@ bool RISCVDAGToDAGISel::selectShiftMask(SDValue N, unsigned ShiftWidth,\n   return true;\n }\n \n+/// Some instructions have a condition operand that is compared against zero.\n+/// Since RISC-V doesn't have seteq/setne instructions, we can use this\n+/// property to avoid a seqz or snez instruction after an xor/addi/xori.\n+/// When \\p Inverse is false, we match seteq or any unknown operation. When\n+/// \\p Inverse is true, we only match setne.\n+bool RISCVDAGToDAGISel::selectCondOp(SDValue N, bool Inverse, SDValue &Val) {\n+  // Start with this node as the output.\n+  Val = N;\n+\n+  // If the node isn't a setcc, there's nothing we can do. Return success\n+  // if we aren't looking for an inverse condition.\n+  if (N->getOpcode() != ISD::SETCC)\n+    return !Inverse;\n+\n+  // If it isn't an equality comparison, we also can't do anything.\n+  ISD::CondCode CCVal = cast<CondCodeSDNode>(N->getOperand(2))->get();\n+  if (!isIntEqualitySetCC(CCVal))\n+    return !Inverse;\n+\n+  // This ComplexPattern occurs in pairs with both polarities of Inverse.\n+  // If this isn't the one we're looking for, let the other polarity match it.\n+  if (isTrueWhenEqual(CCVal) != Inverse)\n+    return false;\n+\n+  SDValue LHS = N->getOperand(0);\n+  SDValue RHS = N->getOperand(1);\n+\n+  // If the RHS side is 0, we don't need any extra instructions, return the LHS.\n+  if (isNullConstant(RHS)) {\n+    Val = LHS;\n+    return true;\n+  }\n+\n+  SDLoc DL(N);\n+\n+  if (auto *C = dyn_cast<ConstantSDNode>(RHS)) {\n+    int64_t CVal = C->getSExtValue();\n+    // If the RHS is -2048, we can use xori to produce 0 if the LHS is -2048 and\n+    // non-zero otherwise.\n+    if (CVal == -2048) {\n+      Val =\n+          SDValue(CurDAG->getMachineNode(\n+                      RISCV::XORI, DL, N->getValueType(0), LHS,\n+                      CurDAG->getTargetConstant(CVal, DL, N->getValueType(0))),\n+                  0);\n+      return true;\n+    }\n+    // If the RHS is [-2047,2048], we can use addi with -RHS to produce 0 if the\n+    // LHS is equal to the RHS and non-zero otherwise.\n+    if (isInt<12>(CVal) || CVal == 2048) {\n+      Val =\n+          SDValue(CurDAG->getMachineNode(\n+                      RISCV::ADDI, DL, N->getValueType(0), LHS,\n+                      CurDAG->getTargetConstant(-CVal, DL, N->getValueType(0))),\n+                  0);\n+      return true;\n+    }\n+  }\n+\n+  // If nothing else we can XOR the LHS and RHS to produce zero if they are\n+  // equal and a non-zero value if they aren't.\n+  Val = SDValue(\n+      CurDAG->getMachineNode(RISCV::XOR, DL, N->getValueType(0), LHS, RHS), 0);\n+  return true;\n+}", "source_url": "https://github.com/llvm/llvm-project/commit/3caa427f8ecbf9f5845c15b53e1021db94b3db03", "code_v0_no_empty_lines": "XVentanaCondOps指令需要大量重复的模式匹配规则来处理seteq/setne操作，每个条件比较都需要单独的匹配模式，导致模式表膨胀和编译时间增加。", "code_v1_no_empty_lines": "diff --git a/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp b/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp\n@@ -2423,6 +2423,72 @@ bool RISCVDAGToDAGISel::selectShiftMask(SDValue N, unsigned ShiftWidth,\n   return true;\n }\n \n+/// Some instructions have a condition operand that is compared against zero.\n+/// Since RISC-V doesn't have seteq/setne instructions, we can use this\n+/// property to avoid a seqz or snez instruction after an xor/addi/xori.\n+/// When \\p Inverse is false, we match seteq or any unknown operation. When\n+/// \\p Inverse is true, we only match setne.\n+bool RISCVDAGToDAGISel::selectCondOp(SDValue N, bool Inverse, SDValue &Val) {\n+  // Start with this node as the output.\n+  Val = N;\n+\n+  // If the node isn't a setcc, there's nothing we can do. Return success\n+  // if we aren't looking for an inverse condition.\n+  if (N->getOpcode() != ISD::SETCC)\n+    return !Inverse;\n+\n+  // If it isn't an equality comparison, we also can't do anything.\n+  ISD::CondCode CCVal = cast<CondCodeSDNode>(N->getOperand(2))->get();\n+  if (!isIntEqualitySetCC(CCVal))\n+    return !Inverse;\n+\n+  // This ComplexPattern occurs in pairs with both polarities of Inverse.\n+  // If this isn't the one we're looking for, let the other polarity match it.\n+  if (isTrueWhenEqual(CCVal) != Inverse)\n+    return false;\n+\n+  SDValue LHS = N->getOperand(0);\n+  SDValue RHS = N->getOperand(1);\n+\n+  // If the RHS side is 0, we don't need any extra instructions, return the LHS.\n+  if (isNullConstant(RHS)) {\n+    Val = LHS;\n+    return true;\n+  }\n+\n+  SDLoc DL(N);\n+\n+  if (auto *C = dyn_cast<ConstantSDNode>(RHS)) {\n+    int64_t CVal = C->getSExtValue();\n+    // If the RHS is -2048, we can use xori to produce 0 if the LHS is -2048 and\n+    // non-zero otherwise.\n+    if (CVal == -2048) {\n+      Val =\n+          SDValue(CurDAG->getMachineNode(\n+                      RISCV::XORI, DL, N->getValueType(0), LHS,\n+                      CurDAG->getTargetConstant(CVal, DL, N->getValueType(0))),\n+                  0);\n+      return true;\n+    }\n+    // If the RHS is [-2047,2048], we can use addi with -RHS to produce 0 if the\n+    // LHS is equal to the RHS and non-zero otherwise.\n+    if (isInt<12>(CVal) || CVal == 2048) {\n+      Val =\n+          SDValue(CurDAG->getMachineNode(\n+                      RISCV::ADDI, DL, N->getValueType(0), LHS,\n+                      CurDAG->getTargetConstant(-CVal, DL, N->getValueType(0))),\n+                  0);\n+      return true;\n+    }\n+  }\n+\n+  // If nothing else we can XOR the LHS and RHS to produce zero if they are\n+  // equal and a non-zero value if they aren't.\n+  Val = SDValue(\n+      CurDAG->getMachineNode(RISCV::XOR, DL, N->getValueType(0), LHS, RHS), 0);\n+  return true;\n+}", "target": "diff --git a/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp b/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp\n@@ -2423,6 +2423,72 @@ bool RISCVDAGToDAGISel::selectShiftMask(SDValue N, unsigned ShiftWidth,\n   return true;\n }\n \n+/// Some instructions have a condition operand that is compared against zero.\n+/// Since RISC-V doesn't have seteq/setne instructions, we can use this\n+/// property to avoid a seqz or snez instruction after an xor/addi/xori.\n+/// When \\p Inverse is false, we match seteq or any unknown operation. When\n+/// \\p Inverse is true, we only match setne.\n+bool RISCVDAGToDAGISel::selectCondOp(SDValue N, bool Inverse, SDValue &Val) {\n+  // Start with this node as the output.\n+  Val = N;\n+\n+  // If the node isn't a setcc, there's nothing we can do. Return success\n+  // if we aren't looking for an inverse condition.\n+  if (N->getOpcode() != ISD::SETCC)\n+    return !Inverse;\n+\n+  // If it isn't an equality comparison, we also can't do anything.\n+  ISD::CondCode CCVal = cast<CondCodeSDNode>(N->getOperand(2))->get();\n+  if (!isIntEqualitySetCC(CCVal))\n+    return !Inverse;\n+\n+  // This ComplexPattern occurs in pairs with both polarities of Inverse.\n+  // If this isn't the one we're looking for, let the other polarity match it.\n+  if (isTrueWhenEqual(CCVal) != Inverse)\n+    return false;\n+\n+  SDValue LHS = N->getOperand(0);\n+  SDValue RHS = N->getOperand(1);\n+\n+  // If the RHS side is 0, we don't need any extra instructions, return the LHS.\n+  if (isNullConstant(RHS)) {\n+    Val = LHS;\n+    return true;\n+  }\n+\n+  SDLoc DL(N);\n+\n+  if (auto *C = dyn_cast<ConstantSDNode>(RHS)) {\n+    int64_t CVal = C->getSExtValue();\n+    // If the RHS is -2048, we can use xori to produce 0 if the LHS is -2048 and\n+    // non-zero otherwise.\n+    if (CVal == -2048) {\n+      Val =\n+          SDValue(CurDAG->getMachineNode(\n+                      RISCV::XORI, DL, N->getValueType(0), LHS,\n+                      CurDAG->getTargetConstant(CVal, DL, N->getValueType(0))),\n+                  0);\n+      return true;\n+    }\n+    // If the RHS is [-2047,2048], we can use addi with -RHS to produce 0 if the\n+    // LHS is equal to the RHS and non-zero otherwise.\n+    if (isInt<12>(CVal) || CVal == 2048) {\n+      Val =\n+          SDValue(CurDAG->getMachineNode(\n+                      RISCV::ADDI, DL, N->getValueType(0), LHS,\n+                      CurDAG->getTargetConstant(-CVal, DL, N->getValueType(0))),\n+                  0);\n+      return true;\n+    }\n+  }\n+\n+  // If nothing else we can XOR the LHS and RHS to produce zero if they are\n+  // equal and a non-zero value if they aren't.\n+  Val = SDValue(\n+      CurDAG->getMachineNode(RISCV::XOR, DL, N->getValueType(0), LHS, RHS), 0);\n+  return true;\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：XVentanaCondOps指令需要大量重复的模式匹配规则来处理seteq/setne操作，每个条件比较都需要单独的匹配模式，导致模式表膨胀和编译时间增加。优化后：引入ComplexPattern机制，通过selectCondOp函数统一处理条件操作数比较零值的各种情况，包括直接比较零值、比较特定常数（如-2048）和比较范围内的常数。优化思路：利用RISC-V没有seteq/setne指令的特性，通过xor/xori/addi等指令生成零值比较结果，避免后续的seqz/snez指令，同时通过ComplexPattern减少模式数量，提高指令选择效率并支持未来扩展。"}
{"id": 16, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：当VMERGE_VVM_TU指令的掩码为全1时，编译器将其转换为VADD_VI_TU指令（加0操作）。优化后：改为转换为VMV_V_V_TU指令（向量移动操作）。优化思路：VMV_V_V_TU是更直接的向量移动指令，相比VADD_VI_TU（需要处理立即数0）更高效，减少了不必要的算术操作开销，提高了代码生成质量。", "original_code": "当VMERGE_VVM_TU指令的掩码为全1时，编译器将其转换为VADD_VI_TU指令（加0操作）。", "optimized_code": "-  case RISCV::PseudoVMERGE_VVM_MF8_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_MF8_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_MF4_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_MF4_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_MF2_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_MF2_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_M1_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_M1_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_M2_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_M2_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_M4_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_M4_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_M8_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_M8_TU;\n-    break;\n+  CASE_VMERGE_TO_VMV(MF8)\n+  CASE_VMERGE_TO_VMV(MF4)\n+  CASE_VMERGE_TO_VMV(MF2)\n+  CASE_VMERGE_TO_VMV(M1)\n+  CASE_VMERGE_TO_VMV(M2)\n+  CASE_VMERGE_TO_VMV(M4)\n+  CASE_VMERGE_TO_VMV(M8)", "source_url": "https://github.com/llvm/llvm-project/commit/c5fdab30143aeb45fc4bfebc9fcd551127e0c569", "code_v0_no_empty_lines": "当VMERGE_VVM_TU指令的掩码为全1时，编译器将其转换为VADD_VI_TU指令（加0操作）。", "code_v1_no_empty_lines": "-  case RISCV::PseudoVMERGE_VVM_MF8_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_MF8_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_MF4_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_MF4_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_MF2_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_MF2_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_M1_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_M1_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_M2_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_M2_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_M4_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_M4_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_M8_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_M8_TU;\n-    break;\n+  CASE_VMERGE_TO_VMV(MF8)\n+  CASE_VMERGE_TO_VMV(MF4)\n+  CASE_VMERGE_TO_VMV(MF2)\n+  CASE_VMERGE_TO_VMV(M1)\n+  CASE_VMERGE_TO_VMV(M2)\n+  CASE_VMERGE_TO_VMV(M4)\n+  CASE_VMERGE_TO_VMV(M8)", "target": "-  case RISCV::PseudoVMERGE_VVM_MF8_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_MF8_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_MF4_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_MF4_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_MF2_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_MF2_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_M1_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_M1_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_M2_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_M2_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_M4_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_M4_TU;\n-    break;\n-  case RISCV::PseudoVMERGE_VVM_M8_TU:\n-    NewOpc = RISCV::PseudoVADD_VI_M8_TU;\n-    break;\n+  CASE_VMERGE_TO_VMV(MF8)\n+  CASE_VMERGE_TO_VMV(MF4)\n+  CASE_VMERGE_TO_VMV(MF2)\n+  CASE_VMERGE_TO_VMV(M1)\n+  CASE_VMERGE_TO_VMV(M2)\n+  CASE_VMERGE_TO_VMV(M4)\n+  CASE_VMERGE_TO_VMV(M8)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当VMERGE_VVM_TU指令的掩码为全1时，编译器将其转换为VADD_VI_TU指令（加0操作）。优化后：改为转换为VMV_V_V_TU指令（向量移动操作）。优化思路：VMV_V_V_TU是更直接的向量移动指令，相比VADD_VI_TU（需要处理立即数0）更高效，减少了不必要的算术操作开销，提高了代码生成质量。"}
{"id": 17, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：编译器无法为 XAndesPerf 扩展生成特定的分支立即指令，导致代码生成效率较低。优化后：添加了针对 XAndesPerf 分支指令的指令选择模式，使编译器能够识别并生成 NDS_BBC、NDS_BBS、NDS_BEQC、NDS_BNEC 等优化指令。优化思路：通过扩展指令选择器模式匹配规则，让编译器在遇到特定条件分支模式时，能够选择更高效的 XAndesPerf 专用指令，减少指令数量和提升分支性能。", "original_code": "编译器无法为 XAndesPerf 扩展生成特定的分支立即指令，导致代码生成效率较低。", "optimized_code": "1. RISCVISelLowering.cpp 中 translateSetCCForBranch 函数添加 XAndesPerf 支持检查\n   - 在条件判断中添加 `!Subtarget.hasVendorXAndesPerf()`\n2. RISCVInstrInfo.cpp 中添加 NDS 分支指令支持\n   - 新增 NDS_BBC、NDS_BBS、NDS_BEQC、NDS_BNEC 指令的条件码映射\n3. RISCVInstrInfoXAndes.td 中添加指令选择模式\n   - 新增 NDS_BBPat 和 NDS_BCPat 模式匹配规则", "source_url": "https://github.com/llvm/llvm-project/commit/283f53ac6fcde5a6f8182e572a3f6f828b89a9a8", "code_v0_no_empty_lines": "编译器无法为 XAndesPerf 扩展生成特定的分支立即指令，导致代码生成效率较低。", "code_v1_no_empty_lines": "1. RISCVISelLowering.cpp 中 translateSetCCForBranch 函数添加 XAndesPerf 支持检查\n   - 在条件判断中添加 `!Subtarget.hasVendorXAndesPerf()`\n2. RISCVInstrInfo.cpp 中添加 NDS 分支指令支持\n   - 新增 NDS_BBC、NDS_BBS、NDS_BEQC、NDS_BNEC 指令的条件码映射\n3. RISCVInstrInfoXAndes.td 中添加指令选择模式\n   - 新增 NDS_BBPat 和 NDS_BCPat 模式匹配规则", "target": "1. RISCVISelLowering.cpp 中 translateSetCCForBranch 函数添加 XAndesPerf 支持检查\n   - 在条件判断中添加 `!Subtarget.hasVendorXAndesPerf()`\n2. RISCVInstrInfo.cpp 中添加 NDS 分支指令支持\n   - 新增 NDS_BBC、NDS_BBS、NDS_BEQC、NDS_BNEC 指令的条件码映射\n3. RISCVInstrInfoXAndes.td 中添加指令选择模式\n   - 新增 NDS_BBPat 和 NDS_BCPat 模式匹配规则", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：编译器无法为 XAndesPerf 扩展生成特定的分支立即指令，导致代码生成效率较低。优化后：添加了针对 XAndesPerf 分支指令的指令选择模式，使编译器能够识别并生成 NDS_BBC、NDS_BBS、NDS_BEQC、NDS_BNEC 等优化指令。优化思路：通过扩展指令选择器模式匹配规则，让编译器在遇到特定条件分支模式时，能够选择更高效的 XAndesPerf 专用指令，减少指令数量和提升分支性能。"}
{"id": 18, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：对于形如 (select cond, u, rot[r/l](u, rot.amt)) 或 (select cond, rot[r/l](u, rot.amt), u) 的模式，编译器需要生成条件选择指令和旋转指令的组合，导致指令数较多。优化后：通过扩展 tryFoldSelectIntoOp 函数，识别旋转操作（ROTL/ROTR）与选择操作的组合模式，将其转换为 (rot[r/l] u, (czero_nez/eqz rot.amt, cond)) 的形式，利用 RISC-V 的 zicond 扩展指令（条件零指令）直接生成更高效的代码。优化思路：利用目标架构的特殊指令集（zicond）来优化特定模式，减少指令数量和依赖关系，提高代码生成效率。", "original_code": "对于形如 (select cond, u, rot[r/l](u, rot.amt)) 或 (select cond, rot[r/l](u, rot.amt), u) 的模式，编译器需要生成条件选择指令和旋转指令的组合，导致指令数较多。", "optimized_code": "// (select C, (rotl Y, X), Y) -> (rotl Y, (select C, X, 0)).\n// (select C, (rotr Y, X), Y) -> (rotr Y, (select C, X, 0)).\n...\n  case ISD::ROTL:\n  case ISD::ROTR:\n    Commutative = false;\n    break;", "source_url": "https://github.com/llvm/llvm-project/commit/be762b7b7d60f47ab75e81942c8899331d89f141", "code_v0_no_empty_lines": "对于形如 (select cond, u, rot[r/l](u, rot.amt)) 或 (select cond, rot[r/l](u, rot.amt), u) 的模式，编译器需要生成条件选择指令和旋转指令的组合，导致指令数较多。", "code_v1_no_empty_lines": "// (select C, (rotl Y, X), Y) -> (rotl Y, (select C, X, 0)).\n// (select C, (rotr Y, X), Y) -> (rotr Y, (select C, X, 0)).\n...\n  case ISD::ROTL:\n  case ISD::ROTR:\n    Commutative = false;\n    break;", "target": "// (select C, (rotl Y, X), Y) -> (rotl Y, (select C, X, 0)).\n// (select C, (rotr Y, X), Y) -> (rotr Y, (select C, X, 0)).\n...\n  case ISD::ROTL:\n  case ISD::ROTR:\n    Commutative = false;\n    break;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于形如 (select cond, u, rot[r/l](u, rot.amt)) 或 (select cond, rot[r/l](u, rot.amt), u) 的模式，编译器需要生成条件选择指令和旋转指令的组合，导致指令数较多。优化后：通过扩展 tryFoldSelectIntoOp 函数，识别旋转操作（ROTL/ROTR）与选择操作的组合模式，将其转换为 (rot[r/l] u, (czero_nez/eqz rot.amt, cond)) 的形式，利用 RISC-V 的 zicond 扩展指令（条件零指令）直接生成更高效的代码。优化思路：利用目标架构的特殊指令集（zicond）来优化特定模式，减少指令数量和依赖关系，提高代码生成效率。"}
{"id": 19, "source": "riscv-dataset-excel", "optimization_type": "向量指令优化+微架构调优", "optimization_description": "优化前：在向量循环中，vector_splice操作被拆分为vslidedown和vslideup指令对，但vslidedown使用较小的AVL（UpOffset），而vslideup使用VLMAX或EVL，导致循环内产生额外的vl切换开销。优化后：通过增加vslidedown的AVL使其与vslideup匹配（即使额外元素会被覆盖），消除了vl切换。同时新增+vl-dependent-latency调优特性，允许在vl相关延迟的微架构（如sifive-x280）上保持旧行为。优化思路：减少动态vl切换以提升向量循环性能，同时提供微架构感知的调优选项。", "original_code": "在向量循环中，vector_splice操作被拆分为vslidedown和vslideup指令对，但vslidedown使用较小的AVL（UpOffset），而vslideup使用VLMAX或EVL，导致循环内产生额外的vl切换开销。", "optimized_code": "-  SDValue SlideDown = getVSlidedown(DAG, Subtarget, DL, VecVT, DAG.getUNDEF(VecVT), V1, DownOffset, TrueMask, UpOffset);\n+  SDValue SlideDown = getVSlidedown(DAG, Subtarget, DL, VecVT, DAG.getUNDEF(VecVT), V1, DownOffset, TrueMask, Subtarget.hasVLDependentLatency() ? UpOffset : DAG.getRegister(RISCV::X0, XLenVT));", "source_url": "https://github.com/llvm/llvm-project/commit/7c812ea01a2d11545033bbed8f5094c4a4763124", "code_v0_no_empty_lines": "在向量循环中，vector_splice操作被拆分为vslidedown和vslideup指令对，但vslidedown使用较小的AVL（UpOffset），而vslideup使用VLMAX或EVL，导致循环内产生额外的vl切换开销。", "code_v1_no_empty_lines": "-  SDValue SlideDown = getVSlidedown(DAG, Subtarget, DL, VecVT, DAG.getUNDEF(VecVT), V1, DownOffset, TrueMask, UpOffset);\n+  SDValue SlideDown = getVSlidedown(DAG, Subtarget, DL, VecVT, DAG.getUNDEF(VecVT), V1, DownOffset, TrueMask, Subtarget.hasVLDependentLatency() ? UpOffset : DAG.getRegister(RISCV::X0, XLenVT));", "target": "-  SDValue SlideDown = getVSlidedown(DAG, Subtarget, DL, VecVT, DAG.getUNDEF(VecVT), V1, DownOffset, TrueMask, UpOffset);\n+  SDValue SlideDown = getVSlidedown(DAG, Subtarget, DL, VecVT, DAG.getUNDEF(VecVT), V1, DownOffset, TrueMask, Subtarget.hasVLDependentLatency() ? UpOffset : DAG.getRegister(RISCV::X0, XLenVT));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在向量循环中，vector_splice操作被拆分为vslidedown和vslideup指令对，但vslidedown使用较小的AVL（UpOffset），而vslideup使用VLMAX或EVL，导致循环内产生额外的vl切换开销。优化后：通过增加vslidedown的AVL使其与vslideup匹配（即使额外元素会被覆盖），消除了vl切换。同时新增+vl-dependent-latency调优特性，允许在vl相关延迟的微架构（如sifive-x280）上保持旧行为。优化思路：减少动态vl切换以提升向量循环性能，同时提供微架构感知的调优选项。"}
{"id": 20, "source": "riscv-dataset-excel", "optimization_type": "栈内存优化", "optimization_description": "优化前：在计算RVV栈对象偏移时，直接使用原始偏移进行对齐填充计算，未考虑已知的最小向量长度（vlen）信息，可能导致不必要的对齐填充。优化后：在计算对齐填充前，先将栈大小乘以vscale因子（基于已知最小vlen），使对齐计算在缩放后的空间进行，计算完对齐后再除以vscale恢复原始大小。优化思路：利用已知的vlen是16的倍数这一信息，避免在vlen已满足对齐要求时产生冗余的对齐填充，从而减少栈内存浪费，提高内存使用效率。", "original_code": "在计算RVV栈对象偏移时，直接使用原始偏移进行对齐填充计算，未考虑已知的最小向量长度（vlen）信息，可能导致不必要的对齐填充。", "optimized_code": "// Multiply by vscale.\n+  if (ST.getRealMinVLen() >= RISCV::RVVBitsPerBlock)\n+    StackSize *= ST.getRealMinVLen() / RISCV::RVVBitsPerBlock;\n\n  // Ensure the alignment of the RVV stack. Since we want the most-aligned\n  // object right at the bottom (i.e., any padding at the top of the frame),\n  // readjust all RVV objects down by the alignment padding.\n-  uint64_t StackSize = Offset;\n   if (auto AlignmentPadding = offsetToAlignment(StackSize, RVVStackAlign)) {\n     StackSize += AlignmentPadding;\n     for (int FI : ObjectsToAllocate)\n       MFI.setObjectOffset(FI, MFI.getObjectOffset(FI) - AlignmentPadding);\n   }\n\n+  // Remove vscale.\n+  if (ST.getRealMinVLen() >= RISCV::RVVBitsPerBlock)\n+    StackSize /= ST.getRealMinVLen() / RISCV::RVVBitsPerBlock;", "source_url": "https://github.com/llvm/llvm-project/commit/ab393cee9dffdb225b94badcb9c21f80b156b74b", "code_v0_no_empty_lines": "在计算RVV栈对象偏移时，直接使用原始偏移进行对齐填充计算，未考虑已知的最小向量长度（vlen）信息，可能导致不必要的对齐填充。", "code_v1_no_empty_lines": "// Multiply by vscale.\n+  if (ST.getRealMinVLen() >= RISCV::RVVBitsPerBlock)\n+    StackSize *= ST.getRealMinVLen() / RISCV::RVVBitsPerBlock;\n\n  // Ensure the alignment of the RVV stack. Since we want the most-aligned\n  // object right at the bottom (i.e., any padding at the top of the frame),\n  // readjust all RVV objects down by the alignment padding.\n-  uint64_t StackSize = Offset;\n   if (auto AlignmentPadding = offsetToAlignment(StackSize, RVVStackAlign)) {\n     StackSize += AlignmentPadding;\n     for (int FI : ObjectsToAllocate)\n       MFI.setObjectOffset(FI, MFI.getObjectOffset(FI) - AlignmentPadding);\n   }\n\n+  // Remove vscale.\n+  if (ST.getRealMinVLen() >= RISCV::RVVBitsPerBlock)\n+    StackSize /= ST.getRealMinVLen() / RISCV::RVVBitsPerBlock;", "target": "// Multiply by vscale.\n+  if (ST.getRealMinVLen() >= RISCV::RVVBitsPerBlock)\n+    StackSize *= ST.getRealMinVLen() / RISCV::RVVBitsPerBlock;\n\n  // Ensure the alignment of the RVV stack. Since we want the most-aligned\n  // object right at the bottom (i.e., any padding at the top of the frame),\n  // readjust all RVV objects down by the alignment padding.\n-  uint64_t StackSize = Offset;\n   if (auto AlignmentPadding = offsetToAlignment(StackSize, RVVStackAlign)) {\n     StackSize += AlignmentPadding;\n     for (int FI : ObjectsToAllocate)\n       MFI.setObjectOffset(FI, MFI.getObjectOffset(FI) - AlignmentPadding);\n   }\n\n+  // Remove vscale.\n+  if (ST.getRealMinVLen() >= RISCV::RVVBitsPerBlock)\n+    StackSize /= ST.getRealMinVLen() / RISCV::RVVBitsPerBlock;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在计算RVV栈对象偏移时，直接使用原始偏移进行对齐填充计算，未考虑已知的最小向量长度（vlen）信息，可能导致不必要的对齐填充。优化后：在计算对齐填充前，先将栈大小乘以vscale因子（基于已知最小vlen），使对齐计算在缩放后的空间进行，计算完对齐后再除以vscale恢复原始大小。优化思路：利用已知的vlen是16的倍数这一信息，避免在vlen已满足对齐要求时产生冗余的对齐填充，从而减少栈内存浪费，提高内存使用效率。"}
{"id": 21, "source": "riscv-dataset-excel", "optimization_type": "栈内存优化", "optimization_description": "优化前：fmt_fp函数总是为long double分配最大缓冲区，即使实际参数是double类型，导致栈空间浪费。优化后：通过新增ps参数区分浮点类型，使用可变长度数组(VLA)根据实际类型动态分配缓冲区大小。当参数为double时，缓冲区大小减少约1/16，且无浮点参数的printf调用完全不分配浮点缓冲区。优化思路：根据实际浮点类型需求动态调整栈使用，避免编译器将栈分配提升到函数开头，显著减少栈内存占用。", "original_code": "fmt_fp函数总是为long double分配最大缓冲区，即使实际参数是double类型，导致栈空间浪费。", "optimized_code": "static int fmt_fp(FILE *f, long double y, int w, int p, int fl, int t)\n+static int fmt_fp(FILE *f, long double y, int w, int p, int fl, int t, int ps)\n {\n- uint32_t big[(LDBL_MANT_DIG+28)/29 + 1          // mantissa expansion\n-   + (LDBL_MAX_EXP+LDBL_MANT_DIG+28+8)/9]; // exponent expansion\n+ int bufsize = (ps==BIGLPRE)\n+   ? (LDBL_MANT_DIG+28)/29 + 1 +          // mantissa expansion\n+     (LDBL_MAX_EXP+LDBL_MANT_DIG+28+8)/9  // exponent expansion\n+   : (DBL_MANT_DIG+28)/29 + 1 +\n+     (DBL_MAX_EXP+DBL_MANT_DIG+28+8)/9;\n+ uint32_t big[bufsize];", "source_url": "https://git.musl-libc.org/cgit/musl/commit/?id=572a2e2eb91f00f2f25d301cfb50f435e7ae16b3", "code_v0_no_empty_lines": "fmt_fp函数总是为long double分配最大缓冲区，即使实际参数是double类型，导致栈空间浪费。", "code_v1_no_empty_lines": "static int fmt_fp(FILE *f, long double y, int w, int p, int fl, int t)\n+static int fmt_fp(FILE *f, long double y, int w, int p, int fl, int t, int ps)\n {\n- uint32_t big[(LDBL_MANT_DIG+28)/29 + 1          // mantissa expansion\n-   + (LDBL_MAX_EXP+LDBL_MANT_DIG+28+8)/9]; // exponent expansion\n+ int bufsize = (ps==BIGLPRE)\n+   ? (LDBL_MANT_DIG+28)/29 + 1 +          // mantissa expansion\n+     (LDBL_MAX_EXP+LDBL_MANT_DIG+28+8)/9  // exponent expansion\n+   : (DBL_MANT_DIG+28)/29 + 1 +\n+     (DBL_MAX_EXP+DBL_MANT_DIG+28+8)/9;\n+ uint32_t big[bufsize];", "target": "static int fmt_fp(FILE *f, long double y, int w, int p, int fl, int t)\n+static int fmt_fp(FILE *f, long double y, int w, int p, int fl, int t, int ps)\n {\n- uint32_t big[(LDBL_MANT_DIG+28)/29 + 1          // mantissa expansion\n-   + (LDBL_MAX_EXP+LDBL_MANT_DIG+28+8)/9]; // exponent expansion\n+ int bufsize = (ps==BIGLPRE)\n+   ? (LDBL_MANT_DIG+28)/29 + 1 +          // mantissa expansion\n+     (LDBL_MAX_EXP+LDBL_MANT_DIG+28+8)/9  // exponent expansion\n+   : (DBL_MANT_DIG+28)/29 + 1 +\n+     (DBL_MAX_EXP+DBL_MANT_DIG+28+8)/9;\n+ uint32_t big[bufsize];", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：fmt_fp函数总是为long double分配最大缓冲区，即使实际参数是double类型，导致栈空间浪费。优化后：通过新增ps参数区分浮点类型，使用可变长度数组(VLA)根据实际类型动态分配缓冲区大小。当参数为double时，缓冲区大小减少约1/16，且无浮点参数的printf调用完全不分配浮点缓冲区。优化思路：根据实际浮点类型需求动态调整栈使用，避免编译器将栈分配提升到函数开头，显著减少栈内存占用。"}
{"id": 22, "source": "riscv-dataset-excel", "optimization_type": "系统调用优化", "optimization_description": "优化前：RISC-V架构未启用vdso的clock_gettime功能，每次获取时间都需要进行完整的系统调用，开销较大。优化后：启用vdso的clock_gettime功能并更新版本号，允许用户态程序通过vdso直接获取时间，避免陷入内核的系统调用开销。优化思路：利用vdso机制减少系统调用次数，提升时间获取性能。", "original_code": "RISC-V架构未启用vdso的clock_gettime功能，每次获取时间都需要进行完整的系统调用，开销较大。", "optimized_code": "-/* We don't have a clock_gettime function.\n #define VDSO_CGT_SYM \"__vdso_clock_gettime\"\n-#define VDSO_CGT_VER \"LINUX_2.6\" */\n+#define VDSO_CGT_VER \"LINUX_4.15\"", "source_url": "https://git.musl-libc.org/cgit/musl/commit/?id=9b6a24f9c56caf70289c1fa3470f4841808ef3b7", "code_v0_no_empty_lines": "RISC-V架构未启用vdso的clock_gettime功能，每次获取时间都需要进行完整的系统调用，开销较大。", "code_v1_no_empty_lines": "-/* We don't have a clock_gettime function.\n #define VDSO_CGT_SYM \"__vdso_clock_gettime\"\n-#define VDSO_CGT_VER \"LINUX_2.6\" */\n+#define VDSO_CGT_VER \"LINUX_4.15\"", "target": "-/* We don't have a clock_gettime function.\n #define VDSO_CGT_SYM \"__vdso_clock_gettime\"\n-#define VDSO_CGT_VER \"LINUX_2.6\" */\n+#define VDSO_CGT_VER \"LINUX_4.15\"", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V架构未启用vdso的clock_gettime功能，每次获取时间都需要进行完整的系统调用，开销较大。优化后：启用vdso的clock_gettime功能并更新版本号，允许用户态程序通过vdso直接获取时间，避免陷入内核的系统调用开销。优化思路：利用vdso机制减少系统调用次数，提升时间获取性能。"}
{"id": 23, "source": "riscv-dataset-excel", "optimization_type": "线程安全与信号处理优化", "optimization_description": "优化前：SIGEV_THREAD定时器线程在重用（重置状态）时，会保留应用程序可能修改过的信号掩码，这违反了定时器线程应始终阻塞所有信号的初始设计，可能导致应用程序代码在不应存在的线程中执行，且如果内部SIGTIMER信号被解除阻塞，可能错过定时器到期事件。优化后：在每次定时器回调执行后，重新阻塞所有信号，确保线程重用时的信号掩码始终处于正确状态，防止信号处理异常和潜在的竞态条件，提高定时器线程的可靠性和安全性。", "original_code": "SIGEV_THREAD定时器线程在重用（重置状态）时，会保留应用程序可能修改过的信号掩码，这违反了定时器线程应始终阻塞所有信号的初始设计，可能导致应用程序代码在不应存在的线程中执行，且如果内部SIGTIMER信号被解除阻塞，可能错过定时器到期事件。", "optimized_code": "-static void *start(void *arg)\n+static void *start(void *arg)\n {\n  struct timer_thread *td = arg;\n  sigset_t set;\n  sigfillset(&set);\n  pthread_sigmask(SIG_BLOCK, &set, 0);\n  for (;;) {\n    sem_wait(&td->sem);\n    td->func(td->evp);\n+    sigfillset(&set);\n+    pthread_sigmask(SIG_BLOCK, &set, 0);\n  }\n }", "source_url": "https://git.musl-libc.org/cgit/musl/commit/?id=561cd07dff8003251729569e5539b00698941697", "code_v0_no_empty_lines": "SIGEV_THREAD定时器线程在重用（重置状态）时，会保留应用程序可能修改过的信号掩码，这违反了定时器线程应始终阻塞所有信号的初始设计，可能导致应用程序代码在不应存在的线程中执行，且如果内部SIGTIMER信号被解除阻塞，可能错过定时器到期事件。", "code_v1_no_empty_lines": "-static void *start(void *arg)\n+static void *start(void *arg)\n {\n  struct timer_thread *td = arg;\n  sigset_t set;\n  sigfillset(&set);\n  pthread_sigmask(SIG_BLOCK, &set, 0);\n  for (;;) {\n    sem_wait(&td->sem);\n    td->func(td->evp);\n+    sigfillset(&set);\n+    pthread_sigmask(SIG_BLOCK, &set, 0);\n  }\n }", "target": "-static void *start(void *arg)\n+static void *start(void *arg)\n {\n  struct timer_thread *td = arg;\n  sigset_t set;\n  sigfillset(&set);\n  pthread_sigmask(SIG_BLOCK, &set, 0);\n  for (;;) {\n    sem_wait(&td->sem);\n    td->func(td->evp);\n+    sigfillset(&set);\n+    pthread_sigmask(SIG_BLOCK, &set, 0);\n  }\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SIGEV_THREAD定时器线程在重用（重置状态）时，会保留应用程序可能修改过的信号掩码，这违反了定时器线程应始终阻塞所有信号的初始设计，可能导致应用程序代码在不应存在的线程中执行，且如果内部SIGTIMER信号被解除阻塞，可能错过定时器到期事件。优化后：在每次定时器回调执行后，重新阻塞所有信号，确保线程重用时的信号掩码始终处于正确状态，防止信号处理异常和潜在的竞态条件，提高定时器线程的可靠性和安全性。"}
{"id": 24, "source": "riscv-dataset-excel", "optimization_type": "内存访问优化+缓存一致性优化", "optimization_description": "优化前：L2缓存无法区分内存访问类型（主内存 vs MMIO）和页面属性（正常缓存 vs 非缓存），可能导致缓存策略错误。优化后：通过Tilelink协议向L2缓存传递MemBackTypeMM（指示是否访问主内存）和MemPageTypeNC（指示是否非缓存页面）信息，使L2缓存能正确处理不同内存区域的访问。优化思路：在指令缓存和未缓存指令路径中正确设置内存类型标志，确保缓存一致性协议能正确处理各种内存访问场景。", "original_code": "L2缓存无法区分内存访问类型（主内存 vs MMIO）和页面属性（正常缓存 vs 非缓存），可能导致缓存策略错误。", "optimized_code": "1. IFU.scala: 添加toUncache.bits.memBackTypeMM和toUncache.bits.memPageTypeNC赋值\n   toUncache.bits.memBackTypeMM := !f3_pmp_mmio\n   toUncache.bits.memPageTypeNC := f3_itlb_pbmt === Pbmt.nc\n2. ICacheMissUnit.scala: 添加io.acquire.bits.acquire.user.lift(MemBackTypeMM).foreach(_ := true.B)\n3. InstrUncache.scala: \n   - 在InsUncacheReq类中添加memBackTypeMM和memPageTypeNC字段\n   - 在InstrMMIOEntry中添加io.mmio_acquire.bits.user.lift(MemBackTypeMM/NC)赋值\n   - 在clientParameters中添加requestFields = Seq(MemBackTypeMMField(), MemPageTypeNCField())", "source_url": "https://github.com/OpenXiangShan/XiangShan/commit/2cf64d6d43e489916211e4a6c51b42e1548ec406", "code_v0_no_empty_lines": "L2缓存无法区分内存访问类型（主内存 vs MMIO）和页面属性（正常缓存 vs 非缓存），可能导致缓存策略错误。", "code_v1_no_empty_lines": "1. IFU.scala: 添加toUncache.bits.memBackTypeMM和toUncache.bits.memPageTypeNC赋值\n   toUncache.bits.memBackTypeMM := !f3_pmp_mmio\n   toUncache.bits.memPageTypeNC := f3_itlb_pbmt === Pbmt.nc\n2. ICacheMissUnit.scala: 添加io.acquire.bits.acquire.user.lift(MemBackTypeMM).foreach(_ := true.B)\n3. InstrUncache.scala: \n   - 在InsUncacheReq类中添加memBackTypeMM和memPageTypeNC字段\n   - 在InstrMMIOEntry中添加io.mmio_acquire.bits.user.lift(MemBackTypeMM/NC)赋值\n   - 在clientParameters中添加requestFields = Seq(MemBackTypeMMField(), MemPageTypeNCField())", "target": "1. IFU.scala: 添加toUncache.bits.memBackTypeMM和toUncache.bits.memPageTypeNC赋值\n   toUncache.bits.memBackTypeMM := !f3_pmp_mmio\n   toUncache.bits.memPageTypeNC := f3_itlb_pbmt === Pbmt.nc\n2. ICacheMissUnit.scala: 添加io.acquire.bits.acquire.user.lift(MemBackTypeMM).foreach(_ := true.B)\n3. InstrUncache.scala: \n   - 在InsUncacheReq类中添加memBackTypeMM和memPageTypeNC字段\n   - 在InstrMMIOEntry中添加io.mmio_acquire.bits.user.lift(MemBackTypeMM/NC)赋值\n   - 在clientParameters中添加requestFields = Seq(MemBackTypeMMField(), MemPageTypeNCField())", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：L2缓存无法区分内存访问类型（主内存 vs MMIO）和页面属性（正常缓存 vs 非缓存），可能导致缓存策略错误。优化后：通过Tilelink协议向L2缓存传递MemBackTypeMM（指示是否访问主内存）和MemPageTypeNC（指示是否非缓存页面）信息，使L2缓存能正确处理不同内存区域的访问。优化思路：在指令缓存和未缓存指令路径中正确设置内存类型标志，确保缓存一致性协议能正确处理各种内存访问场景。"}
{"id": 25, "source": "riscv-dataset-excel", "optimization_type": "指令优化+代码生成优化", "optimization_description": "优化前：encode_heap_oop函数需要处理null检查，即使已知oop不为null时也会产生额外分支开销。优化后：新增encode_heap_oop_not_null函数，专门处理已知非null的oop压缩场景，通过移除null检查分支减少指令开销。优化思路：通过静态分析确定oop不为null的场景，生成专门的汇编指令序列，避免不必要的条件判断，提高代码生成效率。", "original_code": "encode_heap_oop函数需要处理null检查，即使已知oop不为null时也会产生额外分支开销。", "optimized_code": "void MacroAssembler::encode_heap_oop_not_null(Register r) {\n#ifdef ASSERT\n  if (CheckCompressedOops) {\n    Label ok;\n    bnez(r, ok);\n    stop(\"null oop passed to encode_heap_oop_not_null\");\n    bind(ok);\n  }\n#endif\n  verify_oop_msg(r, \"broken oop in encode_heap_oop_not_null\");\n  if (CompressedOops::base() != nullptr) {\n    sub(r, r, xheapbase);\n  }\n  if (CompressedOops::shift() != 0) {\n    assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), \"decode alg wrong\");\n    srli(r, r, LogMinObjAlignmentInBytes);\n  }\n}\n\nvoid MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {\n#ifdef ASSERT\n  if (CheckCompressedOops) {\n    Label ok;\n    bnez(src, ok);\n    stop(\"null oop passed to encode_heap_oop_not_null2\");\n    bind(ok);\n  }\n#endif\n  verify_oop_msg(src, \"broken oop in encode_heap_oop_not_null2\");\n\n  Register data = src;\n  if (CompressedOops::base() != nullptr) {\n    sub(dst, src, xheapbase);\n    data = dst;\n  }\n  if (CompressedOops::shift() != 0) {\n    assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), \"decode alg wrong\");\n    srli(dst, data, LogMinObjAlignmentInBytes);\n    data = dst;\n  }\n  if (data == src) {\n    mv(dst, src);\n  }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/5866b16dbca3f63770c8792d204dabdf49b59839", "code_v0_no_empty_lines": "encode_heap_oop函数需要处理null检查，即使已知oop不为null时也会产生额外分支开销。", "code_v1_no_empty_lines": "void MacroAssembler::encode_heap_oop_not_null(Register r) {\n#ifdef ASSERT\n  if (CheckCompressedOops) {\n    Label ok;\n    bnez(r, ok);\n    stop(\"null oop passed to encode_heap_oop_not_null\");\n    bind(ok);\n  }\n#endif\n  verify_oop_msg(r, \"broken oop in encode_heap_oop_not_null\");\n  if (CompressedOops::base() != nullptr) {\n    sub(r, r, xheapbase);\n  }\n  if (CompressedOops::shift() != 0) {\n    assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), \"decode alg wrong\");\n    srli(r, r, LogMinObjAlignmentInBytes);\n  }\n}\n\nvoid MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {\n#ifdef ASSERT\n  if (CheckCompressedOops) {\n    Label ok;\n    bnez(src, ok);\n    stop(\"null oop passed to encode_heap_oop_not_null2\");\n    bind(ok);\n  }\n#endif\n  verify_oop_msg(src, \"broken oop in encode_heap_oop_not_null2\");\n\n  Register data = src;\n  if (CompressedOops::base() != nullptr) {\n    sub(dst, src, xheapbase);\n    data = dst;\n  }\n  if (CompressedOops::shift() != 0) {\n    assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), \"decode alg wrong\");\n    srli(dst, data, LogMinObjAlignmentInBytes);\n    data = dst;\n  }\n  if (data == src) {\n    mv(dst, src);\n  }\n}", "target": "void MacroAssembler::encode_heap_oop_not_null(Register r) {\n#ifdef ASSERT\n  if (CheckCompressedOops) {\n    Label ok;\n    bnez(r, ok);\n    stop(\"null oop passed to encode_heap_oop_not_null\");\n    bind(ok);\n  }\n#endif\n  verify_oop_msg(r, \"broken oop in encode_heap_oop_not_null\");\n  if (CompressedOops::base() != nullptr) {\n    sub(r, r, xheapbase);\n  }\n  if (CompressedOops::shift() != 0) {\n    assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), \"decode alg wrong\");\n    srli(r, r, LogMinObjAlignmentInBytes);\n  }\n}\n\nvoid MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {\n#ifdef ASSERT\n  if (CheckCompressedOops) {\n    Label ok;\n    bnez(src, ok);\n    stop(\"null oop passed to encode_heap_oop_not_null2\");\n    bind(ok);\n  }\n#endif\n  verify_oop_msg(src, \"broken oop in encode_heap_oop_not_null2\");\n\n  Register data = src;\n  if (CompressedOops::base() != nullptr) {\n    sub(dst, src, xheapbase);\n    data = dst;\n  }\n  if (CompressedOops::shift() != 0) {\n    assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), \"decode alg wrong\");\n    srli(dst, data, LogMinObjAlignmentInBytes);\n    data = dst;\n  }\n  if (data == src) {\n    mv(dst, src);\n  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：encode_heap_oop函数需要处理null检查，即使已知oop不为null时也会产生额外分支开销。优化后：新增encode_heap_oop_not_null函数，专门处理已知非null的oop压缩场景，通过移除null检查分支减少指令开销。优化思路：通过静态分析确定oop不为null的场景，生成专门的汇编指令序列，避免不必要的条件判断，提高代码生成效率。"}
{"id": 26, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化+微架构优化", "optimization_description": "优化前：对于所有RISC-V目标，编译器会将select指令转换为算术操作（如-c | y），这可能导致较长的指令序列。优化后：为SiFive 7系列处理器添加短前向分支优化支持，当检测到目标支持此特性时，将select指令转换为条件移动伪指令（PseudoCCMOVGPR），然后扩展为分支+移动指令序列，利用处理器能够融合整数ALU操作与前向分支指令的特性。优化思路：针对特定微架构特性进行指令选择优化，在支持分支融合的处理器上使用分支+移动序列替代算术操作序列，减少指令数量和潜在的数据依赖，提高指令级并行性。", "original_code": "对于所有RISC-V目标，编译器会将select指令转换为算术操作（如-c | y），这可能导致较长的指令序列。", "optimized_code": "1. 新增TuneShortForwardBranchOpt特性定义\n2. 在RISCVExpandPseudoInsts.cpp中新增expandCCOp函数处理PseudoCCMOVGPR\n3. 在RISCVISelLowering.cpp中为select指令转换添加hasShortForwardBranchOpt条件判断", "source_url": "https://reviews.llvm.org/D135814", "code_v0_no_empty_lines": "对于所有RISC-V目标，编译器会将select指令转换为算术操作（如-c | y），这可能导致较长的指令序列。", "code_v1_no_empty_lines": "1. 新增TuneShortForwardBranchOpt特性定义\n2. 在RISCVExpandPseudoInsts.cpp中新增expandCCOp函数处理PseudoCCMOVGPR\n3. 在RISCVISelLowering.cpp中为select指令转换添加hasShortForwardBranchOpt条件判断", "target": "1. 新增TuneShortForwardBranchOpt特性定义\n2. 在RISCVExpandPseudoInsts.cpp中新增expandCCOp函数处理PseudoCCMOVGPR\n3. 在RISCVISelLowering.cpp中为select指令转换添加hasShortForwardBranchOpt条件判断", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于所有RISC-V目标，编译器会将select指令转换为算术操作（如-c | y），这可能导致较长的指令序列。优化后：为SiFive 7系列处理器添加短前向分支优化支持，当检测到目标支持此特性时，将select指令转换为条件移动伪指令（PseudoCCMOVGPR），然后扩展为分支+移动指令序列，利用处理器能够融合整数ALU操作与前向分支指令的特性。优化思路：针对特定微架构特性进行指令选择优化，在支持分支融合的处理器上使用分支+移动序列替代算术操作序列，减少指令数量和潜在的数据依赖，提高指令级并行性。"}
{"id": 27, "source": "riscv-dataset-excel", "optimization_type": "无法识别", "optimization_description": "输入内容不是有效的Git Commit信息，而是Anubis反爬虫系统的验证页面内容。该页面包含JavaScript验证、Proof-of-Work机制说明和反爬虫保护信息，与编译器优化无关。", "original_code": "// No original code extracted from description\n", "optimized_code": "无", "source_url": "https://lore.kernel.org/linux-riscv/20230810040349.92279-3-leobras@redhat.com/", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "无", "target": "无", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "输入内容不是有效的Git Commit信息，而是Anubis反爬虫系统的验证页面内容。该页面包含JavaScript验证、Proof-of-Work机制说明和反爬虫保护信息，与编译器优化无关。"}
{"id": 28, "source": "riscv-dataset-excel", "optimization_type": "虚拟化性能优化", "optimization_description": "优化前：RISC-V KVM缺少kvm_arch_flush_remote_tlbs_range()实现，mmu_wp_memory_region()只能使用全局TLB刷新kvm_flush_remote_tlbs()，导致不必要的TLB刷新开销。优化后：1. 实现kvm_arch_flush_remote_tlbs_range()函数，利用kvm_riscv_hfence_gvma_vmid_gpa()进行范围TLB刷新；2. mmu_wp_memory_region()改用kvm_flush_remote_tlbs_memslot()进行内存槽粒度的TLB刷新。优化思路：通过实现范围TLB刷新接口，避免全局TLB刷新，减少不必要的TLB失效操作，提升虚拟化性能。", "original_code": "RISC-V KVM缺少kvm_arch_flush_remote_tlbs_range()实现，mmu_wp_memory_region()只能使用全局TLB刷新kvm_flush_remote_tlbs()，导致不必要的TLB刷新开销。", "optimized_code": "- kvm_flush_remote_tlbs(kvm);\n+ kvm_flush_remote_tlbs_memslot(kvm, memslot);\n\n+int kvm_arch_flush_remote_tlbs_range(struct kvm *kvm, gfn_t gfn, u64 nr_pages)\n+{\n+\tkvm_riscv_hfence_gvma_vmid_gpa(kvm, -1UL, 0,\n+\t\t\t\t       gfn << PAGE_SHIFT, nr_pages << PAGE_SHIFT,\n+\t\t\t\t       PAGE_SHIFT);\n+\treturn 0;\n+}", "source_url": "https://github.com/torvalds/linux/commit/ca539ba4bc980610b68dba345b18208c0279b2b1", "code_v0_no_empty_lines": "RISC-V KVM缺少kvm_arch_flush_remote_tlbs_range()实现，mmu_wp_memory_region()只能使用全局TLB刷新kvm_flush_remote_tlbs()，导致不必要的TLB刷新开销。", "code_v1_no_empty_lines": "- kvm_flush_remote_tlbs(kvm);\n+ kvm_flush_remote_tlbs_memslot(kvm, memslot);\n\n+int kvm_arch_flush_remote_tlbs_range(struct kvm *kvm, gfn_t gfn, u64 nr_pages)\n+{\n+\tkvm_riscv_hfence_gvma_vmid_gpa(kvm, -1UL, 0,\n+\t\t\t\t       gfn << PAGE_SHIFT, nr_pages << PAGE_SHIFT,\n+\t\t\t\t       PAGE_SHIFT);\n+\treturn 0;\n+}", "target": "- kvm_flush_remote_tlbs(kvm);\n+ kvm_flush_remote_tlbs_memslot(kvm, memslot);\n\n+int kvm_arch_flush_remote_tlbs_range(struct kvm *kvm, gfn_t gfn, u64 nr_pages)\n+{\n+\tkvm_riscv_hfence_gvma_vmid_gpa(kvm, -1UL, 0,\n+\t\t\t\t       gfn << PAGE_SHIFT, nr_pages << PAGE_SHIFT,\n+\t\t\t\t       PAGE_SHIFT);\n+\treturn 0;\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V KVM缺少kvm_arch_flush_remote_tlbs_range()实现，mmu_wp_memory_region()只能使用全局TLB刷新kvm_flush_remote_tlbs()，导致不必要的TLB刷新开销。优化后：1. 实现kvm_arch_flush_remote_tlbs_range()函数，利用kvm_riscv_hfence_gvma_vmid_gpa()进行范围TLB刷新；2. mmu_wp_memory_region()改用kvm_flush_remote_tlbs_memslot()进行内存槽粒度的TLB刷新。优化思路：通过实现范围TLB刷新接口，避免全局TLB刷新，减少不必要的TLB失效操作，提升虚拟化性能。"}
{"id": 29, "source": "riscv-dataset-excel", "optimization_type": "指令调度优化+指令合并优化", "optimization_description": "优化前：1. 使用slli+add两条指令计算数组偏移地址；2. mulw指令在加载数组元素前执行，可能导致流水线停顿。优化后：1. 使用shadd单条指令合并移位和加法操作，减少指令数；2. 将mulw指令移到四个数组元素加载之后，利用加载延迟隐藏乘法计算时间。优化思路：通过指令合并减少指令数量，通过指令重排提高指令级并行性，减少流水线停顿，提升向量化哈希计算性能。", "original_code": "1. 使用slli+add两条指令计算数组偏移地址；2. mulw指令在加载数组元素前执行，可能导致流水线停顿。", "optimized_code": "-  slli(chunks_end, chunks, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, chunks, ary, t0, chunks_end_shift);\n-  mulw(result, result, pow31_4); // 31^^4 * h\n   arrays_hashcode_elload(t0,   Address(ary, 0 * elsize), eltype);\n   arrays_hashcode_elload(t1,   Address(ary, 1 * elsize), eltype);\n   arrays_hashcode_elload(tmp5, Address(ary, 2 * elsize), eltype);\n   arrays_hashcode_elload(tmp6, Address(ary, 3 * elsize), eltype);\n+  mulw(result, result, pow31_4); // 31^^4 * h\n-  slli(chunks_end, cnt, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, cnt, ary, t0, chunks_end_shift);", "source_url": "https://github.com/openjdk/riscv-port/commit/4189fcbac40943f3b26c3a01938837b4e4762285", "code_v0_no_empty_lines": "1. 使用slli+add两条指令计算数组偏移地址；2. mulw指令在加载数组元素前执行，可能导致流水线停顿。", "code_v1_no_empty_lines": "-  slli(chunks_end, chunks, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, chunks, ary, t0, chunks_end_shift);\n-  mulw(result, result, pow31_4); // 31^^4 * h\n   arrays_hashcode_elload(t0,   Address(ary, 0 * elsize), eltype);\n   arrays_hashcode_elload(t1,   Address(ary, 1 * elsize), eltype);\n   arrays_hashcode_elload(tmp5, Address(ary, 2 * elsize), eltype);\n   arrays_hashcode_elload(tmp6, Address(ary, 3 * elsize), eltype);\n+  mulw(result, result, pow31_4); // 31^^4 * h\n-  slli(chunks_end, cnt, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, cnt, ary, t0, chunks_end_shift);", "target": "-  slli(chunks_end, chunks, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, chunks, ary, t0, chunks_end_shift);\n-  mulw(result, result, pow31_4); // 31^^4 * h\n   arrays_hashcode_elload(t0,   Address(ary, 0 * elsize), eltype);\n   arrays_hashcode_elload(t1,   Address(ary, 1 * elsize), eltype);\n   arrays_hashcode_elload(tmp5, Address(ary, 2 * elsize), eltype);\n   arrays_hashcode_elload(tmp6, Address(ary, 3 * elsize), eltype);\n+  mulw(result, result, pow31_4); // 31^^4 * h\n-  slli(chunks_end, cnt, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, cnt, ary, t0, chunks_end_shift);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 使用slli+add两条指令计算数组偏移地址；2. mulw指令在加载数组元素前执行，可能导致流水线停顿。优化后：1. 使用shadd单条指令合并移位和加法操作，减少指令数；2. 将mulw指令移到四个数组元素加载之后，利用加载延迟隐藏乘法计算时间。优化思路：通过指令合并减少指令数量，通过指令重排提高指令级并行性，减少流水线停顿，提升向量化哈希计算性能。"}
{"id": 30, "source": "riscv-dataset-excel", "optimization_type": "代码简化+性能优化", "optimization_description": "优化前：profile_taken_branch函数使用两个寄存器参数（mdp和bumped_count），手动加载、递增和存储分支计数，包含溢出检查逻辑，代码复杂且需要额外寄存器。优化后：简化为单参数函数，调用现有的increment_mdp_data_at辅助函数处理计数递增，移除了手动计数逻辑和溢出检查。优化思路：通过重用现有辅助函数简化代码，减少寄存器使用和指令数量，提高可维护性，同时保持相同功能。", "original_code": "profile_taken_branch函数使用两个寄存器参数（mdp和bumped_count），手动加载、递增和存储分支计数，包含溢出检查逻辑，代码复杂且需要额外寄存器。", "optimized_code": "-void InterpreterMacroAssembler::profile_taken_branch(Register mdp,\n-                                                     Register bumped_count) {\n+void InterpreterMacroAssembler::profile_taken_branch(Register mdp) {\n   if (ProfileInterpreter) {\n     Label profile_continue;\n \n     // If no method data exists, go to profile_continue.\n-    // Otherwise, assign to mdp\n     test_method_data_pointer(mdp, profile_continue);\n \n     // We are taking a branch.  Increment the taken count.\n-    Address data(mdp, in_bytes(JumpData::taken_offset()));\n-    ld(bumped_count, data);\n-    assert(DataLayout::counter_increment == 1,\n-            \"flow-free idiom only works with 1\");\n-    addi(bumped_count, bumped_count, DataLayout::counter_increment);\n-    Label L;\n-    // eg: bumped_count=0x7fff ffff ffff ffff  + 1 < 0. so we use <= 0;\n-    blez(bumped_count, L);       // skip store if counter overflow,\n-    sd(bumped_count, data);\n-    bind(L);\n+    increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));", "source_url": "https://github.com/openjdk/riscv-port/commit/620df7ec348598580884e3b9d45066495f0c40e5", "code_v0_no_empty_lines": "profile_taken_branch函数使用两个寄存器参数（mdp和bumped_count），手动加载、递增和存储分支计数，包含溢出检查逻辑，代码复杂且需要额外寄存器。", "code_v1_no_empty_lines": "-void InterpreterMacroAssembler::profile_taken_branch(Register mdp,\n-                                                     Register bumped_count) {\n+void InterpreterMacroAssembler::profile_taken_branch(Register mdp) {\n   if (ProfileInterpreter) {\n     Label profile_continue;\n \n     // If no method data exists, go to profile_continue.\n-    // Otherwise, assign to mdp\n     test_method_data_pointer(mdp, profile_continue);\n \n     // We are taking a branch.  Increment the taken count.\n-    Address data(mdp, in_bytes(JumpData::taken_offset()));\n-    ld(bumped_count, data);\n-    assert(DataLayout::counter_increment == 1,\n-            \"flow-free idiom only works with 1\");\n-    addi(bumped_count, bumped_count, DataLayout::counter_increment);\n-    Label L;\n-    // eg: bumped_count=0x7fff ffff ffff ffff  + 1 < 0. so we use <= 0;\n-    blez(bumped_count, L);       // skip store if counter overflow,\n-    sd(bumped_count, data);\n-    bind(L);\n+    increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));", "target": "-void InterpreterMacroAssembler::profile_taken_branch(Register mdp,\n-                                                     Register bumped_count) {\n+void InterpreterMacroAssembler::profile_taken_branch(Register mdp) {\n   if (ProfileInterpreter) {\n     Label profile_continue;\n \n     // If no method data exists, go to profile_continue.\n-    // Otherwise, assign to mdp\n     test_method_data_pointer(mdp, profile_continue);\n \n     // We are taking a branch.  Increment the taken count.\n-    Address data(mdp, in_bytes(JumpData::taken_offset()));\n-    ld(bumped_count, data);\n-    assert(DataLayout::counter_increment == 1,\n-            \"flow-free idiom only works with 1\");\n-    addi(bumped_count, bumped_count, DataLayout::counter_increment);\n-    Label L;\n-    // eg: bumped_count=0x7fff ffff ffff ffff  + 1 < 0. so we use <= 0;\n-    blez(bumped_count, L);       // skip store if counter overflow,\n-    sd(bumped_count, data);\n-    bind(L);\n+    increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：profile_taken_branch函数使用两个寄存器参数（mdp和bumped_count），手动加载、递增和存储分支计数，包含溢出检查逻辑，代码复杂且需要额外寄存器。优化后：简化为单参数函数，调用现有的increment_mdp_data_at辅助函数处理计数递增，移除了手动计数逻辑和溢出检查。优化思路：通过重用现有辅助函数简化代码，减少寄存器使用和指令数量，提高可维护性，同时保持相同功能。"}
{"id": 31, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码简化", "optimization_description": "优化前：increment_mdp_data_at函数支持递增和递减操作，包含复杂的溢出/下溢检查逻辑（bltz/blez分支判断），代码冗余且执行路径长。优化后：移除decrement参数和相关逻辑，仅保留递增操作，简化了函数签名和实现。优化思路：由于实际使用场景中只需要递增操作，移除不必要的递减逻辑可以减少代码大小、消除分支预测开销，并简化维护。", "original_code": "increment_mdp_data_at函数支持递增和递减操作，包含复杂的溢出/下溢检查逻辑（bltz/blez分支判断），代码冗余且执行路径长。", "optimized_code": "void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n                                                      Register index,\n                                                      int constant) {\n  assert(ProfileInterpreter, \"must be profiling interpreter\");\n\n  assert_different_registers(t1, t0, mdp_in, index);\n\n  Address addr1(mdp_in, constant);\n  Address addr2(t1, 0);\n  Address &addr = addr1;\n  if (index != noreg) {\n    la(t1, addr1);\n    add(t1, t1, index);\n    addr = addr2;\n  }\n\n  ld(t0, addr);\n  addi(t0, t0, DataLayout::counter_increment);\n  sd(t0, addr);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/939521b8e4120357108220d177228b683af3334f", "code_v0_no_empty_lines": "increment_mdp_data_at函数支持递增和递减操作，包含复杂的溢出/下溢检查逻辑（bltz/blez分支判断），代码冗余且执行路径长。", "code_v1_no_empty_lines": "void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n                                                      Register index,\n                                                      int constant) {\n  assert(ProfileInterpreter, \"must be profiling interpreter\");\n\n  assert_different_registers(t1, t0, mdp_in, index);\n\n  Address addr1(mdp_in, constant);\n  Address addr2(t1, 0);\n  Address &addr = addr1;\n  if (index != noreg) {\n    la(t1, addr1);\n    add(t1, t1, index);\n    addr = addr2;\n  }\n\n  ld(t0, addr);\n  addi(t0, t0, DataLayout::counter_increment);\n  sd(t0, addr);\n}", "target": "void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n                                                      Register index,\n                                                      int constant) {\n  assert(ProfileInterpreter, \"must be profiling interpreter\");\n\n  assert_different_registers(t1, t0, mdp_in, index);\n\n  Address addr1(mdp_in, constant);\n  Address addr2(t1, 0);\n  Address &addr = addr1;\n  if (index != noreg) {\n    la(t1, addr1);\n    add(t1, t1, index);\n    addr = addr2;\n  }\n\n  ld(t0, addr);\n  addi(t0, t0, DataLayout::counter_increment);\n  sd(t0, addr);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：increment_mdp_data_at函数支持递增和递减操作，包含复杂的溢出/下溢检查逻辑（bltz/blez分支判断），代码冗余且执行路径长。优化后：移除decrement参数和相关逻辑，仅保留递增操作，简化了函数签名和实现。优化思路：由于实际使用场景中只需要递增操作，移除不必要的递减逻辑可以减少代码大小、消除分支预测开销，并简化维护。"}
{"id": 32, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前：在JNI调用期间的安全点轮询中，无论是否需要都包含acquire内存屏障（membar指令），这会强制内存排序并增加开销。优化后：移除了acquire参数及相关内存屏障指令，因为RISC-V架构的弱内存模型下，安全点轮询不需要额外的acquire屏障来保证正确性。优化思路：基于RISC-V内存模型特性，简化代码并减少不必要的内存屏障开销，提升JNI调用性能。", "original_code": "在JNI调用期间的安全点轮询中，无论是否需要都包含acquire内存屏障（membar指令），这会强制内存排序并增加开销。", "optimized_code": "-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp_reg) {\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp_reg) {\n   ld(tmp_reg, Address(xthread, JavaThread::polling_word_offset()));\n-  if (acquire) {\n-    membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n-  }", "source_url": "https://github.com/openjdk/riscv-port/commit/1a01839f8c0522a90710e101cce6ecc479a77529", "code_v0_no_empty_lines": "在JNI调用期间的安全点轮询中，无论是否需要都包含acquire内存屏障（membar指令），这会强制内存排序并增加开销。", "code_v1_no_empty_lines": "-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp_reg) {\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp_reg) {\n   ld(tmp_reg, Address(xthread, JavaThread::polling_word_offset()));\n-  if (acquire) {\n-    membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n-  }", "target": "-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp_reg) {\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp_reg) {\n   ld(tmp_reg, Address(xthread, JavaThread::polling_word_offset()));\n-  if (acquire) {\n-    membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n-  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在JNI调用期间的安全点轮询中，无论是否需要都包含acquire内存屏障（membar指令），这会强制内存排序并增加开销。优化后：移除了acquire参数及相关内存屏障指令，因为RISC-V架构的弱内存模型下，安全点轮询不需要额外的acquire屏障来保证正确性。优化思路：基于RISC-V内存模型特性，简化代码并减少不必要的内存屏障开销，提升JNI调用性能。"}
{"id": 33, "source": "riscv-dataset-excel", "optimization_type": "指令集扩展支持", "optimization_description": "优化前：RISC-V后端仅支持标准原子操作指令（如amoadd_w、amoadd_d等），缺乏对Zabha扩展（字节和半字原子操作）的支持。优化后：重构原子操作指令生成框架，引入模板化的amo_base函数，支持字节（AMO_WIDTH_BYTE）和半字（AMO_WIDTH_HALFWORD）宽度，并添加对应的指令函数（如amoadd_b、amoadd_h）。优化思路：通过扩展指令集支持，使编译器能够生成更细粒度的原子操作指令，提升多线程环境下小数据类型的并发性能，减少锁开销和内存访问冲突。", "original_code": "RISC-V后端仅支持标准原子操作指令（如amoadd_w、amoadd_d等），缺乏对Zabha扩展（字节和半字原子操作）的支持。", "optimized_code": "enum AmoWidthFunct3 : uint8_t {\n    AMO_WIDTH_BYTE        = 0b000, // Zabha extension\n    AMO_WIDTH_HALFWORD    = 0b001, // Zabha extension\n    AMO_WIDTH_WORD        = 0b010,\n    AMO_WIDTH_DOUBLEWORD  = 0b011,\n    AMO_WIDTH_QUADWORD    = 0b100,\n    // 0b101 to 0b111 are reserved\n};\n\ntemplate <AmoOperationFunct5 funct5, AmoWidthFunct3 width>\nvoid amo_base(Register Rd, Register Rs1, uint8_t Rs2, Aqrl memory_order = aqrl) {\n    assert(width > AMO_WIDTH_HALFWORD || UseZabha, \"Must be\");\n    assert(funct5 != AMO_CAS || UseZacas, \"Must be\");\n    unsigned insn = 0;\n    patch((address)&insn,  6,  0, OP_AMO_MAJOR);\n    patch_reg((address)&insn,  7, Rd);\n    patch((address)&insn, 14, 12, width);\n    patch_reg((address)&insn, 15, Rs1);\n    patch((address)&insn, 24, 20, Rs2);\n    patch((address)&insn, 26, 25, memory_order);\n    patch((address)&insn, 31, 27, funct5);\n    emit(insn);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/dc961609f84a38164d10852cb92c005c3eb077e4", "code_v0_no_empty_lines": "RISC-V后端仅支持标准原子操作指令（如amoadd_w、amoadd_d等），缺乏对Zabha扩展（字节和半字原子操作）的支持。", "code_v1_no_empty_lines": "enum AmoWidthFunct3 : uint8_t {\n    AMO_WIDTH_BYTE        = 0b000, // Zabha extension\n    AMO_WIDTH_HALFWORD    = 0b001, // Zabha extension\n    AMO_WIDTH_WORD        = 0b010,\n    AMO_WIDTH_DOUBLEWORD  = 0b011,\n    AMO_WIDTH_QUADWORD    = 0b100,\n    // 0b101 to 0b111 are reserved\n};\n\ntemplate <AmoOperationFunct5 funct5, AmoWidthFunct3 width>\nvoid amo_base(Register Rd, Register Rs1, uint8_t Rs2, Aqrl memory_order = aqrl) {\n    assert(width > AMO_WIDTH_HALFWORD || UseZabha, \"Must be\");\n    assert(funct5 != AMO_CAS || UseZacas, \"Must be\");\n    unsigned insn = 0;\n    patch((address)&insn,  6,  0, OP_AMO_MAJOR);\n    patch_reg((address)&insn,  7, Rd);\n    patch((address)&insn, 14, 12, width);\n    patch_reg((address)&insn, 15, Rs1);\n    patch((address)&insn, 24, 20, Rs2);\n    patch((address)&insn, 26, 25, memory_order);\n    patch((address)&insn, 31, 27, funct5);\n    emit(insn);\n}", "target": "enum AmoWidthFunct3 : uint8_t {\n    AMO_WIDTH_BYTE        = 0b000, // Zabha extension\n    AMO_WIDTH_HALFWORD    = 0b001, // Zabha extension\n    AMO_WIDTH_WORD        = 0b010,\n    AMO_WIDTH_DOUBLEWORD  = 0b011,\n    AMO_WIDTH_QUADWORD    = 0b100,\n    // 0b101 to 0b111 are reserved\n};\n\ntemplate <AmoOperationFunct5 funct5, AmoWidthFunct3 width>\nvoid amo_base(Register Rd, Register Rs1, uint8_t Rs2, Aqrl memory_order = aqrl) {\n    assert(width > AMO_WIDTH_HALFWORD || UseZabha, \"Must be\");\n    assert(funct5 != AMO_CAS || UseZacas, \"Must be\");\n    unsigned insn = 0;\n    patch((address)&insn,  6,  0, OP_AMO_MAJOR);\n    patch_reg((address)&insn,  7, Rd);\n    patch((address)&insn, 14, 12, width);\n    patch_reg((address)&insn, 15, Rs1);\n    patch((address)&insn, 24, 20, Rs2);\n    patch((address)&insn, 26, 25, memory_order);\n    patch((address)&insn, 31, 27, funct5);\n    emit(insn);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V后端仅支持标准原子操作指令（如amoadd_w、amoadd_d等），缺乏对Zabha扩展（字节和半字原子操作）的支持。优化后：重构原子操作指令生成框架，引入模板化的amo_base函数，支持字节（AMO_WIDTH_BYTE）和半字（AMO_WIDTH_HALFWORD）宽度，并添加对应的指令函数（如amoadd_b、amoadd_h）。优化思路：通过扩展指令集支持，使编译器能够生成更细粒度的原子操作指令，提升多线程环境下小数据类型的并发性能，减少锁开销和内存访问冲突。"}
{"id": 34, "source": "riscv-dataset-excel", "optimization_type": "代码优化+性能优化", "optimization_description": "优化前：对于小尺寸数组填充，代码分为两个独立部分处理剩余字节（小于8字节），第一部分假设地址已对齐，使用sw/sh指令；第二部分处理未对齐情况，使用循环逐个字节/半字填充。这导致代码冗余、分支跳转多、循环开销大。\n优化后：合并两个处理路径，统一处理小于8字节的填充，不再假设地址对齐。通过位测试直接展开小循环，将循环展开为顺序的sb/sh指令序列，减少分支跳转和循环控制开销。\n优化思路：针对小尺寸数组填充场景，消除冗余代码路径，通过循环展开减少指令数量和分支预测失败，提高小数组填充操作的执行效率。", "original_code": "对于小尺寸数组填充，代码分为两个独立部分处理剩余字节（小于8字节），第一部分假设地址已对齐，使用sw/sh指令；第二部分处理未对齐情况，使用循环逐个字节/半字填充。这导致代码冗余、分支跳转多、循环开销大。", "optimized_code": "-    // Remaining count is less than 8 bytes and address is heapword aligned.\n-    Label L_fill_1, L_fill_2, L_exit1;\n+    // Handle copies less than 8 bytes.\n+    // Address may not be heapword aligned.\n+    Label L_fill_1, L_fill_2, L_exit;\n+    __ bind(L_fill_elements);\n     switch (t) {\n       case T_BYTE:\n-        __ test_bit(t0, count, 2);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 2);\n+        __ beqz(tmp_reg, L_fill_2);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n+        __ sb(value, Address(to, 2));\n+        __ sb(value, Address(to, 3));\n         __ addi(to, to, 4);\n+\n         __ bind(L_fill_2);\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_1);\n-        __ sh(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_1);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n         __ addi(to, to, 2);\n+\n         __ bind(L_fill_1);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n         __ sb(value, Address(to, 0));\n         break;\n       case T_SHORT:\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n-        __ addi(to, to, 4);\n-        __ bind(L_fill_2);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_2);\n         __ sh(value, Address(to, 0));\n+        __ sh(value, Address(to, 2));\n+        __ addi(to, to, 4);\n+\n+        __ bind(L_fill_2);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n+        __ sh(value, Address(to, 0));\n         break;\n       case T_INT:\n-        __ beqz(count, L_exit1);\n+        __ beqz(count, L_exit);\n         __ sw(value, Address(to, 0));\n         break;\n       default: ShouldNotReachHere();\n     }\n-    __ bind(L_exit1);\n-    __ leave();\n-    __ ret();\n-\n-    // Handle copies less than 8 bytes.\n-    Label L_loop1, L_loop2, L_exit2;\n-    __ bind(L_fill_elements);\n-    __ beqz(count, L_exit2);\n-    switch (t) {\n-      case T_BYTE:\n-        __ bind(L_loop1);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n-        __ subiw(count, count, 1);\n-        __ bnez(count, L_loop1);\n-        break;\n-      case T_SHORT:\n-        __ bind(L_loop2);\n-        __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ subiw(count, count, 2 >> shift);\n-        __ bnez(count, L_loop2);\n-        break;\n-      case T_INT:\n-        __ sw(value, Address(to, 0));\n-        break;\n-      default: ShouldNotReachHere();\n-    }\n-    __ bind(L_exit2);\n+    __ bind(L_exit);\n     __ leave();\n     __ ret();", "source_url": "https://github.com/openjdk/riscv-port/commit/78d0dc75029dba7b4ba388f9a7f5f7b22e4b838e", "code_v0_no_empty_lines": "对于小尺寸数组填充，代码分为两个独立部分处理剩余字节（小于8字节），第一部分假设地址已对齐，使用sw/sh指令；第二部分处理未对齐情况，使用循环逐个字节/半字填充。这导致代码冗余、分支跳转多、循环开销大。", "code_v1_no_empty_lines": "-    // Remaining count is less than 8 bytes and address is heapword aligned.\n-    Label L_fill_1, L_fill_2, L_exit1;\n+    // Handle copies less than 8 bytes.\n+    // Address may not be heapword aligned.\n+    Label L_fill_1, L_fill_2, L_exit;\n+    __ bind(L_fill_elements);\n     switch (t) {\n       case T_BYTE:\n-        __ test_bit(t0, count, 2);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 2);\n+        __ beqz(tmp_reg, L_fill_2);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n+        __ sb(value, Address(to, 2));\n+        __ sb(value, Address(to, 3));\n         __ addi(to, to, 4);\n+\n         __ bind(L_fill_2);\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_1);\n-        __ sh(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_1);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n         __ addi(to, to, 2);\n+\n         __ bind(L_fill_1);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n         __ sb(value, Address(to, 0));\n         break;\n       case T_SHORT:\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n-        __ addi(to, to, 4);\n-        __ bind(L_fill_2);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_2);\n         __ sh(value, Address(to, 0));\n+        __ sh(value, Address(to, 2));\n+        __ addi(to, to, 4);\n+\n+        __ bind(L_fill_2);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n+        __ sh(value, Address(to, 0));\n         break;\n       case T_INT:\n-        __ beqz(count, L_exit1);\n+        __ beqz(count, L_exit);\n         __ sw(value, Address(to, 0));\n         break;\n       default: ShouldNotReachHere();\n     }\n-    __ bind(L_exit1);\n-    __ leave();\n-    __ ret();\n-\n-    // Handle copies less than 8 bytes.\n-    Label L_loop1, L_loop2, L_exit2;\n-    __ bind(L_fill_elements);\n-    __ beqz(count, L_exit2);\n-    switch (t) {\n-      case T_BYTE:\n-        __ bind(L_loop1);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n-        __ subiw(count, count, 1);\n-        __ bnez(count, L_loop1);\n-        break;\n-      case T_SHORT:\n-        __ bind(L_loop2);\n-        __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ subiw(count, count, 2 >> shift);\n-        __ bnez(count, L_loop2);\n-        break;\n-      case T_INT:\n-        __ sw(value, Address(to, 0));\n-        break;\n-      default: ShouldNotReachHere();\n-    }\n-    __ bind(L_exit2);\n+    __ bind(L_exit);\n     __ leave();\n     __ ret();", "target": "-    // Remaining count is less than 8 bytes and address is heapword aligned.\n-    Label L_fill_1, L_fill_2, L_exit1;\n+    // Handle copies less than 8 bytes.\n+    // Address may not be heapword aligned.\n+    Label L_fill_1, L_fill_2, L_exit;\n+    __ bind(L_fill_elements);\n     switch (t) {\n       case T_BYTE:\n-        __ test_bit(t0, count, 2);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 2);\n+        __ beqz(tmp_reg, L_fill_2);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n+        __ sb(value, Address(to, 2));\n+        __ sb(value, Address(to, 3));\n         __ addi(to, to, 4);\n+\n         __ bind(L_fill_2);\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_1);\n-        __ sh(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_1);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n         __ addi(to, to, 2);\n+\n         __ bind(L_fill_1);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n         __ sb(value, Address(to, 0));\n         break;\n       case T_SHORT:\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n-        __ addi(to, to, 4);\n-        __ bind(L_fill_2);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_2);\n         __ sh(value, Address(to, 0));\n+        __ sh(value, Address(to, 2));\n+        __ addi(to, to, 4);\n+\n+        __ bind(L_fill_2);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n+        __ sh(value, Address(to, 0));\n         break;\n       case T_INT:\n-        __ beqz(count, L_exit1);\n+        __ beqz(count, L_exit);\n         __ sw(value, Address(to, 0));\n         break;\n       default: ShouldNotReachHere();\n     }\n-    __ bind(L_exit1);\n-    __ leave();\n-    __ ret();\n-\n-    // Handle copies less than 8 bytes.\n-    Label L_loop1, L_loop2, L_exit2;\n-    __ bind(L_fill_elements);\n-    __ beqz(count, L_exit2);\n-    switch (t) {\n-      case T_BYTE:\n-        __ bind(L_loop1);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n-        __ subiw(count, count, 1);\n-        __ bnez(count, L_loop1);\n-        break;\n-      case T_SHORT:\n-        __ bind(L_loop2);\n-        __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ subiw(count, count, 2 >> shift);\n-        __ bnez(count, L_loop2);\n-        break;\n-      case T_INT:\n-        __ sw(value, Address(to, 0));\n-        break;\n-      default: ShouldNotReachHere();\n-    }\n-    __ bind(L_exit2);\n+    __ bind(L_exit);\n     __ leave();\n     __ ret();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于小尺寸数组填充，代码分为两个独立部分处理剩余字节（小于8字节），第一部分假设地址已对齐，使用sw/sh指令；第二部分处理未对齐情况，使用循环逐个字节/半字填充。这导致代码冗余、分支跳转多、循环开销大。\n优化后：合并两个处理路径，统一处理小于8字节的填充，不再假设地址对齐。通过位测试直接展开小循环，将循环展开为顺序的sb/sh指令序列，减少分支跳转和循环控制开销。\n优化思路：针对小尺寸数组填充场景，消除冗余代码路径，通过循环展开减少指令数量和分支预测失败，提高小数组填充操作的执行效率。"}
{"id": 35, "source": "riscv-dataset-excel", "optimization_type": "条件编译优化", "optimization_description": "优化前：CRC32 intrinsic 仅依赖 UseZba 或 UseRVV 指令集支持即可启用。优化后：增加 AvoidUnalignedAccesses == false 作为前置条件，避免在禁止非对齐访问的平台上启用可能导致性能下降的 intrinsic。优化思路：根据平台特性动态调整 intrinsic 启用策略，确保在支持非对齐访问的硬件上才启用 CRC32 优化，避免潜在的性能陷阱。", "original_code": "CRC32 intrinsic 仅依赖 UseZba 或 UseRVV 指令集支持即可启用。", "optimized_code": "-  if (UseZba || UseRVV) {\n+  if (!AvoidUnalignedAccesses && (UseZba || UseRVV)) {", "source_url": "https://github.com/openjdk/riscv-port/commit/65e63b6ab4241fc9d683e2ffa5bfe6e1a30059b6", "code_v0_no_empty_lines": "CRC32 intrinsic 仅依赖 UseZba 或 UseRVV 指令集支持即可启用。", "code_v1_no_empty_lines": "-  if (UseZba || UseRVV) {\n+  if (!AvoidUnalignedAccesses && (UseZba || UseRVV)) {", "target": "-  if (UseZba || UseRVV) {\n+  if (!AvoidUnalignedAccesses && (UseZba || UseRVV)) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CRC32 intrinsic 仅依赖 UseZba 或 UseRVV 指令集支持即可启用。优化后：增加 AvoidUnalignedAccesses == false 作为前置条件，避免在禁止非对齐访问的平台上启用可能导致性能下降的 intrinsic。优化思路：根据平台特性动态调整 intrinsic 启用策略，确保在支持非对齐访问的硬件上才启用 CRC32 优化，避免潜在的性能陷阱。"}
{"id": 36, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+性能优化", "optimization_description": "优化前：1. 短数组（<8字节）处理逻辑复杂，包含条件分支和可能的重叠存储。2. 值扩展操作使用额外寄存器移动指令（mv）。3. 代码结构不够清晰，存在冗余标签和分支。优化后：1. 重构短数组处理逻辑，将短数组（<8字节）直接通过循环按元素填充，避免复杂条件判断和潜在的重叠存储问题。2. 优化值扩展操作，消除不必要的寄存器移动指令（mv），直接对源寄存器进行移位操作。3. 重新组织代码结构，提前处理短数组分支，使控制流更清晰，减少标签数量。优化思路：通过简化短数组处理路径、消除冗余指令、优化寄存器使用，提高代码生成效率，减少分支预测开销，从而提升数组填充操作的性能。", "original_code": "1. 短数组（<8字节）处理逻辑复杂，包含条件分支和可能的重叠存储。2. 值扩展操作使用额外寄存器移动指令（mv）。3. 代码结构不够清晰，存在冗余标签和分支。", "optimized_code": "-    Label L_fill_elements, L_exit1;\n+    Label L_fill_elements;\n-        __ mv(tmp_reg, value);\n-        __ slli(tmp_reg, tmp_reg, 8);\n+        __ slli(tmp_reg, value, 8);\n-    // Remaining count is less than 8 bytes. Fill it by a single store.\n-    // Note that the total length is no less than 8 bytes.\n-    if (!AvoidUnalignedAccesses && (t == T_BYTE || t == T_SHORT)) {\n-      __ beqz(count, L_exit1);\n-      __ shadd(to, count, to, tmp_reg, shift); // points to the end\n-      __ sd(value, Address(to, -8)); // overwrite some elements\n-      __ bind(L_exit1);\n-      __ leave();\n-      __ ret();\n-    }\n-    // Handle copies less than 8 bytes.\n-    Label L_fill_2, L_fill_4, L_exit2;\n-    __ bind(L_fill_elements);\n+    // Remaining count is less than 8 bytes and address is heapword aligned.\n+    Label L_fill_2, L_fill_4, L_exit1;\n+    // ... (新增循环处理短数组的代码段)\n+    // Handle copies less than 8 bytes.\n+    Label L_loop1, L_loop2, L_exit2;\n+    __ bind(L_fill_elements);\n+    __ beqz(count, L_exit2);", "source_url": "https://github.com/openjdk/riscv-port/commit/d7cb933b89839b692f5562aeeb92076cd25a99f6", "code_v0_no_empty_lines": "1. 短数组（<8字节）处理逻辑复杂，包含条件分支和可能的重叠存储。2. 值扩展操作使用额外寄存器移动指令（mv）。3. 代码结构不够清晰，存在冗余标签和分支。", "code_v1_no_empty_lines": "-    Label L_fill_elements, L_exit1;\n+    Label L_fill_elements;\n-        __ mv(tmp_reg, value);\n-        __ slli(tmp_reg, tmp_reg, 8);\n+        __ slli(tmp_reg, value, 8);\n-    // Remaining count is less than 8 bytes. Fill it by a single store.\n-    // Note that the total length is no less than 8 bytes.\n-    if (!AvoidUnalignedAccesses && (t == T_BYTE || t == T_SHORT)) {\n-      __ beqz(count, L_exit1);\n-      __ shadd(to, count, to, tmp_reg, shift); // points to the end\n-      __ sd(value, Address(to, -8)); // overwrite some elements\n-      __ bind(L_exit1);\n-      __ leave();\n-      __ ret();\n-    }\n-    // Handle copies less than 8 bytes.\n-    Label L_fill_2, L_fill_4, L_exit2;\n-    __ bind(L_fill_elements);\n+    // Remaining count is less than 8 bytes and address is heapword aligned.\n+    Label L_fill_2, L_fill_4, L_exit1;\n+    // ... (新增循环处理短数组的代码段)\n+    // Handle copies less than 8 bytes.\n+    Label L_loop1, L_loop2, L_exit2;\n+    __ bind(L_fill_elements);\n+    __ beqz(count, L_exit2);", "target": "-    Label L_fill_elements, L_exit1;\n+    Label L_fill_elements;\n-        __ mv(tmp_reg, value);\n-        __ slli(tmp_reg, tmp_reg, 8);\n+        __ slli(tmp_reg, value, 8);\n-    // Remaining count is less than 8 bytes. Fill it by a single store.\n-    // Note that the total length is no less than 8 bytes.\n-    if (!AvoidUnalignedAccesses && (t == T_BYTE || t == T_SHORT)) {\n-      __ beqz(count, L_exit1);\n-      __ shadd(to, count, to, tmp_reg, shift); // points to the end\n-      __ sd(value, Address(to, -8)); // overwrite some elements\n-      __ bind(L_exit1);\n-      __ leave();\n-      __ ret();\n-    }\n-    // Handle copies less than 8 bytes.\n-    Label L_fill_2, L_fill_4, L_exit2;\n-    __ bind(L_fill_elements);\n+    // Remaining count is less than 8 bytes and address is heapword aligned.\n+    Label L_fill_2, L_fill_4, L_exit1;\n+    // ... (新增循环处理短数组的代码段)\n+    // Handle copies less than 8 bytes.\n+    Label L_loop1, L_loop2, L_exit2;\n+    __ bind(L_fill_elements);\n+    __ beqz(count, L_exit2);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 短数组（<8字节）处理逻辑复杂，包含条件分支和可能的重叠存储。2. 值扩展操作使用额外寄存器移动指令（mv）。3. 代码结构不够清晰，存在冗余标签和分支。优化后：1. 重构短数组处理逻辑，将短数组（<8字节）直接通过循环按元素填充，避免复杂条件判断和潜在的重叠存储问题。2. 优化值扩展操作，消除不必要的寄存器移动指令（mv），直接对源寄存器进行移位操作。3. 重新组织代码结构，提前处理短数组分支，使控制流更清晰，减少标签数量。优化思路：通过简化短数组处理路径、消除冗余指令、优化寄存器使用，提高代码生成效率，减少分支预测开销，从而提升数组填充操作的性能。"}
{"id": 37, "source": "riscv-dataset-excel", "optimization_type": "指令优化+内存访问优化", "optimization_description": "优化前：数组填充stub在处理尾部剩余元素时，按字节、半字、字的顺序处理，可能导致多次内存访问和指令执行。优化后：重新排序处理逻辑，优先处理更大的内存块（字操作），减少内存访问次数和指令数。优化思路：通过调整位测试顺序和内存操作顺序，减少小内存操作，提高缓存利用率和指令执行效率。", "original_code": "数组填充stub在处理尾部剩余元素时，按字节、半字、字的顺序处理，可能导致多次内存访问和指令执行。", "optimized_code": "-    Label L_fill_2, L_fill_4, L_exit1;\n+    Label L_fill_1, L_fill_2, L_exit1;\n       case T_BYTE:\n-        __ test_bit(t0, count, 0);\n+        __ test_bit(t0, count, 2);\n         __ beqz(t0, L_fill_2);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n+        __ sw(value, Address(to, 0));\n+        __ addi(to, to, 4);\n         __ bind(L_fill_2);\n         __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_4);\n+        __ beqz(t0, L_fill_1);\n         __ sh(value, Address(to, 0));\n         __ addi(to, to, 2);\n-        __ bind(L_fill_4);\n-        __ test_bit(t0, count, 2);\n+        __ bind(L_fill_1);\n+        __ test_bit(t0, count, 0);\n         __ beqz(t0, L_exit1);\n-        __ sw(value, Address(to, 0));\n+        __ sb(value, Address(to, 0));\n         break;\n       case T_SHORT:\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_fill_4);\n-        __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ bind(L_fill_4);\n         __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_exit1);\n+        __ beqz(t0, L_fill_2);\n         __ sw(value, Address(to, 0));\n+        __ addi(to, to, 4);\n+        __ bind(L_fill_2);\n+        __ test_bit(t0, count, 0);\n+        __ beqz(t0, L_exit1);\n+        __ sh(value, Address(to, 0));\n         break;", "source_url": "https://github.com/openjdk/riscv-port/commit/b76b610788cea7149a04faeeba01067272b6e046", "code_v0_no_empty_lines": "数组填充stub在处理尾部剩余元素时，按字节、半字、字的顺序处理，可能导致多次内存访问和指令执行。", "code_v1_no_empty_lines": "-    Label L_fill_2, L_fill_4, L_exit1;\n+    Label L_fill_1, L_fill_2, L_exit1;\n       case T_BYTE:\n-        __ test_bit(t0, count, 0);\n+        __ test_bit(t0, count, 2);\n         __ beqz(t0, L_fill_2);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n+        __ sw(value, Address(to, 0));\n+        __ addi(to, to, 4);\n         __ bind(L_fill_2);\n         __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_4);\n+        __ beqz(t0, L_fill_1);\n         __ sh(value, Address(to, 0));\n         __ addi(to, to, 2);\n-        __ bind(L_fill_4);\n-        __ test_bit(t0, count, 2);\n+        __ bind(L_fill_1);\n+        __ test_bit(t0, count, 0);\n         __ beqz(t0, L_exit1);\n-        __ sw(value, Address(to, 0));\n+        __ sb(value, Address(to, 0));\n         break;\n       case T_SHORT:\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_fill_4);\n-        __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ bind(L_fill_4);\n         __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_exit1);\n+        __ beqz(t0, L_fill_2);\n         __ sw(value, Address(to, 0));\n+        __ addi(to, to, 4);\n+        __ bind(L_fill_2);\n+        __ test_bit(t0, count, 0);\n+        __ beqz(t0, L_exit1);\n+        __ sh(value, Address(to, 0));\n         break;", "target": "-    Label L_fill_2, L_fill_4, L_exit1;\n+    Label L_fill_1, L_fill_2, L_exit1;\n       case T_BYTE:\n-        __ test_bit(t0, count, 0);\n+        __ test_bit(t0, count, 2);\n         __ beqz(t0, L_fill_2);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n+        __ sw(value, Address(to, 0));\n+        __ addi(to, to, 4);\n         __ bind(L_fill_2);\n         __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_4);\n+        __ beqz(t0, L_fill_1);\n         __ sh(value, Address(to, 0));\n         __ addi(to, to, 2);\n-        __ bind(L_fill_4);\n-        __ test_bit(t0, count, 2);\n+        __ bind(L_fill_1);\n+        __ test_bit(t0, count, 0);\n         __ beqz(t0, L_exit1);\n-        __ sw(value, Address(to, 0));\n+        __ sb(value, Address(to, 0));\n         break;\n       case T_SHORT:\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_fill_4);\n-        __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ bind(L_fill_4);\n         __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_exit1);\n+        __ beqz(t0, L_fill_2);\n         __ sw(value, Address(to, 0));\n+        __ addi(to, to, 4);\n+        __ bind(L_fill_2);\n+        __ test_bit(t0, count, 0);\n+        __ beqz(t0, L_exit1);\n+        __ sh(value, Address(to, 0));\n         break;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：数组填充stub在处理尾部剩余元素时，按字节、半字、字的顺序处理，可能导致多次内存访问和指令执行。优化后：重新排序处理逻辑，优先处理更大的内存块（字操作），减少内存访问次数和指令数。优化思路：通过调整位测试顺序和内存操作顺序，减少小内存操作，提高缓存利用率和指令执行效率。"}
{"id": 38, "source": "riscv-dataset-excel", "optimization_type": "指令调度优化+内存访问优化", "optimization_description": "优化前：1. LU/UL字符串比较分支中，先执行内存加载指令再检查阈值，可能导致不必要的内存访问；2. 对齐处理条件判断逻辑错误，当base_offset1不是8字节对齐时反而执行对齐操作。优化后：1. 将阈值检查提前到内存加载之前，避免在需要跳转到stub时执行无效的内存加载，减少缓存污染和指令执行开销；2. 修正对齐条件判断逻辑，仅在需要时才执行对齐加载操作。优化思路：通过指令调度减少不必要的内存访问，修正对齐处理逻辑，提升RISC-V平台在特定编译选项下的字符串比较性能。", "original_code": "1. LU/UL字符串比较分支中，先执行内存加载指令再检查阈值，可能导致不必要的内存访问；2. 对齐处理条件判断逻辑错误，当base_offset1不是8字节对齐时反而执行对齐操作。", "optimized_code": "1. c2_MacroAssembler_riscv.cpp中LU/UL分支的指令重排：\n- lwu(tmp1, Address(str1));\n- load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n+ mv(t0, STUB_THRESHOLD);\n+ bge(cnt2, t0, STUB);\n+ lwu(tmp1, Address(str1));\n+ load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n\n2. stubGenerator_riscv.cpp中条件判断逻辑修正：\n- if (AvoidUnalignedAccesses && (base_offset1 % 8) == 0) {\n+ if (AvoidUnalignedAccesses && (base_offset1 % 8) != 0) {", "source_url": "https://github.com/openjdk/riscv-port/commit/d104debe51d8feb35b7c672a9d05404208bc5526", "code_v0_no_empty_lines": "1. LU/UL字符串比较分支中，先执行内存加载指令再检查阈值，可能导致不必要的内存访问；2. 对齐处理条件判断逻辑错误，当base_offset1不是8字节对齐时反而执行对齐操作。", "code_v1_no_empty_lines": "1. c2_MacroAssembler_riscv.cpp中LU/UL分支的指令重排：\n- lwu(tmp1, Address(str1));\n- load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n+ mv(t0, STUB_THRESHOLD);\n+ bge(cnt2, t0, STUB);\n+ lwu(tmp1, Address(str1));\n+ load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n\n2. stubGenerator_riscv.cpp中条件判断逻辑修正：\n- if (AvoidUnalignedAccesses && (base_offset1 % 8) == 0) {\n+ if (AvoidUnalignedAccesses && (base_offset1 % 8) != 0) {", "target": "1. c2_MacroAssembler_riscv.cpp中LU/UL分支的指令重排：\n- lwu(tmp1, Address(str1));\n- load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n+ mv(t0, STUB_THRESHOLD);\n+ bge(cnt2, t0, STUB);\n+ lwu(tmp1, Address(str1));\n+ load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n\n2. stubGenerator_riscv.cpp中条件判断逻辑修正：\n- if (AvoidUnalignedAccesses && (base_offset1 % 8) == 0) {\n+ if (AvoidUnalignedAccesses && (base_offset1 % 8) != 0) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. LU/UL字符串比较分支中，先执行内存加载指令再检查阈值，可能导致不必要的内存访问；2. 对齐处理条件判断逻辑错误，当base_offset1不是8字节对齐时反而执行对齐操作。优化后：1. 将阈值检查提前到内存加载之前，避免在需要跳转到stub时执行无效的内存加载，减少缓存污染和指令执行开销；2. 修正对齐条件判断逻辑，仅在需要时才执行对齐加载操作。优化思路：通过指令调度减少不必要的内存访问，修正对齐处理逻辑，提升RISC-V平台在特定编译选项下的字符串比较性能。"}
{"id": 39, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "优化前：\nClass.isInstance(obj) → 走通用入口/慢路径 → 多次调用与判断，最后才告诉你结果。\n\n优化后：\nC1 生成 is_instance_of 专用桩 → 用 super_check_offset 直接快判，直接读目标类的类型指针和对象的类型指针，（不命中再查 secondary 表）→ 在寄存器返回结果 0/1。\n\n效果：\n减少调用与分支 → 判定速度明显提升。", "original_code": "Class.isInstance(obj) → 走通用入口/慢路径 → 多次调用与判断，最后才告诉你结果。", "optimized_code": "- return CAST_FROM_FN_PTR(address, Runtime1::is_instance_of);\n+ return Runtime1::entry_for(C1StubId::is_instance_of_id);\n\ncase C1StubId::is_instance_of_id:\n{\n  // 寄存器分配优化\n  Register klass = x16, obj = x11, result = x10;\n  \n  // 快速失败检查\n  Label fail, is_secondary, success;\n  __ beqz(klass, fail);  // Klass为空则失败\n  __ beqz(obj, fail);    // 对象为空则失败\n  \n  // 具体类检查路径\n  __ lwu(x13, Address(klass, in_bytes(Klass::super_check_offset_offset())));\n  __ mv(x17, in_bytes(Klass::secondary_super_cache_offset()));\n  __ beq(x13, x17, is_secondary); // 跳转到次级超类检查\n  \n  // 具体类快速检查\n  __ load_klass(x15, obj);\n  __ add(x17, x15, x13);\n  __ ld(x17, Address(x17));\n  __ beq(klass, x17, success); // 匹配则成功\n  \n  // 次级超类检查路径\n  __ bind(is_secondary);\n  __ load_klass(obj, obj);\n  __ beq(obj, klass, success); // 自引用检查\n  \n  // 查表检查次级超类\n  __ lookup_secondary_supers_table_var(obj, klass, result, x13, x14, x15, x17, &success);\n  \n  // 结果处理\n  __ bind(fail);\n  __ mv(result, 0);\n  __ ret();\n  \n  __ bind(success);\n  __ mv(result, 1);\n  __ ret();\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/b3a4026c65eb049eb4f3a3cbf52c9f0c9979a256", "code_v0_no_empty_lines": "Class.isInstance(obj) → 走通用入口/慢路径 → 多次调用与判断，最后才告诉你结果。", "code_v1_no_empty_lines": "- return CAST_FROM_FN_PTR(address, Runtime1::is_instance_of);\n+ return Runtime1::entry_for(C1StubId::is_instance_of_id);\n\ncase C1StubId::is_instance_of_id:\n{\n  // 寄存器分配优化\n  Register klass = x16, obj = x11, result = x10;\n  \n  // 快速失败检查\n  Label fail, is_secondary, success;\n  __ beqz(klass, fail);  // Klass为空则失败\n  __ beqz(obj, fail);    // 对象为空则失败\n  \n  // 具体类检查路径\n  __ lwu(x13, Address(klass, in_bytes(Klass::super_check_offset_offset())));\n  __ mv(x17, in_bytes(Klass::secondary_super_cache_offset()));\n  __ beq(x13, x17, is_secondary); // 跳转到次级超类检查\n  \n  // 具体类快速检查\n  __ load_klass(x15, obj);\n  __ add(x17, x15, x13);\n  __ ld(x17, Address(x17));\n  __ beq(klass, x17, success); // 匹配则成功\n  \n  // 次级超类检查路径\n  __ bind(is_secondary);\n  __ load_klass(obj, obj);\n  __ beq(obj, klass, success); // 自引用检查\n  \n  // 查表检查次级超类\n  __ lookup_secondary_supers_table_var(obj, klass, result, x13, x14, x15, x17, &success);\n  \n  // 结果处理\n  __ bind(fail);\n  __ mv(result, 0);\n  __ ret();\n  \n  __ bind(success);\n  __ mv(result, 1);\n  __ ret();\n}", "target": "- return CAST_FROM_FN_PTR(address, Runtime1::is_instance_of);\n+ return Runtime1::entry_for(C1StubId::is_instance_of_id);\n\ncase C1StubId::is_instance_of_id:\n{\n  // 寄存器分配优化\n  Register klass = x16, obj = x11, result = x10;\n  \n  // 快速失败检查\n  Label fail, is_secondary, success;\n  __ beqz(klass, fail);  // Klass为空则失败\n  __ beqz(obj, fail);    // 对象为空则失败\n  \n  // 具体类检查路径\n  __ lwu(x13, Address(klass, in_bytes(Klass::super_check_offset_offset())));\n  __ mv(x17, in_bytes(Klass::secondary_super_cache_offset()));\n  __ beq(x13, x17, is_secondary); // 跳转到次级超类检查\n  \n  // 具体类快速检查\n  __ load_klass(x15, obj);\n  __ add(x17, x15, x13);\n  __ ld(x17, Address(x17));\n  __ beq(klass, x17, success); // 匹配则成功\n  \n  // 次级超类检查路径\n  __ bind(is_secondary);\n  __ load_klass(obj, obj);\n  __ beq(obj, klass, success); // 自引用检查\n  \n  // 查表检查次级超类\n  __ lookup_secondary_supers_table_var(obj, klass, result, x13, x14, x15, x17, &success);\n  \n  // 结果处理\n  __ bind(fail);\n  __ mv(result, 0);\n  __ ret();\n  \n  __ bind(success);\n  __ mv(result, 1);\n  __ ret();\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：\nClass.isInstance(obj) → 走通用入口/慢路径 → 多次调用与判断，最后才告诉你结果。\n\n优化后：\nC1 生成 is_instance_of 专用桩 → 用 super_check_offset 直接快判，直接读目标类的类型指针和对象的类型指针，（不命中再查 secondary 表）→ 在寄存器返回结果 0/1。\n\n效果：\n减少调用与分支 → 判定速度明显提升。"}
{"id": 40, "source": "riscv-dataset-excel", "optimization_type": "指令优化+位运算优化", "optimization_description": "优化前使用zero_extend/sign_extend宏和andi指令进行位掩码操作，涉及多个指令组合。优化后统一使用zext/sext专用指令，直接实现零扩展和符号扩展功能。思路：利用RISC-V架构的专用扩展指令替代通用指令组合，减少指令数量，提高位运算和类型转换操作的执行效率。", "original_code": "// No original code extracted from description\n", "optimized_code": "- __ zero_extend(t1, t1, shift);\n+ __ zext(t1, t1, shift);\n- __ sign_extend(dest->as_register(), src->as_register(), 16);\n+ __ sext(dest->as_register(), src->as_register(), 16);\n- __ andi(tmp1, tmp1, 0xFF);\n+ __ zext(tmp1, tmp1, 8);", "source_url": "https://github.com/openjdk/riscv-port/commit/a7631ccf18e468d6ecba121865f7fed29cbf2186", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- __ zero_extend(t1, t1, shift);\n+ __ zext(t1, t1, shift);\n- __ sign_extend(dest->as_register(), src->as_register(), 16);\n+ __ sext(dest->as_register(), src->as_register(), 16);\n- __ andi(tmp1, tmp1, 0xFF);\n+ __ zext(tmp1, tmp1, 8);", "target": "- __ zero_extend(t1, t1, shift);\n+ __ zext(t1, t1, shift);\n- __ sign_extend(dest->as_register(), src->as_register(), 16);\n+ __ sext(dest->as_register(), src->as_register(), 16);\n- __ andi(tmp1, tmp1, 0xFF);\n+ __ zext(tmp1, tmp1, 8);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用zero_extend/sign_extend宏和andi指令进行位掩码操作，涉及多个指令组合。优化后统一使用zext/sext专用指令，直接实现零扩展和符号扩展功能。思路：利用RISC-V架构的专用扩展指令替代通用指令组合，减少指令数量，提高位运算和类型转换操作的执行效率。"}
{"id": 41, "source": "riscv-dataset-excel", "optimization_type": "指令优化+代码清理", "optimization_description": "优化前：存在多个冗余的字节反转函数（revb_h_h、revb_w_w、revb_h_helper、revb_h），代码重复且复杂，特别是非ZBB扩展路径使用多步位操作。优化后：1. 删除冗余函数，统一使用revb_w处理带符号扩展的字反转；2. 简化非ZBB路径，使用循环和位操作替代复杂的分步计算；3. 在汇编指令中直接内联rev8和移位操作，减少函数调用开销。优化思路：利用RISC-V ZBB扩展的rev8指令统一处理字节反转，简化代码结构，提高执行效率，同时清理未使用的函数减少维护成本。", "original_code": "存在多个冗余的字节反转函数（revb_h_h、revb_w_w、revb_h_helper、revb_h），代码重复且复杂，特别是非ZBB扩展路径使用多步位操作。", "optimized_code": "- void MacroAssembler::revb_h_h(Register Rd, Register Rs, Register tmp) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 48);\n    return;\n  }\n  ...\n}\n- void MacroAssembler::revb_w_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 32);\n    return;\n  }\n  ...\n}\n+ void MacroAssembler::revb_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 32);\n    return;\n  }\n  ...\n  sign_extend(Rd, Rd, 32);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/08d563ba15047020fd5f5fea80547e18898bbab2", "code_v0_no_empty_lines": "存在多个冗余的字节反转函数（revb_h_h、revb_w_w、revb_h_helper、revb_h），代码重复且复杂，特别是非ZBB扩展路径使用多步位操作。", "code_v1_no_empty_lines": "- void MacroAssembler::revb_h_h(Register Rd, Register Rs, Register tmp) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 48);\n    return;\n  }\n  ...\n}\n- void MacroAssembler::revb_w_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 32);\n    return;\n  }\n  ...\n}\n+ void MacroAssembler::revb_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 32);\n    return;\n  }\n  ...\n  sign_extend(Rd, Rd, 32);\n}", "target": "- void MacroAssembler::revb_h_h(Register Rd, Register Rs, Register tmp) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 48);\n    return;\n  }\n  ...\n}\n- void MacroAssembler::revb_w_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 32);\n    return;\n  }\n  ...\n}\n+ void MacroAssembler::revb_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 32);\n    return;\n  }\n  ...\n  sign_extend(Rd, Rd, 32);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：存在多个冗余的字节反转函数（revb_h_h、revb_w_w、revb_h_helper、revb_h），代码重复且复杂，特别是非ZBB扩展路径使用多步位操作。优化后：1. 删除冗余函数，统一使用revb_w处理带符号扩展的字反转；2. 简化非ZBB路径，使用循环和位操作替代复杂的分步计算；3. 在汇编指令中直接内联rev8和移位操作，减少函数调用开销。优化思路：利用RISC-V ZBB扩展的rev8指令统一处理字节反转，简化代码结构，提高执行效率，同时清理未使用的函数减少维护成本。"}
{"id": 42, "source": "riscv-dataset-excel", "optimization_type": "指令优化+代码生成优化", "optimization_description": "优化前：使用la指令加载运行时地址（需要6条指令：lui + addi + slli + addi + slli + addi），然后调用jalr。优化后：使用movptr指令（需要4条指令：lui + lui + slli + add）加载地址，配合jalr调用。思路：减少从11条指令到9条指令的指令数量，通过更高效的地址加载方式（movptr替代la）和优化调用序列，提升运行时调用的性能。", "original_code": "使用la指令加载运行时地址（需要6条指令：lui + addi + slli + addi + slli + addi），然后调用jalr。", "optimized_code": "- __ la(t1, RuntimeAddress(entry));\n- __ jalr(t1);\n+ int32_t offset = 0;\n+ // No relocation needed\n+ __ movptr(t1, entry, offset, t0); // lui + lui + slli + add\n+ __ jalr(t1, offset);", "source_url": "https://github.com/openjdk/riscv-port/commit/cbda758010c22b0c1b9aec16004d4bfd24ab5c81", "code_v0_no_empty_lines": "使用la指令加载运行时地址（需要6条指令：lui + addi + slli + addi + slli + addi），然后调用jalr。", "code_v1_no_empty_lines": "- __ la(t1, RuntimeAddress(entry));\n- __ jalr(t1);\n+ int32_t offset = 0;\n+ // No relocation needed\n+ __ movptr(t1, entry, offset, t0); // lui + lui + slli + add\n+ __ jalr(t1, offset);", "target": "- __ la(t1, RuntimeAddress(entry));\n- __ jalr(t1);\n+ int32_t offset = 0;\n+ // No relocation needed\n+ __ movptr(t1, entry, offset, t0); // lui + lui + slli + add\n+ __ jalr(t1, offset);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用la指令加载运行时地址（需要6条指令：lui + addi + slli + addi + slli + addi），然后调用jalr。优化后：使用movptr指令（需要4条指令：lui + lui + slli + add）加载地址，配合jalr调用。思路：减少从11条指令到9条指令的指令数量，通过更高效的地址加载方式（movptr替代la）和优化调用序列，提升运行时调用的性能。"}
{"id": 43, "source": "riscv-dataset-excel", "optimization_type": "指令优化+代码精简", "optimization_description": "优化前：通过调用load_narrow_klass_compact_c2函数来加载压缩类指针，该函数包含地址计算和位移操作，增加了函数调用开销。优化后：直接在指令模板中使用lwu和srli两条指令内联实现，消除了函数调用开销，精简了代码。优化思路：将专用函数调用替换为直接的内联汇编指令，减少间接调用，提高指令执行效率，同时简化代码结构。", "original_code": "通过调用load_narrow_klass_compact_c2函数来加载压缩类指针，该函数包含地址计算和位移操作，增加了函数调用开销。", "optimized_code": "-  format %{ \"load_narrow_klass_compact $dst, $mem\\t# compressed class ptr, #@loadNKlassCompactHeaders\" %}\n-  ins_encode %{\n-    __ load_narrow_klass_compact_c2(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n-  %}\n+  format %{\n+    \"lwu  $dst, $mem\\t# compressed klass ptr, shifted\\n\\t\"\n+    \"srli $dst, $dst, markWord::klass_shift_at_offset\"\n+  %}\n+  ins_encode %{\n+    __ lwu(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n+    __ srli(as_Register($dst$$reg), as_Register($dst$$reg), (unsigned) markWord::klass_shift_at_offset);\n+  %}", "source_url": "https://github.com/openjdk/riscv-port/commit/dc940ec8afcd3cd12ed3785d547f4cd602f65c15", "code_v0_no_empty_lines": "通过调用load_narrow_klass_compact_c2函数来加载压缩类指针，该函数包含地址计算和位移操作，增加了函数调用开销。", "code_v1_no_empty_lines": "-  format %{ \"load_narrow_klass_compact $dst, $mem\\t# compressed class ptr, #@loadNKlassCompactHeaders\" %}\n-  ins_encode %{\n-    __ load_narrow_klass_compact_c2(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n-  %}\n+  format %{\n+    \"lwu  $dst, $mem\\t# compressed klass ptr, shifted\\n\\t\"\n+    \"srli $dst, $dst, markWord::klass_shift_at_offset\"\n+  %}\n+  ins_encode %{\n+    __ lwu(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n+    __ srli(as_Register($dst$$reg), as_Register($dst$$reg), (unsigned) markWord::klass_shift_at_offset);\n+  %}", "target": "-  format %{ \"load_narrow_klass_compact $dst, $mem\\t# compressed class ptr, #@loadNKlassCompactHeaders\" %}\n-  ins_encode %{\n-    __ load_narrow_klass_compact_c2(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n-  %}\n+  format %{\n+    \"lwu  $dst, $mem\\t# compressed klass ptr, shifted\\n\\t\"\n+    \"srli $dst, $dst, markWord::klass_shift_at_offset\"\n+  %}\n+  ins_encode %{\n+    __ lwu(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n+    __ srli(as_Register($dst$$reg), as_Register($dst$$reg), (unsigned) markWord::klass_shift_at_offset);\n+  %}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：通过调用load_narrow_klass_compact_c2函数来加载压缩类指针，该函数包含地址计算和位移操作，增加了函数调用开销。优化后：直接在指令模板中使用lwu和srli两条指令内联实现，消除了函数调用开销，精简了代码。优化思路：将专用函数调用替换为直接的内联汇编指令，减少间接调用，提高指令执行效率，同时简化代码结构。"}
{"id": 44, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+内存访问优化", "optimization_description": "优化前：C2 SuperWord自动向量化时，存在store-to-load forwarding失败导致性能回归的问题。优化后：新增SuperWordStoreToLoadForwardingFailureDetection全局配置参数，并在向量化调度阶段检测store-to-load forwarding失败，若检测到失败则放弃向量化以避免性能下降。思路：通过检测内存访问模式中的store-to-load依赖问题，避免因向量化导致的内存访问冲突，从而修复性能回归。", "original_code": "C2 SuperWord自动向量化时，存在store-to-load forwarding失败导致性能回归的问题。", "optimized_code": "if (!vtransform.schedule()) { return false; }\n+ if (vtransform.has_store_to_load_forwarding_failure()) { return false; }\nvtransform.apply();", "source_url": "https://github.com/openjdk/riscv-port/commit/75420e9314c54adc5b45f9b274a87af54dd6b5a8", "code_v0_no_empty_lines": "C2 SuperWord自动向量化时，存在store-to-load forwarding失败导致性能回归的问题。", "code_v1_no_empty_lines": "if (!vtransform.schedule()) { return false; }\n+ if (vtransform.has_store_to_load_forwarding_failure()) { return false; }\nvtransform.apply();", "target": "if (!vtransform.schedule()) { return false; }\n+ if (vtransform.has_store_to_load_forwarding_failure()) { return false; }\nvtransform.apply();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2 SuperWord自动向量化时，存在store-to-load forwarding失败导致性能回归的问题。优化后：新增SuperWordStoreToLoadForwardingFailureDetection全局配置参数，并在向量化调度阶段检测store-to-load forwarding失败，若检测到失败则放弃向量化以避免性能下降。思路：通过检测内存访问模式中的store-to-load依赖问题，避免因向量化导致的内存访问冲突，从而修复性能回归。"}
{"id": 45, "source": "riscv-dataset-excel", "optimization_type": "指令优化", "optimization_description": "优化前：使用寄存器minusOne存储常量-1，通过bne指令比较failedIdx与-1。优化后：移除minusOne寄存器及其初始化，利用failedIdx为负时仅可能为-1的特性，改用bgez指令直接检查failedIdx是否非负。思路：减少一条寄存器加载指令和寄存器占用，利用已知值域特性简化比较逻辑，提升指令效率。", "original_code": "使用寄存器minusOne存储常量-1，通过bne指令比较failedIdx与-1。", "optimized_code": "-      Register minusOne  = x30;   // t5\n\n-      __ mv(minusOne, -1);\n...\n-      __ bne(failedIdx, minusOne, Exit);\n+      // valid value of failedIdx can only be -1 when < 0\n+      __ bgez(failedIdx, Exit);", "source_url": "https://github.com/openjdk/riscv-port/commit/3ad6e31d81bb8a47dc73a6342a6524a901f07687", "code_v0_no_empty_lines": "使用寄存器minusOne存储常量-1，通过bne指令比较failedIdx与-1。", "code_v1_no_empty_lines": "-      Register minusOne  = x30;   // t5\n\n-      __ mv(minusOne, -1);\n...\n-      __ bne(failedIdx, minusOne, Exit);\n+      // valid value of failedIdx can only be -1 when < 0\n+      __ bgez(failedIdx, Exit);", "target": "-      Register minusOne  = x30;   // t5\n\n-      __ mv(minusOne, -1);\n...\n-      __ bne(failedIdx, minusOne, Exit);\n+      // valid value of failedIdx can only be -1 when < 0\n+      __ bgez(failedIdx, Exit);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用寄存器minusOne存储常量-1，通过bne指令比较failedIdx与-1。优化后：移除minusOne寄存器及其初始化，利用failedIdx为负时仅可能为-1的特性，改用bgez指令直接检查failedIdx是否非负。思路：减少一条寄存器加载指令和寄存器占用，利用已知值域特性简化比较逻辑，提升指令效率。"}
{"id": 46, "source": "riscv-dataset-excel", "optimization_type": "指令优化+向量化优化", "optimization_description": "优化前：在RISC-V向量gather load和scatter store指令中，需要先将索引寄存器复制到目标/临时寄存器，再对复制后的寄存器进行移位操作，产生冗余的vmv1r_v指令。优化后：直接对原始索引寄存器进行移位操作，消除了不必要的寄存器复制指令。思路：通过分析指令依赖关系，发现索引寄存器可以直接用于移位操作，无需先复制到其他寄存器，从而减少指令数量，提升向量内存操作的性能。", "original_code": "在RISC-V向量gather load和scatter store指令中，需要先将索引寄存器复制到目标/临时寄存器，再对复制后的寄存器进行移位操作，产生冗余的vmv1r_v指令。", "optimized_code": "- __ vmv1r_v(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg));\n- __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg), (int)sew);\n+ __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg), (int)sew);", "source_url": "https://github.com/openjdk/riscv-port/commit/88801caef6ccdc5ba9ade2af830f3b3cd96e1467", "code_v0_no_empty_lines": "在RISC-V向量gather load和scatter store指令中，需要先将索引寄存器复制到目标/临时寄存器，再对复制后的寄存器进行移位操作，产生冗余的vmv1r_v指令。", "code_v1_no_empty_lines": "- __ vmv1r_v(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg));\n- __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg), (int)sew);\n+ __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg), (int)sew);", "target": "- __ vmv1r_v(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg));\n- __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg), (int)sew);\n+ __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg), (int)sew);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在RISC-V向量gather load和scatter store指令中，需要先将索引寄存器复制到目标/临时寄存器，再对复制后的寄存器进行移位操作，产生冗余的vmv1r_v指令。优化后：直接对原始索引寄存器进行移位操作，消除了不必要的寄存器复制指令。思路：通过分析指令依赖关系，发现索引寄存器可以直接用于移位操作，无需先复制到其他寄存器，从而减少指令数量，提升向量内存操作的性能。"}
{"id": 47, "source": "riscv-dataset-excel", "optimization_type": "向量化数学运算优化", "optimization_description": "优化前：RISC-V平台上的向量数学运算（如sin、cos等）缺乏专门的向量化实现，无法充分利用RISC-V向量扩展（RVV）硬件加速能力。优化后：1. 集成SLEEF向量数学库，为RISC-V平台提供高性能的向量数学函数实现；2. 实现向量调用约定支持，包括向量参数传递和返回值处理；3. 添加向量数学stub生成器，动态加载SLEEF库函数；4. 在构建系统中添加libsleef编译支持。优化思路：通过引入成熟的SLEEF向量数学库，利用RVV指令集对向量数学运算进行硬件加速，显著提升Java Vector API在RISC-V平台上的数学运算性能。", "original_code": "RISC-V平台上的向量数学运算（如sin、cos等）缺乏专门的向量化实现，无法充分利用RISC-V向量扩展（RVV）硬件加速能力。", "optimized_code": "diff --git a/src/hotspot/cpu/riscv/riscv.ad b/src/hotspot/cpu/riscv/riscv.ad\nindex 563dfd4cde9..a76d1722670 100644\n--- a/src/hotspot/cpu/riscv/riscv.ad\n+++ b/src/hotspot/cpu/riscv/riscv.ad\n@@ -1972,12 +1972,16 @@ const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length)\n \n // Vector calling convention not yet implemented.\n bool Matcher::supports_vector_calling_convention(void) {\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n }\n \n OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(ideal_reg == Op_VecA, \"sanity\");\n+  // check more info at https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc\n+  int lo = V8_num;\n+  int hi = V8_K_num;\n+  return OptoRegPair(hi, lo);\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/580eb62dc097efeb51c76b095c1404106859b673", "code_v0_no_empty_lines": "RISC-V平台上的向量数学运算（如sin、cos等）缺乏专门的向量化实现，无法充分利用RISC-V向量扩展（RVV）硬件加速能力。", "code_v1_no_empty_lines": "diff --git a/src/hotspot/cpu/riscv/riscv.ad b/src/hotspot/cpu/riscv/riscv.ad\nindex 563dfd4cde9..a76d1722670 100644\n--- a/src/hotspot/cpu/riscv/riscv.ad\n+++ b/src/hotspot/cpu/riscv/riscv.ad\n@@ -1972,12 +1972,16 @@ const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length)\n \n // Vector calling convention not yet implemented.\n bool Matcher::supports_vector_calling_convention(void) {\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n }\n \n OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(ideal_reg == Op_VecA, \"sanity\");\n+  // check more info at https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc\n+  int lo = V8_num;\n+  int hi = V8_K_num;\n+  return OptoRegPair(hi, lo);\n }", "target": "diff --git a/src/hotspot/cpu/riscv/riscv.ad b/src/hotspot/cpu/riscv/riscv.ad\nindex 563dfd4cde9..a76d1722670 100644\n--- a/src/hotspot/cpu/riscv/riscv.ad\n+++ b/src/hotspot/cpu/riscv/riscv.ad\n@@ -1972,12 +1972,16 @@ const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length)\n \n // Vector calling convention not yet implemented.\n bool Matcher::supports_vector_calling_convention(void) {\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n }\n \n OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(ideal_reg == Op_VecA, \"sanity\");\n+  // check more info at https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc\n+  int lo = V8_num;\n+  int hi = V8_K_num;\n+  return OptoRegPair(hi, lo);\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V平台上的向量数学运算（如sin、cos等）缺乏专门的向量化实现，无法充分利用RISC-V向量扩展（RVV）硬件加速能力。优化后：1. 集成SLEEF向量数学库，为RISC-V平台提供高性能的向量数学函数实现；2. 实现向量调用约定支持，包括向量参数传递和返回值处理；3. 添加向量数学stub生成器，动态加载SLEEF库函数；4. 在构建系统中添加libsleef编译支持。优化思路：通过引入成熟的SLEEF向量数学库，利用RVV指令集对向量数学运算进行硬件加速，显著提升Java Vector API在RISC-V平台上的数学运算性能。"}
{"id": 48, "source": "riscv-dataset-excel", "optimization_type": "指令优化+控制流优化", "optimization_description": "优化前：base64_vector_decode_round函数接收minusOne寄存器参数，用于比较failedIdx是否为-1（表示无错误），使用beq指令进行相等比较。优化后：移除minusOne参数，改用bltz指令检查failedIdx是否小于0（-1是唯一小于0的有效值），并新增FailureAtIdx0标签处理索引0失败的情况。优化思路：1. 减少寄存器参数传递开销；2. 用更高效的符号检查替代相等比较；3. 优化控制流，当第一个数据（索引0）失败时直接跳转，避免不必要的处理。", "original_code": "base64_vector_decode_round函数接收minusOne寄存器参数，用于比较failedIdx是否为-1（表示无错误），使用beq指令进行相等比较。", "optimized_code": "-    Register size, Register stepSrc, Register stepDst, Register failedIdx, Register minusOne,\n+    Register size, Register stepSrc, Register stepDst, Register failedIdx,\n-    __ beq(failedIdx, minusOne, NoFailure);\n+    Label NoFailure, FailureAtIdx0;\n+    // valid value can only be -1 when < 0\n+    __ bltz(failedIdx, NoFailure);\n+    // when the first data (at index 0) fails, no need to process data anymore\n+    __ beqz(failedIdx, FailureAtIdx0);\n+    __ BIND(FailureAtIdx0);", "source_url": "https://github.com/openjdk/riscv-port/commit/ae39a6603c6c33a36dce30c3290a634b08a6bf05", "code_v0_no_empty_lines": "base64_vector_decode_round函数接收minusOne寄存器参数，用于比较failedIdx是否为-1（表示无错误），使用beq指令进行相等比较。", "code_v1_no_empty_lines": "-    Register size, Register stepSrc, Register stepDst, Register failedIdx, Register minusOne,\n+    Register size, Register stepSrc, Register stepDst, Register failedIdx,\n-    __ beq(failedIdx, minusOne, NoFailure);\n+    Label NoFailure, FailureAtIdx0;\n+    // valid value can only be -1 when < 0\n+    __ bltz(failedIdx, NoFailure);\n+    // when the first data (at index 0) fails, no need to process data anymore\n+    __ beqz(failedIdx, FailureAtIdx0);\n+    __ BIND(FailureAtIdx0);", "target": "-    Register size, Register stepSrc, Register stepDst, Register failedIdx, Register minusOne,\n+    Register size, Register stepSrc, Register stepDst, Register failedIdx,\n-    __ beq(failedIdx, minusOne, NoFailure);\n+    Label NoFailure, FailureAtIdx0;\n+    // valid value can only be -1 when < 0\n+    __ bltz(failedIdx, NoFailure);\n+    // when the first data (at index 0) fails, no need to process data anymore\n+    __ beqz(failedIdx, FailureAtIdx0);\n+    __ BIND(FailureAtIdx0);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：base64_vector_decode_round函数接收minusOne寄存器参数，用于比较failedIdx是否为-1（表示无错误），使用beq指令进行相等比较。优化后：移除minusOne参数，改用bltz指令检查failedIdx是否小于0（-1是唯一小于0的有效值），并新增FailureAtIdx0标签处理索引0失败的情况。优化思路：1. 减少寄存器参数传递开销；2. 用更高效的符号检查替代相等比较；3. 优化控制流，当第一个数据（索引0）失败时直接跳转，避免不必要的处理。"}
{"id": 49, "source": "riscv-dataset-excel", "optimization_type": "指令优化", "optimization_description": "优化前：使用mask32寄存器通过AND指令将state0和state2的高32位清零，确保只处理低32位数据，但需要额外的指令和寄存器操作。优化后：基于MD5算法只处理32位字的特性，直接忽略state0和state2的高32位内容，无需显式清零，从而移除了不必要的AND指令和mask32寄存器设置。思路：减少指令数量和寄存器使用，提升MD5内在函数的执行效率。", "original_code": "使用mask32寄存器通过AND指令将state0和state2的高32位清零，确保只处理低32位数据，但需要额外的指令和寄存器操作。", "optimized_code": "-    __ mv(t0, mask32);\n     __ ld(state0, Address(state));\n     __ srli(state1, state0, 32);\n-    __ andr(state0, state0, t0);\n     __ ld(state2, Address(state, 8));\n     __ srli(state3, state2, 32);\n-    __ andr(state2, state2, t0);", "source_url": "https://github.com/openjdk/riscv-port/commit/fff2e580cdab90ea828c1c300440471981646c51", "code_v0_no_empty_lines": "使用mask32寄存器通过AND指令将state0和state2的高32位清零，确保只处理低32位数据，但需要额外的指令和寄存器操作。", "code_v1_no_empty_lines": "-    __ mv(t0, mask32);\n     __ ld(state0, Address(state));\n     __ srli(state1, state0, 32);\n-    __ andr(state0, state0, t0);\n     __ ld(state2, Address(state, 8));\n     __ srli(state3, state2, 32);\n-    __ andr(state2, state2, t0);", "target": "-    __ mv(t0, mask32);\n     __ ld(state0, Address(state));\n     __ srli(state1, state0, 32);\n-    __ andr(state0, state0, t0);\n     __ ld(state2, Address(state, 8));\n     __ srli(state3, state2, 32);\n-    __ andr(state2, state2, t0);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用mask32寄存器通过AND指令将state0和state2的高32位清零，确保只处理低32位数据，但需要额外的指令和寄存器操作。优化后：基于MD5算法只处理32位字的特性，直接忽略state0和state2的高32位内容，无需显式清零，从而移除了不必要的AND指令和mask32寄存器设置。思路：减少指令数量和寄存器使用，提升MD5内在函数的执行效率。"}
{"id": 50, "source": "riscv-dataset-excel", "optimization_type": "条件分支优化", "optimization_description": "把显式的分支检查 (bnez) 去掉，改为用统一的 clinit_barrier 机制处理，从而减少了分支指令数量和分支预测压力", "original_code": "// No original code extracted from description\n", "optimized_code": "- // make sure klass is initialized & doesn't have finalizer\n - // make sure klass is fully initialized\n - __ lbu(t0, Address(x14, InstanceKlass::init_state_offset()));\n - __ sub(t1, t0, (u1)InstanceKlass::fully_initialized);\n - __ bnez(t1, slow_case);\n + // make sure klass is initialized\n + assert(VM_Version::supports_fast_class_init_checks(),\n +        \"Optimization requires support for fast class+ initialization checks\");\n + __ clinit_barrier(x14, t0, nullptr /*L_fast_path*/, +&slow_case);", "source_url": "https://github.com/openjdk/riscv-port/commit/a1d65eb6d87ff9019a9a92a775213be2a8b60fd1", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- // make sure klass is initialized & doesn't have finalizer\n - // make sure klass is fully initialized\n - __ lbu(t0, Address(x14, InstanceKlass::init_state_offset()));\n - __ sub(t1, t0, (u1)InstanceKlass::fully_initialized);\n - __ bnez(t1, slow_case);\n + // make sure klass is initialized\n + assert(VM_Version::supports_fast_class_init_checks(),\n +        \"Optimization requires support for fast class+ initialization checks\");\n + __ clinit_barrier(x14, t0, nullptr /*L_fast_path*/, +&slow_case);", "target": "- // make sure klass is initialized & doesn't have finalizer\n - // make sure klass is fully initialized\n - __ lbu(t0, Address(x14, InstanceKlass::init_state_offset()));\n - __ sub(t1, t0, (u1)InstanceKlass::fully_initialized);\n - __ bnez(t1, slow_case);\n + // make sure klass is initialized\n + assert(VM_Version::supports_fast_class_init_checks(),\n +        \"Optimization requires support for fast class+ initialization checks\");\n + __ clinit_barrier(x14, t0, nullptr /*L_fast_path*/, +&slow_case);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "把显式的分支检查 (bnez) 去掉，改为用统一的 clinit_barrier 机制处理，从而减少了分支指令数量和分支预测压力"}
{"id": 51, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+指令调度优化", "optimization_description": "优化前：ChaCha20_ctr32_v函数使用固定向量长度（MAX_WORDS=32），向量寄存器分配和指令调度存在优化空间。优化后：1. 将MAX_WORDS从32增加到64，支持更大向量处理；2. 引入动态向量类型选择（vtype），根据输入长度自动选择最优向量配置；3. 重新分配向量寄存器（从v1-v15改为v0-v30），优化寄存器使用模式；4. 重构循环结构，减少分支和指令依赖。优化思路：通过动态向量配置和寄存器重分配，提高RISC-V向量扩展的利用率，减少指令开销，提升ChaCha20加密算法的性能。", "original_code": "ChaCha20_ctr32_v函数使用固定向量长度（MAX_WORDS=32），向量寄存器分配和指令调度存在优化空间。", "optimized_code": "- my $vlen=$t6;\n- my $MAX_WORDS=32;\t# corresponds to 1024 bits\n+ my $vtype=$t5;\n+ my $vlenw=$t6;\n+ my $MAX_WORDS=64;\t# corresponds to 1024x2 bits\n\n- li\t\t$vlen, $MAX_WORDS\n- vsetvli\t\t$vlen, $vlen, e32\n+ li\t\t$vlenw, $MAX_WORDS\n+ li\t\t$vtype, 0x11\t# e32, m2\n+#if 1\n+ vsetvli\t\t$a5, $vlenw, e32, m2\n+ ...\n+ vsetvl\t\t$vlenw, $vlenw, $vtype\n\n- vle32.v\t\tv1, ($key)\t# b'\n- vle32.v\t\tv2, ($t1)\t# c'\n- vle32.v\t\tv3, ($counter)\t# d'\n+ vle32.v\t\tv2, ($key)\t# b'\n+ vle32.v\t\tv4, ($t1)\t# c'\n+ vle32.v\t\tv6, ($counter)\t# d'", "source_url": "https://github.com/dot-asm/cryptogams/commit/f99b47a96875bcb007593abcb115f0a8455ccd6c", "code_v0_no_empty_lines": "ChaCha20_ctr32_v函数使用固定向量长度（MAX_WORDS=32），向量寄存器分配和指令调度存在优化空间。", "code_v1_no_empty_lines": "- my $vlen=$t6;\n- my $MAX_WORDS=32;\t# corresponds to 1024 bits\n+ my $vtype=$t5;\n+ my $vlenw=$t6;\n+ my $MAX_WORDS=64;\t# corresponds to 1024x2 bits\n\n- li\t\t$vlen, $MAX_WORDS\n- vsetvli\t\t$vlen, $vlen, e32\n+ li\t\t$vlenw, $MAX_WORDS\n+ li\t\t$vtype, 0x11\t# e32, m2\n+#if 1\n+ vsetvli\t\t$a5, $vlenw, e32, m2\n+ ...\n+ vsetvl\t\t$vlenw, $vlenw, $vtype\n\n- vle32.v\t\tv1, ($key)\t# b'\n- vle32.v\t\tv2, ($t1)\t# c'\n- vle32.v\t\tv3, ($counter)\t# d'\n+ vle32.v\t\tv2, ($key)\t# b'\n+ vle32.v\t\tv4, ($t1)\t# c'\n+ vle32.v\t\tv6, ($counter)\t# d'", "target": "- my $vlen=$t6;\n- my $MAX_WORDS=32;\t# corresponds to 1024 bits\n+ my $vtype=$t5;\n+ my $vlenw=$t6;\n+ my $MAX_WORDS=64;\t# corresponds to 1024x2 bits\n\n- li\t\t$vlen, $MAX_WORDS\n- vsetvli\t\t$vlen, $vlen, e32\n+ li\t\t$vlenw, $MAX_WORDS\n+ li\t\t$vtype, 0x11\t# e32, m2\n+#if 1\n+ vsetvli\t\t$a5, $vlenw, e32, m2\n+ ...\n+ vsetvl\t\t$vlenw, $vlenw, $vtype\n\n- vle32.v\t\tv1, ($key)\t# b'\n- vle32.v\t\tv2, ($t1)\t# c'\n- vle32.v\t\tv3, ($counter)\t# d'\n+ vle32.v\t\tv2, ($key)\t# b'\n+ vle32.v\t\tv4, ($t1)\t# c'\n+ vle32.v\t\tv6, ($counter)\t# d'", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ChaCha20_ctr32_v函数使用固定向量长度（MAX_WORDS=32），向量寄存器分配和指令调度存在优化空间。优化后：1. 将MAX_WORDS从32增加到64，支持更大向量处理；2. 引入动态向量类型选择（vtype），根据输入长度自动选择最优向量配置；3. 重新分配向量寄存器（从v1-v15改为v0-v30），优化寄存器使用模式；4. 重构循环结构，减少分支和指令依赖。优化思路：通过动态向量配置和寄存器重分配，提高RISC-V向量扩展的利用率，减少指令开销，提升ChaCha20加密算法的性能。"}
{"id": 52, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+指令优化", "optimization_description": "优化前：使用单一VROUND函数处理所有向量长度，循环展开和内存操作效率较低，性能为6.7 cycles/byte。优化后：1. 引入VROUNDm4函数处理m4向量（4倍向量长度），减少指令数量；2. 动态调整向量类型（vtype）和长度（vlenw/vlenb），根据硬件特性选择最优配置；3. 优化内存访问模式，减少临时存储和加载操作；4. 简化计数器管理和循环结构。优化思路：通过向量化优化和指令重组，提高并行处理能力，减少循环开销，使性能提升至6.0 cycles/byte。", "original_code": "使用单一VROUND函数处理所有向量长度，循环展开和内存操作效率较低，性能为6.7 cycles/byte。", "optimized_code": "sub VROUND {\n+my ($vtype, $vlenw, $vlenb) = ($t4, $t5, $counter);\n+\n+sub VROUNDm1 {\n+sub VROUNDm4 {\n+    vsetvli\t\t$zero, $vlenb, e32, m4\n+    vadd.vv\t\tv$a0,v$a0,v$b0\t\t# Q0-Q3\n+    vxor.vv\t\tv$d0,v$d0,v$a0\n+    vadd.vv\t\tv$c0,v$c0,v$d0\n+    vxor.vv\t\tv$b0,v$b0,v$c0\n+    vadd.vv\t\tv$a0,v$a0,v$b0\n+    vxor.vv\t\tv$d0,v$d0,v$a0\n+    vadd.vv\t\tv$c0,v$c0,v$d0\n+    vxor.vv\t\tv$b0,v$b0,v$c0\n+__\n+}\n+    li\t\t$vlenw, -1\t\t# ask for \"infinite\" vlen\n+    vsetvli\t\t$vlenw, $vlenw, e32\t# get actual vlen [in words]\n+    sll\t\t$t0, $vlenw, 2+4\t# vlen in bytes times 16\n+    li\t\t$vtype, 0x10\t\t# e32, m1\n+    sltiu\t\t$t1, $vlenw, 8\n+    sltiu\t\t$t2, $vlenw, 16\n+    add\t\t$vtype, $vtype, $t1\t# adjust lmul to accommodate 64 bytes\n+    add\t\t$vtype, $vtype, $t2\n+    sll\t\t$vlenb, $vlenw, 2\n+    vadd.vx\t\tv28, v28, $t0\t\t# advance the counter\n+    &VROUNDm4(0, 4, 8, 12);\n+    &VROUNDm1(0, 5, 10, 15);\n+    vadd.vx\t\tv0,  v0,  @sigma[0]\n+    vadd.vx\t\tv1,  v1,  @sigma[1]\n+    vadd.vx\t\tv2,  v2,  @sigma[2]\n+    vadd.vx\t\tv3,  v3,  @sigma[3]\n+    vsetvli\t\t$zero, $vlenb, e32, m4\n+    vadd.vv\t\tv4,  v4,  v20\n+    sll\t\t$t3, $vlenb, 2\n+    vadd.vv\t\tv8,  v8,  v24\n+    vadd.vv\t\tv12, v12, v28\n+    vse32.v\t\tv0, ($sp)\t\t# offload for transposition\n+    vse32.v\t\tv4, ($t0)\n+    vse32.v\t\tv8, ($t1)\n+    vse32.v\t\tv12, ($t2)\n+    li\t\t$t2, 16\n+    li\t\t$t3, 64\n+.Loop_xor_vx:\n+    vsetvl\t\t$zero, $t2, $vtype\t# e32\n+    andi\t\t$vtype, $vtype, -0x11\t# clear e32\n+    vlse32.v\tv0, ($t0), $vlenb\t# gather 64 bytes\n+    vsetvl\t\t$zero, $t3, $vtype\t# e8\n+    ori\t\t$vtype, $vtype, 0x10\t# set e32\n+    vle8.v\t\tv4, ($inp)\t\t# load 64 bytes of input\n+    vxor.vv\t\tv0, v0, v4\n+    vse8.v\t\tv0, ($out)\t\t# store 64 bytes of output", "source_url": "https://github.com/dot-asm/cryptogams/commit/22bc238861a7cfbf2113a8dee8982f8d8378c3c1", "code_v0_no_empty_lines": "使用单一VROUND函数处理所有向量长度，循环展开和内存操作效率较低，性能为6.7 cycles/byte。", "code_v1_no_empty_lines": "sub VROUND {\n+my ($vtype, $vlenw, $vlenb) = ($t4, $t5, $counter);\n+\n+sub VROUNDm1 {\n+sub VROUNDm4 {\n+    vsetvli\t\t$zero, $vlenb, e32, m4\n+    vadd.vv\t\tv$a0,v$a0,v$b0\t\t# Q0-Q3\n+    vxor.vv\t\tv$d0,v$d0,v$a0\n+    vadd.vv\t\tv$c0,v$c0,v$d0\n+    vxor.vv\t\tv$b0,v$b0,v$c0\n+    vadd.vv\t\tv$a0,v$a0,v$b0\n+    vxor.vv\t\tv$d0,v$d0,v$a0\n+    vadd.vv\t\tv$c0,v$c0,v$d0\n+    vxor.vv\t\tv$b0,v$b0,v$c0\n+__\n+}\n+    li\t\t$vlenw, -1\t\t# ask for \"infinite\" vlen\n+    vsetvli\t\t$vlenw, $vlenw, e32\t# get actual vlen [in words]\n+    sll\t\t$t0, $vlenw, 2+4\t# vlen in bytes times 16\n+    li\t\t$vtype, 0x10\t\t# e32, m1\n+    sltiu\t\t$t1, $vlenw, 8\n+    sltiu\t\t$t2, $vlenw, 16\n+    add\t\t$vtype, $vtype, $t1\t# adjust lmul to accommodate 64 bytes\n+    add\t\t$vtype, $vtype, $t2\n+    sll\t\t$vlenb, $vlenw, 2\n+    vadd.vx\t\tv28, v28, $t0\t\t# advance the counter\n+    &VROUNDm4(0, 4, 8, 12);\n+    &VROUNDm1(0, 5, 10, 15);\n+    vadd.vx\t\tv0,  v0,  @sigma[0]\n+    vadd.vx\t\tv1,  v1,  @sigma[1]\n+    vadd.vx\t\tv2,  v2,  @sigma[2]\n+    vadd.vx\t\tv3,  v3,  @sigma[3]\n+    vsetvli\t\t$zero, $vlenb, e32, m4\n+    vadd.vv\t\tv4,  v4,  v20\n+    sll\t\t$t3, $vlenb, 2\n+    vadd.vv\t\tv8,  v8,  v24\n+    vadd.vv\t\tv12, v12, v28\n+    vse32.v\t\tv0, ($sp)\t\t# offload for transposition\n+    vse32.v\t\tv4, ($t0)\n+    vse32.v\t\tv8, ($t1)\n+    vse32.v\t\tv12, ($t2)\n+    li\t\t$t2, 16\n+    li\t\t$t3, 64\n+.Loop_xor_vx:\n+    vsetvl\t\t$zero, $t2, $vtype\t# e32\n+    andi\t\t$vtype, $vtype, -0x11\t# clear e32\n+    vlse32.v\tv0, ($t0), $vlenb\t# gather 64 bytes\n+    vsetvl\t\t$zero, $t3, $vtype\t# e8\n+    ori\t\t$vtype, $vtype, 0x10\t# set e32\n+    vle8.v\t\tv4, ($inp)\t\t# load 64 bytes of input\n+    vxor.vv\t\tv0, v0, v4\n+    vse8.v\t\tv0, ($out)\t\t# store 64 bytes of output", "target": "sub VROUND {\n+my ($vtype, $vlenw, $vlenb) = ($t4, $t5, $counter);\n+\n+sub VROUNDm1 {\n+sub VROUNDm4 {\n+    vsetvli\t\t$zero, $vlenb, e32, m4\n+    vadd.vv\t\tv$a0,v$a0,v$b0\t\t# Q0-Q3\n+    vxor.vv\t\tv$d0,v$d0,v$a0\n+    vadd.vv\t\tv$c0,v$c0,v$d0\n+    vxor.vv\t\tv$b0,v$b0,v$c0\n+    vadd.vv\t\tv$a0,v$a0,v$b0\n+    vxor.vv\t\tv$d0,v$d0,v$a0\n+    vadd.vv\t\tv$c0,v$c0,v$d0\n+    vxor.vv\t\tv$b0,v$b0,v$c0\n+__\n+}\n+    li\t\t$vlenw, -1\t\t# ask for \"infinite\" vlen\n+    vsetvli\t\t$vlenw, $vlenw, e32\t# get actual vlen [in words]\n+    sll\t\t$t0, $vlenw, 2+4\t# vlen in bytes times 16\n+    li\t\t$vtype, 0x10\t\t# e32, m1\n+    sltiu\t\t$t1, $vlenw, 8\n+    sltiu\t\t$t2, $vlenw, 16\n+    add\t\t$vtype, $vtype, $t1\t# adjust lmul to accommodate 64 bytes\n+    add\t\t$vtype, $vtype, $t2\n+    sll\t\t$vlenb, $vlenw, 2\n+    vadd.vx\t\tv28, v28, $t0\t\t# advance the counter\n+    &VROUNDm4(0, 4, 8, 12);\n+    &VROUNDm1(0, 5, 10, 15);\n+    vadd.vx\t\tv0,  v0,  @sigma[0]\n+    vadd.vx\t\tv1,  v1,  @sigma[1]\n+    vadd.vx\t\tv2,  v2,  @sigma[2]\n+    vadd.vx\t\tv3,  v3,  @sigma[3]\n+    vsetvli\t\t$zero, $vlenb, e32, m4\n+    vadd.vv\t\tv4,  v4,  v20\n+    sll\t\t$t3, $vlenb, 2\n+    vadd.vv\t\tv8,  v8,  v24\n+    vadd.vv\t\tv12, v12, v28\n+    vse32.v\t\tv0, ($sp)\t\t# offload for transposition\n+    vse32.v\t\tv4, ($t0)\n+    vse32.v\t\tv8, ($t1)\n+    vse32.v\t\tv12, ($t2)\n+    li\t\t$t2, 16\n+    li\t\t$t3, 64\n+.Loop_xor_vx:\n+    vsetvl\t\t$zero, $t2, $vtype\t# e32\n+    andi\t\t$vtype, $vtype, -0x11\t# clear e32\n+    vlse32.v\tv0, ($t0), $vlenb\t# gather 64 bytes\n+    vsetvl\t\t$zero, $t3, $vtype\t# e8\n+    ori\t\t$vtype, $vtype, 0x10\t# set e32\n+    vle8.v\t\tv4, ($inp)\t\t# load 64 bytes of input\n+    vxor.vv\t\tv0, v0, v4\n+    vse8.v\t\tv0, ($out)\t\t# store 64 bytes of output", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用单一VROUND函数处理所有向量长度，循环展开和内存操作效率较低，性能为6.7 cycles/byte。优化后：1. 引入VROUNDm4函数处理m4向量（4倍向量长度），减少指令数量；2. 动态调整向量类型（vtype）和长度（vlenw/vlenb），根据硬件特性选择最优配置；3. 优化内存访问模式，减少临时存储和加载操作；4. 简化计数器管理和循环结构。优化思路：通过向量化优化和指令重组，提高并行处理能力，减少循环开销，使性能提升至6.0 cycles/byte。"}
{"id": 53, "source": "riscv-dataset-excel", "optimization_type": "指令优化+模式匹配优化", "optimization_description": "优化前：1. ILi指令输出格式对齐不一致；2. 未识别常见指令模式进行优化。优化后：1. 对齐ILi指令格式保持一致性；2. 新增模式匹配：当ILi后接IMov且寄存器相同时，优化为addi指令（使用x0寄存器）；当ILi后接IReturn且寄存器相同时，优化为直接设置返回值寄存器a0。优化思路：通过模式识别消除冗余的加载-移动操作，减少指令数量，提高代码生成效率。", "original_code": "1. ILi指令输出格式对齐不一致；2. 未识别常见指令模式进行优化。", "optimized_code": "| ILi (r, i, _) -> \"        li      \" ^ string_of_reg r ^ \" \" ^ string_of_int i\n+| ILi (r, x, _) :: IMov (rx, r', _) :: sl when r = r' ->\n  translate_riscv\n  (acc ^ \"x       addi    \" ^ string_of_reg rx ^ \" x0 \" ^ string_of_int x ^ \"\\n\") sl\n+| ILi (r, x, _) :: IReturn (Some r') :: sl when r = r' ->\n  translate_riscv\n  (acc ^ \"x       addi    a0 x0 \" ^ string_of_int x ^ \"\\n\") (IReturn None :: sl)", "source_url": "https://github.com/RossAdrian/minLang/commit/1578faf5e880e389db5e5bcc7625807768cf3fd2", "code_v0_no_empty_lines": "1. ILi指令输出格式对齐不一致；2. 未识别常见指令模式进行优化。", "code_v1_no_empty_lines": "| ILi (r, i, _) -> \"        li      \" ^ string_of_reg r ^ \" \" ^ string_of_int i\n+| ILi (r, x, _) :: IMov (rx, r', _) :: sl when r = r' ->\n  translate_riscv\n  (acc ^ \"x       addi    \" ^ string_of_reg rx ^ \" x0 \" ^ string_of_int x ^ \"\\n\") sl\n+| ILi (r, x, _) :: IReturn (Some r') :: sl when r = r' ->\n  translate_riscv\n  (acc ^ \"x       addi    a0 x0 \" ^ string_of_int x ^ \"\\n\") (IReturn None :: sl)", "target": "| ILi (r, i, _) -> \"        li      \" ^ string_of_reg r ^ \" \" ^ string_of_int i\n+| ILi (r, x, _) :: IMov (rx, r', _) :: sl when r = r' ->\n  translate_riscv\n  (acc ^ \"x       addi    \" ^ string_of_reg rx ^ \" x0 \" ^ string_of_int x ^ \"\\n\") sl\n+| ILi (r, x, _) :: IReturn (Some r') :: sl when r = r' ->\n  translate_riscv\n  (acc ^ \"x       addi    a0 x0 \" ^ string_of_int x ^ \"\\n\") (IReturn None :: sl)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. ILi指令输出格式对齐不一致；2. 未识别常见指令模式进行优化。优化后：1. 对齐ILi指令格式保持一致性；2. 新增模式匹配：当ILi后接IMov且寄存器相同时，优化为addi指令（使用x0寄存器）；当ILi后接IReturn且寄存器相同时，优化为直接设置返回值寄存器a0。优化思路：通过模式识别消除冗余的加载-移动操作，减少指令数量，提高代码生成效率。"}
{"id": 54, "source": "riscv-dataset-excel", "optimization_type": "项目初始化", "optimization_description": "优化前：无项目结构。优化后：创建完整的RISC-V矩阵乘法性能优化项目，包含多种实现（naive、tiled、vector）、构建系统、测试脚本和文档。思路：建立基础框架，为后续性能优化实验提供平台。", "original_code": "无项目结构。", "optimized_code": "无代码修改，仅创建新文件", "source_url": "https://github.com/kumavatkomal/Port-Polish-Software-Optimization-for-RISC-V---UNPAID/commit/c16ce693df3a68851db4d77889059f764722c1cc", "code_v0_no_empty_lines": "无项目结构。", "code_v1_no_empty_lines": "无代码修改，仅创建新文件", "target": "无代码修改，仅创建新文件", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：无项目结构。优化后：创建完整的RISC-V矩阵乘法性能优化项目，包含多种实现（naive、tiled、vector）、构建系统、测试脚本和文档。思路：建立基础框架，为后续性能优化实验提供平台。"}
{"id": 56, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+性能优化", "optimization_description": "优化前：RISC-V 32位平台使用ZBB扩展时，count_leading_zeros和count_trailing_zeros操作会生成__clz_tab查找表，导致额外的内存访问开销。优化后：当检测到__riscv_zbb扩展时，直接映射到__builtin_clz/__builtin_ctz内置函数，编译器会生成高效的CLZ/CTZ硬件指令。优化思路：利用RISC-V ZBB扩展的硬件指令替代软件查找表，减少内存访问，提高位操作性能。", "original_code": "RISC-V 32位平台使用ZBB扩展时，count_leading_zeros和count_trailing_zeros操作会生成__clz_tab查找表，导致额外的内存访问开销。", "optimized_code": "#ifdef __riscv_zbb\n#if W_TYPE_SIZE == 32\n#define count_leading_zeros(COUNT, X)   ((COUNT) = __builtin_clz (X))\n#define count_trailing_zeros(COUNT, X)   ((COUNT) = __builtin_ctz (X))\n#define COUNT_LEADING_ZEROS_0 32\n#endif /* W_TYPE_SIZE == 32 */\n#if W_TYPE_SIZE == 64\n#define count_leading_zeros(COUNT, X)   ((COUNT) = __builtin_clzll (X))\n#define count_trailing_zeros(COUNT, X)   ((COUNT) = __builtin_ctzll (X))\n#define COUNT_LEADING_ZEROS_0 64\n#endif /* W_TYPE_SIZE == 64 */\n#endif /* __riscv_zbb */", "source_url": "https://github.com/gcc-mirror/gcc/commit/e08ef05e4da86d34223118092bbb857b8dd5d002", "code_v0_no_empty_lines": "RISC-V 32位平台使用ZBB扩展时，count_leading_zeros和count_trailing_zeros操作会生成__clz_tab查找表，导致额外的内存访问开销。", "code_v1_no_empty_lines": "#ifdef __riscv_zbb\n#if W_TYPE_SIZE == 32\n#define count_leading_zeros(COUNT, X)   ((COUNT) = __builtin_clz (X))\n#define count_trailing_zeros(COUNT, X)   ((COUNT) = __builtin_ctz (X))\n#define COUNT_LEADING_ZEROS_0 32\n#endif /* W_TYPE_SIZE == 32 */\n#if W_TYPE_SIZE == 64\n#define count_leading_zeros(COUNT, X)   ((COUNT) = __builtin_clzll (X))\n#define count_trailing_zeros(COUNT, X)   ((COUNT) = __builtin_ctzll (X))\n#define COUNT_LEADING_ZEROS_0 64\n#endif /* W_TYPE_SIZE == 64 */\n#endif /* __riscv_zbb */", "target": "#ifdef __riscv_zbb\n#if W_TYPE_SIZE == 32\n#define count_leading_zeros(COUNT, X)   ((COUNT) = __builtin_clz (X))\n#define count_trailing_zeros(COUNT, X)   ((COUNT) = __builtin_ctz (X))\n#define COUNT_LEADING_ZEROS_0 32\n#endif /* W_TYPE_SIZE == 32 */\n#if W_TYPE_SIZE == 64\n#define count_leading_zeros(COUNT, X)   ((COUNT) = __builtin_clzll (X))\n#define count_trailing_zeros(COUNT, X)   ((COUNT) = __builtin_ctzll (X))\n#define COUNT_LEADING_ZEROS_0 64\n#endif /* W_TYPE_SIZE == 64 */\n#endif /* __riscv_zbb */", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V 32位平台使用ZBB扩展时，count_leading_zeros和count_trailing_zeros操作会生成__clz_tab查找表，导致额外的内存访问开销。优化后：当检测到__riscv_zbb扩展时，直接映射到__builtin_clz/__builtin_ctz内置函数，编译器会生成高效的CLZ/CTZ硬件指令。优化思路：利用RISC-V ZBB扩展的硬件指令替代软件查找表，减少内存访问，提高位操作性能。"}
{"id": 57, "source": "riscv-dataset-excel", "optimization_type": "指令优化+常量优化", "optimization_description": "优化前：对于表达式 (X & C1) == C2 的比较，需要加载常量C1（可能需要li和addi两条指令）。优化后：通过数学变换转换为 (X | ~C1) == (C2 | ~C1)，其中~C1可以通过单个lui指令加载，减少了指令数量。优化思路：利用RISC-V架构中lui指令加载高位常量的特性，将掩码取反后变成可用lui加载的常量，从而减少常量加载的指令开销，提高代码生成效率。", "original_code": "对于表达式 (X & C1) == C2 的比较，需要加载常量C1（可能需要li和addi两条指令）。", "optimized_code": "(define_insn_and_split \"*lui_constraint<ANYI:mode>_and_to_or\"\n\t[(set (match_operand:ANYI 0 \"register_operand\" \"=r\")\n\t(plus:ANYI (and:ANYI (match_operand:ANYI 1 \"register_operand\" \"r\")\n\t\t\t (match_operand 2 \"const_int_operand\"))\n\t\t (match_operand 3 \"const_int_operand\")))\n   (clobber (match_scratch:X 4 \"=&r\"))]\n  \"LUI_OPERAND (~INTVAL (operands[2]))\n   && ((INTVAL (operands[2]) & (-INTVAL (operands[3])))\n   == (-INTVAL (operands[3])))\n   && riscv_const_insns (operands[3], false)\n   && (riscv_const_insns\n   (GEN_INT (~INTVAL (operands[2]) | -INTVAL (operands[3])), false)\n   <= riscv_const_insns (operands[3], false))\"\n  \"#\"\n  \"&& reload_completed\"\n  [(set (match_dup 4) (match_dup 5))\n   (set (match_dup 0) (ior:X (match_dup 1) (match_dup 4)))\n   (set (match_dup 4) (match_dup 6))\n   (set (match_dup 0) (minus:X (match_dup 0) (match_dup 4)))]\n  {\n    operands[5] = GEN_INT (~INTVAL (operands[2]));\n    operands[6] = GEN_INT ((~INTVAL (operands[2])) | (-INTVAL (operands[3])));\n  }\n  [(set_attr \"type\" \"arith\")])", "source_url": "https://github.com/gcc-mirror/gcc/commit/d17b09c07a1da0e3950718aabc2cbdb90cae402b", "code_v0_no_empty_lines": "对于表达式 (X & C1) == C2 的比较，需要加载常量C1（可能需要li和addi两条指令）。", "code_v1_no_empty_lines": "(define_insn_and_split \"*lui_constraint<ANYI:mode>_and_to_or\"\n\t[(set (match_operand:ANYI 0 \"register_operand\" \"=r\")\n\t(plus:ANYI (and:ANYI (match_operand:ANYI 1 \"register_operand\" \"r\")\n\t\t\t (match_operand 2 \"const_int_operand\"))\n\t\t (match_operand 3 \"const_int_operand\")))\n   (clobber (match_scratch:X 4 \"=&r\"))]\n  \"LUI_OPERAND (~INTVAL (operands[2]))\n   && ((INTVAL (operands[2]) & (-INTVAL (operands[3])))\n   == (-INTVAL (operands[3])))\n   && riscv_const_insns (operands[3], false)\n   && (riscv_const_insns\n   (GEN_INT (~INTVAL (operands[2]) | -INTVAL (operands[3])), false)\n   <= riscv_const_insns (operands[3], false))\"\n  \"#\"\n  \"&& reload_completed\"\n  [(set (match_dup 4) (match_dup 5))\n   (set (match_dup 0) (ior:X (match_dup 1) (match_dup 4)))\n   (set (match_dup 4) (match_dup 6))\n   (set (match_dup 0) (minus:X (match_dup 0) (match_dup 4)))]\n  {\n    operands[5] = GEN_INT (~INTVAL (operands[2]));\n    operands[6] = GEN_INT ((~INTVAL (operands[2])) | (-INTVAL (operands[3])));\n  }\n  [(set_attr \"type\" \"arith\")])", "target": "(define_insn_and_split \"*lui_constraint<ANYI:mode>_and_to_or\"\n\t[(set (match_operand:ANYI 0 \"register_operand\" \"=r\")\n\t(plus:ANYI (and:ANYI (match_operand:ANYI 1 \"register_operand\" \"r\")\n\t\t\t (match_operand 2 \"const_int_operand\"))\n\t\t (match_operand 3 \"const_int_operand\")))\n   (clobber (match_scratch:X 4 \"=&r\"))]\n  \"LUI_OPERAND (~INTVAL (operands[2]))\n   && ((INTVAL (operands[2]) & (-INTVAL (operands[3])))\n   == (-INTVAL (operands[3])))\n   && riscv_const_insns (operands[3], false)\n   && (riscv_const_insns\n   (GEN_INT (~INTVAL (operands[2]) | -INTVAL (operands[3])), false)\n   <= riscv_const_insns (operands[3], false))\"\n  \"#\"\n  \"&& reload_completed\"\n  [(set (match_dup 4) (match_dup 5))\n   (set (match_dup 0) (ior:X (match_dup 1) (match_dup 4)))\n   (set (match_dup 4) (match_dup 6))\n   (set (match_dup 0) (minus:X (match_dup 0) (match_dup 4)))]\n  {\n    operands[5] = GEN_INT (~INTVAL (operands[2]));\n    operands[6] = GEN_INT ((~INTVAL (operands[2])) | (-INTVAL (operands[3])));\n  }\n  [(set_attr \"type\" \"arith\")])", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于表达式 (X & C1) == C2 的比较，需要加载常量C1（可能需要li和addi两条指令）。优化后：通过数学变换转换为 (X | ~C1) == (C2 | ~C1)，其中~C1可以通过单个lui指令加载，减少了指令数量。优化思路：利用RISC-V架构中lui指令加载高位常量的特性，将掩码取反后变成可用lui加载的常量，从而减少常量加载的指令开销，提高代码生成效率。"}
{"id": 58, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：cmpmemsi扩展器仅使用标量代码进行内存块比较。优化后：在RISC-V V扩展支持下，新增向量化内存比较函数expand_vec_cmpmem，通过加载整个内存块到向量寄存器、生成差异掩码、查找首个不匹配位置的方式实现高效比较。优化思路：利用向量指令并行处理多个字节，显著提升内存比较性能，特别是对于常量长度的情况。", "original_code": "cmpmemsi扩展器仅使用标量代码进行内存块比较。", "optimized_code": "if (riscv_vector::expand_vec_cmpmem (operands[0], operands[1],\n\t\t\t\t       operands[2], operands[3]))\n    DONE;", "source_url": "https://github.com/gcc-mirror/gcc/commit/b1e828dd9694294de1ec71e319d32a6b30b087d8", "code_v0_no_empty_lines": "cmpmemsi扩展器仅使用标量代码进行内存块比较。", "code_v1_no_empty_lines": "if (riscv_vector::expand_vec_cmpmem (operands[0], operands[1],\n\t\t\t\t       operands[2], operands[3]))\n    DONE;", "target": "if (riscv_vector::expand_vec_cmpmem (operands[0], operands[1],\n\t\t\t\t       operands[2], operands[3]))\n    DONE;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：cmpmemsi扩展器仅使用标量代码进行内存块比较。优化后：在RISC-V V扩展支持下，新增向量化内存比较函数expand_vec_cmpmem，通过加载整个内存块到向量寄存器、生成差异掩码、查找首个不匹配位置的方式实现高效比较。优化思路：利用向量指令并行处理多个字节，显著提升内存比较性能，特别是对于常量长度的情况。"}
{"id": 59, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+正确性修复", "optimization_description": "优化前：使用define_insn_and_split模式优化移位/旋转操作，在匹配硬件行为时移除显式的移位计数掩码。但在某些情况下（如32位移位转换为bset指令时），由于32位移位使用0x1f掩码而64位bset使用0x3f掩码，导致掩码行为改变，产生错误代码。优化后：将define_insn_and_split改为define_insn模式，保持RTL中的掩码不变，确保移位计数掩码的正确性，同时避免不必要的模式重写。优化思路：通过简化指令模式定义，在保持性能优化的同时确保代码生成的正确性。", "original_code": "使用define_insn_and_split模式优化移位/旋转操作，在匹配硬件行为时移除显式的移位计数掩码。但在某些情况下（如32位移位转换为bset指令时），由于32位移位使用0x1f掩码而64位bset使用0x3f掩码，导致掩码行为改变，产生错误代码。", "optimized_code": "- (define_insn_and_split \"*<bitmanip_optab><GPR:mode>3_mask\"\n+ (define_insn \"*<bitmanip_optab><mode>3_mask\"\n- (define_insn_and_split \"*<optab><GPR:mode>3_mask_1\"\n+ (define_insn \"*<optab><GPR:mode>3_mask_1\"", "source_url": "https://github.com/gcc-mirror/gcc/commit/05d75c5bfcf923bc0258b79a08c5861590c5a2b9", "code_v0_no_empty_lines": "使用define_insn_and_split模式优化移位/旋转操作，在匹配硬件行为时移除显式的移位计数掩码。但在某些情况下（如32位移位转换为bset指令时），由于32位移位使用0x1f掩码而64位bset使用0x3f掩码，导致掩码行为改变，产生错误代码。", "code_v1_no_empty_lines": "- (define_insn_and_split \"*<bitmanip_optab><GPR:mode>3_mask\"\n+ (define_insn \"*<bitmanip_optab><mode>3_mask\"\n- (define_insn_and_split \"*<optab><GPR:mode>3_mask_1\"\n+ (define_insn \"*<optab><GPR:mode>3_mask_1\"", "target": "- (define_insn_and_split \"*<bitmanip_optab><GPR:mode>3_mask\"\n+ (define_insn \"*<bitmanip_optab><mode>3_mask\"\n- (define_insn_and_split \"*<optab><GPR:mode>3_mask_1\"\n+ (define_insn \"*<optab><GPR:mode>3_mask_1\"", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用define_insn_and_split模式优化移位/旋转操作，在匹配硬件行为时移除显式的移位计数掩码。但在某些情况下（如32位移位转换为bset指令时），由于32位移位使用0x1f掩码而64位bset使用0x3f掩码，导致掩码行为改变，产生错误代码。优化后：将define_insn_and_split改为define_insn模式，保持RTL中的掩码不变，确保移位计数掩码的正确性，同时避免不必要的模式重写。优化思路：通过简化指令模式定义，在保持性能优化的同时确保代码生成的正确性。"}
{"id": 60, "source": "riscv-dataset-excel", "optimization_type": "指令调度优化+微架构适配", "optimization_description": "优化前：使用全局选项riscv-misched-load-store-clustering和riscv-postmisched-load-store-clustering统一控制机器调度和PostRA阶段的load/store聚类，缺乏细粒度控制。优化后：新增4个子目标特性（disable-misched-load-clustering、disable-misched-store-clustering、disable-postmisched-load-clustering、disable-postmisched-store-clustering），允许针对不同处理器微架构特性（如宏融合）独立控制各阶段的load/store聚类。优化思路：为特定处理器（如veyron-v1）提供更精细的调度控制，通过禁用不必要的聚类来提升指令级并行性，从而更好地利用处理器特性（如store pair宏融合）。", "original_code": "使用全局选项riscv-misched-load-store-clustering和riscv-postmisched-load-store-clustering统一控制机器调度和PostRA阶段的load/store聚类，缺乏细粒度控制。", "optimized_code": "diff --git a/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp b/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp\nindex 3f2a83f8ce98c..66ce13428267c 100644\n--- a/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp\n+++ b/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp\n@@ -94,16 +94,6 @@ static cl::opt<bool>\n                            cl::desc(\"Enable the loop data prefetch pass\"),\n                            cl::init(true));\n \n-static cl::opt<bool> EnableMISchedLoadStoreClustering(\n-    \"riscv-misched-load-store-clustering\", cl::Hidden,\n-    cl::desc(\"Enable load and store clustering in the machine scheduler\"),\n-    cl::init(true));\n-\n-static cl::opt<bool> EnablePostMISchedLoadStoreClustering(\n-    \"riscv-postmisched-load-store-clustering\", cl::Hidden,\n-    cl::desc(\"Enable PostRA load and store clustering in the machine scheduler\"),\n-    cl::init(true));\n-\n static cl::opt<bool> DisableVectorMaskMutation(\n     \"riscv-disable-vector-mask-mutation\",\n     cl::desc(\"Disable the vector mask scheduling mutation\"), cl::init(false),\n@@ -294,15 +284,17 @@ bool RISCVTargetMachine::isNoopAddrSpaceCast(unsigned SrcAS,\n \n ScheduleDAGInstrs *\n RISCVTargetMachine::createMachineScheduler(MachineSchedContext *C) const {\n+  const RISCVSubtarget &ST = C->MF->getSubtarget<RISCVSubtarget>();\n   ScheduleDAGMILive *DAG = createSchedLive(C);\n-  if (EnableMISchedLoadStoreClustering) {\n+\n+  if (ST.enableMISchedLoadClustering())\n     DAG->addMutation(createLoadClusterDAGMutation(\n         DAG->TII, DAG->TRI, /*ReorderWhileClustering=*/true));\n+\n+  if (ST.enableMISchedStoreClustering())\n     DAG->addMutation(createStoreClusterDAGMutation(\n         DAG->TII, DAG->TRI, /*ReorderWhileClustering=*/true));\n-  }\n \n-  const RISCVSubtarget &ST = C->MF->getSubtarget<RISCVSubtarget>();\n   if (!DisableVectorMaskMutation && ST.hasVInstructions())\n     DAG->addMutation(createRISCVVectorMaskDAGMutation(DAG->TRI));\n \n@@ -311,13 +303,16 @@ RISCVTargetMachine::createMachineScheduler(MachineSchedContext *C) const {\n \n ScheduleDAGInstrs *\n RISCVTargetMachine::createPostMachineScheduler(MachineSchedContext *C) const {\n+  const RISCVSubtarget &ST = C->MF->getSubtarget<RISCVSubtarget>();\n   ScheduleDAGMI *DAG = createSchedPostRA(C);\n-  if (EnablePostMISchedLoadStoreClustering) {\n+\n+  if (ST.enablePostMISchedLoadClustering())\n     DAG->addMutation(createLoadClusterDAGMutation(\n         DAG->TII, DAG->TRI, /*ReorderWhileClustering=*/true));\n+\n+  if (ST.enablePostMISchedStoreClustering())\n     DAG->addMutation(createStoreClusterDAGMutation(\n         DAG->TII, DAG->TRI, /*ReorderWhileClustering=*/true));\n-  }\n \n   return DAG;\n }", "source_url": "https://github.com/llvm/llvm-project/commit/8e57689c34f0b0af70f9aaf009c3be0e85d90dda", "code_v0_no_empty_lines": "使用全局选项riscv-misched-load-store-clustering和riscv-postmisched-load-store-clustering统一控制机器调度和PostRA阶段的load/store聚类，缺乏细粒度控制。", "code_v1_no_empty_lines": "diff --git a/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp b/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp\nindex 3f2a83f8ce98c..66ce13428267c 100644\n--- a/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp\n+++ b/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp\n@@ -94,16 +94,6 @@ static cl::opt<bool>\n                            cl::desc(\"Enable the loop data prefetch pass\"),\n                            cl::init(true));\n \n-static cl::opt<bool> EnableMISchedLoadStoreClustering(\n-    \"riscv-misched-load-store-clustering\", cl::Hidden,\n-    cl::desc(\"Enable load and store clustering in the machine scheduler\"),\n-    cl::init(true));\n-\n-static cl::opt<bool> EnablePostMISchedLoadStoreClustering(\n-    \"riscv-postmisched-load-store-clustering\", cl::Hidden,\n-    cl::desc(\"Enable PostRA load and store clustering in the machine scheduler\"),\n-    cl::init(true));\n-\n static cl::opt<bool> DisableVectorMaskMutation(\n     \"riscv-disable-vector-mask-mutation\",\n     cl::desc(\"Disable the vector mask scheduling mutation\"), cl::init(false),\n@@ -294,15 +284,17 @@ bool RISCVTargetMachine::isNoopAddrSpaceCast(unsigned SrcAS,\n \n ScheduleDAGInstrs *\n RISCVTargetMachine::createMachineScheduler(MachineSchedContext *C) const {\n+  const RISCVSubtarget &ST = C->MF->getSubtarget<RISCVSubtarget>();\n   ScheduleDAGMILive *DAG = createSchedLive(C);\n-  if (EnableMISchedLoadStoreClustering) {\n+\n+  if (ST.enableMISchedLoadClustering())\n     DAG->addMutation(createLoadClusterDAGMutation(\n         DAG->TII, DAG->TRI, /*ReorderWhileClustering=*/true));\n+\n+  if (ST.enableMISchedStoreClustering())\n     DAG->addMutation(createStoreClusterDAGMutation(\n         DAG->TII, DAG->TRI, /*ReorderWhileClustering=*/true));\n-  }\n \n-  const RISCVSubtarget &ST = C->MF->getSubtarget<RISCVSubtarget>();\n   if (!DisableVectorMaskMutation && ST.hasVInstructions())\n     DAG->addMutation(createRISCVVectorMaskDAGMutation(DAG->TRI));\n \n@@ -311,13 +303,16 @@ RISCVTargetMachine::createMachineScheduler(MachineSchedContext *C) const {\n \n ScheduleDAGInstrs *\n RISCVTargetMachine::createPostMachineScheduler(MachineSchedContext *C) const {\n+  const RISCVSubtarget &ST = C->MF->getSubtarget<RISCVSubtarget>();\n   ScheduleDAGMI *DAG = createSchedPostRA(C);\n-  if (EnablePostMISchedLoadStoreClustering) {\n+\n+  if (ST.enablePostMISchedLoadClustering())\n     DAG->addMutation(createLoadClusterDAGMutation(\n         DAG->TII, DAG->TRI, /*ReorderWhileClustering=*/true));\n+\n+  if (ST.enablePostMISchedStoreClustering())\n     DAG->addMutation(createStoreClusterDAGMutation(\n         DAG->TII, DAG->TRI, /*ReorderWhileClustering=*/true));\n-  }\n \n   return DAG;\n }", "target": "diff --git a/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp b/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp\nindex 3f2a83f8ce98c..66ce13428267c 100644\n--- a/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp\n+++ b/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp\n@@ -94,16 +94,6 @@ static cl::opt<bool>\n                            cl::desc(\"Enable the loop data prefetch pass\"),\n                            cl::init(true));\n \n-static cl::opt<bool> EnableMISchedLoadStoreClustering(\n-    \"riscv-misched-load-store-clustering\", cl::Hidden,\n-    cl::desc(\"Enable load and store clustering in the machine scheduler\"),\n-    cl::init(true));\n-\n-static cl::opt<bool> EnablePostMISchedLoadStoreClustering(\n-    \"riscv-postmisched-load-store-clustering\", cl::Hidden,\n-    cl::desc(\"Enable PostRA load and store clustering in the machine scheduler\"),\n-    cl::init(true));\n-\n static cl::opt<bool> DisableVectorMaskMutation(\n     \"riscv-disable-vector-mask-mutation\",\n     cl::desc(\"Disable the vector mask scheduling mutation\"), cl::init(false),\n@@ -294,15 +284,17 @@ bool RISCVTargetMachine::isNoopAddrSpaceCast(unsigned SrcAS,\n \n ScheduleDAGInstrs *\n RISCVTargetMachine::createMachineScheduler(MachineSchedContext *C) const {\n+  const RISCVSubtarget &ST = C->MF->getSubtarget<RISCVSubtarget>();\n   ScheduleDAGMILive *DAG = createSchedLive(C);\n-  if (EnableMISchedLoadStoreClustering) {\n+\n+  if (ST.enableMISchedLoadClustering())\n     DAG->addMutation(createLoadClusterDAGMutation(\n         DAG->TII, DAG->TRI, /*ReorderWhileClustering=*/true));\n+\n+  if (ST.enableMISchedStoreClustering())\n     DAG->addMutation(createStoreClusterDAGMutation(\n         DAG->TII, DAG->TRI, /*ReorderWhileClustering=*/true));\n-  }\n \n-  const RISCVSubtarget &ST = C->MF->getSubtarget<RISCVSubtarget>();\n   if (!DisableVectorMaskMutation && ST.hasVInstructions())\n     DAG->addMutation(createRISCVVectorMaskDAGMutation(DAG->TRI));\n \n@@ -311,13 +303,16 @@ RISCVTargetMachine::createMachineScheduler(MachineSchedContext *C) const {\n \n ScheduleDAGInstrs *\n RISCVTargetMachine::createPostMachineScheduler(MachineSchedContext *C) const {\n+  const RISCVSubtarget &ST = C->MF->getSubtarget<RISCVSubtarget>();\n   ScheduleDAGMI *DAG = createSchedPostRA(C);\n-  if (EnablePostMISchedLoadStoreClustering) {\n+\n+  if (ST.enablePostMISchedLoadClustering())\n     DAG->addMutation(createLoadClusterDAGMutation(\n         DAG->TII, DAG->TRI, /*ReorderWhileClustering=*/true));\n+\n+  if (ST.enablePostMISchedStoreClustering())\n     DAG->addMutation(createStoreClusterDAGMutation(\n         DAG->TII, DAG->TRI, /*ReorderWhileClustering=*/true));\n-  }\n \n   return DAG;\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用全局选项riscv-misched-load-store-clustering和riscv-postmisched-load-store-clustering统一控制机器调度和PostRA阶段的load/store聚类，缺乏细粒度控制。优化后：新增4个子目标特性（disable-misched-load-clustering、disable-misched-store-clustering、disable-postmisched-load-clustering、disable-postmisched-store-clustering），允许针对不同处理器微架构特性（如宏融合）独立控制各阶段的load/store聚类。优化思路：为特定处理器（如veyron-v1）提供更精细的调度控制，通过禁用不必要的聚类来提升指令级并行性，从而更好地利用处理器特性（如store pair宏融合）。"}
{"id": 61, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：RVVIntrinsic类包含Name和OverloadedName成员，索引使用32位整数，内置函数名包含\"__builtin_rvv_\"前缀，导致内存占用较高（峰值15.68MB）。优化后：移除不必要的字符串成员，将索引类型从uint32_t缩减为uint16_t，优化字符串存储方式，减少内存占用（峰值降至13.69MB）。优化思路：通过减少数据结构大小和优化字符串存储来降低内存使用，同时保持功能不变。", "original_code": "RVVIntrinsic类包含Name和OverloadedName成员，索引使用32位整数，内置函数名包含\"__builtin_rvv_\"前缀，导致内存占用较高（峰值15.68MB）。", "optimized_code": "1. 移除RVVIntrinsic类中的getName()和getOverloadedName()方法\n2. 将SmallVector<uint32_t, 8> Indexes改为SmallVector<uint16_t, 8> Indexes\n3. 将StringMap<uint32_t> Intrinsics改为StringMap<uint16_t> Intrinsics\n4. 将uint32_t Index = IntrinsicList.size()改为uint16_t Index = IntrinsicList.size()\n5. 修改BuiltinName生成逻辑，移除\"__builtin_rvv_\"前缀\n6. 修改别名创建逻辑，添加\"__builtin_rvv_\"前缀\n7. 修改名称检查逻辑，添加\"__riscv_\"前缀检查", "source_url": "https://github.com/llvm/llvm-project/commit/e0092eae431956a2fd17f7ea88e7ba26d5e44f7e", "code_v0_no_empty_lines": "RVVIntrinsic类包含Name和OverloadedName成员，索引使用32位整数，内置函数名包含\"__builtin_rvv_\"前缀，导致内存占用较高（峰值15.68MB）。", "code_v1_no_empty_lines": "1. 移除RVVIntrinsic类中的getName()和getOverloadedName()方法\n2. 将SmallVector<uint32_t, 8> Indexes改为SmallVector<uint16_t, 8> Indexes\n3. 将StringMap<uint32_t> Intrinsics改为StringMap<uint16_t> Intrinsics\n4. 将uint32_t Index = IntrinsicList.size()改为uint16_t Index = IntrinsicList.size()\n5. 修改BuiltinName生成逻辑，移除\"__builtin_rvv_\"前缀\n6. 修改别名创建逻辑，添加\"__builtin_rvv_\"前缀\n7. 修改名称检查逻辑，添加\"__riscv_\"前缀检查", "target": "1. 移除RVVIntrinsic类中的getName()和getOverloadedName()方法\n2. 将SmallVector<uint32_t, 8> Indexes改为SmallVector<uint16_t, 8> Indexes\n3. 将StringMap<uint32_t> Intrinsics改为StringMap<uint16_t> Intrinsics\n4. 将uint32_t Index = IntrinsicList.size()改为uint16_t Index = IntrinsicList.size()\n5. 修改BuiltinName生成逻辑，移除\"__builtin_rvv_\"前缀\n6. 修改别名创建逻辑，添加\"__builtin_rvv_\"前缀\n7. 修改名称检查逻辑，添加\"__riscv_\"前缀检查", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RVVIntrinsic类包含Name和OverloadedName成员，索引使用32位整数，内置函数名包含\"__builtin_rvv_\"前缀，导致内存占用较高（峰值15.68MB）。优化后：移除不必要的字符串成员，将索引类型从uint32_t缩减为uint16_t，优化字符串存储方式，减少内存占用（峰值降至13.69MB）。优化思路：通过减少数据结构大小和优化字符串存储来降低内存使用，同时保持功能不变。"}
{"id": 62, "source": "riscv-dataset-excel", "optimization_type": "调度模型扩展", "optimization_description": "优化前：RISC-V目标缺少通用的乱序执行（OOO）CPU调度模型，无法评估针对乱序处理器的优化效果。优化后：新增generic-ooo调度模型，提供6发射宽度、192项ROB、4周期加载延迟等参数，支持整数/浮点/访存单元的资源建模。思路：参考GCC做法，添加通用OOO模型作为评估模板，允许用户基于此定制自己的CPU模型，提升编译器对乱序处理器优化的支持能力。", "original_code": "RISC-V目标缺少通用的乱序执行（OOO）CPU调度模型，无法评估针对乱序处理器的优化效果。", "optimized_code": "def GENERIC_OOO : RISCVTuneProcessorModel<\"generic-ooo\", GenericOOOModel>,\n                  GenericTuneInfo;\n\n+def GenericOOOModel : SchedMachineModel {\n+  int IssueWidth = 6;\n+  int MicroOpBufferSize = 192;\n+  int LoadLatency = 4;\n+  int MispredictPenalty = 8;\n+  let CompleteModel = 0;\n+}", "source_url": "https://github.com/llvm/llvm-project/commit/7eadc1960d199676f04add402bb0aa6f65b7b234", "code_v0_no_empty_lines": "RISC-V目标缺少通用的乱序执行（OOO）CPU调度模型，无法评估针对乱序处理器的优化效果。", "code_v1_no_empty_lines": "def GENERIC_OOO : RISCVTuneProcessorModel<\"generic-ooo\", GenericOOOModel>,\n                  GenericTuneInfo;\n\n+def GenericOOOModel : SchedMachineModel {\n+  int IssueWidth = 6;\n+  int MicroOpBufferSize = 192;\n+  int LoadLatency = 4;\n+  int MispredictPenalty = 8;\n+  let CompleteModel = 0;\n+}", "target": "def GENERIC_OOO : RISCVTuneProcessorModel<\"generic-ooo\", GenericOOOModel>,\n                  GenericTuneInfo;\n\n+def GenericOOOModel : SchedMachineModel {\n+  int IssueWidth = 6;\n+  int MicroOpBufferSize = 192;\n+  int LoadLatency = 4;\n+  int MispredictPenalty = 8;\n+  let CompleteModel = 0;\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V目标缺少通用的乱序执行（OOO）CPU调度模型，无法评估针对乱序处理器的优化效果。优化后：新增generic-ooo调度模型，提供6发射宽度、192项ROB、4周期加载延迟等参数，支持整数/浮点/访存单元的资源建模。思路：参考GCC做法，添加通用OOO模型作为评估模板，允许用户基于此定制自己的CPU模型，提升编译器对乱序处理器优化的支持能力。"}
{"id": 63, "source": "riscv-dataset-excel", "optimization_type": "指令优化+向量化优化", "optimization_description": "优化前：当Even向量为undef时，代码未做特殊处理，仍执行完整的向量交织操作（VWSLL_VL + VWADDU_W_VL）。优化后：检测Even向量是否为undef，如果是则优化为更高效的指令序列：1. 使用Zvbb扩展时，用单个vwsll指令；2. 无Zvbb时，用vzext.vf2 + vsll指令序列。优化思路：利用undef向量的特性，减少不必要的计算，生成更精简的指令序列，提升向量交织操作的性能。", "original_code": "当Even向量为undef时，代码未做特殊处理，仍执行完整的向量交织操作（VWSLL_VL + VWADDU_W_VL）。", "optimized_code": "} else if (EvenV.isUndef()) {\n    Interleaved =\n        DAG.getNode(RISCVISD::VZEXT_VL, DL, WideContainerVT, OddV, Mask, VL);\n\n    SDValue OffsetVec =\n        DAG.getConstant(VecVT.getScalarSizeInBits(), DL, WideContainerVT);\n    Interleaved = DAG.getNode(RISCVISD::SHL_VL, DL, WideContainerVT,\n                              Interleaved, OffsetVec, Passthru, Mask, VL);", "source_url": "https://github.com/llvm/llvm-project/commit/323d3ab2574ba9d371926bb1b5c67dbe7b2b4ec3", "code_v0_no_empty_lines": "当Even向量为undef时，代码未做特殊处理，仍执行完整的向量交织操作（VWSLL_VL + VWADDU_W_VL）。", "code_v1_no_empty_lines": "} else if (EvenV.isUndef()) {\n    Interleaved =\n        DAG.getNode(RISCVISD::VZEXT_VL, DL, WideContainerVT, OddV, Mask, VL);\n\n    SDValue OffsetVec =\n        DAG.getConstant(VecVT.getScalarSizeInBits(), DL, WideContainerVT);\n    Interleaved = DAG.getNode(RISCVISD::SHL_VL, DL, WideContainerVT,\n                              Interleaved, OffsetVec, Passthru, Mask, VL);", "target": "} else if (EvenV.isUndef()) {\n    Interleaved =\n        DAG.getNode(RISCVISD::VZEXT_VL, DL, WideContainerVT, OddV, Mask, VL);\n\n    SDValue OffsetVec =\n        DAG.getConstant(VecVT.getScalarSizeInBits(), DL, WideContainerVT);\n    Interleaved = DAG.getNode(RISCVISD::SHL_VL, DL, WideContainerVT,\n                              Interleaved, OffsetVec, Passthru, Mask, VL);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当Even向量为undef时，代码未做特殊处理，仍执行完整的向量交织操作（VWSLL_VL + VWADDU_W_VL）。优化后：检测Even向量是否为undef，如果是则优化为更高效的指令序列：1. 使用Zvbb扩展时，用单个vwsll指令；2. 无Zvbb时，用vzext.vf2 + vsll指令序列。优化思路：利用undef向量的特性，减少不必要的计算，生成更精简的指令序列，提升向量交织操作的性能。"}
{"id": 64, "source": "riscv-dataset-excel", "optimization_type": "基准测试重构与优化", "optimization_description": "优化前：存在一个综合性的BulkOps基准测试文件，包含多种内存段操作（填充、复制、哈希、不匹配检测）的基准测试，代码结构较为集中但可能不够模块化。优化后：删除BulkOps.java文件，将基准测试拆分为四个独立的文件（SegmentBulkCopy.java、SegmentBulkFill.java、SegmentBulkHash.java、SegmentBulkMismatch.java），每个文件专注于单一操作类型，并进行了代码重构（共395行新增，420行删除）。优化思路：通过模块化重构提高基准测试的可维护性和可读性，便于单独分析和优化特定内存段操作，同时可能减少了代码冗余并改进了测试组织。", "original_code": "存在一个综合性的BulkOps基准测试文件，包含多种内存段操作（填充、复制、哈希、不匹配检测）的基准测试，代码结构较为集中但可能不够模块化。", "optimized_code": "- 删除BulkOps.java文件\n+ 重构SegmentBulkCopy.java、SegmentBulkFill.java、SegmentBulkHash.java、SegmentBulkMismatch.java文件", "source_url": "https://github.com/openjdk/riscv-port/commit/1ce2a44e9f4fa9d558602dbd0489fefb0c9563ef", "code_v0_no_empty_lines": "存在一个综合性的BulkOps基准测试文件，包含多种内存段操作（填充、复制、哈希、不匹配检测）的基准测试，代码结构较为集中但可能不够模块化。", "code_v1_no_empty_lines": "- 删除BulkOps.java文件\n+ 重构SegmentBulkCopy.java、SegmentBulkFill.java、SegmentBulkHash.java、SegmentBulkMismatch.java文件", "target": "- 删除BulkOps.java文件\n+ 重构SegmentBulkCopy.java、SegmentBulkFill.java、SegmentBulkHash.java、SegmentBulkMismatch.java文件", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：存在一个综合性的BulkOps基准测试文件，包含多种内存段操作（填充、复制、哈希、不匹配检测）的基准测试，代码结构较为集中但可能不够模块化。优化后：删除BulkOps.java文件，将基准测试拆分为四个独立的文件（SegmentBulkCopy.java、SegmentBulkFill.java、SegmentBulkHash.java、SegmentBulkMismatch.java），每个文件专注于单一操作类型，并进行了代码重构（共395行新增，420行删除）。优化思路：通过模块化重构提高基准测试的可维护性和可读性，便于单独分析和优化特定内存段操作，同时可能减少了代码冗余并改进了测试组织。"}
{"id": 65, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "jcc→ jccb：从2字节指令变为1字节指令\njmp→ jmpb：同样减少指令长度\n性能收益：更紧凑的代码提高指令缓存命中率，减少缓存未命中", "original_code": "// No original code extracted from description\n", "optimized_code": "// 优化前（长跳转指令）\n- __ jcc(Assembler::belowEqual, loop);\n- __ jmp(done);\n\n// 优化后（短跳转指令）  \n+ __ jccb(Assembler::belowEqual, L_loop);\n+ __ jmpb(L_done);", "source_url": "https://github.com/openjdk/riscv-port/commit/848c0c79b69c489db6c6bbb24644134fe33fd0ec", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 优化前（长跳转指令）\n- __ jcc(Assembler::belowEqual, loop);\n- __ jmp(done);\n\n// 优化后（短跳转指令）  \n+ __ jccb(Assembler::belowEqual, L_loop);\n+ __ jmpb(L_done);", "target": "// 优化前（长跳转指令）\n- __ jcc(Assembler::belowEqual, loop);\n- __ jmp(done);\n\n// 优化后（短跳转指令）  \n+ __ jccb(Assembler::belowEqual, L_loop);\n+ __ jmpb(L_done);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "jcc→ jccb：从2字节指令变为1字节指令\njmp→ jmpb：同样减少指令长度\n性能收益：更紧凑的代码提高指令缓存命中率，减少缓存未命中"}
{"id": 66, "source": "riscv-dataset-excel", "optimization_type": "NUMA亲和性优化", "optimization_description": "优化前：工作线程在NUMA节点间轮询查找任务，仅统计NUMA本地转发数量，未设置线程亲和性，可能导致跨NUMA节点内存访问开销。优化后：当工作线程在特定NUMA节点找到任务时，动态设置线程亲和性到该节点（os::numa_set_thread_affinity），任务完成后恢复默认亲和性。优化思路：通过NUMA亲和性绑定，使线程在处理特定节点任务时运行在对应NUMA节点上，减少跨节点内存访问延迟，提高内存局部性，从而提升ZGC重定位阶段的性能。", "original_code": "工作线程在NUMA节点间轮询查找任务，仅统计NUMA本地转发数量，未设置线程亲和性，可能导致跨NUMA节点内存访问开销。", "optimized_code": "- volatile size_t                           _numa_local_forwardings;\n-      _total_forwardings(relocation_set->nforwardings()),\n-      _numa_local_forwardings(0) {\n+      _total_forwardings(relocation_set->nforwardings()) {\n-    if (ZNUMA::is_enabled()) {\n-      log_debug(gc, reloc, numa)(\"Forwardings relocated NUMA-locally: %zu / %zu (%.0f%%)\",\n-                                 _numa_local_forwardings, _total_forwardings, percent_of(_numa_local_forwardings, _total_forwardings));\n-    }\n-    uint32_t numa_local_forwardings_worker = 0;\n+    const uint32_t start_node = ZNUMA::id();\n+    uint32_t current_node = start_node;\n+    bool has_affinity = false;\n+    bool has_affinity_current_node = false;\n-        if (_iters->get(current_node).next_if(&forwarding, check_numa_local, current_node)) {\n-          claim_and_do_forwarding(forwarding);\n-\n-          if (current_node == start_node) {\n-            // Track if this forwarding was relocated on the local NUMA node\n-            numa_local_forwardings_worker++;\n+        if (_iters->get(current_node).next_if(&forwarding, check_numa_local, current_node)) {\n+          // Set thread affinity for NUMA-local processing (if needed)\n+          if (UseNUMA && !has_affinity_current_node) {\n+            os::numa_set_thread_affinity(Thread::current(), ZNUMA::numa_id_to_node(current_node));\n+            has_affinity = true;\n+            has_affinity_current_node = true;\n           }\n+          // Perform the forwarding task\n+          claim_and_do_forwarding(forwarding);\n-    if (ZNUMA::is_enabled()) {\n-      AtomicAccess::add(&_numa_local_forwardings, numa_local_forwardings_worker, memory_order_relaxed);\n-    }\n+    if (UseNUMA && has_affinity) {\n+      // Restore the affinity of the thread so that it isn't bound to a specific\n+      // node any more\n+      os::numa_set_thread_affinity(Thread::current(), -1);\n+    }", "source_url": "https://github.com/openjdk/riscv-port/commit/de546d0e03ff1823b73c32db1861b77efa9552d8", "code_v0_no_empty_lines": "工作线程在NUMA节点间轮询查找任务，仅统计NUMA本地转发数量，未设置线程亲和性，可能导致跨NUMA节点内存访问开销。", "code_v1_no_empty_lines": "- volatile size_t                           _numa_local_forwardings;\n-      _total_forwardings(relocation_set->nforwardings()),\n-      _numa_local_forwardings(0) {\n+      _total_forwardings(relocation_set->nforwardings()) {\n-    if (ZNUMA::is_enabled()) {\n-      log_debug(gc, reloc, numa)(\"Forwardings relocated NUMA-locally: %zu / %zu (%.0f%%)\",\n-                                 _numa_local_forwardings, _total_forwardings, percent_of(_numa_local_forwardings, _total_forwardings));\n-    }\n-    uint32_t numa_local_forwardings_worker = 0;\n+    const uint32_t start_node = ZNUMA::id();\n+    uint32_t current_node = start_node;\n+    bool has_affinity = false;\n+    bool has_affinity_current_node = false;\n-        if (_iters->get(current_node).next_if(&forwarding, check_numa_local, current_node)) {\n-          claim_and_do_forwarding(forwarding);\n-\n-          if (current_node == start_node) {\n-            // Track if this forwarding was relocated on the local NUMA node\n-            numa_local_forwardings_worker++;\n+        if (_iters->get(current_node).next_if(&forwarding, check_numa_local, current_node)) {\n+          // Set thread affinity for NUMA-local processing (if needed)\n+          if (UseNUMA && !has_affinity_current_node) {\n+            os::numa_set_thread_affinity(Thread::current(), ZNUMA::numa_id_to_node(current_node));\n+            has_affinity = true;\n+            has_affinity_current_node = true;\n           }\n+          // Perform the forwarding task\n+          claim_and_do_forwarding(forwarding);\n-    if (ZNUMA::is_enabled()) {\n-      AtomicAccess::add(&_numa_local_forwardings, numa_local_forwardings_worker, memory_order_relaxed);\n-    }\n+    if (UseNUMA && has_affinity) {\n+      // Restore the affinity of the thread so that it isn't bound to a specific\n+      // node any more\n+      os::numa_set_thread_affinity(Thread::current(), -1);\n+    }", "target": "- volatile size_t                           _numa_local_forwardings;\n-      _total_forwardings(relocation_set->nforwardings()),\n-      _numa_local_forwardings(0) {\n+      _total_forwardings(relocation_set->nforwardings()) {\n-    if (ZNUMA::is_enabled()) {\n-      log_debug(gc, reloc, numa)(\"Forwardings relocated NUMA-locally: %zu / %zu (%.0f%%)\",\n-                                 _numa_local_forwardings, _total_forwardings, percent_of(_numa_local_forwardings, _total_forwardings));\n-    }\n-    uint32_t numa_local_forwardings_worker = 0;\n+    const uint32_t start_node = ZNUMA::id();\n+    uint32_t current_node = start_node;\n+    bool has_affinity = false;\n+    bool has_affinity_current_node = false;\n-        if (_iters->get(current_node).next_if(&forwarding, check_numa_local, current_node)) {\n-          claim_and_do_forwarding(forwarding);\n-\n-          if (current_node == start_node) {\n-            // Track if this forwarding was relocated on the local NUMA node\n-            numa_local_forwardings_worker++;\n+        if (_iters->get(current_node).next_if(&forwarding, check_numa_local, current_node)) {\n+          // Set thread affinity for NUMA-local processing (if needed)\n+          if (UseNUMA && !has_affinity_current_node) {\n+            os::numa_set_thread_affinity(Thread::current(), ZNUMA::numa_id_to_node(current_node));\n+            has_affinity = true;\n+            has_affinity_current_node = true;\n           }\n+          // Perform the forwarding task\n+          claim_and_do_forwarding(forwarding);\n-    if (ZNUMA::is_enabled()) {\n-      AtomicAccess::add(&_numa_local_forwardings, numa_local_forwardings_worker, memory_order_relaxed);\n-    }\n+    if (UseNUMA && has_affinity) {\n+      // Restore the affinity of the thread so that it isn't bound to a specific\n+      // node any more\n+      os::numa_set_thread_affinity(Thread::current(), -1);\n+    }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：工作线程在NUMA节点间轮询查找任务，仅统计NUMA本地转发数量，未设置线程亲和性，可能导致跨NUMA节点内存访问开销。优化后：当工作线程在特定NUMA节点找到任务时，动态设置线程亲和性到该节点（os::numa_set_thread_affinity），任务完成后恢复默认亲和性。优化思路：通过NUMA亲和性绑定，使线程在处理特定节点任务时运行在对应NUMA节点上，减少跨节点内存访问延迟，提高内存局部性，从而提升ZGC重定位阶段的性能。"}
{"id": 67, "source": "riscv-dataset-excel", "optimization_type": "内存访问优化", "optimization_description": "是直接内存访问优化\nGetPrimitiveArrayCritical​ 是JNI中的高性能函数，它尝试直接获取Java数组的底层内存指针\n相比原来的getILData自定义封装函数，避免了额外的内存拷贝和封装开销", "original_code": "// No original code extracted from description\n", "optimized_code": "-void *inputBuffer = getILData(env, srcData, srcDType);\n +void *inputBuffer = (*env)->GetPrimitiveArrayCritical(env, srcData, NULL);\n-char *input = (char *) inputBuffer + srcOffset;\n-char *output = (char *) outputBuffer + dstOffset;\n-\n-    cmsDoTransformLineStride(sTrans, input, output, width, --height,\n-                            srcNextRowOffset, -dstNextRowOffset, 0, 0);\n\n-    releaseILData(env, inputBuffer, srcDType, srcData, JNI_ABORT);\n-    releaseILData(env, outputBuffer, dstDType, dstData, 0);\n+        (*env)->ReleasePrimitiveArrayCritical(env, dstData, outputBuffer, 0);\n    }\n+    (*env)->ReleasePrimitiveArrayCritical(env, srcData, inputBuffer, JNI_ABORT);", "source_url": "https://github.com/openjdk/riscv-port/commit/42db9ab629a6209aa471de8b3034c053b77629dd", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "-void *inputBuffer = getILData(env, srcData, srcDType);\n +void *inputBuffer = (*env)->GetPrimitiveArrayCritical(env, srcData, NULL);\n-char *input = (char *) inputBuffer + srcOffset;\n-char *output = (char *) outputBuffer + dstOffset;\n-\n-    cmsDoTransformLineStride(sTrans, input, output, width, --height,\n-                            srcNextRowOffset, -dstNextRowOffset, 0, 0);\n\n-    releaseILData(env, inputBuffer, srcDType, srcData, JNI_ABORT);\n-    releaseILData(env, outputBuffer, dstDType, dstData, 0);\n+        (*env)->ReleasePrimitiveArrayCritical(env, dstData, outputBuffer, 0);\n    }\n+    (*env)->ReleasePrimitiveArrayCritical(env, srcData, inputBuffer, JNI_ABORT);", "target": "-void *inputBuffer = getILData(env, srcData, srcDType);\n +void *inputBuffer = (*env)->GetPrimitiveArrayCritical(env, srcData, NULL);\n-char *input = (char *) inputBuffer + srcOffset;\n-char *output = (char *) outputBuffer + dstOffset;\n-\n-    cmsDoTransformLineStride(sTrans, input, output, width, --height,\n-                            srcNextRowOffset, -dstNextRowOffset, 0, 0);\n\n-    releaseILData(env, inputBuffer, srcDType, srcData, JNI_ABORT);\n-    releaseILData(env, outputBuffer, dstDType, dstData, 0);\n+        (*env)->ReleasePrimitiveArrayCritical(env, dstData, outputBuffer, 0);\n    }\n+    (*env)->ReleasePrimitiveArrayCritical(env, srcData, inputBuffer, JNI_ABORT);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "是直接内存访问优化\nGetPrimitiveArrayCritical​ 是JNI中的高性能函数，它尝试直接获取Java数组的底层内存指针\n相比原来的getILData自定义封装函数，避免了额外的内存拷贝和封装开销"}
{"id": 68, "source": "riscv-dataset-excel", "optimization_type": "新架构支持", "optimization_description": "优化前：OpenJDK不支持RISC-V架构，无法在该平台上运行Java应用。优化后：通过添加完整的RISC-V后端支持，包括汇编器、宏汇编器、C1/C2编译器后端、解释器、垃圾收集器屏障等组件，使OpenJDK能够在RISC-V架构上编译和运行。优化思路是实现JEP 422规范，为RISC-V架构提供完整的Java运行时支持。", "original_code": "OpenJDK不支持RISC-V架构，无法在该平台上运行Java应用。", "optimized_code": "+src/hotspot/cpu/riscv/assembler_riscv.cpp     |   372 +\n+src/hotspot/cpu/riscv/assembler_riscv.hpp     |  3047 +++++\n+src/hotspot/cpu/riscv/macroAssembler_riscv.cpp        |  4016 ++++++\n+src/hotspot/cpu/riscv/macroAssembler_riscv.hpp        |   858 ++\n+src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp       |  2267 ++++\n+src/hotspot/cpu/riscv/c2_MacroAssembler_riscv.cpp     |  1646 +++\n+src/hotspot/cpu/riscv/interp_masm_riscv.cpp   |  1940 +++", "source_url": "https://github.com/openjdk/jdk/commit/5905b02c0e2643ae8d097562f181953f6c88fc89", "code_v0_no_empty_lines": "OpenJDK不支持RISC-V架构，无法在该平台上运行Java应用。", "code_v1_no_empty_lines": "+src/hotspot/cpu/riscv/assembler_riscv.cpp     |   372 +\n+src/hotspot/cpu/riscv/assembler_riscv.hpp     |  3047 +++++\n+src/hotspot/cpu/riscv/macroAssembler_riscv.cpp        |  4016 ++++++\n+src/hotspot/cpu/riscv/macroAssembler_riscv.hpp        |   858 ++\n+src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp       |  2267 ++++\n+src/hotspot/cpu/riscv/c2_MacroAssembler_riscv.cpp     |  1646 +++\n+src/hotspot/cpu/riscv/interp_masm_riscv.cpp   |  1940 +++", "target": "+src/hotspot/cpu/riscv/assembler_riscv.cpp     |   372 +\n+src/hotspot/cpu/riscv/assembler_riscv.hpp     |  3047 +++++\n+src/hotspot/cpu/riscv/macroAssembler_riscv.cpp        |  4016 ++++++\n+src/hotspot/cpu/riscv/macroAssembler_riscv.hpp        |   858 ++\n+src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp       |  2267 ++++\n+src/hotspot/cpu/riscv/c2_MacroAssembler_riscv.cpp     |  1646 +++\n+src/hotspot/cpu/riscv/interp_masm_riscv.cpp   |  1940 +++", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：OpenJDK不支持RISC-V架构，无法在该平台上运行Java应用。优化后：通过添加完整的RISC-V后端支持，包括汇编器、宏汇编器、C1/C2编译器后端、解释器、垃圾收集器屏障等组件，使OpenJDK能够在RISC-V架构上编译和运行。优化思路是实现JEP 422规范，为RISC-V架构提供完整的Java运行时支持。"}
{"id": 69, "source": "riscv-dataset-excel", "optimization_type": "指令生成优化", "optimization_description": "优化前：movptr函数在加载48位地址常量时，使用16位和5位的位移组合，可能导致地址计算错误或溢出。优化后：改为使用17位和6位的位移组合，确保48位地址能正确加载到寄存器中。优化思路是调整位移位数分配，使地址常量加载更精确，避免因位移计算错误导致的程序崩溃或数据损坏。", "original_code": "movptr函数在加载48位地址常量时，使用16位和5位的位移组合，可能导致地址计算错误或溢出。", "optimized_code": "-  int32_t imm = imm64 >> 16;\n+  int32_t imm = imm64 >> 17;\n-  addi(Rd, Rd, (imm64 >> 5) & 0x7ff);\n-  slli(Rd, Rd, 5);\n+  addi(Rd, Rd, (imm64 >> 6) & 0x7ff);\n+  slli(Rd, Rd, 6);\n-  offset = imm64 & 0x1f;\n+  offset = imm64 & 0x3f;\n-  int32_t lower = ((intptr_t)target << 36) >> 36;\n-  int64_t upper = ((intptr_t)target - lower) >> 28;\n+  int32_t lower = ((intptr_t)target << 35) >> 35;\n+  int64_t upper = ((intptr_t)target - lower) >> 29;", "source_url": "https://github.com/openjdk/jdk/commit/447ae006163b00cc46cac1c7ebe201de311bf1a1", "code_v0_no_empty_lines": "movptr函数在加载48位地址常量时，使用16位和5位的位移组合，可能导致地址计算错误或溢出。", "code_v1_no_empty_lines": "-  int32_t imm = imm64 >> 16;\n+  int32_t imm = imm64 >> 17;\n-  addi(Rd, Rd, (imm64 >> 5) & 0x7ff);\n-  slli(Rd, Rd, 5);\n+  addi(Rd, Rd, (imm64 >> 6) & 0x7ff);\n+  slli(Rd, Rd, 6);\n-  offset = imm64 & 0x1f;\n+  offset = imm64 & 0x3f;\n-  int32_t lower = ((intptr_t)target << 36) >> 36;\n-  int64_t upper = ((intptr_t)target - lower) >> 28;\n+  int32_t lower = ((intptr_t)target << 35) >> 35;\n+  int64_t upper = ((intptr_t)target - lower) >> 29;", "target": "-  int32_t imm = imm64 >> 16;\n+  int32_t imm = imm64 >> 17;\n-  addi(Rd, Rd, (imm64 >> 5) & 0x7ff);\n-  slli(Rd, Rd, 5);\n+  addi(Rd, Rd, (imm64 >> 6) & 0x7ff);\n+  slli(Rd, Rd, 6);\n-  offset = imm64 & 0x1f;\n+  offset = imm64 & 0x3f;\n-  int32_t lower = ((intptr_t)target << 36) >> 36;\n-  int64_t upper = ((intptr_t)target - lower) >> 28;\n+  int32_t lower = ((intptr_t)target << 35) >> 35;\n+  int64_t upper = ((intptr_t)target - lower) >> 29;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：movptr函数在加载48位地址常量时，使用16位和5位的位移组合，可能导致地址计算错误或溢出。优化后：改为使用17位和6位的位移组合，确保48位地址能正确加载到寄存器中。优化思路是调整位移位数分配，使地址常量加载更精确，避免因位移计算错误导致的程序崩溃或数据损坏。"}
{"id": 70, "source": "riscv-dataset-excel", "optimization_type": "代码重构+指令生成优化", "optimization_description": "优化前：addw/subw函数使用int64_t参数处理32位增量，存在不必要的类型转换开销；统计计数使用add_memory_int32函数进行内存递增操作。优化后：将addw/subw参数改为int32_t以匹配32位操作语义，减少类型转换；引入专门的incrementw函数替代add_memory_int32进行内存递增，简化代码路径。优化思路是：通过参数类型精确化和专用函数替换通用函数，减少不必要的指令开销，提高代码生成效率。", "original_code": "addw/subw函数使用int64_t参数处理32位增量，存在不必要的类型转换开销；统计计数使用add_memory_int32函数进行内存递增操作。", "optimized_code": "void Assembler::addw(Register Rd, Register Rn, int64_t increment, Register temp) {\n+void Assembler::addw(Register Rd, Register Rn, int32_t increment, Register temp) {\nvoid Assembler::subw(Register Rd, Register Rn, int64_t decrement, Register temp) {\n+void Assembler::subw(Register Rd, Register Rn, int32_t decrement, Register temp) {\n- __ add_memory_int32(Address(t1), 1);\n+ __ incrementw(Address(t1));\n- __ add_memory_int32(ExternalAddress((address)&Runtime1::_generic_arraycopystub_cnt), 1);\n+ __ incrementw(ExternalAddress((address)&Runtime1::_generic_arraycopystub_cnt));", "source_url": "https://github.com/openjdk/jdk/commit/92067e200346c41c2f43763edc01c97c7da1a9e6", "code_v0_no_empty_lines": "addw/subw函数使用int64_t参数处理32位增量，存在不必要的类型转换开销；统计计数使用add_memory_int32函数进行内存递增操作。", "code_v1_no_empty_lines": "void Assembler::addw(Register Rd, Register Rn, int64_t increment, Register temp) {\n+void Assembler::addw(Register Rd, Register Rn, int32_t increment, Register temp) {\nvoid Assembler::subw(Register Rd, Register Rn, int64_t decrement, Register temp) {\n+void Assembler::subw(Register Rd, Register Rn, int32_t decrement, Register temp) {\n- __ add_memory_int32(Address(t1), 1);\n+ __ incrementw(Address(t1));\n- __ add_memory_int32(ExternalAddress((address)&Runtime1::_generic_arraycopystub_cnt), 1);\n+ __ incrementw(ExternalAddress((address)&Runtime1::_generic_arraycopystub_cnt));", "target": "void Assembler::addw(Register Rd, Register Rn, int64_t increment, Register temp) {\n+void Assembler::addw(Register Rd, Register Rn, int32_t increment, Register temp) {\nvoid Assembler::subw(Register Rd, Register Rn, int64_t decrement, Register temp) {\n+void Assembler::subw(Register Rd, Register Rn, int32_t decrement, Register temp) {\n- __ add_memory_int32(Address(t1), 1);\n+ __ incrementw(Address(t1));\n- __ add_memory_int32(ExternalAddress((address)&Runtime1::_generic_arraycopystub_cnt), 1);\n+ __ incrementw(ExternalAddress((address)&Runtime1::_generic_arraycopystub_cnt));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：addw/subw函数使用int64_t参数处理32位增量，存在不必要的类型转换开销；统计计数使用add_memory_int32函数进行内存递增操作。优化后：将addw/subw参数改为int32_t以匹配32位操作语义，减少类型转换；引入专门的incrementw函数替代add_memory_int32进行内存递增，简化代码路径。优化思路是：通过参数类型精确化和专用函数替换通用函数，减少不必要的指令开销，提高代码生成效率。"}
{"id": 71, "source": "riscv-dataset-excel", "optimization_type": "指令优化+内存屏障优化", "optimization_description": "优化前：在RISC-V用户空间代码中，使用fence.i指令（指令缓存同步）来确保指令缓存一致性，这会导致额外的内存屏障开销。优化后：移除了所有fence.i指令及其相关代码（包括ifence()函数、fence_i指令定义、相关计算和引用），减少了不必要的内存屏障操作。优化思路是：在用户空间场景下，fence.i指令通常不是必需的，移除它可以减少指令执行开销，提高代码执行效率。", "original_code": "在RISC-V用户空间代码中，使用fence.i指令（指令缓存同步）来确保指令缓存一致性，这会导致额外的内存屏障开销。", "optimized_code": "-void Assembler::ifence() {\n-  fence_i();\n-  if (UseConservativeFence) {\n-    fence(ir, ir);\n-  }\n-}\n-INSN(fence_i, 0b0001111, 0b001, 0b000000000000);\n-  return NativeFenceI::instruction_size() + 12 * NativeInstruction::instruction_size;\n+  return 12 * NativeInstruction::instruction_size;\n-    = nativeMovConstReg_at(stub + NativeFenceI::instruction_size());\n+    = nativeMovConstReg_at(stub);\n-          \"Extend i for r and o for w in the pred/succ flags of fence;\"          \\\n-          \"Extend fence.i to fence.i + fence.\")                                  \\\n+          \"Extend i for r and o for w in the pred/succ flags of fence\")", "source_url": "https://github.com/openjdk/jdk/commit/5a539e8da7dbea1eaa10d799f75199ea359f7a22", "code_v0_no_empty_lines": "在RISC-V用户空间代码中，使用fence.i指令（指令缓存同步）来确保指令缓存一致性，这会导致额外的内存屏障开销。", "code_v1_no_empty_lines": "-void Assembler::ifence() {\n-  fence_i();\n-  if (UseConservativeFence) {\n-    fence(ir, ir);\n-  }\n-}\n-INSN(fence_i, 0b0001111, 0b001, 0b000000000000);\n-  return NativeFenceI::instruction_size() + 12 * NativeInstruction::instruction_size;\n+  return 12 * NativeInstruction::instruction_size;\n-    = nativeMovConstReg_at(stub + NativeFenceI::instruction_size());\n+    = nativeMovConstReg_at(stub);\n-          \"Extend i for r and o for w in the pred/succ flags of fence;\"          \\\n-          \"Extend fence.i to fence.i + fence.\")                                  \\\n+          \"Extend i for r and o for w in the pred/succ flags of fence\")", "target": "-void Assembler::ifence() {\n-  fence_i();\n-  if (UseConservativeFence) {\n-    fence(ir, ir);\n-  }\n-}\n-INSN(fence_i, 0b0001111, 0b001, 0b000000000000);\n-  return NativeFenceI::instruction_size() + 12 * NativeInstruction::instruction_size;\n+  return 12 * NativeInstruction::instruction_size;\n-    = nativeMovConstReg_at(stub + NativeFenceI::instruction_size());\n+    = nativeMovConstReg_at(stub);\n-          \"Extend i for r and o for w in the pred/succ flags of fence;\"          \\\n-          \"Extend fence.i to fence.i + fence.\")                                  \\\n+          \"Extend i for r and o for w in the pred/succ flags of fence\")", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在RISC-V用户空间代码中，使用fence.i指令（指令缓存同步）来确保指令缓存一致性，这会导致额外的内存屏障开销。优化后：移除了所有fence.i指令及其相关代码（包括ifence()函数、fence_i指令定义、相关计算和引用），减少了不必要的内存屏障操作。优化思路是：在用户空间场景下，fence.i指令通常不是必需的，移除它可以减少指令执行开销，提高代码执行效率。"}
{"id": 72, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化+内存布局优化", "optimization_description": "优化前：Address类使用扁平结构存储所有可能的寻址模式数据，包括_base、_index、_offset、_target、_rspec等字段，无论实际使用哪种寻址模式都会占用全部内存空间。优化后：将Address重构为带标签的联合体（discriminated union），根据_mode字段区分literal和非literal模式，分别使用_literal和_nonliteral联合成员，消除了冗余字段存储。优化思路是：通过联合体实现内存布局优化，减少对象内存占用，提高缓存局部性，同时保持类型安全。", "original_code": "Address类使用扁平结构存储所有可能的寻址模式数据，包括_base、_index、_offset、_target、_rspec等字段，无论实际使用哪种寻址模式都会占用全部内存空间。", "optimized_code": "// 头文件修改：Address类内部结构重构\n-struct Address {\n-  Register _base;\n-  Register _index;\n-  int64_t _offset;\n-  enum mode _mode;\n-  RelocationHolder _rspec;\n-  address _target;\n-};\n\n+struct Address {\n+  enum mode { no_mode, base_plus_offset, literal };\n+  struct Nonliteral {\n+    Nonliteral(Register base, Register index, int64_t offset)\n+      : _base(base), _index(index), _offset(offset) {}\n+    Register _base;\n+    Register _index;\n+    int64_t _offset;\n+  };\n+  struct Literal {\n+    Literal(address target, const RelocationHolder& rspec)\n+      : _target(target), _rspec(rspec) {}\n+    address _target;\n+    RelocationHolder _rspec;\n+  };\n+  enum mode _mode;\n+  union {\n+    Nonliteral _nonliteral;\n+    Literal _literal;\n+  };\n+};\n\n// 构造函数修改\n-Address::Address(address target, relocInfo::relocType rtype) : _base(noreg), _offset(0), _mode(literal) {\n-  _target = target;\n-  switch (rtype) {\n-    case relocInfo::oop_type:\n-    case relocInfo::metadata_type:\n-    case relocInfo::none:\n-      _rspec = RelocationHolder::none;\n-      break;\n-    case relocInfo::external_word_type:\n-      _rspec = external_word_Relocation::spec(target);\n-      break;\n-    // ... 其他case处理\n-  }\n-}\n\n+static RelocationHolder address_relocation(address target, relocInfo::relocType rtype) {\n+  switch (rtype) {\n+    case relocInfo::oop_type:\n+    case relocInfo::metadata_type:\n+    case relocInfo::none:\n+      return RelocationHolder::none;\n+    case relocInfo::external_word_type:\n+      return external_word_Relocation::spec(target);\n+    // ... 其他case处理\n+  }\n+}\n\n+Address::Address(address target, relocInfo::relocType rtype) :\n+  _mode(literal),\n+  _literal(target, address_relocation(target, rtype))\n+{}", "source_url": "https://github.com/openjdk/jdk/commit/226e579c3004a37a09f3329a8ef09c0933126bd6", "code_v0_no_empty_lines": "Address类使用扁平结构存储所有可能的寻址模式数据，包括_base、_index、_offset、_target、_rspec等字段，无论实际使用哪种寻址模式都会占用全部内存空间。", "code_v1_no_empty_lines": "// 头文件修改：Address类内部结构重构\n-struct Address {\n-  Register _base;\n-  Register _index;\n-  int64_t _offset;\n-  enum mode _mode;\n-  RelocationHolder _rspec;\n-  address _target;\n-};\n\n+struct Address {\n+  enum mode { no_mode, base_plus_offset, literal };\n+  struct Nonliteral {\n+    Nonliteral(Register base, Register index, int64_t offset)\n+      : _base(base), _index(index), _offset(offset) {}\n+    Register _base;\n+    Register _index;\n+    int64_t _offset;\n+  };\n+  struct Literal {\n+    Literal(address target, const RelocationHolder& rspec)\n+      : _target(target), _rspec(rspec) {}\n+    address _target;\n+    RelocationHolder _rspec;\n+  };\n+  enum mode _mode;\n+  union {\n+    Nonliteral _nonliteral;\n+    Literal _literal;\n+  };\n+};\n\n// 构造函数修改\n-Address::Address(address target, relocInfo::relocType rtype) : _base(noreg), _offset(0), _mode(literal) {\n-  _target = target;\n-  switch (rtype) {\n-    case relocInfo::oop_type:\n-    case relocInfo::metadata_type:\n-    case relocInfo::none:\n-      _rspec = RelocationHolder::none;\n-      break;\n-    case relocInfo::external_word_type:\n-      _rspec = external_word_Relocation::spec(target);\n-      break;\n-    // ... 其他case处理\n-  }\n-}\n\n+static RelocationHolder address_relocation(address target, relocInfo::relocType rtype) {\n+  switch (rtype) {\n+    case relocInfo::oop_type:\n+    case relocInfo::metadata_type:\n+    case relocInfo::none:\n+      return RelocationHolder::none;\n+    case relocInfo::external_word_type:\n+      return external_word_Relocation::spec(target);\n+    // ... 其他case处理\n+  }\n+}\n\n+Address::Address(address target, relocInfo::relocType rtype) :\n+  _mode(literal),\n+  _literal(target, address_relocation(target, rtype))\n+{}", "target": "// 头文件修改：Address类内部结构重构\n-struct Address {\n-  Register _base;\n-  Register _index;\n-  int64_t _offset;\n-  enum mode _mode;\n-  RelocationHolder _rspec;\n-  address _target;\n-};\n\n+struct Address {\n+  enum mode { no_mode, base_plus_offset, literal };\n+  struct Nonliteral {\n+    Nonliteral(Register base, Register index, int64_t offset)\n+      : _base(base), _index(index), _offset(offset) {}\n+    Register _base;\n+    Register _index;\n+    int64_t _offset;\n+  };\n+  struct Literal {\n+    Literal(address target, const RelocationHolder& rspec)\n+      : _target(target), _rspec(rspec) {}\n+    address _target;\n+    RelocationHolder _rspec;\n+  };\n+  enum mode _mode;\n+  union {\n+    Nonliteral _nonliteral;\n+    Literal _literal;\n+  };\n+};\n\n// 构造函数修改\n-Address::Address(address target, relocInfo::relocType rtype) : _base(noreg), _offset(0), _mode(literal) {\n-  _target = target;\n-  switch (rtype) {\n-    case relocInfo::oop_type:\n-    case relocInfo::metadata_type:\n-    case relocInfo::none:\n-      _rspec = RelocationHolder::none;\n-      break;\n-    case relocInfo::external_word_type:\n-      _rspec = external_word_Relocation::spec(target);\n-      break;\n-    // ... 其他case处理\n-  }\n-}\n\n+static RelocationHolder address_relocation(address target, relocInfo::relocType rtype) {\n+  switch (rtype) {\n+    case relocInfo::oop_type:\n+    case relocInfo::metadata_type:\n+    case relocInfo::none:\n+      return RelocationHolder::none;\n+    case relocInfo::external_word_type:\n+      return external_word_Relocation::spec(target);\n+    // ... 其他case处理\n+  }\n+}\n\n+Address::Address(address target, relocInfo::relocType rtype) :\n+  _mode(literal),\n+  _literal(target, address_relocation(target, rtype))\n+{}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Address类使用扁平结构存储所有可能的寻址模式数据，包括_base、_index、_offset、_target、_rspec等字段，无论实际使用哪种寻址模式都会占用全部内存空间。优化后：将Address重构为带标签的联合体（discriminated union），根据_mode字段区分literal和非literal模式，分别使用_literal和_nonliteral联合成员，消除了冗余字段存储。优化思路是：通过联合体实现内存布局优化，减少对象内存占用，提高缓存局部性，同时保持类型安全。"}
{"id": 73, "source": "riscv-dataset-excel", "optimization_type": "代码重构与清理", "optimization_description": "优化前：assembler_riscv.cpp文件中包含大量辅助函数（如add、addw、sub、subw等），这些函数处理立即数加载和算术操作，增加了代码复杂性和维护成本。优化后：将这些辅助函数从assembler_riscv.cpp中移除，简化了汇编器实现，减少了代码冗余。优化思路：通过代码重构和清理，将通用功能集中到macroAssembler_riscv模块中，提高代码模块化、可维护性和编译效率，同时保持功能不变。", "original_code": "assembler_riscv.cpp文件中包含大量辅助函数（如add、addw、sub、subw等），这些函数处理立即数加载和算术操作，增加了代码复杂性和维护成本。", "optimized_code": "-void Assembler::add(Register Rd, Register Rn, int64_t increment, Register temp) {\n-  if (is_imm_in_range(increment, 12, 0)) {\n-    addi(Rd, Rn, increment);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, increment);\n-    add(Rd, Rn, temp);\n-  }\n-}\n\n-void Assembler::addw(Register Rd, Register Rn, int32_t increment, Register temp) {\n-  if (is_imm_in_range(increment, 12, 0)) {\n-    addiw(Rd, Rn, increment);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, increment);\n-    addw(Rd, Rn, temp);\n-  }\n-}\n\n-void Assembler::sub(Register Rd, Register Rn, int64_t decrement, Register temp) {\n-  if (is_imm_in_range(-decrement, 12, 0)) {\n-    addi(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    sub(Rd, Rn, temp);\n-  }\n-}\n\n-void Assembler::subw(Register Rd, Register Rn, int32_t decrement, Register temp) {\n-  if (is_imm_in_range(-decrement, 12, 0)) {\n-    addiw(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    subw(Rd, Rn, temp);\n-  }\n-}", "source_url": "https://github.com/openjdk/jdk/commit/3d75e88eb25f56ed2214496826004578c2c75012", "code_v0_no_empty_lines": "assembler_riscv.cpp文件中包含大量辅助函数（如add、addw、sub、subw等），这些函数处理立即数加载和算术操作，增加了代码复杂性和维护成本。", "code_v1_no_empty_lines": "-void Assembler::add(Register Rd, Register Rn, int64_t increment, Register temp) {\n-  if (is_imm_in_range(increment, 12, 0)) {\n-    addi(Rd, Rn, increment);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, increment);\n-    add(Rd, Rn, temp);\n-  }\n-}\n\n-void Assembler::addw(Register Rd, Register Rn, int32_t increment, Register temp) {\n-  if (is_imm_in_range(increment, 12, 0)) {\n-    addiw(Rd, Rn, increment);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, increment);\n-    addw(Rd, Rn, temp);\n-  }\n-}\n\n-void Assembler::sub(Register Rd, Register Rn, int64_t decrement, Register temp) {\n-  if (is_imm_in_range(-decrement, 12, 0)) {\n-    addi(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    sub(Rd, Rn, temp);\n-  }\n-}\n\n-void Assembler::subw(Register Rd, Register Rn, int32_t decrement, Register temp) {\n-  if (is_imm_in_range(-decrement, 12, 0)) {\n-    addiw(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    subw(Rd, Rn, temp);\n-  }\n-}", "target": "-void Assembler::add(Register Rd, Register Rn, int64_t increment, Register temp) {\n-  if (is_imm_in_range(increment, 12, 0)) {\n-    addi(Rd, Rn, increment);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, increment);\n-    add(Rd, Rn, temp);\n-  }\n-}\n\n-void Assembler::addw(Register Rd, Register Rn, int32_t increment, Register temp) {\n-  if (is_imm_in_range(increment, 12, 0)) {\n-    addiw(Rd, Rn, increment);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, increment);\n-    addw(Rd, Rn, temp);\n-  }\n-}\n\n-void Assembler::sub(Register Rd, Register Rn, int64_t decrement, Register temp) {\n-  if (is_imm_in_range(-decrement, 12, 0)) {\n-    addi(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    sub(Rd, Rn, temp);\n-  }\n-}\n\n-void Assembler::subw(Register Rd, Register Rn, int32_t decrement, Register temp) {\n-  if (is_imm_in_range(-decrement, 12, 0)) {\n-    addiw(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    subw(Rd, Rn, temp);\n-  }\n-}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：assembler_riscv.cpp文件中包含大量辅助函数（如add、addw、sub、subw等），这些函数处理立即数加载和算术操作，增加了代码复杂性和维护成本。优化后：将这些辅助函数从assembler_riscv.cpp中移除，简化了汇编器实现，减少了代码冗余。优化思路：通过代码重构和清理，将通用功能集中到macroAssembler_riscv模块中，提高代码模块化、可维护性和编译效率，同时保持功能不变。"}
{"id": 74, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化+内存布局优化", "optimization_description": "优化前：Address类使用多个独立字段存储不同寻址模式的数据，包括_base、_index、_offset、_target、_rspec等，无论当前使用哪种寻址模式，所有字段都占用内存空间，存在内存浪费。优化后：将Address重构为带标签的联合体（discriminated union），根据_mode字段的值，只存储当前寻址模式所需的数据（literal模式存储Literal结构体，其他模式存储Nonliteral结构体），消除了未使用字段的内存开销。优化思路是通过联合体实现内存布局优化，减少对象大小，提高缓存利用率。", "original_code": "Address类使用多个独立字段存储不同寻址模式的数据，包括_base、_index、_offset、_target、_rspec等，无论当前使用哪种寻址模式，所有字段都占用内存空间，存在内存浪费。", "optimized_code": "// 头文件修改：\n-  enum mode { no_mode, base_plus_offset, pcrel, literal };\n+  enum mode { no_mode, base_plus_offset, literal };\n\n-  Register _base;\n-  Register _index;\n-  int64_t _offset;\n-  enum mode _mode;\n-  RelocationHolder _rspec;\n-  address          _target;\n+  struct Nonliteral {\n+    Nonliteral(Register base, Register index, int64_t offset)\n+      : _base(base), _index(index), _offset(offset) {}\n+    Register _base;\n+    Register _index;\n+    int64_t _offset;\n+  };\n+  struct Literal {\n+    Literal(address target, const RelocationHolder& rspec)\n+      : _target(target), _rspec(rspec) {}\n+    address _target;\n+    RelocationHolder _rspec;\n+  };\n+  enum mode _mode;\n+  union {\n+    Nonliteral _nonliteral;\n+    Literal _literal;\n+  };\n\n// 源文件修改：\n-Address::Address(address target, relocInfo::relocType rtype) : _base(noreg), _offset(0), _mode(literal) {\n-  _target = target;\n-  switch (rtype) {\n-    case relocInfo::oop_type:\n-    case relocInfo::metadata_type:\n-    case relocInfo::none:\n-      _rspec = RelocationHolder::none;\n-      break;\n-    case relocInfo::external_word_type:\n-      _rspec = external_word_Relocation::spec(target);\n-      break;\n-    // ... 其他case分支类似\n-  }\n-}\n+static RelocationHolder address_relocation(address target, relocInfo::relocType rtype) {\n+  switch (rtype) {\n+    case relocInfo::oop_type:\n+    case relocInfo::metadata_type:\n+    case relocInfo::none:\n+      return RelocationHolder::none;\n+    case relocInfo::external_word_type:\n+      return external_word_Relocation::spec(target);\n+    // ... 其他case分支类似\n+  }\n+}\n+Address::Address(address target, relocInfo::relocType rtype) :\n+  _mode(literal),\n+  _literal(target, address_relocation(target, rtype))\n+{}", "source_url": "https://github.com/openjdk/jdk/commit/226e579c3004a37a09f3329a8ef09c0933126bd6", "code_v0_no_empty_lines": "Address类使用多个独立字段存储不同寻址模式的数据，包括_base、_index、_offset、_target、_rspec等，无论当前使用哪种寻址模式，所有字段都占用内存空间，存在内存浪费。", "code_v1_no_empty_lines": "// 头文件修改：\n-  enum mode { no_mode, base_plus_offset, pcrel, literal };\n+  enum mode { no_mode, base_plus_offset, literal };\n\n-  Register _base;\n-  Register _index;\n-  int64_t _offset;\n-  enum mode _mode;\n-  RelocationHolder _rspec;\n-  address          _target;\n+  struct Nonliteral {\n+    Nonliteral(Register base, Register index, int64_t offset)\n+      : _base(base), _index(index), _offset(offset) {}\n+    Register _base;\n+    Register _index;\n+    int64_t _offset;\n+  };\n+  struct Literal {\n+    Literal(address target, const RelocationHolder& rspec)\n+      : _target(target), _rspec(rspec) {}\n+    address _target;\n+    RelocationHolder _rspec;\n+  };\n+  enum mode _mode;\n+  union {\n+    Nonliteral _nonliteral;\n+    Literal _literal;\n+  };\n\n// 源文件修改：\n-Address::Address(address target, relocInfo::relocType rtype) : _base(noreg), _offset(0), _mode(literal) {\n-  _target = target;\n-  switch (rtype) {\n-    case relocInfo::oop_type:\n-    case relocInfo::metadata_type:\n-    case relocInfo::none:\n-      _rspec = RelocationHolder::none;\n-      break;\n-    case relocInfo::external_word_type:\n-      _rspec = external_word_Relocation::spec(target);\n-      break;\n-    // ... 其他case分支类似\n-  }\n-}\n+static RelocationHolder address_relocation(address target, relocInfo::relocType rtype) {\n+  switch (rtype) {\n+    case relocInfo::oop_type:\n+    case relocInfo::metadata_type:\n+    case relocInfo::none:\n+      return RelocationHolder::none;\n+    case relocInfo::external_word_type:\n+      return external_word_Relocation::spec(target);\n+    // ... 其他case分支类似\n+  }\n+}\n+Address::Address(address target, relocInfo::relocType rtype) :\n+  _mode(literal),\n+  _literal(target, address_relocation(target, rtype))\n+{}", "target": "// 头文件修改：\n-  enum mode { no_mode, base_plus_offset, pcrel, literal };\n+  enum mode { no_mode, base_plus_offset, literal };\n\n-  Register _base;\n-  Register _index;\n-  int64_t _offset;\n-  enum mode _mode;\n-  RelocationHolder _rspec;\n-  address          _target;\n+  struct Nonliteral {\n+    Nonliteral(Register base, Register index, int64_t offset)\n+      : _base(base), _index(index), _offset(offset) {}\n+    Register _base;\n+    Register _index;\n+    int64_t _offset;\n+  };\n+  struct Literal {\n+    Literal(address target, const RelocationHolder& rspec)\n+      : _target(target), _rspec(rspec) {}\n+    address _target;\n+    RelocationHolder _rspec;\n+  };\n+  enum mode _mode;\n+  union {\n+    Nonliteral _nonliteral;\n+    Literal _literal;\n+  };\n\n// 源文件修改：\n-Address::Address(address target, relocInfo::relocType rtype) : _base(noreg), _offset(0), _mode(literal) {\n-  _target = target;\n-  switch (rtype) {\n-    case relocInfo::oop_type:\n-    case relocInfo::metadata_type:\n-    case relocInfo::none:\n-      _rspec = RelocationHolder::none;\n-      break;\n-    case relocInfo::external_word_type:\n-      _rspec = external_word_Relocation::spec(target);\n-      break;\n-    // ... 其他case分支类似\n-  }\n-}\n+static RelocationHolder address_relocation(address target, relocInfo::relocType rtype) {\n+  switch (rtype) {\n+    case relocInfo::oop_type:\n+    case relocInfo::metadata_type:\n+    case relocInfo::none:\n+      return RelocationHolder::none;\n+    case relocInfo::external_word_type:\n+      return external_word_Relocation::spec(target);\n+    // ... 其他case分支类似\n+  }\n+}\n+Address::Address(address target, relocInfo::relocType rtype) :\n+  _mode(literal),\n+  _literal(target, address_relocation(target, rtype))\n+{}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Address类使用多个独立字段存储不同寻址模式的数据，包括_base、_index、_offset、_target、_rspec等，无论当前使用哪种寻址模式，所有字段都占用内存空间，存在内存浪费。优化后：将Address重构为带标签的联合体（discriminated union），根据_mode字段的值，只存储当前寻址模式所需的数据（literal模式存储Literal结构体，其他模式存储Nonliteral结构体），消除了未使用字段的内存开销。优化思路是通过联合体实现内存布局优化，减少对象大小，提高缓存利用率。"}
{"id": 75, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+架构重构", "optimization_description": "优化前：C2编译器使用专门的表结构（如C2SafepointPollStubTable、C2EntryBarrierStubTable）管理代码桩（stub），每个功能有独立的表实现，导致代码重复和架构复杂。优化后：引入通用的C2CodeStub基类机制，统一管理所有类型的代码桩，通过add_stub()方法动态添加，简化了代码生成路径。优化思路是抽象化桩管理，减少平台特定代码重复，提高可维护性和扩展性。", "original_code": "C2编译器使用专门的表结构（如C2SafepointPollStubTable、C2EntryBarrierStubTable）管理代码桩（stub），每个功能有独立的表实现，导致代码重复和架构复杂。", "optimized_code": "- C2SafepointPollStubTable* safepoint_poll_table() const { return _safepoint_poll_table; }\n- C2EntryBarrierStubTable* entry_barrier_table() const { return _entry_barrier_table; }\n+ void add_stub(C2CodeStub* stub) { _stubs.add(stub); }\n+ C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+ C->output()->add_stub(stub);\n+ code_stub = &stub->entry();", "source_url": "https://github.com/openjdk/jdk/commit/b30b464d054716bbc3d4d70633b740b227b8775d", "code_v0_no_empty_lines": "C2编译器使用专门的表结构（如C2SafepointPollStubTable、C2EntryBarrierStubTable）管理代码桩（stub），每个功能有独立的表实现，导致代码重复和架构复杂。", "code_v1_no_empty_lines": "- C2SafepointPollStubTable* safepoint_poll_table() const { return _safepoint_poll_table; }\n- C2EntryBarrierStubTable* entry_barrier_table() const { return _entry_barrier_table; }\n+ void add_stub(C2CodeStub* stub) { _stubs.add(stub); }\n+ C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+ C->output()->add_stub(stub);\n+ code_stub = &stub->entry();", "target": "- C2SafepointPollStubTable* safepoint_poll_table() const { return _safepoint_poll_table; }\n- C2EntryBarrierStubTable* entry_barrier_table() const { return _entry_barrier_table; }\n+ void add_stub(C2CodeStub* stub) { _stubs.add(stub); }\n+ C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+ C->output()->add_stub(stub);\n+ code_stub = &stub->entry();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器使用专门的表结构（如C2SafepointPollStubTable、C2EntryBarrierStubTable）管理代码桩（stub），每个功能有独立的表实现，导致代码重复和架构复杂。优化后：引入通用的C2CodeStub基类机制，统一管理所有类型的代码桩，通过add_stub()方法动态添加，简化了代码生成路径。优化思路是抽象化桩管理，减少平台特定代码重复，提高可维护性和扩展性。"}
{"id": 76, "source": "riscv-dataset-excel", "optimization_type": "后端优化+指令生成", "optimization_description": "优化前：RISC-V后端在调用指令后缺少必要的NOP指令，可能导致分支预测和指令流水线效率降低。优化后：在call、ic_call和rt_call等调用指令后添加__post_call_nop()指令，填充延迟槽或对齐指令边界，提高分支预测准确性和流水线效率。优化思路是遵循RISC-V架构的最佳实践，通过添加NOP指令优化指令序列，提升处理器执行效率。", "original_code": "RISC-V后端在调用指令后缺少必要的NOP指令，可能导致分支预测和指令流水线效率降低。", "optimized_code": "diff --git a/src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp b/src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp\nindex 5394e1c3927da..35a4742728711 100644\n--- a/src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp\n+++ b/src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp\n@@ -1359,6 +1359,7 @@ void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {\n     return;\n   }\n   add_call_info(code_offset(), op->info());\n+  __ post_call_nop();\n }\n \n void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {\n@@ -1368,6 +1369,7 @@ void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {\n     return;\n   }\n   add_call_info(code_offset(), op->info());\n+  __ post_call_nop();\n }\n \n void LIR_Assembler::emit_static_call_stub() {\n@@ -1852,6 +1854,7 @@ void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* arg\n   if (info != NULL) {\n     add_call_info_here(info);\n   }\n+  __ post_call_nop();\n }", "source_url": "https://github.com/openjdk/jdk/commit/91292d56a9c2b8010466d105520e6e898ae53679", "code_v0_no_empty_lines": "RISC-V后端在调用指令后缺少必要的NOP指令，可能导致分支预测和指令流水线效率降低。", "code_v1_no_empty_lines": "diff --git a/src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp b/src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp\nindex 5394e1c3927da..35a4742728711 100644\n--- a/src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp\n+++ b/src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp\n@@ -1359,6 +1359,7 @@ void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {\n     return;\n   }\n   add_call_info(code_offset(), op->info());\n+  __ post_call_nop();\n }\n \n void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {\n@@ -1368,6 +1369,7 @@ void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {\n     return;\n   }\n   add_call_info(code_offset(), op->info());\n+  __ post_call_nop();\n }\n \n void LIR_Assembler::emit_static_call_stub() {\n@@ -1852,6 +1854,7 @@ void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* arg\n   if (info != NULL) {\n     add_call_info_here(info);\n   }\n+  __ post_call_nop();\n }", "target": "diff --git a/src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp b/src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp\nindex 5394e1c3927da..35a4742728711 100644\n--- a/src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp\n+++ b/src/hotspot/cpu/riscv/c1_LIRAssembler_riscv.cpp\n@@ -1359,6 +1359,7 @@ void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {\n     return;\n   }\n   add_call_info(code_offset(), op->info());\n+  __ post_call_nop();\n }\n \n void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {\n@@ -1368,6 +1369,7 @@ void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {\n     return;\n   }\n   add_call_info(code_offset(), op->info());\n+  __ post_call_nop();\n }\n \n void LIR_Assembler::emit_static_call_stub() {\n@@ -1852,6 +1854,7 @@ void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* arg\n   if (info != NULL) {\n     add_call_info_here(info);\n   }\n+  __ post_call_nop();\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V后端在调用指令后缺少必要的NOP指令，可能导致分支预测和指令流水线效率降低。优化后：在call、ic_call和rt_call等调用指令后添加__post_call_nop()指令，填充延迟槽或对齐指令边界，提高分支预测准确性和流水线效率。优化思路是遵循RISC-V架构的最佳实践，通过添加NOP指令优化指令序列，提升处理器执行效率。"}
{"id": 77, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：RISC-V后端不支持向量归约操作（AndReductionV、OrReductionV、XorReductionV），这些操作可能通过标量循环实现，性能较低。优化后：1. 在C2_MacroAssembler中新增reduce_operation函数，利用RISC-V向量扩展指令（vredand.vs、vredor.vs、vredxor.vs）实现向量归约操作；2. 在AD文件中添加对应的归约指令模式（reduce_andI、reduce_andL、reduce_orI、reduce_orL、reduce_xorI、reduce_xorL），支持整数和长整型向量归约。优化思路：通过硬件向量指令替代标量循环，利用SIMD并行性加速向量归约操作，提升Vector API性能。", "original_code": "RISC-V后端不支持向量归约操作（AndReductionV、OrReductionV、XorReductionV），这些操作可能通过标量循环实现，性能较低。", "optimized_code": "+void C2_MacroAssembler::reduce_operation(Register dst, VectorRegister tmp,\n+                                         Register src1, VectorRegister src2,\n+                                         BasicType bt, REDUCTION_OP op) {\n+  Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+  vsetvli(t0, x0, sew);\n+\n+  vmv_s_x(tmp, src1);\n+\n+  switch (op) {\n+    case REDUCTION_OP::ADD:\n+      vredsum_vs(tmp, src2, tmp);\n+      break;\n+    case REDUCTION_OP::AND:\n+      vredand_vs(tmp, src2, tmp);\n+      break;\n+    case REDUCTION_OP::OR:\n+      vredor_vs(tmp, src2, tmp);\n+      break;\n+    case REDUCTION_OP::XOR:\n+      vredxor_vs(tmp, src2, tmp);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  vmv_x_s(dst, tmp);\n+}\n\n+instruct reduce_andI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_andI\\n\\t\"\n+            \"vredand.vs $tmp, $src2, $tmp\\n\\t\"\n+            \"vmv.x.s $dst, $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_operation($dst$$Register, as_VectorRegister($tmp$$reg),\n+                        $src1$$Register, as_VectorRegister($src2$$reg), bt, REDUCTION_OP::AND);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}", "source_url": "https://github.com/openjdk/jdk/commit/087cedc080963f027306f9d4c4ab737ddf42a5bc", "code_v0_no_empty_lines": "RISC-V后端不支持向量归约操作（AndReductionV、OrReductionV、XorReductionV），这些操作可能通过标量循环实现，性能较低。", "code_v1_no_empty_lines": "+void C2_MacroAssembler::reduce_operation(Register dst, VectorRegister tmp,\n+                                         Register src1, VectorRegister src2,\n+                                         BasicType bt, REDUCTION_OP op) {\n+  Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+  vsetvli(t0, x0, sew);\n+\n+  vmv_s_x(tmp, src1);\n+\n+  switch (op) {\n+    case REDUCTION_OP::ADD:\n+      vredsum_vs(tmp, src2, tmp);\n+      break;\n+    case REDUCTION_OP::AND:\n+      vredand_vs(tmp, src2, tmp);\n+      break;\n+    case REDUCTION_OP::OR:\n+      vredor_vs(tmp, src2, tmp);\n+      break;\n+    case REDUCTION_OP::XOR:\n+      vredxor_vs(tmp, src2, tmp);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  vmv_x_s(dst, tmp);\n+}\n\n+instruct reduce_andI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_andI\\n\\t\"\n+            \"vredand.vs $tmp, $src2, $tmp\\n\\t\"\n+            \"vmv.x.s $dst, $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_operation($dst$$Register, as_VectorRegister($tmp$$reg),\n+                        $src1$$Register, as_VectorRegister($src2$$reg), bt, REDUCTION_OP::AND);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}", "target": "+void C2_MacroAssembler::reduce_operation(Register dst, VectorRegister tmp,\n+                                         Register src1, VectorRegister src2,\n+                                         BasicType bt, REDUCTION_OP op) {\n+  Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+  vsetvli(t0, x0, sew);\n+\n+  vmv_s_x(tmp, src1);\n+\n+  switch (op) {\n+    case REDUCTION_OP::ADD:\n+      vredsum_vs(tmp, src2, tmp);\n+      break;\n+    case REDUCTION_OP::AND:\n+      vredand_vs(tmp, src2, tmp);\n+      break;\n+    case REDUCTION_OP::OR:\n+      vredor_vs(tmp, src2, tmp);\n+      break;\n+    case REDUCTION_OP::XOR:\n+      vredxor_vs(tmp, src2, tmp);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  vmv_x_s(dst, tmp);\n+}\n\n+instruct reduce_andI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_andI\\n\\t\"\n+            \"vredand.vs $tmp, $src2, $tmp\\n\\t\"\n+            \"vmv.x.s $dst, $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_operation($dst$$Register, as_VectorRegister($tmp$$reg),\n+                        $src1$$Register, as_VectorRegister($src2$$reg), bt, REDUCTION_OP::AND);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V后端不支持向量归约操作（AndReductionV、OrReductionV、XorReductionV），这些操作可能通过标量循环实现，性能较低。优化后：1. 在C2_MacroAssembler中新增reduce_operation函数，利用RISC-V向量扩展指令（vredand.vs、vredor.vs、vredxor.vs）实现向量归约操作；2. 在AD文件中添加对应的归约指令模式（reduce_andI、reduce_andL、reduce_orI、reduce_orL、reduce_xorI、reduce_xorL），支持整数和长整型向量归约。优化思路：通过硬件向量指令替代标量循环，利用SIMD并行性加速向量归约操作，提升Vector API性能。"}
{"id": 78, "source": "riscv-dataset-excel", "optimization_type": "指令优化+NaN处理优化", "optimization_description": "优化前：使用fsflags/flt/frflags指令序列检测NaN，通过浮点比较设置标志位，然后检查标志位判断是否为NaN，最后在NaN情况下执行fadd生成NaN结果。优化后：使用fclass指令直接检查浮点数的类别位，通过位操作快速判断是否为NaN，如果是NaN则直接执行fadd返回NaN，否则执行fmin/fmax指令。优化思路：减少指令数量和依赖关系，避免不必要的标志位操作，利用RISC-V的fclass指令特性更高效地处理NaN情况，提升浮点最大值/最小值内联函数的性能。", "original_code": "使用fsflags/flt/frflags指令序列检测NaN，通过浮点比较设置标志位，然后检查标志位判断是否为NaN，最后在NaN情况下执行fadd生成NaN结果。", "optimized_code": "-  fsflags(zr);\n+  is_double ? fclass_d(t0, src1)\n+            : fclass_s(t0, src1);\n+  is_double ? fclass_d(t1, src2)\n+            : fclass_s(t1, src2);\n+  orr(t0, t0, t1);\n+  andi(t0, t0, 0b1100000000);\n+  beqz(t0, Compare);\n+  is_double ? fadd_d(dst, src1, src2)\n+            : fadd_s(dst, src1, src2);\n+  j(Done);\n+\n+  bind(Compare);\n   if (is_double) {\n     is_min ? fmin_d(dst, src1, src2)\n            : fmax_d(dst, src1, src2);\n-    // Checking NaNs\n-    flt_d(zr, src1, src2);\n   } else {\n     is_min ? fmin_s(dst, src1, src2)\n            : fmax_s(dst, src1, src2);\n-    // Checking NaNs\n-    flt_s(zr, src1, src2);\n   }\n-\n-  frflags(t0);\n-  beqz(t0, Done);\n-\n-  // In case of NaNs\n-  is_double ? fadd_d(dst, src1, src2)\n-            : fadd_s(dst, src1, src2);", "source_url": "https://github.com/openjdk/jdk/commit/99d3840d368f1d99af72250678a2cb0c55ee0957", "code_v0_no_empty_lines": "使用fsflags/flt/frflags指令序列检测NaN，通过浮点比较设置标志位，然后检查标志位判断是否为NaN，最后在NaN情况下执行fadd生成NaN结果。", "code_v1_no_empty_lines": "-  fsflags(zr);\n+  is_double ? fclass_d(t0, src1)\n+            : fclass_s(t0, src1);\n+  is_double ? fclass_d(t1, src2)\n+            : fclass_s(t1, src2);\n+  orr(t0, t0, t1);\n+  andi(t0, t0, 0b1100000000);\n+  beqz(t0, Compare);\n+  is_double ? fadd_d(dst, src1, src2)\n+            : fadd_s(dst, src1, src2);\n+  j(Done);\n+\n+  bind(Compare);\n   if (is_double) {\n     is_min ? fmin_d(dst, src1, src2)\n            : fmax_d(dst, src1, src2);\n-    // Checking NaNs\n-    flt_d(zr, src1, src2);\n   } else {\n     is_min ? fmin_s(dst, src1, src2)\n            : fmax_s(dst, src1, src2);\n-    // Checking NaNs\n-    flt_s(zr, src1, src2);\n   }\n-\n-  frflags(t0);\n-  beqz(t0, Done);\n-\n-  // In case of NaNs\n-  is_double ? fadd_d(dst, src1, src2)\n-            : fadd_s(dst, src1, src2);", "target": "-  fsflags(zr);\n+  is_double ? fclass_d(t0, src1)\n+            : fclass_s(t0, src1);\n+  is_double ? fclass_d(t1, src2)\n+            : fclass_s(t1, src2);\n+  orr(t0, t0, t1);\n+  andi(t0, t0, 0b1100000000);\n+  beqz(t0, Compare);\n+  is_double ? fadd_d(dst, src1, src2)\n+            : fadd_s(dst, src1, src2);\n+  j(Done);\n+\n+  bind(Compare);\n   if (is_double) {\n     is_min ? fmin_d(dst, src1, src2)\n            : fmax_d(dst, src1, src2);\n-    // Checking NaNs\n-    flt_d(zr, src1, src2);\n   } else {\n     is_min ? fmin_s(dst, src1, src2)\n            : fmax_s(dst, src1, src2);\n-    // Checking NaNs\n-    flt_s(zr, src1, src2);\n   }\n-\n-  frflags(t0);\n-  beqz(t0, Done);\n-\n-  // In case of NaNs\n-  is_double ? fadd_d(dst, src1, src2)\n-            : fadd_s(dst, src1, src2);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用fsflags/flt/frflags指令序列检测NaN，通过浮点比较设置标志位，然后检查标志位判断是否为NaN，最后在NaN情况下执行fadd生成NaN结果。优化后：使用fclass指令直接检查浮点数的类别位，通过位操作快速判断是否为NaN，如果是NaN则直接执行fadd返回NaN，否则执行fmin/fmax指令。优化思路：减少指令数量和依赖关系，避免不必要的标志位操作，利用RISC-V的fclass指令特性更高效地处理NaN情况，提升浮点最大值/最小值内联函数的性能。"}
{"id": 79, "source": "riscv-dataset-excel", "optimization_type": "向量化指令支持", "optimization_description": "优化前：RISC-V后端不支持带掩码的向量算术指令，Vector API无法充分利用RISC-V向量扩展。优化后：添加了vmerge_vxm/vim/vvm等向量合并指令，并实现了compare_integral_v和compare_floating_point_v函数来支持带掩码的向量比较操作。优化思路：通过扩展汇编器宏定义和C2宏汇编器，为RISC-V架构添加对掩码向量指令的支持，使Vector API能够生成更高效的向量化代码，提升数值计算性能。", "original_code": "RISC-V后端不支持带掩码的向量算术指令，Vector API无法充分利用RISC-V向量扩展。", "optimized_code": "INSN(vmerge_vxm,  0b1010111, 0b100, 0b0, 0b010111);\nINSN(vmerge_vim,  0b1010111, 0b011, 0b0, 0b010111);\nINSN(vmerge_vvm,  0b1010111, 0b000, 0b0, 0b010111);\nvoid compare_integral_v(VectorRegister vd, BasicType bt, int length_in_bytes,\n                        VectorRegister src1, VectorRegister src2, int cond, VectorMask vm);\nvoid compare_floating_point_v(VectorRegister vd, BasicType bt, int length_in_bytes,\n                              VectorRegister src1, VectorRegister src2,\n                              VectorRegister tmp1, VectorRegister tmp2,\n                              VectorRegister vmask, int cond, VectorMask vm);", "source_url": "https://github.com/openjdk/jdk/commit/1c1a73f715b291faabbc77d09d0f7b0ae65ebea7", "code_v0_no_empty_lines": "RISC-V后端不支持带掩码的向量算术指令，Vector API无法充分利用RISC-V向量扩展。", "code_v1_no_empty_lines": "INSN(vmerge_vxm,  0b1010111, 0b100, 0b0, 0b010111);\nINSN(vmerge_vim,  0b1010111, 0b011, 0b0, 0b010111);\nINSN(vmerge_vvm,  0b1010111, 0b000, 0b0, 0b010111);\nvoid compare_integral_v(VectorRegister vd, BasicType bt, int length_in_bytes,\n                        VectorRegister src1, VectorRegister src2, int cond, VectorMask vm);\nvoid compare_floating_point_v(VectorRegister vd, BasicType bt, int length_in_bytes,\n                              VectorRegister src1, VectorRegister src2,\n                              VectorRegister tmp1, VectorRegister tmp2,\n                              VectorRegister vmask, int cond, VectorMask vm);", "target": "INSN(vmerge_vxm,  0b1010111, 0b100, 0b0, 0b010111);\nINSN(vmerge_vim,  0b1010111, 0b011, 0b0, 0b010111);\nINSN(vmerge_vvm,  0b1010111, 0b000, 0b0, 0b010111);\nvoid compare_integral_v(VectorRegister vd, BasicType bt, int length_in_bytes,\n                        VectorRegister src1, VectorRegister src2, int cond, VectorMask vm);\nvoid compare_floating_point_v(VectorRegister vd, BasicType bt, int length_in_bytes,\n                              VectorRegister src1, VectorRegister src2,\n                              VectorRegister tmp1, VectorRegister tmp2,\n                              VectorRegister vmask, int cond, VectorMask vm);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V后端不支持带掩码的向量算术指令，Vector API无法充分利用RISC-V向量扩展。优化后：添加了vmerge_vxm/vim/vvm等向量合并指令，并实现了compare_integral_v和compare_floating_point_v函数来支持带掩码的向量比较操作。优化思路：通过扩展汇编器宏定义和C2宏汇编器，为RISC-V架构添加对掩码向量指令的支持，使Vector API能够生成更高效的向量化代码，提升数值计算性能。"}
{"id": 80, "source": "riscv-dataset-excel", "optimization_type": "向量指令支持扩展", "optimization_description": "优化前：RISC-V后端缺乏对Vector API中Extract、Compress、Expand等关键节点的支持，导致相关向量操作无法生成高效的硬件指令。优化后：1. 在assembler_riscv.hpp中添加了vslidedown_vi、vslidedown_vx、vfmerge_vfm、vsuxei32_v等向量指令支持；2. 在c2_MacroAssembler_riscv.cpp中实现了minmax_fp_masked_v等带掩码的浮点向量操作函数；3. 增强了reduce_minmax_fp_v和reduce_integral_v函数以支持掩码操作。优化思路：通过扩展RISC-V向量指令集支持，使Vector API能够生成更高效的硬件指令，减少软件模拟开销，提升向量化代码性能。", "original_code": "RISC-V后端缺乏对Vector API中Extract、Compress、Expand等关键节点的支持，导致相关向量操作无法生成高效的硬件指令。", "optimized_code": "+  INSN(vslidedown_vi, 0b1010111, 0b011, 0b001111);\n+  INSN(vslidedown_vx, 0b1010111, 0b100, 0b001111);\n+  INSN(vfmerge_vfm,  0b1010111, 0b101, 0b0, 0b010111);\n+  INSN(vsuxei32_v, 0b0100111, 0b110, 0b01, 0b0);\n+void C2_MacroAssembler::minmax_fp_masked_v(VectorRegister dst, VectorRegister src1, VectorRegister src2,\n+                                           VectorRegister vmask, VectorRegister tmp1, VectorRegister tmp2,\n+                                           bool is_double, bool is_min, int vector_length) {\n+  vsetvli_helper(is_double ? T_DOUBLE : T_FLOAT, vector_length);\n+  vmfeq_vv(tmp1, src1, src1);\n+  vmfeq_vv(tmp2, src2, src2);\n+  vmandn_mm(v0, vmask, tmp1);\n+  vfadd_vv(dst, src1, src1, Assembler::v0_t);\n+  vmandn_mm(v0, vmask, tmp2);\n+  vfadd_vv(dst, src2, src2, Assembler::v0_t);\n+  vmand_mm(tmp2, tmp1, tmp2);\n+  vmand_mm(v0, vmask, tmp2);\n+  is_min ? vfmin_vv(dst, src1, src2, Assembler::v0_t)\n+         : vfmax_vv(dst, src1, src2, Assembler::v0_t);\n+}", "source_url": "https://github.com/openjdk/jdk/commit/97ade57fb244b17e93b150b7f9e025a5ba906bb2", "code_v0_no_empty_lines": "RISC-V后端缺乏对Vector API中Extract、Compress、Expand等关键节点的支持，导致相关向量操作无法生成高效的硬件指令。", "code_v1_no_empty_lines": "+  INSN(vslidedown_vi, 0b1010111, 0b011, 0b001111);\n+  INSN(vslidedown_vx, 0b1010111, 0b100, 0b001111);\n+  INSN(vfmerge_vfm,  0b1010111, 0b101, 0b0, 0b010111);\n+  INSN(vsuxei32_v, 0b0100111, 0b110, 0b01, 0b0);\n+void C2_MacroAssembler::minmax_fp_masked_v(VectorRegister dst, VectorRegister src1, VectorRegister src2,\n+                                           VectorRegister vmask, VectorRegister tmp1, VectorRegister tmp2,\n+                                           bool is_double, bool is_min, int vector_length) {\n+  vsetvli_helper(is_double ? T_DOUBLE : T_FLOAT, vector_length);\n+  vmfeq_vv(tmp1, src1, src1);\n+  vmfeq_vv(tmp2, src2, src2);\n+  vmandn_mm(v0, vmask, tmp1);\n+  vfadd_vv(dst, src1, src1, Assembler::v0_t);\n+  vmandn_mm(v0, vmask, tmp2);\n+  vfadd_vv(dst, src2, src2, Assembler::v0_t);\n+  vmand_mm(tmp2, tmp1, tmp2);\n+  vmand_mm(v0, vmask, tmp2);\n+  is_min ? vfmin_vv(dst, src1, src2, Assembler::v0_t)\n+         : vfmax_vv(dst, src1, src2, Assembler::v0_t);\n+}", "target": "+  INSN(vslidedown_vi, 0b1010111, 0b011, 0b001111);\n+  INSN(vslidedown_vx, 0b1010111, 0b100, 0b001111);\n+  INSN(vfmerge_vfm,  0b1010111, 0b101, 0b0, 0b010111);\n+  INSN(vsuxei32_v, 0b0100111, 0b110, 0b01, 0b0);\n+void C2_MacroAssembler::minmax_fp_masked_v(VectorRegister dst, VectorRegister src1, VectorRegister src2,\n+                                           VectorRegister vmask, VectorRegister tmp1, VectorRegister tmp2,\n+                                           bool is_double, bool is_min, int vector_length) {\n+  vsetvli_helper(is_double ? T_DOUBLE : T_FLOAT, vector_length);\n+  vmfeq_vv(tmp1, src1, src1);\n+  vmfeq_vv(tmp2, src2, src2);\n+  vmandn_mm(v0, vmask, tmp1);\n+  vfadd_vv(dst, src1, src1, Assembler::v0_t);\n+  vmandn_mm(v0, vmask, tmp2);\n+  vfadd_vv(dst, src2, src2, Assembler::v0_t);\n+  vmand_mm(tmp2, tmp1, tmp2);\n+  vmand_mm(v0, vmask, tmp2);\n+  is_min ? vfmin_vv(dst, src1, src2, Assembler::v0_t)\n+         : vfmax_vv(dst, src1, src2, Assembler::v0_t);\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V后端缺乏对Vector API中Extract、Compress、Expand等关键节点的支持，导致相关向量操作无法生成高效的硬件指令。优化后：1. 在assembler_riscv.hpp中添加了vslidedown_vi、vslidedown_vx、vfmerge_vfm、vsuxei32_v等向量指令支持；2. 在c2_MacroAssembler_riscv.cpp中实现了minmax_fp_masked_v等带掩码的浮点向量操作函数；3. 增强了reduce_minmax_fp_v和reduce_integral_v函数以支持掩码操作。优化思路：通过扩展RISC-V向量指令集支持，使Vector API能够生成更高效的硬件指令，减少软件模拟开销，提升向量化代码性能。"}
{"id": 81, "source": "riscv-dataset-excel", "optimization_type": "寄存器分配优化", "optimization_description": "优化前：多个向量操作（如字符串比较、数组清零、字符查找等）都使用v0作为临时向量寄存器，导致寄存器分配冲突和性能瓶颈。优化后：将v0的使用替换为v2、v4、v6、v8等更高编号的向量寄存器，并新增v8-v11寄存器定义，分散寄存器压力。优化思路：避免使用v0（可能被系统保留或频繁使用），通过使用更多可用的向量寄存器来减少冲突，提高指令级并行性和整体性能。", "original_code": "多个向量操作（如字符串比较、数组清零、字符查找等）都使用v0作为临时向量寄存器，导致寄存器分配冲突和性能瓶颈。", "optimized_code": "- element_compare(a1, a2, result, cnt, tmp1, tmp2, v0, v2, v0, elem_size == 1, DONE);\n+ element_compare(a1, a2, result, cnt, tmp1, tmp2, v2, v4, v2, elem_size == 1, DONE);\n- vxor_vv(v0, v0, v0);\n+ vxor_vv(v4, v4, v4);\n- vse64_v(v0, base);\n+ vse64_v(v4, base);\n- vle8_v(v0, ary);\n+ vle8_v(v4, ary);\n- vmslt_vx(v0, v0, zr);\n+ vmslt_vx(v4, v4, zr);\n- vfirst_m(tmp, v0);\n+ vfirst_m(tmp, v4);", "source_url": "https://github.com/openjdk/jdk/commit/e21f865d84c7c861843ff568019e1ad11d280a50", "code_v0_no_empty_lines": "多个向量操作（如字符串比较、数组清零、字符查找等）都使用v0作为临时向量寄存器，导致寄存器分配冲突和性能瓶颈。", "code_v1_no_empty_lines": "- element_compare(a1, a2, result, cnt, tmp1, tmp2, v0, v2, v0, elem_size == 1, DONE);\n+ element_compare(a1, a2, result, cnt, tmp1, tmp2, v2, v4, v2, elem_size == 1, DONE);\n- vxor_vv(v0, v0, v0);\n+ vxor_vv(v4, v4, v4);\n- vse64_v(v0, base);\n+ vse64_v(v4, base);\n- vle8_v(v0, ary);\n+ vle8_v(v4, ary);\n- vmslt_vx(v0, v0, zr);\n+ vmslt_vx(v4, v4, zr);\n- vfirst_m(tmp, v0);\n+ vfirst_m(tmp, v4);", "target": "- element_compare(a1, a2, result, cnt, tmp1, tmp2, v0, v2, v0, elem_size == 1, DONE);\n+ element_compare(a1, a2, result, cnt, tmp1, tmp2, v2, v4, v2, elem_size == 1, DONE);\n- vxor_vv(v0, v0, v0);\n+ vxor_vv(v4, v4, v4);\n- vse64_v(v0, base);\n+ vse64_v(v4, base);\n- vle8_v(v0, ary);\n+ vle8_v(v4, ary);\n- vmslt_vx(v0, v0, zr);\n+ vmslt_vx(v4, v4, zr);\n- vfirst_m(tmp, v0);\n+ vfirst_m(tmp, v4);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多个向量操作（如字符串比较、数组清零、字符查找等）都使用v0作为临时向量寄存器，导致寄存器分配冲突和性能瓶颈。优化后：将v0的使用替换为v2、v4、v6、v8等更高编号的向量寄存器，并新增v8-v11寄存器定义，分散寄存器压力。优化思路：避免使用v0（可能被系统保留或频繁使用），通过使用更多可用的向量寄存器来减少冲突，提高指令级并行性和整体性能。"}
{"id": 82, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：RISC-V平台缺少Math.signum函数的向量化实现，只能使用标量计算。优化后：新增向量化signum_fp_v函数，利用RISC-V向量扩展指令集（RVV）实现并行符号计算。优化思路：通过vfclass_v指令分类浮点数，识别零值和NaN，然后使用vfsgnj_vv指令将输入符号注入到1.0中，实现向量化的符号函数计算，显著提升浮点数组处理性能。", "original_code": "RISC-V平台缺少Math.signum函数的向量化实现，只能使用标量计算。", "optimized_code": "void C2_MacroAssembler::signum_fp_v(VectorRegister dst, VectorRegister one, BasicType bt, int vlen) {\n  vsetvli_helper(bt, vlen);\n\n  // check if input is -0, +0, signaling NaN or quiet NaN\n  vfclass_v(v0, dst);\n  mv(t0, fclass_mask::zero | fclass_mask::nan);\n  vand_vx(v0, v0, t0);\n  vmseq_vi(v0, v0, 0);\n\n  // use floating-point 1.0 with a sign of input\n  vfsgnj_vv(dst, one, dst, v0_t);\n}", "source_url": "https://github.com/openjdk/jdk/commit/2f9e70e4ad94af0b94fd2fbc97356b32f0b73628", "code_v0_no_empty_lines": "RISC-V平台缺少Math.signum函数的向量化实现，只能使用标量计算。", "code_v1_no_empty_lines": "void C2_MacroAssembler::signum_fp_v(VectorRegister dst, VectorRegister one, BasicType bt, int vlen) {\n  vsetvli_helper(bt, vlen);\n\n  // check if input is -0, +0, signaling NaN or quiet NaN\n  vfclass_v(v0, dst);\n  mv(t0, fclass_mask::zero | fclass_mask::nan);\n  vand_vx(v0, v0, t0);\n  vmseq_vi(v0, v0, 0);\n\n  // use floating-point 1.0 with a sign of input\n  vfsgnj_vv(dst, one, dst, v0_t);\n}", "target": "void C2_MacroAssembler::signum_fp_v(VectorRegister dst, VectorRegister one, BasicType bt, int vlen) {\n  vsetvli_helper(bt, vlen);\n\n  // check if input is -0, +0, signaling NaN or quiet NaN\n  vfclass_v(v0, dst);\n  mv(t0, fclass_mask::zero | fclass_mask::nan);\n  vand_vx(v0, v0, t0);\n  vmseq_vi(v0, v0, 0);\n\n  // use floating-point 1.0 with a sign of input\n  vfsgnj_vv(dst, one, dst, v0_t);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V平台缺少Math.signum函数的向量化实现，只能使用标量计算。优化后：新增向量化signum_fp_v函数，利用RISC-V向量扩展指令集（RVV）实现并行符号计算。优化思路：通过vfclass_v指令分类浮点数，识别零值和NaN，然后使用vfsgnj_vv指令将输入符号注入到1.0中，实现向量化的符号函数计算，显著提升浮点数组处理性能。"}
{"id": 83, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+内联汇编优化", "optimization_description": "优化前：RISC-V平台缺少copySign和signum浮点运算的硬件指令支持，需要通过软件模拟实现，性能较低。优化后：1. 新增signum_fp汇编函数，利用RISC-V的fclass指令检测特殊值（NaN/±0），使用fsgnj指令高效处理符号复制；2. 在riscv.ad中新增copySignD/F和signumD/F指令模式，将高级操作映射到硬件指令；3. 在vm_version中默认启用UseCopySignIntrinsic和UseSignumIntrinsic标志。优化思路：利用RISC-V指令集特性，将浮点符号操作从软件模拟转为硬件指令执行，减少函数调用开销，提升数学运算性能。", "original_code": "RISC-V平台缺少copySign和signum浮点运算的硬件指令支持，需要通过软件模拟实现，性能较低。", "optimized_code": "void C2_MacroAssembler::signum_fp(FloatRegister dst, FloatRegister src, FloatRegister one, bool is_double) {\n  Register tmp1 = t0;\n  Label done;\n  is_double ? fclass_d(tmp1, src)\n            : fclass_s(tmp1, src);\n  is_double ? fmv_d(dst, src)\n            : fmv_s(dst, src);\n  andi(tmp1, tmp1, 0b1100011000);\n  bnez(tmp1, done);\n  is_double ? fsgnj_d(dst, one, src)\n            : fsgnj_s(dst, one, src);\n  bind(done);\n}", "source_url": "https://github.com/openjdk/jdk/commit/5a97411f857b0bc9e70b417efa76a5fd5f887fe0", "code_v0_no_empty_lines": "RISC-V平台缺少copySign和signum浮点运算的硬件指令支持，需要通过软件模拟实现，性能较低。", "code_v1_no_empty_lines": "void C2_MacroAssembler::signum_fp(FloatRegister dst, FloatRegister src, FloatRegister one, bool is_double) {\n  Register tmp1 = t0;\n  Label done;\n  is_double ? fclass_d(tmp1, src)\n            : fclass_s(tmp1, src);\n  is_double ? fmv_d(dst, src)\n            : fmv_s(dst, src);\n  andi(tmp1, tmp1, 0b1100011000);\n  bnez(tmp1, done);\n  is_double ? fsgnj_d(dst, one, src)\n            : fsgnj_s(dst, one, src);\n  bind(done);\n}", "target": "void C2_MacroAssembler::signum_fp(FloatRegister dst, FloatRegister src, FloatRegister one, bool is_double) {\n  Register tmp1 = t0;\n  Label done;\n  is_double ? fclass_d(tmp1, src)\n            : fclass_s(tmp1, src);\n  is_double ? fmv_d(dst, src)\n            : fmv_s(dst, src);\n  andi(tmp1, tmp1, 0b1100011000);\n  bnez(tmp1, done);\n  is_double ? fsgnj_d(dst, one, src)\n            : fsgnj_s(dst, one, src);\n  bind(done);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V平台缺少copySign和signum浮点运算的硬件指令支持，需要通过软件模拟实现，性能较低。优化后：1. 新增signum_fp汇编函数，利用RISC-V的fclass指令检测特殊值（NaN/±0），使用fsgnj指令高效处理符号复制；2. 在riscv.ad中新增copySignD/F和signumD/F指令模式，将高级操作映射到硬件指令；3. 在vm_version中默认启用UseCopySignIntrinsic和UseSignumIntrinsic标志。优化思路：利用RISC-V指令集特性，将浮点符号操作从软件模拟转为硬件指令执行，减少函数调用开销，提升数学运算性能。"}
{"id": 84, "source": "riscv-dataset-excel", "optimization_type": "向量化指令优化", "optimization_description": "优化前：Java的Integer/Long.compress()方法可能使用标量指令逐位处理，效率较低。优化后：新增compress_bits_v()函数，利用RISC-V向量扩展（RVV）指令实现向量化压缩操作，通过vcompress.vm等指令并行处理32位或64位数据。优化思路：利用硬件向量化能力，将位压缩操作从标量循环转换为单条向量指令，显著提升压缩操作的吞吐量，特别适用于大数据位操作场景。", "original_code": "Java的Integer/Long.compress()方法可能使用标量指令逐位处理，效率较低。", "optimized_code": "void C2_MacroAssembler::compress_bits_v(Register dst, Register src, Register mask, bool is_long) {\n  Assembler::SEW sew = is_long ? Assembler::e64 : Assembler::e32;\n  // intrinsic is enabled when MaxVectorSize >= 16\n  Assembler::LMUL lmul = is_long ? Assembler::m4 : Assembler::m2;\n  long len = is_long ? 64 : 32;\n\n  // load the src data(in bits) to be compressed.\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_s_x(v0, src);\n  // reset the src data(in bytes) to zero.\n  mv(t0, len);\n  vsetvli(x0, t0, Assembler::e8, lmul);\n  vmv_v_i(v4, 0);\n  // convert the src data from bits to bytes.\n  vmerge_vim(v4, v4, 1); // v0 as the implicit mask register\n  // reset the dst data(in bytes) to zero.\n  vmv_v_i(v8, 0);\n  // load the mask data(in bits).\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_s_x(v0, mask);\n  // compress the src data(in bytes) to dst(in bytes).\n  vsetvli(x0, t0, Assembler::e8, lmul);\n  vcompress_vm(v8, v4, v0);\n  // convert the dst data from bytes to bits.\n  vmseq_vi(v0, v8, 1);\n  // store result back.\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_x_s(dst, v0);\n}", "source_url": "https://github.com/openjdk/jdk/commit/cb7875d57db652cd49cdc09a92d2c1be2b5ec66a", "code_v0_no_empty_lines": "Java的Integer/Long.compress()方法可能使用标量指令逐位处理，效率较低。", "code_v1_no_empty_lines": "void C2_MacroAssembler::compress_bits_v(Register dst, Register src, Register mask, bool is_long) {\n  Assembler::SEW sew = is_long ? Assembler::e64 : Assembler::e32;\n  // intrinsic is enabled when MaxVectorSize >= 16\n  Assembler::LMUL lmul = is_long ? Assembler::m4 : Assembler::m2;\n  long len = is_long ? 64 : 32;\n\n  // load the src data(in bits) to be compressed.\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_s_x(v0, src);\n  // reset the src data(in bytes) to zero.\n  mv(t0, len);\n  vsetvli(x0, t0, Assembler::e8, lmul);\n  vmv_v_i(v4, 0);\n  // convert the src data from bits to bytes.\n  vmerge_vim(v4, v4, 1); // v0 as the implicit mask register\n  // reset the dst data(in bytes) to zero.\n  vmv_v_i(v8, 0);\n  // load the mask data(in bits).\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_s_x(v0, mask);\n  // compress the src data(in bytes) to dst(in bytes).\n  vsetvli(x0, t0, Assembler::e8, lmul);\n  vcompress_vm(v8, v4, v0);\n  // convert the dst data from bytes to bits.\n  vmseq_vi(v0, v8, 1);\n  // store result back.\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_x_s(dst, v0);\n}", "target": "void C2_MacroAssembler::compress_bits_v(Register dst, Register src, Register mask, bool is_long) {\n  Assembler::SEW sew = is_long ? Assembler::e64 : Assembler::e32;\n  // intrinsic is enabled when MaxVectorSize >= 16\n  Assembler::LMUL lmul = is_long ? Assembler::m4 : Assembler::m2;\n  long len = is_long ? 64 : 32;\n\n  // load the src data(in bits) to be compressed.\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_s_x(v0, src);\n  // reset the src data(in bytes) to zero.\n  mv(t0, len);\n  vsetvli(x0, t0, Assembler::e8, lmul);\n  vmv_v_i(v4, 0);\n  // convert the src data from bits to bytes.\n  vmerge_vim(v4, v4, 1); // v0 as the implicit mask register\n  // reset the dst data(in bytes) to zero.\n  vmv_v_i(v8, 0);\n  // load the mask data(in bits).\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_s_x(v0, mask);\n  // compress the src data(in bytes) to dst(in bytes).\n  vsetvli(x0, t0, Assembler::e8, lmul);\n  vcompress_vm(v8, v4, v0);\n  // convert the dst data from bytes to bits.\n  vmseq_vi(v0, v8, 1);\n  // store result back.\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_x_s(dst, v0);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Java的Integer/Long.compress()方法可能使用标量指令逐位处理，效率较低。优化后：新增compress_bits_v()函数，利用RISC-V向量扩展（RVV）指令实现向量化压缩操作，通过vcompress.vm等指令并行处理32位或64位数据。优化思路：利用硬件向量化能力，将位压缩操作从标量循环转换为单条向量指令，显著提升压缩操作的吞吐量，特别适用于大数据位操作场景。"}
{"id": 85, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+指令集优化", "optimization_description": "优化前：RISC-V平台缺少对Java的Integer/Long.expand()方法的向量化实现，只能使用标量指令处理位扩展操作。优化后：新增了expand_bits_v()函数及其变体，利用RISC-V向量扩展（RVV）指令实现高效的位扩展操作，通过向量寄存器v0、v4、v8、v12等，使用viota.m和vrgather.vv等向量指令并行处理数据。优化思路：利用RISC-V的向量处理能力，将原本需要多次循环的位操作转换为单次向量操作，显著提升位扩展操作的性能，特别是在处理大数据集时效果更明显。", "original_code": "RISC-V平台缺少对Java的Integer/Long.expand()方法的向量化实现，只能使用标量指令处理位扩展操作。", "optimized_code": "void C2_MacroAssembler::expand_bits_v(Register dst, Register src, Register mask, bool is_long) {\n  Assembler::SEW sew = is_long ? Assembler::e64 : Assembler::e32;\n  // intrinsic is enabled when MaxVectorSize >= 16\n  Assembler::LMUL lmul = is_long ? Assembler::m4 : Assembler::m2;\n  long len = is_long ? 64 : 32;\n\n  // load the src data(in bits) to be expanded.\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_s_x(v0, src);\n  // reset the src data(in bytes) to zero.\n  mv(t0, len);\n  vsetvli(x0, t0, Assembler::e8, lmul);\n  vmv_v_i(v4, 0);\n  // convert the src data from bits to bytes.\n  vmerge_vim(v4, v4, 1); // v0 as implicit mask register\n  // reset the dst data(in bytes) to zero.\n  vmv_v_i(v12, 0);\n  // load the mask data(in bits).\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_s_x(v0, mask);\n  // expand the src data(in bytes) to dst(in bytes).\n  vsetvli(x0, t0, Assembler::e8, lmul);\n  viota_m(v8, v0);\n  vrgather_vv(v12, v4, v8, VectorMask::v0_t); // v0 as implicit mask register\n  // convert the dst data from bytes to bits.\n  vmseq_vi(v0, v12, 1);\n  // store result back.\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_x_s(dst, v0);\n}", "source_url": "https://github.com/openjdk/jdk/commit/3c6ffcadfec42c544c9b0d4188e50135f608b9db", "code_v0_no_empty_lines": "RISC-V平台缺少对Java的Integer/Long.expand()方法的向量化实现，只能使用标量指令处理位扩展操作。", "code_v1_no_empty_lines": "void C2_MacroAssembler::expand_bits_v(Register dst, Register src, Register mask, bool is_long) {\n  Assembler::SEW sew = is_long ? Assembler::e64 : Assembler::e32;\n  // intrinsic is enabled when MaxVectorSize >= 16\n  Assembler::LMUL lmul = is_long ? Assembler::m4 : Assembler::m2;\n  long len = is_long ? 64 : 32;\n\n  // load the src data(in bits) to be expanded.\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_s_x(v0, src);\n  // reset the src data(in bytes) to zero.\n  mv(t0, len);\n  vsetvli(x0, t0, Assembler::e8, lmul);\n  vmv_v_i(v4, 0);\n  // convert the src data from bits to bytes.\n  vmerge_vim(v4, v4, 1); // v0 as implicit mask register\n  // reset the dst data(in bytes) to zero.\n  vmv_v_i(v12, 0);\n  // load the mask data(in bits).\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_s_x(v0, mask);\n  // expand the src data(in bytes) to dst(in bytes).\n  vsetvli(x0, t0, Assembler::e8, lmul);\n  viota_m(v8, v0);\n  vrgather_vv(v12, v4, v8, VectorMask::v0_t); // v0 as implicit mask register\n  // convert the dst data from bytes to bits.\n  vmseq_vi(v0, v12, 1);\n  // store result back.\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_x_s(dst, v0);\n}", "target": "void C2_MacroAssembler::expand_bits_v(Register dst, Register src, Register mask, bool is_long) {\n  Assembler::SEW sew = is_long ? Assembler::e64 : Assembler::e32;\n  // intrinsic is enabled when MaxVectorSize >= 16\n  Assembler::LMUL lmul = is_long ? Assembler::m4 : Assembler::m2;\n  long len = is_long ? 64 : 32;\n\n  // load the src data(in bits) to be expanded.\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_s_x(v0, src);\n  // reset the src data(in bytes) to zero.\n  mv(t0, len);\n  vsetvli(x0, t0, Assembler::e8, lmul);\n  vmv_v_i(v4, 0);\n  // convert the src data from bits to bytes.\n  vmerge_vim(v4, v4, 1); // v0 as implicit mask register\n  // reset the dst data(in bytes) to zero.\n  vmv_v_i(v12, 0);\n  // load the mask data(in bits).\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_s_x(v0, mask);\n  // expand the src data(in bytes) to dst(in bytes).\n  vsetvli(x0, t0, Assembler::e8, lmul);\n  viota_m(v8, v0);\n  vrgather_vv(v12, v4, v8, VectorMask::v0_t); // v0 as implicit mask register\n  // convert the dst data from bytes to bits.\n  vmseq_vi(v0, v12, 1);\n  // store result back.\n  vsetivli(x0, 1, sew, Assembler::m1);\n  vmv_x_s(dst, v0);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V平台缺少对Java的Integer/Long.expand()方法的向量化实现，只能使用标量指令处理位扩展操作。优化后：新增了expand_bits_v()函数及其变体，利用RISC-V向量扩展（RVV）指令实现高效的位扩展操作，通过向量寄存器v0、v4、v8、v12等，使用viota.m和vrgather.vv等向量指令并行处理数据。优化思路：利用RISC-V的向量处理能力，将原本需要多次循环的位操作转换为单次向量操作，显著提升位扩展操作的性能，特别是在处理大数据集时效果更明显。"}
{"id": 86, "source": "riscv-dataset-excel", "optimization_type": "SIMD向量化优化", "optimization_description": "优化前：数组哈希计算采用标量方式逐个元素处理，每次迭代计算 result = 31 * result + array[i]，循环开销大且无法利用现代CPU的并行能力。优化后：实现向量化哈希计算，通过展开循环每次处理4个元素（stride=4），使用预计算的31的幂次（31^4, 31^3, 31^2）和移位优化（31*result优化为result<<5 - result），将4个元素的计算并行化。优化思路：利用循环展开和指令级并行，减少循环迭代次数，通过预计算常数和优化乘法操作为移位加减，显著提升数组哈希计算的性能。", "original_code": "数组哈希计算采用标量方式逐个元素处理，每次迭代计算 result = 31 * result + array[i]，循环开销大且无法利用现代CPU的并行能力。", "optimized_code": "+void C2_MacroAssembler::arrays_hashcode(Register ary, Register cnt, Register result,\n+                                        Register tmp1, Register tmp2, Register tmp3,\n+                                        Register tmp4, Register tmp5, Register tmp6,\n+                                        BasicType eltype)\n+{\n+  // ... 向量化哈希计算实现 ...\n+  bind(WIDE_LOOP);\n+  mulw(result, result, pow31_4); // 31^^4 * h\n+  arrays_hashcode_elload(t0,   Address(ary, 0 * elsize), eltype);\n+  arrays_hashcode_elload(t1,   Address(ary, 1 * elsize), eltype);\n+  arrays_hashcode_elload(tmp5, Address(ary, 2 * elsize), eltype);\n+  arrays_hashcode_elload(tmp6, Address(ary, 3 * elsize), eltype);\n+  // ... 并行处理4个元素 ...\n+  addi(ary, ary, elsize * stride);\n+  bne(ary, chunks_end, WIDE_LOOP);", "source_url": "https://github.com/openjdk/jdk/commit/6359b4ec2303e9cd81f3cbcfdf1c3e015278cb7b", "code_v0_no_empty_lines": "数组哈希计算采用标量方式逐个元素处理，每次迭代计算 result = 31 * result + array[i]，循环开销大且无法利用现代CPU的并行能力。", "code_v1_no_empty_lines": "+void C2_MacroAssembler::arrays_hashcode(Register ary, Register cnt, Register result,\n+                                        Register tmp1, Register tmp2, Register tmp3,\n+                                        Register tmp4, Register tmp5, Register tmp6,\n+                                        BasicType eltype)\n+{\n+  // ... 向量化哈希计算实现 ...\n+  bind(WIDE_LOOP);\n+  mulw(result, result, pow31_4); // 31^^4 * h\n+  arrays_hashcode_elload(t0,   Address(ary, 0 * elsize), eltype);\n+  arrays_hashcode_elload(t1,   Address(ary, 1 * elsize), eltype);\n+  arrays_hashcode_elload(tmp5, Address(ary, 2 * elsize), eltype);\n+  arrays_hashcode_elload(tmp6, Address(ary, 3 * elsize), eltype);\n+  // ... 并行处理4个元素 ...\n+  addi(ary, ary, elsize * stride);\n+  bne(ary, chunks_end, WIDE_LOOP);", "target": "+void C2_MacroAssembler::arrays_hashcode(Register ary, Register cnt, Register result,\n+                                        Register tmp1, Register tmp2, Register tmp3,\n+                                        Register tmp4, Register tmp5, Register tmp6,\n+                                        BasicType eltype)\n+{\n+  // ... 向量化哈希计算实现 ...\n+  bind(WIDE_LOOP);\n+  mulw(result, result, pow31_4); // 31^^4 * h\n+  arrays_hashcode_elload(t0,   Address(ary, 0 * elsize), eltype);\n+  arrays_hashcode_elload(t1,   Address(ary, 1 * elsize), eltype);\n+  arrays_hashcode_elload(tmp5, Address(ary, 2 * elsize), eltype);\n+  arrays_hashcode_elload(tmp6, Address(ary, 3 * elsize), eltype);\n+  // ... 并行处理4个元素 ...\n+  addi(ary, ary, elsize * stride);\n+  bne(ary, chunks_end, WIDE_LOOP);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：数组哈希计算采用标量方式逐个元素处理，每次迭代计算 result = 31 * result + array[i]，循环开销大且无法利用现代CPU的并行能力。优化后：实现向量化哈希计算，通过展开循环每次处理4个元素（stride=4），使用预计算的31的幂次（31^4, 31^3, 31^2）和移位优化（31*result优化为result<<5 - result），将4个元素的计算并行化。优化思路：利用循环展开和指令级并行，减少循环迭代次数，通过预计算常数和优化乘法操作为移位加减，显著提升数组哈希计算的性能。"}
{"id": 87, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+性能优化", "optimization_description": "优化前：RISC-V架构缺少ConvF2HF（单精度浮点数转半精度浮点数）指令支持，需要软件模拟实现。优化后：1. 新增float_to_float16函数，利用RISC-V Zfh扩展的fcvt.h.s和fmv.x.h硬件指令直接转换；2. 针对NaN特殊情况，用feq_s指令替代fclass进行NaN检测（性能优化）；3. 添加慢速路径处理非规范NaN。优化思路：利用硬件指令加速常规浮点数转换，同时优化NaN检测逻辑，提升Java Float.floatToFloat16方法的执行效率。", "original_code": "RISC-V架构缺少ConvF2HF（单精度浮点数转半精度浮点数）指令支持，需要软件模拟实现。", "optimized_code": "void C2_MacroAssembler::float_to_float16(Register dst, FloatRegister src, FloatRegister ftmp, Register xtmp) {\n  auto stub = C2CodeStub::make<Register, FloatRegister, Register>(dst, src, xtmp, 130, float_to_float16_slow_path);\n\n  // in riscv, NaN needs a special process as fcvt does not work in that case.\n\n  // check whether it's a NaN.\n  // replace fclass with feq as performance optimization.\n  feq_s(t0, src, src);\n  // jump to stub processing NaN cases.\n  beqz(t0, stub->entry());\n\n  // non-NaN cases, just use built-in instructions.\n  fcvt_h_s(ftmp, src);\n  fmv_x_h(dst, ftmp);\n\n  bind(stub->continuation());\n}", "source_url": "https://github.com/openjdk/jdk/commit/bcaad515fdedd0c41a719d2a88b2da3036c766a3", "code_v0_no_empty_lines": "RISC-V架构缺少ConvF2HF（单精度浮点数转半精度浮点数）指令支持，需要软件模拟实现。", "code_v1_no_empty_lines": "void C2_MacroAssembler::float_to_float16(Register dst, FloatRegister src, FloatRegister ftmp, Register xtmp) {\n  auto stub = C2CodeStub::make<Register, FloatRegister, Register>(dst, src, xtmp, 130, float_to_float16_slow_path);\n\n  // in riscv, NaN needs a special process as fcvt does not work in that case.\n\n  // check whether it's a NaN.\n  // replace fclass with feq as performance optimization.\n  feq_s(t0, src, src);\n  // jump to stub processing NaN cases.\n  beqz(t0, stub->entry());\n\n  // non-NaN cases, just use built-in instructions.\n  fcvt_h_s(ftmp, src);\n  fmv_x_h(dst, ftmp);\n\n  bind(stub->continuation());\n}", "target": "void C2_MacroAssembler::float_to_float16(Register dst, FloatRegister src, FloatRegister ftmp, Register xtmp) {\n  auto stub = C2CodeStub::make<Register, FloatRegister, Register>(dst, src, xtmp, 130, float_to_float16_slow_path);\n\n  // in riscv, NaN needs a special process as fcvt does not work in that case.\n\n  // check whether it's a NaN.\n  // replace fclass with feq as performance optimization.\n  feq_s(t0, src, src);\n  // jump to stub processing NaN cases.\n  beqz(t0, stub->entry());\n\n  // non-NaN cases, just use built-in instructions.\n  fcvt_h_s(ftmp, src);\n  fmv_x_h(dst, ftmp);\n\n  bind(stub->continuation());\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V架构缺少ConvF2HF（单精度浮点数转半精度浮点数）指令支持，需要软件模拟实现。优化后：1. 新增float_to_float16函数，利用RISC-V Zfh扩展的fcvt.h.s和fmv.x.h硬件指令直接转换；2. 针对NaN特殊情况，用feq_s指令替代fclass进行NaN检测（性能优化）；3. 添加慢速路径处理非规范NaN。优化思路：利用硬件指令加速常规浮点数转换，同时优化NaN检测逻辑，提升Java Float.floatToFloat16方法的执行效率。"}
{"id": 88, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：RISC-V平台缺少对float16与float之间向量转换（VectorCastHF2F和VectorCastF2HF）的硬件指令支持，导致相关操作无法向量化，性能较低。优化后：1. 在汇编器头文件中添加了vnsra_wi（向量窄化整数右移）和vwadd_vx（向量扩展整数加法）等向量指令支持；2. 在C2宏汇编器中实现了float16_to_float_v向量转换函数，通过vfwcvt_f_f_v指令处理常规值，并通过慢速路径特殊处理NaN值以保持非规范NaN的有效载荷。优化思路：利用RISC-V向量扩展指令集实现float16与float之间的批量转换，通过向量化提升性能，同时正确处理NaN边界情况以保证语义正确性。", "original_code": "RISC-V平台缺少对float16与float之间向量转换（VectorCastHF2F和VectorCastF2HF）的硬件指令支持，导致相关操作无法向量化，性能较低。", "optimized_code": "INSN(vnsra_wi, 0b1010111, 0b011, 0b101101);\nINSN(vwadd_vx, 0b1010111, 0b110, 0b110001);\nvoid C2_MacroAssembler::float16_to_float_v(VectorRegister dst, VectorRegister src, uint vector_length) {\n  auto stub = C2CodeStub::make<VectorRegister, VectorRegister, uint>\n              (dst, src, vector_length, 24, float16_to_float_v_slow_path);\n  assert_different_registers(dst, src);\n  // On riscv, NaN needs a special process as vfwcvt_f_f_v does not work in that case.\n  // On riscv, Inf does not need a special process as vfwcvt_f_f_v can handle it correctly.\n  // but we consider to get the slow path to process NaN and Inf at the same time,\n  // as both of them are rare cases, and if we try to get the slow path to handle\n  // only NaN case it would sacrifise the performance for normal cases,\n  // i.e. non-NaN and no", "source_url": "https://github.com/openjdk/jdk/commit/d7273ac8b1ad8bc5d0a17fff5dc941c735fdae24", "code_v0_no_empty_lines": "RISC-V平台缺少对float16与float之间向量转换（VectorCastHF2F和VectorCastF2HF）的硬件指令支持，导致相关操作无法向量化，性能较低。", "code_v1_no_empty_lines": "INSN(vnsra_wi, 0b1010111, 0b011, 0b101101);\nINSN(vwadd_vx, 0b1010111, 0b110, 0b110001);\nvoid C2_MacroAssembler::float16_to_float_v(VectorRegister dst, VectorRegister src, uint vector_length) {\n  auto stub = C2CodeStub::make<VectorRegister, VectorRegister, uint>\n              (dst, src, vector_length, 24, float16_to_float_v_slow_path);\n  assert_different_registers(dst, src);\n  // On riscv, NaN needs a special process as vfwcvt_f_f_v does not work in that case.\n  // On riscv, Inf does not need a special process as vfwcvt_f_f_v can handle it correctly.\n  // but we consider to get the slow path to process NaN and Inf at the same time,\n  // as both of them are rare cases, and if we try to get the slow path to handle\n  // only NaN case it would sacrifise the performance for normal cases,\n  // i.e. non-NaN and no", "target": "INSN(vnsra_wi, 0b1010111, 0b011, 0b101101);\nINSN(vwadd_vx, 0b1010111, 0b110, 0b110001);\nvoid C2_MacroAssembler::float16_to_float_v(VectorRegister dst, VectorRegister src, uint vector_length) {\n  auto stub = C2CodeStub::make<VectorRegister, VectorRegister, uint>\n              (dst, src, vector_length, 24, float16_to_float_v_slow_path);\n  assert_different_registers(dst, src);\n  // On riscv, NaN needs a special process as vfwcvt_f_f_v does not work in that case.\n  // On riscv, Inf does not need a special process as vfwcvt_f_f_v can handle it correctly.\n  // but we consider to get the slow path to process NaN and Inf at the same time,\n  // as both of them are rare cases, and if we try to get the slow path to handle\n  // only NaN case it would sacrifise the performance for normal cases,\n  // i.e. non-NaN and no", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V平台缺少对float16与float之间向量转换（VectorCastHF2F和VectorCastF2HF）的硬件指令支持，导致相关操作无法向量化，性能较低。优化后：1. 在汇编器头文件中添加了vnsra_wi（向量窄化整数右移）和vwadd_vx（向量扩展整数加法）等向量指令支持；2. 在C2宏汇编器中实现了float16_to_float_v向量转换函数，通过vfwcvt_f_f_v指令处理常规值，并通过慢速路径特殊处理NaN值以保持非规范NaN的有效载荷。优化思路：利用RISC-V向量扩展指令集实现float16与float之间的批量转换，通过向量化提升性能，同时正确处理NaN边界情况以保证语义正确性。"}
{"id": 89, "source": "riscv-dataset-excel", "optimization_type": "指令集扩展+向量化优化", "optimization_description": "优化前：RISC-V向量比较指令仅支持有符号比较（vmslt_vv等），不支持无符号比较指令（vmsltu_vv等），导致无符号向量比较需要额外转换或软件模拟。优化后：在compare_integral_v函数中添加无符号比较指令支持（vmsleu_vv、vmsgeu_vv、vmsltu_vv、vmsgtu_vv），并修改supports_vector_comparison_unsigned函数返回UseRVV标志。优化思路：利用RISC-V向量扩展（RVV）的无符号比较指令，直接生成硬件支持的无符号向量比较，减少软件模拟开销，提升向量化代码性能。", "original_code": "RISC-V向量比较指令仅支持有符号比较（vmslt_vv等），不支持无符号比较指令（vmsltu_vv等），导致无符号向量比较需要额外转换或软件模拟。", "optimized_code": "case BoolTest::ule: vmsleu_vv(vd, src1, src2, vm); break;\n+    case BoolTest::uge: vmsgeu_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ult: vmsltu_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ugt: vmsgtu_vv(vd, src1, src2, vm); break;\n+  }\n+  \n+  // Does the CPU supports vector unsigned comparison instructions?\n+  static bool supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n+    return UseRVV;", "source_url": "https://github.com/openjdk/jdk/commit/9b61a7608efff13fc3685488f3f54a810ec0ac22", "code_v0_no_empty_lines": "RISC-V向量比较指令仅支持有符号比较（vmslt_vv等），不支持无符号比较指令（vmsltu_vv等），导致无符号向量比较需要额外转换或软件模拟。", "code_v1_no_empty_lines": "case BoolTest::ule: vmsleu_vv(vd, src1, src2, vm); break;\n+    case BoolTest::uge: vmsgeu_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ult: vmsltu_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ugt: vmsgtu_vv(vd, src1, src2, vm); break;\n+  }\n+  \n+  // Does the CPU supports vector unsigned comparison instructions?\n+  static bool supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n+    return UseRVV;", "target": "case BoolTest::ule: vmsleu_vv(vd, src1, src2, vm); break;\n+    case BoolTest::uge: vmsgeu_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ult: vmsltu_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ugt: vmsgtu_vv(vd, src1, src2, vm); break;\n+  }\n+  \n+  // Does the CPU supports vector unsigned comparison instructions?\n+  static bool supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n+    return UseRVV;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V向量比较指令仅支持有符号比较（vmslt_vv等），不支持无符号比较指令（vmsltu_vv等），导致无符号向量比较需要额外转换或软件模拟。优化后：在compare_integral_v函数中添加无符号比较指令支持（vmsleu_vv、vmsgeu_vv、vmsltu_vv、vmsgtu_vv），并修改supports_vector_comparison_unsigned函数返回UseRVV标志。优化思路：利用RISC-V向量扩展（RVV）的无符号比较指令，直接生成硬件支持的无符号向量比较，减少软件模拟开销，提升向量化代码性能。"}
{"id": 90, "source": "riscv-dataset-excel", "optimization_type": "代码结构优化+性能优化", "optimization_description": "优化前：uncommon_trap stub位于SharedRuntime中，与运行时系统耦合较紧，可能导致性能开销和代码维护复杂。优化后：将uncommon_trap stub从SharedRuntime迁移到OptoRuntime，使其更接近JIT编译优化层，减少调用开销，提高代码组织清晰度。思路：通过重构代码位置，使优化相关的运行时组件更集中，提升编译优化效率和解耦系统组件。", "original_code": "uncommon_trap stub位于SharedRuntime中，与运行时系统耦合较紧，可能导致性能开销和代码维护复杂。", "optimized_code": "- 从SharedRuntime移除uncommon_trap_stub相关代码\n+ 在OptoRuntime中为各架构添加uncommon_trap_blob生成函数", "source_url": "https://github.com/openjdk/jdk/commit/ab509f1b98329b1624a3111e226b640ee76f5969", "code_v0_no_empty_lines": "uncommon_trap stub位于SharedRuntime中，与运行时系统耦合较紧，可能导致性能开销和代码维护复杂。", "code_v1_no_empty_lines": "- 从SharedRuntime移除uncommon_trap_stub相关代码\n+ 在OptoRuntime中为各架构添加uncommon_trap_blob生成函数", "target": "- 从SharedRuntime移除uncommon_trap_stub相关代码\n+ 在OptoRuntime中为各架构添加uncommon_trap_blob生成函数", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：uncommon_trap stub位于SharedRuntime中，与运行时系统耦合较紧，可能导致性能开销和代码维护复杂。优化后：将uncommon_trap stub从SharedRuntime迁移到OptoRuntime，使其更接近JIT编译优化层，减少调用开销，提高代码组织清晰度。思路：通过重构代码位置，使优化相关的运行时组件更集中，提升编译优化效率和解耦系统组件。"}
{"id": 91, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+内存优化", "optimization_description": "优化前：传统线程模型存在线程创建/销毁开销大、上下文切换成本高、内存占用多的问题。优化后：实现虚拟线程（Virtual Threads）预览功能，通过continuation机制实现轻量级线程，虚拟线程由JVM调度到少量平台线程上执行，支持挂起/恢复操作。优化思路：引入continuation框架，添加continuationEntry、continuationFreezeThaw、continuationHelper等核心组件，实现栈帧的冻结/解冻机制，大幅减少线程创建开销和内存占用，提高高并发场景下的性能。", "original_code": "传统线程模型存在线程创建/销毁开销大、上下文切换成本高、内存占用多的问题。", "optimized_code": "+ src/hotspot/cpu/x86/continuationEntry_x86.inline.hpp\n+ src/hotspot/cpu/x86/continuationFreezeThaw_x86.inline.hpp\n+ src/hotspot/cpu/x86/continuationHelper_x86.inline.hpp\n+ src/hotspot/cpu/x86/stackChunkFrameStream_x86.inline.hpp\n+ src/hotspot/cpu/x86/stackChunkOop_x86.inline.hpp", "source_url": "https://github.com/openjdk/jdk/commit/9583e3657e43cc1c6f2101a64534564db2a9bd84", "code_v0_no_empty_lines": "传统线程模型存在线程创建/销毁开销大、上下文切换成本高、内存占用多的问题。", "code_v1_no_empty_lines": "+ src/hotspot/cpu/x86/continuationEntry_x86.inline.hpp\n+ src/hotspot/cpu/x86/continuationFreezeThaw_x86.inline.hpp\n+ src/hotspot/cpu/x86/continuationHelper_x86.inline.hpp\n+ src/hotspot/cpu/x86/stackChunkFrameStream_x86.inline.hpp\n+ src/hotspot/cpu/x86/stackChunkOop_x86.inline.hpp", "target": "+ src/hotspot/cpu/x86/continuationEntry_x86.inline.hpp\n+ src/hotspot/cpu/x86/continuationFreezeThaw_x86.inline.hpp\n+ src/hotspot/cpu/x86/continuationHelper_x86.inline.hpp\n+ src/hotspot/cpu/x86/stackChunkFrameStream_x86.inline.hpp\n+ src/hotspot/cpu/x86/stackChunkOop_x86.inline.hpp", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：传统线程模型存在线程创建/销毁开销大、上下文切换成本高、内存占用多的问题。优化后：实现虚拟线程（Virtual Threads）预览功能，通过continuation机制实现轻量级线程，虚拟线程由JVM调度到少量平台线程上执行，支持挂起/恢复操作。优化思路：引入continuation框架，添加continuationEntry、continuationFreezeThaw、continuationHelper等核心组件，实现栈帧的冻结/解冻机制，大幅减少线程创建开销和内存占用，提高高并发场景下的性能。"}
{"id": 92, "source": "riscv-dataset-excel", "optimization_type": "指令调度优化+指令合并优化", "optimization_description": "优化前：1. 使用slli+add两条指令计算数组块结束地址；2. mulw乘法指令在数组元素加载指令之前执行，可能导致流水线停顿。优化后：1. 使用shadd单条指令合并地址计算，减少指令数量；2. 将mulw指令调整到数组元素加载指令之后，利用加载延迟隐藏乘法计算时间。思路：通过指令合并减少指令数，通过指令重排改善流水线利用率，提升_vectorizedHashCode内在函数的执行效率。", "original_code": "1. 使用slli+add两条指令计算数组块结束地址；2. mulw乘法指令在数组元素加载指令之前执行，可能导致流水线停顿。", "optimized_code": "-  slli(chunks_end, chunks, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, chunks, ary, t0, chunks_end_shift);\n-  mulw(result, result, pow31_4); // 31^^4 * h\n+  mulw(result, result, pow31_4); // 31^^4 * h (位置调整到加载指令之后)", "source_url": "https://github.com/openjdk/jdk/commit/4189fcbac40943f3b26c3a01938837b4e4762285", "code_v0_no_empty_lines": "1. 使用slli+add两条指令计算数组块结束地址；2. mulw乘法指令在数组元素加载指令之前执行，可能导致流水线停顿。", "code_v1_no_empty_lines": "-  slli(chunks_end, chunks, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, chunks, ary, t0, chunks_end_shift);\n-  mulw(result, result, pow31_4); // 31^^4 * h\n+  mulw(result, result, pow31_4); // 31^^4 * h (位置调整到加载指令之后)", "target": "-  slli(chunks_end, chunks, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, chunks, ary, t0, chunks_end_shift);\n-  mulw(result, result, pow31_4); // 31^^4 * h\n+  mulw(result, result, pow31_4); // 31^^4 * h (位置调整到加载指令之后)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 使用slli+add两条指令计算数组块结束地址；2. mulw乘法指令在数组元素加载指令之前执行，可能导致流水线停顿。优化后：1. 使用shadd单条指令合并地址计算，减少指令数量；2. 将mulw指令调整到数组元素加载指令之后，利用加载延迟隐藏乘法计算时间。思路：通过指令合并减少指令数，通过指令重排改善流水线利用率，提升_vectorizedHashCode内在函数的执行效率。"}
{"id": 93, "source": "riscv-dataset-excel", "optimization_type": "数值精度优化+向量化优化", "optimization_description": "优化前：浮点数转float16的向量化实现中，NaN payload处理不完整，仅保留符号位和部分尾数，可能导致NaN信息丢失。优化后：完整保留float32 NaN的payload到float16中，通过分步提取尾数的10位、9位、4位并组合，确保NaN payload正确传递。优化思路：遵循Java规范要求，在向量化转换中正确处理NaN payload，同时新增vnsrl_wi指令支持，改进测试用例增加随机性验证。", "original_code": "浮点数转float16的向量化实现中，NaN payload处理不完整，仅保留符号位和部分尾数，可能导致NaN信息丢失。", "optimized_code": "- __ vnsra_wi(dst, src, 13, Assembler::v0_t);\n- __ vnsra_wi(tmp, src, 26, Assembler::v0_t);\n- __ vsll_vi(tmp, tmp, 10, Assembler::v0_t);\n- __ mv(t0, 0x3ff);\n- __ vor_vx(tmp, tmp, t0, Assembler::v0_t);\n- __ vand_vv(dst, dst, tmp, Assembler::v0_t);\n+ __ vnsra_wi(dst, src, fp32_bits - fp_sign_bits - fp16_exponent_bits, Assembler::v0_t);\n+ __ vsll_vi(dst, dst, fp16_mantissa_bits, Assembler::v0_t);\n+ __ vnsrl_wi(vtmp, src, fp32_mantissa_2nd_part_bits + fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+ __ mv(t0, 0x3ff);\n+ __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+ __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+ __ vnsrl_wi(vtmp, src, fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+ __ mv(t0, 0x1ff);\n+ __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+ __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+ __ vnsrl_wi(vtmp, src, 0, Assembler::v0_t);\n+ __ vand_vi(vtmp, vtmp, 0xf, Assembler::v0_t);\n+ __ vor_vv(dst, dst, vtmp, Assembler::v0_t);", "source_url": "https://github.com/openjdk/jdk/commit/32df2d17f3c0407ad7e90eacfdc0fd7a65f67551", "code_v0_no_empty_lines": "浮点数转float16的向量化实现中，NaN payload处理不完整，仅保留符号位和部分尾数，可能导致NaN信息丢失。", "code_v1_no_empty_lines": "- __ vnsra_wi(dst, src, 13, Assembler::v0_t);\n- __ vnsra_wi(tmp, src, 26, Assembler::v0_t);\n- __ vsll_vi(tmp, tmp, 10, Assembler::v0_t);\n- __ mv(t0, 0x3ff);\n- __ vor_vx(tmp, tmp, t0, Assembler::v0_t);\n- __ vand_vv(dst, dst, tmp, Assembler::v0_t);\n+ __ vnsra_wi(dst, src, fp32_bits - fp_sign_bits - fp16_exponent_bits, Assembler::v0_t);\n+ __ vsll_vi(dst, dst, fp16_mantissa_bits, Assembler::v0_t);\n+ __ vnsrl_wi(vtmp, src, fp32_mantissa_2nd_part_bits + fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+ __ mv(t0, 0x3ff);\n+ __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+ __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+ __ vnsrl_wi(vtmp, src, fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+ __ mv(t0, 0x1ff);\n+ __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+ __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+ __ vnsrl_wi(vtmp, src, 0, Assembler::v0_t);\n+ __ vand_vi(vtmp, vtmp, 0xf, Assembler::v0_t);\n+ __ vor_vv(dst, dst, vtmp, Assembler::v0_t);", "target": "- __ vnsra_wi(dst, src, 13, Assembler::v0_t);\n- __ vnsra_wi(tmp, src, 26, Assembler::v0_t);\n- __ vsll_vi(tmp, tmp, 10, Assembler::v0_t);\n- __ mv(t0, 0x3ff);\n- __ vor_vx(tmp, tmp, t0, Assembler::v0_t);\n- __ vand_vv(dst, dst, tmp, Assembler::v0_t);\n+ __ vnsra_wi(dst, src, fp32_bits - fp_sign_bits - fp16_exponent_bits, Assembler::v0_t);\n+ __ vsll_vi(dst, dst, fp16_mantissa_bits, Assembler::v0_t);\n+ __ vnsrl_wi(vtmp, src, fp32_mantissa_2nd_part_bits + fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+ __ mv(t0, 0x3ff);\n+ __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+ __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+ __ vnsrl_wi(vtmp, src, fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+ __ mv(t0, 0x1ff);\n+ __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+ __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+ __ vnsrl_wi(vtmp, src, 0, Assembler::v0_t);\n+ __ vand_vi(vtmp, vtmp, 0xf, Assembler::v0_t);\n+ __ vor_vv(dst, dst, vtmp, Assembler::v0_t);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：浮点数转float16的向量化实现中，NaN payload处理不完整，仅保留符号位和部分尾数，可能导致NaN信息丢失。优化后：完整保留float32 NaN的payload到float16中，通过分步提取尾数的10位、9位、4位并组合，确保NaN payload正确传递。优化思路：遵循Java规范要求，在向量化转换中正确处理NaN payload，同时新增vnsrl_wi指令支持，改进测试用例增加随机性验证。"}
{"id": 94, "source": "riscv-dataset-excel", "optimization_type": "指令缓存同步优化+错误处理增强", "optimization_description": "优化前：使用__builtin___clear_cache进行指令缓存刷新，但在RISC-V架构下可能因缺少内存屏障保证而静默失败，导致缓存同步不可靠。优化后：1. 新增RiscvFlushIcache类封装Linux系统调用NR_riscv_flush_icache，确保正确的内存顺序（通过fence指令）和跨核心缓存一致性。2. 添加test()方法在初始化时验证系统调用可用性，失败时明确报错退出。思路：将不可靠的编译器内置函数替换为架构专用的系统调用实现，增强错误检测和可靠性，确保JIT编译代码在多核RISC-V系统上的正确执行。", "original_code": "使用__builtin___clear_cache进行指令缓存刷新，但在RISC-V架构下可能因缺少内存屏障保证而静默失败，导致缓存同步不可靠。", "optimized_code": "- __builtin___clear_cache(addr, addr + (lines << ICache::log2_line_size));\n+ RiscvFlushIcache::flush((uintptr_t)addr, ((uintptr_t)lines) << ICache::log2_line_size);\n+ if (!RiscvFlushIcache::test()) {\n+   vm_exit_during_initialization(\"Unable to synchronize I-cache\");\n+ }", "source_url": "https://github.com/openjdk/jdk/commit/faf1b822d03b726413d77a2b247dfbbf4db7d57e", "code_v0_no_empty_lines": "使用__builtin___clear_cache进行指令缓存刷新，但在RISC-V架构下可能因缺少内存屏障保证而静默失败，导致缓存同步不可靠。", "code_v1_no_empty_lines": "- __builtin___clear_cache(addr, addr + (lines << ICache::log2_line_size));\n+ RiscvFlushIcache::flush((uintptr_t)addr, ((uintptr_t)lines) << ICache::log2_line_size);\n+ if (!RiscvFlushIcache::test()) {\n+   vm_exit_during_initialization(\"Unable to synchronize I-cache\");\n+ }", "target": "- __builtin___clear_cache(addr, addr + (lines << ICache::log2_line_size));\n+ RiscvFlushIcache::flush((uintptr_t)addr, ((uintptr_t)lines) << ICache::log2_line_size);\n+ if (!RiscvFlushIcache::test()) {\n+   vm_exit_during_initialization(\"Unable to synchronize I-cache\");\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用__builtin___clear_cache进行指令缓存刷新，但在RISC-V架构下可能因缺少内存屏障保证而静默失败，导致缓存同步不可靠。优化后：1. 新增RiscvFlushIcache类封装Linux系统调用NR_riscv_flush_icache，确保正确的内存顺序（通过fence指令）和跨核心缓存一致性。2. 添加test()方法在初始化时验证系统调用可用性，失败时明确报错退出。思路：将不可靠的编译器内置函数替换为架构专用的系统调用实现，增强错误检测和可靠性，确保JIT编译代码在多核RISC-V系统上的正确执行。"}
{"id": 95, "source": "riscv-dataset-excel", "optimization_type": "字符串格式化性能优化", "optimization_description": "优化前：多个日期时间类（MonthDay、YearMonth、ZoneOffset、ChronoLocalDateImpl、DateTimeHelper）在toString()方法中使用字符串拼接和条件判断（如month < 10 ? \"0\" : \"\"）来格式化两位数字，这涉及多次字符串操作和条件分支。优化后：引入DecimalDigits.appendPair()和appendQuad()方法，统一处理两位和四位数字的格式化，减少字符串拼接次数和条件判断，提高格式化性能。同时将ChronoLocalDateImpl中的getLong()改为get()，因为日期值在int范围内，避免不必要的long类型转换开销。", "original_code": "多个日期时间类（MonthDay、YearMonth、ZoneOffset、ChronoLocalDateImpl、DateTimeHelper）在toString()方法中使用字符串拼接和条件判断（如month < 10 ? \"0\" : \"\"）来格式化两位数字，这涉及多次字符串操作和条件分支。", "optimized_code": "--- a/src/java.base/share/classes/java/time/MonthDay.java\n+++ b/src/java.base/share/classes/java/time/MonthDay.java\n@@ -764,10 +766,12 @@ public int hashCode() {\n     @Override\n     public String toString() {\n-        return new StringBuilder(10).append(\"--\")\n-            .append(month < 10 ? \"0\" : \"\").append(month)\n-            .append(day < 10 ? \"-0\" : \"-\").append(day)\n-            .toString();\n+        StringBuilder buf = new StringBuilder(10);\n+        buf.append(\"--\");\n+        DecimalDigits.appendPair(buf, month);\n+        buf.append('-');\n+        DecimalDigits.appendPair(buf, day);\n+        return buf.toString();\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/4ffdf7af88f6c0a69663eb249957dbceea3cb697", "code_v0_no_empty_lines": "多个日期时间类（MonthDay、YearMonth、ZoneOffset、ChronoLocalDateImpl、DateTimeHelper）在toString()方法中使用字符串拼接和条件判断（如month < 10 ? \"0\" : \"\"）来格式化两位数字，这涉及多次字符串操作和条件分支。", "code_v1_no_empty_lines": "--- a/src/java.base/share/classes/java/time/MonthDay.java\n+++ b/src/java.base/share/classes/java/time/MonthDay.java\n@@ -764,10 +766,12 @@ public int hashCode() {\n     @Override\n     public String toString() {\n-        return new StringBuilder(10).append(\"--\")\n-            .append(month < 10 ? \"0\" : \"\").append(month)\n-            .append(day < 10 ? \"-0\" : \"-\").append(day)\n-            .toString();\n+        StringBuilder buf = new StringBuilder(10);\n+        buf.append(\"--\");\n+        DecimalDigits.appendPair(buf, month);\n+        buf.append('-');\n+        DecimalDigits.appendPair(buf, day);\n+        return buf.toString();\n     }", "target": "--- a/src/java.base/share/classes/java/time/MonthDay.java\n+++ b/src/java.base/share/classes/java/time/MonthDay.java\n@@ -764,10 +766,12 @@ public int hashCode() {\n     @Override\n     public String toString() {\n-        return new StringBuilder(10).append(\"--\")\n-            .append(month < 10 ? \"0\" : \"\").append(month)\n-            .append(day < 10 ? \"-0\" : \"-\").append(day)\n-            .toString();\n+        StringBuilder buf = new StringBuilder(10);\n+        buf.append(\"--\");\n+        DecimalDigits.appendPair(buf, month);\n+        buf.append('-');\n+        DecimalDigits.appendPair(buf, day);\n+        return buf.toString();\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多个日期时间类（MonthDay、YearMonth、ZoneOffset、ChronoLocalDateImpl、DateTimeHelper）在toString()方法中使用字符串拼接和条件判断（如month < 10 ? \"0\" : \"\"）来格式化两位数字，这涉及多次字符串操作和条件分支。优化后：引入DecimalDigits.appendPair()和appendQuad()方法，统一处理两位和四位数字的格式化，减少字符串拼接次数和条件判断，提高格式化性能。同时将ChronoLocalDateImpl中的getLong()改为get()，因为日期值在int范围内，避免不必要的long类型转换开销。"}
{"id": 96, "source": "riscv-dataset-excel", "optimization_type": "SIMD指令优化+内联汇编优化", "optimization_description": "优化前：ML-DSA算法实现缺少AVX2/AVX512专用SIMD指令支持，依赖通用指令或软件实现，性能受限。优化后：新增vmovsldup/vmovshdup等AVX2指令和evmovsldup/evmovshdup等AVX512指令，支持掩码操作和向量长度控制，优化Dilithium后量子密码算法的NTT变换和蒙哥马利乘法。优化思路：利用AVX2/AVX512 SIMD指令集实现数据并行处理，通过内联汇编直接生成机器码，减少函数调用开销，提升密码学运算性能。", "original_code": "ML-DSA算法实现缺少AVX2/AVX512专用SIMD指令支持，依赖通用指令或软件实现，性能受限。", "optimized_code": "+void Assembler::vmovsldup(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_evex() : VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x12, (0xC0 | encode));\n+}\n\n+void Assembler::evmovsldup(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x12, (0xC0 | encode));\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/b36b69470968b1578877cfe9658892a5fe44e38e", "code_v0_no_empty_lines": "ML-DSA算法实现缺少AVX2/AVX512专用SIMD指令支持，依赖通用指令或软件实现，性能受限。", "code_v1_no_empty_lines": "+void Assembler::vmovsldup(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_evex() : VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x12, (0xC0 | encode));\n+}\n\n+void Assembler::evmovsldup(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x12, (0xC0 | encode));\n+}", "target": "+void Assembler::vmovsldup(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_evex() : VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x12, (0xC0 | encode));\n+}\n\n+void Assembler::evmovsldup(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x12, (0xC0 | encode));\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ML-DSA算法实现缺少AVX2/AVX512专用SIMD指令支持，依赖通用指令或软件实现，性能受限。优化后：新增vmovsldup/vmovshdup等AVX2指令和evmovsldup/evmovshdup等AVX512指令，支持掩码操作和向量长度控制，优化Dilithium后量子密码算法的NTT变换和蒙哥马利乘法。优化思路：利用AVX2/AVX512 SIMD指令集实现数据并行处理，通过内联汇编直接生成机器码，减少函数调用开销，提升密码学运算性能。"}
{"id": 97, "source": "riscv-dataset-excel", "optimization_type": "代码重构+类型安全优化", "optimization_description": "优化前：Register对象直接进行整数比较（如obj_reg < lock_reg），依赖隐式转换到整数编码。优化后：通过obj_reg->encoding()显式获取寄存器编码值进行比较，将Register作为值类型处理。思路：提高类型安全性，消除隐式转换的歧义，使代码更清晰且符合ARM32寄存器表示规范，减少潜在的类型错误。", "original_code": "Register对象直接进行整数比较（如obj_reg < lock_reg），依赖隐式转换到整数编码。", "optimized_code": "- reg_def R_R0 (SOC, SOC, Op_RegI,  0,  R(0)->as_VMReg());\n+ reg_def R_R0 (SOC, SOC, Op_RegI,  0,  as_Register(0)->as_VMReg());\n- if (obj_reg < lock_reg) {\n+ if (obj_reg->encoding() < lock_reg->encoding()) {", "source_url": "https://github.com/openjdk/riscv-port/commit/c1230068dc4501c52999ac0bbb3a2e5933453f09", "code_v0_no_empty_lines": "Register对象直接进行整数比较（如obj_reg < lock_reg），依赖隐式转换到整数编码。", "code_v1_no_empty_lines": "- reg_def R_R0 (SOC, SOC, Op_RegI,  0,  R(0)->as_VMReg());\n+ reg_def R_R0 (SOC, SOC, Op_RegI,  0,  as_Register(0)->as_VMReg());\n- if (obj_reg < lock_reg) {\n+ if (obj_reg->encoding() < lock_reg->encoding()) {", "target": "- reg_def R_R0 (SOC, SOC, Op_RegI,  0,  R(0)->as_VMReg());\n+ reg_def R_R0 (SOC, SOC, Op_RegI,  0,  as_Register(0)->as_VMReg());\n- if (obj_reg < lock_reg) {\n+ if (obj_reg->encoding() < lock_reg->encoding()) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Register对象直接进行整数比较（如obj_reg < lock_reg），依赖隐式转换到整数编码。优化后：通过obj_reg->encoding()显式获取寄存器编码值进行比较，将Register作为值类型处理。思路：提高类型安全性，消除隐式转换的歧义，使代码更清晰且符合ARM32寄存器表示规范，减少潜在的类型错误。"}
{"id": 98, "source": "riscv-dataset-excel", "optimization_type": "内存分配优化", "optimization_description": "优化前：GCLogMessage使用512字节的缓冲区，可能导致GC日志事件在缓冲区满时被截断或丢失。优化后：将缓冲区大小从512字节增加到1024字节，确保GC日志事件能够完整记录，减少因缓冲区不足导致的日志丢失问题，提高GC日志的完整性和可调试性。", "original_code": "GCLogMessage使用512字节的缓冲区，可能导致GC日志事件在缓冲区满时被截断或丢失。", "optimized_code": "-class GCLogMessage : public FormatBuffer<512> {};\n+class GCLogMessage : public FormatBuffer<1024> {};", "source_url": "https://github.com/openjdk/riscv-port/commit/81ea1442a86795dafbf96c875fbecc65210804be", "code_v0_no_empty_lines": "GCLogMessage使用512字节的缓冲区，可能导致GC日志事件在缓冲区满时被截断或丢失。", "code_v1_no_empty_lines": "-class GCLogMessage : public FormatBuffer<512> {};\n+class GCLogMessage : public FormatBuffer<1024> {};", "target": "-class GCLogMessage : public FormatBuffer<512> {};\n+class GCLogMessage : public FormatBuffer<1024> {};", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：GCLogMessage使用512字节的缓冲区，可能导致GC日志事件在缓冲区满时被截断或丢失。优化后：将缓冲区大小从512字节增加到1024字节，确保GC日志事件能够完整记录，减少因缓冲区不足导致的日志丢失问题，提高GC日志的完整性和可调试性。"}
{"id": 99, "source": "riscv-dataset-excel", "optimization_type": "原子操作优化", "optimization_description": "优化前：使用volatile变量配合AtomicAccess包装函数进行原子操作，存在额外函数调用开销和间接访问。优化后：直接使用C++11风格的Atomic<T>模板类，通过成员函数（如load_relaxed、compare_exchange）实现原子操作，减少函数调用开销，提高代码可读性和编译器优化空间。思路：将手动内存屏障管理转换为标准原子类型，利用现代C++原子操作原语提升并发性能。", "original_code": "使用volatile变量配合AtomicAccess包装函数进行原子操作，存在额外函数调用开销和间接访问。", "optimized_code": "- volatile int64_t _state;\n+ Atomic<int64_t> _state;\n- volatile int _outstanding_wakeups;\n+ Atomic<int> _outstanding_wakeups;\n- volatile int _barrier_tag;\n+ Atomic<int> _barrier_tag;\n- AtomicAccess::load(&_barrier_tag)\n+ _barrier_tag.load_relaxed()\n- AtomicAccess::cmpxchg(&_state, state, new_state)\n+ _state.compare_exchange(state, new_state)", "source_url": "https://github.com/openjdk/riscv-port/commit/52568bf4832b2bcc5dc547dbdf45a6a7172281fb", "code_v0_no_empty_lines": "使用volatile变量配合AtomicAccess包装函数进行原子操作，存在额外函数调用开销和间接访问。", "code_v1_no_empty_lines": "- volatile int64_t _state;\n+ Atomic<int64_t> _state;\n- volatile int _outstanding_wakeups;\n+ Atomic<int> _outstanding_wakeups;\n- volatile int _barrier_tag;\n+ Atomic<int> _barrier_tag;\n- AtomicAccess::load(&_barrier_tag)\n+ _barrier_tag.load_relaxed()\n- AtomicAccess::cmpxchg(&_state, state, new_state)\n+ _state.compare_exchange(state, new_state)", "target": "- volatile int64_t _state;\n+ Atomic<int64_t> _state;\n- volatile int _outstanding_wakeups;\n+ Atomic<int> _outstanding_wakeups;\n- volatile int _barrier_tag;\n+ Atomic<int> _barrier_tag;\n- AtomicAccess::load(&_barrier_tag)\n+ _barrier_tag.load_relaxed()\n- AtomicAccess::cmpxchg(&_state, state, new_state)\n+ _state.compare_exchange(state, new_state)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用volatile变量配合AtomicAccess包装函数进行原子操作，存在额外函数调用开销和间接访问。优化后：直接使用C++11风格的Atomic<T>模板类，通过成员函数（如load_relaxed、compare_exchange）实现原子操作，减少函数调用开销，提高代码可读性和编译器优化空间。思路：将手动内存屏障管理转换为标准原子类型，利用现代C++原子操作原语提升并发性能。"}
{"id": 100, "source": "riscv-dataset-excel", "optimization_type": "连接管理优化+超时处理优化", "optimization_description": "优化前：HTTP/3连接配置了较长的空闲超时时间时，底层的QUIC连接可能因空闲超时提前终止，导致HTTP/3连接意外关闭。优化后：HTTP/3层通过appLayerMaxIdle()向QUIC层传递应用层空闲超时配置，当HTTP/3连接在连接池中空闲时，通过isQUICTrafficGenerationRequired()回调指示QUIC层生成流量保持连接活跃。优化思路：协调HTTP/3和QUIC层的空闲超时机制，确保HTTP/3连接的空闲超时配置能正确影响底层QUIC连接的生命周期管理。", "original_code": "HTTP/3连接配置了较长的空闲超时时间时，底层的QUIC连接可能因空闲超时提前终止，导致HTTP/3连接意外关闭。", "optimized_code": "1. Http3Connection.java 新增 idleTimeoutDuration 字段和 appLayerMaxIdle 调用\n2. Http3Connection.java 新增 isQUICTrafficGenerationRequired() 方法\n3. Http3ConnectionPool.java 在 putIfAbsent 方法中调用 c.setPooled(true)", "source_url": "https://github.com/openjdk/riscv-port/commit/92e1357dfd2d874ef1a62ddd69c86a7bb189c6a2", "code_v0_no_empty_lines": "HTTP/3连接配置了较长的空闲超时时间时，底层的QUIC连接可能因空闲超时提前终止，导致HTTP/3连接意外关闭。", "code_v1_no_empty_lines": "1. Http3Connection.java 新增 idleTimeoutDuration 字段和 appLayerMaxIdle 调用\n2. Http3Connection.java 新增 isQUICTrafficGenerationRequired() 方法\n3. Http3ConnectionPool.java 在 putIfAbsent 方法中调用 c.setPooled(true)", "target": "1. Http3Connection.java 新增 idleTimeoutDuration 字段和 appLayerMaxIdle 调用\n2. Http3Connection.java 新增 isQUICTrafficGenerationRequired() 方法\n3. Http3ConnectionPool.java 在 putIfAbsent 方法中调用 c.setPooled(true)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：HTTP/3连接配置了较长的空闲超时时间时，底层的QUIC连接可能因空闲超时提前终止，导致HTTP/3连接意外关闭。优化后：HTTP/3层通过appLayerMaxIdle()向QUIC层传递应用层空闲超时配置，当HTTP/3连接在连接池中空闲时，通过isQUICTrafficGenerationRequired()回调指示QUIC层生成流量保持连接活跃。优化思路：协调HTTP/3和QUIC层的空闲超时机制，确保HTTP/3连接的空闲超时配置能正确影响底层QUIC连接的生命周期管理。"}
{"id": 101, "source": "riscv-dataset-excel", "optimization_type": "原子操作优化+内存模型优化", "optimization_description": "优化前：使用volatile关键字和AtomicAccess类进行原子操作，存在内存屏障开销和代码冗余。优化后：统一使用Atomic<T>模板类，提供更清晰的内存语义（如load_relaxed、store_relaxed、compare_exchange），减少不必要的内存屏障，简化代码结构。优化思路：通过标准化的原子操作接口提升并发性能，减少同步开销，并提高代码可维护性。", "original_code": "使用volatile关键字和AtomicAccess类进行原子操作，存在内存屏障开销和代码冗余。", "optimized_code": "- BufferNode* volatile _next;\n+ Atomic<BufferNode*> _next;\n- volatile size_t _count_and_process_flag;\n+ Atomic<size_t> _count_and_process_flag;\n- size_t value = AtomicAccess::load(cfptr);\n+ size_t value = cfptr->load_relaxed();\n- value = AtomicAccess::cmpxchg(cfptr, old, value);\n+ value = cfptr->compare_exchange(old, value);", "source_url": "https://github.com/openjdk/riscv-port/commit/0021dc04100befd107d3aa763510b28dd62cd62c", "code_v0_no_empty_lines": "使用volatile关键字和AtomicAccess类进行原子操作，存在内存屏障开销和代码冗余。", "code_v1_no_empty_lines": "- BufferNode* volatile _next;\n+ Atomic<BufferNode*> _next;\n- volatile size_t _count_and_process_flag;\n+ Atomic<size_t> _count_and_process_flag;\n- size_t value = AtomicAccess::load(cfptr);\n+ size_t value = cfptr->load_relaxed();\n- value = AtomicAccess::cmpxchg(cfptr, old, value);\n+ value = cfptr->compare_exchange(old, value);", "target": "- BufferNode* volatile _next;\n+ Atomic<BufferNode*> _next;\n- volatile size_t _count_and_process_flag;\n+ Atomic<size_t> _count_and_process_flag;\n- size_t value = AtomicAccess::load(cfptr);\n+ size_t value = cfptr->load_relaxed();\n- value = AtomicAccess::cmpxchg(cfptr, old, value);\n+ value = cfptr->compare_exchange(old, value);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用volatile关键字和AtomicAccess类进行原子操作，存在内存屏障开销和代码冗余。优化后：统一使用Atomic<T>模板类，提供更清晰的内存语义（如load_relaxed、store_relaxed、compare_exchange），减少不必要的内存屏障，简化代码结构。优化思路：通过标准化的原子操作接口提升并发性能，减少同步开销，并提高代码可维护性。"}
{"id": 102, "source": "riscv-dataset-excel", "optimization_type": "算法优化+代码简化", "optimization_description": "优化前：ThreadLocalRandom类移除了对nextGaussian()方法的覆盖，导致使用父类Random的较慢的polar算法生成高斯随机数。优化后：重新添加了nextGaussian()方法覆盖，调用RandomSupport.computeNextGaussian(this)使用更快的McFarland's modified ziggurat算法。优化思路：恢复使用更高效的高斯随机数生成算法，提升ThreadLocalRandom的性能，同时简化了RandomGenerator接口的注释，移除了过时的算法引用。", "original_code": "ThreadLocalRandom类移除了对nextGaussian()方法的覆盖，导致使用父类Random的较慢的polar算法生成高斯随机数。", "optimized_code": "--- a/src/java.base/share/classes/java/util/concurrent/ThreadLocalRandom.java\n+++ b/src/java.base/share/classes/java/util/concurrent/ThreadLocalRandom.java\n@@ -499,6 +494,23 @@ public long nextLong(long origin, long bound) {\n         return super.nextLong(origin, bound);\n     }\n \n+    /**\n+     * Returns a {@code double} value pseudorandomly chosen from a Gaussian\n+     * (normal) distribution whose mean is 0 and whose standard deviation is 1.\n+     *\n+     * @return a {@code double} value pseudorandomly chosen from a\n+     *         Gaussian distribution\n+     *\n+     * @implNote This implementation invokes the default implementation of\n+     *           {@link java.util.random.RandomGenerator#nextGaussian()},\n+     *           and so it uses McFarland's fast modified ziggurat algorithm\n+     *           rather than the polar method described in the superclass.\n+     */\n+    @Override\n+    public double nextGaussian() {\n+        return RandomSupport.computeNextGaussian(this);\n+    }\n+\n     /**\n      * {@inheritDoc}\n      */\n--- a/src/java.base/share/classes/java/util/random/RandomGenerator.java\n+++ b/src/java.base/share/classes/java/util/random/RandomGenerator.java\n@@ -917,7 +917,6 @@ default long nextLong(long origin, long bound) {\n      * a discrete distribution also plays a role.\n      */\n     default double nextGaussian() {\n-        // See Knuth, TAOCP, Vol. 2, 3rd edition, Section 3.4.1 Algorithm C.\n         return RandomSupport.computeNextGaussian(this);\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/f1d90b8b25b78b15dc6529a5a6e45633eb250286", "code_v0_no_empty_lines": "ThreadLocalRandom类移除了对nextGaussian()方法的覆盖，导致使用父类Random的较慢的polar算法生成高斯随机数。", "code_v1_no_empty_lines": "--- a/src/java.base/share/classes/java/util/concurrent/ThreadLocalRandom.java\n+++ b/src/java.base/share/classes/java/util/concurrent/ThreadLocalRandom.java\n@@ -499,6 +494,23 @@ public long nextLong(long origin, long bound) {\n         return super.nextLong(origin, bound);\n     }\n \n+    /**\n+     * Returns a {@code double} value pseudorandomly chosen from a Gaussian\n+     * (normal) distribution whose mean is 0 and whose standard deviation is 1.\n+     *\n+     * @return a {@code double} value pseudorandomly chosen from a\n+     *         Gaussian distribution\n+     *\n+     * @implNote This implementation invokes the default implementation of\n+     *           {@link java.util.random.RandomGenerator#nextGaussian()},\n+     *           and so it uses McFarland's fast modified ziggurat algorithm\n+     *           rather than the polar method described in the superclass.\n+     */\n+    @Override\n+    public double nextGaussian() {\n+        return RandomSupport.computeNextGaussian(this);\n+    }\n+\n     /**\n      * {@inheritDoc}\n      */\n--- a/src/java.base/share/classes/java/util/random/RandomGenerator.java\n+++ b/src/java.base/share/classes/java/util/random/RandomGenerator.java\n@@ -917,7 +917,6 @@ default long nextLong(long origin, long bound) {\n      * a discrete distribution also plays a role.\n      */\n     default double nextGaussian() {\n-        // See Knuth, TAOCP, Vol. 2, 3rd edition, Section 3.4.1 Algorithm C.\n         return RandomSupport.computeNextGaussian(this);\n     }", "target": "--- a/src/java.base/share/classes/java/util/concurrent/ThreadLocalRandom.java\n+++ b/src/java.base/share/classes/java/util/concurrent/ThreadLocalRandom.java\n@@ -499,6 +494,23 @@ public long nextLong(long origin, long bound) {\n         return super.nextLong(origin, bound);\n     }\n \n+    /**\n+     * Returns a {@code double} value pseudorandomly chosen from a Gaussian\n+     * (normal) distribution whose mean is 0 and whose standard deviation is 1.\n+     *\n+     * @return a {@code double} value pseudorandomly chosen from a\n+     *         Gaussian distribution\n+     *\n+     * @implNote This implementation invokes the default implementation of\n+     *           {@link java.util.random.RandomGenerator#nextGaussian()},\n+     *           and so it uses McFarland's fast modified ziggurat algorithm\n+     *           rather than the polar method described in the superclass.\n+     */\n+    @Override\n+    public double nextGaussian() {\n+        return RandomSupport.computeNextGaussian(this);\n+    }\n+\n     /**\n      * {@inheritDoc}\n      */\n--- a/src/java.base/share/classes/java/util/random/RandomGenerator.java\n+++ b/src/java.base/share/classes/java/util/random/RandomGenerator.java\n@@ -917,7 +917,6 @@ default long nextLong(long origin, long bound) {\n      * a discrete distribution also plays a role.\n      */\n     default double nextGaussian() {\n-        // See Knuth, TAOCP, Vol. 2, 3rd edition, Section 3.4.1 Algorithm C.\n         return RandomSupport.computeNextGaussian(this);\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ThreadLocalRandom类移除了对nextGaussian()方法的覆盖，导致使用父类Random的较慢的polar算法生成高斯随机数。优化后：重新添加了nextGaussian()方法覆盖，调用RandomSupport.computeNextGaussian(this)使用更快的McFarland's modified ziggurat算法。优化思路：恢复使用更高效的高斯随机数生成算法，提升ThreadLocalRandom的性能，同时简化了RandomGenerator接口的注释，移除了过时的算法引用。"}
{"id": 103, "source": "riscv-dataset-excel", "optimization_type": "内存对齐优化", "optimization_description": "优化前：当byteAlignment > alignedSize时，分配的内存可能无法满足对齐要求，导致allocateNativeInternal返回未正确对齐的内存。优化后：通过Math.max确保分配大小至少为byteAlignment，保证malloc返回的指针满足对齐要求。思路：修复内存对齐缺陷，确保内存分配始终满足指定的对齐约束。", "original_code": "当byteAlignment > alignedSize时，分配的内存可能无法满足对齐要求，导致allocateNativeInternal返回未正确对齐的内存。", "optimized_code": "- allocationSize = alignedSize;\n+ allocationSize = Math.max(alignedSize, byteAlignment);", "source_url": "https://github.com/openjdk/riscv-port/commit/10ba0ab3c0017858bafb65b49a4cadd9a0351fb4", "code_v0_no_empty_lines": "当byteAlignment > alignedSize时，分配的内存可能无法满足对齐要求，导致allocateNativeInternal返回未正确对齐的内存。", "code_v1_no_empty_lines": "- allocationSize = alignedSize;\n+ allocationSize = Math.max(alignedSize, byteAlignment);", "target": "- allocationSize = alignedSize;\n+ allocationSize = Math.max(alignedSize, byteAlignment);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当byteAlignment > alignedSize时，分配的内存可能无法满足对齐要求，导致allocateNativeInternal返回未正确对齐的内存。优化后：通过Math.max确保分配大小至少为byteAlignment，保证malloc返回的指针满足对齐要求。思路：修复内存对齐缺陷，确保内存分配始终满足指定的对齐约束。"}
{"id": 104, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+编译器图优化", "optimization_description": "优化前：在C2编译器的SuperWord向量化中，VTransform::add_speculative_check使用pre_init值，但该值在Auto_Vectorization_Check后被固定，导致图结构错误，可能产生错误的向量化检查。\n优化后：新增is_available_for_speculative_check方法，严格检查节点是否在推测性检查点之前可用（控制流支配关系），确保pre_init、pre_limit和main_limit等值在向量化推测检查时可用，避免图结构问题。\n优化思路：将原有的is_pre_loop_invariant条件强化为更严格的可用性检查，确保向量化推测检查使用的节点控制流位置正确，防止因节点不可用导致的错误向量化决策。", "original_code": "在C2编译器的SuperWord向量化中，VTransform::add_speculative_check使用pre_init值，但该值在Auto_Vectorization_Check后被固定，导致图结构错误，可能产生错误的向量化检查。", "optimized_code": "bool is_available_for_speculative_check(Node* n) const {\n  assert(are_speculative_checks_possible(), \"meaningless without speculative check\");\n  ParsePredicateSuccessProj* parse_predicate_proj = auto_vectorization_parse_predicate_proj();\n  // Find the control of the predicate:\n  ProjNode* proj = (parse_predicate_proj != nullptr) ? parse_predicate_proj : multiversioning_fast_proj();\n  Node* check_ctrl = proj->in(0)->as_If()->in(0);\n\n  // Often, the control of n already dominates that of the predicate.\n  Node* n_ctrl = phase()->get_ctrl(n);\n  if (phase()->is_dominator(n_ctrl, check_ctrl)) { return true; }\n\n  // But in some cases, the ctrl of n is after that of the predicate,\n  // but the early ctrl is before the predicate.\n  Node* n_early = phase()->compute_early_ctrl(n, n_ctrl);\n  return phase()->is_dominator(n_early, check_ctrl);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/e3a085581bfa70437b73d4b0527a084e0c5c9aac", "code_v0_no_empty_lines": "在C2编译器的SuperWord向量化中，VTransform::add_speculative_check使用pre_init值，但该值在Auto_Vectorization_Check后被固定，导致图结构错误，可能产生错误的向量化检查。", "code_v1_no_empty_lines": "bool is_available_for_speculative_check(Node* n) const {\n  assert(are_speculative_checks_possible(), \"meaningless without speculative check\");\n  ParsePredicateSuccessProj* parse_predicate_proj = auto_vectorization_parse_predicate_proj();\n  // Find the control of the predicate:\n  ProjNode* proj = (parse_predicate_proj != nullptr) ? parse_predicate_proj : multiversioning_fast_proj();\n  Node* check_ctrl = proj->in(0)->as_If()->in(0);\n\n  // Often, the control of n already dominates that of the predicate.\n  Node* n_ctrl = phase()->get_ctrl(n);\n  if (phase()->is_dominator(n_ctrl, check_ctrl)) { return true; }\n\n  // But in some cases, the ctrl of n is after that of the predicate,\n  // but the early ctrl is before the predicate.\n  Node* n_early = phase()->compute_early_ctrl(n, n_ctrl);\n  return phase()->is_dominator(n_early, check_ctrl);\n}", "target": "bool is_available_for_speculative_check(Node* n) const {\n  assert(are_speculative_checks_possible(), \"meaningless without speculative check\");\n  ParsePredicateSuccessProj* parse_predicate_proj = auto_vectorization_parse_predicate_proj();\n  // Find the control of the predicate:\n  ProjNode* proj = (parse_predicate_proj != nullptr) ? parse_predicate_proj : multiversioning_fast_proj();\n  Node* check_ctrl = proj->in(0)->as_If()->in(0);\n\n  // Often, the control of n already dominates that of the predicate.\n  Node* n_ctrl = phase()->get_ctrl(n);\n  if (phase()->is_dominator(n_ctrl, check_ctrl)) { return true; }\n\n  // But in some cases, the ctrl of n is after that of the predicate,\n  // but the early ctrl is before the predicate.\n  Node* n_early = phase()->compute_early_ctrl(n, n_ctrl);\n  return phase()->is_dominator(n_early, check_ctrl);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在C2编译器的SuperWord向量化中，VTransform::add_speculative_check使用pre_init值，但该值在Auto_Vectorization_Check后被固定，导致图结构错误，可能产生错误的向量化检查。\n优化后：新增is_available_for_speculative_check方法，严格检查节点是否在推测性检查点之前可用（控制流支配关系），确保pre_init、pre_limit和main_limit等值在向量化推测检查时可用，避免图结构问题。\n优化思路：将原有的is_pre_loop_invariant条件强化为更严格的可用性检查，确保向量化推测检查使用的节点控制流位置正确，防止因节点不可用导致的错误向量化决策。"}
{"id": 105, "source": "riscv-dataset-excel", "optimization_type": "基准测试重构", "optimization_description": "优化前：BulkOps.java 文件包含多个不相关的基准测试（fill、copy、hash、mismatch），代码结构混乱，维护困难。优化后：将不同功能的基准测试拆分为独立的文件（SegmentBulkCopy.java、SegmentBulkFill.java、SegmentBulkHash.java、SegmentBulkMismatch.java），每个文件专注于单一操作类型。优化思路：通过模块化重构提高代码可读性、可维护性和扩展性，便于后续针对特定内存操作进行性能分析和优化。", "original_code": "BulkOps.java 文件包含多个不相关的基准测试（fill、copy、hash、mismatch），代码结构混乱，维护困难。", "optimized_code": "- delete mode 100644 test/micro/org/openjdk/bench/java/lang/foreign/BulkOps.java\n+ .../java/lang/foreign/SegmentBulkCopy.java    | 165 +++++++++-----\n+ .../java/lang/foreign/SegmentBulkFill.java    | 162 +++++++-------\n+ .../java/lang/foreign/SegmentBulkHash.java    | 118 +++++++---\n+ .../lang/foreign/SegmentBulkMismatch.java     | 159 +++++++++----", "source_url": "https://github.com/openjdk/riscv-port/commit/1ce2a44e9f4fa9d558602dbd0489fefb0c9563ef", "code_v0_no_empty_lines": "BulkOps.java 文件包含多个不相关的基准测试（fill、copy、hash、mismatch），代码结构混乱，维护困难。", "code_v1_no_empty_lines": "- delete mode 100644 test/micro/org/openjdk/bench/java/lang/foreign/BulkOps.java\n+ .../java/lang/foreign/SegmentBulkCopy.java    | 165 +++++++++-----\n+ .../java/lang/foreign/SegmentBulkFill.java    | 162 +++++++-------\n+ .../java/lang/foreign/SegmentBulkHash.java    | 118 +++++++---\n+ .../lang/foreign/SegmentBulkMismatch.java     | 159 +++++++++----", "target": "- delete mode 100644 test/micro/org/openjdk/bench/java/lang/foreign/BulkOps.java\n+ .../java/lang/foreign/SegmentBulkCopy.java    | 165 +++++++++-----\n+ .../java/lang/foreign/SegmentBulkFill.java    | 162 +++++++-------\n+ .../java/lang/foreign/SegmentBulkHash.java    | 118 +++++++---\n+ .../lang/foreign/SegmentBulkMismatch.java     | 159 +++++++++----", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：BulkOps.java 文件包含多个不相关的基准测试（fill、copy、hash、mismatch），代码结构混乱，维护困难。优化后：将不同功能的基准测试拆分为独立的文件（SegmentBulkCopy.java、SegmentBulkFill.java、SegmentBulkHash.java、SegmentBulkMismatch.java），每个文件专注于单一操作类型。优化思路：通过模块化重构提高代码可读性、可维护性和扩展性，便于后续针对特定内存操作进行性能分析和优化。"}
{"id": 106, "source": "riscv-dataset-excel", "optimization_type": "流处理优化+内存优化", "optimization_description": "优化前：当Stream使用Comparator.naturalOrder()进行排序时，系统会错误地认为这不是自然排序，导致不必要的复制和排序操作。具体表现为：1. SortedOps.OfRef构造器对自然排序设置了IS_SORTED标志，但其他构造器对自然排序设置了NOT_SORTED标志；2. StreamOpFlag.fromCharacteristics方法只检查比较器是否为null，不识别Comparator.naturalOrder()。\n\n优化后：1. 统一了自然排序的处理逻辑，通过比较器是否为Comparator.naturalOrder()来正确设置IS_SORTED标志；2. 修改了fromCharacteristics方法，使其能识别Comparator.naturalOrder()作为自然排序。\n\n优化思路：通过精确识别自然排序（包括显式使用Comparator.naturalOrder()的情况），避免对已经自然排序的数据进行不必要的复制和重新排序，减少内存分配和计算开销，提高Stream操作的性能。", "original_code": "当Stream使用Comparator.naturalOrder()进行排序时，系统会错误地认为这不是自然排序，导致不必要的复制和排序操作。具体表现为：1. SortedOps.OfRef构造器对自然排序设置了IS_SORTED标志，但其他构造器对自然排序设置了NOT_SORTED标志；2. StreamOpFlag.fromCharacteristics方法只检查比较器是否为null，不识别Comparator.naturalOrder()。", "optimized_code": "1. SortedOps.java中OfRef构造器修改：\n- super(upstream, StreamShape.REFERENCE,\n  StreamOpFlag.IS_ORDERED | StreamOpFlag.IS_SORTED);\n- this.isNaturalSort = true;\n+ this(upstream, comp);\n\n2. StreamOpFlag.java中fromCharacteristics方法修改：\n- if ((characteristics & Spliterator.SORTED) != 0 && spliterator.getComparator() != null) {\n+ if ((characteristics & Spliterator.SORTED) != 0) {\n  Comparator<?> comparator = spliterator.getComparator();\n  if (comparator != null && !Comparator.naturalOrder().equals(comparator)) {", "source_url": "https://github.com/openjdk/riscv-port/commit/67ef81eb78b28e5dcdf91785b476dfd0858cbd16", "code_v0_no_empty_lines": "当Stream使用Comparator.naturalOrder()进行排序时，系统会错误地认为这不是自然排序，导致不必要的复制和排序操作。具体表现为：1. SortedOps.OfRef构造器对自然排序设置了IS_SORTED标志，但其他构造器对自然排序设置了NOT_SORTED标志；2. StreamOpFlag.fromCharacteristics方法只检查比较器是否为null，不识别Comparator.naturalOrder()。", "code_v1_no_empty_lines": "1. SortedOps.java中OfRef构造器修改：\n- super(upstream, StreamShape.REFERENCE,\n  StreamOpFlag.IS_ORDERED | StreamOpFlag.IS_SORTED);\n- this.isNaturalSort = true;\n+ this(upstream, comp);\n\n2. StreamOpFlag.java中fromCharacteristics方法修改：\n- if ((characteristics & Spliterator.SORTED) != 0 && spliterator.getComparator() != null) {\n+ if ((characteristics & Spliterator.SORTED) != 0) {\n  Comparator<?> comparator = spliterator.getComparator();\n  if (comparator != null && !Comparator.naturalOrder().equals(comparator)) {", "target": "1. SortedOps.java中OfRef构造器修改：\n- super(upstream, StreamShape.REFERENCE,\n  StreamOpFlag.IS_ORDERED | StreamOpFlag.IS_SORTED);\n- this.isNaturalSort = true;\n+ this(upstream, comp);\n\n2. StreamOpFlag.java中fromCharacteristics方法修改：\n- if ((characteristics & Spliterator.SORTED) != 0 && spliterator.getComparator() != null) {\n+ if ((characteristics & Spliterator.SORTED) != 0) {\n  Comparator<?> comparator = spliterator.getComparator();\n  if (comparator != null && !Comparator.naturalOrder().equals(comparator)) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当Stream使用Comparator.naturalOrder()进行排序时，系统会错误地认为这不是自然排序，导致不必要的复制和排序操作。具体表现为：1. SortedOps.OfRef构造器对自然排序设置了IS_SORTED标志，但其他构造器对自然排序设置了NOT_SORTED标志；2. StreamOpFlag.fromCharacteristics方法只检查比较器是否为null，不识别Comparator.naturalOrder()。\n\n优化后：1. 统一了自然排序的处理逻辑，通过比较器是否为Comparator.naturalOrder()来正确设置IS_SORTED标志；2. 修改了fromCharacteristics方法，使其能识别Comparator.naturalOrder()作为自然排序。\n\n优化思路：通过精确识别自然排序（包括显式使用Comparator.naturalOrder()的情况），避免对已经自然排序的数据进行不必要的复制和重新排序，减少内存分配和计算开销，提高Stream操作的性能。"}
{"id": 107, "source": "riscv-dataset-excel", "optimization_type": "链接时优化(LTO)支持", "optimization_description": "优化前：构建系统缺乏对链接时优化(LTO)的支持，无法在库级别启用跨模块的全局优化。优化后：为GCC、Clang和MSVC编译器添加了LTO编译和链接标志支持，包括C_O_FLAG_LTO、CXX_O_FLAG_LTO和LDFLAGS_LTO变量，并在NativeCompilation.gmk中引入了LINK_TIME_OPTIMIZATION配置选项，允许在构建时启用LTO。优化思路：通过添加编译器特定的LTO标志（如GCC的-flto=auto、Clang的-flto、MSVC的-GL/-LTCG）和相应的链接器标志，实现跨模块的全局优化，提升运行时性能。", "original_code": "构建系统缺乏对链接时优化(LTO)的支持，无法在库级别启用跨模块的全局优化。", "optimized_code": "if test \"x$TOOLCHAIN_TYPE\" = xgcc; then\n  C_O_FLAG_LTO=\"-flto=auto -fuse-linker-plugin -fno-strict-aliasing -fno-fat-lto-objects\"\nelse\n  C_O_FLAG_LTO=\"-flto -fno-strict-aliasing\"\nfi\n\nifeq (true, $$($1_LINK_TIME_OPTIMIZATION))\n  $1_EXTRA_CFLAGS += $(C_O_FLAG_LTO)\n  $1_EXTRA_CXXFLAGS += $(CXX_O_FLAG_LTO)\nendif\n\nifeq ($$($1_LINK_TIME_OPTIMIZATION), true)\n  $1_EXTRA_LDFLAGS += $(LDFLAGS_LTO)\nendif", "source_url": "https://github.com/openjdk/riscv-port/commit/5ef2c9aa09247f9853bf04db0df962fcff764499", "code_v0_no_empty_lines": "构建系统缺乏对链接时优化(LTO)的支持，无法在库级别启用跨模块的全局优化。", "code_v1_no_empty_lines": "if test \"x$TOOLCHAIN_TYPE\" = xgcc; then\n  C_O_FLAG_LTO=\"-flto=auto -fuse-linker-plugin -fno-strict-aliasing -fno-fat-lto-objects\"\nelse\n  C_O_FLAG_LTO=\"-flto -fno-strict-aliasing\"\nfi\n\nifeq (true, $$($1_LINK_TIME_OPTIMIZATION))\n  $1_EXTRA_CFLAGS += $(C_O_FLAG_LTO)\n  $1_EXTRA_CXXFLAGS += $(CXX_O_FLAG_LTO)\nendif\n\nifeq ($$($1_LINK_TIME_OPTIMIZATION), true)\n  $1_EXTRA_LDFLAGS += $(LDFLAGS_LTO)\nendif", "target": "if test \"x$TOOLCHAIN_TYPE\" = xgcc; then\n  C_O_FLAG_LTO=\"-flto=auto -fuse-linker-plugin -fno-strict-aliasing -fno-fat-lto-objects\"\nelse\n  C_O_FLAG_LTO=\"-flto -fno-strict-aliasing\"\nfi\n\nifeq (true, $$($1_LINK_TIME_OPTIMIZATION))\n  $1_EXTRA_CFLAGS += $(C_O_FLAG_LTO)\n  $1_EXTRA_CXXFLAGS += $(CXX_O_FLAG_LTO)\nendif\n\nifeq ($$($1_LINK_TIME_OPTIMIZATION), true)\n  $1_EXTRA_LDFLAGS += $(LDFLAGS_LTO)\nendif", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：构建系统缺乏对链接时优化(LTO)的支持，无法在库级别启用跨模块的全局优化。优化后：为GCC、Clang和MSVC编译器添加了LTO编译和链接标志支持，包括C_O_FLAG_LTO、CXX_O_FLAG_LTO和LDFLAGS_LTO变量，并在NativeCompilation.gmk中引入了LINK_TIME_OPTIMIZATION配置选项，允许在构建时启用LTO。优化思路：通过添加编译器特定的LTO标志（如GCC的-flto=auto、Clang的-flto、MSVC的-GL/-LTCG）和相应的链接器标志，实现跨模块的全局优化，提升运行时性能。"}
{"id": 108, "source": "riscv-dataset-excel", "optimization_type": "原子操作优化", "optimization_description": "优化前：VarHandle.getAndAdd()方法使用int字面量1，可能导致不必要的类型转换开销。优化后：使用long字面量1L，直接匹配VarHandle的long类型操作，消除类型转换，提升原子操作的性能。", "original_code": "VarHandle.getAndAdd()方法使用int字面量1，可能导致不必要的类型转换开销。", "optimized_code": "-                return name + (long) COUNT.getAndAdd(this, 1);\n+                return name + (long) COUNT.getAndAdd(this, 1L);", "source_url": "https://github.com/openjdk/riscv-port/commit/1226873ab94d2cc341ddb7040aa60c3bf3614feb", "code_v0_no_empty_lines": "VarHandle.getAndAdd()方法使用int字面量1，可能导致不必要的类型转换开销。", "code_v1_no_empty_lines": "-                return name + (long) COUNT.getAndAdd(this, 1);\n+                return name + (long) COUNT.getAndAdd(this, 1L);", "target": "-                return name + (long) COUNT.getAndAdd(this, 1);\n+                return name + (long) COUNT.getAndAdd(this, 1L);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：VarHandle.getAndAdd()方法使用int字面量1，可能导致不必要的类型转换开销。优化后：使用long字面量1L，直接匹配VarHandle的long类型操作，消除类型转换，提升原子操作的性能。"}
{"id": 109, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化+代码简化", "optimization_description": "优化前：使用枚举类型表示分配请求类型，需要额外的_affiliation和_is_promotion字段来存储代际和晋升信息，查询方法使用switch-case进行类型判断，代码冗余且效率较低。优化后：将分配类型重新设计为位编码的整数值，通过位掩码组合表示请求者、目的和代际信息，移除了_affiliation和_is_promotion字段，查询方法简化为位运算。优化思路：通过位编码将多个属性压缩到单个整数值中，减少内存占用，简化代码结构，提高查询效率，使代码更清晰高效。", "original_code": "使用枚举类型表示分配请求类型，需要额外的_affiliation和_is_promotion字段来存储代际和晋升信息，查询方法使用switch-case进行类型判断，代码冗余且效率较低。", "optimized_code": "enum Type {\n  _alloc_shared,      // Allocate common, outside of TLAB\n  _alloc_shared_gc,   // Allocate common, outside of GCLAB/PLAB\n  _alloc_cds,         // Allocate for CDS\n  _alloc_tlab,        // Allocate TLAB\n  _alloc_gclab,       // Allocate GCLAB\n  _alloc_plab,        // Allocate PLAB\n  _ALLOC_LIMIT\n};\n\nShenandoahAllocRequest(size_t _min_size, size_t _requested_size, Type _alloc_type, ShenandoahAffiliation affiliation, bool is_promotion = false) :\n        _min_size(_min_size), _requested_size(_requested_size),\n        _actual_size(0), _waste(0), _alloc_type(_alloc_type), _affiliation(affiliation), _is_promotion(is_promotion)\n\ninline bool is_mutator_alloc() const {\n  switch (_alloc_type) {\n    case _alloc_tlab:\n    case _alloc_shared:\n    case _alloc_cds:\n      return true;\n    case _alloc_gclab:\n    case _alloc_plab:\n    case _alloc_shared_gc:\n      return false;\n    default:\n      ShouldNotReachHere();\n      return false;\n  }\n}\n\n---\n\n// Alloc type is an int value with encoded bits in scheme as:\n// [x|xx|xx|xx]\n//          ^---- Requester:\n//                  00 -- mutator\n//                  10 -- mutator (CDS)\n//                  01 -- GC\n//       ^------- Purpose:\n//                  00 -- shared\n//                  01 -- TLAB/GCLAB\n//                  11 -- PLAB\n//    ^---------- Affiliation:\n//                  00 -- YOUNG\n//                  01 -- OLD\n//                  11 -- OLD, promotion\ntypedef int Type;\n\nstatic constexpr int bit_gc_alloc         = 1 << 0;\nstatic constexpr int bit_cds_alloc        = 1 << 1;\nstatic constexpr int bit_lab_alloc        = 1 << 2;\nstatic constexpr int bit_plab_alloc       = 1 << 3;\nstatic constexpr int bit_old_alloc        = 1 << 4;\nstatic constexpr int bit_promotion_alloc  = 1 << 5;\n\nstatic constexpr Type _alloc_shared              = 0;\nstatic constexpr Type _alloc_tlab                = bit_lab_alloc;\nstatic constexpr Type _alloc_cds                 = bit_cds_alloc;\nstatic constexpr Type _alloc_shared_gc           = bit_gc_alloc;\nstatic constexpr Type _alloc_shared_gc_old       = bit_gc_alloc | bit_old_alloc;\nstatic constexpr Type _alloc_shared_gc_promotion = bit_gc_alloc | bit_old_alloc | bit_promotion_alloc;\nstatic constexpr Type _alloc_gclab               = bit_gc_alloc | bit_lab_alloc;\nstatic constexpr Type _alloc_plab                = bit_gc_alloc | bit_lab_alloc | bit_plab_alloc | bit_old_alloc;\n\nShenandoahAllocRequest(size_t _min_size, size_t _requested_size, Type _alloc_type) :\n        _min_size(_min_size), _requested_size(_requested_size),\n        _actual_size(0), _waste(0), _alloc_type(_alloc_type)\n\ninline bool is_mutator_alloc() const {\n  return (_alloc_type & bit_gc_alloc) == 0;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/e00dec58083302fb74ebc994a65232c6367aee44", "code_v0_no_empty_lines": "使用枚举类型表示分配请求类型，需要额外的_affiliation和_is_promotion字段来存储代际和晋升信息，查询方法使用switch-case进行类型判断，代码冗余且效率较低。", "code_v1_no_empty_lines": "enum Type {\n  _alloc_shared,      // Allocate common, outside of TLAB\n  _alloc_shared_gc,   // Allocate common, outside of GCLAB/PLAB\n  _alloc_cds,         // Allocate for CDS\n  _alloc_tlab,        // Allocate TLAB\n  _alloc_gclab,       // Allocate GCLAB\n  _alloc_plab,        // Allocate PLAB\n  _ALLOC_LIMIT\n};\n\nShenandoahAllocRequest(size_t _min_size, size_t _requested_size, Type _alloc_type, ShenandoahAffiliation affiliation, bool is_promotion = false) :\n        _min_size(_min_size), _requested_size(_requested_size),\n        _actual_size(0), _waste(0), _alloc_type(_alloc_type), _affiliation(affiliation), _is_promotion(is_promotion)\n\ninline bool is_mutator_alloc() const {\n  switch (_alloc_type) {\n    case _alloc_tlab:\n    case _alloc_shared:\n    case _alloc_cds:\n      return true;\n    case _alloc_gclab:\n    case _alloc_plab:\n    case _alloc_shared_gc:\n      return false;\n    default:\n      ShouldNotReachHere();\n      return false;\n  }\n}\n\n---\n\n// Alloc type is an int value with encoded bits in scheme as:\n// [x|xx|xx|xx]\n//          ^---- Requester:\n//                  00 -- mutator\n//                  10 -- mutator (CDS)\n//                  01 -- GC\n//       ^------- Purpose:\n//                  00 -- shared\n//                  01 -- TLAB/GCLAB\n//                  11 -- PLAB\n//    ^---------- Affiliation:\n//                  00 -- YOUNG\n//                  01 -- OLD\n//                  11 -- OLD, promotion\ntypedef int Type;\n\nstatic constexpr int bit_gc_alloc         = 1 << 0;\nstatic constexpr int bit_cds_alloc        = 1 << 1;\nstatic constexpr int bit_lab_alloc        = 1 << 2;\nstatic constexpr int bit_plab_alloc       = 1 << 3;\nstatic constexpr int bit_old_alloc        = 1 << 4;\nstatic constexpr int bit_promotion_alloc  = 1 << 5;\n\nstatic constexpr Type _alloc_shared              = 0;\nstatic constexpr Type _alloc_tlab                = bit_lab_alloc;\nstatic constexpr Type _alloc_cds                 = bit_cds_alloc;\nstatic constexpr Type _alloc_shared_gc           = bit_gc_alloc;\nstatic constexpr Type _alloc_shared_gc_old       = bit_gc_alloc | bit_old_alloc;\nstatic constexpr Type _alloc_shared_gc_promotion = bit_gc_alloc | bit_old_alloc | bit_promotion_alloc;\nstatic constexpr Type _alloc_gclab               = bit_gc_alloc | bit_lab_alloc;\nstatic constexpr Type _alloc_plab                = bit_gc_alloc | bit_lab_alloc | bit_plab_alloc | bit_old_alloc;\n\nShenandoahAllocRequest(size_t _min_size, size_t _requested_size, Type _alloc_type) :\n        _min_size(_min_size), _requested_size(_requested_size),\n        _actual_size(0), _waste(0), _alloc_type(_alloc_type)\n\ninline bool is_mutator_alloc() const {\n  return (_alloc_type & bit_gc_alloc) == 0;\n}", "target": "enum Type {\n  _alloc_shared,      // Allocate common, outside of TLAB\n  _alloc_shared_gc,   // Allocate common, outside of GCLAB/PLAB\n  _alloc_cds,         // Allocate for CDS\n  _alloc_tlab,        // Allocate TLAB\n  _alloc_gclab,       // Allocate GCLAB\n  _alloc_plab,        // Allocate PLAB\n  _ALLOC_LIMIT\n};\n\nShenandoahAllocRequest(size_t _min_size, size_t _requested_size, Type _alloc_type, ShenandoahAffiliation affiliation, bool is_promotion = false) :\n        _min_size(_min_size), _requested_size(_requested_size),\n        _actual_size(0), _waste(0), _alloc_type(_alloc_type), _affiliation(affiliation), _is_promotion(is_promotion)\n\ninline bool is_mutator_alloc() const {\n  switch (_alloc_type) {\n    case _alloc_tlab:\n    case _alloc_shared:\n    case _alloc_cds:\n      return true;\n    case _alloc_gclab:\n    case _alloc_plab:\n    case _alloc_shared_gc:\n      return false;\n    default:\n      ShouldNotReachHere();\n      return false;\n  }\n}\n\n---\n\n// Alloc type is an int value with encoded bits in scheme as:\n// [x|xx|xx|xx]\n//          ^---- Requester:\n//                  00 -- mutator\n//                  10 -- mutator (CDS)\n//                  01 -- GC\n//       ^------- Purpose:\n//                  00 -- shared\n//                  01 -- TLAB/GCLAB\n//                  11 -- PLAB\n//    ^---------- Affiliation:\n//                  00 -- YOUNG\n//                  01 -- OLD\n//                  11 -- OLD, promotion\ntypedef int Type;\n\nstatic constexpr int bit_gc_alloc         = 1 << 0;\nstatic constexpr int bit_cds_alloc        = 1 << 1;\nstatic constexpr int bit_lab_alloc        = 1 << 2;\nstatic constexpr int bit_plab_alloc       = 1 << 3;\nstatic constexpr int bit_old_alloc        = 1 << 4;\nstatic constexpr int bit_promotion_alloc  = 1 << 5;\n\nstatic constexpr Type _alloc_shared              = 0;\nstatic constexpr Type _alloc_tlab                = bit_lab_alloc;\nstatic constexpr Type _alloc_cds                 = bit_cds_alloc;\nstatic constexpr Type _alloc_shared_gc           = bit_gc_alloc;\nstatic constexpr Type _alloc_shared_gc_old       = bit_gc_alloc | bit_old_alloc;\nstatic constexpr Type _alloc_shared_gc_promotion = bit_gc_alloc | bit_old_alloc | bit_promotion_alloc;\nstatic constexpr Type _alloc_gclab               = bit_gc_alloc | bit_lab_alloc;\nstatic constexpr Type _alloc_plab                = bit_gc_alloc | bit_lab_alloc | bit_plab_alloc | bit_old_alloc;\n\nShenandoahAllocRequest(size_t _min_size, size_t _requested_size, Type _alloc_type) :\n        _min_size(_min_size), _requested_size(_requested_size),\n        _actual_size(0), _waste(0), _alloc_type(_alloc_type)\n\ninline bool is_mutator_alloc() const {\n  return (_alloc_type & bit_gc_alloc) == 0;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用枚举类型表示分配请求类型，需要额外的_affiliation和_is_promotion字段来存储代际和晋升信息，查询方法使用switch-case进行类型判断，代码冗余且效率较低。优化后：将分配类型重新设计为位编码的整数值，通过位掩码组合表示请求者、目的和代际信息，移除了_affiliation和_is_promotion字段，查询方法简化为位运算。优化思路：通过位编码将多个属性压缩到单个整数值中，减少内存占用，简化代码结构，提高查询效率，使代码更清晰高效。"}
{"id": 110, "source": "riscv-dataset-excel", "optimization_type": "垃圾收集器屏障优化", "optimization_description": "优化前：arraycopy_marking函数接受src、dst、count和is_old_marking四个参数，包含大量针对分代模式的复杂条件判断（检查区域类型、TAMS位置等），代码冗余且维护困难。优化后：1. 简化函数签名，移除src和is_old_marking参数；2. 统一标记逻辑，使用allocated_after_mark_start()方法替代复杂的分代检查；3. 简化调用路径，移除对YOUNG_MARKING和OLD_MARKING的单独处理。优化思路：通过统一标记条件和简化参数，减少代码复杂性和维护成本，同时保持SATB屏障的正确性，提升代码可读性和执行效率。", "original_code": "arraycopy_marking函数接受src、dst、count和is_old_marking四个参数，包含大量针对分代模式的复杂条件判断（检查区域类型、TAMS位置等），代码冗余且维护困难。", "optimized_code": "template <class T>\n-  inline void arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking);\n+  inline void arraycopy_marking(T* dst, size_t count);\n\n-      if (ENQUEUE && !ctx->is_marked_strong_or_old(obj)) {\n+      if (ENQUEUE && !ctx->is_marked_strong(obj)) {\n\n-  char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n+  const char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n\n-  if (_heap->mode()->is_generational()) {\n-    assert(ShenandoahSATBBarrier, \"Generational mode assumes SATB mode\");\n-    if ((gc_state & ShenandoahHeap::YOUNG_MARKING) != 0) {\n-      arraycopy_marking(src, dst, count, false);\n-    }\n-    if ((gc_state & ShenandoahHeap::OLD_MARKING) != 0) {\n-      arraycopy_marking(src, dst, count, true);\n-    }\n-  } else if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n-    arraycopy_marking(src, dst, count, false);\n-  }\n+  if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n+    arraycopy_marking(dst, count);\n+  }\n\ntemplate <class T>\n-void ShenandoahBarrierSet::arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking) {\n+void ShenandoahBarrierSet::arraycopy_marking(T* dst, size_t count) {\n-    if (is_old_marking) {\n-      // Generational, old marking\n-      assert(_heap->mode()->is_generational(), \"Invariant\");\n-      if (r->is_old() && (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n-        arraycopy_work<T, false, false, true>(array, count);\n-      }\n-    } else if (_heap->mode()->is_generational()) {\n-      // Generational, young marking\n-      if (r->is_old() || (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n-        arraycopy_work<T, false, false, true>(array, count);\n-      }\n-    } else if (array_addr < _heap->marking_context()->top_at_mark_start(r)) {\n-      // Non-generational, marking\n-      arraycopy_work<T, false, false, true>(array, count);\n-    }\n+    if (!_heap->marking_context()->allocated_after_mark_start(reinterpret_cast<HeapWord*>(dst))) {\n+      arraycopy_work<T, false, false, true>(dst, count);\n+    }", "source_url": "https://github.com/openjdk/riscv-port/commit/f8cf9ca69cfef286c80559bfe1d147b6303d10d2", "code_v0_no_empty_lines": "arraycopy_marking函数接受src、dst、count和is_old_marking四个参数，包含大量针对分代模式的复杂条件判断（检查区域类型、TAMS位置等），代码冗余且维护困难。", "code_v1_no_empty_lines": "template <class T>\n-  inline void arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking);\n+  inline void arraycopy_marking(T* dst, size_t count);\n\n-      if (ENQUEUE && !ctx->is_marked_strong_or_old(obj)) {\n+      if (ENQUEUE && !ctx->is_marked_strong(obj)) {\n\n-  char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n+  const char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n\n-  if (_heap->mode()->is_generational()) {\n-    assert(ShenandoahSATBBarrier, \"Generational mode assumes SATB mode\");\n-    if ((gc_state & ShenandoahHeap::YOUNG_MARKING) != 0) {\n-      arraycopy_marking(src, dst, count, false);\n-    }\n-    if ((gc_state & ShenandoahHeap::OLD_MARKING) != 0) {\n-      arraycopy_marking(src, dst, count, true);\n-    }\n-  } else if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n-    arraycopy_marking(src, dst, count, false);\n-  }\n+  if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n+    arraycopy_marking(dst, count);\n+  }\n\ntemplate <class T>\n-void ShenandoahBarrierSet::arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking) {\n+void ShenandoahBarrierSet::arraycopy_marking(T* dst, size_t count) {\n-    if (is_old_marking) {\n-      // Generational, old marking\n-      assert(_heap->mode()->is_generational(), \"Invariant\");\n-      if (r->is_old() && (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n-        arraycopy_work<T, false, false, true>(array, count);\n-      }\n-    } else if (_heap->mode()->is_generational()) {\n-      // Generational, young marking\n-      if (r->is_old() || (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n-        arraycopy_work<T, false, false, true>(array, count);\n-      }\n-    } else if (array_addr < _heap->marking_context()->top_at_mark_start(r)) {\n-      // Non-generational, marking\n-      arraycopy_work<T, false, false, true>(array, count);\n-    }\n+    if (!_heap->marking_context()->allocated_after_mark_start(reinterpret_cast<HeapWord*>(dst))) {\n+      arraycopy_work<T, false, false, true>(dst, count);\n+    }", "target": "template <class T>\n-  inline void arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking);\n+  inline void arraycopy_marking(T* dst, size_t count);\n\n-      if (ENQUEUE && !ctx->is_marked_strong_or_old(obj)) {\n+      if (ENQUEUE && !ctx->is_marked_strong(obj)) {\n\n-  char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n+  const char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n\n-  if (_heap->mode()->is_generational()) {\n-    assert(ShenandoahSATBBarrier, \"Generational mode assumes SATB mode\");\n-    if ((gc_state & ShenandoahHeap::YOUNG_MARKING) != 0) {\n-      arraycopy_marking(src, dst, count, false);\n-    }\n-    if ((gc_state & ShenandoahHeap::OLD_MARKING) != 0) {\n-      arraycopy_marking(src, dst, count, true);\n-    }\n-  } else if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n-    arraycopy_marking(src, dst, count, false);\n-  }\n+  if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n+    arraycopy_marking(dst, count);\n+  }\n\ntemplate <class T>\n-void ShenandoahBarrierSet::arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking) {\n+void ShenandoahBarrierSet::arraycopy_marking(T* dst, size_t count) {\n-    if (is_old_marking) {\n-      // Generational, old marking\n-      assert(_heap->mode()->is_generational(), \"Invariant\");\n-      if (r->is_old() && (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n-        arraycopy_work<T, false, false, true>(array, count);\n-      }\n-    } else if (_heap->mode()->is_generational()) {\n-      // Generational, young marking\n-      if (r->is_old() || (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n-        arraycopy_work<T, false, false, true>(array, count);\n-      }\n-    } else if (array_addr < _heap->marking_context()->top_at_mark_start(r)) {\n-      // Non-generational, marking\n-      arraycopy_work<T, false, false, true>(array, count);\n-    }\n+    if (!_heap->marking_context()->allocated_after_mark_start(reinterpret_cast<HeapWord*>(dst))) {\n+      arraycopy_work<T, false, false, true>(dst, count);\n+    }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：arraycopy_marking函数接受src、dst、count和is_old_marking四个参数，包含大量针对分代模式的复杂条件判断（检查区域类型、TAMS位置等），代码冗余且维护困难。优化后：1. 简化函数签名，移除src和is_old_marking参数；2. 统一标记逻辑，使用allocated_after_mark_start()方法替代复杂的分代检查；3. 简化调用路径，移除对YOUNG_MARKING和OLD_MARKING的单独处理。优化思路：通过统一标记条件和简化参数，减少代码复杂性和维护成本，同时保持SATB屏障的正确性，提升代码可读性和执行效率。"}
{"id": 111, "source": "riscv-dataset-excel", "optimization_type": "原子操作优化+内存模型优化", "optimization_description": "优化前使用通用的AtomicAccess包装函数进行原子操作，存在间接调用开销且内存序语义不够精确。优化后直接使用C++11风格的Atomic<T>模板类，提供更精确的内存序控制（如load_relaxed、release_store）和更高效的原子操作原语（如exchange、add_then_fetch）。这减少了函数调用开销，允许编译器生成更优化的代码，并明确内存同步语义，提升多线程并发性能。", "original_code": "// No original code extracted from description\n", "optimized_code": "- FreeNode* old_head = AtomicAccess::xchg(&_head, node);\n+ FreeNode* old_head = _head.exchange(node);\n- size_t result = AtomicAccess::load(&_count);\n+ size_t result = _count.load_relaxed();\n- AtomicAccess::store(&_transfer_lock, false);\n+ _transfer_lock.release_store(false);", "source_url": "https://github.com/openjdk/riscv-port/commit/3f47e5795378fda6da90dd45e043cb491a73e792", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- FreeNode* old_head = AtomicAccess::xchg(&_head, node);\n+ FreeNode* old_head = _head.exchange(node);\n- size_t result = AtomicAccess::load(&_count);\n+ size_t result = _count.load_relaxed();\n- AtomicAccess::store(&_transfer_lock, false);\n+ _transfer_lock.release_store(false);", "target": "- FreeNode* old_head = AtomicAccess::xchg(&_head, node);\n+ FreeNode* old_head = _head.exchange(node);\n- size_t result = AtomicAccess::load(&_count);\n+ size_t result = _count.load_relaxed();\n- AtomicAccess::store(&_transfer_lock, false);\n+ _transfer_lock.release_store(false);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用通用的AtomicAccess包装函数进行原子操作，存在间接调用开销且内存序语义不够精确。优化后直接使用C++11风格的Atomic<T>模板类，提供更精确的内存序控制（如load_relaxed、release_store）和更高效的原子操作原语（如exchange、add_then_fetch）。这减少了函数调用开销，允许编译器生成更优化的代码，并明确内存同步语义，提升多线程并发性能。"}
{"id": 112, "source": "riscv-dataset-excel", "optimization_type": "原子操作优化", "optimization_description": "优化前：使用volatile变量配合AtomicAccess工具函数进行原子操作，代码分散且依赖外部工具。优化后：使用C++11风格的Atomic<T>模板类，将_age和_bottom声明为Atomic类型，直接调用成员函数如load_relaxed()、compare_exchange()。优化思路：统一原子操作接口，减少间接调用，提高代码可读性和维护性，可能带来轻微性能提升。", "original_code": "使用volatile变量配合AtomicAccess工具函数进行原子操作，代码分散且依赖外部工具。", "optimized_code": "- volatile uint _bottom;\n+ Atomic<uint> _bottom;\n- volatile Age _age;\n+ Atomic<Age> _age;\n- return AtomicAccess::load(&_age._data);\n+ return _age.load_relaxed();\n- return Age(AtomicAccess::cmpxchg(&_age._data, old_age._data, new_age._data));\n+ return _age.compare_exchange(old_age, new_age);", "source_url": "https://github.com/openjdk/riscv-port/commit/45246bc72daf68b905d7342f478e53bfe2883796", "code_v0_no_empty_lines": "使用volatile变量配合AtomicAccess工具函数进行原子操作，代码分散且依赖外部工具。", "code_v1_no_empty_lines": "- volatile uint _bottom;\n+ Atomic<uint> _bottom;\n- volatile Age _age;\n+ Atomic<Age> _age;\n- return AtomicAccess::load(&_age._data);\n+ return _age.load_relaxed();\n- return Age(AtomicAccess::cmpxchg(&_age._data, old_age._data, new_age._data));\n+ return _age.compare_exchange(old_age, new_age);", "target": "- volatile uint _bottom;\n+ Atomic<uint> _bottom;\n- volatile Age _age;\n+ Atomic<Age> _age;\n- return AtomicAccess::load(&_age._data);\n+ return _age.load_relaxed();\n- return Age(AtomicAccess::cmpxchg(&_age._data, old_age._data, new_age._data));\n+ return _age.compare_exchange(old_age, new_age);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用volatile变量配合AtomicAccess工具函数进行原子操作，代码分散且依赖外部工具。优化后：使用C++11风格的Atomic<T>模板类，将_age和_bottom声明为Atomic类型，直接调用成员函数如load_relaxed()、compare_exchange()。优化思路：统一原子操作接口，减少间接调用，提高代码可读性和维护性，可能带来轻微性能提升。"}
{"id": 113, "source": "riscv-dataset-excel", "optimization_type": "内存分配优化+性能优化", "optimization_description": "优化前：normalize方法总是创建新的char数组并转换所有字符，即使输入已经是规范化格式。优化后：1) 添加快速路径检查，如果输入已经是规范化格式（首字符非小写字母且后续字符非大写字母），直接返回原字符串，避免不必要的数组分配和字符转换。2) 方法改为static，减少实例方法调用开销。3) 优化字符检查逻辑，提前发现非法字符。优化思路：通过减少不必要的内存分配和字符操作，提升HTTP头部规范化性能，特别是对于已经规范化的常见头部名称。", "original_code": "normalize方法总是创建新的char数组并转换所有字符，即使输入已经是规范化格式。", "optimized_code": "-    private String normalize(String key) {\n+    private static String normalize(String key) {\n         Objects.requireNonNull(key);\n-        int len = key.length();\n-        if (len == 0) {\n+        int l = key.length();\n+        if (l == 0) {\n             return key;\n         }\n-        char[] b = key.toCharArray();\n-        if (b[0] >= 'a' && b[0] <= 'z') {\n-            b[0] = (char)(b[0] - ('a' - 'A'));\n-        } else if (b[0] == '\\r' || b[0] == '\\n')\n-            throw new IllegalArgumentException(\"illegal character in key\");\n-\n-        for (int i=1; i<len; i++) {\n-            if (b[i] >= 'A' && b[i] <= 'Z') {\n-                b[i] = (char) (b[i] + ('a' - 'A'));\n-            } else if (b[i] == '\\r' || b[i] == '\\n')\n-                throw new IllegalArgumentException(\"illegal character in key\");\n+        // Find the first non-normalized `char`\n+        int i = 0;\n+        char c = key.charAt(i);\n+        if (!(c == '\\r' || c == '\\n' || (c >= 'a' && c <= 'z'))) {\n+            i++;\n+            for (; i < l; i++) {\n+                c = key.charAt(i);\n+                if (c == '\\r' || c == '\\n' || (c >= 'A' && c <= 'Z')) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // Fast path for the already normalized key\n+        if (i == l) {\n+            return key;\n         }\n-        return new String(b);\n+\n+        // Upper-case the first `char`\n+        char[] cs = key.toCharArray();\n+        int o = 'a' - 'A';\n+        if (i == 0) {\n+            if (c == '\\r' || c == '\\n') {\n+                throw new IllegalArgumentException(\"illegal character in key at index \" + i);\n+            }\n+            if (c >= 'a' && c <= 'z') {\n+                cs[0] = (char) (c - o);\n+            }\n+            i++;\n+        }\n+\n+        // Lower-case the secondary `char`s\n+        for (; i < l; i++) {\n+            c = cs[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                cs[i] = (char) (c + o);\n+            } else if (c == '\\r' || c == '\\n') {\n+                throw new IllegalArgumentException(\"illegal character in key at index \" + i);\n+            }\n+        }\n+\n+        return new String(cs);", "source_url": "https://github.com/openjdk/riscv-port/commit/ea19ad2ac8a1fa9d4124be9a8e05cf4c6f6231bd", "code_v0_no_empty_lines": "normalize方法总是创建新的char数组并转换所有字符，即使输入已经是规范化格式。", "code_v1_no_empty_lines": "-    private String normalize(String key) {\n+    private static String normalize(String key) {\n         Objects.requireNonNull(key);\n-        int len = key.length();\n-        if (len == 0) {\n+        int l = key.length();\n+        if (l == 0) {\n             return key;\n         }\n-        char[] b = key.toCharArray();\n-        if (b[0] >= 'a' && b[0] <= 'z') {\n-            b[0] = (char)(b[0] - ('a' - 'A'));\n-        } else if (b[0] == '\\r' || b[0] == '\\n')\n-            throw new IllegalArgumentException(\"illegal character in key\");\n-\n-        for (int i=1; i<len; i++) {\n-            if (b[i] >= 'A' && b[i] <= 'Z') {\n-                b[i] = (char) (b[i] + ('a' - 'A'));\n-            } else if (b[i] == '\\r' || b[i] == '\\n')\n-                throw new IllegalArgumentException(\"illegal character in key\");\n+        // Find the first non-normalized `char`\n+        int i = 0;\n+        char c = key.charAt(i);\n+        if (!(c == '\\r' || c == '\\n' || (c >= 'a' && c <= 'z'))) {\n+            i++;\n+            for (; i < l; i++) {\n+                c = key.charAt(i);\n+                if (c == '\\r' || c == '\\n' || (c >= 'A' && c <= 'Z')) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // Fast path for the already normalized key\n+        if (i == l) {\n+            return key;\n         }\n-        return new String(b);\n+\n+        // Upper-case the first `char`\n+        char[] cs = key.toCharArray();\n+        int o = 'a' - 'A';\n+        if (i == 0) {\n+            if (c == '\\r' || c == '\\n') {\n+                throw new IllegalArgumentException(\"illegal character in key at index \" + i);\n+            }\n+            if (c >= 'a' && c <= 'z') {\n+                cs[0] = (char) (c - o);\n+            }\n+            i++;\n+        }\n+\n+        // Lower-case the secondary `char`s\n+        for (; i < l; i++) {\n+            c = cs[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                cs[i] = (char) (c + o);\n+            } else if (c == '\\r' || c == '\\n') {\n+                throw new IllegalArgumentException(\"illegal character in key at index \" + i);\n+            }\n+        }\n+\n+        return new String(cs);", "target": "-    private String normalize(String key) {\n+    private static String normalize(String key) {\n         Objects.requireNonNull(key);\n-        int len = key.length();\n-        if (len == 0) {\n+        int l = key.length();\n+        if (l == 0) {\n             return key;\n         }\n-        char[] b = key.toCharArray();\n-        if (b[0] >= 'a' && b[0] <= 'z') {\n-            b[0] = (char)(b[0] - ('a' - 'A'));\n-        } else if (b[0] == '\\r' || b[0] == '\\n')\n-            throw new IllegalArgumentException(\"illegal character in key\");\n-\n-        for (int i=1; i<len; i++) {\n-            if (b[i] >= 'A' && b[i] <= 'Z') {\n-                b[i] = (char) (b[i] + ('a' - 'A'));\n-            } else if (b[i] == '\\r' || b[i] == '\\n')\n-                throw new IllegalArgumentException(\"illegal character in key\");\n+        // Find the first non-normalized `char`\n+        int i = 0;\n+        char c = key.charAt(i);\n+        if (!(c == '\\r' || c == '\\n' || (c >= 'a' && c <= 'z'))) {\n+            i++;\n+            for (; i < l; i++) {\n+                c = key.charAt(i);\n+                if (c == '\\r' || c == '\\n' || (c >= 'A' && c <= 'Z')) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // Fast path for the already normalized key\n+        if (i == l) {\n+            return key;\n         }\n-        return new String(b);\n+\n+        // Upper-case the first `char`\n+        char[] cs = key.toCharArray();\n+        int o = 'a' - 'A';\n+        if (i == 0) {\n+            if (c == '\\r' || c == '\\n') {\n+                throw new IllegalArgumentException(\"illegal character in key at index \" + i);\n+            }\n+            if (c >= 'a' && c <= 'z') {\n+                cs[0] = (char) (c - o);\n+            }\n+            i++;\n+        }\n+\n+        // Lower-case the secondary `char`s\n+        for (; i < l; i++) {\n+            c = cs[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                cs[i] = (char) (c + o);\n+            } else if (c == '\\r' || c == '\\n') {\n+                throw new IllegalArgumentException(\"illegal character in key at index \" + i);\n+            }\n+        }\n+\n+        return new String(cs);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：normalize方法总是创建新的char数组并转换所有字符，即使输入已经是规范化格式。优化后：1) 添加快速路径检查，如果输入已经是规范化格式（首字符非小写字母且后续字符非大写字母），直接返回原字符串，避免不必要的数组分配和字符转换。2) 方法改为static，减少实例方法调用开销。3) 优化字符检查逻辑，提前发现非法字符。优化思路：通过减少不必要的内存分配和字符操作，提升HTTP头部规范化性能，特别是对于已经规范化的常见头部名称。"}
{"id": 114, "source": "riscv-dataset-excel", "optimization_type": "延迟初始化+线程安全优化", "optimization_description": "优化前：1. Timer对象在类加载时立即初始化，增加启动开销；2. WatcherThread在setupWatch()中无条件启动，即使后续可能不需要。优化后：1. 使用静态内部类TimerHolder实现Timer的延迟初始化，减少应用启动时的资源消耗；2. 引入双重检查锁定机制，仅在首次调用getTokens()时启动WatcherThread，避免不必要的线程创建。优化思路：通过延迟初始化和条件启动减少远程桌面场景下的性能开销。", "original_code": "1. Timer对象在类加载时立即初始化，增加启动开销；2. WatcherThread在setupWatch()中无条件启动，即使后续可能不需要。", "optimized_code": "1. ScreencastHelper.java:\n- private static final Timer timerCloseSession = new Timer(\"auto-close screencast session\", true);\n+ private static class TimerHolder {\n+     private static final Timer timerCloseSession = new Timer(\"auto-close screencast session\", true);\n+ }\n\n2. TokenStorage.java:\n- if (watchService != null) {\n-     new WatcherThread(watchService).start();\n- }\n+ private static void startWatcherThreadIfNeeded() {\n+     if (!isWatcherThreadStarted) {\n+         synchronized (TokenStorage.class) {\n+             if (!isWatcherThreadStarted) {\n+                 readTokens(PROPS_PATH);\n+                 if (watchService != null) {\n+                     new WatcherThread(watchService).start();\n+                 }\n+                 isWatcherThreadStarted = true;\n+             }\n+         }\n+     }\n+ }\n\n+ static Set<TokenItem> getTokens(List<Rectangle> affectedScreenBounds) {\n+     startWatcherThreadIfNeeded();", "source_url": "https://github.com/openjdk/riscv-port/commit/0b3df489e9d3b6d876a67793e082b930c17ade3e", "code_v0_no_empty_lines": "1. Timer对象在类加载时立即初始化，增加启动开销；2. WatcherThread在setupWatch()中无条件启动，即使后续可能不需要。", "code_v1_no_empty_lines": "1. ScreencastHelper.java:\n- private static final Timer timerCloseSession = new Timer(\"auto-close screencast session\", true);\n+ private static class TimerHolder {\n+     private static final Timer timerCloseSession = new Timer(\"auto-close screencast session\", true);\n+ }\n\n2. TokenStorage.java:\n- if (watchService != null) {\n-     new WatcherThread(watchService).start();\n- }\n+ private static void startWatcherThreadIfNeeded() {\n+     if (!isWatcherThreadStarted) {\n+         synchronized (TokenStorage.class) {\n+             if (!isWatcherThreadStarted) {\n+                 readTokens(PROPS_PATH);\n+                 if (watchService != null) {\n+                     new WatcherThread(watchService).start();\n+                 }\n+                 isWatcherThreadStarted = true;\n+             }\n+         }\n+     }\n+ }\n\n+ static Set<TokenItem> getTokens(List<Rectangle> affectedScreenBounds) {\n+     startWatcherThreadIfNeeded();", "target": "1. ScreencastHelper.java:\n- private static final Timer timerCloseSession = new Timer(\"auto-close screencast session\", true);\n+ private static class TimerHolder {\n+     private static final Timer timerCloseSession = new Timer(\"auto-close screencast session\", true);\n+ }\n\n2. TokenStorage.java:\n- if (watchService != null) {\n-     new WatcherThread(watchService).start();\n- }\n+ private static void startWatcherThreadIfNeeded() {\n+     if (!isWatcherThreadStarted) {\n+         synchronized (TokenStorage.class) {\n+             if (!isWatcherThreadStarted) {\n+                 readTokens(PROPS_PATH);\n+                 if (watchService != null) {\n+                     new WatcherThread(watchService).start();\n+                 }\n+                 isWatcherThreadStarted = true;\n+             }\n+         }\n+     }\n+ }\n\n+ static Set<TokenItem> getTokens(List<Rectangle> affectedScreenBounds) {\n+     startWatcherThreadIfNeeded();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. Timer对象在类加载时立即初始化，增加启动开销；2. WatcherThread在setupWatch()中无条件启动，即使后续可能不需要。优化后：1. 使用静态内部类TimerHolder实现Timer的延迟初始化，减少应用启动时的资源消耗；2. 引入双重检查锁定机制，仅在首次调用getTokens()时启动WatcherThread，避免不必要的线程创建。优化思路：通过延迟初始化和条件启动减少远程桌面场景下的性能开销。"}
{"id": 115, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前：在ZGC的AArch64平台屏障重定位代码中，调用OrderAccess::fence()创建了冗余的内存屏障。优化后：移除了该冗余的OrderAccess::fence()调用。优化思路：分析发现ICache::invalidate_word()内部已经包含了必要的内存同步操作，外部的显式内存屏障是多余的，移除它可以减少不必要的内存屏障开销，提升性能。", "original_code": "在ZGC的AArch64平台屏障重定位代码中，调用OrderAccess::fence()创建了冗余的内存屏障。", "optimized_code": "-  OrderAccess::fence();", "source_url": "https://github.com/openjdk/riscv-port/commit/d2926dfd9a242928877d0b1e40eac498073975bd", "code_v0_no_empty_lines": "在ZGC的AArch64平台屏障重定位代码中，调用OrderAccess::fence()创建了冗余的内存屏障。", "code_v1_no_empty_lines": "-  OrderAccess::fence();", "target": "-  OrderAccess::fence();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在ZGC的AArch64平台屏障重定位代码中，调用OrderAccess::fence()创建了冗余的内存屏障。优化后：移除了该冗余的OrderAccess::fence()调用。优化思路：分析发现ICache::invalidate_word()内部已经包含了必要的内存同步操作，外部的显式内存屏障是多余的，移除它可以减少不必要的内存屏障开销，提升性能。"}
{"id": 116, "source": "riscv-dataset-excel", "optimization_type": "性能优化+内存优化", "optimization_description": "优化前：ArrayList.addAll()对所有集合类型都调用toArray()方法，这会为源集合创建新的数组副本，增加内存分配和复制开销。优化后：当源集合是ArrayList时，直接访问其内部elementData数组和size字段，避免创建中间数组副本。同时为Collections.singletonList添加了toArray()方法实现，支持更高效的数组转换。优化思路：通过类型检查实现特化路径，减少内存分配和数据复制，提升批量操作性能。", "original_code": "ArrayList.addAll()对所有集合类型都调用toArray()方法，这会为源集合创建新的数组副本，增加内存分配和复制开销。", "optimized_code": "public boolean addAll(Collection<? extends E> c) {\n-        Object[] a = c.toArray();\n+        Object[] a;\n+        int numNew;\n+        if (c.getClass() == ArrayList.class) {\n+            ArrayList<?> src = (ArrayList<?>) c;\n+            a = src.elementData;\n+            numNew = src.size;\n+        } else {\n+            a = c.toArray();\n+            numNew = a.length;\n+        }\n         modCount++;\n-        int numNew = a.length;\n         if (numNew == 0)\n             return false;\n         Object[] elementData;", "source_url": "https://github.com/openjdk/riscv-port/commit/aeea8497562aabda12f292ad93c9f0f6935cc842", "code_v0_no_empty_lines": "ArrayList.addAll()对所有集合类型都调用toArray()方法，这会为源集合创建新的数组副本，增加内存分配和复制开销。", "code_v1_no_empty_lines": "public boolean addAll(Collection<? extends E> c) {\n-        Object[] a = c.toArray();\n+        Object[] a;\n+        int numNew;\n+        if (c.getClass() == ArrayList.class) {\n+            ArrayList<?> src = (ArrayList<?>) c;\n+            a = src.elementData;\n+            numNew = src.size;\n+        } else {\n+            a = c.toArray();\n+            numNew = a.length;\n+        }\n         modCount++;\n-        int numNew = a.length;\n         if (numNew == 0)\n             return false;\n         Object[] elementData;", "target": "public boolean addAll(Collection<? extends E> c) {\n-        Object[] a = c.toArray();\n+        Object[] a;\n+        int numNew;\n+        if (c.getClass() == ArrayList.class) {\n+            ArrayList<?> src = (ArrayList<?>) c;\n+            a = src.elementData;\n+            numNew = src.size;\n+        } else {\n+            a = c.toArray();\n+            numNew = a.length;\n+        }\n         modCount++;\n-        int numNew = a.length;\n         if (numNew == 0)\n             return false;\n         Object[] elementData;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ArrayList.addAll()对所有集合类型都调用toArray()方法，这会为源集合创建新的数组副本，增加内存分配和复制开销。优化后：当源集合是ArrayList时，直接访问其内部elementData数组和size字段，避免创建中间数组副本。同时为Collections.singletonList添加了toArray()方法实现，支持更高效的数组转换。优化思路：通过类型检查实现特化路径，减少内存分配和数据复制，提升批量操作性能。"}
{"id": 117, "source": "riscv-dataset-excel", "optimization_type": "原子操作优化", "optimization_description": "优化前使用自定义的AtomicAccess包装类进行原子操作，存在额外的函数调用开销和间接访问。优化后直接使用C++11标准的Atomic<T>模板类，通过成员函数调用实现原子操作，减少了间接调用开销，提高了内存访问效率，同时保持了相同的线程安全语义。", "original_code": "// No original code extracted from description\n", "optimized_code": "- int new_value = AtomicAccess::add(&_refcount, 1);\n+ int old_value = _refcount.fetch_then_add(1);\n- size_t index = _block_count;\n+ size_t index = _block_count.load_relaxed();\n- AtomicAccess::release_store(&_block_count, index + 1);\n+ _block_count.release_store(index + 1);", "source_url": "https://github.com/openjdk/riscv-port/commit/152cd4d8bab7d3428d0330c56a3cb9ed7feef313", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- int new_value = AtomicAccess::add(&_refcount, 1);\n+ int old_value = _refcount.fetch_then_add(1);\n- size_t index = _block_count;\n+ size_t index = _block_count.load_relaxed();\n- AtomicAccess::release_store(&_block_count, index + 1);\n+ _block_count.release_store(index + 1);", "target": "- int new_value = AtomicAccess::add(&_refcount, 1);\n+ int old_value = _refcount.fetch_then_add(1);\n- size_t index = _block_count;\n+ size_t index = _block_count.load_relaxed();\n- AtomicAccess::release_store(&_block_count, index + 1);\n+ _block_count.release_store(index + 1);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用自定义的AtomicAccess包装类进行原子操作，存在额外的函数调用开销和间接访问。优化后直接使用C++11标准的Atomic<T>模板类，通过成员函数调用实现原子操作，减少了间接调用开销，提高了内存访问效率，同时保持了相同的线程安全语义。"}
{"id": 118, "source": "riscv-dataset-excel", "optimization_type": "内联优化+类层次分析优化", "optimization_description": "优化前：C2编译器在通过方法句柄链接器进行内联时，无法对接口调用应用类层次分析（CHA）优化，导致无法将接口调用转换为直接调用或内联。优化后：扩展CHA支持到通过方法句柄链接器（linkToInterface/linkToVirtual）的接口调用，通过改进is_leaf_type()判断逻辑、添加接口类型检查、重构调用类型检测逻辑，使得编译器能够识别方法句柄链接器调用的接口调用，并应用CHA优化。优化思路：通过统一处理invokeinterface字节码和方法句柄链接器调用，使编译器能够识别这些调用模式，检查接口的唯一实现者，从而将虚调用转换为直接调用或内联，减少虚方法调用的开销。", "original_code": "C2编译器在通过方法句柄链接器进行内联时，无法对接口调用应用类层次分析（CHA）优化，导致无法将接口调用转换为直接调用或内联。", "optimized_code": "const bool is_virtual = (bytecode == Bytecodes::_invokevirtual) || (orig_callee->intrinsic_id() == vmIntrinsics::_linkToVirtual);\nconst bool is_interface = (bytecode == Bytecodes::_invokeinterface) || (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface);\nconst bool is_virtual_or_interface = is_virtual || is_interface;\n\n...\n\nif (call_does_dispatch && is_interface) {\n  ciInstanceKlass* declared_interface = nullptr;\n  if (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface) {\n    declared_interface = callee->holder();\n  } else {\n    declared_interface = caller->get_declared_method_holder_at_bci(bci)->as_instance_klass();\n  }\n  assert(declared_interface->is_interface(), \"required\");\n  ciInstanceKlass* singleton = declared_interface->unique_implementor();\n\n  if (singleton != nullptr) {\n    ciMethod* cha_monomorphic_target =\n        callee->find_monomorphic_target(caller->holder(), declared_interface, singleton, check_access);", "source_url": "https://github.com/openjdk/riscv-port/commit/256a9beffc106d6657a912a33f97e7f97acbb1e1", "code_v0_no_empty_lines": "C2编译器在通过方法句柄链接器进行内联时，无法对接口调用应用类层次分析（CHA）优化，导致无法将接口调用转换为直接调用或内联。", "code_v1_no_empty_lines": "const bool is_virtual = (bytecode == Bytecodes::_invokevirtual) || (orig_callee->intrinsic_id() == vmIntrinsics::_linkToVirtual);\nconst bool is_interface = (bytecode == Bytecodes::_invokeinterface) || (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface);\nconst bool is_virtual_or_interface = is_virtual || is_interface;\n\n...\n\nif (call_does_dispatch && is_interface) {\n  ciInstanceKlass* declared_interface = nullptr;\n  if (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface) {\n    declared_interface = callee->holder();\n  } else {\n    declared_interface = caller->get_declared_method_holder_at_bci(bci)->as_instance_klass();\n  }\n  assert(declared_interface->is_interface(), \"required\");\n  ciInstanceKlass* singleton = declared_interface->unique_implementor();\n\n  if (singleton != nullptr) {\n    ciMethod* cha_monomorphic_target =\n        callee->find_monomorphic_target(caller->holder(), declared_interface, singleton, check_access);", "target": "const bool is_virtual = (bytecode == Bytecodes::_invokevirtual) || (orig_callee->intrinsic_id() == vmIntrinsics::_linkToVirtual);\nconst bool is_interface = (bytecode == Bytecodes::_invokeinterface) || (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface);\nconst bool is_virtual_or_interface = is_virtual || is_interface;\n\n...\n\nif (call_does_dispatch && is_interface) {\n  ciInstanceKlass* declared_interface = nullptr;\n  if (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface) {\n    declared_interface = callee->holder();\n  } else {\n    declared_interface = caller->get_declared_method_holder_at_bci(bci)->as_instance_klass();\n  }\n  assert(declared_interface->is_interface(), \"required\");\n  ciInstanceKlass* singleton = declared_interface->unique_implementor();\n\n  if (singleton != nullptr) {\n    ciMethod* cha_monomorphic_target =\n        callee->find_monomorphic_target(caller->holder(), declared_interface, singleton, check_access);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器在通过方法句柄链接器进行内联时，无法对接口调用应用类层次分析（CHA）优化，导致无法将接口调用转换为直接调用或内联。优化后：扩展CHA支持到通过方法句柄链接器（linkToInterface/linkToVirtual）的接口调用，通过改进is_leaf_type()判断逻辑、添加接口类型检查、重构调用类型检测逻辑，使得编译器能够识别方法句柄链接器调用的接口调用，并应用CHA优化。优化思路：通过统一处理invokeinterface字节码和方法句柄链接器调用，使编译器能够识别这些调用模式，检查接口的唯一实现者，从而将虚调用转换为直接调用或内联，减少虚方法调用的开销。"}
{"id": 119, "source": "riscv-dataset-excel", "optimization_type": "内存优化+代码简化", "optimization_description": "优化前：为C2编译器生成的预取指令（特别是SPARC平台的BIS指令）预留额外空间，防止访问堆外内存导致故障。这增加了TLAB的保留空间计算复杂度。优化后：移除了_reserve_for_allocation_prefetch字段及相关计算逻辑，TLAB保留空间仅基于堆对齐需求。优化思路：随着代码演进，预取指令已不再需要额外空间保护，简化了内存分配路径，减少了代码复杂性和潜在的内存浪费。", "original_code": "为C2编译器生成的预取指令（特别是SPARC平台的BIS指令）预留额外空间，防止访问堆外内存导致故障。这增加了TLAB的保留空间计算复杂度。", "optimized_code": "-  static int      _reserve_for_allocation_prefetch;   // Reserve at the end of the TLAB\n-  int lines =  MAX2(AllocatePrefetchLines, AllocateInstancePrefetchLines) + 2;\n    _reserve_for_allocation_prefetch = (AllocatePrefetchDistance + AllocatePrefetchStepSize * lines) /\n                                       (int)HeapWordSize;\n+  return CollectedHeap::lab_alignment_reserve();", "source_url": "https://github.com/openjdk/riscv-port/commit/50a30497370799e8f377a11914562a15b0a48fbb", "code_v0_no_empty_lines": "为C2编译器生成的预取指令（特别是SPARC平台的BIS指令）预留额外空间，防止访问堆外内存导致故障。这增加了TLAB的保留空间计算复杂度。", "code_v1_no_empty_lines": "-  static int      _reserve_for_allocation_prefetch;   // Reserve at the end of the TLAB\n-  int lines =  MAX2(AllocatePrefetchLines, AllocateInstancePrefetchLines) + 2;\n    _reserve_for_allocation_prefetch = (AllocatePrefetchDistance + AllocatePrefetchStepSize * lines) /\n                                       (int)HeapWordSize;\n+  return CollectedHeap::lab_alignment_reserve();", "target": "-  static int      _reserve_for_allocation_prefetch;   // Reserve at the end of the TLAB\n-  int lines =  MAX2(AllocatePrefetchLines, AllocateInstancePrefetchLines) + 2;\n    _reserve_for_allocation_prefetch = (AllocatePrefetchDistance + AllocatePrefetchStepSize * lines) /\n                                       (int)HeapWordSize;\n+  return CollectedHeap::lab_alignment_reserve();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：为C2编译器生成的预取指令（特别是SPARC平台的BIS指令）预留额外空间，防止访问堆外内存导致故障。这增加了TLAB的保留空间计算复杂度。优化后：移除了_reserve_for_allocation_prefetch字段及相关计算逻辑，TLAB保留空间仅基于堆对齐需求。优化思路：随着代码演进，预取指令已不再需要额外空间保护，简化了内存分配路径，减少了代码复杂性和潜在的内存浪费。"}
{"id": 120, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：使用fill_with_objects逐个填充对象并循环更新BOT（Block Offset Table），每次迭代需要计算对象大小并调用update_bot_for_block，存在多次函数调用和循环开销。优化后：改用更精确的fill_with_object API一次性填充整个范围，并直接调用update_bot_for_block更新整个范围的BOT，消除了循环和重复计算。优化思路：简化内存填充逻辑，减少不必要的循环和函数调用，提高GC期间内存区域填充的效率。", "original_code": "使用fill_with_objects逐个填充对象并循环更新BOT（Block Offset Table），每次迭代需要计算对象大小并调用update_bot_for_block，存在多次函数调用和循环开销。", "optimized_code": "-  CollectedHeap::fill_with_objects(start, range_size, !has_pinned_objects());\n+  CollectedHeap::fill_with_object(start, range_size, !has_pinned_objects());\n-  HeapWord* current = start;\n-  do {\n-    // Update the BOT if the a threshold is crossed.\n-    size_t obj_size = cast_to_oop(current)->size();\n-    update_bot_for_block(current, current + obj_size);\n-\n-    // Advance to the next object.\n-    current += obj_size;\n-    guarantee(current <= end, \"Should never go past end\");\n-  } while (current != end);\n+  update_bot_for_block(start, start + range_size);", "source_url": "https://github.com/openjdk/riscv-port/commit/8301d9917ec9fed40e3af77998f88165e0837daf", "code_v0_no_empty_lines": "使用fill_with_objects逐个填充对象并循环更新BOT（Block Offset Table），每次迭代需要计算对象大小并调用update_bot_for_block，存在多次函数调用和循环开销。", "code_v1_no_empty_lines": "-  CollectedHeap::fill_with_objects(start, range_size, !has_pinned_objects());\n+  CollectedHeap::fill_with_object(start, range_size, !has_pinned_objects());\n-  HeapWord* current = start;\n-  do {\n-    // Update the BOT if the a threshold is crossed.\n-    size_t obj_size = cast_to_oop(current)->size();\n-    update_bot_for_block(current, current + obj_size);\n-\n-    // Advance to the next object.\n-    current += obj_size;\n-    guarantee(current <= end, \"Should never go past end\");\n-  } while (current != end);\n+  update_bot_for_block(start, start + range_size);", "target": "-  CollectedHeap::fill_with_objects(start, range_size, !has_pinned_objects());\n+  CollectedHeap::fill_with_object(start, range_size, !has_pinned_objects());\n-  HeapWord* current = start;\n-  do {\n-    // Update the BOT if the a threshold is crossed.\n-    size_t obj_size = cast_to_oop(current)->size();\n-    update_bot_for_block(current, current + obj_size);\n-\n-    // Advance to the next object.\n-    current += obj_size;\n-    guarantee(current <= end, \"Should never go past end\");\n-  } while (current != end);\n+  update_bot_for_block(start, start + range_size);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用fill_with_objects逐个填充对象并循环更新BOT（Block Offset Table），每次迭代需要计算对象大小并调用update_bot_for_block，存在多次函数调用和循环开销。优化后：改用更精确的fill_with_object API一次性填充整个范围，并直接调用update_bot_for_block更新整个范围的BOT，消除了循环和重复计算。优化思路：简化内存填充逻辑，减少不必要的循环和函数调用，提高GC期间内存区域填充的效率。"}
{"id": 121, "source": "riscv-dataset-excel", "optimization_type": "代码质量优化+内存语义优化", "optimization_description": "优化前：1. 使用ackRanges.get(0)和ackRanges.add(0, first)等索引访问方式，代码可读性较差；2. 在AckFrameSpliterator内部类中，largest、smallest、pn字段被声明为volatile，但实际使用场景不需要严格的可见性保证，存在不必要的内存屏障开销。优化后：1. 统一使用getFirst()和addFirst()等语义更清晰的API，提高代码可读性和维护性；2. 移除volatile修饰符，消除不必要的内存屏障，减少并发开销。优化思路：通过使用更合适的集合API和移除不必要的volatile修饰，在保持功能正确性的同时提升代码质量和运行时性能。", "original_code": "1. 使用ackRanges.get(0)和ackRanges.add(0, first)等索引访问方式，代码可读性较差；2. 在AckFrameSpliterator内部类中，largest、smallest、pn字段被声明为volatile，但实际使用场景不需要严格的可见性保证，存在不必要的内存屏障开销。", "optimized_code": "-        ackRanges.add(0, first);\n+        ackRanges.addFirst(first);\n-        if (ackRanges.size() < 1) {\n+        if (ackRanges.isEmpty()) {\n-        if (ackRanges.get(0).gap() != 0) {\n+        if (ackRanges.getFirst().gap() != 0) {\n-        encodeVLField(buffer, ackRanges.get(0).range(), \"firstAckRange\");\n+        encodeVLField(buffer, ackRanges.getFirst().range(), \"firstAckRange\");\n-        + getVLFieldLengthFor(ackRanges.get(0).range())\n+        + getVLFieldLengthFor(ackRanges.getFirst().range())\n-        private volatile long largest;\n-        private volatile long smallest;\n-        private volatile long pn;  // the current packet number\n+        private long largest;\n+        private long smallest;\n+        private long pn;  // the current packet number\n-        var firstAckRange = ackRanges.get(0);\n+        var firstAckRange = ackRanges.getFirst();\n-                ackRanges.add(0, AckRange.INITIAL); // acknowledge packetNumber only\n+                ackRanges.addFirst(AckRange.INITIAL); // acknowledge packetNumber only", "source_url": "https://github.com/openjdk/riscv-port/commit/d19e072f97681cfc50a8c7b96a25589070436a10", "code_v0_no_empty_lines": "1. 使用ackRanges.get(0)和ackRanges.add(0, first)等索引访问方式，代码可读性较差；2. 在AckFrameSpliterator内部类中，largest、smallest、pn字段被声明为volatile，但实际使用场景不需要严格的可见性保证，存在不必要的内存屏障开销。", "code_v1_no_empty_lines": "-        ackRanges.add(0, first);\n+        ackRanges.addFirst(first);\n-        if (ackRanges.size() < 1) {\n+        if (ackRanges.isEmpty()) {\n-        if (ackRanges.get(0).gap() != 0) {\n+        if (ackRanges.getFirst().gap() != 0) {\n-        encodeVLField(buffer, ackRanges.get(0).range(), \"firstAckRange\");\n+        encodeVLField(buffer, ackRanges.getFirst().range(), \"firstAckRange\");\n-        + getVLFieldLengthFor(ackRanges.get(0).range())\n+        + getVLFieldLengthFor(ackRanges.getFirst().range())\n-        private volatile long largest;\n-        private volatile long smallest;\n-        private volatile long pn;  // the current packet number\n+        private long largest;\n+        private long smallest;\n+        private long pn;  // the current packet number\n-        var firstAckRange = ackRanges.get(0);\n+        var firstAckRange = ackRanges.getFirst();\n-                ackRanges.add(0, AckRange.INITIAL); // acknowledge packetNumber only\n+                ackRanges.addFirst(AckRange.INITIAL); // acknowledge packetNumber only", "target": "-        ackRanges.add(0, first);\n+        ackRanges.addFirst(first);\n-        if (ackRanges.size() < 1) {\n+        if (ackRanges.isEmpty()) {\n-        if (ackRanges.get(0).gap() != 0) {\n+        if (ackRanges.getFirst().gap() != 0) {\n-        encodeVLField(buffer, ackRanges.get(0).range(), \"firstAckRange\");\n+        encodeVLField(buffer, ackRanges.getFirst().range(), \"firstAckRange\");\n-        + getVLFieldLengthFor(ackRanges.get(0).range())\n+        + getVLFieldLengthFor(ackRanges.getFirst().range())\n-        private volatile long largest;\n-        private volatile long smallest;\n-        private volatile long pn;  // the current packet number\n+        private long largest;\n+        private long smallest;\n+        private long pn;  // the current packet number\n-        var firstAckRange = ackRanges.get(0);\n+        var firstAckRange = ackRanges.getFirst();\n-                ackRanges.add(0, AckRange.INITIAL); // acknowledge packetNumber only\n+                ackRanges.addFirst(AckRange.INITIAL); // acknowledge packetNumber only", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 使用ackRanges.get(0)和ackRanges.add(0, first)等索引访问方式，代码可读性较差；2. 在AckFrameSpliterator内部类中，largest、smallest、pn字段被声明为volatile，但实际使用场景不需要严格的可见性保证，存在不必要的内存屏障开销。优化后：1. 统一使用getFirst()和addFirst()等语义更清晰的API，提高代码可读性和维护性；2. 移除volatile修饰符，消除不必要的内存屏障，减少并发开销。优化思路：通过使用更合适的集合API和移除不必要的volatile修饰，在保持功能正确性的同时提升代码质量和运行时性能。"}
{"id": 122, "source": "riscv-dataset-excel", "optimization_type": "代码重构+断言优化", "optimization_description": "优化前：1. MutableSpace::needs_expand()方法存在冗余，仅用于检查是否需要扩展老年代空间。2. 断言条件过于简单，未区分启动阶段和运行阶段的线程/锁状态。优化后：1. 移除needs_expand()方法，直接在调用处内联pointer_delta计算，减少函数调用开销。2. 细化断言条件，明确区分启动阶段（Java线程持有Heap_lock）和运行阶段（VM线程在安全点或GC工作线程持有PSOldGenExpand_lock），提高代码可维护性和调试能力。优化思路：通过内联简化调用链，同时增强断言以更精确地反映并发场景下的锁状态要求。", "original_code": "1. MutableSpace::needs_expand()方法存在冗余，仅用于检查是否需要扩展老年代空间。2. 断言条件过于简单，未区分启动阶段和运行阶段的线程/锁状态。", "optimized_code": "- bool MutableSpace::needs_expand(size_t word_size) const {\n  // This method can be invoked either outside of safepoint by java threads or\n  // in safepoint by gc workers. Such accesses are synchronized by holding one\n  // of the following locks.\n  assert(Heap_lock->is_locked() || PSOldGenExpand_lock->is_locked(), \"precondition\");\n\n  // Holding the lock means end is stable.  So while top may be advancing\n  // via concurrent allocations, there is no need to order the reads of top\n  // and end here, unlike in cas_allocate.\n  return pointer_delta(end(), top()) < word_size;\n}\n\n+  if (pointer_delta(object_space()->end(), object_space()->top()) < word_size) {\n+    expand(word_size*HeapWordSize);\n+  }\n\n+#ifdef ASSERT\n+  if (is_init_completed()) {\n+    assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+    assert(Thread::current()->is_VM_thread() || PSOldGenExpand_lock->owned_by_self(), \"precondition\");\n+  } else {\n+    assert(Heap_lock->owned_by_self() || PSOldGenExpand_lock->owned_by_self(), \"precondition\");\n+  }\n+#endif", "source_url": "https://github.com/openjdk/riscv-port/commit/09b25cd0a24a4eaddce49917d958adc667ab5465", "code_v0_no_empty_lines": "1. MutableSpace::needs_expand()方法存在冗余，仅用于检查是否需要扩展老年代空间。2. 断言条件过于简单，未区分启动阶段和运行阶段的线程/锁状态。", "code_v1_no_empty_lines": "- bool MutableSpace::needs_expand(size_t word_size) const {\n  // This method can be invoked either outside of safepoint by java threads or\n  // in safepoint by gc workers. Such accesses are synchronized by holding one\n  // of the following locks.\n  assert(Heap_lock->is_locked() || PSOldGenExpand_lock->is_locked(), \"precondition\");\n\n  // Holding the lock means end is stable.  So while top may be advancing\n  // via concurrent allocations, there is no need to order the reads of top\n  // and end here, unlike in cas_allocate.\n  return pointer_delta(end(), top()) < word_size;\n}\n\n+  if (pointer_delta(object_space()->end(), object_space()->top()) < word_size) {\n+    expand(word_size*HeapWordSize);\n+  }\n\n+#ifdef ASSERT\n+  if (is_init_completed()) {\n+    assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+    assert(Thread::current()->is_VM_thread() || PSOldGenExpand_lock->owned_by_self(), \"precondition\");\n+  } else {\n+    assert(Heap_lock->owned_by_self() || PSOldGenExpand_lock->owned_by_self(), \"precondition\");\n+  }\n+#endif", "target": "- bool MutableSpace::needs_expand(size_t word_size) const {\n  // This method can be invoked either outside of safepoint by java threads or\n  // in safepoint by gc workers. Such accesses are synchronized by holding one\n  // of the following locks.\n  assert(Heap_lock->is_locked() || PSOldGenExpand_lock->is_locked(), \"precondition\");\n\n  // Holding the lock means end is stable.  So while top may be advancing\n  // via concurrent allocations, there is no need to order the reads of top\n  // and end here, unlike in cas_allocate.\n  return pointer_delta(end(), top()) < word_size;\n}\n\n+  if (pointer_delta(object_space()->end(), object_space()->top()) < word_size) {\n+    expand(word_size*HeapWordSize);\n+  }\n\n+#ifdef ASSERT\n+  if (is_init_completed()) {\n+    assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+    assert(Thread::current()->is_VM_thread() || PSOldGenExpand_lock->owned_by_self(), \"precondition\");\n+  } else {\n+    assert(Heap_lock->owned_by_self() || PSOldGenExpand_lock->owned_by_self(), \"precondition\");\n+  }\n+#endif", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. MutableSpace::needs_expand()方法存在冗余，仅用于检查是否需要扩展老年代空间。2. 断言条件过于简单，未区分启动阶段和运行阶段的线程/锁状态。优化后：1. 移除needs_expand()方法，直接在调用处内联pointer_delta计算，减少函数调用开销。2. 细化断言条件，明确区分启动阶段（Java线程持有Heap_lock）和运行阶段（VM线程在安全点或GC工作线程持有PSOldGenExpand_lock），提高代码可维护性和调试能力。优化思路：通过内联简化调用链，同时增强断言以更精确地反映并发场景下的锁状态要求。"}
{"id": 123, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：non_young_occupancy_after_allocation()方法简单地将老年代和大对象区域数量乘以区域大小，忽略了保留的老年代区域中的空闲空间，导致非年轻代占用率计算不准确。优化后：新增free_bytes_in_retained_old_region()方法获取保留的老年代区域中的空闲字节数，并在计算占用率时减去这部分空闲空间，提高了内存占用计算的准确性。优化思路：通过更精确地计算实际占用的内存空间，避免因高估占用率而触发不必要的垃圾回收，从而提升G1垃圾收集器的性能。", "original_code": "non_young_occupancy_after_allocation()方法简单地将老年代和大对象区域数量乘以区域大小，忽略了保留的老年代区域中的空闲空间，导致非年轻代占用率计算不准确。", "optimized_code": "size_t G1CollectedHeap::non_young_occupancy_after_allocation(size_t allocation_word_size) {\n-  // For simplicity, just count whole regions.\n-  const size_t cur_occupancy = (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes;\n+  const size_t cur_occupancy = (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes -\n+                               _allocator->free_bytes_in_retained_old_region();", "source_url": "https://github.com/openjdk/riscv-port/commit/4cc655a2f445bb32ce555b80ac28610b26c51f4c", "code_v0_no_empty_lines": "non_young_occupancy_after_allocation()方法简单地将老年代和大对象区域数量乘以区域大小，忽略了保留的老年代区域中的空闲空间，导致非年轻代占用率计算不准确。", "code_v1_no_empty_lines": "size_t G1CollectedHeap::non_young_occupancy_after_allocation(size_t allocation_word_size) {\n-  // For simplicity, just count whole regions.\n-  const size_t cur_occupancy = (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes;\n+  const size_t cur_occupancy = (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes -\n+                               _allocator->free_bytes_in_retained_old_region();", "target": "size_t G1CollectedHeap::non_young_occupancy_after_allocation(size_t allocation_word_size) {\n-  // For simplicity, just count whole regions.\n-  const size_t cur_occupancy = (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes;\n+  const size_t cur_occupancy = (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes -\n+                               _allocator->free_bytes_in_retained_old_region();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：non_young_occupancy_after_allocation()方法简单地将老年代和大对象区域数量乘以区域大小，忽略了保留的老年代区域中的空闲空间，导致非年轻代占用率计算不准确。优化后：新增free_bytes_in_retained_old_region()方法获取保留的老年代区域中的空闲字节数，并在计算占用率时减去这部分空闲空间，提高了内存占用计算的准确性。优化思路：通过更精确地计算实际占用的内存空间，避免因高估占用率而触发不必要的垃圾回收，从而提升G1垃圾收集器的性能。"}
{"id": 124, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+平台适配优化", "optimization_description": "优化前：SHA3指令集内联函数仅在Apple Silicon处理器上默认启用，Qualcomm处理器无法利用硬件加速。优化后：扩展CPU检测逻辑，将Qualcomm处理器加入支持列表，修复CPU_QUALCOM拼写错误为CPU_QUALCOMM，使Qualcomm处理器能够自动启用SHA3指令集内联函数。优化思路：根据性能评估，在Qualcomm处理器上启用SHA3内联函数能获得性能提升，通过平台适配扩展硬件加速支持范围。", "original_code": "SHA3指令集内联函数仅在Apple Silicon处理器上默认启用，Qualcomm处理器无法利用硬件加速。", "optimized_code": "if (_cpu == CPU_APPLE) {  // Apple silicon\n+if (_cpu == CPU_APPLE || _cpu == CPU_QUALCOMM) {  // Apple or Qualcomm silicon\n@@ -106,7 +106,7 @@ class VM_Version : public Abstract_VM_Version {\n     CPU_MOTOROLA  = 'M',\n     CPU_NVIDIA    = 'N',\n     CPU_AMCC      = 'P',\n-    CPU_QUALCOM   = 'Q',\n+    CPU_QUALCOMM  = 'Q',\n     CPU_MARVELL   = 'V',\n     CPU_INTEL     = 'i',\n     CPU_APPLE     = 'a',\n@@ -84,6 +84,8 @@ void VM_Version::get_os_cpu_info() {\n       _cpu = CPU_AMCC;\n     } else if (buf && strstr(buf, \"Cavium Inc.\") != nullptr) {\n       _cpu = CPU_CAVIUM;\n+    } else if (buf && strstr(buf, \"Qualcomm Technologies Inc\") != nullptr) {\n+      _cpu = CPU_QUALCOMM;\n     } else {\n       log_info(os)(\"VM_Version: unknown CPU model\");\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/00f2c38e373f5ae58ad6593cc7b9d53b9596eb17", "code_v0_no_empty_lines": "SHA3指令集内联函数仅在Apple Silicon处理器上默认启用，Qualcomm处理器无法利用硬件加速。", "code_v1_no_empty_lines": "if (_cpu == CPU_APPLE) {  // Apple silicon\n+if (_cpu == CPU_APPLE || _cpu == CPU_QUALCOMM) {  // Apple or Qualcomm silicon\n@@ -106,7 +106,7 @@ class VM_Version : public Abstract_VM_Version {\n     CPU_MOTOROLA  = 'M',\n     CPU_NVIDIA    = 'N',\n     CPU_AMCC      = 'P',\n-    CPU_QUALCOM   = 'Q',\n+    CPU_QUALCOMM  = 'Q',\n     CPU_MARVELL   = 'V',\n     CPU_INTEL     = 'i',\n     CPU_APPLE     = 'a',\n@@ -84,6 +84,8 @@ void VM_Version::get_os_cpu_info() {\n       _cpu = CPU_AMCC;\n     } else if (buf && strstr(buf, \"Cavium Inc.\") != nullptr) {\n       _cpu = CPU_CAVIUM;\n+    } else if (buf && strstr(buf, \"Qualcomm Technologies Inc\") != nullptr) {\n+      _cpu = CPU_QUALCOMM;\n     } else {\n       log_info(os)(\"VM_Version: unknown CPU model\");\n     }", "target": "if (_cpu == CPU_APPLE) {  // Apple silicon\n+if (_cpu == CPU_APPLE || _cpu == CPU_QUALCOMM) {  // Apple or Qualcomm silicon\n@@ -106,7 +106,7 @@ class VM_Version : public Abstract_VM_Version {\n     CPU_MOTOROLA  = 'M',\n     CPU_NVIDIA    = 'N',\n     CPU_AMCC      = 'P',\n-    CPU_QUALCOM   = 'Q',\n+    CPU_QUALCOMM  = 'Q',\n     CPU_MARVELL   = 'V',\n     CPU_INTEL     = 'i',\n     CPU_APPLE     = 'a',\n@@ -84,6 +84,8 @@ void VM_Version::get_os_cpu_info() {\n       _cpu = CPU_AMCC;\n     } else if (buf && strstr(buf, \"Cavium Inc.\") != nullptr) {\n       _cpu = CPU_CAVIUM;\n+    } else if (buf && strstr(buf, \"Qualcomm Technologies Inc\") != nullptr) {\n+      _cpu = CPU_QUALCOMM;\n     } else {\n       log_info(os)(\"VM_Version: unknown CPU model\");\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SHA3指令集内联函数仅在Apple Silicon处理器上默认启用，Qualcomm处理器无法利用硬件加速。优化后：扩展CPU检测逻辑，将Qualcomm处理器加入支持列表，修复CPU_QUALCOM拼写错误为CPU_QUALCOMM，使Qualcomm处理器能够自动启用SHA3指令集内联函数。优化思路：根据性能评估，在Qualcomm处理器上启用SHA3内联函数能获得性能提升，通过平台适配扩展硬件加速支持范围。"}
{"id": 125, "source": "riscv-dataset-excel", "optimization_type": "垃圾收集器算法优化", "optimization_description": "优化前：IHOP（Initiating Heap Occupancy Percentage）计算中，年轻代分配被错误计入非年轻代占用率，导致IHOP阈值判断不准确，可能过早或过晚触发混合GC。\n优化后：新增non_young_occupancy_after_allocation()方法，在计算非年轻代占用率时，只考虑巨型对象分配（这些对象直接分配到非年轻代），忽略普通年轻代分配。\n优化思路：修正IHOP控制逻辑，确保只有真正影响非年轻代空间的分配才被计入占用率计算，避免年轻代分配干扰GC触发时机，提高GC效率和堆空间利用率。", "original_code": "IHOP（Initiating Heap Occupancy Percentage）计算中，年轻代分配被错误计入非年轻代占用率，导致IHOP阈值判断不准确，可能过早或过晚触发混合GC。", "optimized_code": "size_t G1CollectedHeap::non_young_occupancy_after_allocation(size_t allocation_word_size) {\n  // For simplicity, just count whole regions.\n  const size_t cur_occupancy = (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes;\n  // Humongous allocations will always be assigned to non-young heap, so consider\n  // that allocation in the result as well. Otherwise the allocation will always\n  // be in young gen, so there is no need to account it here.\n  return cur_occupancy + (is_humongous(allocation_word_size) ? allocation_used_bytes(allocation_word_size) : 0);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/7d78818ae609461ab830c32c222f15f1cab0d2d4", "code_v0_no_empty_lines": "IHOP（Initiating Heap Occupancy Percentage）计算中，年轻代分配被错误计入非年轻代占用率，导致IHOP阈值判断不准确，可能过早或过晚触发混合GC。", "code_v1_no_empty_lines": "size_t G1CollectedHeap::non_young_occupancy_after_allocation(size_t allocation_word_size) {\n  // For simplicity, just count whole regions.\n  const size_t cur_occupancy = (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes;\n  // Humongous allocations will always be assigned to non-young heap, so consider\n  // that allocation in the result as well. Otherwise the allocation will always\n  // be in young gen, so there is no need to account it here.\n  return cur_occupancy + (is_humongous(allocation_word_size) ? allocation_used_bytes(allocation_word_size) : 0);\n}", "target": "size_t G1CollectedHeap::non_young_occupancy_after_allocation(size_t allocation_word_size) {\n  // For simplicity, just count whole regions.\n  const size_t cur_occupancy = (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes;\n  // Humongous allocations will always be assigned to non-young heap, so consider\n  // that allocation in the result as well. Otherwise the allocation will always\n  // be in young gen, so there is no need to account it here.\n  return cur_occupancy + (is_humongous(allocation_word_size) ? allocation_used_bytes(allocation_word_size) : 0);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：IHOP（Initiating Heap Occupancy Percentage）计算中，年轻代分配被错误计入非年轻代占用率，导致IHOP阈值判断不准确，可能过早或过晚触发混合GC。\n优化后：新增non_young_occupancy_after_allocation()方法，在计算非年轻代占用率时，只考虑巨型对象分配（这些对象直接分配到非年轻代），忽略普通年轻代分配。\n优化思路：修正IHOP控制逻辑，确保只有真正影响非年轻代空间的分配才被计入占用率计算，避免年轻代分配干扰GC触发时机，提高GC效率和堆空间利用率。"}
{"id": 126, "source": "riscv-dataset-excel", "optimization_type": "算法优化+内存优化", "optimization_description": "优化前：genInvRoundKeys方法使用临时数组temp进行中间计算，需要多次System.arraycopy调用和数组填充操作，存在额外内存分配和复制开销。优化后：直接计算并赋值到目标数组dw中，消除了临时数组temp，减少了内存分配和复制操作。优化思路：通过内联计算和直接数组访问，避免不必要的中间存储，提高AES密钥生成性能，同时简化代码逻辑。", "original_code": "genInvRoundKeys方法使用临时数组temp进行中间计算，需要多次System.arraycopy调用和数组填充操作，存在额外内存分配和复制开销。", "optimized_code": "-        int kLen = w.length;;\n-        int[] temp = new int[WB];\n-        int[] dw = new int[kLen];\n+        int[] dw = new int[w.length];\n \n         // Intrinsics requires the inverse key expansion to be reverse order\n         // except for the first and last round key as the first two round keys\n         // are without a mix column transform.\n         for (int i = 1; i < rounds; i++) {\n-            System.arraycopy(w, i * WB, temp, 0, WB);\n-            temp[0] = TMI0[temp[0] >>> 24] ^ TMI1[(temp[0] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[0] >> 8) & 0xFF] ^ TMI3[temp[0] & 0xFF];\n-            temp[1] = TMI0[temp[1] >>> 24] ^ TMI1[(temp[1] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[1] >> 8) & 0xFF] ^ TMI3[temp[1] & 0xFF];\n-            temp[2] = TMI0[temp[2] >>> 24] ^ TMI1[(temp[2] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[2] >> 8) & 0xFF] ^ TMI3[temp[2] & 0xFF];\n-            temp[3] = TMI0[temp[3] >>> 24] ^ TMI1[(temp[3] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[3] >> 8) & 0xFF] ^ TMI3[temp[3] & 0xFF];\n-            System.arraycopy(temp, 0, dw, kLen - (i * WB), WB);\n+            int widx = i * WB;\n+            int idx = w.length - widx;\n+\n+            dw[idx] = TMI0[w[widx] >>> 24] ^ TMI1[(w[widx] >> 16) & 0xFF]\n+                    ^ TMI2[(w[widx] >> 8) & 0xFF] ^ TMI3[w[widx] & 0xFF];\n+            dw[idx + 1] = TMI0[w[widx + 1] >>> 24]\n+                    ^ TMI1[(w[widx + 1] >> 16) & 0xFF]\n+                    ^ TMI2[(w[widx + 1] >> 8) & 0xFF]\n+                    ^ TMI3[w[widx + 1] & 0xFF];\n+            dw[idx + 2] = TMI0[w[widx + 2] >>> 24]\n+                    ^ TMI1[(w[widx + 2] >> 16) & 0xFF]\n+                    ^ TMI2[(w[widx + 2] >> 8) & 0xFF]\n+                    ^ TMI3[w[widx + 2] & 0xFF];\n+            dw[idx + 3] = TMI0[w[widx + 3] >>> 24]\n+                    ^ TMI1[(w[widx + 3] >> 16) & 0xFF]\n+                    ^ TMI2[(w[widx + 3] >> 8) & 0xFF]\n+                    ^ TMI3[w[widx + 3] & 0xFF];\n         }\n-        System.arraycopy(w, kLen - WB, dw, WB, WB);\n+        System.arraycopy(w, w.length - WB, dw, WB, WB);\n         System.arraycopy(w, 0, dw, 0, WB);\n-        Arrays.fill(temp, 0);", "source_url": "https://github.com/openjdk/riscv-port/commit/436b3357e9791f6acb2673e2ac96d33c6a2782e6", "code_v0_no_empty_lines": "genInvRoundKeys方法使用临时数组temp进行中间计算，需要多次System.arraycopy调用和数组填充操作，存在额外内存分配和复制开销。", "code_v1_no_empty_lines": "-        int kLen = w.length;;\n-        int[] temp = new int[WB];\n-        int[] dw = new int[kLen];\n+        int[] dw = new int[w.length];\n \n         // Intrinsics requires the inverse key expansion to be reverse order\n         // except for the first and last round key as the first two round keys\n         // are without a mix column transform.\n         for (int i = 1; i < rounds; i++) {\n-            System.arraycopy(w, i * WB, temp, 0, WB);\n-            temp[0] = TMI0[temp[0] >>> 24] ^ TMI1[(temp[0] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[0] >> 8) & 0xFF] ^ TMI3[temp[0] & 0xFF];\n-            temp[1] = TMI0[temp[1] >>> 24] ^ TMI1[(temp[1] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[1] >> 8) & 0xFF] ^ TMI3[temp[1] & 0xFF];\n-            temp[2] = TMI0[temp[2] >>> 24] ^ TMI1[(temp[2] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[2] >> 8) & 0xFF] ^ TMI3[temp[2] & 0xFF];\n-            temp[3] = TMI0[temp[3] >>> 24] ^ TMI1[(temp[3] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[3] >> 8) & 0xFF] ^ TMI3[temp[3] & 0xFF];\n-            System.arraycopy(temp, 0, dw, kLen - (i * WB), WB);\n+            int widx = i * WB;\n+            int idx = w.length - widx;\n+\n+            dw[idx] = TMI0[w[widx] >>> 24] ^ TMI1[(w[widx] >> 16) & 0xFF]\n+                    ^ TMI2[(w[widx] >> 8) & 0xFF] ^ TMI3[w[widx] & 0xFF];\n+            dw[idx + 1] = TMI0[w[widx + 1] >>> 24]\n+                    ^ TMI1[(w[widx + 1] >> 16) & 0xFF]\n+                    ^ TMI2[(w[widx + 1] >> 8) & 0xFF]\n+                    ^ TMI3[w[widx + 1] & 0xFF];\n+            dw[idx + 2] = TMI0[w[widx + 2] >>> 24]\n+                    ^ TMI1[(w[widx + 2] >> 16) & 0xFF]\n+                    ^ TMI2[(w[widx + 2] >> 8) & 0xFF]\n+                    ^ TMI3[w[widx + 2] & 0xFF];\n+            dw[idx + 3] = TMI0[w[widx + 3] >>> 24]\n+                    ^ TMI1[(w[widx + 3] >> 16) & 0xFF]\n+                    ^ TMI2[(w[widx + 3] >> 8) & 0xFF]\n+                    ^ TMI3[w[widx + 3] & 0xFF];\n         }\n-        System.arraycopy(w, kLen - WB, dw, WB, WB);\n+        System.arraycopy(w, w.length - WB, dw, WB, WB);\n         System.arraycopy(w, 0, dw, 0, WB);\n-        Arrays.fill(temp, 0);", "target": "-        int kLen = w.length;;\n-        int[] temp = new int[WB];\n-        int[] dw = new int[kLen];\n+        int[] dw = new int[w.length];\n \n         // Intrinsics requires the inverse key expansion to be reverse order\n         // except for the first and last round key as the first two round keys\n         // are without a mix column transform.\n         for (int i = 1; i < rounds; i++) {\n-            System.arraycopy(w, i * WB, temp, 0, WB);\n-            temp[0] = TMI0[temp[0] >>> 24] ^ TMI1[(temp[0] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[0] >> 8) & 0xFF] ^ TMI3[temp[0] & 0xFF];\n-            temp[1] = TMI0[temp[1] >>> 24] ^ TMI1[(temp[1] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[1] >> 8) & 0xFF] ^ TMI3[temp[1] & 0xFF];\n-            temp[2] = TMI0[temp[2] >>> 24] ^ TMI1[(temp[2] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[2] >> 8) & 0xFF] ^ TMI3[temp[2] & 0xFF];\n-            temp[3] = TMI0[temp[3] >>> 24] ^ TMI1[(temp[3] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[3] >> 8) & 0xFF] ^ TMI3[temp[3] & 0xFF];\n-            System.arraycopy(temp, 0, dw, kLen - (i * WB), WB);\n+            int widx = i * WB;\n+            int idx = w.length - widx;\n+\n+            dw[idx] = TMI0[w[widx] >>> 24] ^ TMI1[(w[widx] >> 16) & 0xFF]\n+                    ^ TMI2[(w[widx] >> 8) & 0xFF] ^ TMI3[w[widx] & 0xFF];\n+            dw[idx + 1] = TMI0[w[widx + 1] >>> 24]\n+                    ^ TMI1[(w[widx + 1] >> 16) & 0xFF]\n+                    ^ TMI2[(w[widx + 1] >> 8) & 0xFF]\n+                    ^ TMI3[w[widx + 1] & 0xFF];\n+            dw[idx + 2] = TMI0[w[widx + 2] >>> 24]\n+                    ^ TMI1[(w[widx + 2] >> 16) & 0xFF]\n+                    ^ TMI2[(w[widx + 2] >> 8) & 0xFF]\n+                    ^ TMI3[w[widx + 2] & 0xFF];\n+            dw[idx + 3] = TMI0[w[widx + 3] >>> 24]\n+                    ^ TMI1[(w[widx + 3] >> 16) & 0xFF]\n+                    ^ TMI2[(w[widx + 3] >> 8) & 0xFF]\n+                    ^ TMI3[w[widx + 3] & 0xFF];\n         }\n-        System.arraycopy(w, kLen - WB, dw, WB, WB);\n+        System.arraycopy(w, w.length - WB, dw, WB, WB);\n         System.arraycopy(w, 0, dw, 0, WB);\n-        Arrays.fill(temp, 0);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：genInvRoundKeys方法使用临时数组temp进行中间计算，需要多次System.arraycopy调用和数组填充操作，存在额外内存分配和复制开销。优化后：直接计算并赋值到目标数组dw中，消除了临时数组temp，减少了内存分配和复制操作。优化思路：通过内联计算和直接数组访问，避免不必要的中间存储，提高AES密钥生成性能，同时简化代码逻辑。"}
{"id": 127, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+指令集优化", "optimization_description": "优化前：VectorMask.fromLong/toLong()操作在SVE架构下使用谓词寄存器(pReg)和多个临时向量寄存器，缺乏原生SVE谓词指令支持，性能较低。优化后：1) 添加mask_op_prefers_predicate()函数，为VectorMaskToLong和VectorLongToMask操作返回false，使其使用向量寄存器(vReg)而非谓词寄存器；2) 根据CPU是否支持SVE位排列指令(svebitperm)，提供两种优化实现：支持时使用sve2_vmask_tolong()减少临时寄存器数量，不支持时使用sve_vmask_tolong()；3) 统一将VectorLongToMask操作改为使用向量寄存器。优化思路：针对SVE架构缺乏原生谓词指令的问题，改用向量寄存器存储掩码，利用现有向量指令实现转换，减少寄存器使用和转换开销，提升性能。", "original_code": "VectorMask.fromLong/toLong()操作在SVE架构下使用谓词寄存器(pReg)和多个临时向量寄存器，缺乏原生SVE谓词指令支持，性能较低。", "optimized_code": "instruct vmask_tolong_sve(iRegLNoSp dst, pReg src, vReg tmp1, vReg tmp2) %{\n  predicate(UseSVE > 0);\n  match(Set dst (VectorMaskToLong src));\n  effect(TEMP tmp1, TEMP tmp2);\n  format %{ \"vmask_tolong_sve $dst, $src\\t# KILL $tmp1, $tmp2\" %}", "source_url": "https://github.com/openjdk/riscv-port/commit/676e6fd8d5152f4e0d14ae59ddd7aa0a7127ea58", "code_v0_no_empty_lines": "VectorMask.fromLong/toLong()操作在SVE架构下使用谓词寄存器(pReg)和多个临时向量寄存器，缺乏原生SVE谓词指令支持，性能较低。", "code_v1_no_empty_lines": "instruct vmask_tolong_sve(iRegLNoSp dst, pReg src, vReg tmp1, vReg tmp2) %{\n  predicate(UseSVE > 0);\n  match(Set dst (VectorMaskToLong src));\n  effect(TEMP tmp1, TEMP tmp2);\n  format %{ \"vmask_tolong_sve $dst, $src\\t# KILL $tmp1, $tmp2\" %}", "target": "instruct vmask_tolong_sve(iRegLNoSp dst, pReg src, vReg tmp1, vReg tmp2) %{\n  predicate(UseSVE > 0);\n  match(Set dst (VectorMaskToLong src));\n  effect(TEMP tmp1, TEMP tmp2);\n  format %{ \"vmask_tolong_sve $dst, $src\\t# KILL $tmp1, $tmp2\" %}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：VectorMask.fromLong/toLong()操作在SVE架构下使用谓词寄存器(pReg)和多个临时向量寄存器，缺乏原生SVE谓词指令支持，性能较低。优化后：1) 添加mask_op_prefers_predicate()函数，为VectorMaskToLong和VectorLongToMask操作返回false，使其使用向量寄存器(vReg)而非谓词寄存器；2) 根据CPU是否支持SVE位排列指令(svebitperm)，提供两种优化实现：支持时使用sve2_vmask_tolong()减少临时寄存器数量，不支持时使用sve_vmask_tolong()；3) 统一将VectorLongToMask操作改为使用向量寄存器。优化思路：针对SVE架构缺乏原生谓词指令的问题，改用向量寄存器存储掩码，利用现有向量指令实现转换，减少寄存器使用和转换开销，提升性能。"}
{"id": 128, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "减少数据依赖：​ 原始模式(x & mask) >> shift中，>>操作必须等待&操作完成，存在数据依赖\n增加指令级并行：​ 转换后的模式(x >> shift) & (mask >> shift)中，x >> shift和mask >> shift可以并行计算\n常量传播机会：​ 如果mask和shift是常量，mask >> shift可以在编译时计算，减少运行时计算", "original_code": "// No original code extracted from description\n", "optimized_code": "// 修改前：只检查有符号右移\n- if (u->Opcode() == Op_RShiftI || u->Opcode() == Op_RShiftL) {\n\n// 修改后：同时检查有符号和无符号右移\n+ if (u->Opcode() == Op_RShiftI || u->Opcode() == Op_RShiftL ||\n+     u->Opcode() == Op_URShiftI || u->Opcode() == Op_URShiftL) {\n    worklist.push(u);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/f5eacbeb5fc58c1bd844d709fe92621ce3689d78", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 修改前：只检查有符号右移\n- if (u->Opcode() == Op_RShiftI || u->Opcode() == Op_RShiftL) {\n\n// 修改后：同时检查有符号和无符号右移\n+ if (u->Opcode() == Op_RShiftI || u->Opcode() == Op_RShiftL ||\n+     u->Opcode() == Op_URShiftI || u->Opcode() == Op_URShiftL) {\n    worklist.push(u);\n}", "target": "// 修改前：只检查有符号右移\n- if (u->Opcode() == Op_RShiftI || u->Opcode() == Op_RShiftL) {\n\n// 修改后：同时检查有符号和无符号右移\n+ if (u->Opcode() == Op_RShiftI || u->Opcode() == Op_RShiftL ||\n+     u->Opcode() == Op_URShiftI || u->Opcode() == Op_URShiftL) {\n    worklist.push(u);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "减少数据依赖：​ 原始模式(x & mask) >> shift中，>>操作必须等待&操作完成，存在数据依赖\n增加指令级并行：​ 转换后的模式(x >> shift) & (mask >> shift)中，x >> shift和mask >> shift可以并行计算\n常量传播机会：​ 如果mask和shift是常量，mask >> shift可以在编译时计算，减少运行时计算"}
{"id": 129, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+启动性能优化", "optimization_description": "优化前：在JVM启动初始化阶段，当年轻代区域已满时，mutator线程无法分配新区域，导致分配失败或等待GC。优化后：在初始化完成前，允许通过堆扩展来分配新的mutator区域，避免分配阻塞。优化思路：在启动阶段GC不可用时，通过堆扩展支持内存分配，提升启动性能和稳定性。", "original_code": "在JVM启动初始化阶段，当年轻代区域已满时，mutator线程无法分配新区域，导致分配失败或等待GC。", "optimized_code": "diff --git a/src/hotspot/share/gc/g1/g1Policy.cpp b/src/hotspot/share/gc/g1/g1Policy.cpp\nindex fe754020e0c..ddcdfb0c3a4 100644\n--- a/src/hotspot/share/gc/g1/g1Policy.cpp\n+++ b/src/hotspot/share/gc/g1/g1Policy.cpp\n@@ -1187,8 +1187,21 @@ double G1Policy::predict_region_code_root_scan_time(G1HeapRegion* hr, bool for_y\n }\n \n bool G1Policy::should_allocate_mutator_region() const {\n-  uint young_list_length = _g1h->young_regions_count();\n-  return young_list_length < young_list_target_length();\n+  if (_g1h->young_regions_count() < young_list_target_length()) {\n+    return true;\n+  }\n+\n+  if (should_expand_on_mutator_allocation()) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool G1Policy::should_expand_on_mutator_allocation() const {\n+  // We can't do a GC during init so allow additional mutator\n+  // allocations until we can GC.\n+  return !is_init_completed();\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/2902436fb15c76755286ed2df444bc6f9d93af13", "code_v0_no_empty_lines": "在JVM启动初始化阶段，当年轻代区域已满时，mutator线程无法分配新区域，导致分配失败或等待GC。", "code_v1_no_empty_lines": "diff --git a/src/hotspot/share/gc/g1/g1Policy.cpp b/src/hotspot/share/gc/g1/g1Policy.cpp\nindex fe754020e0c..ddcdfb0c3a4 100644\n--- a/src/hotspot/share/gc/g1/g1Policy.cpp\n+++ b/src/hotspot/share/gc/g1/g1Policy.cpp\n@@ -1187,8 +1187,21 @@ double G1Policy::predict_region_code_root_scan_time(G1HeapRegion* hr, bool for_y\n }\n \n bool G1Policy::should_allocate_mutator_region() const {\n-  uint young_list_length = _g1h->young_regions_count();\n-  return young_list_length < young_list_target_length();\n+  if (_g1h->young_regions_count() < young_list_target_length()) {\n+    return true;\n+  }\n+\n+  if (should_expand_on_mutator_allocation()) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool G1Policy::should_expand_on_mutator_allocation() const {\n+  // We can't do a GC during init so allow additional mutator\n+  // allocations until we can GC.\n+  return !is_init_completed();\n }", "target": "diff --git a/src/hotspot/share/gc/g1/g1Policy.cpp b/src/hotspot/share/gc/g1/g1Policy.cpp\nindex fe754020e0c..ddcdfb0c3a4 100644\n--- a/src/hotspot/share/gc/g1/g1Policy.cpp\n+++ b/src/hotspot/share/gc/g1/g1Policy.cpp\n@@ -1187,8 +1187,21 @@ double G1Policy::predict_region_code_root_scan_time(G1HeapRegion* hr, bool for_y\n }\n \n bool G1Policy::should_allocate_mutator_region() const {\n-  uint young_list_length = _g1h->young_regions_count();\n-  return young_list_length < young_list_target_length();\n+  if (_g1h->young_regions_count() < young_list_target_length()) {\n+    return true;\n+  }\n+\n+  if (should_expand_on_mutator_allocation()) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool G1Policy::should_expand_on_mutator_allocation() const {\n+  // We can't do a GC during init so allow additional mutator\n+  // allocations until we can GC.\n+  return !is_init_completed();\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在JVM启动初始化阶段，当年轻代区域已满时，mutator线程无法分配新区域，导致分配失败或等待GC。优化后：在初始化完成前，允许通过堆扩展来分配新的mutator区域，避免分配阻塞。优化思路：在启动阶段GC不可用时，通过堆扩展支持内存分配，提升启动性能和稳定性。"}
{"id": 130, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：SuperWord向量化阶段缺乏成本模型，仅通过简单的启发式规则（如统计归约操作数量）判断向量化是否有利可图，可能导致不准确的向量化决策。优化后：实现了成本模型（cost model），通过profitable函数精确评估每个向量化包（pack）的性能收益，移除不盈利的向量化包，并更新了AArch64后端对特定向量操作（如Op_MulVL、浮点归约操作）在NEON上的支持判断逻辑，添加了详细的注释说明。优化思路：引入系统化的成本分析机制，替代简单的启发式规则，确保向量化仅在能带来实际性能提升时执行，提高编译优化的准确性。", "original_code": "SuperWord向量化阶段缺乏成本模型，仅通过简单的启发式规则（如统计归约操作数量）判断向量化是否有利可图，可能导致不准确的向量化决策。", "optimized_code": "-  _num_work_vecs(0),                                        // amount of vector work we have\n-  _num_reductions(0)                                        // amount of reduction work we have\n+  // Remove packs that are not profitable\n+  auto filter = [&](const Node_List* pack) {\n+    return profitable(pack);\n+  };", "source_url": "https://github.com/openjdk/riscv-port/commit/72989e0fac7dae1bfec40e3017ba89aa201cc8ee", "code_v0_no_empty_lines": "SuperWord向量化阶段缺乏成本模型，仅通过简单的启发式规则（如统计归约操作数量）判断向量化是否有利可图，可能导致不准确的向量化决策。", "code_v1_no_empty_lines": "-  _num_work_vecs(0),                                        // amount of vector work we have\n-  _num_reductions(0)                                        // amount of reduction work we have\n+  // Remove packs that are not profitable\n+  auto filter = [&](const Node_List* pack) {\n+    return profitable(pack);\n+  };", "target": "-  _num_work_vecs(0),                                        // amount of vector work we have\n-  _num_reductions(0)                                        // amount of reduction work we have\n+  // Remove packs that are not profitable\n+  auto filter = [&](const Node_List* pack) {\n+    return profitable(pack);\n+  };", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SuperWord向量化阶段缺乏成本模型，仅通过简单的启发式规则（如统计归约操作数量）判断向量化是否有利可图，可能导致不准确的向量化决策。优化后：实现了成本模型（cost model），通过profitable函数精确评估每个向量化包（pack）的性能收益，移除不盈利的向量化包，并更新了AArch64后端对特定向量操作（如Op_MulVL、浮点归约操作）在NEON上的支持判断逻辑，添加了详细的注释说明。优化思路：引入系统化的成本分析机制，替代简单的启发式规则，确保向量化仅在能带来实际性能提升时执行，提高编译优化的准确性。"}
{"id": 132, "source": "riscv-dataset-excel", "optimization_type": "编译器优化-冗余转换消除", "optimization_description": "优化前：在add_users_of_use_to_worklist函数中，检测冗余转换模式（如ConvI2F->ConvF2I->ConvI2F）的条件过于严格，要求n和use的Opcode必须严格匹配特定转换对，这导致某些优化机会被错过。优化后：放宽检测条件，首先检查use的Opcode是否为四种目标转换操作之一，然后在use的用户中查找对应的反向转换操作，从而更全面地识别可优化的转换链。优化思路：通过更灵活的匹配逻辑，让编译器能够检测并消除更多冗余的类型转换序列，减少不必要的计算开销，提高代码执行效率。", "original_code": "在add_users_of_use_to_worklist函数中，检测冗余转换模式（如ConvI2F->ConvF2I->ConvI2F）的条件过于严格，要求n和use的Opcode必须严格匹配特定转换对，这导致某些优化机会被错过。", "optimized_code": "-  if ((n->Opcode() == Op_ConvD2L && use_op == Op_ConvL2D) ||\n-      (n->Opcode() == Op_ConvF2I && use_op == Op_ConvI2F) ||\n-      (n->Opcode() == Op_ConvF2L && use_op == Op_ConvL2F) ||\n-      (n->Opcode() == Op_ConvI2F && use_op == Op_ConvF2I)) {\n+  if (use_op == Op_ConvL2D ||\n+      use_op == Op_ConvI2F ||\n+      use_op == Op_ConvL2F ||\n+      use_op == Op_ConvF2I) {\n     for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n       Node* u = use->fast_out(i2);\n-      if (u->Opcode() == n->Opcode()) {\n+      if ((use_op == Op_ConvL2D && u->Opcode() == Op_ConvD2L) ||\n+          (use_op == Op_ConvI2F && u->Opcode() == Op_ConvF2I) ||\n+          (use_op == Op_ConvL2F && u->Opcode() == Op_ConvF2L) ||\n+          (use_op == Op_ConvF2I && u->Opcode() == Op_ConvI2F)) {", "source_url": "https://github.com/openjdk/riscv-port/commit/5e8bf7a283f75464dbd906454c852e4d1db497dc", "code_v0_no_empty_lines": "在add_users_of_use_to_worklist函数中，检测冗余转换模式（如ConvI2F->ConvF2I->ConvI2F）的条件过于严格，要求n和use的Opcode必须严格匹配特定转换对，这导致某些优化机会被错过。", "code_v1_no_empty_lines": "-  if ((n->Opcode() == Op_ConvD2L && use_op == Op_ConvL2D) ||\n-      (n->Opcode() == Op_ConvF2I && use_op == Op_ConvI2F) ||\n-      (n->Opcode() == Op_ConvF2L && use_op == Op_ConvL2F) ||\n-      (n->Opcode() == Op_ConvI2F && use_op == Op_ConvF2I)) {\n+  if (use_op == Op_ConvL2D ||\n+      use_op == Op_ConvI2F ||\n+      use_op == Op_ConvL2F ||\n+      use_op == Op_ConvF2I) {\n     for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n       Node* u = use->fast_out(i2);\n-      if (u->Opcode() == n->Opcode()) {\n+      if ((use_op == Op_ConvL2D && u->Opcode() == Op_ConvD2L) ||\n+          (use_op == Op_ConvI2F && u->Opcode() == Op_ConvF2I) ||\n+          (use_op == Op_ConvL2F && u->Opcode() == Op_ConvF2L) ||\n+          (use_op == Op_ConvF2I && u->Opcode() == Op_ConvI2F)) {", "target": "-  if ((n->Opcode() == Op_ConvD2L && use_op == Op_ConvL2D) ||\n-      (n->Opcode() == Op_ConvF2I && use_op == Op_ConvI2F) ||\n-      (n->Opcode() == Op_ConvF2L && use_op == Op_ConvL2F) ||\n-      (n->Opcode() == Op_ConvI2F && use_op == Op_ConvF2I)) {\n+  if (use_op == Op_ConvL2D ||\n+      use_op == Op_ConvI2F ||\n+      use_op == Op_ConvL2F ||\n+      use_op == Op_ConvF2I) {\n     for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n       Node* u = use->fast_out(i2);\n-      if (u->Opcode() == n->Opcode()) {\n+      if ((use_op == Op_ConvL2D && u->Opcode() == Op_ConvD2L) ||\n+          (use_op == Op_ConvI2F && u->Opcode() == Op_ConvF2I) ||\n+          (use_op == Op_ConvL2F && u->Opcode() == Op_ConvF2L) ||\n+          (use_op == Op_ConvF2I && u->Opcode() == Op_ConvI2F)) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在add_users_of_use_to_worklist函数中，检测冗余转换模式（如ConvI2F->ConvF2I->ConvI2F）的条件过于严格，要求n和use的Opcode必须严格匹配特定转换对，这导致某些优化机会被错过。优化后：放宽检测条件，首先检查use的Opcode是否为四种目标转换操作之一，然后在use的用户中查找对应的反向转换操作，从而更全面地识别可优化的转换链。优化思路：通过更灵活的匹配逻辑，让编译器能够检测并消除更多冗余的类型转换序列，减少不必要的计算开销，提高代码执行效率。"}
{"id": 133, "source": "riscv-dataset-excel", "optimization_type": "启动性能优化+内存优化", "optimization_description": "优化前：Java应用启动时需要重新构建堆对象，增加启动时间和内存开销。优化后：实现JEP 516 Ahead-of-Time Object Caching，新增AOT堆映射和流式堆加载器，支持任何GC算法下预缓存堆对象。思路：通过预编译时缓存堆对象到CDS存档，运行时直接映射或流式加载，减少启动时的对象分配和初始化开销，提升应用启动性能。", "original_code": "Java应用启动时需要重新构建堆对象，增加启动时间和内存开销。", "optimized_code": "create mode 100644 src/hotspot/share/cds/aotMappedHeapLoader.cpp\ncreate mode 100644 src/hotspot/share/cds/aotStreamedHeapLoader.cpp\ncreate mode 100644 src/hotspot/share/cds/aotStreamedHeapWriter.cpp\ndelete mode 100644 src/hotspot/share/cds/archiveHeapLoader.cpp", "source_url": "https://github.com/openjdk/riscv-port/commit/c8656449c28581ae9c3d815105e338e42253bb43", "code_v0_no_empty_lines": "Java应用启动时需要重新构建堆对象，增加启动时间和内存开销。", "code_v1_no_empty_lines": "create mode 100644 src/hotspot/share/cds/aotMappedHeapLoader.cpp\ncreate mode 100644 src/hotspot/share/cds/aotStreamedHeapLoader.cpp\ncreate mode 100644 src/hotspot/share/cds/aotStreamedHeapWriter.cpp\ndelete mode 100644 src/hotspot/share/cds/archiveHeapLoader.cpp", "target": "create mode 100644 src/hotspot/share/cds/aotMappedHeapLoader.cpp\ncreate mode 100644 src/hotspot/share/cds/aotStreamedHeapLoader.cpp\ncreate mode 100644 src/hotspot/share/cds/aotStreamedHeapWriter.cpp\ndelete mode 100644 src/hotspot/share/cds/archiveHeapLoader.cpp", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Java应用启动时需要重新构建堆对象，增加启动时间和内存开销。优化后：实现JEP 516 Ahead-of-Time Object Caching，新增AOT堆映射和流式堆加载器，支持任何GC算法下预缓存堆对象。思路：通过预编译时缓存堆对象到CDS存档，运行时直接映射或流式加载，减少启动时的对象分配和初始化开销，提升应用启动性能。"}
{"id": 134, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+性能调优", "optimization_description": "优化前：默认禁用SIMD SHA3指令集优化（UseSIMDForSHA3Intrinsic=false），且SHA3内在函数启用逻辑复杂，包含多个条件判断和警告处理。优化后：默认启用SIMD SHA3指令集优化（UseSIMDForSHA3Intrinsic=true），并简化了SHA3内在函数的启用逻辑，仅在Apple Silicon硬件上自动启用UseSHA3Intrinsics，移除了对Neoverse V1/V2/N2的性能警告。优化思路：根据性能评估结果，在支持SHA3指令集的硬件上默认启用SIMD优化以提高性能，同时简化代码逻辑，减少不必要的条件分支和警告输出。", "original_code": "默认禁用SIMD SHA3指令集优化（UseSIMDForSHA3Intrinsic=false），且SHA3内在函数启用逻辑复杂，包含多个条件判断和警告处理。", "optimized_code": "-  product(bool, UseSIMDForSHA3Intrinsic, false,                         \\\n+  product(bool, UseSIMDForSHA3Intrinsic, true,                          \\\n           \"Use SIMD SHA3 instructions for SHA3 intrinsic\")              \\\n@@ -375,24 +375,18 @@ void VM_Version::initialize() {\n     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n   }\n \n-  if (UseSHA && VM_Version::supports_sha3() && _cpu == CPU_APPLE && FLAG_IS_DEFAULT(UseSIMDForSHA3Intrinsic)) {\n-    // Note: SIMD faster on Apple, worse on Neoverse V1, V2 and N2.\n-    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, true);\n-  }\n-\n-  // Enable SHA-3 intrinsics (SIMD or GPR). The GPR path does not require SHA instructions.\n-  if (FLAG_IS_DEFAULT(UseSHA3Intrinsics)) {\n-    FLAG_SET_DEFAULT(UseSHA3Intrinsics, true);\n-  }\n-\n-  if (!UseSHA3Intrinsics && UseSIMDForSHA3Intrinsic) {\n-    // Keep flags consistent: if SHA3 intrinsics are off, disable the SHA3 SIMD variant.\n-    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, false);\n-  }\n-\n-  if (!VM_Version::supports_sha3() && UseSIMDForSHA3Intrinsic) {\n-    warning(\"SHA3 instructions are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, false);\n+  if (UseSHA && VM_Version::supports_sha3()) {\n+    // Auto-enable UseSHA3Intrinsics on hardware with performance benefit.\n+    // Note that the evaluation of UseSHA3Intrinsics shows better performance\n+    // on Apple silicon but worse performance on Neoverse V1 and N2.\n+    if (_cpu == CPU_APPLE) {  // Apple silicon\n+      if (FLAG_IS_DEFAULT(UseSHA3Intrinsics)) {\n+        FLAG_SET_DEFAULT(UseSHA3Intrinsics, true);\n+      }\n+    }\n+  } else if (UseSHA3Intrinsics && UseSIMDForSHA3Intrinsic) {\n+    warning(\"Intrinsics for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 crypto hash functions not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseSHA3Intrinsics, false);\n   }", "source_url": "https://github.com/openjdk/riscv-port/commit/3d6824e802bda6efed40f7613eda7c8c0d84e673", "code_v0_no_empty_lines": "默认禁用SIMD SHA3指令集优化（UseSIMDForSHA3Intrinsic=false），且SHA3内在函数启用逻辑复杂，包含多个条件判断和警告处理。", "code_v1_no_empty_lines": "-  product(bool, UseSIMDForSHA3Intrinsic, false,                         \\\n+  product(bool, UseSIMDForSHA3Intrinsic, true,                          \\\n           \"Use SIMD SHA3 instructions for SHA3 intrinsic\")              \\\n@@ -375,24 +375,18 @@ void VM_Version::initialize() {\n     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n   }\n \n-  if (UseSHA && VM_Version::supports_sha3() && _cpu == CPU_APPLE && FLAG_IS_DEFAULT(UseSIMDForSHA3Intrinsic)) {\n-    // Note: SIMD faster on Apple, worse on Neoverse V1, V2 and N2.\n-    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, true);\n-  }\n-\n-  // Enable SHA-3 intrinsics (SIMD or GPR). The GPR path does not require SHA instructions.\n-  if (FLAG_IS_DEFAULT(UseSHA3Intrinsics)) {\n-    FLAG_SET_DEFAULT(UseSHA3Intrinsics, true);\n-  }\n-\n-  if (!UseSHA3Intrinsics && UseSIMDForSHA3Intrinsic) {\n-    // Keep flags consistent: if SHA3 intrinsics are off, disable the SHA3 SIMD variant.\n-    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, false);\n-  }\n-\n-  if (!VM_Version::supports_sha3() && UseSIMDForSHA3Intrinsic) {\n-    warning(\"SHA3 instructions are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, false);\n+  if (UseSHA && VM_Version::supports_sha3()) {\n+    // Auto-enable UseSHA3Intrinsics on hardware with performance benefit.\n+    // Note that the evaluation of UseSHA3Intrinsics shows better performance\n+    // on Apple silicon but worse performance on Neoverse V1 and N2.\n+    if (_cpu == CPU_APPLE) {  // Apple silicon\n+      if (FLAG_IS_DEFAULT(UseSHA3Intrinsics)) {\n+        FLAG_SET_DEFAULT(UseSHA3Intrinsics, true);\n+      }\n+    }\n+  } else if (UseSHA3Intrinsics && UseSIMDForSHA3Intrinsic) {\n+    warning(\"Intrinsics for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 crypto hash functions not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseSHA3Intrinsics, false);\n   }", "target": "-  product(bool, UseSIMDForSHA3Intrinsic, false,                         \\\n+  product(bool, UseSIMDForSHA3Intrinsic, true,                          \\\n           \"Use SIMD SHA3 instructions for SHA3 intrinsic\")              \\\n@@ -375,24 +375,18 @@ void VM_Version::initialize() {\n     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n   }\n \n-  if (UseSHA && VM_Version::supports_sha3() && _cpu == CPU_APPLE && FLAG_IS_DEFAULT(UseSIMDForSHA3Intrinsic)) {\n-    // Note: SIMD faster on Apple, worse on Neoverse V1, V2 and N2.\n-    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, true);\n-  }\n-\n-  // Enable SHA-3 intrinsics (SIMD or GPR). The GPR path does not require SHA instructions.\n-  if (FLAG_IS_DEFAULT(UseSHA3Intrinsics)) {\n-    FLAG_SET_DEFAULT(UseSHA3Intrinsics, true);\n-  }\n-\n-  if (!UseSHA3Intrinsics && UseSIMDForSHA3Intrinsic) {\n-    // Keep flags consistent: if SHA3 intrinsics are off, disable the SHA3 SIMD variant.\n-    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, false);\n-  }\n-\n-  if (!VM_Version::supports_sha3() && UseSIMDForSHA3Intrinsic) {\n-    warning(\"SHA3 instructions are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, false);\n+  if (UseSHA && VM_Version::supports_sha3()) {\n+    // Auto-enable UseSHA3Intrinsics on hardware with performance benefit.\n+    // Note that the evaluation of UseSHA3Intrinsics shows better performance\n+    // on Apple silicon but worse performance on Neoverse V1 and N2.\n+    if (_cpu == CPU_APPLE) {  // Apple silicon\n+      if (FLAG_IS_DEFAULT(UseSHA3Intrinsics)) {\n+        FLAG_SET_DEFAULT(UseSHA3Intrinsics, true);\n+      }\n+    }\n+  } else if (UseSHA3Intrinsics && UseSIMDForSHA3Intrinsic) {\n+    warning(\"Intrinsics for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 crypto hash functions not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseSHA3Intrinsics, false);\n   }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：默认禁用SIMD SHA3指令集优化（UseSIMDForSHA3Intrinsic=false），且SHA3内在函数启用逻辑复杂，包含多个条件判断和警告处理。优化后：默认启用SIMD SHA3指令集优化（UseSIMDForSHA3Intrinsic=true），并简化了SHA3内在函数的启用逻辑，仅在Apple Silicon硬件上自动启用UseSHA3Intrinsics，移除了对Neoverse V1/V2/N2的性能警告。优化思路：根据性能评估结果，在支持SHA3指令集的硬件上默认启用SIMD优化以提高性能，同时简化代码逻辑，减少不必要的条件分支和警告输出。"}
{"id": 135, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：Shenandoah GC的compact启发式算法中未启用字符串去重功能，可能导致内存中存在重复的字符串对象，浪费内存空间。优化后：在ShenandoahCompactHeuristics构造函数中启用UseStringDeduplication标志，允许GC在compact模式下识别并合并重复的字符串，减少内存占用。优化思路：通过启用字符串去重功能，利用GC自动检测和消除重复字符串，提高内存利用率，减少内存碎片。", "original_code": "Shenandoah GC的compact启发式算法中未启用字符串去重功能，可能导致内存中存在重复的字符串对象，浪费内存空间。", "optimized_code": "+  SHENANDOAH_ERGO_ENABLE_FLAG(UseStringDeduplication);", "source_url": "https://github.com/openjdk/riscv-port/commit/e34a831814996be3e0a2df86b11b1718a76ea558", "code_v0_no_empty_lines": "Shenandoah GC的compact启发式算法中未启用字符串去重功能，可能导致内存中存在重复的字符串对象，浪费内存空间。", "code_v1_no_empty_lines": "+  SHENANDOAH_ERGO_ENABLE_FLAG(UseStringDeduplication);", "target": "+  SHENANDOAH_ERGO_ENABLE_FLAG(UseStringDeduplication);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Shenandoah GC的compact启发式算法中未启用字符串去重功能，可能导致内存中存在重复的字符串对象，浪费内存空间。优化后：在ShenandoahCompactHeuristics构造函数中启用UseStringDeduplication标志，允许GC在compact模式下识别并合并重复的字符串，减少内存占用。优化思路：通过启用字符串去重功能，利用GC自动检测和消除重复字符串，提高内存利用率，减少内存碎片。"}
{"id": 136, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+性能调优", "optimization_description": "优化前：默认启用SIMD SHA3指令（UseSIMDForSHA3Intrinsic=true），在Neoverse V1/V2/N2等ARM CPU上性能较差。优化后：将默认值改为false，优先使用GPR（通用寄存器）路径的SHA3 intrinsic，同时在代码逻辑中优化了标志设置逻辑，仅在Apple芯片上自动启用SIMD路径。优化思路：根据CPU架构特性选择最优实现，在非Apple ARM架构上使用GPR intrinsic获得更好性能，同时保持代码逻辑更清晰和一致。", "original_code": "默认启用SIMD SHA3指令（UseSIMDForSHA3Intrinsic=true），在Neoverse V1/V2/N2等ARM CPU上性能较差。", "optimized_code": "-  product(bool, UseSIMDForSHA3Intrinsic, true,                          \\\n+  product(bool, UseSIMDForSHA3Intrinsic, false,                         \\\n           \"Use SIMD SHA3 instructions for SHA3 intrinsic\")              \\\n@@ -375,18 +375,24 @@ void VM_Version::initialize() {\n     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n   }\n \n-  if (UseSHA && VM_Version::supports_sha3()) {\n-    // Auto-enable UseSHA3Intrinsics on hardware with performance benefit.\n-    // Note that the evaluation of UseSIMDForSHA3Intrinsics shows better performance\n-    // on Apple silicon but worse performance on Neoverse V1 and N2.\n-    if (_cpu == CPU_APPLE) {  // Apple silicon\n-      if (FLAG_IS_DEFAULT(UseSIMDForSHA3Intrinsic)) {\n-        FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, true);\n-      }\n-    }\n-  } else if (UseSHA3Intrinsics && UseSIMDForSHA3Intrinsic) {\n-    warning(\"Intrinsics for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseSHA3Intrinsics, false);\n+  if (UseSHA && VM_Version::supports_sha3() && _cpu == CPU_APPLE && FLAG_IS_DEFAULT(UseSIMDForSHA3Intrinsic)) {\n+    // Note: SIMD faster on Apple, worse on Neoverse V1, V2 and N2.\n+    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, true);\n+  }\n+\n+  // Enable SHA-3 intrinsics (SIMD or GPR). The GPR path does not require SHA instructions.\n+  if (FLAG_IS_DEFAULT(UseSHA3Intrinsics)) {\n+    FLAG_SET_DEFAULT(UseSHA3Intrinsics, true);\n+  }\n+\n+  if (!UseSHA3Intrinsics && UseSIMDForSHA3Intrinsic) {\n+    // Keep flags consistent: if SHA3 intrinsics are off, disable the SHA3 SIMD variant.\n+    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, false);\n+  }\n+\n+  if (!VM_Version::supports_sha3() && UseSIMDForSHA3Intrinsic) {\n+    warning(\"SHA3 instructions are not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, false);", "source_url": "https://github.com/openjdk/riscv-port/commit/c173d416f749348bee42e1a9436a999700d0f0e8", "code_v0_no_empty_lines": "默认启用SIMD SHA3指令（UseSIMDForSHA3Intrinsic=true），在Neoverse V1/V2/N2等ARM CPU上性能较差。", "code_v1_no_empty_lines": "-  product(bool, UseSIMDForSHA3Intrinsic, true,                          \\\n+  product(bool, UseSIMDForSHA3Intrinsic, false,                         \\\n           \"Use SIMD SHA3 instructions for SHA3 intrinsic\")              \\\n@@ -375,18 +375,24 @@ void VM_Version::initialize() {\n     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n   }\n \n-  if (UseSHA && VM_Version::supports_sha3()) {\n-    // Auto-enable UseSHA3Intrinsics on hardware with performance benefit.\n-    // Note that the evaluation of UseSIMDForSHA3Intrinsics shows better performance\n-    // on Apple silicon but worse performance on Neoverse V1 and N2.\n-    if (_cpu == CPU_APPLE) {  // Apple silicon\n-      if (FLAG_IS_DEFAULT(UseSIMDForSHA3Intrinsic)) {\n-        FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, true);\n-      }\n-    }\n-  } else if (UseSHA3Intrinsics && UseSIMDForSHA3Intrinsic) {\n-    warning(\"Intrinsics for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseSHA3Intrinsics, false);\n+  if (UseSHA && VM_Version::supports_sha3() && _cpu == CPU_APPLE && FLAG_IS_DEFAULT(UseSIMDForSHA3Intrinsic)) {\n+    // Note: SIMD faster on Apple, worse on Neoverse V1, V2 and N2.\n+    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, true);\n+  }\n+\n+  // Enable SHA-3 intrinsics (SIMD or GPR). The GPR path does not require SHA instructions.\n+  if (FLAG_IS_DEFAULT(UseSHA3Intrinsics)) {\n+    FLAG_SET_DEFAULT(UseSHA3Intrinsics, true);\n+  }\n+\n+  if (!UseSHA3Intrinsics && UseSIMDForSHA3Intrinsic) {\n+    // Keep flags consistent: if SHA3 intrinsics are off, disable the SHA3 SIMD variant.\n+    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, false);\n+  }\n+\n+  if (!VM_Version::supports_sha3() && UseSIMDForSHA3Intrinsic) {\n+    warning(\"SHA3 instructions are not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, false);", "target": "-  product(bool, UseSIMDForSHA3Intrinsic, true,                          \\\n+  product(bool, UseSIMDForSHA3Intrinsic, false,                         \\\n           \"Use SIMD SHA3 instructions for SHA3 intrinsic\")              \\\n@@ -375,18 +375,24 @@ void VM_Version::initialize() {\n     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n   }\n \n-  if (UseSHA && VM_Version::supports_sha3()) {\n-    // Auto-enable UseSHA3Intrinsics on hardware with performance benefit.\n-    // Note that the evaluation of UseSIMDForSHA3Intrinsics shows better performance\n-    // on Apple silicon but worse performance on Neoverse V1 and N2.\n-    if (_cpu == CPU_APPLE) {  // Apple silicon\n-      if (FLAG_IS_DEFAULT(UseSIMDForSHA3Intrinsic)) {\n-        FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, true);\n-      }\n-    }\n-  } else if (UseSHA3Intrinsics && UseSIMDForSHA3Intrinsic) {\n-    warning(\"Intrinsics for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseSHA3Intrinsics, false);\n+  if (UseSHA && VM_Version::supports_sha3() && _cpu == CPU_APPLE && FLAG_IS_DEFAULT(UseSIMDForSHA3Intrinsic)) {\n+    // Note: SIMD faster on Apple, worse on Neoverse V1, V2 and N2.\n+    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, true);\n+  }\n+\n+  // Enable SHA-3 intrinsics (SIMD or GPR). The GPR path does not require SHA instructions.\n+  if (FLAG_IS_DEFAULT(UseSHA3Intrinsics)) {\n+    FLAG_SET_DEFAULT(UseSHA3Intrinsics, true);\n+  }\n+\n+  if (!UseSHA3Intrinsics && UseSIMDForSHA3Intrinsic) {\n+    // Keep flags consistent: if SHA3 intrinsics are off, disable the SHA3 SIMD variant.\n+    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, false);\n+  }\n+\n+  if (!VM_Version::supports_sha3() && UseSIMDForSHA3Intrinsic) {\n+    warning(\"SHA3 instructions are not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseSIMDForSHA3Intrinsic, false);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：默认启用SIMD SHA3指令（UseSIMDForSHA3Intrinsic=true），在Neoverse V1/V2/N2等ARM CPU上性能较差。优化后：将默认值改为false，优先使用GPR（通用寄存器）路径的SHA3 intrinsic，同时在代码逻辑中优化了标志设置逻辑，仅在Apple芯片上自动启用SIMD路径。优化思路：根据CPU架构特性选择最优实现，在非Apple ARM架构上使用GPR intrinsic获得更好性能，同时保持代码逻辑更清晰和一致。"}
{"id": 137, "source": "riscv-dataset-excel", "optimization_type": "内存分配算法优化", "optimization_description": "优化前：分配器在collector分区中分配内存时，先尝试从affiliation匹配的区域分配，失败后需要重新调用allocate_from_partition_with_affiliation函数在FREE区域中分配，导致额外的函数调用和区域迭代开销。\n优化后：重构allocate_with_affiliation函数，在单次迭代中同时记录第一个FREE区域，如果affiliation匹配区域分配失败，直接使用记录的FREE区域分配，避免二次迭代。同时移除了allocate_from_partition_with_affiliation函数，简化了allocate_for_collector函数的逻辑。\n优化思路：通过单次遍历合并分配逻辑，减少不必要的区域迭代和函数调用，简化代码结构，提高内存分配效率。", "original_code": "分配器在collector分区中分配内存时，先尝试从affiliation匹配的区域分配，失败后需要重新调用allocate_from_partition_with_affiliation函数在FREE区域中分配，导致额外的函数调用和区域迭代开销。", "optimized_code": "-HeapWord* ShenandoahFreeSet::allocate_from_partition_with_affiliation(ShenandoahAffiliation affiliation,\n-                                                                      ShenandoahAllocRequest& req, bool& in_new_region) {\n-\n-  shenandoah_assert_heaplocked();\n-  ShenandoahFreeSetPartitionId which_partition = req.is_old()? ShenandoahFreeSetPartitionId::OldCollector: ShenandoahFreeSetPartitionId::Collector;\n-  if (_partitions.alloc_from_left_bias(which_partition)) {\n-    ShenandoahLeftRightIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n-    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n-  } else {\n-    ShenandoahRightLeftIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n-    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n-  }\n-}\n+\ntemplate<typename Iter>\n+HeapWord* ShenandoahFreeSet::allocate_with_affiliation(Iter& iterator,\n+                                                       ShenandoahAffiliation affiliation,\n+                                                       ShenandoahAllocRequest& req,\n+                                                       bool& in_new_region) {\n+  assert(affiliation != ShenandoahAffiliation::FREE, \"Must not\");\n+  ShenandoahHeapRegion* free_region = nullptr;\n   for (idx_t idx = iterator.current(); iterator.has_next(); idx = iterator.next()) {\n     ShenandoahHeapRegion* r = _heap->get_region(idx);\n     if (r->affiliation() == affiliation) {\n       HeapWord* result = try_allocate_in(r, req, in_new_region);\n       if (result != nullptr) {\n         return result;\n       }\n+    } else if (free_region == nullptr && r->affiliation() == FREE) {\n+      free_region = r;\n     }\n   }\n+  // Failed to allocate within any affiliated region, try the first free region in the partition.\n+  if (free_region != nullptr) {\n+    HeapWord* result = try_allocate_in(free_region, req, in_new_region);\n+    assert(result != nullptr, \"Allocate in free region in the partition always succeed.\");\n+    return result;\n+  }\n   log_debug(gc, free)(\"Could not allocate collector region with affiliation: %s for request \" PTR_FORMAT,\n                       shenandoah_affiliation_name(affiliation), p2i(&req));\n   return nullptr;\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/9cc542ebcb81552fe8c32a8cc3c63332853e5127", "code_v0_no_empty_lines": "分配器在collector分区中分配内存时，先尝试从affiliation匹配的区域分配，失败后需要重新调用allocate_from_partition_with_affiliation函数在FREE区域中分配，导致额外的函数调用和区域迭代开销。", "code_v1_no_empty_lines": "-HeapWord* ShenandoahFreeSet::allocate_from_partition_with_affiliation(ShenandoahAffiliation affiliation,\n-                                                                      ShenandoahAllocRequest& req, bool& in_new_region) {\n-\n-  shenandoah_assert_heaplocked();\n-  ShenandoahFreeSetPartitionId which_partition = req.is_old()? ShenandoahFreeSetPartitionId::OldCollector: ShenandoahFreeSetPartitionId::Collector;\n-  if (_partitions.alloc_from_left_bias(which_partition)) {\n-    ShenandoahLeftRightIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n-    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n-  } else {\n-    ShenandoahRightLeftIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n-    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n-  }\n-}\n+\ntemplate<typename Iter>\n+HeapWord* ShenandoahFreeSet::allocate_with_affiliation(Iter& iterator,\n+                                                       ShenandoahAffiliation affiliation,\n+                                                       ShenandoahAllocRequest& req,\n+                                                       bool& in_new_region) {\n+  assert(affiliation != ShenandoahAffiliation::FREE, \"Must not\");\n+  ShenandoahHeapRegion* free_region = nullptr;\n   for (idx_t idx = iterator.current(); iterator.has_next(); idx = iterator.next()) {\n     ShenandoahHeapRegion* r = _heap->get_region(idx);\n     if (r->affiliation() == affiliation) {\n       HeapWord* result = try_allocate_in(r, req, in_new_region);\n       if (result != nullptr) {\n         return result;\n       }\n+    } else if (free_region == nullptr && r->affiliation() == FREE) {\n+      free_region = r;\n     }\n   }\n+  // Failed to allocate within any affiliated region, try the first free region in the partition.\n+  if (free_region != nullptr) {\n+    HeapWord* result = try_allocate_in(free_region, req, in_new_region);\n+    assert(result != nullptr, \"Allocate in free region in the partition always succeed.\");\n+    return result;\n+  }\n   log_debug(gc, free)(\"Could not allocate collector region with affiliation: %s for request \" PTR_FORMAT,\n                       shenandoah_affiliation_name(affiliation), p2i(&req));\n   return nullptr;\n }", "target": "-HeapWord* ShenandoahFreeSet::allocate_from_partition_with_affiliation(ShenandoahAffiliation affiliation,\n-                                                                      ShenandoahAllocRequest& req, bool& in_new_region) {\n-\n-  shenandoah_assert_heaplocked();\n-  ShenandoahFreeSetPartitionId which_partition = req.is_old()? ShenandoahFreeSetPartitionId::OldCollector: ShenandoahFreeSetPartitionId::Collector;\n-  if (_partitions.alloc_from_left_bias(which_partition)) {\n-    ShenandoahLeftRightIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n-    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n-  } else {\n-    ShenandoahRightLeftIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n-    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n-  }\n-}\n+\ntemplate<typename Iter>\n+HeapWord* ShenandoahFreeSet::allocate_with_affiliation(Iter& iterator,\n+                                                       ShenandoahAffiliation affiliation,\n+                                                       ShenandoahAllocRequest& req,\n+                                                       bool& in_new_region) {\n+  assert(affiliation != ShenandoahAffiliation::FREE, \"Must not\");\n+  ShenandoahHeapRegion* free_region = nullptr;\n   for (idx_t idx = iterator.current(); iterator.has_next(); idx = iterator.next()) {\n     ShenandoahHeapRegion* r = _heap->get_region(idx);\n     if (r->affiliation() == affiliation) {\n       HeapWord* result = try_allocate_in(r, req, in_new_region);\n       if (result != nullptr) {\n         return result;\n       }\n+    } else if (free_region == nullptr && r->affiliation() == FREE) {\n+      free_region = r;\n     }\n   }\n+  // Failed to allocate within any affiliated region, try the first free region in the partition.\n+  if (free_region != nullptr) {\n+    HeapWord* result = try_allocate_in(free_region, req, in_new_region);\n+    assert(result != nullptr, \"Allocate in free region in the partition always succeed.\");\n+    return result;\n+  }\n   log_debug(gc, free)(\"Could not allocate collector region with affiliation: %s for request \" PTR_FORMAT,\n                       shenandoah_affiliation_name(affiliation), p2i(&req));\n   return nullptr;\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：分配器在collector分区中分配内存时，先尝试从affiliation匹配的区域分配，失败后需要重新调用allocate_from_partition_with_affiliation函数在FREE区域中分配，导致额外的函数调用和区域迭代开销。\n优化后：重构allocate_with_affiliation函数，在单次迭代中同时记录第一个FREE区域，如果affiliation匹配区域分配失败，直接使用记录的FREE区域分配，避免二次迭代。同时移除了allocate_from_partition_with_affiliation函数，简化了allocate_for_collector函数的逻辑。\n优化思路：通过单次遍历合并分配逻辑，减少不必要的区域迭代和函数调用，简化代码结构，提高内存分配效率。"}
{"id": 138, "source": "riscv-dataset-excel", "optimization_type": "循环优化+安全点消除", "optimization_description": "优化前：PhaseIdealLoop在消除循环中冗余安全点时，可能错误删除外层循环所需的安全点，导致外层循环缺少安全点检查。优化后：改进安全点分析逻辑，通过维护_required_safept列表标记需要保护的非调用安全点，并修改check_safepts方法继续搜索保证执行的调用，确保内层循环不会删除外层循环依赖的安全点。优化思路：基于对循环层次结构和安全点依赖关系的深入分析，区分计数循环/非计数循环、内层/外层循环、调用/非调用安全点等不同情况，建立更精确的安全点保护机制。", "original_code": "PhaseIdealLoop在消除循环中冗余安全点时，可能错误删除外层循环所需的安全点，导致外层循环缺少安全点检查。", "optimized_code": "@@ -4227,10 +4236,10 @@ void IdealLoopTree::check_safepts(VectorSet &visited, Node_List &stack) {\n           break;\n         } else if (n->Opcode() == Op_SafePoint) {\n           if (_phase->get_loop(n) == this) {\n+            // We found a local ncsfpt.\n+            // Continue searching for a call that is guaranteed to be a safepoint.\n             has_local_ncsfpt = true;\n-            break;\n-          }\n-          if (nonlocal_ncsfpt == nullptr) {\n+          } else if (nonlocal_ncsfpt == nullptr) {\n             nonlocal_ncsfpt = n; // save the one closest to the tail\n           }\n         } else {", "source_url": "https://github.com/openjdk/riscv-port/commit/093e128771f3dc01f64a8572de068e9776e38b97", "code_v0_no_empty_lines": "PhaseIdealLoop在消除循环中冗余安全点时，可能错误删除外层循环所需的安全点，导致外层循环缺少安全点检查。", "code_v1_no_empty_lines": "@@ -4227,10 +4236,10 @@ void IdealLoopTree::check_safepts(VectorSet &visited, Node_List &stack) {\n           break;\n         } else if (n->Opcode() == Op_SafePoint) {\n           if (_phase->get_loop(n) == this) {\n+            // We found a local ncsfpt.\n+            // Continue searching for a call that is guaranteed to be a safepoint.\n             has_local_ncsfpt = true;\n-            break;\n-          }\n-          if (nonlocal_ncsfpt == nullptr) {\n+          } else if (nonlocal_ncsfpt == nullptr) {\n             nonlocal_ncsfpt = n; // save the one closest to the tail\n           }\n         } else {", "target": "@@ -4227,10 +4236,10 @@ void IdealLoopTree::check_safepts(VectorSet &visited, Node_List &stack) {\n           break;\n         } else if (n->Opcode() == Op_SafePoint) {\n           if (_phase->get_loop(n) == this) {\n+            // We found a local ncsfpt.\n+            // Continue searching for a call that is guaranteed to be a safepoint.\n             has_local_ncsfpt = true;\n-            break;\n-          }\n-          if (nonlocal_ncsfpt == nullptr) {\n+          } else if (nonlocal_ncsfpt == nullptr) {\n             nonlocal_ncsfpt = n; // save the one closest to the tail\n           }\n         } else {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PhaseIdealLoop在消除循环中冗余安全点时，可能错误删除外层循环所需的安全点，导致外层循环缺少安全点检查。优化后：改进安全点分析逻辑，通过维护_required_safept列表标记需要保护的非调用安全点，并修改check_safepts方法继续搜索保证执行的调用，确保内层循环不会删除外层循环依赖的安全点。优化思路：基于对循环层次结构和安全点依赖关系的深入分析，区分计数循环/非计数循环、内层/外层循环、调用/非调用安全点等不同情况，建立更精确的安全点保护机制。"}
{"id": 139, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+异常处理优化", "optimization_description": "优化前：C2编译器为每个编译方法生成异常处理桩代码（exception handler stub），增加了代码大小和编译开销。优化后：完全移除异常处理桩代码生成，简化deopt处理器的实现，使用循环结构替代原有的adr+far_jump模式。优化思路：通过移除不必要的异常处理桩代码减少代码生成开销，优化deopt处理器结构提高执行效率，同时保持功能完整性。", "original_code": "C2编译器为每个编译方法生成异常处理桩代码（exception handler stub），增加了代码大小和编译开销。", "optimized_code": "- static int emit_exception_handler(C2_MacroAssembler *masm);\n- static uint size_exception_handler() {\n-   return MacroAssembler::far_codestub_branch_size();\n- }\n+ // 移除exception_handler相关代码\n- __ adr(lr, __ pc());\n- __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+ Label start;\n+ __ bind(start);\n+ __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+ int entry_offset = __ offset();\n+ __ b(start);", "source_url": "https://github.com/openjdk/riscv-port/commit/3e3822ad7eadbb3d86a3b94a6bd858f8c8ef9364", "code_v0_no_empty_lines": "C2编译器为每个编译方法生成异常处理桩代码（exception handler stub），增加了代码大小和编译开销。", "code_v1_no_empty_lines": "- static int emit_exception_handler(C2_MacroAssembler *masm);\n- static uint size_exception_handler() {\n-   return MacroAssembler::far_codestub_branch_size();\n- }\n+ // 移除exception_handler相关代码\n- __ adr(lr, __ pc());\n- __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+ Label start;\n+ __ bind(start);\n+ __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+ int entry_offset = __ offset();\n+ __ b(start);", "target": "- static int emit_exception_handler(C2_MacroAssembler *masm);\n- static uint size_exception_handler() {\n-   return MacroAssembler::far_codestub_branch_size();\n- }\n+ // 移除exception_handler相关代码\n- __ adr(lr, __ pc());\n- __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+ Label start;\n+ __ bind(start);\n+ __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+ int entry_offset = __ offset();\n+ __ b(start);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器为每个编译方法生成异常处理桩代码（exception handler stub），增加了代码大小和编译开销。优化后：完全移除异常处理桩代码生成，简化deopt处理器的实现，使用循环结构替代原有的adr+far_jump模式。优化思路：通过移除不必要的异常处理桩代码减少代码生成开销，优化deopt处理器结构提高执行效率，同时保持功能完整性。"}
{"id": 140, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化+算法优化", "optimization_description": "优化前：每次调用get_filename_and_line_number时都创建新的DebugAranges对象并进行线性扫描查找，时间复杂度为O(n)。优化后：引入缓存机制，首次调用时构建排序后的地址范围数组，后续查找使用二分搜索（O(log n)），大幅提升查找速度。优化思路：将频繁访问的.debug_aranges数据预加载到内存中并排序，用空间换时间，同时保留线性扫描作为后备方案。", "original_code": "每次调用get_filename_and_line_number时都创建新的DebugAranges对象并进行线性扫描查找，时间复杂度为O(n)。", "optimized_code": "bool DwarfFile::DebugAranges::find_compilation_unit_offset(const uint32_t offset_in_library, uint32_t* compilation_unit_offset) {\n+  switch (ensure_cached()) {\n+    case CacheHint::VALID:\n+      return _cache.find_compilation_unit_offset(offset_in_library, compilation_unit_offset);\n+    case CacheHint::TRY_LINEAR_SCAN:\n+      break;\n+    case CacheHint::FAILED:\n+      return false;\n+  }\n+\n+  // Fall back to linear scan if building of the cache failed, which can happen\n+  // if there are C heap allocation errors.\n+  DWARF_LOG_INFO(\"Falling back to linear scan of .debug_aranges for '%s'\", _dwarf_file->filepath());\n   if (!read_section_header()) {\n     DWARF_LOG_ERROR(\"Failed to read a .debug_aranges header.\");\n     return false;\n   }\n\n   // (2) The .debug_aranges section contains a number of entries/sets. Each set contains one or multiple address range descriptors of the\n   // form [beginning_address, beginning_address+length). Start reading these sets and their descriptors until we find one that contains\n   // 'offset_in_library'. Read the debug_info_offset field from the header of this set which defines the offset for the compilation unit.\n   // This process is described in section 6.1.2 of the DWARF 4 spec.\n-  DebugAranges debug_aranges(this);\n-  uint32_t compilation_unit_offset = 0; // 4-bytes for 32-bit DWARF\n-  if (!debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n+  if (!_debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n     DWARF_LOG_ERROR(\"Failed to find .debug_info offset for the compilation unit.\");\n     return false;\n   }", "source_url": "https://github.com/openjdk/riscv-port/commit/dddfcd03aa30514d63eceff707d48bff35e93c56", "code_v0_no_empty_lines": "每次调用get_filename_and_line_number时都创建新的DebugAranges对象并进行线性扫描查找，时间复杂度为O(n)。", "code_v1_no_empty_lines": "bool DwarfFile::DebugAranges::find_compilation_unit_offset(const uint32_t offset_in_library, uint32_t* compilation_unit_offset) {\n+  switch (ensure_cached()) {\n+    case CacheHint::VALID:\n+      return _cache.find_compilation_unit_offset(offset_in_library, compilation_unit_offset);\n+    case CacheHint::TRY_LINEAR_SCAN:\n+      break;\n+    case CacheHint::FAILED:\n+      return false;\n+  }\n+\n+  // Fall back to linear scan if building of the cache failed, which can happen\n+  // if there are C heap allocation errors.\n+  DWARF_LOG_INFO(\"Falling back to linear scan of .debug_aranges for '%s'\", _dwarf_file->filepath());\n   if (!read_section_header()) {\n     DWARF_LOG_ERROR(\"Failed to read a .debug_aranges header.\");\n     return false;\n   }\n\n   // (2) The .debug_aranges section contains a number of entries/sets. Each set contains one or multiple address range descriptors of the\n   // form [beginning_address, beginning_address+length). Start reading these sets and their descriptors until we find one that contains\n   // 'offset_in_library'. Read the debug_info_offset field from the header of this set which defines the offset for the compilation unit.\n   // This process is described in section 6.1.2 of the DWARF 4 spec.\n-  DebugAranges debug_aranges(this);\n-  uint32_t compilation_unit_offset = 0; // 4-bytes for 32-bit DWARF\n-  if (!debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n+  if (!_debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n     DWARF_LOG_ERROR(\"Failed to find .debug_info offset for the compilation unit.\");\n     return false;\n   }", "target": "bool DwarfFile::DebugAranges::find_compilation_unit_offset(const uint32_t offset_in_library, uint32_t* compilation_unit_offset) {\n+  switch (ensure_cached()) {\n+    case CacheHint::VALID:\n+      return _cache.find_compilation_unit_offset(offset_in_library, compilation_unit_offset);\n+    case CacheHint::TRY_LINEAR_SCAN:\n+      break;\n+    case CacheHint::FAILED:\n+      return false;\n+  }\n+\n+  // Fall back to linear scan if building of the cache failed, which can happen\n+  // if there are C heap allocation errors.\n+  DWARF_LOG_INFO(\"Falling back to linear scan of .debug_aranges for '%s'\", _dwarf_file->filepath());\n   if (!read_section_header()) {\n     DWARF_LOG_ERROR(\"Failed to read a .debug_aranges header.\");\n     return false;\n   }\n\n   // (2) The .debug_aranges section contains a number of entries/sets. Each set contains one or multiple address range descriptors of the\n   // form [beginning_address, beginning_address+length). Start reading these sets and their descriptors until we find one that contains\n   // 'offset_in_library'. Read the debug_info_offset field from the header of this set which defines the offset for the compilation unit.\n   // This process is described in section 6.1.2 of the DWARF 4 spec.\n-  DebugAranges debug_aranges(this);\n-  uint32_t compilation_unit_offset = 0; // 4-bytes for 32-bit DWARF\n-  if (!debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n+  if (!_debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n     DWARF_LOG_ERROR(\"Failed to find .debug_info offset for the compilation unit.\");\n     return false;\n   }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次调用get_filename_and_line_number时都创建新的DebugAranges对象并进行线性扫描查找，时间复杂度为O(n)。优化后：引入缓存机制，首次调用时构建排序后的地址范围数组，后续查找使用二分搜索（O(log n)），大幅提升查找速度。优化思路：将频繁访问的.debug_aranges数据预加载到内存中并排序，用空间换时间，同时保留线性扫描作为后备方案。"}
{"id": 141, "source": "riscv-dataset-excel", "optimization_type": "虚拟线程调度优化", "optimization_description": "优化前：虚拟线程在类初始化路径（如静态初始化、类加载）中无法被抢占，导致长时间阻塞其他虚拟线程。优化后：通过修改解释器帧处理逻辑（如anchor_mark_set_pd函数），允许在常见类初始化路径中抢占虚拟线程，提升调度公平性和响应性。优化思路：在解释器帧中正确处理last_sp指针，确保抢占时能安全保存和恢复线程状态，避免死锁或状态损坏。", "original_code": "虚拟线程在类初始化路径（如静态初始化、类加载）中无法被抢占，导致长时间阻塞其他虚拟线程。", "optimized_code": "inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n  intptr_t* sp = _top_frame.sp();\n  if (_top_frame.is_interpreted_frame()) {\n    // In case the top frame is interpreted we need to set up the anchor using\n    // the last_sp saved in the frame (remove possible alignment added while\n    // thawing, see ThawBase::finish_thaw()). We also clear last_sp to match\n    // the behavior when calling the VM from the interpreter (we check for this\n    // in FreezeBase::prepare_freeze_interpreted_top_frame, which can be reached\n    // if preempting again at redo_vmcall()).\n    _last_sp_from_frame = _top_frame.interpreter_frame_last_sp();\n    assert(_last_sp_from_frame != nullptr, \"\");\n    _top_frame.interpreter_frame_set_last_sp(nullptr);\n    if (sp != _last_sp_from_frame) {\n      // We need to move up return pc and fp. They will be read next in\n      // set_anchor() and set as _last_Java_pc and _last_Java_f", "source_url": "https://github.com/openjdk/riscv-port/commit/c6a88155b519a5d0b22f6009e75a0e6388601756", "code_v0_no_empty_lines": "虚拟线程在类初始化路径（如静态初始化、类加载）中无法被抢占，导致长时间阻塞其他虚拟线程。", "code_v1_no_empty_lines": "inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n  intptr_t* sp = _top_frame.sp();\n  if (_top_frame.is_interpreted_frame()) {\n    // In case the top frame is interpreted we need to set up the anchor using\n    // the last_sp saved in the frame (remove possible alignment added while\n    // thawing, see ThawBase::finish_thaw()). We also clear last_sp to match\n    // the behavior when calling the VM from the interpreter (we check for this\n    // in FreezeBase::prepare_freeze_interpreted_top_frame, which can be reached\n    // if preempting again at redo_vmcall()).\n    _last_sp_from_frame = _top_frame.interpreter_frame_last_sp();\n    assert(_last_sp_from_frame != nullptr, \"\");\n    _top_frame.interpreter_frame_set_last_sp(nullptr);\n    if (sp != _last_sp_from_frame) {\n      // We need to move up return pc and fp. They will be read next in\n      // set_anchor() and set as _last_Java_pc and _last_Java_f", "target": "inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n  intptr_t* sp = _top_frame.sp();\n  if (_top_frame.is_interpreted_frame()) {\n    // In case the top frame is interpreted we need to set up the anchor using\n    // the last_sp saved in the frame (remove possible alignment added while\n    // thawing, see ThawBase::finish_thaw()). We also clear last_sp to match\n    // the behavior when calling the VM from the interpreter (we check for this\n    // in FreezeBase::prepare_freeze_interpreted_top_frame, which can be reached\n    // if preempting again at redo_vmcall()).\n    _last_sp_from_frame = _top_frame.interpreter_frame_last_sp();\n    assert(_last_sp_from_frame != nullptr, \"\");\n    _top_frame.interpreter_frame_set_last_sp(nullptr);\n    if (sp != _last_sp_from_frame) {\n      // We need to move up return pc and fp. They will be read next in\n      // set_anchor() and set as _last_Java_pc and _last_Java_f", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：虚拟线程在类初始化路径（如静态初始化、类加载）中无法被抢占，导致长时间阻塞其他虚拟线程。优化后：通过修改解释器帧处理逻辑（如anchor_mark_set_pd函数），允许在常见类初始化路径中抢占虚拟线程，提升调度公平性和响应性。优化思路：在解释器帧中正确处理last_sp指针，确保抢占时能安全保存和恢复线程状态，避免死锁或状态损坏。"}
{"id": 142, "source": "riscv-dataset-excel", "optimization_type": "性能优化+常量计算优化", "optimization_description": "优化前：每次调用fill方法时，通过位运算（8次移位和7次或运算）动态计算longValue，产生运行时计算开销。优化后：预定义常量BYTE_REPLICATOR（0x0101010101010101L），通过一次乘法运算生成longValue，将运行时计算转换为编译时常量乘法。优化思路：将重复的位运算模式提取为常量，减少每次方法调用的计算开销，提升MemorySegment::fill方法的性能。", "original_code": "每次调用fill方法时，通过位运算（8次移位和7次或运算）动态计算longValue，产生运行时计算开销。", "optimized_code": "+ private static final long BYTE_REPLICATOR = 0x0101010101010101L;\n- final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+ final long longValue = BYTE_REPLICATOR * u;", "source_url": "https://github.com/openjdk/riscv-port/commit/8dbefc53a95c6e3f722082316157c6372737c162", "code_v0_no_empty_lines": "每次调用fill方法时，通过位运算（8次移位和7次或运算）动态计算longValue，产生运行时计算开销。", "code_v1_no_empty_lines": "+ private static final long BYTE_REPLICATOR = 0x0101010101010101L;\n- final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+ final long longValue = BYTE_REPLICATOR * u;", "target": "+ private static final long BYTE_REPLICATOR = 0x0101010101010101L;\n- final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+ final long longValue = BYTE_REPLICATOR * u;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次调用fill方法时，通过位运算（8次移位和7次或运算）动态计算longValue，产生运行时计算开销。优化后：预定义常量BYTE_REPLICATOR（0x0101010101010101L），通过一次乘法运算生成longValue，将运行时计算转换为编译时常量乘法。优化思路：将重复的位运算模式提取为常量，减少每次方法调用的计算开销，提升MemorySegment::fill方法的性能。"}
{"id": 143, "source": "riscv-dataset-excel", "optimization_type": "文档更新", "optimization_description": "优化前：缺少RISC-V架构的优化指南文档。优化后：新增了完整的RISC-V优化指南文档，涵盖了标量整数、标量浮点、向量操作的优化建议，以及Linux系统上RISC-V扩展检测方法。思路：为RISC-V软件开发者提供系统性的性能优化指导，包括实现无关的通用优化和特定实现的优化建议，帮助开发者编写更高效的RISC-V代码。", "original_code": "缺少RISC-V架构的优化指南文档。", "optimized_code": "无代码修改", "source_url": "https://riscv-optimization-guide-riseproject-c94355ae3e6872252baa952524.gitlab.io/riscv-optimization-guide.html#_unit_stride_segment_loads_and_stores", "code_v0_no_empty_lines": "缺少RISC-V架构的优化指南文档。", "code_v1_no_empty_lines": "无代码修改", "target": "无代码修改", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：缺少RISC-V架构的优化指南文档。优化后：新增了完整的RISC-V优化指南文档，涵盖了标量整数、标量浮点、向量操作的优化建议，以及Linux系统上RISC-V扩展检测方法。思路：为RISC-V软件开发者提供系统性的性能优化指导，包括实现无关的通用优化和特定实现的优化建议，帮助开发者编写更高效的RISC-V代码。"}
{"id": 144, "source": "riscv-dataset-excel", "optimization_type": "算法优化+性能优化", "optimization_description": "优化前：FloatingDecimal中的浮点数解析使用硬编码的5的幂次表，代码冗长且维护困难。优化后：1. 使用@Stable注解标记静态数组，允许JIT编译器进行更积极的优化；2. 将硬编码的5的幂次表改为动态计算生成，减少代码体积；3. 重构FDBigInteger类，移除JML规范注释，简化实现。优化思路：通过减少代码体积、改进缓存机制和利用JVM优化特性，扩展fast paths处理范围，提升浮点数解析性能。", "original_code": "FloatingDecimal中的浮点数解析使用硬编码的5的幂次表，代码冗长且维护困难。", "optimized_code": "- static final int[] SMALL_5_POW;\n+ @Stable\n+ static final int[] SMALL_5_POW;\n- private static final FDBigInteger POW_5_CACHE[];\n+ @Stable\n+ private static final FDBigInteger[] POW_5_CACHE;\n- int[] small5pow = {\n-     1,\n-     5,\n-     5 * 5,\n-     ...\n- };\n+ int[] small5pow = new int[13 + 1];\n+ small5pow[0] = 1;\n+ for (int i = 1; i < small5pow.length; ++i) {\n+     small5pow[i] = 5 * small5pow[i - 1];\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/deb7edb151fd5940fdf9fdb2a6356080ee94e222", "code_v0_no_empty_lines": "FloatingDecimal中的浮点数解析使用硬编码的5的幂次表，代码冗长且维护困难。", "code_v1_no_empty_lines": "- static final int[] SMALL_5_POW;\n+ @Stable\n+ static final int[] SMALL_5_POW;\n- private static final FDBigInteger POW_5_CACHE[];\n+ @Stable\n+ private static final FDBigInteger[] POW_5_CACHE;\n- int[] small5pow = {\n-     1,\n-     5,\n-     5 * 5,\n-     ...\n- };\n+ int[] small5pow = new int[13 + 1];\n+ small5pow[0] = 1;\n+ for (int i = 1; i < small5pow.length; ++i) {\n+     small5pow[i] = 5 * small5pow[i - 1];\n+ }", "target": "- static final int[] SMALL_5_POW;\n+ @Stable\n+ static final int[] SMALL_5_POW;\n- private static final FDBigInteger POW_5_CACHE[];\n+ @Stable\n+ private static final FDBigInteger[] POW_5_CACHE;\n- int[] small5pow = {\n-     1,\n-     5,\n-     5 * 5,\n-     ...\n- };\n+ int[] small5pow = new int[13 + 1];\n+ small5pow[0] = 1;\n+ for (int i = 1; i < small5pow.length; ++i) {\n+     small5pow[i] = 5 * small5pow[i - 1];\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：FloatingDecimal中的浮点数解析使用硬编码的5的幂次表，代码冗长且维护困难。优化后：1. 使用@Stable注解标记静态数组，允许JIT编译器进行更积极的优化；2. 将硬编码的5的幂次表改为动态计算生成，减少代码体积；3. 重构FDBigInteger类，移除JML规范注释，简化实现。优化思路：通过减少代码体积、改进缓存机制和利用JVM优化特性，扩展fast paths处理范围，提升浮点数解析性能。"}
{"id": 145, "source": "riscv-dataset-excel", "optimization_type": "NUMA内存优化+TLAB计算优化", "optimization_description": "优化前：1. 每个线程创建时都调用update_lgrp_id()更新NUMA节点ID，增加了线程创建开销；2. TLAB容量计算基于单个线程的NUMA节点，可能导致负载不均衡；3. 需要维护线程的lgrp_id状态。\n\n优化后：1. 移除线程创建时的lgrp_id更新调用，减少开销；2. TLAB容量/使用量/最大分配计算改为所有NUMA节点的平均值，实现更均衡的内存分配；3. 直接从操作系统获取当前线程的NUMA节点ID，简化状态管理。\n\n优化思路：通过平均化NUMA节点的TLAB计算，避免热点节点过载，同时移除不必要的线程状态更新，减少开销，提高并行GC在NUMA系统下的性能。", "original_code": "1. 每个线程创建时都调用update_lgrp_id()更新NUMA节点ID，增加了线程创建开销；2. TLAB容量计算基于单个线程的NUMA节点，可能导致负载不均衡；3. 需要维护线程的lgrp_id状态。", "optimized_code": "1. 移除线程创建时的lgrp_id更新：\n- if (UseNUMA) {\n-   thread->update_lgrp_id();\n- }\n\n2. 修改TLAB计算方法（从基于线程改为基于平均值）：\n- size_t MutableNUMASpace::tlab_capacity(Thread *thr) const {\n-   return lgrp_space_for_thread(thr)->space()->capacity_in_bytes();\n- }\n+ size_t MutableNUMASpace::tlab_capacity(Thread *ignored) const {\n+   size_t s = 0;\n+   for (LGRPSpace* ls : *lgrp_spaces()) {\n+     s += ls->space()->capacity_in_bytes();\n+   }\n+   return s / (size_t)lgrp_spaces()->length();\n+ }\n\n3. 简化lgrp_space查找逻辑：\n- MutableNUMASpace::LGRPSpace *MutableNUMASpace::lgrp_space_for_thread(Thread* thr) const {\n-   guarantee(thr != nullptr, \"No thread\");\n-   int lgrp_id = thr->lgrp_id();\n-   ...\n- }\n+ MutableNUMASpace::LGRPSpace *MutableNUMASpace::lgrp_space_for_current_thread() const {\n+   const int lgrp_id = os::numa_get_group_id();\n+   ...\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/10ea585b5ca01dc0136fe76a11109d0f17828772", "code_v0_no_empty_lines": "1. 每个线程创建时都调用update_lgrp_id()更新NUMA节点ID，增加了线程创建开销；2. TLAB容量计算基于单个线程的NUMA节点，可能导致负载不均衡；3. 需要维护线程的lgrp_id状态。", "code_v1_no_empty_lines": "1. 移除线程创建时的lgrp_id更新：\n- if (UseNUMA) {\n-   thread->update_lgrp_id();\n- }\n\n2. 修改TLAB计算方法（从基于线程改为基于平均值）：\n- size_t MutableNUMASpace::tlab_capacity(Thread *thr) const {\n-   return lgrp_space_for_thread(thr)->space()->capacity_in_bytes();\n- }\n+ size_t MutableNUMASpace::tlab_capacity(Thread *ignored) const {\n+   size_t s = 0;\n+   for (LGRPSpace* ls : *lgrp_spaces()) {\n+     s += ls->space()->capacity_in_bytes();\n+   }\n+   return s / (size_t)lgrp_spaces()->length();\n+ }\n\n3. 简化lgrp_space查找逻辑：\n- MutableNUMASpace::LGRPSpace *MutableNUMASpace::lgrp_space_for_thread(Thread* thr) const {\n-   guarantee(thr != nullptr, \"No thread\");\n-   int lgrp_id = thr->lgrp_id();\n-   ...\n- }\n+ MutableNUMASpace::LGRPSpace *MutableNUMASpace::lgrp_space_for_current_thread() const {\n+   const int lgrp_id = os::numa_get_group_id();\n+   ...\n+ }", "target": "1. 移除线程创建时的lgrp_id更新：\n- if (UseNUMA) {\n-   thread->update_lgrp_id();\n- }\n\n2. 修改TLAB计算方法（从基于线程改为基于平均值）：\n- size_t MutableNUMASpace::tlab_capacity(Thread *thr) const {\n-   return lgrp_space_for_thread(thr)->space()->capacity_in_bytes();\n- }\n+ size_t MutableNUMASpace::tlab_capacity(Thread *ignored) const {\n+   size_t s = 0;\n+   for (LGRPSpace* ls : *lgrp_spaces()) {\n+     s += ls->space()->capacity_in_bytes();\n+   }\n+   return s / (size_t)lgrp_spaces()->length();\n+ }\n\n3. 简化lgrp_space查找逻辑：\n- MutableNUMASpace::LGRPSpace *MutableNUMASpace::lgrp_space_for_thread(Thread* thr) const {\n-   guarantee(thr != nullptr, \"No thread\");\n-   int lgrp_id = thr->lgrp_id();\n-   ...\n- }\n+ MutableNUMASpace::LGRPSpace *MutableNUMASpace::lgrp_space_for_current_thread() const {\n+   const int lgrp_id = os::numa_get_group_id();\n+   ...\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 每个线程创建时都调用update_lgrp_id()更新NUMA节点ID，增加了线程创建开销；2. TLAB容量计算基于单个线程的NUMA节点，可能导致负载不均衡；3. 需要维护线程的lgrp_id状态。\n\n优化后：1. 移除线程创建时的lgrp_id更新调用，减少开销；2. TLAB容量/使用量/最大分配计算改为所有NUMA节点的平均值，实现更均衡的内存分配；3. 直接从操作系统获取当前线程的NUMA节点ID，简化状态管理。\n\n优化思路：通过平均化NUMA节点的TLAB计算，避免热点节点过载，同时移除不必要的线程状态更新，减少开销，提高并行GC在NUMA系统下的性能。"}
{"id": 146, "source": "riscv-dataset-excel", "optimization_type": "启动性能优化+内存分配优化", "optimization_description": "优化前：在JVM启动阶段（初始化未完成时），内存分配请求只能等待或失败，因为此时无法执行垃圾回收。优化后：在启动阶段检测到内存分配失败时，直接尝试堆扩展来满足分配请求，避免不必要的等待。同时将expand_heap_and_allocate方法的断言从要求安全点改为要求堆锁，使其能在非安全点调用。优化思路：通过堆扩展机制在启动阶段提供更灵活的内存分配策略，提升启动性能和内存分配成功率。", "original_code": "在JVM启动阶段（初始化未完成时），内存分配请求只能等待或失败，因为此时无法执行垃圾回收。", "optimized_code": "@@ -324,6 +325,14 @@ HeapWord* ParallelScavengeHeap::mem_allocate_work(size_t size, bool is_tlab) {\n         return result;\n       }\n \n+      if (!is_init_completed()) {\n+        // Can't do GC; try heap expansion to satisfy the request.\n+        result = expand_heap_and_allocate(size, is_tlab);\n+        if (result != nullptr) {\n+          return result;\n+        }\n+      }\n+\n       gc_count = total_collections();\n     }\n \n@@ -394,8 +403,8 @@ bool ParallelScavengeHeap::check_gc_overhead_limit() {\n }\n \n HeapWord* ParallelScavengeHeap::expand_heap_and_allocate(size_t size, bool is_tlab) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n-  // We just finished a young/full gc, try everything to satisfy this allocation request.\n+  assert(Heap_lock->is_locked(), \"precondition\");", "source_url": "https://github.com/openjdk/riscv-port/commit/67a81c476f1e3c0d6aeca0d0aa2148efcb70a180", "code_v0_no_empty_lines": "在JVM启动阶段（初始化未完成时），内存分配请求只能等待或失败，因为此时无法执行垃圾回收。", "code_v1_no_empty_lines": "@@ -324,6 +325,14 @@ HeapWord* ParallelScavengeHeap::mem_allocate_work(size_t size, bool is_tlab) {\n         return result;\n       }\n \n+      if (!is_init_completed()) {\n+        // Can't do GC; try heap expansion to satisfy the request.\n+        result = expand_heap_and_allocate(size, is_tlab);\n+        if (result != nullptr) {\n+          return result;\n+        }\n+      }\n+\n       gc_count = total_collections();\n     }\n \n@@ -394,8 +403,8 @@ bool ParallelScavengeHeap::check_gc_overhead_limit() {\n }\n \n HeapWord* ParallelScavengeHeap::expand_heap_and_allocate(size_t size, bool is_tlab) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n-  // We just finished a young/full gc, try everything to satisfy this allocation request.\n+  assert(Heap_lock->is_locked(), \"precondition\");", "target": "@@ -324,6 +325,14 @@ HeapWord* ParallelScavengeHeap::mem_allocate_work(size_t size, bool is_tlab) {\n         return result;\n       }\n \n+      if (!is_init_completed()) {\n+        // Can't do GC; try heap expansion to satisfy the request.\n+        result = expand_heap_and_allocate(size, is_tlab);\n+        if (result != nullptr) {\n+          return result;\n+        }\n+      }\n+\n       gc_count = total_collections();\n     }\n \n@@ -394,8 +403,8 @@ bool ParallelScavengeHeap::check_gc_overhead_limit() {\n }\n \n HeapWord* ParallelScavengeHeap::expand_heap_and_allocate(size_t size, bool is_tlab) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n-  // We just finished a young/full gc, try everything to satisfy this allocation request.\n+  assert(Heap_lock->is_locked(), \"precondition\");", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在JVM启动阶段（初始化未完成时），内存分配请求只能等待或失败，因为此时无法执行垃圾回收。优化后：在启动阶段检测到内存分配失败时，直接尝试堆扩展来满足分配请求，避免不必要的等待。同时将expand_heap_and_allocate方法的断言从要求安全点改为要求堆锁，使其能在非安全点调用。优化思路：通过堆扩展机制在启动阶段提供更灵活的内存分配策略，提升启动性能和内存分配成功率。"}
{"id": 147, "source": "riscv-dataset-excel", "optimization_type": "内联优化", "optimization_description": "优化前：fill_with_object和fill_with_objects方法通过DEBUG_ONLY宏调用独立的fill_args_check函数进行参数检查，存在函数调用开销。优化后：将fill_args_check函数内联到调用点，直接使用assert语句进行参数检查，消除了函数调用开销。优化思路：通过内联消除小型检查函数的调用开销，提高运行时性能，同时保持相同的断言检查功能。", "original_code": "fill_with_object和fill_with_objects方法通过DEBUG_ONLY宏调用独立的fill_args_check函数进行参数检查，存在函数调用开销。", "optimized_code": "-  DEBUG_ONLY(fill_args_check(start, words);)\n+  assert(words >= min_fill_size(), \"too small to fill\");\n+  assert(is_object_aligned(words), \"unaligned size\");", "source_url": "https://github.com/openjdk/riscv-port/commit/4913b548a79a981816718def38d059b5175f6f59", "code_v0_no_empty_lines": "fill_with_object和fill_with_objects方法通过DEBUG_ONLY宏调用独立的fill_args_check函数进行参数检查，存在函数调用开销。", "code_v1_no_empty_lines": "-  DEBUG_ONLY(fill_args_check(start, words);)\n+  assert(words >= min_fill_size(), \"too small to fill\");\n+  assert(is_object_aligned(words), \"unaligned size\");", "target": "-  DEBUG_ONLY(fill_args_check(start, words);)\n+  assert(words >= min_fill_size(), \"too small to fill\");\n+  assert(is_object_aligned(words), \"unaligned size\");", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：fill_with_object和fill_with_objects方法通过DEBUG_ONLY宏调用独立的fill_args_check函数进行参数检查，存在函数调用开销。优化后：将fill_args_check函数内联到调用点，直接使用assert语句进行参数检查，消除了函数调用开销。优化思路：通过内联消除小型检查函数的调用开销，提高运行时性能，同时保持相同的断言检查功能。"}
{"id": 148, "source": "riscv-dataset-excel", "optimization_type": "算术表达式优化", "optimization_description": "优化前：表达式 (con0 - X) << con1 需要先计算减法再左移，涉及两个操作。优化后：转换为 (con0 << con1) - (X << con1)，将常量左移提前计算，减少运行时计算量。优化思路：利用算术变换将常量计算提前，减少指令数量，同时避免破坏 i2s/i2b 等模式折叠。", "original_code": "表达式 (con0 - X) << con1 需要先计算减法再左移，涉及两个操作。", "optimized_code": "// Check for \"(con0 - X) << con1\"\n// Transform is legal, but check for profit.  Avoid breaking 'i2s'\n// and 'i2b' patterns which typically fold into 'StoreC/StoreB'.\nif (add1_op == Op_Sub(bt) && (bt != T_INT || con < 16)) {    // Left input is a sub?\n    // Left input is a sub from a constant?\n    const TypeInteger* t11 = phase->type(add1->in(1))->isa_integer(bt);\n    if (t11 != nullptr && t11->is_con()) {\n        // Compute X << con0\n        Node* lsh = phase->transform(LShiftNode::make(add1->in(2), in(2), bt));\n        // Compute (con1<<con0) - (X<<con0)\n        return SubNode::make(phase->integercon(java_shift_left(t11->get_con_as_long(bt), con, bt), bt), lsh, bt);\n    }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/80fcfaf41aa2d6af30f15877e4466647dbca424e", "code_v0_no_empty_lines": "表达式 (con0 - X) << con1 需要先计算减法再左移，涉及两个操作。", "code_v1_no_empty_lines": "// Check for \"(con0 - X) << con1\"\n// Transform is legal, but check for profit.  Avoid breaking 'i2s'\n// and 'i2b' patterns which typically fold into 'StoreC/StoreB'.\nif (add1_op == Op_Sub(bt) && (bt != T_INT || con < 16)) {    // Left input is a sub?\n    // Left input is a sub from a constant?\n    const TypeInteger* t11 = phase->type(add1->in(1))->isa_integer(bt);\n    if (t11 != nullptr && t11->is_con()) {\n        // Compute X << con0\n        Node* lsh = phase->transform(LShiftNode::make(add1->in(2), in(2), bt));\n        // Compute (con1<<con0) - (X<<con0)\n        return SubNode::make(phase->integercon(java_shift_left(t11->get_con_as_long(bt), con, bt), bt), lsh, bt);\n    }\n}", "target": "// Check for \"(con0 - X) << con1\"\n// Transform is legal, but check for profit.  Avoid breaking 'i2s'\n// and 'i2b' patterns which typically fold into 'StoreC/StoreB'.\nif (add1_op == Op_Sub(bt) && (bt != T_INT || con < 16)) {    // Left input is a sub?\n    // Left input is a sub from a constant?\n    const TypeInteger* t11 = phase->type(add1->in(1))->isa_integer(bt);\n    if (t11 != nullptr && t11->is_con()) {\n        // Compute X << con0\n        Node* lsh = phase->transform(LShiftNode::make(add1->in(2), in(2), bt));\n        // Compute (con1<<con0) - (X<<con0)\n        return SubNode::make(phase->integercon(java_shift_left(t11->get_con_as_long(bt), con, bt), bt), lsh, bt);\n    }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：表达式 (con0 - X) << con1 需要先计算减法再左移，涉及两个操作。优化后：转换为 (con0 << con1) - (X << con1)，将常量左移提前计算，减少运行时计算量。优化思路：利用算术变换将常量计算提前，减少指令数量，同时避免破坏 i2s/i2b 等模式折叠。"}
{"id": 149, "source": "riscv-dataset-excel", "optimization_type": "内存安全优化", "optimization_description": "优化前：AES-GCM向量内在函数在加载密钥时可能读取越界内存，存在内存安全风险。优化后：1. 新增check_key_offset函数，在ASSERT模式下检查密钥偏移量是否超出数组边界；2. 在所有load_key和ev_load_key函数调用前插入边界检查；3. 调整ghash16_encrypt_parallel16_avx512中密钥加载顺序，确保检查在正确位置执行。优化思路：通过运行时边界检查防止越界读取，同时保持检查代码紧凑以最小化性能影响，修复了8370318号bug中报告的AVX-512下AES-GCM向量内在函数的安全漏洞。", "original_code": "AES-GCM向量内在函数在加载密钥时可能读取越界内存，存在内存安全风险。", "optimized_code": "+void StubGenerator::check_key_offset(Register key, int offset, int load_size) {\n+#ifdef ASSERT\n+  Address key_length(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT));\n+  assert((offset + load_size) % 4 == 0, \"Alignment is good: %d + %d\", offset, load_size);\n+  int end_offset = (offset + load_size) / 4;\n+  Label L_good;\n+  __ cmpl(key_length, end_offset);\n+  __ jccb(Assembler::greaterEqual, L_good);\n+  __ hlt();\n+  __ bind(L_good);\n+#endif\n+}\n\n void StubGenerator::load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask) {\n+  check_key_offset(key, offset, 16);\n   __ movdqu(xmmdst, Address(key, offset));\n   __ pshufb(xmmdst, xmm_shuf_mask);\n }\n\n void StubGenerator::load_key(XMMRegister xmmdst, Register key, int offset, Register rscratch) {\n+  check_key_offset(key, offset, 16);\n   __ movdqu(xmmdst, Address(key, offset));\n   __ pshufb(xmmdst, ExternalAddress(key_shuffle_mask_addr()), rscratch);\n }\n\n void StubGenerator::ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask) {\n+  check_key_offset(key, offset, 16);\n   __ movdqu(xmmdst, Address(key, offset));\n   __ pshufb(xmmdst, xmm_shuf_mask);\n   __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n }\n\n void StubGenerator::ev_load_key(XMMRegister xmmdst, Register key, int offset, Register rscratch) {\n+  check_key_offset(key, offset, 16);\n   __ movdqu(xmmdst, Address(key, offset));\n   __ pshufb(xmmdst, ExternalAddress(key_shuffle_mask_addr()), rscratch);\n   __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n }\n\n@@ -3205,12 +3223,12 @@ void StubGenerator::ghash16_encrypt_parallel16_avx512(Register in, Register out,\n \n   //AES round 9\n   roundEncode(AESKEY2, B00_03, B04_07, B08_11, B12_15);\n-  ev_load_key(AESKEY2, key, 11 * 16, rbx);\n   //AES rounds up to 11 (AES192) or 13 (AES256)\n   //AES128 is done\n   __ cmpl(NROUNDS, 52);\n   __ jcc(Assembler::less, last_aes_rnd);\n   __ bind(aes_192);\n+  ev_load_key(AESKEY2, key, 11 * 16, rbx);", "source_url": "https://github.com/openjdk/riscv-port/commit/7bb490c4bf7ae55547e4468da0795dac0a873d2b", "code_v0_no_empty_lines": "AES-GCM向量内在函数在加载密钥时可能读取越界内存，存在内存安全风险。", "code_v1_no_empty_lines": "+void StubGenerator::check_key_offset(Register key, int offset, int load_size) {\n+#ifdef ASSERT\n+  Address key_length(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT));\n+  assert((offset + load_size) % 4 == 0, \"Alignment is good: %d + %d\", offset, load_size);\n+  int end_offset = (offset + load_size) / 4;\n+  Label L_good;\n+  __ cmpl(key_length, end_offset);\n+  __ jccb(Assembler::greaterEqual, L_good);\n+  __ hlt();\n+  __ bind(L_good);\n+#endif\n+}\n\n void StubGenerator::load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask) {\n+  check_key_offset(key, offset, 16);\n   __ movdqu(xmmdst, Address(key, offset));\n   __ pshufb(xmmdst, xmm_shuf_mask);\n }\n\n void StubGenerator::load_key(XMMRegister xmmdst, Register key, int offset, Register rscratch) {\n+  check_key_offset(key, offset, 16);\n   __ movdqu(xmmdst, Address(key, offset));\n   __ pshufb(xmmdst, ExternalAddress(key_shuffle_mask_addr()), rscratch);\n }\n\n void StubGenerator::ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask) {\n+  check_key_offset(key, offset, 16);\n   __ movdqu(xmmdst, Address(key, offset));\n   __ pshufb(xmmdst, xmm_shuf_mask);\n   __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n }\n\n void StubGenerator::ev_load_key(XMMRegister xmmdst, Register key, int offset, Register rscratch) {\n+  check_key_offset(key, offset, 16);\n   __ movdqu(xmmdst, Address(key, offset));\n   __ pshufb(xmmdst, ExternalAddress(key_shuffle_mask_addr()), rscratch);\n   __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n }\n\n@@ -3205,12 +3223,12 @@ void StubGenerator::ghash16_encrypt_parallel16_avx512(Register in, Register out,\n \n   //AES round 9\n   roundEncode(AESKEY2, B00_03, B04_07, B08_11, B12_15);\n-  ev_load_key(AESKEY2, key, 11 * 16, rbx);\n   //AES rounds up to 11 (AES192) or 13 (AES256)\n   //AES128 is done\n   __ cmpl(NROUNDS, 52);\n   __ jcc(Assembler::less, last_aes_rnd);\n   __ bind(aes_192);\n+  ev_load_key(AESKEY2, key, 11 * 16, rbx);", "target": "+void StubGenerator::check_key_offset(Register key, int offset, int load_size) {\n+#ifdef ASSERT\n+  Address key_length(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT));\n+  assert((offset + load_size) % 4 == 0, \"Alignment is good: %d + %d\", offset, load_size);\n+  int end_offset = (offset + load_size) / 4;\n+  Label L_good;\n+  __ cmpl(key_length, end_offset);\n+  __ jccb(Assembler::greaterEqual, L_good);\n+  __ hlt();\n+  __ bind(L_good);\n+#endif\n+}\n\n void StubGenerator::load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask) {\n+  check_key_offset(key, offset, 16);\n   __ movdqu(xmmdst, Address(key, offset));\n   __ pshufb(xmmdst, xmm_shuf_mask);\n }\n\n void StubGenerator::load_key(XMMRegister xmmdst, Register key, int offset, Register rscratch) {\n+  check_key_offset(key, offset, 16);\n   __ movdqu(xmmdst, Address(key, offset));\n   __ pshufb(xmmdst, ExternalAddress(key_shuffle_mask_addr()), rscratch);\n }\n\n void StubGenerator::ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask) {\n+  check_key_offset(key, offset, 16);\n   __ movdqu(xmmdst, Address(key, offset));\n   __ pshufb(xmmdst, xmm_shuf_mask);\n   __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n }\n\n void StubGenerator::ev_load_key(XMMRegister xmmdst, Register key, int offset, Register rscratch) {\n+  check_key_offset(key, offset, 16);\n   __ movdqu(xmmdst, Address(key, offset));\n   __ pshufb(xmmdst, ExternalAddress(key_shuffle_mask_addr()), rscratch);\n   __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n }\n\n@@ -3205,12 +3223,12 @@ void StubGenerator::ghash16_encrypt_parallel16_avx512(Register in, Register out,\n \n   //AES round 9\n   roundEncode(AESKEY2, B00_03, B04_07, B08_11, B12_15);\n-  ev_load_key(AESKEY2, key, 11 * 16, rbx);\n   //AES rounds up to 11 (AES192) or 13 (AES256)\n   //AES128 is done\n   __ cmpl(NROUNDS, 52);\n   __ jcc(Assembler::less, last_aes_rnd);\n   __ bind(aes_192);\n+  ev_load_key(AESKEY2, key, 11 * 16, rbx);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AES-GCM向量内在函数在加载密钥时可能读取越界内存，存在内存安全风险。优化后：1. 新增check_key_offset函数，在ASSERT模式下检查密钥偏移量是否超出数组边界；2. 在所有load_key和ev_load_key函数调用前插入边界检查；3. 调整ghash16_encrypt_parallel16_avx512中密钥加载顺序，确保检查在正确位置执行。优化思路：通过运行时边界检查防止越界读取，同时保持检查代码紧凑以最小化性能影响，修复了8370318号bug中报告的AVX-512下AES-GCM向量内在函数的安全漏洞。"}
{"id": 150, "source": "riscv-dataset-excel", "optimization_type": "编译策略优化", "optimization_description": "优化前：对于lukewarm方法（在训练运行期间未被C2编译，当前运行在级别2），通过standard_transition函数的delay_profiling参数统一延迟状态转换。优化后：引入should_delay_standard_transition函数，根据方法训练数据（MethodTrainingData）中的调用计数和回边计数，仅在当前计数器未超过训练运行计数时延迟状态转换。优化思路：更精确地控制lukewarm方法的编译延迟，避免不必要的编译开销，同时确保在方法行为发生变化时能及时触发重新编译。", "original_code": "对于lukewarm方法（在训练运行期间未被C2编译，当前运行在级别2），通过standard_transition函数的delay_profiling参数统一延迟状态转换。", "optimized_code": "- next_level = standard_transition<Predicate>(method, cur_level, true /*delay_profiling*/, disable_feedback);\n+ next_level = standard_transition<Predicate>(method, cur_level, disable_feedback);\n+bool CompilationPolicy::should_delay_standard_transition(const methodHandle& method, CompLevel cur_level, MethodTrainingData* mtd) {\n+  // This is a lukewarm method - it hasn't been compiled with C2 during the training run and is currently\n+  // running at level 2. Delay any further state changes until its counters exceed the training run counts.", "source_url": "https://github.com/openjdk/riscv-port/commit/1e49376ece39e8f9b5c72b58688b1e195a0014be", "code_v0_no_empty_lines": "对于lukewarm方法（在训练运行期间未被C2编译，当前运行在级别2），通过standard_transition函数的delay_profiling参数统一延迟状态转换。", "code_v1_no_empty_lines": "- next_level = standard_transition<Predicate>(method, cur_level, true /*delay_profiling*/, disable_feedback);\n+ next_level = standard_transition<Predicate>(method, cur_level, disable_feedback);\n+bool CompilationPolicy::should_delay_standard_transition(const methodHandle& method, CompLevel cur_level, MethodTrainingData* mtd) {\n+  // This is a lukewarm method - it hasn't been compiled with C2 during the training run and is currently\n+  // running at level 2. Delay any further state changes until its counters exceed the training run counts.", "target": "- next_level = standard_transition<Predicate>(method, cur_level, true /*delay_profiling*/, disable_feedback);\n+ next_level = standard_transition<Predicate>(method, cur_level, disable_feedback);\n+bool CompilationPolicy::should_delay_standard_transition(const methodHandle& method, CompLevel cur_level, MethodTrainingData* mtd) {\n+  // This is a lukewarm method - it hasn't been compiled with C2 during the training run and is currently\n+  // running at level 2. Delay any further state changes until its counters exceed the training run counts.", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于lukewarm方法（在训练运行期间未被C2编译，当前运行在级别2），通过standard_transition函数的delay_profiling参数统一延迟状态转换。优化后：引入should_delay_standard_transition函数，根据方法训练数据（MethodTrainingData）中的调用计数和回边计数，仅在当前计数器未超过训练运行计数时延迟状态转换。优化思路：更精确地控制lukewarm方法的编译延迟，避免不必要的编译开销，同时确保在方法行为发生变化时能及时触发重新编译。"}
{"id": 151, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化+原子操作优化", "optimization_description": "优化前：队列操作使用原子操作（load_acquire、cmpxchg）和内存屏障确保多线程安全，但带来额外开销。优化后：利用JfrThreadLocal中的三态CPU时间JFR锁作为内存屏障，移除大部分原子操作和内存屏障，仅保留_lost_samples的原子访问（可在未获取锁时访问）。优化思路：通过锁机制保证内存可见性，简化并发控制，提升CPU时间分析器的性能。", "original_code": "队列操作使用原子操作（load_acquire、cmpxchg）和内存屏障确保多线程安全，但带来额外开销。", "optimized_code": "-  do {\n-    elementIndex = AtomicAccess::load_acquire(&_head);\n-    if (elementIndex >= _capacity) {\n-      return false;\n-    }\n-  } while (AtomicAccess::cmpxchg(&_head, elementIndex, elementIndex + 1) != elementIndex);\n-  _data[elementIndex] = request;\n+  _data[_head++] = request;", "source_url": "https://github.com/openjdk/riscv-port/commit/b7a4c9ced82717434e43b3f3a0a57083f4005f32", "code_v0_no_empty_lines": "队列操作使用原子操作（load_acquire、cmpxchg）和内存屏障确保多线程安全，但带来额外开销。", "code_v1_no_empty_lines": "-  do {\n-    elementIndex = AtomicAccess::load_acquire(&_head);\n-    if (elementIndex >= _capacity) {\n-      return false;\n-    }\n-  } while (AtomicAccess::cmpxchg(&_head, elementIndex, elementIndex + 1) != elementIndex);\n-  _data[elementIndex] = request;\n+  _data[_head++] = request;", "target": "-  do {\n-    elementIndex = AtomicAccess::load_acquire(&_head);\n-    if (elementIndex >= _capacity) {\n-      return false;\n-    }\n-  } while (AtomicAccess::cmpxchg(&_head, elementIndex, elementIndex + 1) != elementIndex);\n-  _data[elementIndex] = request;\n+  _data[_head++] = request;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：队列操作使用原子操作（load_acquire、cmpxchg）和内存屏障确保多线程安全，但带来额外开销。优化后：利用JfrThreadLocal中的三态CPU时间JFR锁作为内存屏障，移除大部分原子操作和内存屏障，仅保留_lost_samples的原子访问（可在未获取锁时访问）。优化思路：通过锁机制保证内存可见性，简化并发控制，提升CPU时间分析器的性能。"}
{"id": 152, "source": "riscv-dataset-excel", "optimization_type": "字符串处理优化+内存分配优化", "optimization_description": "优化前：使用StringBuilder和正则表达式处理十六进制字符串，涉及临时字符串创建和正则匹配开销。优化后：预先计算输出长度，直接操作字节数组，手动转换十六进制数字，避免正则表达式和StringBuilder。优化思路：消除正则匹配和中间字符串分配，通过精确长度预分配和直接字符操作提升性能。", "original_code": "使用StringBuilder和正则表达式处理十六进制字符串，涉及临时字符串创建和正则匹配开销。", "optimized_code": "- StringBuilder answer = new StringBuilder(24);\n- String signif = Long.toHexString(signifBits).substring(3,16);\n- answer.append(signif.equals(\"0000000000000\") ? \"0\": signif.replaceFirst(\"0{1,12}$\", \"\"));\n+ int charlen = (negative ? 1 : 0) + 4 + 13 - trailingZeros + 1 + DecimalDigits.stringSize(exp);\n+ byte[] chars = new byte[charlen];\n+ for (int sh = 4 * 12, end = 4 * trailingZeros; sh >= end; sh -= 4) {\n+     chars[index++] = Integer.digits[((int)(signifBits >> sh)) & 0xF];\n+ }\n+ DecimalDigits.uncheckedGetCharsLatin1(exp, charlen, chars);\n+ return String.newStringWithLatin1Bytes(chars);", "source_url": "https://github.com/openjdk/riscv-port/commit/586235896536cde293402167775d4d60f1426a9e", "code_v0_no_empty_lines": "使用StringBuilder和正则表达式处理十六进制字符串，涉及临时字符串创建和正则匹配开销。", "code_v1_no_empty_lines": "- StringBuilder answer = new StringBuilder(24);\n- String signif = Long.toHexString(signifBits).substring(3,16);\n- answer.append(signif.equals(\"0000000000000\") ? \"0\": signif.replaceFirst(\"0{1,12}$\", \"\"));\n+ int charlen = (negative ? 1 : 0) + 4 + 13 - trailingZeros + 1 + DecimalDigits.stringSize(exp);\n+ byte[] chars = new byte[charlen];\n+ for (int sh = 4 * 12, end = 4 * trailingZeros; sh >= end; sh -= 4) {\n+     chars[index++] = Integer.digits[((int)(signifBits >> sh)) & 0xF];\n+ }\n+ DecimalDigits.uncheckedGetCharsLatin1(exp, charlen, chars);\n+ return String.newStringWithLatin1Bytes(chars);", "target": "- StringBuilder answer = new StringBuilder(24);\n- String signif = Long.toHexString(signifBits).substring(3,16);\n- answer.append(signif.equals(\"0000000000000\") ? \"0\": signif.replaceFirst(\"0{1,12}$\", \"\"));\n+ int charlen = (negative ? 1 : 0) + 4 + 13 - trailingZeros + 1 + DecimalDigits.stringSize(exp);\n+ byte[] chars = new byte[charlen];\n+ for (int sh = 4 * 12, end = 4 * trailingZeros; sh >= end; sh -= 4) {\n+     chars[index++] = Integer.digits[((int)(signifBits >> sh)) & 0xF];\n+ }\n+ DecimalDigits.uncheckedGetCharsLatin1(exp, charlen, chars);\n+ return String.newStringWithLatin1Bytes(chars);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用StringBuilder和正则表达式处理十六进制字符串，涉及临时字符串创建和正则匹配开销。优化后：预先计算输出长度，直接操作字节数组，手动转换十六进制数字，避免正则表达式和StringBuilder。优化思路：消除正则匹配和中间字符串分配，通过精确长度预分配和直接字符操作提升性能。"}
{"id": 153, "source": "riscv-dataset-excel", "optimization_type": "加密算法实现优化", "optimization_description": "优化前使用旧的AESCrypt类实现AES加密算法。优化后替换为新的AES_Crypt类实现，该实现遵循FIPS 197标准更新，提供更标准、更高效的AES加密算法实现。优化思路是通过更新底层加密算法实现来提升加密性能和标准合规性，同时保持API兼容性。", "original_code": "// No original code extracted from description\n", "optimized_code": "- do_class(com_sun_crypto_provider_aescrypt, \"com/sun/crypto/provider/AESCrypt\")\n+ do_class(com_sun_crypto_provider_aescrypt, \"com/sun/crypto/provider/AES_Crypt\")\n- ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com/sun/crypto/provider/AESCrypt\"));\n+ ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com/sun/crypto/provider/AES_Crypt\"));", "source_url": "https://github.com/openjdk/riscv-port/commit/62f11cd4070f21ad82eebbb5319bdbbf4e13f9cf", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- do_class(com_sun_crypto_provider_aescrypt, \"com/sun/crypto/provider/AESCrypt\")\n+ do_class(com_sun_crypto_provider_aescrypt, \"com/sun/crypto/provider/AES_Crypt\")\n- ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com/sun/crypto/provider/AESCrypt\"));\n+ ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com/sun/crypto/provider/AES_Crypt\"));", "target": "- do_class(com_sun_crypto_provider_aescrypt, \"com/sun/crypto/provider/AESCrypt\")\n+ do_class(com_sun_crypto_provider_aescrypt, \"com/sun/crypto/provider/AES_Crypt\")\n- ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com/sun/crypto/provider/AESCrypt\"));\n+ ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com/sun/crypto/provider/AES_Crypt\"));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用旧的AESCrypt类实现AES加密算法。优化后替换为新的AES_Crypt类实现，该实现遵循FIPS 197标准更新，提供更标准、更高效的AES加密算法实现。优化思路是通过更新底层加密算法实现来提升加密性能和标准合规性，同时保持API兼容性。"}
{"id": 154, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前：在JavaFrameAnchor的clear()、set()、copy()和set_last_Java_sp()方法中，对volatile成员变量的读写操作前后都插入了OrderAccess::release()和OrderAccess::fence()内存屏障指令，以确保内存可见性和顺序一致性。优化后：移除了所有OrderAccess::release()和OrderAccess::fence()调用，并添加了注释说明原因。优化思路：由于所有相关成员变量（_last_Java_sp和_last_Java_pc）都已声明为volatile，且分析器（profiler）仅在信号处理器中运行并仅观察其所在线程，因此硬件内存屏障是不必要的。移除这些屏障可以减少指令开销，提升性能，特别是在s390架构上。", "original_code": "在JavaFrameAnchor的clear()、set()、copy()和set_last_Java_sp()方法中，对volatile成员变量的读写操作前后都插入了OrderAccess::release()和OrderAccess::fence()内存屏障指令，以确保内存可见性和顺序一致性。", "optimized_code": "-    OrderAccess::release();\n-    OrderAccess::fence();\n+    // No hardware barriers are necessary. All members are volatile and the profiler\n+    // is run from a signal handler and only observers the thread its running on.", "source_url": "https://github.com/openjdk/riscv-port/commit/87645afa052a87ab2af9602c8fafc2a707c77c19", "code_v0_no_empty_lines": "在JavaFrameAnchor的clear()、set()、copy()和set_last_Java_sp()方法中，对volatile成员变量的读写操作前后都插入了OrderAccess::release()和OrderAccess::fence()内存屏障指令，以确保内存可见性和顺序一致性。", "code_v1_no_empty_lines": "-    OrderAccess::release();\n-    OrderAccess::fence();\n+    // No hardware barriers are necessary. All members are volatile and the profiler\n+    // is run from a signal handler and only observers the thread its running on.", "target": "-    OrderAccess::release();\n-    OrderAccess::fence();\n+    // No hardware barriers are necessary. All members are volatile and the profiler\n+    // is run from a signal handler and only observers the thread its running on.", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在JavaFrameAnchor的clear()、set()、copy()和set_last_Java_sp()方法中，对volatile成员变量的读写操作前后都插入了OrderAccess::release()和OrderAccess::fence()内存屏障指令，以确保内存可见性和顺序一致性。优化后：移除了所有OrderAccess::release()和OrderAccess::fence()调用，并添加了注释说明原因。优化思路：由于所有相关成员变量（_last_Java_sp和_last_Java_pc）都已声明为volatile，且分析器（profiler）仅在信号处理器中运行并仅观察其所在线程，因此硬件内存屏障是不必要的。移除这些屏障可以减少指令开销，提升性能，特别是在s390架构上。"}
{"id": 155, "source": "riscv-dataset-excel", "optimization_type": "GC策略优化", "optimization_description": "优化前：TLAB分配失败时会触发GC，可能导致UseGCOverheadLimit机制失效（GC可能释放空间，使后续分配成功，掩盖了开销超限问题）。优化后：为allocate_new_tlab()添加allow_gc=false参数，禁止在TLAB分配时触发GC；mem_allocate()保持allow_gc=true。思路：分离分配策略，TLAB分配失败时直接返回null，由后续mem_allocate()处理GC，确保开销限制检测准确。", "original_code": "TLAB分配失败时会触发GC，可能导致UseGCOverheadLimit机制失效（GC可能释放空间，使后续分配成功，掩盖了开销超限问题）。", "optimized_code": "- return attempt_allocation(min_size, requested_size, actual_size);\n+ return attempt_allocation(min_size, requested_size, actual_size, false /* allow_gc */);\n- return attempt_allocation(word_size, word_size, &dummy);\n+ return attempt_allocation(word_size, word_size, &dummy, true /* allow_gc */);\n- result = attempt_allocation_slow(node_index, desired_word_size);\n+ result = attempt_allocation_slow(node_index, desired_word_size, allow_gc);\n- HeapWord* attempt_allocation_slow(uint node_index, size_t word_size) {\n+ HeapWord* attempt_allocation_slow(uint node_index, size_t word_size, bool allow_gc) {\n+ } else if (!allow_gc) {\n+   return nullptr;\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/027aea9d2e0dff29fcd00fa7074ca955066929ec", "code_v0_no_empty_lines": "TLAB分配失败时会触发GC，可能导致UseGCOverheadLimit机制失效（GC可能释放空间，使后续分配成功，掩盖了开销超限问题）。", "code_v1_no_empty_lines": "- return attempt_allocation(min_size, requested_size, actual_size);\n+ return attempt_allocation(min_size, requested_size, actual_size, false /* allow_gc */);\n- return attempt_allocation(word_size, word_size, &dummy);\n+ return attempt_allocation(word_size, word_size, &dummy, true /* allow_gc */);\n- result = attempt_allocation_slow(node_index, desired_word_size);\n+ result = attempt_allocation_slow(node_index, desired_word_size, allow_gc);\n- HeapWord* attempt_allocation_slow(uint node_index, size_t word_size) {\n+ HeapWord* attempt_allocation_slow(uint node_index, size_t word_size, bool allow_gc) {\n+ } else if (!allow_gc) {\n+   return nullptr;\n+ }", "target": "- return attempt_allocation(min_size, requested_size, actual_size);\n+ return attempt_allocation(min_size, requested_size, actual_size, false /* allow_gc */);\n- return attempt_allocation(word_size, word_size, &dummy);\n+ return attempt_allocation(word_size, word_size, &dummy, true /* allow_gc */);\n- result = attempt_allocation_slow(node_index, desired_word_size);\n+ result = attempt_allocation_slow(node_index, desired_word_size, allow_gc);\n- HeapWord* attempt_allocation_slow(uint node_index, size_t word_size) {\n+ HeapWord* attempt_allocation_slow(uint node_index, size_t word_size, bool allow_gc) {\n+ } else if (!allow_gc) {\n+   return nullptr;\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：TLAB分配失败时会触发GC，可能导致UseGCOverheadLimit机制失效（GC可能释放空间，使后续分配成功，掩盖了开销超限问题）。优化后：为allocate_new_tlab()添加allow_gc=false参数，禁止在TLAB分配时触发GC；mem_allocate()保持allow_gc=true。思路：分离分配策略，TLAB分配失败时直接返回null，由后续mem_allocate()处理GC，确保开销限制检测准确。"}
{"id": 156, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（C2编译器）", "optimization_description": "优化前：代码包含一个专门检查use->is_SafePoint()的条件分支，然后是一个空注释。优化后：移除了这个冗余的条件分支，将注释合并到else块中，简化了控制流。优化思路：通过消除不必要的分支减少代码复杂度和潜在的性能开销，同时保持相同的断言逻辑。", "original_code": "代码包含一个专门检查use->is_SafePoint()的条件分支，然后是一个空注释。", "optimized_code": "-    } else if (use->is_SafePoint()) {\n-      // processed later\n     } else {\n+      // Safepoints to be processed later; other users aren't expected here\n       assert(use->is_SafePoint(), \"Unexpected user of reducible Phi %d -> %d:%s:%d\", ophi->_idx, use->_idx, use->Name(), use->outcnt());\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/bdfd5e843a7d3db50edf4375e50449b0ce528f8a", "code_v0_no_empty_lines": "代码包含一个专门检查use->is_SafePoint()的条件分支，然后是一个空注释。", "code_v1_no_empty_lines": "-    } else if (use->is_SafePoint()) {\n-      // processed later\n     } else {\n+      // Safepoints to be processed later; other users aren't expected here\n       assert(use->is_SafePoint(), \"Unexpected user of reducible Phi %d -> %d:%s:%d\", ophi->_idx, use->_idx, use->Name(), use->outcnt());\n     }", "target": "-    } else if (use->is_SafePoint()) {\n-      // processed later\n     } else {\n+      // Safepoints to be processed later; other users aren't expected here\n       assert(use->is_SafePoint(), \"Unexpected user of reducible Phi %d -> %d:%s:%d\", ophi->_idx, use->_idx, use->Name(), use->outcnt());\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：代码包含一个专门检查use->is_SafePoint()的条件分支，然后是一个空注释。优化后：移除了这个冗余的条件分支，将注释合并到else块中，简化了控制流。优化思路：通过消除不必要的分支减少代码复杂度和潜在的性能开销，同时保持相同的断言逻辑。"}
{"id": 157, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码优化", "optimization_description": "优化前：RelocActions 是一个抽象基类，包含虚函数和成员变量，每次调用 run() 需要构造对象并产生虚函数调用开销。优化后：将 RelocActions 改为模板类并继承 AllStatic，所有方法变为静态方法，通过模板参数 T 调用具体实现（如 Patcher）。优化思路：通过去虚拟化（devirtualization）消除虚函数调用开销，将运行时多态改为编译时静态分发，提高热点代码的执行效率，同时减少对象构造开销。", "original_code": "RelocActions 是一个抽象基类，包含虚函数和成员变量，每次调用 run() 需要构造对象并产生虚函数调用开销。", "optimized_code": "class RelocActions {\n-protected:\n-  typedef int (*reloc_insn)(address insn_addr, address &target);\n-\n-  virtual reloc_insn adrpMem() = 0;\n-  virtual reloc_insn adrpAdd() = 0;\n-  virtual reloc_insn adrpMovk() = 0;\n-\n-  const address _insn_addr;\n-  const uint32_t _insn;\n+template<typename T>\n+class RelocActions : public AllStatic {\n \n public:\n \n-  RelocActions(address insn_addr) : _insn_addr(insn_addr), _insn(insn_at(insn_addr, 0)) {}\n-  RelocActions(address insn_addr, uint32_t insn)\n-    :  _insn_addr(insn_addr), _insn(insn) {}\n-\n-  virtual int unconditionalBranch(address insn_addr, address &target) = 0;\n-  virtual int conditionalBranch(address insn_addr, address &target) = 0;\n-  virtual int testAndBranch(address insn_addr, address &target) = 0;\n-  virtual int loadStore(address insn_addr, address &target) = 0;\n-  virtual int adr(address insn_addr, address &target) = 0;\n-  virtual int adrp(address insn_addr, address &target, reloc_insn inner) = 0;\n-  virtual int immediate(address insn_addr, address &target) = 0;\n-  virtual void verify(address insn_addr, address &target) = 0;\n-\n-  int ALWAYSINLINE run(address insn_addr, address &target) {\n+  static int ALWAYSINLINE run(address insn_addr, address &target) {\n     int instructions = 1;\n+    uint32_t insn = insn_at(insn_addr, 0);", "source_url": "https://github.com/openjdk/riscv-port/commit/9a88d7f468cdd040bdf4e1ff9441dc9c66eab03e", "code_v0_no_empty_lines": "RelocActions 是一个抽象基类，包含虚函数和成员变量，每次调用 run() 需要构造对象并产生虚函数调用开销。", "code_v1_no_empty_lines": "class RelocActions {\n-protected:\n-  typedef int (*reloc_insn)(address insn_addr, address &target);\n-\n-  virtual reloc_insn adrpMem() = 0;\n-  virtual reloc_insn adrpAdd() = 0;\n-  virtual reloc_insn adrpMovk() = 0;\n-\n-  const address _insn_addr;\n-  const uint32_t _insn;\n+template<typename T>\n+class RelocActions : public AllStatic {\n \n public:\n \n-  RelocActions(address insn_addr) : _insn_addr(insn_addr), _insn(insn_at(insn_addr, 0)) {}\n-  RelocActions(address insn_addr, uint32_t insn)\n-    :  _insn_addr(insn_addr), _insn(insn) {}\n-\n-  virtual int unconditionalBranch(address insn_addr, address &target) = 0;\n-  virtual int conditionalBranch(address insn_addr, address &target) = 0;\n-  virtual int testAndBranch(address insn_addr, address &target) = 0;\n-  virtual int loadStore(address insn_addr, address &target) = 0;\n-  virtual int adr(address insn_addr, address &target) = 0;\n-  virtual int adrp(address insn_addr, address &target, reloc_insn inner) = 0;\n-  virtual int immediate(address insn_addr, address &target) = 0;\n-  virtual void verify(address insn_addr, address &target) = 0;\n-\n-  int ALWAYSINLINE run(address insn_addr, address &target) {\n+  static int ALWAYSINLINE run(address insn_addr, address &target) {\n     int instructions = 1;\n+    uint32_t insn = insn_at(insn_addr, 0);", "target": "class RelocActions {\n-protected:\n-  typedef int (*reloc_insn)(address insn_addr, address &target);\n-\n-  virtual reloc_insn adrpMem() = 0;\n-  virtual reloc_insn adrpAdd() = 0;\n-  virtual reloc_insn adrpMovk() = 0;\n-\n-  const address _insn_addr;\n-  const uint32_t _insn;\n+template<typename T>\n+class RelocActions : public AllStatic {\n \n public:\n \n-  RelocActions(address insn_addr) : _insn_addr(insn_addr), _insn(insn_at(insn_addr, 0)) {}\n-  RelocActions(address insn_addr, uint32_t insn)\n-    :  _insn_addr(insn_addr), _insn(insn) {}\n-\n-  virtual int unconditionalBranch(address insn_addr, address &target) = 0;\n-  virtual int conditionalBranch(address insn_addr, address &target) = 0;\n-  virtual int testAndBranch(address insn_addr, address &target) = 0;\n-  virtual int loadStore(address insn_addr, address &target) = 0;\n-  virtual int adr(address insn_addr, address &target) = 0;\n-  virtual int adrp(address insn_addr, address &target, reloc_insn inner) = 0;\n-  virtual int immediate(address insn_addr, address &target) = 0;\n-  virtual void verify(address insn_addr, address &target) = 0;\n-\n-  int ALWAYSINLINE run(address insn_addr, address &target) {\n+  static int ALWAYSINLINE run(address insn_addr, address &target) {\n     int instructions = 1;\n+    uint32_t insn = insn_at(insn_addr, 0);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RelocActions 是一个抽象基类，包含虚函数和成员变量，每次调用 run() 需要构造对象并产生虚函数调用开销。优化后：将 RelocActions 改为模板类并继承 AllStatic，所有方法变为静态方法，通过模板参数 T 调用具体实现（如 Patcher）。优化思路：通过去虚拟化（devirtualization）消除虚函数调用开销，将运行时多态改为编译时静态分发，提高热点代码的执行效率，同时减少对象构造开销。"}
{"id": 158, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+大页支持修复", "optimization_description": "优化前：代码中存在对大页（UseLargePages）支持的错误计算逻辑，特别是在页面大小对齐和内存区域处理时，使用了不一致的alignment和page_size概念，导致在启用大页时可能计算出错误的页面大小和内存区域。\n优化后：统一使用page_size作为内存对齐和计算的基础，移除了与alignment相关的复杂逻辑，简化了bias_region、default_chunk_size和adaptive_chunk_size等函数的实现，确保在使用大页时能正确计算页面大小和内存区域。\n优化思路：修复8346005号bug，通过统一页面大小处理逻辑，消除alignment和page_size之间的混淆，提高内存管理的正确性和性能，特别是在NUMA环境下使用大页时的稳定性。", "original_code": "代码中存在对大页（UseLargePages）支持的错误计算逻辑，特别是在页面大小对齐和内存区域处理时，使用了不一致的alignment和page_size概念，导致在启用大页时可能计算出错误的页面大小和内存区域。", "optimized_code": "- MutableNUMASpace::MutableNUMASpace(size_t alignment) : MutableSpace(alignment), _must_use_large_pages(false) {\n+ MutableNUMASpace::MutableNUMASpace(size_t page_size) : MutableSpace(page_size) {\n-   _page_size = os::vm_page_size();\n- #ifdef LINUX\n-   // Changing the page size can lead to freeing of memory. When using large pages\n-   // and the memory has been both reserved and committed, Linux does not support\n-   // freeing parts of it.\n-     if (UseLargePages && !os::can_commit_large_page_memory()) {\n-       _must_use_large_pages = true;\n-     }\n- #endif // LINUX\n-     lgrp_spaces()->append(new LGRPSpace(lgrp_ids[i], alignment));\n+     lgrp_spaces()->append(new LGRPSpace(lgrp_ids[i], page_size));\n-   const size_t os_align = UseLargePages ? page_size() : os::vm_page_size();\n-   os::realign_memory((char*)aligned_region.start(), aligned_region.byte_size(), os_align);\n+   os::realign_memory((char*) mr.start(), mr.byte_size(), page_size());\n-   return base_space_size() / lgrp_spaces()->length() * page_size();\n+   return align_down(capacity_in_bytes() / lgrp_spaces()->length(), page_size());\n-   size_t pages_available = base_space_size();\n+   size_t pages_available = capacity_in_bytes() / page_size();", "source_url": "https://github.com/openjdk/riscv-port/commit/2be273f20f839980f22a74b88b74fc5754fa0c11", "code_v0_no_empty_lines": "代码中存在对大页（UseLargePages）支持的错误计算逻辑，特别是在页面大小对齐和内存区域处理时，使用了不一致的alignment和page_size概念，导致在启用大页时可能计算出错误的页面大小和内存区域。", "code_v1_no_empty_lines": "- MutableNUMASpace::MutableNUMASpace(size_t alignment) : MutableSpace(alignment), _must_use_large_pages(false) {\n+ MutableNUMASpace::MutableNUMASpace(size_t page_size) : MutableSpace(page_size) {\n-   _page_size = os::vm_page_size();\n- #ifdef LINUX\n-   // Changing the page size can lead to freeing of memory. When using large pages\n-   // and the memory has been both reserved and committed, Linux does not support\n-   // freeing parts of it.\n-     if (UseLargePages && !os::can_commit_large_page_memory()) {\n-       _must_use_large_pages = true;\n-     }\n- #endif // LINUX\n-     lgrp_spaces()->append(new LGRPSpace(lgrp_ids[i], alignment));\n+     lgrp_spaces()->append(new LGRPSpace(lgrp_ids[i], page_size));\n-   const size_t os_align = UseLargePages ? page_size() : os::vm_page_size();\n-   os::realign_memory((char*)aligned_region.start(), aligned_region.byte_size(), os_align);\n+   os::realign_memory((char*) mr.start(), mr.byte_size(), page_size());\n-   return base_space_size() / lgrp_spaces()->length() * page_size();\n+   return align_down(capacity_in_bytes() / lgrp_spaces()->length(), page_size());\n-   size_t pages_available = base_space_size();\n+   size_t pages_available = capacity_in_bytes() / page_size();", "target": "- MutableNUMASpace::MutableNUMASpace(size_t alignment) : MutableSpace(alignment), _must_use_large_pages(false) {\n+ MutableNUMASpace::MutableNUMASpace(size_t page_size) : MutableSpace(page_size) {\n-   _page_size = os::vm_page_size();\n- #ifdef LINUX\n-   // Changing the page size can lead to freeing of memory. When using large pages\n-   // and the memory has been both reserved and committed, Linux does not support\n-   // freeing parts of it.\n-     if (UseLargePages && !os::can_commit_large_page_memory()) {\n-       _must_use_large_pages = true;\n-     }\n- #endif // LINUX\n-     lgrp_spaces()->append(new LGRPSpace(lgrp_ids[i], alignment));\n+     lgrp_spaces()->append(new LGRPSpace(lgrp_ids[i], page_size));\n-   const size_t os_align = UseLargePages ? page_size() : os::vm_page_size();\n-   os::realign_memory((char*)aligned_region.start(), aligned_region.byte_size(), os_align);\n+   os::realign_memory((char*) mr.start(), mr.byte_size(), page_size());\n-   return base_space_size() / lgrp_spaces()->length() * page_size();\n+   return align_down(capacity_in_bytes() / lgrp_spaces()->length(), page_size());\n-   size_t pages_available = base_space_size();\n+   size_t pages_available = capacity_in_bytes() / page_size();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：代码中存在对大页（UseLargePages）支持的错误计算逻辑，特别是在页面大小对齐和内存区域处理时，使用了不一致的alignment和page_size概念，导致在启用大页时可能计算出错误的页面大小和内存区域。\n优化后：统一使用page_size作为内存对齐和计算的基础，移除了与alignment相关的复杂逻辑，简化了bias_region、default_chunk_size和adaptive_chunk_size等函数的实现，确保在使用大页时能正确计算页面大小和内存区域。\n优化思路：修复8346005号bug，通过统一页面大小处理逻辑，消除alignment和page_size之间的混淆，提高内存管理的正确性和性能，特别是在NUMA环境下使用大页时的稳定性。"}
{"id": 159, "source": "riscv-dataset-excel", "optimization_type": "代码简化+参数优化", "optimization_description": "优化前：ContiguousSpace::initialize方法接受三个参数（MemRegion、clear_space、mangle_space），其中mangle_space参数控制是否对未使用堆区域进行标记。优化后：移除了mangle_space参数，直接根据ZapUnusedHeapArea全局标志决定是否标记未使用区域。优化思路：简化API，减少参数传递开销，统一内存标记行为，使代码更简洁且行为更一致。", "original_code": "ContiguousSpace::initialize方法接受三个参数（MemRegion、clear_space、mangle_space），其中mangle_space参数控制是否对未使用堆区域进行标记。", "optimized_code": "void ContiguousSpace::initialize(MemRegion mr,\n                                 bool clear_space,\n                                 bool mangle_space) {\n+                                 bool clear_space) {\n  ...\n  if (ZapUnusedHeapArea && mangle_space) {\n+  if (ZapUnusedHeapArea) {", "source_url": "https://github.com/openjdk/riscv-port/commit/a0c41244325c3d14873e494e79f6c4e38c8e541a", "code_v0_no_empty_lines": "ContiguousSpace::initialize方法接受三个参数（MemRegion、clear_space、mangle_space），其中mangle_space参数控制是否对未使用堆区域进行标记。", "code_v1_no_empty_lines": "void ContiguousSpace::initialize(MemRegion mr,\n                                 bool clear_space,\n                                 bool mangle_space) {\n+                                 bool clear_space) {\n  ...\n  if (ZapUnusedHeapArea && mangle_space) {\n+  if (ZapUnusedHeapArea) {", "target": "void ContiguousSpace::initialize(MemRegion mr,\n                                 bool clear_space,\n                                 bool mangle_space) {\n+                                 bool clear_space) {\n  ...\n  if (ZapUnusedHeapArea && mangle_space) {\n+  if (ZapUnusedHeapArea) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ContiguousSpace::initialize方法接受三个参数（MemRegion、clear_space、mangle_space），其中mangle_space参数控制是否对未使用堆区域进行标记。优化后：移除了mangle_space参数，直接根据ZapUnusedHeapArea全局标志决定是否标记未使用区域。优化思路：简化API，减少参数传递开销，统一内存标记行为，使代码更简洁且行为更一致。"}
{"id": 160, "source": "riscv-dataset-excel", "optimization_type": "向量化指令优化", "optimization_description": "优化前：AArch64 SVE向量压缩指令实现需要4个临时向量寄存器（vcompressB）和2个临时向量寄存器（vcompressS），寄存器使用效率不高，且缺少向量长度参数。优化后：1. vcompressB减少1个临时向量寄存器（tmp4），从4个减至3个；2. vcompressS添加sve_dup初始化操作，使用vzr寄存器；3. 两个指令都添加length_in_bytes参数传递给底层函数；4. 新增sve_splice指令支持。优化思路：通过减少临时寄存器使用、添加向量长度参数、利用新硬件指令，提高寄存器利用率和代码生成效率，增强SVE子字类型向量压缩操作的性能。", "original_code": "AArch64 SVE向量压缩指令实现需要4个临时向量寄存器（vcompressB）和2个临时向量寄存器（vcompressS），寄存器使用效率不高，且缺少向量长度参数。", "optimized_code": "- instruct vcompressB(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2,\n                    vReg tmp3, vReg tmp4, pReg ptmp, pRegGov pgtmp) %{\n+ instruct vcompressB(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2,\n                    vReg tmp3, pReg ptmp, pRegGov pgtmp) %{\n-   effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ptmp, TEMP pgtmp);\n+   effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp, TEMP pgtmp);\n-   format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, tmp4, $ptmp, $pgtmp\" %}\n+   format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, $ptmp, $pgtmp\" %}\n   ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n     __ sve_compress_byte($dst$$FloatRegister, $src$$FloatRegister, $pg$$PRegister,\n-                         $tmp1$$FloatRegister,$tmp2$$FloatRegister,\n-                         $tmp3$$FloatRegister,$tmp4$$FloatRegister,\n-                         $ptmp$$PRegister, $pgtmp$$PRegister);\n+                         $tmp1$$FloatRegister, $tmp2$$FloatRegister, $tmp3$$FloatRegister,\n+                         $ptmp$$PRegister, $pgtmp$$PRegister, length_in_bytes);\n   %}", "source_url": "https://github.com/openjdk/riscv-port/commit/2de8d58552936e5b02b851003ec000373c32a918", "code_v0_no_empty_lines": "AArch64 SVE向量压缩指令实现需要4个临时向量寄存器（vcompressB）和2个临时向量寄存器（vcompressS），寄存器使用效率不高，且缺少向量长度参数。", "code_v1_no_empty_lines": "- instruct vcompressB(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2,\n                    vReg tmp3, vReg tmp4, pReg ptmp, pRegGov pgtmp) %{\n+ instruct vcompressB(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2,\n                    vReg tmp3, pReg ptmp, pRegGov pgtmp) %{\n-   effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ptmp, TEMP pgtmp);\n+   effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp, TEMP pgtmp);\n-   format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, tmp4, $ptmp, $pgtmp\" %}\n+   format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, $ptmp, $pgtmp\" %}\n   ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n     __ sve_compress_byte($dst$$FloatRegister, $src$$FloatRegister, $pg$$PRegister,\n-                         $tmp1$$FloatRegister,$tmp2$$FloatRegister,\n-                         $tmp3$$FloatRegister,$tmp4$$FloatRegister,\n-                         $ptmp$$PRegister, $pgtmp$$PRegister);\n+                         $tmp1$$FloatRegister, $tmp2$$FloatRegister, $tmp3$$FloatRegister,\n+                         $ptmp$$PRegister, $pgtmp$$PRegister, length_in_bytes);\n   %}", "target": "- instruct vcompressB(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2,\n                    vReg tmp3, vReg tmp4, pReg ptmp, pRegGov pgtmp) %{\n+ instruct vcompressB(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2,\n                    vReg tmp3, pReg ptmp, pRegGov pgtmp) %{\n-   effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ptmp, TEMP pgtmp);\n+   effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp, TEMP pgtmp);\n-   format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, tmp4, $ptmp, $pgtmp\" %}\n+   format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, $ptmp, $pgtmp\" %}\n   ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n     __ sve_compress_byte($dst$$FloatRegister, $src$$FloatRegister, $pg$$PRegister,\n-                         $tmp1$$FloatRegister,$tmp2$$FloatRegister,\n-                         $tmp3$$FloatRegister,$tmp4$$FloatRegister,\n-                         $ptmp$$PRegister, $pgtmp$$PRegister);\n+                         $tmp1$$FloatRegister, $tmp2$$FloatRegister, $tmp3$$FloatRegister,\n+                         $ptmp$$PRegister, $pgtmp$$PRegister, length_in_bytes);\n   %}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AArch64 SVE向量压缩指令实现需要4个临时向量寄存器（vcompressB）和2个临时向量寄存器（vcompressS），寄存器使用效率不高，且缺少向量长度参数。优化后：1. vcompressB减少1个临时向量寄存器（tmp4），从4个减至3个；2. vcompressS添加sve_dup初始化操作，使用vzr寄存器；3. 两个指令都添加length_in_bytes参数传递给底层函数；4. 新增sve_splice指令支持。优化思路：通过减少临时寄存器使用、添加向量长度参数、利用新硬件指令，提高寄存器利用率和代码生成效率，增强SVE子字类型向量压缩操作的性能。"}
{"id": 161, "source": "riscv-dataset-excel", "optimization_type": "启动性能优化", "optimization_description": "优化前：AOT链接类的链接和初始化操作在JVM启动过程中混合进行，可能导致启动延迟。优化后：将链接操作提前到JVM引导阶段（bootstrap）执行，初始化操作保持原有时机。优化思路：通过分离链接和初始化阶段，让AOT链接类在JVM完全启动前就完成链接，减少启动时的类链接开销，提升JVM启动性能。", "original_code": "AOT链接类的链接和初始化操作在JVM启动过程中混合进行，可能导致启动延迟。", "optimized_code": "-void AOTLinkedClassBulkLoader::link_or_init_javabase_classes(JavaThread* current) {\n-  link_or_init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n+void AOTLinkedClassBulkLoader::init_javabase_classes(JavaThread* current) {\n+  init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/6cd7f30d8d4118787401693b8628c72679d37a6a", "code_v0_no_empty_lines": "AOT链接类的链接和初始化操作在JVM启动过程中混合进行，可能导致启动延迟。", "code_v1_no_empty_lines": "-void AOTLinkedClassBulkLoader::link_or_init_javabase_classes(JavaThread* current) {\n-  link_or_init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n+void AOTLinkedClassBulkLoader::init_javabase_classes(JavaThread* current) {\n+  init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n }", "target": "-void AOTLinkedClassBulkLoader::link_or_init_javabase_classes(JavaThread* current) {\n-  link_or_init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n+void AOTLinkedClassBulkLoader::init_javabase_classes(JavaThread* current) {\n+  init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AOT链接类的链接和初始化操作在JVM启动过程中混合进行，可能导致启动延迟。优化后：将链接操作提前到JVM引导阶段（bootstrap）执行，初始化操作保持原有时机。优化思路：通过分离链接和初始化阶段，让AOT链接类在JVM完全启动前就完成链接，减少启动时的类链接开销，提升JVM启动性能。"}
{"id": 162, "source": "riscv-dataset-excel", "optimization_type": "循环优化+表达式重关联", "optimization_description": "优化前：ReassociateInvariants优化仅适用于BaseCountedLoop类型的循环，限制了优化范围。优化后：移除了对BaseCountedLoop类型的限制，使ReassociateInvariants优化适用于所有最内层循环类型（包括非计数循环）。优化思路：通过放宽循环类型限制，让更多循环能够受益于表达式重关联优化，将循环不变表达式移出循环，减少重复计算，同时为后续的Range Check Elimination等优化创造更多机会，提升循环性能。", "original_code": "ReassociateInvariants优化仅适用于BaseCountedLoop类型的循环，限制了优化范围。", "optimized_code": "-      if (!head->is_BaseCountedLoop() || !lpt->is_innermost()) continue;\n \n       // check for vectorized loops, any reassociation of invariants was already done\n-      if (head->is_CountedLoop()) {\n-        if (head->as_CountedLoop()->is_unroll_only()) {\n-          continue;\n-        } else {\n-          AutoNodeBudget node_budget(this);\n-          lpt->reassociate_invariants(this);\n-        }\n+      if (head->is_CountedLoop() && head->as_CountedLoop()->is_unroll_only()) {\n+        continue;\n+      } else {\n+        AutoNodeBudget node_budget(this);\n+        lpt->reassociate_invariants(this);\n       }", "source_url": "https://github.com/openjdk/riscv-port/commit/ff6a0170f0ab5cfb4af6d6a4a779451823c486d6", "code_v0_no_empty_lines": "ReassociateInvariants优化仅适用于BaseCountedLoop类型的循环，限制了优化范围。", "code_v1_no_empty_lines": "-      if (!head->is_BaseCountedLoop() || !lpt->is_innermost()) continue;\n \n       // check for vectorized loops, any reassociation of invariants was already done\n-      if (head->is_CountedLoop()) {\n-        if (head->as_CountedLoop()->is_unroll_only()) {\n-          continue;\n-        } else {\n-          AutoNodeBudget node_budget(this);\n-          lpt->reassociate_invariants(this);\n-        }\n+      if (head->is_CountedLoop() && head->as_CountedLoop()->is_unroll_only()) {\n+        continue;\n+      } else {\n+        AutoNodeBudget node_budget(this);\n+        lpt->reassociate_invariants(this);\n       }", "target": "-      if (!head->is_BaseCountedLoop() || !lpt->is_innermost()) continue;\n \n       // check for vectorized loops, any reassociation of invariants was already done\n-      if (head->is_CountedLoop()) {\n-        if (head->as_CountedLoop()->is_unroll_only()) {\n-          continue;\n-        } else {\n-          AutoNodeBudget node_budget(this);\n-          lpt->reassociate_invariants(this);\n-        }\n+      if (head->is_CountedLoop() && head->as_CountedLoop()->is_unroll_only()) {\n+        continue;\n+      } else {\n+        AutoNodeBudget node_budget(this);\n+        lpt->reassociate_invariants(this);\n       }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ReassociateInvariants优化仅适用于BaseCountedLoop类型的循环，限制了优化范围。优化后：移除了对BaseCountedLoop类型的限制，使ReassociateInvariants优化适用于所有最内层循环类型（包括非计数循环）。优化思路：通过放宽循环类型限制，让更多循环能够受益于表达式重关联优化，将循环不变表达式移出循环，减少重复计算，同时为后续的Range Check Elimination等优化创造更多机会，提升循环性能。"}
{"id": 163, "source": "riscv-dataset-excel", "optimization_type": "编译器中间表示优化", "optimization_description": "优化前：LShiftINode和LShiftLNode的Value/Identity/Ideal实现存在重复代码，类型处理不一致（int和uint混用），且部分优化逻辑未统一处理32位和64位整数。优化后：重构代码，提取通用逻辑到LShiftNode基类，统一使用uint类型处理移位计数，消除类型转换开销，合并32位和64位整数的优化路径。优化思路：通过代码重构减少重复，统一类型处理避免隐式转换，提高编译器中间表示优化的效率和一致性。", "original_code": "LShiftINode和LShiftLNode的Value/Identity/Ideal实现存在重复代码，类型处理不一致（int和uint混用），且部分优化逻辑未统一处理32位和64位整数。", "optimized_code": "-static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& real_shift, int& masked_shift) {\n+static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& real_shift, uint& masked_shift) {\n\n-static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& masked_shift) {\n+static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, uint& masked_shift) {\n\n-static int mask_and_replace_shift_amount(PhaseGVN* phase, Node* shift_node, uint nBits) {\n+static uint mask_and_replace_shift_amount(PhaseGVN* phase, Node* shift_node, uint nBits) {\n\n-    if (real_shift != masked_shift) {\n+    if (real_shift != (int)masked_shift) {\n\n-static Node* collapse_nested_shift_left(PhaseGVN* phase, const Node* outer_shift, int con_outer, BasicType bt) {\n+static Node* collapse_nested_shift_left(PhaseGVN* phase, const Node* outer_shift, uint con_outer, BasicType bt) {\n\n-  int nbits = static_cast<int>(bits_per_java_integer(bt));\n-  int con_inner;\n+  uint nbits = bits_per_java_integer(bt);\n+  uint con_inner;", "source_url": "https://github.com/openjdk/riscv-port/commit/7fe066573004a525673e4ec55df6783b13bfc189", "code_v0_no_empty_lines": "LShiftINode和LShiftLNode的Value/Identity/Ideal实现存在重复代码，类型处理不一致（int和uint混用），且部分优化逻辑未统一处理32位和64位整数。", "code_v1_no_empty_lines": "-static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& real_shift, int& masked_shift) {\n+static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& real_shift, uint& masked_shift) {\n\n-static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& masked_shift) {\n+static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, uint& masked_shift) {\n\n-static int mask_and_replace_shift_amount(PhaseGVN* phase, Node* shift_node, uint nBits) {\n+static uint mask_and_replace_shift_amount(PhaseGVN* phase, Node* shift_node, uint nBits) {\n\n-    if (real_shift != masked_shift) {\n+    if (real_shift != (int)masked_shift) {\n\n-static Node* collapse_nested_shift_left(PhaseGVN* phase, const Node* outer_shift, int con_outer, BasicType bt) {\n+static Node* collapse_nested_shift_left(PhaseGVN* phase, const Node* outer_shift, uint con_outer, BasicType bt) {\n\n-  int nbits = static_cast<int>(bits_per_java_integer(bt));\n-  int con_inner;\n+  uint nbits = bits_per_java_integer(bt);\n+  uint con_inner;", "target": "-static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& real_shift, int& masked_shift) {\n+static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& real_shift, uint& masked_shift) {\n\n-static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& masked_shift) {\n+static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, uint& masked_shift) {\n\n-static int mask_and_replace_shift_amount(PhaseGVN* phase, Node* shift_node, uint nBits) {\n+static uint mask_and_replace_shift_amount(PhaseGVN* phase, Node* shift_node, uint nBits) {\n\n-    if (real_shift != masked_shift) {\n+    if (real_shift != (int)masked_shift) {\n\n-static Node* collapse_nested_shift_left(PhaseGVN* phase, const Node* outer_shift, int con_outer, BasicType bt) {\n+static Node* collapse_nested_shift_left(PhaseGVN* phase, const Node* outer_shift, uint con_outer, BasicType bt) {\n\n-  int nbits = static_cast<int>(bits_per_java_integer(bt));\n-  int con_inner;\n+  uint nbits = bits_per_java_integer(bt);\n+  uint con_inner;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：LShiftINode和LShiftLNode的Value/Identity/Ideal实现存在重复代码，类型处理不一致（int和uint混用），且部分优化逻辑未统一处理32位和64位整数。优化后：重构代码，提取通用逻辑到LShiftNode基类，统一使用uint类型处理移位计数，消除类型转换开销，合并32位和64位整数的优化路径。优化思路：通过代码重构减少重复，统一类型处理避免隐式转换，提高编译器中间表示优化的效率和一致性。"}
{"id": 164, "source": "riscv-dataset-excel", "optimization_type": "平台特定优化+原子操作优化", "optimization_description": "优化前：AIX和Linux平台上的PPC架构共享通用的原子操作实现，可能未充分利用PPC64架构的特定指令集优势。优化后：为PPC64架构创建专门的原子操作实现文件（atomicAccess_ppc.hpp和orderAccess_ppc.hpp），使用PPC64特有的汇编指令（如lwarx/stwcx、ldarx/stdcx）和内存屏障指令（lwsync、isync、sync）来优化原子操作性能。优化思路：通过平台特定化，减少通用代码路径的开销，利用PPC64架构的原子操作原语提高并发性能，同时简化了AIX和Linux平台的相关代码（减少了890行）。", "original_code": "AIX和Linux平台上的PPC架构共享通用的原子操作实现，可能未充分利用PPC64架构的特定指令集优势。", "optimized_code": "创建新文件 src/hotspot/cpu/ppc/atomicAccess_ppc.hpp 和 src/hotspot/cpu/ppc/orderAccess_ppc.hpp，包含针对PPC64架构的原子操作实现，如：\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<4>::add_then_fetch(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(I));\n+  STATIC_ASSERT(4 == sizeof(D));\n+\n+  D result;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \"1: lwarx   %[result], 0, %[dest]                 \\n\"\n+    \"   add     %[result], %[result], %[add_value]    \\n\"\n+    \"   stwcx.  %[result], 0, %[dest]                 \\n\"\n+    \"   bne-    1b                                    \\n\"\n+    : [result]     \"=&r\"  (result)\n+    : [add_value]  \"r\"    (add_value),\n+      [dest]       \"b\"    (dest)\n+    : \"cc\", \"memory\" );\n+\n+  post_membar(order);\n+\n+  return result;\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/c9cbd31f8575a25c4decd68dc645378c5ba2bad0", "code_v0_no_empty_lines": "AIX和Linux平台上的PPC架构共享通用的原子操作实现，可能未充分利用PPC64架构的特定指令集优势。", "code_v1_no_empty_lines": "创建新文件 src/hotspot/cpu/ppc/atomicAccess_ppc.hpp 和 src/hotspot/cpu/ppc/orderAccess_ppc.hpp，包含针对PPC64架构的原子操作实现，如：\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<4>::add_then_fetch(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(I));\n+  STATIC_ASSERT(4 == sizeof(D));\n+\n+  D result;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \"1: lwarx   %[result], 0, %[dest]                 \\n\"\n+    \"   add     %[result], %[result], %[add_value]    \\n\"\n+    \"   stwcx.  %[result], 0, %[dest]                 \\n\"\n+    \"   bne-    1b                                    \\n\"\n+    : [result]     \"=&r\"  (result)\n+    : [add_value]  \"r\"    (add_value),\n+      [dest]       \"b\"    (dest)\n+    : \"cc\", \"memory\" );\n+\n+  post_membar(order);\n+\n+  return result;\n+}", "target": "创建新文件 src/hotspot/cpu/ppc/atomicAccess_ppc.hpp 和 src/hotspot/cpu/ppc/orderAccess_ppc.hpp，包含针对PPC64架构的原子操作实现，如：\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<4>::add_then_fetch(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(I));\n+  STATIC_ASSERT(4 == sizeof(D));\n+\n+  D result;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \"1: lwarx   %[result], 0, %[dest]                 \\n\"\n+    \"   add     %[result], %[result], %[add_value]    \\n\"\n+    \"   stwcx.  %[result], 0, %[dest]                 \\n\"\n+    \"   bne-    1b                                    \\n\"\n+    : [result]     \"=&r\"  (result)\n+    : [add_value]  \"r\"    (add_value),\n+      [dest]       \"b\"    (dest)\n+    : \"cc\", \"memory\" );\n+\n+  post_membar(order);\n+\n+  return result;\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AIX和Linux平台上的PPC架构共享通用的原子操作实现，可能未充分利用PPC64架构的特定指令集优势。优化后：为PPC64架构创建专门的原子操作实现文件（atomicAccess_ppc.hpp和orderAccess_ppc.hpp），使用PPC64特有的汇编指令（如lwarx/stwcx、ldarx/stdcx）和内存屏障指令（lwsync、isync、sync）来优化原子操作性能。优化思路：通过平台特定化，减少通用代码路径的开销，利用PPC64架构的原子操作原语提高并发性能，同时简化了AIX和Linux平台的相关代码（减少了890行）。"}
{"id": 165, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前：在JavaFrameAnchor的clear()、set()、copy()和set_last_Java_sp()方法中，每次对_last_Java_sp和_last_Java_pc成员赋值后都调用了OrderAccess::release()内存屏障，以确保内存可见性。优化后：移除了所有OrderAccess::release()调用，并添加注释说明硬件屏障是不必要的，因为所有成员都是volatile类型，且分析器（profiler）在信号处理器中运行，仅观察其所在线程。优化思路：通过分析内存访问模式，发现这些内存屏障是冗余的，因为volatile变量本身提供内存可见性保证，且单线程访问模式消除了跨线程同步需求，从而减少了不必要的内存屏障开销，提升了性能。", "original_code": "在JavaFrameAnchor的clear()、set()、copy()和set_last_Java_sp()方法中，每次对_last_Java_sp和_last_Java_pc成员赋值后都调用了OrderAccess::release()内存屏障，以确保内存可见性。", "optimized_code": "-    OrderAccess::release();\n-    OrderAccess::release();\n-    OrderAccess::release();\n-    OrderAccess::release();\n-    OrderAccess::release();\n+    // No hardware barriers are necessary. All members are volatile and the profiler\n+    // is run from a signal handler and only observers the thread its running on.", "source_url": "https://github.com/openjdk/riscv-port/commit/bfe6937244ff7ec9899bb6a5eaa4222736898177", "code_v0_no_empty_lines": "在JavaFrameAnchor的clear()、set()、copy()和set_last_Java_sp()方法中，每次对_last_Java_sp和_last_Java_pc成员赋值后都调用了OrderAccess::release()内存屏障，以确保内存可见性。", "code_v1_no_empty_lines": "-    OrderAccess::release();\n-    OrderAccess::release();\n-    OrderAccess::release();\n-    OrderAccess::release();\n-    OrderAccess::release();\n+    // No hardware barriers are necessary. All members are volatile and the profiler\n+    // is run from a signal handler and only observers the thread its running on.", "target": "-    OrderAccess::release();\n-    OrderAccess::release();\n-    OrderAccess::release();\n-    OrderAccess::release();\n-    OrderAccess::release();\n+    // No hardware barriers are necessary. All members are volatile and the profiler\n+    // is run from a signal handler and only observers the thread its running on.", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在JavaFrameAnchor的clear()、set()、copy()和set_last_Java_sp()方法中，每次对_last_Java_sp和_last_Java_pc成员赋值后都调用了OrderAccess::release()内存屏障，以确保内存可见性。优化后：移除了所有OrderAccess::release()调用，并添加注释说明硬件屏障是不必要的，因为所有成员都是volatile类型，且分析器（profiler）在信号处理器中运行，仅观察其所在线程。优化思路：通过分析内存访问模式，发现这些内存屏障是冗余的，因为volatile变量本身提供内存可见性保证，且单线程访问模式消除了跨线程同步需求，从而减少了不必要的内存屏障开销，提升了性能。"}
{"id": 166, "source": "riscv-dataset-excel", "optimization_type": "文件系统性能优化", "optimization_description": "优化前：toRealPath(NOFOLLOW_LINKS)在macOS上性能极差，因为每次迭代目录条目时都会调用UnixFileAttributes.get()获取文件属性来比较fileKey，这涉及昂贵的系统调用。优化后：首先通过简单的路径名比较(name.compareTo(element) == 0)来匹配条目，这避免了系统调用；只有在路径名不匹配时才回退到fileKey比较。优化思路：将廉价操作（路径名比较）放在前面，昂贵的系统调用（获取文件属性）放在后面，显著减少了不必要的系统调用次数，从而大幅提升性能。", "original_code": "toRealPath(NOFOLLOW_LINKS)在macOS上性能极差，因为每次迭代目录条目时都会调用UnixFileAttributes.get()获取文件属性来比较fileKey，这涉及昂贵的系统调用。", "optimized_code": "@@ -948,28 +948,51 @@ public Path toRealPath(LinkOption... options) throws IOException {\n             // Obtain the stream of entries in the directory corresponding\n             // to the path constructed thus far, and extract the entry whose\n-            // key is equal to the key of the current element\n+            // internal path bytes equal the internal path bytes of the current\n+            // element, or whose key is equal to the key  of the current element\n+            boolean found = false;\n             DirectoryStream.Filter<Path> filter = (p) -> { return true; };\n+            // compare path bytes until a match is found or no more entries\n             try (DirectoryStream<Path> entries = new UnixDirectoryStream(path, dp, filter)) {\n-                boolean found = false;\n                 for (Path entry : entries) {\n-                    UnixPath p = path.resolve(entry.getFileName());\n-                    UnixFileAttributes attributes = null;\n-                    try {\n-                        attributes = UnixFileAttributes.get(p, false);\n-                        UnixFileKey key = attributes.fileKey();\n-                        if (key.equals(elementKey)) {\n-                            path = path.resolve(entry);\n-                            found = true;\n-                            break;\n+                    Path name = entry.getFileName();\n+                    if (name.compareTo(element) == 0) {\n+                        found = true;\n+                        path = path.resolve(entry);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            // if no path match found, compare file keys\n+            if (!found) {\n+                try {\n+                    dp = opendir(path);\n+                } catch (UnixException x) {\n+                    x.rethrowAsIOException(path);\n+                }\n+\n+                try (DirectoryStream<Path> entries = new UnixDirectoryStream(path, dp, filter)) {\n+                    for (Path entry : entries) {\n+                        Path name = entry.getFileName();\n+                        UnixPath p = path.resolve(name);\n+                        UnixFileAttributes attributes = null;\n+                        try {\n+                            attributes = UnixFileAttributes.get(p, false);\n+                            UnixFileKey key = attributes.fileKey();\n+                            if (key.equals(elementKey)) {\n+                                found = true;\n+                                path = path.resolve(entry);\n+                                break;\n+                            }\n+                        } catch (UnixException ignore) {\n+                            continue;\n                         }\n-                    } catch (UnixException ignore) {\n-                        continue;\n                     }\n                 }\n \n-                // Fallback which should in theory never happen\n                 if (!found) {\n+                    // Fallback which should in theory never happen\n                     path = path.resolve(element);\n                 }\n             }", "source_url": "https://github.com/openjdk/riscv-port/commit/09e87971e8a53951b40eef15d127aad0b7c2bee8", "code_v0_no_empty_lines": "toRealPath(NOFOLLOW_LINKS)在macOS上性能极差，因为每次迭代目录条目时都会调用UnixFileAttributes.get()获取文件属性来比较fileKey，这涉及昂贵的系统调用。", "code_v1_no_empty_lines": "@@ -948,28 +948,51 @@ public Path toRealPath(LinkOption... options) throws IOException {\n             // Obtain the stream of entries in the directory corresponding\n             // to the path constructed thus far, and extract the entry whose\n-            // key is equal to the key of the current element\n+            // internal path bytes equal the internal path bytes of the current\n+            // element, or whose key is equal to the key  of the current element\n+            boolean found = false;\n             DirectoryStream.Filter<Path> filter = (p) -> { return true; };\n+            // compare path bytes until a match is found or no more entries\n             try (DirectoryStream<Path> entries = new UnixDirectoryStream(path, dp, filter)) {\n-                boolean found = false;\n                 for (Path entry : entries) {\n-                    UnixPath p = path.resolve(entry.getFileName());\n-                    UnixFileAttributes attributes = null;\n-                    try {\n-                        attributes = UnixFileAttributes.get(p, false);\n-                        UnixFileKey key = attributes.fileKey();\n-                        if (key.equals(elementKey)) {\n-                            path = path.resolve(entry);\n-                            found = true;\n-                            break;\n+                    Path name = entry.getFileName();\n+                    if (name.compareTo(element) == 0) {\n+                        found = true;\n+                        path = path.resolve(entry);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            // if no path match found, compare file keys\n+            if (!found) {\n+                try {\n+                    dp = opendir(path);\n+                } catch (UnixException x) {\n+                    x.rethrowAsIOException(path);\n+                }\n+\n+                try (DirectoryStream<Path> entries = new UnixDirectoryStream(path, dp, filter)) {\n+                    for (Path entry : entries) {\n+                        Path name = entry.getFileName();\n+                        UnixPath p = path.resolve(name);\n+                        UnixFileAttributes attributes = null;\n+                        try {\n+                            attributes = UnixFileAttributes.get(p, false);\n+                            UnixFileKey key = attributes.fileKey();\n+                            if (key.equals(elementKey)) {\n+                                found = true;\n+                                path = path.resolve(entry);\n+                                break;\n+                            }\n+                        } catch (UnixException ignore) {\n+                            continue;\n                         }\n-                    } catch (UnixException ignore) {\n-                        continue;\n                     }\n                 }\n \n-                // Fallback which should in theory never happen\n                 if (!found) {\n+                    // Fallback which should in theory never happen\n                     path = path.resolve(element);\n                 }\n             }", "target": "@@ -948,28 +948,51 @@ public Path toRealPath(LinkOption... options) throws IOException {\n             // Obtain the stream of entries in the directory corresponding\n             // to the path constructed thus far, and extract the entry whose\n-            // key is equal to the key of the current element\n+            // internal path bytes equal the internal path bytes of the current\n+            // element, or whose key is equal to the key  of the current element\n+            boolean found = false;\n             DirectoryStream.Filter<Path> filter = (p) -> { return true; };\n+            // compare path bytes until a match is found or no more entries\n             try (DirectoryStream<Path> entries = new UnixDirectoryStream(path, dp, filter)) {\n-                boolean found = false;\n                 for (Path entry : entries) {\n-                    UnixPath p = path.resolve(entry.getFileName());\n-                    UnixFileAttributes attributes = null;\n-                    try {\n-                        attributes = UnixFileAttributes.get(p, false);\n-                        UnixFileKey key = attributes.fileKey();\n-                        if (key.equals(elementKey)) {\n-                            path = path.resolve(entry);\n-                            found = true;\n-                            break;\n+                    Path name = entry.getFileName();\n+                    if (name.compareTo(element) == 0) {\n+                        found = true;\n+                        path = path.resolve(entry);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            // if no path match found, compare file keys\n+            if (!found) {\n+                try {\n+                    dp = opendir(path);\n+                } catch (UnixException x) {\n+                    x.rethrowAsIOException(path);\n+                }\n+\n+                try (DirectoryStream<Path> entries = new UnixDirectoryStream(path, dp, filter)) {\n+                    for (Path entry : entries) {\n+                        Path name = entry.getFileName();\n+                        UnixPath p = path.resolve(name);\n+                        UnixFileAttributes attributes = null;\n+                        try {\n+                            attributes = UnixFileAttributes.get(p, false);\n+                            UnixFileKey key = attributes.fileKey();\n+                            if (key.equals(elementKey)) {\n+                                found = true;\n+                                path = path.resolve(entry);\n+                                break;\n+                            }\n+                        } catch (UnixException ignore) {\n+                            continue;\n                         }\n-                    } catch (UnixException ignore) {\n-                        continue;\n                     }\n                 }\n \n-                // Fallback which should in theory never happen\n                 if (!found) {\n+                    // Fallback which should in theory never happen\n                     path = path.resolve(element);\n                 }\n             }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：toRealPath(NOFOLLOW_LINKS)在macOS上性能极差，因为每次迭代目录条目时都会调用UnixFileAttributes.get()获取文件属性来比较fileKey，这涉及昂贵的系统调用。优化后：首先通过简单的路径名比较(name.compareTo(element) == 0)来匹配条目，这避免了系统调用；只有在路径名不匹配时才回退到fileKey比较。优化思路：将廉价操作（路径名比较）放在前面，昂贵的系统调用（获取文件属性）放在后面，显著减少了不必要的系统调用次数，从而大幅提升性能。"}
{"id": 167, "source": "riscv-dataset-excel", "optimization_type": "字符串处理优化", "optimization_description": "优化前使用正则表达式replaceFirst(\"p-1022$\", \"p-126\")进行字符串替换，需要正则匹配开销。优化后使用普通字符串替换replace(\"-1022\", \"-126\")，因为注释说明\"-1022\"字符序列只出现在指数表示中，不会出现在十六进制有效数字中，所以可以安全使用更高效的普通字符串替换。", "original_code": "// No original code extracted from description\n", "optimized_code": "-            return s.replaceFirst(\"p-1022$\", \"p-126\");\n+            return s.replace(\"-1022\", \"-126\");", "source_url": "https://github.com/openjdk/riscv-port/commit/7ed93cf40ed4fa1ad545dcb1a33b0d4fdabfa277", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "-            return s.replaceFirst(\"p-1022$\", \"p-126\");\n+            return s.replace(\"-1022\", \"-126\");", "target": "-            return s.replaceFirst(\"p-1022$\", \"p-126\");\n+            return s.replace(\"-1022\", \"-126\");", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用正则表达式replaceFirst(\"p-1022$\", \"p-126\")进行字符串替换，需要正则匹配开销。优化后使用普通字符串替换replace(\"-1022\", \"-126\")，因为注释说明\"-1022\"字符序列只出现在指数表示中，不会出现在十六进制有效数字中，所以可以安全使用更高效的普通字符串替换。"}
{"id": 168, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化+指令顺序优化", "optimization_description": "优化前：JavaFrameAnchor在clear()和copy()方法中使用了不必要的OrderAccess::release()内存屏障，且MacroAssembler中设置last_Java_sp的顺序可能导致状态不一致。优化后：1. 移除两个冗余的内存屏障调用，因为所有成员都是volatile且仅在信号处理程序中由同一线程观察，无需硬件屏障。2. 调整指令顺序，确保last_Java_sp最后设置，避免在设置其他字段时sp已更新导致的潜在状态问题。优化思路：基于RISC-V架构特性和线程安全分析，消除不必要的同步开销并修正存储顺序。", "original_code": "JavaFrameAnchor在clear()和copy()方法中使用了不必要的OrderAccess::release()内存屏障，且MacroAssembler中设置last_Java_sp的顺序可能导致状态不一致。", "optimized_code": "-    OrderAccess::release();\n-    OrderAccess::release();\n-  sd(last_java_sp, Address(xthread, JavaThread::last_Java_sp_offset()));\n+  // We must set sp last.\n+  sd(last_java_sp, Address(xthread, JavaThread::last_Java_sp_offset()));", "source_url": "https://github.com/openjdk/riscv-port/commit/72663695da9a51c8eefbd496f14a6d1625ad7b42", "code_v0_no_empty_lines": "JavaFrameAnchor在clear()和copy()方法中使用了不必要的OrderAccess::release()内存屏障，且MacroAssembler中设置last_Java_sp的顺序可能导致状态不一致。", "code_v1_no_empty_lines": "-    OrderAccess::release();\n-    OrderAccess::release();\n-  sd(last_java_sp, Address(xthread, JavaThread::last_Java_sp_offset()));\n+  // We must set sp last.\n+  sd(last_java_sp, Address(xthread, JavaThread::last_Java_sp_offset()));", "target": "-    OrderAccess::release();\n-    OrderAccess::release();\n-  sd(last_java_sp, Address(xthread, JavaThread::last_Java_sp_offset()));\n+  // We must set sp last.\n+  sd(last_java_sp, Address(xthread, JavaThread::last_Java_sp_offset()));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：JavaFrameAnchor在clear()和copy()方法中使用了不必要的OrderAccess::release()内存屏障，且MacroAssembler中设置last_Java_sp的顺序可能导致状态不一致。优化后：1. 移除两个冗余的内存屏障调用，因为所有成员都是volatile且仅在信号处理程序中由同一线程观察，无需硬件屏障。2. 调整指令顺序，确保last_Java_sp最后设置，避免在设置其他字段时sp已更新导致的潜在状态问题。优化思路：基于RISC-V架构特性和线程安全分析，消除不必要的同步开销并修正存储顺序。"}
{"id": 169, "source": "riscv-dataset-excel", "optimization_type": "循环优化+向量化重构", "optimization_description": "优化前：无序归约（UnorderedReduction）操作在循环优化阶段（PhaseIdealLoop::build_and_optimize）中处理，通过move_unordered_reduction_out_of_loop函数将无序归约移出循环以减少开销。优化后：将该功能重构到向量化变换阶段（VTransform::optimize）中处理，使无序归约的移出操作与向量化过程更紧密集成。优化思路：通过重构代码结构，将循环优化中的无序归约处理逻辑迁移到向量化变换模块，提高向量化优化的整体性和效率，减少模块间的耦合，便于后续维护和扩展。", "original_code": "无序归约（UnorderedReduction）操作在循环优化阶段（PhaseIdealLoop::build_and_optimize）中处理，通过move_unordered_reduction_out_of_loop函数将无序归约移出循环以减少开销。", "optimized_code": "-  // Move UnorderedReduction out of counted loop. Can be introduced by AutoVectorization.\n  if (C->has_loops() && !C->major_progress()) {\n    for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n      IdealLoopTree* lpt = iter.current();\n      if (lpt->is_counted() && lpt->is_innermost()) {\n        move_unordered_reduction_out_of_loop(lpt);\n      }\n    }\n  }\n+  // 在VTransform::optimize中处理move_unordered_reduction_out_of_loop", "source_url": "https://github.com/openjdk/riscv-port/commit/4786f8bee5c79c1bcf652758a25360b4d308ce1c", "code_v0_no_empty_lines": "无序归约（UnorderedReduction）操作在循环优化阶段（PhaseIdealLoop::build_and_optimize）中处理，通过move_unordered_reduction_out_of_loop函数将无序归约移出循环以减少开销。", "code_v1_no_empty_lines": "-  // Move UnorderedReduction out of counted loop. Can be introduced by AutoVectorization.\n  if (C->has_loops() && !C->major_progress()) {\n    for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n      IdealLoopTree* lpt = iter.current();\n      if (lpt->is_counted() && lpt->is_innermost()) {\n        move_unordered_reduction_out_of_loop(lpt);\n      }\n    }\n  }\n+  // 在VTransform::optimize中处理move_unordered_reduction_out_of_loop", "target": "-  // Move UnorderedReduction out of counted loop. Can be introduced by AutoVectorization.\n  if (C->has_loops() && !C->major_progress()) {\n    for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n      IdealLoopTree* lpt = iter.current();\n      if (lpt->is_counted() && lpt->is_innermost()) {\n        move_unordered_reduction_out_of_loop(lpt);\n      }\n    }\n  }\n+  // 在VTransform::optimize中处理move_unordered_reduction_out_of_loop", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：无序归约（UnorderedReduction）操作在循环优化阶段（PhaseIdealLoop::build_and_optimize）中处理，通过move_unordered_reduction_out_of_loop函数将无序归约移出循环以减少开销。优化后：将该功能重构到向量化变换阶段（VTransform::optimize）中处理，使无序归约的移出操作与向量化过程更紧密集成。优化思路：通过重构代码结构，将循环优化中的无序归约处理逻辑迁移到向量化变换模块，提高向量化优化的整体性和效率，减少模块间的耦合，便于后续维护和扩展。"}
{"id": 170, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（值范围分析+常量折叠）", "optimization_description": "优化前：PopCountINode和PopCountLNode节点没有实现Value()方法，编译器无法利用已知位信息（KnownBits）来推断popcount操作的结果范围。优化后：为这两个节点添加了Value()方法实现，利用输入类型的KnownBits信息（ones和zeros位掩码）计算popcount结果的最小值和最大值范围。优化思路：通过已知位分析推导出popcount(t)的范围满足pop_count(ones) ≤ popcount(t) ≤ pop_count(~zeros)，从而在编译时确定值范围，支持后续的常量折叠、死代码消除等优化。", "original_code": "PopCountINode和PopCountLNode节点没有实现Value()方法，编译器无法利用已知位信息（KnownBits）来推断popcount操作的结果范围。", "optimized_code": "const Type* PopCountINode::Value(PhaseGVN* phase) const {\n  const Type* t = phase->type(in(1));\n  if (t == Type::TOP) {\n    return Type::TOP;\n  }\n  const TypeInt* tint = t->is_int();\n  KnownBits<juint> bits = tint->_bits;\n  return TypeInt::make(population_count(bits._ones), population_count(~bits._zeros), tint->_widen);\n}\n\nconst Type* PopCountLNode::Value(PhaseGVN* phase) const {\n  const Type* t = phase->type(in(1));\n  if (t == Type::TOP) {\n    return Type::TOP;\n  }\n  const TypeLong* tlong = t->is_long();\n  KnownBits<julong> bits = tlong->_bits;\n  return TypeInt::make(population_count(bits._ones), population_count(~bits._zeros), tlong->_widen);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/449641813ada3b0af6441dd7299e40235e7adf56", "code_v0_no_empty_lines": "PopCountINode和PopCountLNode节点没有实现Value()方法，编译器无法利用已知位信息（KnownBits）来推断popcount操作的结果范围。", "code_v1_no_empty_lines": "const Type* PopCountINode::Value(PhaseGVN* phase) const {\n  const Type* t = phase->type(in(1));\n  if (t == Type::TOP) {\n    return Type::TOP;\n  }\n  const TypeInt* tint = t->is_int();\n  KnownBits<juint> bits = tint->_bits;\n  return TypeInt::make(population_count(bits._ones), population_count(~bits._zeros), tint->_widen);\n}\n\nconst Type* PopCountLNode::Value(PhaseGVN* phase) const {\n  const Type* t = phase->type(in(1));\n  if (t == Type::TOP) {\n    return Type::TOP;\n  }\n  const TypeLong* tlong = t->is_long();\n  KnownBits<julong> bits = tlong->_bits;\n  return TypeInt::make(population_count(bits._ones), population_count(~bits._zeros), tlong->_widen);\n}", "target": "const Type* PopCountINode::Value(PhaseGVN* phase) const {\n  const Type* t = phase->type(in(1));\n  if (t == Type::TOP) {\n    return Type::TOP;\n  }\n  const TypeInt* tint = t->is_int();\n  KnownBits<juint> bits = tint->_bits;\n  return TypeInt::make(population_count(bits._ones), population_count(~bits._zeros), tint->_widen);\n}\n\nconst Type* PopCountLNode::Value(PhaseGVN* phase) const {\n  const Type* t = phase->type(in(1));\n  if (t == Type::TOP) {\n    return Type::TOP;\n  }\n  const TypeLong* tlong = t->is_long();\n  KnownBits<julong> bits = tlong->_bits;\n  return TypeInt::make(population_count(bits._ones), population_count(~bits._zeros), tlong->_widen);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PopCountINode和PopCountLNode节点没有实现Value()方法，编译器无法利用已知位信息（KnownBits）来推断popcount操作的结果范围。优化后：为这两个节点添加了Value()方法实现，利用输入类型的KnownBits信息（ones和zeros位掩码）计算popcount结果的最小值和最大值范围。优化思路：通过已知位分析推导出popcount(t)的范围满足pop_count(ones) ≤ popcount(t) ≤ pop_count(~zeros)，从而在编译时确定值范围，支持后续的常量折叠、死代码消除等优化。"}
{"id": 171, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+虚拟线程支持", "optimization_description": "优化前：虚拟线程检测基于线程类型，可能导致不必要的定时park或错过必要的定时park，存在死锁风险。优化后：引入_unmounted_vthreads计数器跟踪未挂载虚拟线程，基于计数器状态决定是否使用定时park，并优化了park间隔处理。优化思路：通过精确跟踪未挂载虚拟线程状态，避免因虚拟线程无法运行导致的死锁，同时减少不必要的定时park开销。", "original_code": "虚拟线程检测基于线程类型，可能导致不必要的定时park或错过必要的定时park，存在死锁风险。", "optimized_code": "- static int MAX_RECHECK_INTERVAL = 1000;\n+ static const jlong MAX_RECHECK_INTERVAL = 1000;\n- bool do_timed_parked = false;\n- ContinuationEntry* ce = current->last_continuation();\n- if (ce != nullptr && ce->is_virtual_thread()) {\n-   do_timed_parked = true;\n- }\n+ bool do_timed_parked = has_unmounted_vthreads();\n- current->_ParkEvent->park((jlong) recheck_interval);\n+ current->_ParkEvent->park(recheck_interval);\n+ inc_unmounted_vthreads();\n+ dec_unmounted_vthreads();", "source_url": "https://github.com/openjdk/riscv-port/commit/9feb8f21b5d000f8901938f1dde89638c79ca805", "code_v0_no_empty_lines": "虚拟线程检测基于线程类型，可能导致不必要的定时park或错过必要的定时park，存在死锁风险。", "code_v1_no_empty_lines": "- static int MAX_RECHECK_INTERVAL = 1000;\n+ static const jlong MAX_RECHECK_INTERVAL = 1000;\n- bool do_timed_parked = false;\n- ContinuationEntry* ce = current->last_continuation();\n- if (ce != nullptr && ce->is_virtual_thread()) {\n-   do_timed_parked = true;\n- }\n+ bool do_timed_parked = has_unmounted_vthreads();\n- current->_ParkEvent->park((jlong) recheck_interval);\n+ current->_ParkEvent->park(recheck_interval);\n+ inc_unmounted_vthreads();\n+ dec_unmounted_vthreads();", "target": "- static int MAX_RECHECK_INTERVAL = 1000;\n+ static const jlong MAX_RECHECK_INTERVAL = 1000;\n- bool do_timed_parked = false;\n- ContinuationEntry* ce = current->last_continuation();\n- if (ce != nullptr && ce->is_virtual_thread()) {\n-   do_timed_parked = true;\n- }\n+ bool do_timed_parked = has_unmounted_vthreads();\n- current->_ParkEvent->park((jlong) recheck_interval);\n+ current->_ParkEvent->park(recheck_interval);\n+ inc_unmounted_vthreads();\n+ dec_unmounted_vthreads();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：虚拟线程检测基于线程类型，可能导致不必要的定时park或错过必要的定时park，存在死锁风险。优化后：引入_unmounted_vthreads计数器跟踪未挂载虚拟线程，基于计数器状态决定是否使用定时park，并优化了park间隔处理。优化思路：通过精确跟踪未挂载虚拟线程状态，避免因虚拟线程无法运行导致的死锁，同时减少不必要的定时park开销。"}
{"id": 172, "source": "riscv-dataset-excel", "optimization_type": "算术优化+表达式化简", "optimization_description": "优化前：C2编译器在处理连续加法表达式时，如a + a + a + ... + a，会生成多个AddNode指令，导致指令数量多、计算效率低。优化后：新增Ideal_collapse_variable_times_con函数，能够识别并转换连续加法模式为乘法运算，例如将a + a + a转换为3*a。优化思路：在IGVN阶段增量式转换表达式，从左到右逐步合并相同项，支持多种模式匹配（简单加法、左移、乘法、幂次加法），避免无限循环优化，最终减少指令数量、提高计算效率。", "original_code": "C2编译器在处理连续加法表达式时，如a + a + a + ... + a，会生成多个AddNode指令，导致指令数量多、计算效率低。", "optimized_code": "Node* AddNode::Ideal_collapse_variable_times_con(PhaseGVN* phase, BasicType bt) {\n  // We need to make sure that the current AddNode is not part of a MulNode that has already been optimized to a\n  // power-of-2 addition (e.g., 3 * a => (a << 2) + a). Without this check, GVN would keep trying to optimize the same\n  // node and can't progress. For example, 3 * a => (a << 2) + a => 3 * a => (a << 2) + a => ...\n  if (Multiplication::find_power_of_two_addition_pattern(this, bt).is_valid()) {\n    return nullptr;\n  }\n\n  Node* lhs = in(1);\n  Node* rhs = in(2);\n\n  Multiplication mul = Multiplication::find_collapsible_addition_patterns(lhs, rhs, bt);\n  if (!mul.is_valid_with(rhs)) {\n    // Swap lhs and rhs then try again\n    mul = Multiplication::find_collapsible_addition_patterns(rhs, lhs, bt);\n    if (!mul.is_valid_with(lhs)) {\n      return nullptr;\n    }\n  }\n\n  Node* con;\n  if (bt == T_INT) {\n    con = phase->intcon(java_add(static_cast<jint>(mul.multiplier()), 1));\n  } else {\n    con = phase->longcon(java_add(mul.multiplier(), CONST64(1)));\n  }\n\n  return MulNode::make(con, mul.variable(), bt);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/f6d77cb33299ae0636a2b52ee752f27e9ea9191b", "code_v0_no_empty_lines": "C2编译器在处理连续加法表达式时，如a + a + a + ... + a，会生成多个AddNode指令，导致指令数量多、计算效率低。", "code_v1_no_empty_lines": "Node* AddNode::Ideal_collapse_variable_times_con(PhaseGVN* phase, BasicType bt) {\n  // We need to make sure that the current AddNode is not part of a MulNode that has already been optimized to a\n  // power-of-2 addition (e.g., 3 * a => (a << 2) + a). Without this check, GVN would keep trying to optimize the same\n  // node and can't progress. For example, 3 * a => (a << 2) + a => 3 * a => (a << 2) + a => ...\n  if (Multiplication::find_power_of_two_addition_pattern(this, bt).is_valid()) {\n    return nullptr;\n  }\n\n  Node* lhs = in(1);\n  Node* rhs = in(2);\n\n  Multiplication mul = Multiplication::find_collapsible_addition_patterns(lhs, rhs, bt);\n  if (!mul.is_valid_with(rhs)) {\n    // Swap lhs and rhs then try again\n    mul = Multiplication::find_collapsible_addition_patterns(rhs, lhs, bt);\n    if (!mul.is_valid_with(lhs)) {\n      return nullptr;\n    }\n  }\n\n  Node* con;\n  if (bt == T_INT) {\n    con = phase->intcon(java_add(static_cast<jint>(mul.multiplier()), 1));\n  } else {\n    con = phase->longcon(java_add(mul.multiplier(), CONST64(1)));\n  }\n\n  return MulNode::make(con, mul.variable(), bt);\n}", "target": "Node* AddNode::Ideal_collapse_variable_times_con(PhaseGVN* phase, BasicType bt) {\n  // We need to make sure that the current AddNode is not part of a MulNode that has already been optimized to a\n  // power-of-2 addition (e.g., 3 * a => (a << 2) + a). Without this check, GVN would keep trying to optimize the same\n  // node and can't progress. For example, 3 * a => (a << 2) + a => 3 * a => (a << 2) + a => ...\n  if (Multiplication::find_power_of_two_addition_pattern(this, bt).is_valid()) {\n    return nullptr;\n  }\n\n  Node* lhs = in(1);\n  Node* rhs = in(2);\n\n  Multiplication mul = Multiplication::find_collapsible_addition_patterns(lhs, rhs, bt);\n  if (!mul.is_valid_with(rhs)) {\n    // Swap lhs and rhs then try again\n    mul = Multiplication::find_collapsible_addition_patterns(rhs, lhs, bt);\n    if (!mul.is_valid_with(lhs)) {\n      return nullptr;\n    }\n  }\n\n  Node* con;\n  if (bt == T_INT) {\n    con = phase->intcon(java_add(static_cast<jint>(mul.multiplier()), 1));\n  } else {\n    con = phase->longcon(java_add(mul.multiplier(), CONST64(1)));\n  }\n\n  return MulNode::make(con, mul.variable(), bt);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器在处理连续加法表达式时，如a + a + a + ... + a，会生成多个AddNode指令，导致指令数量多、计算效率低。优化后：新增Ideal_collapse_variable_times_con函数，能够识别并转换连续加法模式为乘法运算，例如将a + a + a转换为3*a。优化思路：在IGVN阶段增量式转换表达式，从左到右逐步合并相同项，支持多种模式匹配（简单加法、左移、乘法、幂次加法），避免无限循环优化，最终减少指令数量、提高计算效率。"}
{"id": 173, "source": "riscv-dataset-excel", "optimization_type": "向量化架构重构", "optimization_description": "优化前：SuperWord向量化采用基于基本块（basic block）的VTransform模型，内存操作重排序（memops reordering）是向量化应用阶段的一个独立步骤，通过_mem_ref_for_main_loop_alignment引用内存节点进行主循环对齐。优化后：重构VTransform以建模整个循环（whole loop），移除独立的AUTO_VECTORIZATION2_AFTER_REORDER阶段，将内存操作重排序整合到更统一的循环建模中，使用_vpointer_for_main_loop_alignment（向量指针）替代直接内存引用，通过do_vtransform()方法统一处理向量化转换。优化思路：提升向量化架构的模块化和可维护性，将向量化过程从基于基本块的局部视图升级为基于循环的全局视图，简化阶段管理并增强对齐处理的抽象性。", "original_code": "SuperWord向量化采用基于基本块（basic block）的VTransform模型，内存操作重排序（memops reordering）是向量化应用阶段的一个独立步骤，通过_mem_ref_for_main_loop_alignment引用内存节点进行主循环对齐。", "optimized_code": "-  flags(AUTO_VECTORIZATION2_AFTER_REORDER,                    \"AutoVectorization 2, after Apply Memop Reordering\") \\n-  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 3, after Adjusting Pre-loop Limit\") \\n-  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 4, after Adding Speculative Runtime Checks\") \\n-  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 5, after Apply\") \\n+  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 2, after Adjusting Pre-loop Limit\") \\n+  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 3, after Adding Speculative Runtime Checks\") \\n+  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 4, after Apply\") \\n-  _mem_ref_for_main_loop_alignment(nullptr),\\n+  _vpointer_for_main_loop_alignment(nullptr),\\n-  return schedule_and_apply();\\n+  return do_vtransform();\\n-  _mem_ref_for_main_loop_alignment = mem;\\n+  _vpointer_for_main_loop_alignment = &vpointer(mem);\\n-  VTransform vtransform(_vloop_analyzer,\\n-                        _mem_ref_for_main_loop_alignment,\\n+  VTransform vtransform(_vloop_analyzer,\\n+                        _vpointer_for_main_loop_alignment,\\n-  _graph.apply_memops_reordering_with_schedule();\\n-  C->print_method(PHASE_AUTO_VECTORIZATION2_AFTER_REORDER, 4, cl());", "source_url": "https://github.com/openjdk/riscv-port/commit/2ac24bf1bac9c32704ebd72b93a75819b9404063", "code_v0_no_empty_lines": "SuperWord向量化采用基于基本块（basic block）的VTransform模型，内存操作重排序（memops reordering）是向量化应用阶段的一个独立步骤，通过_mem_ref_for_main_loop_alignment引用内存节点进行主循环对齐。", "code_v1_no_empty_lines": "-  flags(AUTO_VECTORIZATION2_AFTER_REORDER,                    \"AutoVectorization 2, after Apply Memop Reordering\") \\n-  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 3, after Adjusting Pre-loop Limit\") \\n-  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 4, after Adding Speculative Runtime Checks\") \\n-  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 5, after Apply\") \\n+  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 2, after Adjusting Pre-loop Limit\") \\n+  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 3, after Adding Speculative Runtime Checks\") \\n+  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 4, after Apply\") \\n-  _mem_ref_for_main_loop_alignment(nullptr),\\n+  _vpointer_for_main_loop_alignment(nullptr),\\n-  return schedule_and_apply();\\n+  return do_vtransform();\\n-  _mem_ref_for_main_loop_alignment = mem;\\n+  _vpointer_for_main_loop_alignment = &vpointer(mem);\\n-  VTransform vtransform(_vloop_analyzer,\\n-                        _mem_ref_for_main_loop_alignment,\\n+  VTransform vtransform(_vloop_analyzer,\\n+                        _vpointer_for_main_loop_alignment,\\n-  _graph.apply_memops_reordering_with_schedule();\\n-  C->print_method(PHASE_AUTO_VECTORIZATION2_AFTER_REORDER, 4, cl());", "target": "-  flags(AUTO_VECTORIZATION2_AFTER_REORDER,                    \"AutoVectorization 2, after Apply Memop Reordering\") \\n-  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 3, after Adjusting Pre-loop Limit\") \\n-  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 4, after Adding Speculative Runtime Checks\") \\n-  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 5, after Apply\") \\n+  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 2, after Adjusting Pre-loop Limit\") \\n+  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 3, after Adding Speculative Runtime Checks\") \\n+  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 4, after Apply\") \\n-  _mem_ref_for_main_loop_alignment(nullptr),\\n+  _vpointer_for_main_loop_alignment(nullptr),\\n-  return schedule_and_apply();\\n+  return do_vtransform();\\n-  _mem_ref_for_main_loop_alignment = mem;\\n+  _vpointer_for_main_loop_alignment = &vpointer(mem);\\n-  VTransform vtransform(_vloop_analyzer,\\n-                        _mem_ref_for_main_loop_alignment,\\n+  VTransform vtransform(_vloop_analyzer,\\n+                        _vpointer_for_main_loop_alignment,\\n-  _graph.apply_memops_reordering_with_schedule();\\n-  C->print_method(PHASE_AUTO_VECTORIZATION2_AFTER_REORDER, 4, cl());", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SuperWord向量化采用基于基本块（basic block）的VTransform模型，内存操作重排序（memops reordering）是向量化应用阶段的一个独立步骤，通过_mem_ref_for_main_loop_alignment引用内存节点进行主循环对齐。优化后：重构VTransform以建模整个循环（whole loop），移除独立的AUTO_VECTORIZATION2_AFTER_REORDER阶段，将内存操作重排序整合到更统一的循环建模中，使用_vpointer_for_main_loop_alignment（向量指针）替代直接内存引用，通过do_vtransform()方法统一处理向量化转换。优化思路：提升向量化架构的模块化和可维护性，将向量化过程从基于基本块的局部视图升级为基于循环的全局视图，简化阶段管理并增强对齐处理的抽象性。"}
{"id": 174, "source": "riscv-dataset-excel", "optimization_type": "内存访问优化", "optimization_description": "优化前：AlwaysAtomicAccesses标志为true时，所有内存访问都强制使用原子操作（volatile_field_store/load），即使对于字大小及以下的单拷贝原子类型（如int、float等）也产生不必要的开销。优化后：新增access_is_atomic()函数判断基本类型是否单拷贝原子，仅对非原子类型（如long、double）或volatile访问才使用原子操作。优化思路：根据JMM规范，字大小及以下的内存访问在大多数处理器上天然原子，避免对这类访问强制使用高开销的原子操作，提升普通内存访问性能。", "original_code": "AlwaysAtomicAccesses标志为true时，所有内存访问都强制使用原子操作（volatile_field_store/load），即使对于字大小及以下的单拷贝原子类型（如int、float等）也产生不必要的开销。", "optimized_code": "static bool access_is_atomic(BasicType bt) {\n  return type2aelembytes(bt) <= wordSize;\n}\n\nvoid BarrierSetC1::store_at_resolved(LIRAccess& access, LIR_Opr value) {\n  ...\n- bool is_atomic = is_volatile || AlwaysAtomicAccesses;\n+ bool needs_atomic = AlwaysAtomicAccesses && !access_is_atomic(value->type());\n  ...\n- if (is_atomic && !needs_patching) {\n+ if ((is_volatile || needs_atomic) && !needs_patching) {\n    gen->volatile_field_store(...);\n  } else {\n    __ store(...);\n  }\n}\n\nvoid BarrierSetC1::load_at_resolved(LIRAccess& access, LIR_Opr result) {\n  ...\n- bool is_atomic = is_volatile || AlwaysAtomicAccesses;\n+ bool needs_atomic = AlwaysAtomicAccesses && !access_is_atomic(result->type());\n  ...\n- } else if (is_atomic && !needs_patching) {\n+ } else if ((is_volatile || needs_atomic) && !needs_patching) {\n    gen->volatile_field_load(...);\n  } else {\n    __ load(...);\n  }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/aed9485bbb1d93063e5e5f60ed84bfb36053bdd1", "code_v0_no_empty_lines": "AlwaysAtomicAccesses标志为true时，所有内存访问都强制使用原子操作（volatile_field_store/load），即使对于字大小及以下的单拷贝原子类型（如int、float等）也产生不必要的开销。", "code_v1_no_empty_lines": "static bool access_is_atomic(BasicType bt) {\n  return type2aelembytes(bt) <= wordSize;\n}\n\nvoid BarrierSetC1::store_at_resolved(LIRAccess& access, LIR_Opr value) {\n  ...\n- bool is_atomic = is_volatile || AlwaysAtomicAccesses;\n+ bool needs_atomic = AlwaysAtomicAccesses && !access_is_atomic(value->type());\n  ...\n- if (is_atomic && !needs_patching) {\n+ if ((is_volatile || needs_atomic) && !needs_patching) {\n    gen->volatile_field_store(...);\n  } else {\n    __ store(...);\n  }\n}\n\nvoid BarrierSetC1::load_at_resolved(LIRAccess& access, LIR_Opr result) {\n  ...\n- bool is_atomic = is_volatile || AlwaysAtomicAccesses;\n+ bool needs_atomic = AlwaysAtomicAccesses && !access_is_atomic(result->type());\n  ...\n- } else if (is_atomic && !needs_patching) {\n+ } else if ((is_volatile || needs_atomic) && !needs_patching) {\n    gen->volatile_field_load(...);\n  } else {\n    __ load(...);\n  }\n}", "target": "static bool access_is_atomic(BasicType bt) {\n  return type2aelembytes(bt) <= wordSize;\n}\n\nvoid BarrierSetC1::store_at_resolved(LIRAccess& access, LIR_Opr value) {\n  ...\n- bool is_atomic = is_volatile || AlwaysAtomicAccesses;\n+ bool needs_atomic = AlwaysAtomicAccesses && !access_is_atomic(value->type());\n  ...\n- if (is_atomic && !needs_patching) {\n+ if ((is_volatile || needs_atomic) && !needs_patching) {\n    gen->volatile_field_store(...);\n  } else {\n    __ store(...);\n  }\n}\n\nvoid BarrierSetC1::load_at_resolved(LIRAccess& access, LIR_Opr result) {\n  ...\n- bool is_atomic = is_volatile || AlwaysAtomicAccesses;\n+ bool needs_atomic = AlwaysAtomicAccesses && !access_is_atomic(result->type());\n  ...\n- } else if (is_atomic && !needs_patching) {\n+ } else if ((is_volatile || needs_atomic) && !needs_patching) {\n    gen->volatile_field_load(...);\n  } else {\n    __ load(...);\n  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AlwaysAtomicAccesses标志为true时，所有内存访问都强制使用原子操作（volatile_field_store/load），即使对于字大小及以下的单拷贝原子类型（如int、float等）也产生不必要的开销。优化后：新增access_is_atomic()函数判断基本类型是否单拷贝原子，仅对非原子类型（如long、double）或volatile访问才使用原子操作。优化思路：根据JMM规范，字大小及以下的内存访问在大多数处理器上天然原子，避免对这类访问强制使用高开销的原子操作，提升普通内存访问性能。"}
{"id": 175, "source": "riscv-dataset-excel", "optimization_type": "编译器资源优化", "optimization_description": "优化前：C2编译器在处理重复堆叠字符串连接时，会无限制地合并连接操作，导致生成过多的中间表示（IR）节点，消耗大量内存和编译时间，最终触发“Hit MemLimit”等资源错误。优化后：在StringConcat::merge方法中引入参数上限（STACKED_CONCAT_UPPER_BOUND=256），当合并的连接参数数量超过此限制时，提前返回nullptr终止合并，避免资源过度消耗。优化思路：通过设置合理的参数上限，在保持优化效果的同时，防止编译器因处理过多参数而耗尽资源，确保编译过程稳定可靠。", "original_code": "C2编译器在处理重复堆叠字符串连接时，会无限制地合并连接操作，导致生成过多的中间表示（IR）节点，消耗大量内存和编译时间，最终触发“Hit MemLimit”等资源错误。", "optimized_code": "+  static constexpr uint STACKED_CONCAT_UPPER_BOUND = 256; // argument limit for a merged concat.\n+  uint arguments_appended = 0;\n+    arguments_appended += other->num_arguments();\n+      arguments_appended++;\n+    // Check if this concatenation would result in an excessive number of arguments\n+    // -- leading to high memory use, compilation time, and later, a large number of IR nodes\n+    // -- and bail out in that case.\n+    if (arguments_appended > STACKED_CONCAT_UPPER_BOUND) {\n+#ifndef PRODUCT\n+      if (PrintOptimizeStringConcat) {\n+        tty->print_cr(\"Merge candidate of length %d exceeds argument limit\", arguments_appended);\n+      }\n+#endif\n+      return nullptr;\n+    }\n-            if (merged->validate_control_flow() && merged->validate_mem_flow()) {\n+            if (merged != nullptr && merged->validate_control_flow() && merged->validate_mem_flow()) {", "source_url": "https://github.com/openjdk/riscv-port/commit/c06d6805aae3af2e6175f3f43deea46c9ce08bc6", "code_v0_no_empty_lines": "C2编译器在处理重复堆叠字符串连接时，会无限制地合并连接操作，导致生成过多的中间表示（IR）节点，消耗大量内存和编译时间，最终触发“Hit MemLimit”等资源错误。", "code_v1_no_empty_lines": "+  static constexpr uint STACKED_CONCAT_UPPER_BOUND = 256; // argument limit for a merged concat.\n+  uint arguments_appended = 0;\n+    arguments_appended += other->num_arguments();\n+      arguments_appended++;\n+    // Check if this concatenation would result in an excessive number of arguments\n+    // -- leading to high memory use, compilation time, and later, a large number of IR nodes\n+    // -- and bail out in that case.\n+    if (arguments_appended > STACKED_CONCAT_UPPER_BOUND) {\n+#ifndef PRODUCT\n+      if (PrintOptimizeStringConcat) {\n+        tty->print_cr(\"Merge candidate of length %d exceeds argument limit\", arguments_appended);\n+      }\n+#endif\n+      return nullptr;\n+    }\n-            if (merged->validate_control_flow() && merged->validate_mem_flow()) {\n+            if (merged != nullptr && merged->validate_control_flow() && merged->validate_mem_flow()) {", "target": "+  static constexpr uint STACKED_CONCAT_UPPER_BOUND = 256; // argument limit for a merged concat.\n+  uint arguments_appended = 0;\n+    arguments_appended += other->num_arguments();\n+      arguments_appended++;\n+    // Check if this concatenation would result in an excessive number of arguments\n+    // -- leading to high memory use, compilation time, and later, a large number of IR nodes\n+    // -- and bail out in that case.\n+    if (arguments_appended > STACKED_CONCAT_UPPER_BOUND) {\n+#ifndef PRODUCT\n+      if (PrintOptimizeStringConcat) {\n+        tty->print_cr(\"Merge candidate of length %d exceeds argument limit\", arguments_appended);\n+      }\n+#endif\n+      return nullptr;\n+    }\n-            if (merged->validate_control_flow() && merged->validate_mem_flow()) {\n+            if (merged != nullptr && merged->validate_control_flow() && merged->validate_mem_flow()) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器在处理重复堆叠字符串连接时，会无限制地合并连接操作，导致生成过多的中间表示（IR）节点，消耗大量内存和编译时间，最终触发“Hit MemLimit”等资源错误。优化后：在StringConcat::merge方法中引入参数上限（STACKED_CONCAT_UPPER_BOUND=256），当合并的连接参数数量超过此限制时，提前返回nullptr终止合并，避免资源过度消耗。优化思路：通过设置合理的参数上限，在保持优化效果的同时，防止编译器因处理过多参数而耗尽资源，确保编译过程稳定可靠。"}
{"id": 176, "source": "riscv-dataset-excel", "optimization_type": "内存访问优化+指令优化", "optimization_description": "优化前：1) 短数组阈值过低（<8字节），导致小数组过早进入复杂处理路径；2) 未对齐数组在AVX2填充时会产生SPLIT_STORE，降低内存访问效率；3) 4字节填充为单次操作，未充分利用循环。优化后：1) 提高短数组阈值至<32字节，减少分支开销；2) 为较大数组（>96元素）添加缓存行对齐逻辑，通过预填充对齐数据避免SPLIT_STORE；3) 将4字节填充重构为循环结构，减少指令跳转。优化思路：通过调整阈值、添加内存对齐和重构循环，减少分支预测失败和内存访问惩罚，提升数组填充性能。", "original_code": "1) 短数组阈值过低（<8字节），导致小数组过早进入复杂处理路径；2) 未对齐数组在AVX2填充时会产生SPLIT_STORE，降低内存访问效率；3) 4字节填充为单次操作，未充分利用循环。", "optimized_code": "1. cmpptr(count, 2<<shift); -> cmpptr(count, 8 << shift);\n2. 新增对齐逻辑：if (EnableX86ECoreOpts) { ... // align 'big' arrays to cache lines }\n3. 重构4字节填充循环：从单次填充改为循环结构", "source_url": "https://github.com/openjdk/riscv-port/commit/ba7bf43c76c94bea85dbbd865794184b7ee0cc86", "code_v0_no_empty_lines": "1) 短数组阈值过低（<8字节），导致小数组过早进入复杂处理路径；2) 未对齐数组在AVX2填充时会产生SPLIT_STORE，降低内存访问效率；3) 4字节填充为单次操作，未充分利用循环。", "code_v1_no_empty_lines": "1. cmpptr(count, 2<<shift); -> cmpptr(count, 8 << shift);\n2. 新增对齐逻辑：if (EnableX86ECoreOpts) { ... // align 'big' arrays to cache lines }\n3. 重构4字节填充循环：从单次填充改为循环结构", "target": "1. cmpptr(count, 2<<shift); -> cmpptr(count, 8 << shift);\n2. 新增对齐逻辑：if (EnableX86ECoreOpts) { ... // align 'big' arrays to cache lines }\n3. 重构4字节填充循环：从单次填充改为循环结构", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1) 短数组阈值过低（<8字节），导致小数组过早进入复杂处理路径；2) 未对齐数组在AVX2填充时会产生SPLIT_STORE，降低内存访问效率；3) 4字节填充为单次操作，未充分利用循环。优化后：1) 提高短数组阈值至<32字节，减少分支开销；2) 为较大数组（>96元素）添加缓存行对齐逻辑，通过预填充对齐数据避免SPLIT_STORE；3) 将4字节填充重构为循环结构，减少指令跳转。优化思路：通过调整阈值、添加内存对齐和重构循环，减少分支预测失败和内存访问惩罚，提升数组填充性能。"}
{"id": 177, "source": "riscv-dataset-excel", "optimization_type": "内存优化+代码缓存管理优化", "optimization_description": "优化前：CodeCache中的nmethod无法在运行时重新定位，导致内存碎片化和空间浪费。优化后：实现了nmethod在CodeCache内的重定位功能，允许运行时移动已编译方法到更优的内存位置。优化思路：通过修改编译代码保护机制（CompiledICProtectionBehaviour），在nmethod未安装状态时允许安全操作；移除不必要的断言检查；添加重定位相关逻辑，减少内存碎片，提高CodeCache空间利用率。", "original_code": "CodeCache中的nmethod无法在运行时重新定位，导致内存碎片化和空间浪费。", "optimized_code": "--- a/src/hotspot/share/code/codeBehaviours.cpp\n+++ b/src/hotspot/share/code/codeBehaviours.cpp\n@@ -23,23 +23,24 @@\n #include \"code/codeBehaviours.hpp\"\n+#include \"code/nmethod.hpp\"\n #include \"runtime/mutexLocker.hpp\"\n #include \"runtime/safepoint.hpp\"\n@@ -33,18 +33,18 @@\n class CompiledICProtectionBehaviour {\n public:\n-  virtual bool lock(nmethod* method) = 0;\n-  virtual void unlock(nmethod* method) = 0;\n-  virtual bool is_safe(nmethod* method) = 0;\n+  virtual bool lock(nmethod* nm) = 0;\n+  virtual void unlock(nmethod* nm) = 0;\n+  virtual bool is_safe(nmethod* nm) = 0;\n@@ -90,7 +90,6 @@ void trampoline_stub_Relocation::pd_fix_owner_after_move() {\n   NativeCall* call = nativeCall_at(owner());\n-  assert(call->raw_destination() == owner(), \"destination should be empty\");\n   address trampoline = addr();", "source_url": "https://github.com/openjdk/riscv-port/commit/f740cd2aad43a008da1ed1ff15ebe2c790f893a0", "code_v0_no_empty_lines": "CodeCache中的nmethod无法在运行时重新定位，导致内存碎片化和空间浪费。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/code/codeBehaviours.cpp\n+++ b/src/hotspot/share/code/codeBehaviours.cpp\n@@ -23,23 +23,24 @@\n #include \"code/codeBehaviours.hpp\"\n+#include \"code/nmethod.hpp\"\n #include \"runtime/mutexLocker.hpp\"\n #include \"runtime/safepoint.hpp\"\n@@ -33,18 +33,18 @@\n class CompiledICProtectionBehaviour {\n public:\n-  virtual bool lock(nmethod* method) = 0;\n-  virtual void unlock(nmethod* method) = 0;\n-  virtual bool is_safe(nmethod* method) = 0;\n+  virtual bool lock(nmethod* nm) = 0;\n+  virtual void unlock(nmethod* nm) = 0;\n+  virtual bool is_safe(nmethod* nm) = 0;\n@@ -90,7 +90,6 @@ void trampoline_stub_Relocation::pd_fix_owner_after_move() {\n   NativeCall* call = nativeCall_at(owner());\n-  assert(call->raw_destination() == owner(), \"destination should be empty\");\n   address trampoline = addr();", "target": "--- a/src/hotspot/share/code/codeBehaviours.cpp\n+++ b/src/hotspot/share/code/codeBehaviours.cpp\n@@ -23,23 +23,24 @@\n #include \"code/codeBehaviours.hpp\"\n+#include \"code/nmethod.hpp\"\n #include \"runtime/mutexLocker.hpp\"\n #include \"runtime/safepoint.hpp\"\n@@ -33,18 +33,18 @@\n class CompiledICProtectionBehaviour {\n public:\n-  virtual bool lock(nmethod* method) = 0;\n-  virtual void unlock(nmethod* method) = 0;\n-  virtual bool is_safe(nmethod* method) = 0;\n+  virtual bool lock(nmethod* nm) = 0;\n+  virtual void unlock(nmethod* nm) = 0;\n+  virtual bool is_safe(nmethod* nm) = 0;\n@@ -90,7 +90,6 @@ void trampoline_stub_Relocation::pd_fix_owner_after_move() {\n   NativeCall* call = nativeCall_at(owner());\n-  assert(call->raw_destination() == owner(), \"destination should be empty\");\n   address trampoline = addr();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CodeCache中的nmethod无法在运行时重新定位，导致内存碎片化和空间浪费。优化后：实现了nmethod在CodeCache内的重定位功能，允许运行时移动已编译方法到更优的内存位置。优化思路：通过修改编译代码保护机制（CompiledICProtectionBehaviour），在nmethod未安装状态时允许安全操作；移除不必要的断言检查；添加重定位相关逻辑，减少内存碎片，提高CodeCache空间利用率。"}
{"id": 178, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：数组哈希码计算使用标量指令逐元素处理，效率较低。优化后：为RISC-V RVV向量扩展实现向量化哈希码计算函数arrays_hashcode_v，使用向量寄存器并行处理多个数组元素，通过vle32_v、vmul_vv、vmadd_vx等向量指令批量加载、乘法和累加操作，显著提升计算性能。优化思路：利用RISC-V向量扩展的SIMD能力，将哈希码计算中的乘法和累加操作向量化，同时保持向后兼容的标量尾部处理。", "original_code": "数组哈希码计算使用标量指令逐元素处理，效率较低。", "optimized_code": "+void C2_MacroAssembler::arrays_hashcode_v(Register ary, Register cnt, Register result,\n+                                          Register tmp1, Register tmp2, Register tmp3,\n+                                          BasicType eltype)\n+{\n+  assert(UseRVV, \"sanity\");\n+  assert(StubRoutines::riscv::arrays_hashcode_powers_of_31() != nullptr, \"sanity\");\n+  assert_different_registers(ary, cnt, result, tmp1, tmp2, tmp3, t0, t1);\n+\n+  // The MaxVectorSize should have been set by detecting RVV max vector register\n+  // size when check UseRVV (i.e. MaxVectorSize == VM_Version::_initial_vector_length).\n+  // Let's use T_INT as all hashCode calculations eventually deal with ints.\n+  const int lmul = 2;\n+  const int stride = MaxVectorSize / sizeof(jint) * lmul;\n+\n+  const int elsize_bytes = arrays_hashcode_elsize(eltype);\n+  const int elsize_shift = exact_log2(elsize_bytes);\n+\n+  switch (eltype) {\n+    case T_BOOLEAN: BLOCK_COMMENT(\"arrays_hashcode_v(unsigned byte) {\"); break;\n+    case T_CHAR:    BLOCK_COMMENT(\"arrays_hashcode_v(char) {\");          break;\n+    case T_BYTE:    BLOCK_COMMENT(\"arrays_hashcode_v(byte) {\");          break;\n+    case T_SHORT:   BLOCK_COMMENT(\"arrays_hashcode_v(short) {\");         break;\n+    case T_INT:     BLOCK_COMMENT(\"arrays_hashcode_v(int) {\");           break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  const Register pow31_highest = tmp1;\n+  const Register ary_end       = tmp2;\n+  const Register consumed      = tmp3;\n+\n+  const VectorRegister v_sum    = v2;\n+  const VectorRegister v_src    = v4;\n+  const VectorRegister v_coeffs = v6;\n+  const VectorRegister v_tmp    = v8;\n+\n+  const address adr_pows31 = StubRoutines::riscv::arrays_hashcode_powers_of_31()\n+                           + sizeof(jint);\n+  Label VEC_LOOP, DONE, SCALAR_TAIL, SCALAR_TAIL_LOOP;\n+\n+  // NB: at this point (a) 'result' already has some value,\n+  // (b) 'cnt' is not 0 or 1, see java code for details.\n+\n+  andi(t0, cnt, ~(stride - 1));\n+  beqz(t0, SCALAR_TAIL);\n+\n+  la(t1, ExternalAddress(adr_pows31));\n+  lw(pow31_highest, Address(t1, -1 * sizeof(jint)));\n+\n+  vsetvli(consumed, cnt, Assembler::e32, Assembler::m2);\n+  vle32_v(v_coeffs, t1); // 31^^(stride - 1) ... 31^^0\n+  vmv_v_x(v_sum, x0);\n+\n+  bind(VEC_LOOP);\n+  arrays_hashcode_elload_v(v_src, v_tmp, ary, eltype);\n+  vmul_vv(v_src, v_src, v_coeffs);\n+  vmadd_vx(v_sum, pow31_highest, v_src);\n+  mulw(result, result, pow31_highest);\n+  shadd(ary, consumed, ary, t0, elsize_shift);\n+  subw(cnt, cnt, consumed);\n+  andi(t1, cnt, ~(stride - 1));\n+  bnez(t1, VEC_LOOP);\n+\n+  vmv_s_x(v_tmp, x0);\n+  vredsum_vs(v_sum, v_sum, v_tmp);\n+  vmv_x_s(t0, v_sum);\n+  addw(result, result, t0);\n+  beqz(cnt, DONE);\n+\n+  bind(SCALAR_TAIL);\n+  shadd(ary_end, cnt, ary, t0, elsize_shift);\n+\n+  bind(SCALAR_TAIL_LOOP);\n+  arrays_hashcode_elload(t0, Address(ary), eltype);\n+  slli(t1, result, 5);      // optimize 31 * result\n+  subw(result, t1, result); // with result<<5 - result\n+  addw(result, result, t0);\n+  addi(ary, ary, elsize_bytes);\n+  bne(ary, ary_end, SCALAR_TAIL_LOOP);\n+\n+  bind(DONE);\n+  BLOCK_COMMENT(\"} // arrays_hashcode_v\");\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/134b63f0e8c4093f7ad0a528d6996898ab881d5c", "code_v0_no_empty_lines": "数组哈希码计算使用标量指令逐元素处理，效率较低。", "code_v1_no_empty_lines": "+void C2_MacroAssembler::arrays_hashcode_v(Register ary, Register cnt, Register result,\n+                                          Register tmp1, Register tmp2, Register tmp3,\n+                                          BasicType eltype)\n+{\n+  assert(UseRVV, \"sanity\");\n+  assert(StubRoutines::riscv::arrays_hashcode_powers_of_31() != nullptr, \"sanity\");\n+  assert_different_registers(ary, cnt, result, tmp1, tmp2, tmp3, t0, t1);\n+\n+  // The MaxVectorSize should have been set by detecting RVV max vector register\n+  // size when check UseRVV (i.e. MaxVectorSize == VM_Version::_initial_vector_length).\n+  // Let's use T_INT as all hashCode calculations eventually deal with ints.\n+  const int lmul = 2;\n+  const int stride = MaxVectorSize / sizeof(jint) * lmul;\n+\n+  const int elsize_bytes = arrays_hashcode_elsize(eltype);\n+  const int elsize_shift = exact_log2(elsize_bytes);\n+\n+  switch (eltype) {\n+    case T_BOOLEAN: BLOCK_COMMENT(\"arrays_hashcode_v(unsigned byte) {\"); break;\n+    case T_CHAR:    BLOCK_COMMENT(\"arrays_hashcode_v(char) {\");          break;\n+    case T_BYTE:    BLOCK_COMMENT(\"arrays_hashcode_v(byte) {\");          break;\n+    case T_SHORT:   BLOCK_COMMENT(\"arrays_hashcode_v(short) {\");         break;\n+    case T_INT:     BLOCK_COMMENT(\"arrays_hashcode_v(int) {\");           break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  const Register pow31_highest = tmp1;\n+  const Register ary_end       = tmp2;\n+  const Register consumed      = tmp3;\n+\n+  const VectorRegister v_sum    = v2;\n+  const VectorRegister v_src    = v4;\n+  const VectorRegister v_coeffs = v6;\n+  const VectorRegister v_tmp    = v8;\n+\n+  const address adr_pows31 = StubRoutines::riscv::arrays_hashcode_powers_of_31()\n+                           + sizeof(jint);\n+  Label VEC_LOOP, DONE, SCALAR_TAIL, SCALAR_TAIL_LOOP;\n+\n+  // NB: at this point (a) 'result' already has some value,\n+  // (b) 'cnt' is not 0 or 1, see java code for details.\n+\n+  andi(t0, cnt, ~(stride - 1));\n+  beqz(t0, SCALAR_TAIL);\n+\n+  la(t1, ExternalAddress(adr_pows31));\n+  lw(pow31_highest, Address(t1, -1 * sizeof(jint)));\n+\n+  vsetvli(consumed, cnt, Assembler::e32, Assembler::m2);\n+  vle32_v(v_coeffs, t1); // 31^^(stride - 1) ... 31^^0\n+  vmv_v_x(v_sum, x0);\n+\n+  bind(VEC_LOOP);\n+  arrays_hashcode_elload_v(v_src, v_tmp, ary, eltype);\n+  vmul_vv(v_src, v_src, v_coeffs);\n+  vmadd_vx(v_sum, pow31_highest, v_src);\n+  mulw(result, result, pow31_highest);\n+  shadd(ary, consumed, ary, t0, elsize_shift);\n+  subw(cnt, cnt, consumed);\n+  andi(t1, cnt, ~(stride - 1));\n+  bnez(t1, VEC_LOOP);\n+\n+  vmv_s_x(v_tmp, x0);\n+  vredsum_vs(v_sum, v_sum, v_tmp);\n+  vmv_x_s(t0, v_sum);\n+  addw(result, result, t0);\n+  beqz(cnt, DONE);\n+\n+  bind(SCALAR_TAIL);\n+  shadd(ary_end, cnt, ary, t0, elsize_shift);\n+\n+  bind(SCALAR_TAIL_LOOP);\n+  arrays_hashcode_elload(t0, Address(ary), eltype);\n+  slli(t1, result, 5);      // optimize 31 * result\n+  subw(result, t1, result); // with result<<5 - result\n+  addw(result, result, t0);\n+  addi(ary, ary, elsize_bytes);\n+  bne(ary, ary_end, SCALAR_TAIL_LOOP);\n+\n+  bind(DONE);\n+  BLOCK_COMMENT(\"} // arrays_hashcode_v\");\n+}", "target": "+void C2_MacroAssembler::arrays_hashcode_v(Register ary, Register cnt, Register result,\n+                                          Register tmp1, Register tmp2, Register tmp3,\n+                                          BasicType eltype)\n+{\n+  assert(UseRVV, \"sanity\");\n+  assert(StubRoutines::riscv::arrays_hashcode_powers_of_31() != nullptr, \"sanity\");\n+  assert_different_registers(ary, cnt, result, tmp1, tmp2, tmp3, t0, t1);\n+\n+  // The MaxVectorSize should have been set by detecting RVV max vector register\n+  // size when check UseRVV (i.e. MaxVectorSize == VM_Version::_initial_vector_length).\n+  // Let's use T_INT as all hashCode calculations eventually deal with ints.\n+  const int lmul = 2;\n+  const int stride = MaxVectorSize / sizeof(jint) * lmul;\n+\n+  const int elsize_bytes = arrays_hashcode_elsize(eltype);\n+  const int elsize_shift = exact_log2(elsize_bytes);\n+\n+  switch (eltype) {\n+    case T_BOOLEAN: BLOCK_COMMENT(\"arrays_hashcode_v(unsigned byte) {\"); break;\n+    case T_CHAR:    BLOCK_COMMENT(\"arrays_hashcode_v(char) {\");          break;\n+    case T_BYTE:    BLOCK_COMMENT(\"arrays_hashcode_v(byte) {\");          break;\n+    case T_SHORT:   BLOCK_COMMENT(\"arrays_hashcode_v(short) {\");         break;\n+    case T_INT:     BLOCK_COMMENT(\"arrays_hashcode_v(int) {\");           break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  const Register pow31_highest = tmp1;\n+  const Register ary_end       = tmp2;\n+  const Register consumed      = tmp3;\n+\n+  const VectorRegister v_sum    = v2;\n+  const VectorRegister v_src    = v4;\n+  const VectorRegister v_coeffs = v6;\n+  const VectorRegister v_tmp    = v8;\n+\n+  const address adr_pows31 = StubRoutines::riscv::arrays_hashcode_powers_of_31()\n+                           + sizeof(jint);\n+  Label VEC_LOOP, DONE, SCALAR_TAIL, SCALAR_TAIL_LOOP;\n+\n+  // NB: at this point (a) 'result' already has some value,\n+  // (b) 'cnt' is not 0 or 1, see java code for details.\n+\n+  andi(t0, cnt, ~(stride - 1));\n+  beqz(t0, SCALAR_TAIL);\n+\n+  la(t1, ExternalAddress(adr_pows31));\n+  lw(pow31_highest, Address(t1, -1 * sizeof(jint)));\n+\n+  vsetvli(consumed, cnt, Assembler::e32, Assembler::m2);\n+  vle32_v(v_coeffs, t1); // 31^^(stride - 1) ... 31^^0\n+  vmv_v_x(v_sum, x0);\n+\n+  bind(VEC_LOOP);\n+  arrays_hashcode_elload_v(v_src, v_tmp, ary, eltype);\n+  vmul_vv(v_src, v_src, v_coeffs);\n+  vmadd_vx(v_sum, pow31_highest, v_src);\n+  mulw(result, result, pow31_highest);\n+  shadd(ary, consumed, ary, t0, elsize_shift);\n+  subw(cnt, cnt, consumed);\n+  andi(t1, cnt, ~(stride - 1));\n+  bnez(t1, VEC_LOOP);\n+\n+  vmv_s_x(v_tmp, x0);\n+  vredsum_vs(v_sum, v_sum, v_tmp);\n+  vmv_x_s(t0, v_sum);\n+  addw(result, result, t0);\n+  beqz(cnt, DONE);\n+\n+  bind(SCALAR_TAIL);\n+  shadd(ary_end, cnt, ary, t0, elsize_shift);\n+\n+  bind(SCALAR_TAIL_LOOP);\n+  arrays_hashcode_elload(t0, Address(ary), eltype);\n+  slli(t1, result, 5);      // optimize 31 * result\n+  subw(result, t1, result); // with result<<5 - result\n+  addw(result, result, t0);\n+  addi(ary, ary, elsize_bytes);\n+  bne(ary, ary_end, SCALAR_TAIL_LOOP);\n+\n+  bind(DONE);\n+  BLOCK_COMMENT(\"} // arrays_hashcode_v\");\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：数组哈希码计算使用标量指令逐元素处理，效率较低。优化后：为RISC-V RVV向量扩展实现向量化哈希码计算函数arrays_hashcode_v，使用向量寄存器并行处理多个数组元素，通过vle32_v、vmul_vv、vmadd_vx等向量指令批量加载、乘法和累加操作，显著提升计算性能。优化思路：利用RISC-V向量扩展的SIMD能力，将哈希码计算中的乘法和累加操作向量化，同时保持向后兼容的标量尾部处理。"}
{"id": 179, "source": "riscv-dataset-excel", "optimization_type": "并行化优化+负载均衡", "optimization_description": "优化前：KlassCleaningTask使用基于Klass的迭代器（ClassLoaderDataGraphKlassIteratorAtomic），通过原子操作逐个获取Klass进行处理，存在负载不均衡问题，因为不同ClassLoaderData包含的Klass数量差异很大。优化后：改为基于ClassLoaderData的迭代器（ClassLoaderDataGraphIteratorAtomic），每个worker线程处理一个完整的ClassLoaderData，通过cur->classes_do(&cl)批量处理该CLD下的所有Klass。优化思路：将任务粒度从单个Klass调整为整个ClassLoaderData，减少原子操作开销，改善并行负载均衡，提高GC期间类清理的并行效率。", "original_code": "KlassCleaningTask使用基于Klass的迭代器（ClassLoaderDataGraphKlassIteratorAtomic），通过原子操作逐个获取Klass进行处理，存在负载不均衡问题，因为不同ClassLoaderData包含的Klass数量差异很大。", "optimized_code": "void KlassCleaningTask::work() {\n  for (ClassLoaderData* cur = _cld_iterator_atomic.next(); cur != nullptr; cur = _cld_iterator_atomic.next()) {\n      class CleanKlasses : public KlassClosure {\n      public:\n        void do_klass(Klass* klass) override {\n          klass->clean_subklass(true);\n          Klass* sibling = klass->next_sibling(true);\n          klass->set_next_sibling(sibling);\n          if (klass->is_instance_klass()) {\n            Klass::clean_weak_instanceklass_links(InstanceKlass::cast(klass));\n          }\n          assert(klass->subklass() == nullptr || klass->subklass()->is_loader_alive(), \"must be\");\n          assert(klass->next_sibling(false) == nullptr || klass->next_sibling(false)->is_loader_alive(), \"must be\");\n        }\n      } cl;\n      cur->classes_do(&cl);\n  }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/586167cff5aaead0949c509f48bc5080834cc362", "code_v0_no_empty_lines": "KlassCleaningTask使用基于Klass的迭代器（ClassLoaderDataGraphKlassIteratorAtomic），通过原子操作逐个获取Klass进行处理，存在负载不均衡问题，因为不同ClassLoaderData包含的Klass数量差异很大。", "code_v1_no_empty_lines": "void KlassCleaningTask::work() {\n  for (ClassLoaderData* cur = _cld_iterator_atomic.next(); cur != nullptr; cur = _cld_iterator_atomic.next()) {\n      class CleanKlasses : public KlassClosure {\n      public:\n        void do_klass(Klass* klass) override {\n          klass->clean_subklass(true);\n          Klass* sibling = klass->next_sibling(true);\n          klass->set_next_sibling(sibling);\n          if (klass->is_instance_klass()) {\n            Klass::clean_weak_instanceklass_links(InstanceKlass::cast(klass));\n          }\n          assert(klass->subklass() == nullptr || klass->subklass()->is_loader_alive(), \"must be\");\n          assert(klass->next_sibling(false) == nullptr || klass->next_sibling(false)->is_loader_alive(), \"must be\");\n        }\n      } cl;\n      cur->classes_do(&cl);\n  }\n}", "target": "void KlassCleaningTask::work() {\n  for (ClassLoaderData* cur = _cld_iterator_atomic.next(); cur != nullptr; cur = _cld_iterator_atomic.next()) {\n      class CleanKlasses : public KlassClosure {\n      public:\n        void do_klass(Klass* klass) override {\n          klass->clean_subklass(true);\n          Klass* sibling = klass->next_sibling(true);\n          klass->set_next_sibling(sibling);\n          if (klass->is_instance_klass()) {\n            Klass::clean_weak_instanceklass_links(InstanceKlass::cast(klass));\n          }\n          assert(klass->subklass() == nullptr || klass->subklass()->is_loader_alive(), \"must be\");\n          assert(klass->next_sibling(false) == nullptr || klass->next_sibling(false)->is_loader_alive(), \"must be\");\n        }\n      } cl;\n      cur->classes_do(&cl);\n  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：KlassCleaningTask使用基于Klass的迭代器（ClassLoaderDataGraphKlassIteratorAtomic），通过原子操作逐个获取Klass进行处理，存在负载不均衡问题，因为不同ClassLoaderData包含的Klass数量差异很大。优化后：改为基于ClassLoaderData的迭代器（ClassLoaderDataGraphIteratorAtomic），每个worker线程处理一个完整的ClassLoaderData，通过cur->classes_do(&cl)批量处理该CLD下的所有Klass。优化思路：将任务粒度从单个Klass调整为整个ClassLoaderData，减少原子操作开销，改善并行负载均衡，提高GC期间类清理的并行效率。"}
{"id": 180, "source": "riscv-dataset-excel", "optimization_type": "硬件检测优化+向量化优化", "optimization_description": "优化前：仅通过单一unaligned_access标志检测硬件非对齐访问性能，无法区分标量和向量访问特性，可能导致向量操作使用次优对齐策略。优化后：通过hwprobe系统调用分别检测标量（unaligned_scalar）和向量（unaligned_vector）的非对齐访问性能，并据此设置AvoidUnalignedAccesses、UseUnalignedAccesses和新增的AlignVector标志。优化思路：更精确的硬件能力检测允许JVM根据实际硬件特性选择最优的内存访问策略，特别是为向量操作启用更合适的对齐策略，提升SIMD指令性能。", "original_code": "仅通过单一unaligned_access标志检测硬件非对齐访问性能，无法区分标量和向量访问特性，可能导致向量操作使用次优对齐策略。", "optimized_code": "- FLAG_SET_DEFAULT(AvoidUnalignedAccesses,\n      unaligned_access.value() != MISALIGNED_FAST);\n+ FLAG_SET_DEFAULT(AvoidUnalignedAccesses,\n      unaligned_scalar.value() != MISALIGNED_SCALAR_FAST);\n\n- FLAG_SET_DEFAULT(UseUnalignedAccesses,\n      unaligned_access.value() == MISALIGNED_FAST);\n+ FLAG_SET_DEFAULT(UseUnalignedAccesses,\n      (unaligned_scalar.value() == MISALIGNED_SCALAR_FAST));\n\n+ if (FLAG_IS_DEFAULT(AlignVector)) {\n+   FLAG_SET_DEFAULT(AlignVector,\n+     unaligned_vector.value() != MISALIGNED_VECTOR_FAST);\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/538a722c2e9123cc575355879ff230444cf2dadc", "code_v0_no_empty_lines": "仅通过单一unaligned_access标志检测硬件非对齐访问性能，无法区分标量和向量访问特性，可能导致向量操作使用次优对齐策略。", "code_v1_no_empty_lines": "- FLAG_SET_DEFAULT(AvoidUnalignedAccesses,\n      unaligned_access.value() != MISALIGNED_FAST);\n+ FLAG_SET_DEFAULT(AvoidUnalignedAccesses,\n      unaligned_scalar.value() != MISALIGNED_SCALAR_FAST);\n\n- FLAG_SET_DEFAULT(UseUnalignedAccesses,\n      unaligned_access.value() == MISALIGNED_FAST);\n+ FLAG_SET_DEFAULT(UseUnalignedAccesses,\n      (unaligned_scalar.value() == MISALIGNED_SCALAR_FAST));\n\n+ if (FLAG_IS_DEFAULT(AlignVector)) {\n+   FLAG_SET_DEFAULT(AlignVector,\n+     unaligned_vector.value() != MISALIGNED_VECTOR_FAST);\n+ }", "target": "- FLAG_SET_DEFAULT(AvoidUnalignedAccesses,\n      unaligned_access.value() != MISALIGNED_FAST);\n+ FLAG_SET_DEFAULT(AvoidUnalignedAccesses,\n      unaligned_scalar.value() != MISALIGNED_SCALAR_FAST);\n\n- FLAG_SET_DEFAULT(UseUnalignedAccesses,\n      unaligned_access.value() == MISALIGNED_FAST);\n+ FLAG_SET_DEFAULT(UseUnalignedAccesses,\n      (unaligned_scalar.value() == MISALIGNED_SCALAR_FAST));\n\n+ if (FLAG_IS_DEFAULT(AlignVector)) {\n+   FLAG_SET_DEFAULT(AlignVector,\n+     unaligned_vector.value() != MISALIGNED_VECTOR_FAST);\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：仅通过单一unaligned_access标志检测硬件非对齐访问性能，无法区分标量和向量访问特性，可能导致向量操作使用次优对齐策略。优化后：通过hwprobe系统调用分别检测标量（unaligned_scalar）和向量（unaligned_vector）的非对齐访问性能，并据此设置AvoidUnalignedAccesses、UseUnalignedAccesses和新增的AlignVector标志。优化思路：更精确的硬件能力检测允许JVM根据实际硬件特性选择最优的内存访问策略，特别是为向量操作启用更合适的对齐策略，提升SIMD指令性能。"}
{"id": 181, "source": "riscv-dataset-excel", "optimization_type": "代码重构+依赖管理优化", "optimization_description": "优化前：RISC-V CPU扩展依赖检查在.cpp文件中硬编码，每个依赖扩展都需要单独的条件判断和警告逻辑，代码重复且难以维护。优化后：重构为通用的依赖管理机制，在.hpp文件中添加deps_all_enabled()和deps_string()辅助函数，将UPDATE_DEFAULT_DEP宏改为支持可变参数，可处理任意数量的依赖扩展。优化思路：通过抽象和泛化减少代码重复，提高可维护性和扩展性，同时提供更详细的依赖关系警告信息。", "original_code": "RISC-V CPU扩展依赖检查在.cpp文件中硬编码，每个依赖扩展都需要单独的条件判断和警告逻辑，代码重复且难以维护。", "optimized_code": "- #define UPDATE_DEFAULT_DEP(flag, dep)      \\\n  void update_flag() {                       \\\n      assert(enabled(), \"Must be.\");         \\\n      /* dep must be declared before */      \\\n      assert((uintptr_t)(this) >             \\\n             (uintptr_t)(&dep), \"Invalid\");  \\\n      if (FLAG_IS_DEFAULT(flag)) {           \\\n        if (dep.enabled()) {                 \\\n          FLAG_SET_DEFAULT(flag, true);      \\\n        } else {                             \\\n          FLAG_SET_DEFAULT(flag, false);     \\\n          /* Sync CPU features with flags */ \\\n          disable_feature();                 \\\n        }                                    \\\n      } else {                               \\\n        /* Sync CPU features with flags */   \\\n        if (!flag) {                         \\\n          disable_feature();                 \\\n        }                                    \\\n      }                                      \\\n  }                                          \\\n\n+ #define UPDATE_DEFAULT_DEP(flag, dep0, ...)                                                               \\\n  void update_flag() {                                                                                      \\\n      assert(enabled(), \"Must be.\");                                                                        \\\n      if (FLAG_IS_DEFAULT(flag)) {                                                                          \\\n        if (this->deps_all_enabled(dep0, ##__VA_ARGS__)) {                                                  \\\n          FLAG_SET_DEFAULT(flag, true);                                                                     \\\n        } else {                                                                                            \\\n          FLAG_SET_DEFAULT(flag, false);                                                                    \\\n          stringStream ss;                                                                                  \\\n          deps_string(ss, dep0, ##__VA_ARGS__);                                                             \\\n          warning(\"Cannot enable \" #flag \", it's missing dependent extension(s) %s\", ss.as_string(true));   \\\n          /* Sync CPU features with flags */                                                                \\\n          disable_feature();                                                                                \\\n        }                                                                                                   \\\n      } else {                                                                                              \\\n        /* Sync CPU features with flags */                                                                  \\\n        if (!flag) {                                                                                        \\\n          disable_feature();                                                                                \\\n        } else if (!deps_all_enabled(dep0, ##__VA_ARGS__)) {                                                \\\n          FLAG_SET_DEFAULT(flag, false);                                                                    \\\n          stringStream ss;                                                                                  \\\n          deps_string(ss, dep0, ##__VA_ARGS__);                                                             \\\n          warning(\"Cannot enable \" #flag \", it's missing dependent extension(s) %s\", ss.as_string(true));   \\\n          /* Sync CPU features with flags */                                                                \\\n          disable_feature();                                                                                \\\n        }                                                                                                   \\\n      }                                                                                                     \\\n  }                                                                                                         \\", "source_url": "https://github.com/openjdk/riscv-port/commit/9d71af108ea2cc3682607527246d60a19fd820ba", "code_v0_no_empty_lines": "RISC-V CPU扩展依赖检查在.cpp文件中硬编码，每个依赖扩展都需要单独的条件判断和警告逻辑，代码重复且难以维护。", "code_v1_no_empty_lines": "- #define UPDATE_DEFAULT_DEP(flag, dep)      \\\n  void update_flag() {                       \\\n      assert(enabled(), \"Must be.\");         \\\n      /* dep must be declared before */      \\\n      assert((uintptr_t)(this) >             \\\n             (uintptr_t)(&dep), \"Invalid\");  \\\n      if (FLAG_IS_DEFAULT(flag)) {           \\\n        if (dep.enabled()) {                 \\\n          FLAG_SET_DEFAULT(flag, true);      \\\n        } else {                             \\\n          FLAG_SET_DEFAULT(flag, false);     \\\n          /* Sync CPU features with flags */ \\\n          disable_feature();                 \\\n        }                                    \\\n      } else {                               \\\n        /* Sync CPU features with flags */   \\\n        if (!flag) {                         \\\n          disable_feature();                 \\\n        }                                    \\\n      }                                      \\\n  }                                          \\\n\n+ #define UPDATE_DEFAULT_DEP(flag, dep0, ...)                                                               \\\n  void update_flag() {                                                                                      \\\n      assert(enabled(), \"Must be.\");                                                                        \\\n      if (FLAG_IS_DEFAULT(flag)) {                                                                          \\\n        if (this->deps_all_enabled(dep0, ##__VA_ARGS__)) {                                                  \\\n          FLAG_SET_DEFAULT(flag, true);                                                                     \\\n        } else {                                                                                            \\\n          FLAG_SET_DEFAULT(flag, false);                                                                    \\\n          stringStream ss;                                                                                  \\\n          deps_string(ss, dep0, ##__VA_ARGS__);                                                             \\\n          warning(\"Cannot enable \" #flag \", it's missing dependent extension(s) %s\", ss.as_string(true));   \\\n          /* Sync CPU features with flags */                                                                \\\n          disable_feature();                                                                                \\\n        }                                                                                                   \\\n      } else {                                                                                              \\\n        /* Sync CPU features with flags */                                                                  \\\n        if (!flag) {                                                                                        \\\n          disable_feature();                                                                                \\\n        } else if (!deps_all_enabled(dep0, ##__VA_ARGS__)) {                                                \\\n          FLAG_SET_DEFAULT(flag, false);                                                                    \\\n          stringStream ss;                                                                                  \\\n          deps_string(ss, dep0, ##__VA_ARGS__);                                                             \\\n          warning(\"Cannot enable \" #flag \", it's missing dependent extension(s) %s\", ss.as_string(true));   \\\n          /* Sync CPU features with flags */                                                                \\\n          disable_feature();                                                                                \\\n        }                                                                                                   \\\n      }                                                                                                     \\\n  }                                                                                                         \\", "target": "- #define UPDATE_DEFAULT_DEP(flag, dep)      \\\n  void update_flag() {                       \\\n      assert(enabled(), \"Must be.\");         \\\n      /* dep must be declared before */      \\\n      assert((uintptr_t)(this) >             \\\n             (uintptr_t)(&dep), \"Invalid\");  \\\n      if (FLAG_IS_DEFAULT(flag)) {           \\\n        if (dep.enabled()) {                 \\\n          FLAG_SET_DEFAULT(flag, true);      \\\n        } else {                             \\\n          FLAG_SET_DEFAULT(flag, false);     \\\n          /* Sync CPU features with flags */ \\\n          disable_feature();                 \\\n        }                                    \\\n      } else {                               \\\n        /* Sync CPU features with flags */   \\\n        if (!flag) {                         \\\n          disable_feature();                 \\\n        }                                    \\\n      }                                      \\\n  }                                          \\\n\n+ #define UPDATE_DEFAULT_DEP(flag, dep0, ...)                                                               \\\n  void update_flag() {                                                                                      \\\n      assert(enabled(), \"Must be.\");                                                                        \\\n      if (FLAG_IS_DEFAULT(flag)) {                                                                          \\\n        if (this->deps_all_enabled(dep0, ##__VA_ARGS__)) {                                                  \\\n          FLAG_SET_DEFAULT(flag, true);                                                                     \\\n        } else {                                                                                            \\\n          FLAG_SET_DEFAULT(flag, false);                                                                    \\\n          stringStream ss;                                                                                  \\\n          deps_string(ss, dep0, ##__VA_ARGS__);                                                             \\\n          warning(\"Cannot enable \" #flag \", it's missing dependent extension(s) %s\", ss.as_string(true));   \\\n          /* Sync CPU features with flags */                                                                \\\n          disable_feature();                                                                                \\\n        }                                                                                                   \\\n      } else {                                                                                              \\\n        /* Sync CPU features with flags */                                                                  \\\n        if (!flag) {                                                                                        \\\n          disable_feature();                                                                                \\\n        } else if (!deps_all_enabled(dep0, ##__VA_ARGS__)) {                                                \\\n          FLAG_SET_DEFAULT(flag, false);                                                                    \\\n          stringStream ss;                                                                                  \\\n          deps_string(ss, dep0, ##__VA_ARGS__);                                                             \\\n          warning(\"Cannot enable \" #flag \", it's missing dependent extension(s) %s\", ss.as_string(true));   \\\n          /* Sync CPU features with flags */                                                                \\\n          disable_feature();                                                                                \\\n        }                                                                                                   \\\n      }                                                                                                     \\\n  }                                                                                                         \\", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V CPU扩展依赖检查在.cpp文件中硬编码，每个依赖扩展都需要单独的条件判断和警告逻辑，代码重复且难以维护。优化后：重构为通用的依赖管理机制，在.hpp文件中添加deps_all_enabled()和deps_string()辅助函数，将UPDATE_DEFAULT_DEP宏改为支持可变参数，可处理任意数量的依赖扩展。优化思路：通过抽象和泛化减少代码重复，提高可维护性和扩展性，同时提供更详细的依赖关系警告信息。"}
{"id": 182, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+错误修复", "optimization_description": "优化前：在mod_value函数中，处理除数为零的检查放在处理被除数为零和相同操作数之后，这可能导致类型推导不单调，引发\"Not monotonic\"致命错误。优化后：将除数为零的检查提前到函数开始处，确保类型推导的单调性。优化思路：通过重新排序检查逻辑，保证编译器在常量传播阶段能正确处理模运算的类型推导，避免因检查顺序导致的类型推导不一致问题。", "original_code": "在mod_value函数中，处理除数为零的检查放在处理被除数为零和相同操作数之后，这可能导致类型推导不单调，引发\"Not monotonic\"致命错误。", "optimized_code": "// Mod by zero?  Throw exception at runtime!\n  if (t2 == TypeInteger::zero(bt)) {\n    return Type::TOP;\n  }\n\n  // We always generate the dynamic check for 0.\n  // 0 MOD X is 0\n  if (t1 == TypeInteger::zero(bt)) { return t1; }\n\n  // X MOD X is 0\n  if (phase->eqv(in1, in2)) {\n    return TypeInteger::zero(bt);\n  }\n\n-  // Mod by zero?  Throw exception at runtime!\n-  if (t2 == TypeInteger::zero(bt)) {\n-    return Type::TOP;\n-  }", "source_url": "https://github.com/openjdk/riscv-port/commit/59e76af47b23f582bbc21465a1871205d2499f28", "code_v0_no_empty_lines": "在mod_value函数中，处理除数为零的检查放在处理被除数为零和相同操作数之后，这可能导致类型推导不单调，引发\"Not monotonic\"致命错误。", "code_v1_no_empty_lines": "// Mod by zero?  Throw exception at runtime!\n  if (t2 == TypeInteger::zero(bt)) {\n    return Type::TOP;\n  }\n\n  // We always generate the dynamic check for 0.\n  // 0 MOD X is 0\n  if (t1 == TypeInteger::zero(bt)) { return t1; }\n\n  // X MOD X is 0\n  if (phase->eqv(in1, in2)) {\n    return TypeInteger::zero(bt);\n  }\n\n-  // Mod by zero?  Throw exception at runtime!\n-  if (t2 == TypeInteger::zero(bt)) {\n-    return Type::TOP;\n-  }", "target": "// Mod by zero?  Throw exception at runtime!\n  if (t2 == TypeInteger::zero(bt)) {\n    return Type::TOP;\n  }\n\n  // We always generate the dynamic check for 0.\n  // 0 MOD X is 0\n  if (t1 == TypeInteger::zero(bt)) { return t1; }\n\n  // X MOD X is 0\n  if (phase->eqv(in1, in2)) {\n    return TypeInteger::zero(bt);\n  }\n\n-  // Mod by zero?  Throw exception at runtime!\n-  if (t2 == TypeInteger::zero(bt)) {\n-    return Type::TOP;\n-  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在mod_value函数中，处理除数为零的检查放在处理被除数为零和相同操作数之后，这可能导致类型推导不单调，引发\"Not monotonic\"致命错误。优化后：将除数为零的检查提前到函数开始处，确保类型推导的单调性。优化思路：通过重新排序检查逻辑，保证编译器在常量传播阶段能正确处理模运算的类型推导，避免因检查顺序导致的类型推导不一致问题。"}
{"id": 183, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "优化前：OpenJDK HotSpot JIT编译器不支持AVX10的饱和浮点转换指令，浮点到整数转换可能使用较慢的软件模拟或非饱和指令。优化后：添加了AVX10饱和浮点转换指令（如evcvttss2sisl、evcvttps2dqs、evcvttpd2dqs）的汇编器支持，这些指令在转换时自动处理溢出饱和。优化思路：利用AVX10指令集的饱和转换特性，提高浮点到整数转换的性能和精度，避免溢出导致的未定义行为，同时减少分支和异常处理开销。", "original_code": "OpenJDK HotSpot JIT编译器不支持AVX10的饱和浮点转换指令，浮点到整数转换可能使用较慢的软件模拟或非饱和指令。", "optimized_code": "+void Assembler::evcvttss2sisl(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n\n+void Assembler::evcvttps2dqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n\n+void Assembler::evcvttpd2dqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/37f0e74d328d909810b54f7889cca991426d7488", "code_v0_no_empty_lines": "OpenJDK HotSpot JIT编译器不支持AVX10的饱和浮点转换指令，浮点到整数转换可能使用较慢的软件模拟或非饱和指令。", "code_v1_no_empty_lines": "+void Assembler::evcvttss2sisl(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n\n+void Assembler::evcvttps2dqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n\n+void Assembler::evcvttpd2dqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}", "target": "+void Assembler::evcvttss2sisl(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n\n+void Assembler::evcvttps2dqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n\n+void Assembler::evcvttpd2dqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：OpenJDK HotSpot JIT编译器不支持AVX10的饱和浮点转换指令，浮点到整数转换可能使用较慢的软件模拟或非饱和指令。优化后：添加了AVX10饱和浮点转换指令（如evcvttss2sisl、evcvttps2dqs、evcvttpd2dqs）的汇编器支持，这些指令在转换时自动处理溢出饱和。优化思路：利用AVX10指令集的饱和转换特性，提高浮点到整数转换的性能和精度，避免溢出导致的未定义行为，同时减少分支和异常处理开销。"}
{"id": 184, "source": "riscv-dataset-excel", "optimization_type": "调试性能优化", "optimization_description": "性能提升：优化前，当JDWP代理启动但调试器未连接时，每次continuation yield都会无条件检查can_post_frame_pop()，导致不必要的性能开销。优化后，新增has_frame_pops()函数，仅在当前线程确实有frame pop事件需要处理时才执行清理操作，避免了无谓的检查开销。", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 新增函数: static bool has_frame_pops(JavaThread* thread) NOT_JVMTI_RETURN_(false);\n2. 修改调用: - if (JvmtiExport::can_post_frame_pop()) {\n+ if (JvmtiExport::has_frame_pops(thread)) {", "source_url": "https://github.com/openjdk/riscv-port/commit/17244c699ad20fafe7448678a53266ce6bf017e5", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 新增函数: static bool has_frame_pops(JavaThread* thread) NOT_JVMTI_RETURN_(false);\n2. 修改调用: - if (JvmtiExport::can_post_frame_pop()) {\n+ if (JvmtiExport::has_frame_pops(thread)) {", "target": "1. 新增函数: static bool has_frame_pops(JavaThread* thread) NOT_JVMTI_RETURN_(false);\n2. 修改调用: - if (JvmtiExport::can_post_frame_pop()) {\n+ if (JvmtiExport::has_frame_pops(thread)) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升：优化前，当JDWP代理启动但调试器未连接时，每次continuation yield都会无条件检查can_post_frame_pop()，导致不必要的性能开销。优化后，新增has_frame_pops()函数，仅在当前线程确实有frame pop事件需要处理时才执行清理操作，避免了无谓的检查开销。"}
{"id": 185, "source": "riscv-dataset-excel", "optimization_type": "启动性能优化", "optimization_description": "优化前：AOT缓存中的类在VM启动过程中按需加载，导致启动时多次触发类加载操作，增加启动延迟。优化后：在VM引导阶段批量预加载AOT缓存中的类，通过preload_classes()函数一次性加载boot1、boot2、platform和app类加载器中的预定义类集合。优化思路：利用AOT缓存中已编译的类信息，在Java代码执行前预先完成类加载，减少运行时类加载开销，提升VM启动速度。", "original_code": "AOT缓存中的类在VM启动过程中按需加载，导致启动时多次触发类加载操作，增加启动延迟。", "optimized_code": "void AOTLinkedClassBulkLoader::preload_classes(JavaThread* current) {\n  preload_classes_impl(current);\n  if (current->has_pending_exception()) {\n    exit_on_exception(current);\n  }\n}\n\nvoid AOTLinkedClassBulkLoader::preload_classes_impl(TRAPS) {\n  precond(CDSConfig::is_using_aot_linked_classes());\n\n  ClassLoaderDataShared::restore_archived_modules_for_preloading_classes(THREAD);\n  Handle h_platform_loader(THREAD, SystemDictionary::java_platform_loader());\n  Handle h_system_loader(THREAD, SystemDictionary::java_system_loader());\n\n  AOTLinkedClassTable* table = AOTLinkedClassTable::get();\n\n  preload_classes_in_table(table->boot1(), \"boot1\", Handle(), CHECK);\n  preload_classes_in_table(table->boot2(), \"boot2\", Handle(), CHECK);\n\n  initiate_loading(THREAD, \"plat\", h_platform_loader, table->boot1());\n  initiate_loading(THREAD, \"plat\", h_platform_loader, table->boot2());\n  preload_classes_in_table(table->platform(), \"plat\", h_platform_loader, CHECK);\n\n  initiate_loading(THREAD, \"app\", h_system_loader, table->boot1());\n  initiate_loading(THREAD, \"app\", h_system_loader, table->boot2());\n  initiate_loading(THREAD, \"app\", h_system_loader, table->platform());\n  preload_classes_in_table(table->app(), \"app\", h_system_loader, CHECK);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/fd30ae988bc512b5d2a5a3fd1bc1ed351af974c7", "code_v0_no_empty_lines": "AOT缓存中的类在VM启动过程中按需加载，导致启动时多次触发类加载操作，增加启动延迟。", "code_v1_no_empty_lines": "void AOTLinkedClassBulkLoader::preload_classes(JavaThread* current) {\n  preload_classes_impl(current);\n  if (current->has_pending_exception()) {\n    exit_on_exception(current);\n  }\n}\n\nvoid AOTLinkedClassBulkLoader::preload_classes_impl(TRAPS) {\n  precond(CDSConfig::is_using_aot_linked_classes());\n\n  ClassLoaderDataShared::restore_archived_modules_for_preloading_classes(THREAD);\n  Handle h_platform_loader(THREAD, SystemDictionary::java_platform_loader());\n  Handle h_system_loader(THREAD, SystemDictionary::java_system_loader());\n\n  AOTLinkedClassTable* table = AOTLinkedClassTable::get();\n\n  preload_classes_in_table(table->boot1(), \"boot1\", Handle(), CHECK);\n  preload_classes_in_table(table->boot2(), \"boot2\", Handle(), CHECK);\n\n  initiate_loading(THREAD, \"plat\", h_platform_loader, table->boot1());\n  initiate_loading(THREAD, \"plat\", h_platform_loader, table->boot2());\n  preload_classes_in_table(table->platform(), \"plat\", h_platform_loader, CHECK);\n\n  initiate_loading(THREAD, \"app\", h_system_loader, table->boot1());\n  initiate_loading(THREAD, \"app\", h_system_loader, table->boot2());\n  initiate_loading(THREAD, \"app\", h_system_loader, table->platform());\n  preload_classes_in_table(table->app(), \"app\", h_system_loader, CHECK);\n}", "target": "void AOTLinkedClassBulkLoader::preload_classes(JavaThread* current) {\n  preload_classes_impl(current);\n  if (current->has_pending_exception()) {\n    exit_on_exception(current);\n  }\n}\n\nvoid AOTLinkedClassBulkLoader::preload_classes_impl(TRAPS) {\n  precond(CDSConfig::is_using_aot_linked_classes());\n\n  ClassLoaderDataShared::restore_archived_modules_for_preloading_classes(THREAD);\n  Handle h_platform_loader(THREAD, SystemDictionary::java_platform_loader());\n  Handle h_system_loader(THREAD, SystemDictionary::java_system_loader());\n\n  AOTLinkedClassTable* table = AOTLinkedClassTable::get();\n\n  preload_classes_in_table(table->boot1(), \"boot1\", Handle(), CHECK);\n  preload_classes_in_table(table->boot2(), \"boot2\", Handle(), CHECK);\n\n  initiate_loading(THREAD, \"plat\", h_platform_loader, table->boot1());\n  initiate_loading(THREAD, \"plat\", h_platform_loader, table->boot2());\n  preload_classes_in_table(table->platform(), \"plat\", h_platform_loader, CHECK);\n\n  initiate_loading(THREAD, \"app\", h_system_loader, table->boot1());\n  initiate_loading(THREAD, \"app\", h_system_loader, table->boot2());\n  initiate_loading(THREAD, \"app\", h_system_loader, table->platform());\n  preload_classes_in_table(table->app(), \"app\", h_system_loader, CHECK);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AOT缓存中的类在VM启动过程中按需加载，导致启动时多次触发类加载操作，增加启动延迟。优化后：在VM引导阶段批量预加载AOT缓存中的类，通过preload_classes()函数一次性加载boot1、boot2、platform和app类加载器中的预定义类集合。优化思路：利用AOT缓存中已编译的类信息，在Java代码执行前预先完成类加载，减少运行时类加载开销，提升VM启动速度。"}
{"id": 186, "source": "riscv-dataset-excel", "optimization_type": "代码重构与封装优化", "optimization_description": "优化前：G1CollectedHeap类直接管理年轻代收集集组（young_regions_cset_group）的清理操作，并在多个地方分散调用collection_set()的不同方法（start_incremental_building、clear、stop_incremental_building等），导致代码重复且职责分散。优化后：将年轻代收集集组的管理逻辑封装到G1CollectionSet类中，通过新增的start()和abandon()方法统一处理相关操作，简化了G1CollectedHeap的调用逻辑。优化思路：通过重构提高代码的内聚性和可维护性，将相关功能集中到G1CollectionSet类，减少跨类依赖和重复代码，使接口更清晰。", "original_code": "G1CollectedHeap类直接管理年轻代收集集组（young_regions_cset_group）的清理操作，并在多个地方分散调用collection_set()的不同方法（start_incremental_building、clear、stop_incremental_building等），导致代码重复且职责分散。", "optimized_code": "- void G1CollectedHeap::start_new_collection_set() {\n-   young_regions_cset_group()->clear();\n-   collection_set()->start_incremental_building();\n+ void G1CollectedHeap::start_new_collection_set() {\n+   collection_set()->start();\n- void G1CollectedHeap::abandon_collection_set() {\n-   collection_set()->clear();\n-   collection_set()->stop_incremental_building();\n-   collection_set()->abandon_all_candidates();\n-   young_regions_cset_group()->clear(true /* uninstall_group_cardset */);\n+ void G1CollectedHeap::abandon_collection_set() {\n+   collection_set()->abandon();\n+ void G1CollectionSet::abandon() {\n+   _g1h->young_regions_cset_group()->clear(true /* uninstall_cset_group */);\n+   clear();\n+   abandon_all_candidates();\n+   stop_incremental_building();\n- void G1CollectionSet::start_incremental_building() {\n+ void G1CollectionSet::start() {\n+   continue_incremental_building();\n+   G1CSetCandidateGroup* young_group = _g1h->young_regions_cset_group();\n+   young_group->clear();", "source_url": "https://github.com/openjdk/riscv-port/commit/02c78bb47e3a9cc8760dd0d0970bb9855f9909d3", "code_v0_no_empty_lines": "G1CollectedHeap类直接管理年轻代收集集组（young_regions_cset_group）的清理操作，并在多个地方分散调用collection_set()的不同方法（start_incremental_building、clear、stop_incremental_building等），导致代码重复且职责分散。", "code_v1_no_empty_lines": "- void G1CollectedHeap::start_new_collection_set() {\n-   young_regions_cset_group()->clear();\n-   collection_set()->start_incremental_building();\n+ void G1CollectedHeap::start_new_collection_set() {\n+   collection_set()->start();\n- void G1CollectedHeap::abandon_collection_set() {\n-   collection_set()->clear();\n-   collection_set()->stop_incremental_building();\n-   collection_set()->abandon_all_candidates();\n-   young_regions_cset_group()->clear(true /* uninstall_group_cardset */);\n+ void G1CollectedHeap::abandon_collection_set() {\n+   collection_set()->abandon();\n+ void G1CollectionSet::abandon() {\n+   _g1h->young_regions_cset_group()->clear(true /* uninstall_cset_group */);\n+   clear();\n+   abandon_all_candidates();\n+   stop_incremental_building();\n- void G1CollectionSet::start_incremental_building() {\n+ void G1CollectionSet::start() {\n+   continue_incremental_building();\n+   G1CSetCandidateGroup* young_group = _g1h->young_regions_cset_group();\n+   young_group->clear();", "target": "- void G1CollectedHeap::start_new_collection_set() {\n-   young_regions_cset_group()->clear();\n-   collection_set()->start_incremental_building();\n+ void G1CollectedHeap::start_new_collection_set() {\n+   collection_set()->start();\n- void G1CollectedHeap::abandon_collection_set() {\n-   collection_set()->clear();\n-   collection_set()->stop_incremental_building();\n-   collection_set()->abandon_all_candidates();\n-   young_regions_cset_group()->clear(true /* uninstall_group_cardset */);\n+ void G1CollectedHeap::abandon_collection_set() {\n+   collection_set()->abandon();\n+ void G1CollectionSet::abandon() {\n+   _g1h->young_regions_cset_group()->clear(true /* uninstall_cset_group */);\n+   clear();\n+   abandon_all_candidates();\n+   stop_incremental_building();\n- void G1CollectionSet::start_incremental_building() {\n+ void G1CollectionSet::start() {\n+   continue_incremental_building();\n+   G1CSetCandidateGroup* young_group = _g1h->young_regions_cset_group();\n+   young_group->clear();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：G1CollectedHeap类直接管理年轻代收集集组（young_regions_cset_group）的清理操作，并在多个地方分散调用collection_set()的不同方法（start_incremental_building、clear、stop_incremental_building等），导致代码重复且职责分散。优化后：将年轻代收集集组的管理逻辑封装到G1CollectionSet类中，通过新增的start()和abandon()方法统一处理相关操作，简化了G1CollectedHeap的调用逻辑。优化思路：通过重构提高代码的内聚性和可维护性，将相关功能集中到G1CollectionSet类，减少跨类依赖和重复代码，使接口更清晰。"}
{"id": 187, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+内存优化", "optimization_description": "优化前：G1 GC使用全局锁保护的脏卡队列（G1DirtyCardQueue）和重脏卡队列（G1RedirtyCardsQueue）来管理并发标记期间的卡表更新，这些全局锁成为性能瓶颈，限制了并发线程的吞吐量。优化后：引入无锁的卡表声明表（G1CardTableClaimTable）机制，线程通过原子操作声明卡表条目，消除了全局锁竞争。同时重构了并发细化（G1ConcurrentRefine）线程模型，减少了同步开销。思路：通过无锁数据结构和减少同步原语，提高G1 GC在多核环境下的并发处理能力，从而提升整体吞吐量。", "original_code": "G1 GC使用全局锁保护的脏卡队列（G1DirtyCardQueue）和重脏卡队列（G1RedirtyCardsQueue）来管理并发标记期间的卡表更新，这些全局锁成为性能瓶颈，限制了并发线程的吞吐量。", "optimized_code": "- // 旧代码：使用全局锁保护脏卡队列\n- MutexLocker x(&_dirty_card_queue_lock);\n- _dirty_card_queue.push(card);\n+ // 新代码：使用无锁的卡表声明表\n+ G1CardTableClaimTable::claim_card(card);", "source_url": "https://github.com/openjdk/riscv-port/commit/8d5c0056420731cbbd83f2d23837bbb5cdc9e4cc", "code_v0_no_empty_lines": "G1 GC使用全局锁保护的脏卡队列（G1DirtyCardQueue）和重脏卡队列（G1RedirtyCardsQueue）来管理并发标记期间的卡表更新，这些全局锁成为性能瓶颈，限制了并发线程的吞吐量。", "code_v1_no_empty_lines": "- // 旧代码：使用全局锁保护脏卡队列\n- MutexLocker x(&_dirty_card_queue_lock);\n- _dirty_card_queue.push(card);\n+ // 新代码：使用无锁的卡表声明表\n+ G1CardTableClaimTable::claim_card(card);", "target": "- // 旧代码：使用全局锁保护脏卡队列\n- MutexLocker x(&_dirty_card_queue_lock);\n- _dirty_card_queue.push(card);\n+ // 新代码：使用无锁的卡表声明表\n+ G1CardTableClaimTable::claim_card(card);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：G1 GC使用全局锁保护的脏卡队列（G1DirtyCardQueue）和重脏卡队列（G1RedirtyCardsQueue）来管理并发标记期间的卡表更新，这些全局锁成为性能瓶颈，限制了并发线程的吞吐量。优化后：引入无锁的卡表声明表（G1CardTableClaimTable）机制，线程通过原子操作声明卡表条目，消除了全局锁竞争。同时重构了并发细化（G1ConcurrentRefine）线程模型，减少了同步开销。思路：通过无锁数据结构和减少同步原语，提高G1 GC在多核环境下的并发处理能力，从而提升整体吞吐量。"}
{"id": 188, "source": "riscv-dataset-excel", "optimization_type": "代码现代化+编译时优化", "optimization_description": "优化前：使用复杂的SFINAE模板元编程技术（如自定义has_cmp_type/has_less_than_type类型特征）和多个重载函数（通过ENABLE_IF条件编译）来实现类型检查和函数分派，代码冗长且依赖旧C++标准。优化后：采用C++17特性，包括if constexpr进行编译时条件分支、std::is_invocable_r_v等标准类型特征替代自定义实现、简化模板参数。优化思路：利用C++17现代特性简化代码结构，减少模板实例化和编译时代码膨胀，提高代码可读性和维护性，同时保持相同的功能语义。", "original_code": "使用复杂的SFINAE模板元编程技术（如自定义has_cmp_type/has_less_than_type类型特征）和多个重载函数（通过ENABLE_IF条件编译）来实现类型检查和函数分派，代码冗长且依赖旧C++标准。", "optimized_code": "- template <typename CMP, typename RET, typename ARG1, typename ARG2, typename = void>\n  struct has_cmp_type : std::false_type {};\n  template <typename CMP, typename RET, typename ARG1, typename ARG2>\n  struct has_cmp_type<CMP, RET, ARG1, ARG2, decltype(static_cast<RET(*)(ARG1, ARG2)>(CMP::cmp), void())> : std::true_type {};\n\n- template <typename CMP>\n  static constexpr bool HasKeyComparator = has_cmp_type<CMP, RBTreeOrdering, K, K>::value;\n\n+ static constexpr bool HasKeyComparator =\n      std::is_invocable_r_v<RBTreeOrdering, decltype(&COMPARATOR::cmp), K, K>;\n\n- template <typename CMP = COMPARATOR, ENABLE_IF(HasKeyComparator<CMP> && !HasNodeComparator<CMP>)>\n  RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n    return COMPARATOR::cmp(a, b->key());\n  }\n\n- template <typename CMP = COMPARATOR, ENABLE_IF(HasNodeComparator<CMP>)>\n  RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n    return COMPARATOR::cmp(a, b);\n  }\n\n+ RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n    if constexpr (HasNodeComparator) {\n      return COMPARATOR::cmp(a, b);\n    } else if constexpr (HasKeyComparator) {\n      return COMPARATOR::cmp(a, b->key());\n    }\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/2131584add9ab46c3380bbf35170307e4878ce51", "code_v0_no_empty_lines": "使用复杂的SFINAE模板元编程技术（如自定义has_cmp_type/has_less_than_type类型特征）和多个重载函数（通过ENABLE_IF条件编译）来实现类型检查和函数分派，代码冗长且依赖旧C++标准。", "code_v1_no_empty_lines": "- template <typename CMP, typename RET, typename ARG1, typename ARG2, typename = void>\n  struct has_cmp_type : std::false_type {};\n  template <typename CMP, typename RET, typename ARG1, typename ARG2>\n  struct has_cmp_type<CMP, RET, ARG1, ARG2, decltype(static_cast<RET(*)(ARG1, ARG2)>(CMP::cmp), void())> : std::true_type {};\n\n- template <typename CMP>\n  static constexpr bool HasKeyComparator = has_cmp_type<CMP, RBTreeOrdering, K, K>::value;\n\n+ static constexpr bool HasKeyComparator =\n      std::is_invocable_r_v<RBTreeOrdering, decltype(&COMPARATOR::cmp), K, K>;\n\n- template <typename CMP = COMPARATOR, ENABLE_IF(HasKeyComparator<CMP> && !HasNodeComparator<CMP>)>\n  RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n    return COMPARATOR::cmp(a, b->key());\n  }\n\n- template <typename CMP = COMPARATOR, ENABLE_IF(HasNodeComparator<CMP>)>\n  RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n    return COMPARATOR::cmp(a, b);\n  }\n\n+ RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n    if constexpr (HasNodeComparator) {\n      return COMPARATOR::cmp(a, b);\n    } else if constexpr (HasKeyComparator) {\n      return COMPARATOR::cmp(a, b->key());\n    }\n  }", "target": "- template <typename CMP, typename RET, typename ARG1, typename ARG2, typename = void>\n  struct has_cmp_type : std::false_type {};\n  template <typename CMP, typename RET, typename ARG1, typename ARG2>\n  struct has_cmp_type<CMP, RET, ARG1, ARG2, decltype(static_cast<RET(*)(ARG1, ARG2)>(CMP::cmp), void())> : std::true_type {};\n\n- template <typename CMP>\n  static constexpr bool HasKeyComparator = has_cmp_type<CMP, RBTreeOrdering, K, K>::value;\n\n+ static constexpr bool HasKeyComparator =\n      std::is_invocable_r_v<RBTreeOrdering, decltype(&COMPARATOR::cmp), K, K>;\n\n- template <typename CMP = COMPARATOR, ENABLE_IF(HasKeyComparator<CMP> && !HasNodeComparator<CMP>)>\n  RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n    return COMPARATOR::cmp(a, b->key());\n  }\n\n- template <typename CMP = COMPARATOR, ENABLE_IF(HasNodeComparator<CMP>)>\n  RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n    return COMPARATOR::cmp(a, b);\n  }\n\n+ RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n    if constexpr (HasNodeComparator) {\n      return COMPARATOR::cmp(a, b);\n    } else if constexpr (HasKeyComparator) {\n      return COMPARATOR::cmp(a, b->key());\n    }\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用复杂的SFINAE模板元编程技术（如自定义has_cmp_type/has_less_than_type类型特征）和多个重载函数（通过ENABLE_IF条件编译）来实现类型检查和函数分派，代码冗长且依赖旧C++标准。优化后：采用C++17特性，包括if constexpr进行编译时条件分支、std::is_invocable_r_v等标准类型特征替代自定义实现、简化模板参数。优化思路：利用C++17现代特性简化代码结构，减少模板实例化和编译时代码膨胀，提高代码可读性和维护性，同时保持相同的功能语义。"}
{"id": 189, "source": "riscv-dataset-excel", "optimization_type": "内存访问优化+代码重构", "optimization_description": "优化前：PSThreadRootsTaskClosure构造函数接收worker_id，在do_thread方法中通过worker_id查找PSPromotionManager，导致每次线程处理时都需要额外的查找开销。ScavengeRootsTask::work方法中多次调用PSPromotionManager::gc_thread_promotion_manager(worker_id)获取相同的管理器。优化后：PSThreadRootsTaskClosure构造函数直接接收PSPromotionManager指针，避免重复查找。在ScavengeRootsTask::work方法中，提前获取PSPromotionManager并复用，减少内存访问次数和函数调用开销。优化思路：通过传递对象指针而非ID来避免重复查找，减少内存访问和函数调用，提高GC并行任务执行效率。", "original_code": "PSThreadRootsTaskClosure构造函数接收worker_id，在do_thread方法中通过worker_id查找PSPromotionManager，导致每次线程处理时都需要额外的查找开销。ScavengeRootsTask::work方法中多次调用PSPromotionManager::gc_thread_promotion_manager(worker_id)获取相同的管理器。", "optimized_code": "-  PSThreadRootsTaskClosure(uint worker_id) : _worker_id(worker_id) { }\n+  PSThreadRootsTaskClosure(PSPromotionManager* pm) : _pm(pm) {}\n-    PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(_worker_id);\n-    PSScavengeRootsClosure roots_closure(pm);\n+    PSScavengeRootsClosure roots_closure(_pm);\n-    pm->drain_stacks(false);\n+    _pm->drain_stacks(false);\n-    PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n+    PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n-        PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n-    PSThreadRootsTaskClosure closure(worker_id);\n-    Threads::possibly_parallel_threads_do(_active_workers > 1 /* is_par */, &closure);\n+    PSThreadRootsTaskClosure thread_closure(pm);\n+    Threads::possibly_parallel_threads_do(_active_workers > 1 /* is_par */, &thread_closure);\n-      PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n-      PSScavengeRootsClosure closure(pm);\n-      _oop_storage_strong_par_state.oops_do(&closure);\n+      PSScavengeRootsClosure root_closure(pm);\n+      _oop_storage_strong_par_state.oops_do(&root_closure);", "source_url": "https://github.com/openjdk/riscv-port/commit/f779ad64ac3184a90e2d3ddf2cba5321d050d325", "code_v0_no_empty_lines": "PSThreadRootsTaskClosure构造函数接收worker_id，在do_thread方法中通过worker_id查找PSPromotionManager，导致每次线程处理时都需要额外的查找开销。ScavengeRootsTask::work方法中多次调用PSPromotionManager::gc_thread_promotion_manager(worker_id)获取相同的管理器。", "code_v1_no_empty_lines": "-  PSThreadRootsTaskClosure(uint worker_id) : _worker_id(worker_id) { }\n+  PSThreadRootsTaskClosure(PSPromotionManager* pm) : _pm(pm) {}\n-    PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(_worker_id);\n-    PSScavengeRootsClosure roots_closure(pm);\n+    PSScavengeRootsClosure roots_closure(_pm);\n-    pm->drain_stacks(false);\n+    _pm->drain_stacks(false);\n-    PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n+    PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n-        PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n-    PSThreadRootsTaskClosure closure(worker_id);\n-    Threads::possibly_parallel_threads_do(_active_workers > 1 /* is_par */, &closure);\n+    PSThreadRootsTaskClosure thread_closure(pm);\n+    Threads::possibly_parallel_threads_do(_active_workers > 1 /* is_par */, &thread_closure);\n-      PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n-      PSScavengeRootsClosure closure(pm);\n-      _oop_storage_strong_par_state.oops_do(&closure);\n+      PSScavengeRootsClosure root_closure(pm);\n+      _oop_storage_strong_par_state.oops_do(&root_closure);", "target": "-  PSThreadRootsTaskClosure(uint worker_id) : _worker_id(worker_id) { }\n+  PSThreadRootsTaskClosure(PSPromotionManager* pm) : _pm(pm) {}\n-    PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(_worker_id);\n-    PSScavengeRootsClosure roots_closure(pm);\n+    PSScavengeRootsClosure roots_closure(_pm);\n-    pm->drain_stacks(false);\n+    _pm->drain_stacks(false);\n-    PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n+    PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n-        PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n-    PSThreadRootsTaskClosure closure(worker_id);\n-    Threads::possibly_parallel_threads_do(_active_workers > 1 /* is_par */, &closure);\n+    PSThreadRootsTaskClosure thread_closure(pm);\n+    Threads::possibly_parallel_threads_do(_active_workers > 1 /* is_par */, &thread_closure);\n-      PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n-      PSScavengeRootsClosure closure(pm);\n-      _oop_storage_strong_par_state.oops_do(&closure);\n+      PSScavengeRootsClosure root_closure(pm);\n+      _oop_storage_strong_par_state.oops_do(&root_closure);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PSThreadRootsTaskClosure构造函数接收worker_id，在do_thread方法中通过worker_id查找PSPromotionManager，导致每次线程处理时都需要额外的查找开销。ScavengeRootsTask::work方法中多次调用PSPromotionManager::gc_thread_promotion_manager(worker_id)获取相同的管理器。优化后：PSThreadRootsTaskClosure构造函数直接接收PSPromotionManager指针，避免重复查找。在ScavengeRootsTask::work方法中，提前获取PSPromotionManager并复用，减少内存访问次数和函数调用开销。优化思路：通过传递对象指针而非ID来避免重复查找，减少内存访问和函数调用，提高GC并行任务执行效率。"}
{"id": 190, "source": "riscv-dataset-excel", "optimization_type": "向量化指令优化", "optimization_description": "优化前：AArch64后端缺少对VectorAPI expand操作的完整支持，仅支持SVE2且不支持子字类型。优化后：1. 添加NEON实现（vexpand_neon）支持非SVE场景；2. 添加SVE1实现（vexpand_sve）支持SVE1和SVE2子字类型；3. 优化SVE2实现（vexpand_sve2_SD）支持单/双精度浮点类型；4. 添加sve_movprfx指令支持。思路：通过分层实现覆盖所有硬件配置（NEON/SVE1/SVE2），移除类型限制，完善VectorAPI后端支持。", "original_code": "AArch64后端缺少对VectorAPI expand操作的完整支持，仅支持SVE2且不支持子字类型。", "optimized_code": "- instruct vexpand(vReg dst, vReg src, pRegGov pg) %{\n+ instruct vexpand_neon(vReg dst, vReg src, vReg mask, vReg tmp1, vReg tmp2) %{\n+   predicate(UseSVE == 0);\n+   match(Set dst (ExpandV src mask));\n+   effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+   format %{ \"vexpand_neon $dst, $src, $mask\\t# KILL $tmp1, $tmp2\" %}", "source_url": "https://github.com/openjdk/riscv-port/commit/e6f8450d957f79beacf2fc70e545db3a4bb58742", "code_v0_no_empty_lines": "AArch64后端缺少对VectorAPI expand操作的完整支持，仅支持SVE2且不支持子字类型。", "code_v1_no_empty_lines": "- instruct vexpand(vReg dst, vReg src, pRegGov pg) %{\n+ instruct vexpand_neon(vReg dst, vReg src, vReg mask, vReg tmp1, vReg tmp2) %{\n+   predicate(UseSVE == 0);\n+   match(Set dst (ExpandV src mask));\n+   effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+   format %{ \"vexpand_neon $dst, $src, $mask\\t# KILL $tmp1, $tmp2\" %}", "target": "- instruct vexpand(vReg dst, vReg src, pRegGov pg) %{\n+ instruct vexpand_neon(vReg dst, vReg src, vReg mask, vReg tmp1, vReg tmp2) %{\n+   predicate(UseSVE == 0);\n+   match(Set dst (ExpandV src mask));\n+   effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+   format %{ \"vexpand_neon $dst, $src, $mask\\t# KILL $tmp1, $tmp2\" %}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AArch64后端缺少对VectorAPI expand操作的完整支持，仅支持SVE2且不支持子字类型。优化后：1. 添加NEON实现（vexpand_neon）支持非SVE场景；2. 添加SVE1实现（vexpand_sve）支持SVE1和SVE2子字类型；3. 优化SVE2实现（vexpand_sve2_SD）支持单/双精度浮点类型；4. 添加sve_movprfx指令支持。思路：通过分层实现覆盖所有硬件配置（NEON/SVE1/SVE2），移除类型限制，完善VectorAPI后端支持。"}
{"id": 191, "source": "riscv-dataset-excel", "optimization_type": "编译超时机制优化", "optimization_description": "优化前：当使用RepeatCompilation参数进行重复编译时，编译任务超时计时器在每次迭代中不会重置，导致后续编译可能过早超时。优化后：在每次重复编译迭代开始时调用reset()方法重置超时计时器，确保每次编译都有完整的超时时间。优化思路：修复编译超时机制在重复编译场景下的缺陷，确保编译任务超时功能正常工作，避免因计时器未重置导致的意外编译失败。", "original_code": "当使用RepeatCompilation参数进行重复编译时，编译任务超时计时器在每次迭代中不会重置，导致后续编译可能过早超时。", "optimized_code": "diff --git a/src/hotspot/share/compiler/compileBroker.cpp b/src/hotspot/share/compiler/compileBroker.cpp\nindex 24f28821087..226a6d3ad5c 100644\n--- a/src/hotspot/share/compiler/compileBroker.cpp\n+++ b/src/hotspot/share/compiler/compileBroker.cpp\n@@ -2349,6 +2349,7 @@ void CompileBroker::invoke_compiler_on_method(CompileTask* task) {\n       while (repeat_compilation_count > 0) {\n         ResourceMark rm(thread);\n         task->print_ul(\"NO CODE INSTALLED\");\n+        thread->timeout()->reset();\n         comp->compile_method(&ci_env, target, osr_bci, false, directive);\n         repeat_compilation_count--;\n       }", "source_url": "https://github.com/openjdk/riscv-port/commit/94a301a70e19be284f406ebb6d8b94b6f96e1a24", "code_v0_no_empty_lines": "当使用RepeatCompilation参数进行重复编译时，编译任务超时计时器在每次迭代中不会重置，导致后续编译可能过早超时。", "code_v1_no_empty_lines": "diff --git a/src/hotspot/share/compiler/compileBroker.cpp b/src/hotspot/share/compiler/compileBroker.cpp\nindex 24f28821087..226a6d3ad5c 100644\n--- a/src/hotspot/share/compiler/compileBroker.cpp\n+++ b/src/hotspot/share/compiler/compileBroker.cpp\n@@ -2349,6 +2349,7 @@ void CompileBroker::invoke_compiler_on_method(CompileTask* task) {\n       while (repeat_compilation_count > 0) {\n         ResourceMark rm(thread);\n         task->print_ul(\"NO CODE INSTALLED\");\n+        thread->timeout()->reset();\n         comp->compile_method(&ci_env, target, osr_bci, false, directive);\n         repeat_compilation_count--;\n       }", "target": "diff --git a/src/hotspot/share/compiler/compileBroker.cpp b/src/hotspot/share/compiler/compileBroker.cpp\nindex 24f28821087..226a6d3ad5c 100644\n--- a/src/hotspot/share/compiler/compileBroker.cpp\n+++ b/src/hotspot/share/compiler/compileBroker.cpp\n@@ -2349,6 +2349,7 @@ void CompileBroker::invoke_compiler_on_method(CompileTask* task) {\n       while (repeat_compilation_count > 0) {\n         ResourceMark rm(thread);\n         task->print_ul(\"NO CODE INSTALLED\");\n+        thread->timeout()->reset();\n         comp->compile_method(&ci_env, target, osr_bci, false, directive);\n         repeat_compilation_count--;\n       }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当使用RepeatCompilation参数进行重复编译时，编译任务超时计时器在每次迭代中不会重置，导致后续编译可能过早超时。优化后：在每次重复编译迭代开始时调用reset()方法重置超时计时器，确保每次编译都有完整的超时时间。优化思路：修复编译超时机制在重复编译场景下的缺陷，确保编译任务超时功能正常工作，避免因计时器未重置导致的意外编译失败。"}
{"id": 192, "source": "riscv-dataset-excel", "optimization_type": "内存安全优化", "optimization_description": "优化前：在AOT汇编阶段，_buffer_offset_to_source_obj_table等表格直接存储原始oop指针，这些指针在GC期间可能失效，导致内存安全问题。优化后：将表格中的原始oop指针替换为OopHandle（GC安全引用），通过OopHandle::resolve()安全访问对象，并添加HeapShared::delete_tables_with_raw_oops()在AOT阶段后清理表格。优化思路：确保GC期间表格引用的对象安全，避免悬垂指针，提升系统稳定性。", "original_code": "在AOT汇编阶段，_buffer_offset_to_source_obj_table等表格直接存储原始oop指针，这些指针在GC期间可能失效，导致内存安全问题。", "optimized_code": "- oop* p = _buffer_offset_to_source_obj_table->get(buffered_address_to_offset(buffered_addr));\n+ OopHandle* oh = _buffer_offset_to_source_obj_table->get(buffered_address_to_offset(buffered_addr));\n- return *p;\n+ return oh->resolve();\n- _buffer_offset_to_source_obj_table->put_when_absent(buffer_offset, src_obj);\n+ OopHandle handle(Universe::vm_global(), src_obj);\n+ _buffer_offset_to_source_obj_table->put_when_absent(buffer_offset, handle);", "source_url": "https://github.com/openjdk/riscv-port/commit/e3a4c28409ac62feee9efe069e3a3482e7e2cdd2", "code_v0_no_empty_lines": "在AOT汇编阶段，_buffer_offset_to_source_obj_table等表格直接存储原始oop指针，这些指针在GC期间可能失效，导致内存安全问题。", "code_v1_no_empty_lines": "- oop* p = _buffer_offset_to_source_obj_table->get(buffered_address_to_offset(buffered_addr));\n+ OopHandle* oh = _buffer_offset_to_source_obj_table->get(buffered_address_to_offset(buffered_addr));\n- return *p;\n+ return oh->resolve();\n- _buffer_offset_to_source_obj_table->put_when_absent(buffer_offset, src_obj);\n+ OopHandle handle(Universe::vm_global(), src_obj);\n+ _buffer_offset_to_source_obj_table->put_when_absent(buffer_offset, handle);", "target": "- oop* p = _buffer_offset_to_source_obj_table->get(buffered_address_to_offset(buffered_addr));\n+ OopHandle* oh = _buffer_offset_to_source_obj_table->get(buffered_address_to_offset(buffered_addr));\n- return *p;\n+ return oh->resolve();\n- _buffer_offset_to_source_obj_table->put_when_absent(buffer_offset, src_obj);\n+ OopHandle handle(Universe::vm_global(), src_obj);\n+ _buffer_offset_to_source_obj_table->put_when_absent(buffer_offset, handle);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在AOT汇编阶段，_buffer_offset_to_source_obj_table等表格直接存储原始oop指针，这些指针在GC期间可能失效，导致内存安全问题。优化后：将表格中的原始oop指针替换为OopHandle（GC安全引用），通过OopHandle::resolve()安全访问对象，并添加HeapShared::delete_tables_with_raw_oops()在AOT阶段后清理表格。优化思路：确保GC期间表格引用的对象安全，避免悬垂指针，提升系统稳定性。"}
{"id": 193, "source": "riscv-dataset-excel", "optimization_type": "GC性能优化+内存管理优化", "optimization_description": "优化前：Young GC期间使用MarkingNMethodClosure处理代码缓存，需要额外的keepalive参数；使用StrongRootsScope管理线程声明，存在性能开销。优化后：1. 改用NMethodToOopClosure，简化接口并减少参数传递；2. 引入ThreadsClaimTokenScope替代StrongRootsScope，通过轻量级的线程声明令牌机制减少GC暂停时间。优化思路：通过简化闭包接口和优化线程声明机制，提升并行GC性能，减少Young GC的停顿时间。", "original_code": "Young GC期间使用MarkingNMethodClosure处理代码缓存，需要额外的keepalive参数；使用StrongRootsScope管理线程声明，存在性能开销。", "optimized_code": "-        MarkingNMethodClosure code_closure(&roots_to_old_closure, NMethodToOopClosure::FixRelocations, false /* keepalive nmethods */);\n+        NMethodToOopClosure code_closure(&roots_to_old_closure, NMethodToOopClosure::FixRelocations);\n-  StrongRootsScope _strong_roots_scope; // needed for Threads::possibly_parallel_threads_do\n+  ThreadsClaimTokenScope _threads_claim_token_scope; // needed for Threads::possibly_parallel_threads_do\n+struct ThreadsClaimTokenScope : StackObj {\n+  ThreadsClaimTokenScope() {\n+    Threads::change_thread_claim_token();\n+  }\n+  ~ThreadsClaimTokenScope() {\n+    Threads::assert_all_threads_claimed();\n+  }\n+};", "source_url": "https://github.com/openjdk/riscv-port/commit/28879d3d03ca6e8ea68a6063da349d83310b22ce", "code_v0_no_empty_lines": "Young GC期间使用MarkingNMethodClosure处理代码缓存，需要额外的keepalive参数；使用StrongRootsScope管理线程声明，存在性能开销。", "code_v1_no_empty_lines": "-        MarkingNMethodClosure code_closure(&roots_to_old_closure, NMethodToOopClosure::FixRelocations, false /* keepalive nmethods */);\n+        NMethodToOopClosure code_closure(&roots_to_old_closure, NMethodToOopClosure::FixRelocations);\n-  StrongRootsScope _strong_roots_scope; // needed for Threads::possibly_parallel_threads_do\n+  ThreadsClaimTokenScope _threads_claim_token_scope; // needed for Threads::possibly_parallel_threads_do\n+struct ThreadsClaimTokenScope : StackObj {\n+  ThreadsClaimTokenScope() {\n+    Threads::change_thread_claim_token();\n+  }\n+  ~ThreadsClaimTokenScope() {\n+    Threads::assert_all_threads_claimed();\n+  }\n+};", "target": "-        MarkingNMethodClosure code_closure(&roots_to_old_closure, NMethodToOopClosure::FixRelocations, false /* keepalive nmethods */);\n+        NMethodToOopClosure code_closure(&roots_to_old_closure, NMethodToOopClosure::FixRelocations);\n-  StrongRootsScope _strong_roots_scope; // needed for Threads::possibly_parallel_threads_do\n+  ThreadsClaimTokenScope _threads_claim_token_scope; // needed for Threads::possibly_parallel_threads_do\n+struct ThreadsClaimTokenScope : StackObj {\n+  ThreadsClaimTokenScope() {\n+    Threads::change_thread_claim_token();\n+  }\n+  ~ThreadsClaimTokenScope() {\n+    Threads::assert_all_threads_claimed();\n+  }\n+};", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Young GC期间使用MarkingNMethodClosure处理代码缓存，需要额外的keepalive参数；使用StrongRootsScope管理线程声明，存在性能开销。优化后：1. 改用NMethodToOopClosure，简化接口并减少参数传递；2. 引入ThreadsClaimTokenScope替代StrongRootsScope，通过轻量级的线程声明令牌机制减少GC暂停时间。优化思路：通过简化闭包接口和优化线程声明机制，提升并行GC性能，减少Young GC的停顿时间。"}
{"id": 194, "source": "riscv-dataset-excel", "optimization_type": "算法优化+常量折叠", "optimization_description": "优化前：P256模数数组的第二个元素modulus[2]为0，但代码仍对其执行完整的乘法运算和减法操作，产生冗余计算。优化后：1. 添加@Stable注解标记modulus为稳定常量，便于JVM优化；2. 利用modulus[2]=0的数学特性，将涉及modulus[2]的乘法结果直接设为0，并移除相关累加操作；3. 在最终约减步骤中，由于modulus[2]=0，简化c2的计算表达式。优化思路：通过常量折叠和消除冗余计算，减少P256算术运算的指令数量，提升椭圆曲线密码学操作的性能。", "original_code": "P256模数数组的第二个元素modulus[2]为0，但代码仍对其执行完整的乘法运算和减法操作，产生冗余计算。", "optimized_code": "-        n2 = n * modulus[2];\n-        nn2 = Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n-        n2 &= LIMB_MASK;\n+        n2 = 0;\n+        nn2 = 0;\n-        dd2 += nn2;\n-        d2 += n2;\n-        n2 = n * modulus[2];\n-        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n-        d2 += n2 & LIMB_MASK;\n-        c2 = c7 - modulus[2] + (c1 >> BITS_PER_LIMB);\n+        c2 = c7 + (c1 >> BITS_PER_LIMB);", "source_url": "https://github.com/openjdk/riscv-port/commit/72e5ad3d21effff6a4efae8ab3ed45c4f6bfba76", "code_v0_no_empty_lines": "P256模数数组的第二个元素modulus[2]为0，但代码仍对其执行完整的乘法运算和减法操作，产生冗余计算。", "code_v1_no_empty_lines": "-        n2 = n * modulus[2];\n-        nn2 = Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n-        n2 &= LIMB_MASK;\n+        n2 = 0;\n+        nn2 = 0;\n-        dd2 += nn2;\n-        d2 += n2;\n-        n2 = n * modulus[2];\n-        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n-        d2 += n2 & LIMB_MASK;\n-        c2 = c7 - modulus[2] + (c1 >> BITS_PER_LIMB);\n+        c2 = c7 + (c1 >> BITS_PER_LIMB);", "target": "-        n2 = n * modulus[2];\n-        nn2 = Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n-        n2 &= LIMB_MASK;\n+        n2 = 0;\n+        nn2 = 0;\n-        dd2 += nn2;\n-        d2 += n2;\n-        n2 = n * modulus[2];\n-        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n-        d2 += n2 & LIMB_MASK;\n-        c2 = c7 - modulus[2] + (c1 >> BITS_PER_LIMB);\n+        c2 = c7 + (c1 >> BITS_PER_LIMB);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：P256模数数组的第二个元素modulus[2]为0，但代码仍对其执行完整的乘法运算和减法操作，产生冗余计算。优化后：1. 添加@Stable注解标记modulus为稳定常量，便于JVM优化；2. 利用modulus[2]=0的数学特性，将涉及modulus[2]的乘法结果直接设为0，并移除相关累加操作；3. 在最终约减步骤中，由于modulus[2]=0，简化c2的计算表达式。优化思路：通过常量折叠和消除冗余计算，减少P256算术运算的指令数量，提升椭圆曲线密码学操作的性能。"}
{"id": 195, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（GVN值范围分析）", "optimization_description": "优化前：ModINode::Value和ModLNode::Value函数分别处理int和long类型的模运算值范围分析，逻辑重复且简单。对于非常量输入，只能返回粗略的范围（如TypeInt::POS或TypeInt::INT），无法利用除数的幅度信息和被除数的符号范围来精确推断结果范围。\n\n优化后：提取通用mod_value函数，统一处理int和long类型。通过计算除数的最大幅度（divisor_magnitude），根据JVM规范确定模运算结果的基本范围[-|divisor|-1, |divisor|-1]。然后结合被除数的符号范围进一步收紧结果范围：如果被除数全为非正数，结果上限为0；如果被除数全为非负数，结果下限为0；如果符号混合，则结合被除数的边界。\n\n优化思路：通过更精确的值范围分析，编译器可以在全局值编号（GVN）阶段识别更多冗余计算和常量折叠机会，减少运行时计算，提升性能。特别是对于模运算这种相对昂贵的操作，精确的范围分析有助于消除不必要的计算和分支。", "original_code": "ModINode::Value和ModLNode::Value函数分别处理int和long类型的模运算值范围分析，逻辑重复且简单。对于非常量输入，只能返回粗略的范围（如TypeInt::POS或TypeInt::INT），无法利用除数的幅度信息和被除数的符号范围来精确推断结果范围。", "optimized_code": "-static const Type* mod_value(const PhaseGVN* phase, const Node* in1, const Node* in2, const BasicType bt) {\n+  // 新增通用mod_value函数，统一处理int和long类型的模运算值范围分析\n+  // 关键逻辑：根据除数的幅度和符号信息，更精确地计算模运算结果的范围\n+  julong divisor_magnitude = MAX2(g_uabs(i2->lo_as_long()), g_uabs(i2->hi_as_long()));\n+  jlong hi = static_cast<jlong>(divisor_magnitude - 1);\n+  jlong lo = -hi;\n+  // 根据被除数的符号范围进一步收紧结果范围\n+  if (i1->hi_as_long() <= 0) {\n+    hi = 0;\n+    lo = MAX2(lo, i1->lo_as_long());\n+  } else if (i1->lo_as_long() >= 0) {\n+    lo = 0;\n+    hi = MIN2(hi, i1->hi_as_long());\n+  } else {\n+    lo = MAX2(lo, i1->lo_as_long());\n+    hi = MIN2(hi, i1->hi_as_long());\n+  }\n+  return TypeInteger::make(lo, hi, MAX2(i1->_widen, i2->_widen), bt);", "source_url": "https://github.com/openjdk/riscv-port/commit/c7f014ed494409cdf9fc925fe98de08346606408", "code_v0_no_empty_lines": "ModINode::Value和ModLNode::Value函数分别处理int和long类型的模运算值范围分析，逻辑重复且简单。对于非常量输入，只能返回粗略的范围（如TypeInt::POS或TypeInt::INT），无法利用除数的幅度信息和被除数的符号范围来精确推断结果范围。", "code_v1_no_empty_lines": "-static const Type* mod_value(const PhaseGVN* phase, const Node* in1, const Node* in2, const BasicType bt) {\n+  // 新增通用mod_value函数，统一处理int和long类型的模运算值范围分析\n+  // 关键逻辑：根据除数的幅度和符号信息，更精确地计算模运算结果的范围\n+  julong divisor_magnitude = MAX2(g_uabs(i2->lo_as_long()), g_uabs(i2->hi_as_long()));\n+  jlong hi = static_cast<jlong>(divisor_magnitude - 1);\n+  jlong lo = -hi;\n+  // 根据被除数的符号范围进一步收紧结果范围\n+  if (i1->hi_as_long() <= 0) {\n+    hi = 0;\n+    lo = MAX2(lo, i1->lo_as_long());\n+  } else if (i1->lo_as_long() >= 0) {\n+    lo = 0;\n+    hi = MIN2(hi, i1->hi_as_long());\n+  } else {\n+    lo = MAX2(lo, i1->lo_as_long());\n+    hi = MIN2(hi, i1->hi_as_long());\n+  }\n+  return TypeInteger::make(lo, hi, MAX2(i1->_widen, i2->_widen), bt);", "target": "-static const Type* mod_value(const PhaseGVN* phase, const Node* in1, const Node* in2, const BasicType bt) {\n+  // 新增通用mod_value函数，统一处理int和long类型的模运算值范围分析\n+  // 关键逻辑：根据除数的幅度和符号信息，更精确地计算模运算结果的范围\n+  julong divisor_magnitude = MAX2(g_uabs(i2->lo_as_long()), g_uabs(i2->hi_as_long()));\n+  jlong hi = static_cast<jlong>(divisor_magnitude - 1);\n+  jlong lo = -hi;\n+  // 根据被除数的符号范围进一步收紧结果范围\n+  if (i1->hi_as_long() <= 0) {\n+    hi = 0;\n+    lo = MAX2(lo, i1->lo_as_long());\n+  } else if (i1->lo_as_long() >= 0) {\n+    lo = 0;\n+    hi = MIN2(hi, i1->hi_as_long());\n+  } else {\n+    lo = MAX2(lo, i1->lo_as_long());\n+    hi = MIN2(hi, i1->hi_as_long());\n+  }\n+  return TypeInteger::make(lo, hi, MAX2(i1->_widen, i2->_widen), bt);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ModINode::Value和ModLNode::Value函数分别处理int和long类型的模运算值范围分析，逻辑重复且简单。对于非常量输入，只能返回粗略的范围（如TypeInt::POS或TypeInt::INT），无法利用除数的幅度信息和被除数的符号范围来精确推断结果范围。\n\n优化后：提取通用mod_value函数，统一处理int和long类型。通过计算除数的最大幅度（divisor_magnitude），根据JVM规范确定模运算结果的基本范围[-|divisor|-1, |divisor|-1]。然后结合被除数的符号范围进一步收紧结果范围：如果被除数全为非正数，结果上限为0；如果被除数全为非负数，结果下限为0；如果符号混合，则结合被除数的边界。\n\n优化思路：通过更精确的值范围分析，编译器可以在全局值编号（GVN）阶段识别更多冗余计算和常量折叠机会，减少运行时计算，提升性能。特别是对于模运算这种相对昂贵的操作，精确的范围分析有助于消除不必要的计算和分支。"}
{"id": 196, "source": "riscv-dataset-excel", "optimization_type": "指令编码优化", "optimization_description": "优化前：对于可交换操作（如add、and、or等），当目标寄存器与第二个源寄存器相同时，使用Extended EVEX编码，需要手动设置InstructionAttr并调用多个函数。优化后：引入新的emit_eevex_prefix_or_demote_arith_ndd和emit_eevex_or_demote函数，自动处理EVEX到REX2/REX的降级，通过is_commutative参数识别可交换操作，简化代码并提高指令编码效率。优化思路：利用可交换操作的特性，在目标寄存器与第二个源寄存器相同时，允许更灵活的编码选择，减少指令大小和潜在的解码开销。", "original_code": "对于可交换操作（如add、and、or等），当目标寄存器与第二个源寄存器相同时，使用Extended EVEX编码，需要手动设置InstructionAttr并调用多个函数。", "optimized_code": "- InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n  // NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n  // Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C /* MAP4 */, &attributes, no_flags);\n  emit_arith(0x23, 0xC0, src1, src2);\n+ emit_eevex_prefix_or_demote_arith_ndd(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C /* MAP4 */, EVEX_32bit, 0x23, 0xC0, no_flags, true /* is_commutative */);", "source_url": "https://github.com/openjdk/riscv-port/commit/c41add8d3e24be5f469f18cfbf0f476f2baf63a6", "code_v0_no_empty_lines": "对于可交换操作（如add、and、or等），当目标寄存器与第二个源寄存器相同时，使用Extended EVEX编码，需要手动设置InstructionAttr并调用多个函数。", "code_v1_no_empty_lines": "- InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n  // NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n  // Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C /* MAP4 */, &attributes, no_flags);\n  emit_arith(0x23, 0xC0, src1, src2);\n+ emit_eevex_prefix_or_demote_arith_ndd(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C /* MAP4 */, EVEX_32bit, 0x23, 0xC0, no_flags, true /* is_commutative */);", "target": "- InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n  // NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n  // Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C /* MAP4 */, &attributes, no_flags);\n  emit_arith(0x23, 0xC0, src1, src2);\n+ emit_eevex_prefix_or_demote_arith_ndd(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C /* MAP4 */, EVEX_32bit, 0x23, 0xC0, no_flags, true /* is_commutative */);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于可交换操作（如add、and、or等），当目标寄存器与第二个源寄存器相同时，使用Extended EVEX编码，需要手动设置InstructionAttr并调用多个函数。优化后：引入新的emit_eevex_prefix_or_demote_arith_ndd和emit_eevex_or_demote函数，自动处理EVEX到REX2/REX的降级，通过is_commutative参数识别可交换操作，简化代码并提高指令编码效率。优化思路：利用可交换操作的特性，在目标寄存器与第二个源寄存器相同时，允许更灵活的编码选择，减少指令大小和潜在的解码开销。"}
{"id": 197, "source": "riscv-dataset-excel", "optimization_type": "寄存器分配优化", "optimization_description": "优化前：在decode_klass_not_null函数中，当dst和src寄存器相同时，需要将xbase设置为tmp寄存器，并在shift!=0时使用额外的临时寄存器t（可能是dst或t0），增加了寄存器分配复杂性和潜在冲突。优化后：始终使用tmp作为xbase寄存器，简化了寄存器分配逻辑；在shift!=0时直接使用dst作为临时寄存器（通过assert确保dst!=xbase），减少了寄存器使用。优化思路：通过更合理的寄存器选择策略，减少寄存器依赖和分配复杂性，提高代码生成效率。", "original_code": "在decode_klass_not_null函数中，当dst和src寄存器相同时，需要将xbase设置为tmp寄存器，并在shift!=0时使用额外的临时寄存器t（可能是dst或t0），增加了寄存器分配复杂性和潜在冲突。", "optimized_code": "-  Register xbase = dst;\n-  if (dst == src) {\n-    xbase = tmp;\n-  }\n-  assert_different_registers(src, xbase);\n-  if (CompressedKlassPointers::shift() != 0) {\n-    Register t = src == dst ? dst : t0;\n-    assert_different_registers(t, xbase);\n-    shadd(dst, src, xbase, t, CompressedKlassPointers::shift());\n-  } else {\n-    add(dst, xbase, src);\n-  }\n+  Register xbase = tmp;\n+  if (CompressedKlassPointers::shift() != 0) {\n+    // dst = (src << shift) + xbase\n+    shadd(dst, src, xbase, dst /* temporary, dst != xbase */, CompressedKlassPointers::shift());\n+  } else {\n+    add(dst, xbase, src);\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/0b3a303053d0eb5a98ed3d9df42c659db148b470", "code_v0_no_empty_lines": "在decode_klass_not_null函数中，当dst和src寄存器相同时，需要将xbase设置为tmp寄存器，并在shift!=0时使用额外的临时寄存器t（可能是dst或t0），增加了寄存器分配复杂性和潜在冲突。", "code_v1_no_empty_lines": "-  Register xbase = dst;\n-  if (dst == src) {\n-    xbase = tmp;\n-  }\n-  assert_different_registers(src, xbase);\n-  if (CompressedKlassPointers::shift() != 0) {\n-    Register t = src == dst ? dst : t0;\n-    assert_different_registers(t, xbase);\n-    shadd(dst, src, xbase, t, CompressedKlassPointers::shift());\n-  } else {\n-    add(dst, xbase, src);\n-  }\n+  Register xbase = tmp;\n+  if (CompressedKlassPointers::shift() != 0) {\n+    // dst = (src << shift) + xbase\n+    shadd(dst, src, xbase, dst /* temporary, dst != xbase */, CompressedKlassPointers::shift());\n+  } else {\n+    add(dst, xbase, src);\n+  }", "target": "-  Register xbase = dst;\n-  if (dst == src) {\n-    xbase = tmp;\n-  }\n-  assert_different_registers(src, xbase);\n-  if (CompressedKlassPointers::shift() != 0) {\n-    Register t = src == dst ? dst : t0;\n-    assert_different_registers(t, xbase);\n-    shadd(dst, src, xbase, t, CompressedKlassPointers::shift());\n-  } else {\n-    add(dst, xbase, src);\n-  }\n+  Register xbase = tmp;\n+  if (CompressedKlassPointers::shift() != 0) {\n+    // dst = (src << shift) + xbase\n+    shadd(dst, src, xbase, dst /* temporary, dst != xbase */, CompressedKlassPointers::shift());\n+  } else {\n+    add(dst, xbase, src);\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在decode_klass_not_null函数中，当dst和src寄存器相同时，需要将xbase设置为tmp寄存器，并在shift!=0时使用额外的临时寄存器t（可能是dst或t0），增加了寄存器分配复杂性和潜在冲突。优化后：始终使用tmp作为xbase寄存器，简化了寄存器分配逻辑；在shift!=0时直接使用dst作为临时寄存器（通过assert确保dst!=xbase），减少了寄存器使用。优化思路：通过更合理的寄存器选择策略，减少寄存器依赖和分配复杂性，提高代码生成效率。"}
{"id": 198, "source": "riscv-dataset-excel", "optimization_type": "代码重构+向量化优化", "optimization_description": "优化前：代码结构复杂，使用嵌套if-else和assert语句处理不同类型的向量节点，CMove处理逻辑不清晰且存在潜在错误。优化后：重构为扁平化的if-else链，移除assert，简化代码结构；改进CMove处理逻辑，明确输入重排规则（mask, blend1, blend2 -> blend1, blend2, mask）并正确处理测试取反情况。优化思路：通过代码重构提高可维护性和可读性，同时修正向量化过程中CMove节点的处理逻辑，确保向量化转换的正确性和性能。", "original_code": "代码结构复杂，使用嵌套if-else和assert语句处理不同类型的向量节点，CMove处理逻辑不清晰且存在潜在错误。", "optimized_code": "-      } else {\n-        assert(vtn->isa_ElementWiseVector() != nullptr, \"all other vtnodes are handled above\");\n-        if (VectorNode::is_scalar_rotate(p0) &&\n-            p0->in(2)->is_Con() &&\n-            Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n-          init_req_with_vector(pack, vtn, 1);\n-          init_req_with_scalar(p0,   vtn, 2); // constant rotation\n-        } else if (VectorNode::is_roundopD(p0)) {\n-          init_req_with_vector(pack, vtn, 1);\n-          init_req_with_scalar(p0,   vtn, 2); // constant rounding mode\n-        } else if (p0->is_CMove()) {\n-          // Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n-          set_all_req_with_vectors(pack, vtn);\n-          VTransformBoolVectorNode* vtn_mask_cmp = vtn->in_req(1)->isa_BoolVector();\n-          if (vtn_mask_cmp->test()._is_negated) {\n-            vtn->swap_req(2, 3); // swap if test was negated.\n-          }\n-        } else {\n-          set_all_req_with_vectors(pack, vtn);\n-        }\n+    } else if (VectorNode::is_scalar_rotate(p0) &&\n+               p0->in(2)->is_Con() &&\n+               Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n+      init_req_with_vector(pack, vtn, 1);\n+      init_req_with_scalar(p0,   vtn, 2); // constant rotation\n+    } else if (VectorNode::is_roundopD(p0)) {\n+      init_req_with_vector(pack, vtn, 1);\n+      init_req_with_scalar(p0,   vtn, 2); // constant rounding mode\n+    } else if (p0->is_CMove()) {\n+      // Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n+      init_all_req_with_vectors(pack, vtn);\n+      // Inputs must be permuted from (mask, blend1, blend2) -> (blend1, blend2, mask)\n+      vtn->swap_req(1, 2);\n+      vtn->swap_req(2, 3);\n+      // If the test was negated: (blend1, blend2, mask) -> (blend2, blend1, mask)\n+      VTransformBoolVectorNode* vtn_mask_cmp = vtn->in_req(3)->isa_BoolVector();\n+      if (vtn_mask_cmp->test()._is_negated) {\n+        vtn->swap_req(1, 2); // swap if test was negated.\n+      }\n+    } else {\n+      init_all_req_with_vectors(pack, vtn);", "source_url": "https://github.com/openjdk/riscv-port/commit/4cc75be80e6a89e0ed293e2f8bbb6d0f94189468", "code_v0_no_empty_lines": "代码结构复杂，使用嵌套if-else和assert语句处理不同类型的向量节点，CMove处理逻辑不清晰且存在潜在错误。", "code_v1_no_empty_lines": "-      } else {\n-        assert(vtn->isa_ElementWiseVector() != nullptr, \"all other vtnodes are handled above\");\n-        if (VectorNode::is_scalar_rotate(p0) &&\n-            p0->in(2)->is_Con() &&\n-            Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n-          init_req_with_vector(pack, vtn, 1);\n-          init_req_with_scalar(p0,   vtn, 2); // constant rotation\n-        } else if (VectorNode::is_roundopD(p0)) {\n-          init_req_with_vector(pack, vtn, 1);\n-          init_req_with_scalar(p0,   vtn, 2); // constant rounding mode\n-        } else if (p0->is_CMove()) {\n-          // Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n-          set_all_req_with_vectors(pack, vtn);\n-          VTransformBoolVectorNode* vtn_mask_cmp = vtn->in_req(1)->isa_BoolVector();\n-          if (vtn_mask_cmp->test()._is_negated) {\n-            vtn->swap_req(2, 3); // swap if test was negated.\n-          }\n-        } else {\n-          set_all_req_with_vectors(pack, vtn);\n-        }\n+    } else if (VectorNode::is_scalar_rotate(p0) &&\n+               p0->in(2)->is_Con() &&\n+               Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n+      init_req_with_vector(pack, vtn, 1);\n+      init_req_with_scalar(p0,   vtn, 2); // constant rotation\n+    } else if (VectorNode::is_roundopD(p0)) {\n+      init_req_with_vector(pack, vtn, 1);\n+      init_req_with_scalar(p0,   vtn, 2); // constant rounding mode\n+    } else if (p0->is_CMove()) {\n+      // Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n+      init_all_req_with_vectors(pack, vtn);\n+      // Inputs must be permuted from (mask, blend1, blend2) -> (blend1, blend2, mask)\n+      vtn->swap_req(1, 2);\n+      vtn->swap_req(2, 3);\n+      // If the test was negated: (blend1, blend2, mask) -> (blend2, blend1, mask)\n+      VTransformBoolVectorNode* vtn_mask_cmp = vtn->in_req(3)->isa_BoolVector();\n+      if (vtn_mask_cmp->test()._is_negated) {\n+        vtn->swap_req(1, 2); // swap if test was negated.\n+      }\n+    } else {\n+      init_all_req_with_vectors(pack, vtn);", "target": "-      } else {\n-        assert(vtn->isa_ElementWiseVector() != nullptr, \"all other vtnodes are handled above\");\n-        if (VectorNode::is_scalar_rotate(p0) &&\n-            p0->in(2)->is_Con() &&\n-            Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n-          init_req_with_vector(pack, vtn, 1);\n-          init_req_with_scalar(p0,   vtn, 2); // constant rotation\n-        } else if (VectorNode::is_roundopD(p0)) {\n-          init_req_with_vector(pack, vtn, 1);\n-          init_req_with_scalar(p0,   vtn, 2); // constant rounding mode\n-        } else if (p0->is_CMove()) {\n-          // Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n-          set_all_req_with_vectors(pack, vtn);\n-          VTransformBoolVectorNode* vtn_mask_cmp = vtn->in_req(1)->isa_BoolVector();\n-          if (vtn_mask_cmp->test()._is_negated) {\n-            vtn->swap_req(2, 3); // swap if test was negated.\n-          }\n-        } else {\n-          set_all_req_with_vectors(pack, vtn);\n-        }\n+    } else if (VectorNode::is_scalar_rotate(p0) &&\n+               p0->in(2)->is_Con() &&\n+               Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n+      init_req_with_vector(pack, vtn, 1);\n+      init_req_with_scalar(p0,   vtn, 2); // constant rotation\n+    } else if (VectorNode::is_roundopD(p0)) {\n+      init_req_with_vector(pack, vtn, 1);\n+      init_req_with_scalar(p0,   vtn, 2); // constant rounding mode\n+    } else if (p0->is_CMove()) {\n+      // Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n+      init_all_req_with_vectors(pack, vtn);\n+      // Inputs must be permuted from (mask, blend1, blend2) -> (blend1, blend2, mask)\n+      vtn->swap_req(1, 2);\n+      vtn->swap_req(2, 3);\n+      // If the test was negated: (blend1, blend2, mask) -> (blend2, blend1, mask)\n+      VTransformBoolVectorNode* vtn_mask_cmp = vtn->in_req(3)->isa_BoolVector();\n+      if (vtn_mask_cmp->test()._is_negated) {\n+        vtn->swap_req(1, 2); // swap if test was negated.\n+      }\n+    } else {\n+      init_all_req_with_vectors(pack, vtn);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：代码结构复杂，使用嵌套if-else和assert语句处理不同类型的向量节点，CMove处理逻辑不清晰且存在潜在错误。优化后：重构为扁平化的if-else链，移除assert，简化代码结构；改进CMove处理逻辑，明确输入重排规则（mask, blend1, blend2 -> blend1, blend2, mask）并正确处理测试取反情况。优化思路：通过代码重构提高可维护性和可读性，同时修正向量化过程中CMove节点的处理逻辑，确保向量化转换的正确性和性能。"}
{"id": 199, "source": "riscv-dataset-excel", "optimization_type": "垃圾回收算法优化", "optimization_description": "优化前：在多个GC启发式算法中，通过age_census()->tenuring_threshold()获取晋升阈值，并在条件判断中直接比较region->age() >= tenuring_threshold。\n优化后：引入heap->is_tenurable(region)内联函数封装晋升判断逻辑，移除对tenuring_threshold的局部变量存储和直接比较。\n优化思路：1. 避免在算法中直接暴露tenuring_threshold的获取和比较逻辑，提高代码抽象层次；2. 通过内联函数减少函数调用开销；3. 集中晋升判断逻辑，便于后续算法调整和维护；4. 解决自适应晋升阈值算法可能过早提升阈值的问题（Bug 8365956）。", "original_code": "在多个GC启发式算法中，通过age_census()->tenuring_threshold()获取晋升阈值，并在条件判断中直接比较region->age() >= tenuring_threshold。", "optimized_code": "- const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+ // 移除局部变量tenuring_threshold\n- if (region->is_young() && (region->age() >= tenuring_threshold)) {\n+ if (region->is_young() && heap->is_tenurable(region)) {", "source_url": "https://github.com/openjdk/riscv-port/commit/7fcce27096605a27ca3b74349d1012bb0bd5963d", "code_v0_no_empty_lines": "在多个GC启发式算法中，通过age_census()->tenuring_threshold()获取晋升阈值，并在条件判断中直接比较region->age() >= tenuring_threshold。", "code_v1_no_empty_lines": "- const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+ // 移除局部变量tenuring_threshold\n- if (region->is_young() && (region->age() >= tenuring_threshold)) {\n+ if (region->is_young() && heap->is_tenurable(region)) {", "target": "- const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+ // 移除局部变量tenuring_threshold\n- if (region->is_young() && (region->age() >= tenuring_threshold)) {\n+ if (region->is_young() && heap->is_tenurable(region)) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在多个GC启发式算法中，通过age_census()->tenuring_threshold()获取晋升阈值，并在条件判断中直接比较region->age() >= tenuring_threshold。\n优化后：引入heap->is_tenurable(region)内联函数封装晋升判断逻辑，移除对tenuring_threshold的局部变量存储和直接比较。\n优化思路：1. 避免在算法中直接暴露tenuring_threshold的获取和比较逻辑，提高代码抽象层次；2. 通过内联函数减少函数调用开销；3. 集中晋升判断逻辑，便于后续算法调整和维护；4. 解决自适应晋升阈值算法可能过早提升阈值的问题（Bug 8365956）。"}
{"id": 200, "source": "riscv-dataset-excel", "optimization_type": "AOT缓存优化+类链接优化", "optimization_description": "优化前：AOT缓存转储时，旧类（old classes）在链接状态处理不完善，可能导致验证依赖问题。优化后：通过重构类链接逻辑，将链接循环提取为独立函数link_all_loaded_classes，并引入AOT安全点标志（is_at_aot_safepoint）来管理旧类的验证约束。思路：确保在AOT缓存转储过程中，旧类能以链接状态正确存储，避免运行时验证失败，提升AOT缓存的可靠性和启动性能。", "original_code": "AOT缓存转储时，旧类（old classes）在链接状态处理不完善，可能导致验证依赖问题。", "optimized_code": "void AOTMetaspace::link_shared_classes(TRAPS) {\n-  AOTClassLinker::initialize();\n-  AOTClassInitializer::init_test_class(CHECK);\n-\n-  while (true) {\n-    ResourceMark rm(THREAD);\n-    CollectClassesForLinking collect_classes;\n-    bool has_linked = false;\n-    const GrowableArray<OopHandle>* mirrors = collect_classes.mirrors();\n-    for (int i = 0; i < mirrors->length(); i++) {\n-      OopHandle mirror = mirrors->at(i);\n-      InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror.resolve()));\n-      if (may_be_eagerly_linked(ik)) {\n-        has_linked |= try_link_class(THREAD, ik);\n-      }\n-    }\n-\n-    if (!has_linked) {\n-      break;\n-    }\n-    // Class linking includes verification which may load more classes.\n-    // Keep scanning until we have linked no more classes.\n-  }\n+  AOTClassLinker::initialize();\n+  AOTClassInitializer::init_test_class(CHECK);\n+\n+  link_all_loaded_classes(THREAD);\n \n   // Eargerly resolve all string constants in constant pools\n   {\n\n+void AOTMetaspace::link_all_loaded_classes(JavaThread* current) {\n+  while (true) {\n+    ResourceMark rm(current);\n+    CollectClassesForLinking collect_classes;\n+    bool has_linked = false;\n+    const GrowableArray<OopHandle>* mirrors = collect_classes.mirrors();\n+    for (int i = 0; i < mirrors->length(); i++) {\n+      OopHandle mirror = mirrors->at(i);\n+      InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror.resolve()));\n+      if (may_be_eagerly_linked(ik)) {\n+        has_linked |= try_link_class(current, ik);\n+      }\n+    }\n+\n+    if (!has_linked) {\n+      break;\n+    }\n+    // Class linking includes verification which may load more classes.\n+    // Keep scanning until we have linked no more classes.\n+  }\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/85715e1050fa774c3267dbbe2f749717aeeec8ff", "code_v0_no_empty_lines": "AOT缓存转储时，旧类（old classes）在链接状态处理不完善，可能导致验证依赖问题。", "code_v1_no_empty_lines": "void AOTMetaspace::link_shared_classes(TRAPS) {\n-  AOTClassLinker::initialize();\n-  AOTClassInitializer::init_test_class(CHECK);\n-\n-  while (true) {\n-    ResourceMark rm(THREAD);\n-    CollectClassesForLinking collect_classes;\n-    bool has_linked = false;\n-    const GrowableArray<OopHandle>* mirrors = collect_classes.mirrors();\n-    for (int i = 0; i < mirrors->length(); i++) {\n-      OopHandle mirror = mirrors->at(i);\n-      InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror.resolve()));\n-      if (may_be_eagerly_linked(ik)) {\n-        has_linked |= try_link_class(THREAD, ik);\n-      }\n-    }\n-\n-    if (!has_linked) {\n-      break;\n-    }\n-    // Class linking includes verification which may load more classes.\n-    // Keep scanning until we have linked no more classes.\n-  }\n+  AOTClassLinker::initialize();\n+  AOTClassInitializer::init_test_class(CHECK);\n+\n+  link_all_loaded_classes(THREAD);\n \n   // Eargerly resolve all string constants in constant pools\n   {\n\n+void AOTMetaspace::link_all_loaded_classes(JavaThread* current) {\n+  while (true) {\n+    ResourceMark rm(current);\n+    CollectClassesForLinking collect_classes;\n+    bool has_linked = false;\n+    const GrowableArray<OopHandle>* mirrors = collect_classes.mirrors();\n+    for (int i = 0; i < mirrors->length(); i++) {\n+      OopHandle mirror = mirrors->at(i);\n+      InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror.resolve()));\n+      if (may_be_eagerly_linked(ik)) {\n+        has_linked |= try_link_class(current, ik);\n+      }\n+    }\n+\n+    if (!has_linked) {\n+      break;\n+    }\n+    // Class linking includes verification which may load more classes.\n+    // Keep scanning until we have linked no more classes.\n+  }\n+}", "target": "void AOTMetaspace::link_shared_classes(TRAPS) {\n-  AOTClassLinker::initialize();\n-  AOTClassInitializer::init_test_class(CHECK);\n-\n-  while (true) {\n-    ResourceMark rm(THREAD);\n-    CollectClassesForLinking collect_classes;\n-    bool has_linked = false;\n-    const GrowableArray<OopHandle>* mirrors = collect_classes.mirrors();\n-    for (int i = 0; i < mirrors->length(); i++) {\n-      OopHandle mirror = mirrors->at(i);\n-      InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror.resolve()));\n-      if (may_be_eagerly_linked(ik)) {\n-        has_linked |= try_link_class(THREAD, ik);\n-      }\n-    }\n-\n-    if (!has_linked) {\n-      break;\n-    }\n-    // Class linking includes verification which may load more classes.\n-    // Keep scanning until we have linked no more classes.\n-  }\n+  AOTClassLinker::initialize();\n+  AOTClassInitializer::init_test_class(CHECK);\n+\n+  link_all_loaded_classes(THREAD);\n \n   // Eargerly resolve all string constants in constant pools\n   {\n\n+void AOTMetaspace::link_all_loaded_classes(JavaThread* current) {\n+  while (true) {\n+    ResourceMark rm(current);\n+    CollectClassesForLinking collect_classes;\n+    bool has_linked = false;\n+    const GrowableArray<OopHandle>* mirrors = collect_classes.mirrors();\n+    for (int i = 0; i < mirrors->length(); i++) {\n+      OopHandle mirror = mirrors->at(i);\n+      InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror.resolve()));\n+      if (may_be_eagerly_linked(ik)) {\n+        has_linked |= try_link_class(current, ik);\n+      }\n+    }\n+\n+    if (!has_linked) {\n+      break;\n+    }\n+    // Class linking includes verification which may load more classes.\n+    // Keep scanning until we have linked no more classes.\n+  }\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AOT缓存转储时，旧类（old classes）在链接状态处理不完善，可能导致验证依赖问题。优化后：通过重构类链接逻辑，将链接循环提取为独立函数link_all_loaded_classes，并引入AOT安全点标志（is_at_aot_safepoint）来管理旧类的验证约束。思路：确保在AOT缓存转储过程中，旧类能以链接状态正确存储，避免运行时验证失败，提升AOT缓存的可靠性和启动性能。"}
{"id": 201, "source": "riscv-dataset-excel", "optimization_type": "代码清理/无用代码移除", "optimization_description": "优化前：在多个CPU架构的AD文件中定义了nops列表，并在ADLC解析器中维护了_noplist和_nopcnt字段用于处理这些nop指令定义。优化后：移除了所有CPU架构AD文件中的nops定义，删除了ADLC中相关的解析、存储和输出代码，将nops标记为过时令牌。优化思路：nops列表在C2编译器中未被使用，属于无用代码，移除这些代码可以减少代码复杂度、降低维护成本，并可能轻微减少编译时内存使用。", "original_code": "在多个CPU架构的AD文件中定义了nops列表，并在ADLC解析器中维护了_noplist和_nopcnt字段用于处理这些nop指令定义。", "optimized_code": "-  // List of nop instructions\n-  nops( MachNop );", "source_url": "https://github.com/openjdk/riscv-port/commit/cc6d34b2fa299a68a05e65e25c1f41dffa67c118", "code_v0_no_empty_lines": "在多个CPU架构的AD文件中定义了nops列表，并在ADLC解析器中维护了_noplist和_nopcnt字段用于处理这些nop指令定义。", "code_v1_no_empty_lines": "-  // List of nop instructions\n-  nops( MachNop );", "target": "-  // List of nop instructions\n-  nops( MachNop );", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在多个CPU架构的AD文件中定义了nops列表，并在ADLC解析器中维护了_noplist和_nopcnt字段用于处理这些nop指令定义。优化后：移除了所有CPU架构AD文件中的nops定义，删除了ADLC中相关的解析、存储和输出代码，将nops标记为过时令牌。优化思路：nops列表在C2编译器中未被使用，属于无用代码，移除这些代码可以减少代码复杂度、降低维护成本，并可能轻微减少编译时内存使用。"}
{"id": 202, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+内联优化", "optimization_description": "优化前：VectorMask.laneIsSet方法在输入索引为变量时无法进行内联优化，导致性能下降。优化后：放宽内联条件，允许变量索引的VectorMask.laneIsSet调用进行内联优化，提升向量化代码性能。思路：通过移除索引必须为常量的限制，使编译器能够对更多场景下的VectorMask.laneIsSet调用进行内联优化。", "original_code": "VectorMask.laneIsSet方法在输入索引为变量时无法进行内联优化，导致性能下降。", "optimized_code": "-      idx          == nullptr || !idx->is_con()) {\n+      idx          == nullptr) {", "source_url": "https://github.com/openjdk/riscv-port/commit/53b3e0567d2801ddf62c5849b219324ddfcb264a", "code_v0_no_empty_lines": "VectorMask.laneIsSet方法在输入索引为变量时无法进行内联优化，导致性能下降。", "code_v1_no_empty_lines": "-      idx          == nullptr || !idx->is_con()) {\n+      idx          == nullptr) {", "target": "-      idx          == nullptr || !idx->is_con()) {\n+      idx          == nullptr) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：VectorMask.laneIsSet方法在输入索引为变量时无法进行内联优化，导致性能下降。优化后：放宽内联条件，允许变量索引的VectorMask.laneIsSet调用进行内联优化，提升向量化代码性能。思路：通过移除索引必须为常量的限制，使编译器能够对更多场景下的VectorMask.laneIsSet调用进行内联优化。"}
{"id": 203, "source": "riscv-dataset-excel", "optimization_type": "内存优化+自适应算法优化", "optimization_description": "优化前：CPU时间采样队列使用固定容量或基于采样周期简单计算容量，可能导致队列溢出丢失样本或内存浪费。优化后：引入自适应队列大小调整机制，基于队列满导致的样本丢失率动态调整容量，使用多级缩放因子（2x、4x、8x或丢失率比例）快速响应负载变化，同时添加原子操作保证线程安全。优化思路：通过监控队列溢出情况自动调整内存分配，在保证采样完整性的同时减少不必要的内存开销，提高采样系统的健壮性和效率。", "original_code": "CPU时间采样队列使用固定容量或基于采样周期简单计算容量，可能导致队列溢出丢失样本或内存浪费。", "optimized_code": "void JfrCPUTimeTraceQueue::resize_if_needed() {\n  u4 lost_samples_due_to_queue_full = get_and_reset_lost_samples_due_to_queue_full();\n  if (lost_samples_due_to_queue_full == 0) {\n    return;\n  }\n  u4 capacity = Atomic::load(&_capacity);\n  if (capacity < CPU_TIME_QUEUE_MAX_CAPACITY) {\n    float ratio = (float)lost_samples_due_to_queue_full / (float)capacity;\n    int factor = 1;\n    if (ratio > 8) { // idea is to quickly scale the queue in the worst case\n      factor = ratio;\n    } else if (ratio > 2) {\n      factor = 8;\n    } else if (ratio > 0.5) {\n      factor = 4;\n    } else if (ratio > 0.01) {\n      factor = 2;\n    }\n    if (factor > 1) {\n      u4 new_capacity = MIN2(CPU_TIME_QUEUE_MAX_CAPACITY, capacity * factor);\n      set_capacity(new_capacity);\n    }\n  }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/002f936ef21943ff1c8c03618091793768e756ac", "code_v0_no_empty_lines": "CPU时间采样队列使用固定容量或基于采样周期简单计算容量，可能导致队列溢出丢失样本或内存浪费。", "code_v1_no_empty_lines": "void JfrCPUTimeTraceQueue::resize_if_needed() {\n  u4 lost_samples_due_to_queue_full = get_and_reset_lost_samples_due_to_queue_full();\n  if (lost_samples_due_to_queue_full == 0) {\n    return;\n  }\n  u4 capacity = Atomic::load(&_capacity);\n  if (capacity < CPU_TIME_QUEUE_MAX_CAPACITY) {\n    float ratio = (float)lost_samples_due_to_queue_full / (float)capacity;\n    int factor = 1;\n    if (ratio > 8) { // idea is to quickly scale the queue in the worst case\n      factor = ratio;\n    } else if (ratio > 2) {\n      factor = 8;\n    } else if (ratio > 0.5) {\n      factor = 4;\n    } else if (ratio > 0.01) {\n      factor = 2;\n    }\n    if (factor > 1) {\n      u4 new_capacity = MIN2(CPU_TIME_QUEUE_MAX_CAPACITY, capacity * factor);\n      set_capacity(new_capacity);\n    }\n  }\n}", "target": "void JfrCPUTimeTraceQueue::resize_if_needed() {\n  u4 lost_samples_due_to_queue_full = get_and_reset_lost_samples_due_to_queue_full();\n  if (lost_samples_due_to_queue_full == 0) {\n    return;\n  }\n  u4 capacity = Atomic::load(&_capacity);\n  if (capacity < CPU_TIME_QUEUE_MAX_CAPACITY) {\n    float ratio = (float)lost_samples_due_to_queue_full / (float)capacity;\n    int factor = 1;\n    if (ratio > 8) { // idea is to quickly scale the queue in the worst case\n      factor = ratio;\n    } else if (ratio > 2) {\n      factor = 8;\n    } else if (ratio > 0.5) {\n      factor = 4;\n    } else if (ratio > 0.01) {\n      factor = 2;\n    }\n    if (factor > 1) {\n      u4 new_capacity = MIN2(CPU_TIME_QUEUE_MAX_CAPACITY, capacity * factor);\n      set_capacity(new_capacity);\n    }\n  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CPU时间采样队列使用固定容量或基于采样周期简单计算容量，可能导致队列溢出丢失样本或内存浪费。优化后：引入自适应队列大小调整机制，基于队列满导致的样本丢失率动态调整容量，使用多级缩放因子（2x、4x、8x或丢失率比例）快速响应负载变化，同时添加原子操作保证线程安全。优化思路：通过监控队列溢出情况自动调整内存分配，在保证采样完整性的同时减少不必要的内存开销，提高采样系统的健壮性和效率。"}
{"id": 204, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（递归内联检查修复）", "optimization_description": "优化前：递归内联检查对编译lambda形式的处理存在缺陷，仅通过比较方法参数节点来判断递归，忽略了方法句柄调用器（MH invoker）的特殊情况，可能导致错误的递归检测或遗漏检测。\n优化后：1. 在JVMState中添加receiver_info字段存储编译lambda形式的常量接收者实例；2. 实现compute_receiver_info方法计算接收者信息；3. 重构递归检测逻辑，区分普通方法和编译lambda形式，对lambda形式通过比较接收者实例来判断真正递归。\n优化思路：修复编译lambda形式的递归内联检查机制，确保正确识别真正递归调用（相同接收者）以限制内联深度，同时允许重用lambda形式的内联，避免编译器栈溢出并提高优化准确性。", "original_code": "递归内联检查对编译lambda形式的处理存在缺陷，仅通过比较方法参数节点来判断递归，忽略了方法句柄调用器（MH invoker）的特殊情况，可能导致错误的递归检测或遗漏检测。", "optimized_code": "@@ -437,24 +438,26 @@ bool InlineTree::try_to_inline(ciMethod* callee_method, ciMethod* caller_method,\n \n   // detect direct and indirect recursive inlining\n   {\n-    // count the current method and the callee\n     const bool is_compiled_lambda_form = callee_method->is_compiled_lambda_form();\n-    int inline_level = 0;\n-    if (!is_compiled_lambda_form) {\n-      if (method() == callee_method) {\n-        inline_level++;\n-      }\n+    const bool is_method_handle_invoker = is_compiled_lambda_form && !jvms->method()->is_compiled_lambda_form();\n+\n+    ciInstance* lform_callee_recv = nullptr;\n+    if (is_compiled_lambda_form && !is_method_handle_invoker) { // MH invokers don't have a receiver\n+      lform_callee_recv = jvms->compute_receiver_info(callee_method);\n     }\n-    // count callers of current method and callee\n-    Node* callee_argument0 = is_compiled_lambda_form ? jvms->map()->argument(jvms, 0)->uncast() : nullptr;\n-    for (JVMState* j = jvms->caller(); j != nullptr && j->has_method(); j = j->caller()) {\n+\n+    int inline_level = 0;\n+    for (JVMState* j = jvms; j != nullptr && j->has_method(); j = j->caller()) {\n       if (j->method() == callee_method) {\n-        if (is_compiled_lambda_form) {\n-          // Since compiled lambda forms are heavily reused we allow recursive inlining.  If it is truly\n-          // a recursion (using the same \"receiver\") we limit inlining otherwise we can easily blow the\n-          // compiler stack.\n-          Node* caller_argument0 = j->map()->argument(j, 0)->uncast();\n-          if (caller_argument0 == callee_argument0) {\n+        // Since compiled lambda forms are heavily reused we allow recursive inlining.  If it is truly\n+        // a recursion (using the same \"receiver\") we limit inlining otherwise we can easily blow the\n+        // compiler stack.\n+        if (lform_callee_recv != nullptr) {\n+          ciInstance* lform_caller_recv = j->receiver_info();\n+          assert(lform_caller_recv != nullptr || j->depth() == 1 ||\n+                 !j->caller()->method()->is_compiled_lambda_form(), // MH invoker\n+                 \"missing receiver info\");\n+          if (lform_caller_recv == lform_callee_recv || lform_caller_recv == nullptr) {\n             inline_level++;\n           }\n         } else {\n@@ -262,7 +262,8 @@ uint TailJumpNode::match_edge(uint idx) const {\n \n //=============================================================================\n JVMState::JVMState(ciMethod* method, JVMState* caller) :\n-  _method(method) {\n+  _method(method),\n+  _receiver_info(nullptr) {\n   assert(method != nullptr, \"must be valid call site\");\n   _bci = InvocationEntryBci;\n   _reexecute = Reexecute_Undefined;\n@@ -278,7 +279,8 @@ JVMState::JVMState(ciMethod* method, JVMState* caller) :\n   _sp = 0;\n }\n JVMState::JVMState(int stack_size) :\n-  _method(nullptr) {\n+  _method(nullptr),\n+  _receiver_info(nullptr) {\n   _bci = InvocationEntryBci;\n   _reexecute = Reexecute_Undefined;\n   DEBUG_ONLY(_map = (SafePointNode*)-1);\n@@ -613,6 +615,7 @@ JVMState* JVMState::clone_shallow(Compile* C) const {\n   n->set_endoff(_endoff);\n   n->set_sp(_sp);\n   n->set_map(_map);\n+  n->set_receiver_info(_receiver_info);\n   return n;\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/9cca4f7c760bea9bf79f7c03f37a70449acad51e", "code_v0_no_empty_lines": "递归内联检查对编译lambda形式的处理存在缺陷，仅通过比较方法参数节点来判断递归，忽略了方法句柄调用器（MH invoker）的特殊情况，可能导致错误的递归检测或遗漏检测。", "code_v1_no_empty_lines": "@@ -437,24 +438,26 @@ bool InlineTree::try_to_inline(ciMethod* callee_method, ciMethod* caller_method,\n \n   // detect direct and indirect recursive inlining\n   {\n-    // count the current method and the callee\n     const bool is_compiled_lambda_form = callee_method->is_compiled_lambda_form();\n-    int inline_level = 0;\n-    if (!is_compiled_lambda_form) {\n-      if (method() == callee_method) {\n-        inline_level++;\n-      }\n+    const bool is_method_handle_invoker = is_compiled_lambda_form && !jvms->method()->is_compiled_lambda_form();\n+\n+    ciInstance* lform_callee_recv = nullptr;\n+    if (is_compiled_lambda_form && !is_method_handle_invoker) { // MH invokers don't have a receiver\n+      lform_callee_recv = jvms->compute_receiver_info(callee_method);\n     }\n-    // count callers of current method and callee\n-    Node* callee_argument0 = is_compiled_lambda_form ? jvms->map()->argument(jvms, 0)->uncast() : nullptr;\n-    for (JVMState* j = jvms->caller(); j != nullptr && j->has_method(); j = j->caller()) {\n+\n+    int inline_level = 0;\n+    for (JVMState* j = jvms; j != nullptr && j->has_method(); j = j->caller()) {\n       if (j->method() == callee_method) {\n-        if (is_compiled_lambda_form) {\n-          // Since compiled lambda forms are heavily reused we allow recursive inlining.  If it is truly\n-          // a recursion (using the same \"receiver\") we limit inlining otherwise we can easily blow the\n-          // compiler stack.\n-          Node* caller_argument0 = j->map()->argument(j, 0)->uncast();\n-          if (caller_argument0 == callee_argument0) {\n+        // Since compiled lambda forms are heavily reused we allow recursive inlining.  If it is truly\n+        // a recursion (using the same \"receiver\") we limit inlining otherwise we can easily blow the\n+        // compiler stack.\n+        if (lform_callee_recv != nullptr) {\n+          ciInstance* lform_caller_recv = j->receiver_info();\n+          assert(lform_caller_recv != nullptr || j->depth() == 1 ||\n+                 !j->caller()->method()->is_compiled_lambda_form(), // MH invoker\n+                 \"missing receiver info\");\n+          if (lform_caller_recv == lform_callee_recv || lform_caller_recv == nullptr) {\n             inline_level++;\n           }\n         } else {\n@@ -262,7 +262,8 @@ uint TailJumpNode::match_edge(uint idx) const {\n \n //=============================================================================\n JVMState::JVMState(ciMethod* method, JVMState* caller) :\n-  _method(method) {\n+  _method(method),\n+  _receiver_info(nullptr) {\n   assert(method != nullptr, \"must be valid call site\");\n   _bci = InvocationEntryBci;\n   _reexecute = Reexecute_Undefined;\n@@ -278,7 +279,8 @@ JVMState::JVMState(ciMethod* method, JVMState* caller) :\n   _sp = 0;\n }\n JVMState::JVMState(int stack_size) :\n-  _method(nullptr) {\n+  _method(nullptr),\n+  _receiver_info(nullptr) {\n   _bci = InvocationEntryBci;\n   _reexecute = Reexecute_Undefined;\n   DEBUG_ONLY(_map = (SafePointNode*)-1);\n@@ -613,6 +615,7 @@ JVMState* JVMState::clone_shallow(Compile* C) const {\n   n->set_endoff(_endoff);\n   n->set_sp(_sp);\n   n->set_map(_map);\n+  n->set_receiver_info(_receiver_info);\n   return n;\n }", "target": "@@ -437,24 +438,26 @@ bool InlineTree::try_to_inline(ciMethod* callee_method, ciMethod* caller_method,\n \n   // detect direct and indirect recursive inlining\n   {\n-    // count the current method and the callee\n     const bool is_compiled_lambda_form = callee_method->is_compiled_lambda_form();\n-    int inline_level = 0;\n-    if (!is_compiled_lambda_form) {\n-      if (method() == callee_method) {\n-        inline_level++;\n-      }\n+    const bool is_method_handle_invoker = is_compiled_lambda_form && !jvms->method()->is_compiled_lambda_form();\n+\n+    ciInstance* lform_callee_recv = nullptr;\n+    if (is_compiled_lambda_form && !is_method_handle_invoker) { // MH invokers don't have a receiver\n+      lform_callee_recv = jvms->compute_receiver_info(callee_method);\n     }\n-    // count callers of current method and callee\n-    Node* callee_argument0 = is_compiled_lambda_form ? jvms->map()->argument(jvms, 0)->uncast() : nullptr;\n-    for (JVMState* j = jvms->caller(); j != nullptr && j->has_method(); j = j->caller()) {\n+\n+    int inline_level = 0;\n+    for (JVMState* j = jvms; j != nullptr && j->has_method(); j = j->caller()) {\n       if (j->method() == callee_method) {\n-        if (is_compiled_lambda_form) {\n-          // Since compiled lambda forms are heavily reused we allow recursive inlining.  If it is truly\n-          // a recursion (using the same \"receiver\") we limit inlining otherwise we can easily blow the\n-          // compiler stack.\n-          Node* caller_argument0 = j->map()->argument(j, 0)->uncast();\n-          if (caller_argument0 == callee_argument0) {\n+        // Since compiled lambda forms are heavily reused we allow recursive inlining.  If it is truly\n+        // a recursion (using the same \"receiver\") we limit inlining otherwise we can easily blow the\n+        // compiler stack.\n+        if (lform_callee_recv != nullptr) {\n+          ciInstance* lform_caller_recv = j->receiver_info();\n+          assert(lform_caller_recv != nullptr || j->depth() == 1 ||\n+                 !j->caller()->method()->is_compiled_lambda_form(), // MH invoker\n+                 \"missing receiver info\");\n+          if (lform_caller_recv == lform_callee_recv || lform_caller_recv == nullptr) {\n             inline_level++;\n           }\n         } else {\n@@ -262,7 +262,8 @@ uint TailJumpNode::match_edge(uint idx) const {\n \n //=============================================================================\n JVMState::JVMState(ciMethod* method, JVMState* caller) :\n-  _method(method) {\n+  _method(method),\n+  _receiver_info(nullptr) {\n   assert(method != nullptr, \"must be valid call site\");\n   _bci = InvocationEntryBci;\n   _reexecute = Reexecute_Undefined;\n@@ -278,7 +279,8 @@ JVMState::JVMState(ciMethod* method, JVMState* caller) :\n   _sp = 0;\n }\n JVMState::JVMState(int stack_size) :\n-  _method(nullptr) {\n+  _method(nullptr),\n+  _receiver_info(nullptr) {\n   _bci = InvocationEntryBci;\n   _reexecute = Reexecute_Undefined;\n   DEBUG_ONLY(_map = (SafePointNode*)-1);\n@@ -613,6 +615,7 @@ JVMState* JVMState::clone_shallow(Compile* C) const {\n   n->set_endoff(_endoff);\n   n->set_sp(_sp);\n   n->set_map(_map);\n+  n->set_receiver_info(_receiver_info);\n   return n;\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：递归内联检查对编译lambda形式的处理存在缺陷，仅通过比较方法参数节点来判断递归，忽略了方法句柄调用器（MH invoker）的特殊情况，可能导致错误的递归检测或遗漏检测。\n优化后：1. 在JVMState中添加receiver_info字段存储编译lambda形式的常量接收者实例；2. 实现compute_receiver_info方法计算接收者信息；3. 重构递归检测逻辑，区分普通方法和编译lambda形式，对lambda形式通过比较接收者实例来判断真正递归。\n优化思路：修复编译lambda形式的递归内联检查机制，确保正确识别真正递归调用（相同接收者）以限制内联深度，同时允许重用lambda形式的内联，避免编译器栈溢出并提高优化准确性。"}
{"id": 205, "source": "riscv-dataset-excel", "optimization_type": "代码简化+内存优化", "optimization_description": "优化前：MemAllocator::Allocation::_overhead_limit_exceeded字段及相关代码用于跟踪GC开销限制是否超限，增加了内存占用和代码复杂度。优化后：移除了该字段及相关参数传递，简化了mem_allocate方法的签名和实现，减少了内存开销和函数调用参数传递。思路：该字段已不再使用，属于dead code，移除后可以简化代码结构并减少内存占用。", "original_code": "MemAllocator::Allocation::_overhead_limit_exceeded字段及相关代码用于跟踪GC开销限制是否超限，增加了内存占用和代码复杂度。", "optimized_code": "-HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) override;\n+HeapWord* mem_allocate(size_t size) override;", "source_url": "https://github.com/openjdk/riscv-port/commit/33794d161467635eb32591fee189e5409cd2d114", "code_v0_no_empty_lines": "MemAllocator::Allocation::_overhead_limit_exceeded字段及相关代码用于跟踪GC开销限制是否超限，增加了内存占用和代码复杂度。", "code_v1_no_empty_lines": "-HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) override;\n+HeapWord* mem_allocate(size_t size) override;", "target": "-HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) override;\n+HeapWord* mem_allocate(size_t size) override;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：MemAllocator::Allocation::_overhead_limit_exceeded字段及相关代码用于跟踪GC开销限制是否超限，增加了内存占用和代码复杂度。优化后：移除了该字段及相关参数传递，简化了mem_allocate方法的签名和实现，减少了内存开销和函数调用参数传递。思路：该字段已不再使用，属于dead code，移除后可以简化代码结构并减少内存占用。"}
{"id": 206, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+编译器Bug修复", "optimization_description": "优化前：VectorReinterpretNode构造函数参数顺序错误，导致在SuperWord向量化优化中，当Reinterpret操作后接Cast操作时，源类型和目标类型被错误交换，产生错误的向量转换。优化后：修正参数顺序，确保Reinterpret操作正确处理源类型和目标类型，避免后续Cast操作使用错误的类型。思路：修复C2编译器SuperWord优化中的向量重解释节点构造错误，确保向量重解释和类型转换的正确性。", "original_code": "VectorReinterpretNode构造函数参数顺序错误，导致在SuperWord向量化优化中，当Reinterpret操作后接Cast操作时，源类型和目标类型被错误交换，产生错误的向量转换。", "optimized_code": "-    vn = new VectorReinterpretNode(in1, vt, in1->bottom_type()->is_vect());\n+    vn = new VectorReinterpretNode(in1, in1->bottom_type()->is_vect(), vt);", "source_url": "https://github.com/openjdk/riscv-port/commit/e6fa8aae6168ea5a8579cd0a38209ca71c32e704", "code_v0_no_empty_lines": "VectorReinterpretNode构造函数参数顺序错误，导致在SuperWord向量化优化中，当Reinterpret操作后接Cast操作时，源类型和目标类型被错误交换，产生错误的向量转换。", "code_v1_no_empty_lines": "-    vn = new VectorReinterpretNode(in1, vt, in1->bottom_type()->is_vect());\n+    vn = new VectorReinterpretNode(in1, in1->bottom_type()->is_vect(), vt);", "target": "-    vn = new VectorReinterpretNode(in1, vt, in1->bottom_type()->is_vect());\n+    vn = new VectorReinterpretNode(in1, in1->bottom_type()->is_vect(), vt);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：VectorReinterpretNode构造函数参数顺序错误，导致在SuperWord向量化优化中，当Reinterpret操作后接Cast操作时，源类型和目标类型被错误交换，产生错误的向量转换。优化后：修正参数顺序，确保Reinterpret操作正确处理源类型和目标类型，避免后续Cast操作使用错误的类型。思路：修复C2编译器SuperWord优化中的向量重解释节点构造错误，确保向量重解释和类型转换的正确性。"}
{"id": 207, "source": "riscv-dataset-excel", "optimization_type": "编译器优化策略调整", "optimization_description": "优化前：OptimizeFill功能仅在MaxVectorSize<32或不支持AVX-512VLBW指令集时被禁用。优化后：增加对EnableX86ECoreOpts标志的判断，当该标志未启用且不支持AVX-512VLBW时，才禁用OptimizeFill。优化思路：放宽OptimizeFill的启用条件，允许在更多硬件配置下使用更广泛的内部函数（intrinsics）进行填充操作优化，从而提升性能。", "original_code": "OptimizeFill功能仅在MaxVectorSize<32或不支持AVX-512VLBW指令集时被禁用。", "optimized_code": "-    if (MaxVectorSize < 32 || !VM_Version::supports_avx512vlbw()) {\n+    if (MaxVectorSize < 32 || (!EnableX86ECoreOpts && !VM_Version::supports_avx512vlbw())) {", "source_url": "https://github.com/openjdk/riscv-port/commit/1dc1d56f79e10c9b4c5c8b42a80a191f7b14c738", "code_v0_no_empty_lines": "OptimizeFill功能仅在MaxVectorSize<32或不支持AVX-512VLBW指令集时被禁用。", "code_v1_no_empty_lines": "-    if (MaxVectorSize < 32 || !VM_Version::supports_avx512vlbw()) {\n+    if (MaxVectorSize < 32 || (!EnableX86ECoreOpts && !VM_Version::supports_avx512vlbw())) {", "target": "-    if (MaxVectorSize < 32 || !VM_Version::supports_avx512vlbw()) {\n+    if (MaxVectorSize < 32 || (!EnableX86ECoreOpts && !VM_Version::supports_avx512vlbw())) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：OptimizeFill功能仅在MaxVectorSize<32或不支持AVX-512VLBW指令集时被禁用。优化后：增加对EnableX86ECoreOpts标志的判断，当该标志未启用且不支持AVX-512VLBW时，才禁用OptimizeFill。优化思路：放宽OptimizeFill的启用条件，允许在更多硬件配置下使用更广泛的内部函数（intrinsics）进行填充操作优化，从而提升性能。"}
{"id": 208, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前使用OrderAccess::fence()全内存屏障释放自旋锁，开销较大。优化后改用Atomic::release_store()精确释放语义，仅需#loadstore|#storestore屏障，减少不必要的内存屏障开销，提升锁释放性能。", "original_code": "// No original code extracted from description\n", "optimized_code": "-  OrderAccess::fence();\n-  *adr = 0;\n+  Atomic::release_store(adr, 0);", "source_url": "https://github.com/openjdk/riscv-port/commit/4d1dfabcb4e94601995b07b7ecea4249ae375a04", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "-  OrderAccess::fence();\n-  *adr = 0;\n+  Atomic::release_store(adr, 0);", "target": "-  OrderAccess::fence();\n-  *adr = 0;\n+  Atomic::release_store(adr, 0);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用OrderAccess::fence()全内存屏障释放自旋锁，开销较大。优化后改用Atomic::release_store()精确释放语义，仅需#loadstore|#storestore屏障，减少不必要的内存屏障开销，提升锁释放性能。"}
{"id": 209, "source": "riscv-dataset-excel", "optimization_type": "编译器正确性优化+内存安全优化", "optimization_description": "优化前：CastP2X节点缺少控制依赖（ctrl=nullptr），在向量化优化中可能浮动到SafePoint之前，导致GC移动对象后指针值过时（stale oops），产生错误结果。优化后：1) 为make_pointer_expression和make_speculative_aliasing_check_with函数添加ctrl参数；2) 在CastP2X节点创建时传入正确的控制依赖，确保指针转换不会跨越SafePoint；3) 重构add_speculative_check为模板回调函数，在生成检查时提供正确的控制节点。优化思路：通过确保指针转换操作具有适当的控制依赖，防止GC安全点导致的指针值不一致问题，修复向量化优化中的内存安全性缺陷。", "original_code": "CastP2X节点缺少控制依赖（ctrl=nullptr），在向量化优化中可能浮动到SafePoint之前，导致GC移动对象后指针值过时（stale oops），产生错误结果。", "optimized_code": "- Node* VPointer::make_pointer_expression(Node* iv_value) const {\n+ Node* VPointer::make_pointer_expression(Node* iv_value, Node* ctrl) const {\n   ...\n-       variable = new CastP2XNode(nullptr, variable);\n+       variable = new CastP2XNode(ctrl, variable);\n   ...\n- BoolNode* VPointer::make_speculative_aliasing_check_with(const VPointer& other) const {\n+ BoolNode* VPointer::make_speculative_aliasing_check_with(const VPointer& other, Node* ctrl) const {\n   ...\n-   Node* p1_init = vp1.make_pointer_expression(main_init);\n-   Node* p2_init = vp2.make_pointer_expression(main_init);\n+   Node* p1_init = vp1.make_pointer_expression(main_init, ctrl);\n+   Node* p2_init = vp2.make_pointer_expression(main_init, ctrl);\n   ...\n- void VTransform::add_speculative_check(BoolNode* bol) {\n+ template<typename Callback>\n+ void VTransform::add_speculative_check(Callback callback) {\n   ...\n+   // Create the check, given the ctrl just before the iff.\n+   BoolNode* bol = callback(iff_speculate->in(0));", "source_url": "https://github.com/openjdk/riscv-port/commit/2527e9e58d770c50e6d807bf1483c6bb07dd3de7", "code_v0_no_empty_lines": "CastP2X节点缺少控制依赖（ctrl=nullptr），在向量化优化中可能浮动到SafePoint之前，导致GC移动对象后指针值过时（stale oops），产生错误结果。", "code_v1_no_empty_lines": "- Node* VPointer::make_pointer_expression(Node* iv_value) const {\n+ Node* VPointer::make_pointer_expression(Node* iv_value, Node* ctrl) const {\n   ...\n-       variable = new CastP2XNode(nullptr, variable);\n+       variable = new CastP2XNode(ctrl, variable);\n   ...\n- BoolNode* VPointer::make_speculative_aliasing_check_with(const VPointer& other) const {\n+ BoolNode* VPointer::make_speculative_aliasing_check_with(const VPointer& other, Node* ctrl) const {\n   ...\n-   Node* p1_init = vp1.make_pointer_expression(main_init);\n-   Node* p2_init = vp2.make_pointer_expression(main_init);\n+   Node* p1_init = vp1.make_pointer_expression(main_init, ctrl);\n+   Node* p2_init = vp2.make_pointer_expression(main_init, ctrl);\n   ...\n- void VTransform::add_speculative_check(BoolNode* bol) {\n+ template<typename Callback>\n+ void VTransform::add_speculative_check(Callback callback) {\n   ...\n+   // Create the check, given the ctrl just before the iff.\n+   BoolNode* bol = callback(iff_speculate->in(0));", "target": "- Node* VPointer::make_pointer_expression(Node* iv_value) const {\n+ Node* VPointer::make_pointer_expression(Node* iv_value, Node* ctrl) const {\n   ...\n-       variable = new CastP2XNode(nullptr, variable);\n+       variable = new CastP2XNode(ctrl, variable);\n   ...\n- BoolNode* VPointer::make_speculative_aliasing_check_with(const VPointer& other) const {\n+ BoolNode* VPointer::make_speculative_aliasing_check_with(const VPointer& other, Node* ctrl) const {\n   ...\n-   Node* p1_init = vp1.make_pointer_expression(main_init);\n-   Node* p2_init = vp2.make_pointer_expression(main_init);\n+   Node* p1_init = vp1.make_pointer_expression(main_init, ctrl);\n+   Node* p2_init = vp2.make_pointer_expression(main_init, ctrl);\n   ...\n- void VTransform::add_speculative_check(BoolNode* bol) {\n+ template<typename Callback>\n+ void VTransform::add_speculative_check(Callback callback) {\n   ...\n+   // Create the check, given the ctrl just before the iff.\n+   BoolNode* bol = callback(iff_speculate->in(0));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CastP2X节点缺少控制依赖（ctrl=nullptr），在向量化优化中可能浮动到SafePoint之前，导致GC移动对象后指针值过时（stale oops），产生错误结果。优化后：1) 为make_pointer_expression和make_speculative_aliasing_check_with函数添加ctrl参数；2) 在CastP2X节点创建时传入正确的控制依赖，确保指针转换不会跨越SafePoint；3) 重构add_speculative_check为模板回调函数，在生成检查时提供正确的控制节点。优化思路：通过确保指针转换操作具有适当的控制依赖，防止GC安全点导致的指针值不一致问题，修复向量化优化中的内存安全性缺陷。"}
{"id": 210, "source": "riscv-dataset-excel", "optimization_type": "性能监控与算法优化", "optimization_description": "优化前：G1垃圾收集器的堆大小调整策略仅基于GC暂停时间（pause_time_ms）计算时间比率，忽略了并发GC线程在暂停期间之外消耗的CPU时间对应用程序线程的影响，导致堆大小决策可能不够准确。\n优化后：引入并发GC CPU时间测量（_concurrent_gc_cpu_time_ms），在update_gc_time_ratios()函数中计算并发GC活动对应用程序线程造成的“损失”时间（concurrent_gc_impact_time = _concurrent_gc_cpu_time_ms / num_cpus），并将其与暂停时间相加得到总GC时间（gc_time_ms）。然后基于总GC时间重新计算长短期GC时间比率（_long_term_gc_time_ratio和_short_term_gc_time_ratio），替代原有的暂停时间比率。\n优化思路：通过更精确地量化GC活动（包括并发阶段）对系统资源的占用，改进G1堆大小调整策略的CPU使用率测量，使堆大小决策更能反映实际性能影响，从而提升整体系统效率。", "original_code": "G1垃圾收集器的堆大小调整策略仅基于GC暂停时间（pause_time_ms）计算时间比率，忽略了并发GC线程在暂停期间之外消耗的CPU时间对应用程序线程的影响，导致堆大小决策可能不够准确。", "optimized_code": "void G1Analytics::update_gc_time_ratios(double end_time_sec, double pause_time_ms) {\n+  // This estimates the wall-clock time \"lost\" by application mutator threads due to concurrent GC\n+  // activity. We do not account for contention on other shared resources such as memory bandwidth and\n+  // caches, therefore underestimate the impact of the concurrent GC activity on mutator threads.\n+  uint num_cpus = (uint)os::active_processor_count();\n+  double concurrent_gc_impact_time = _concurrent_gc_cpu_time_ms / num_cpus;\n+\n+  double gc_time_ms = pause_time_ms + concurrent_gc_impact_time;\n\n   double long_interval_ms = (end_time_sec - oldest_known_gc_end_time_sec()) * 1000.0;\n-  double gc_pause_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + pause_time_ms;\n-  _long_term_pause_time_ratio = gc_pause_time_ms / long_interval_ms;\n-  _long_term_pause_time_ratio = clamp(_long_term_pause_time_ratio, 0.0, 1.0);\n+  double long_term_gc_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + gc_time_ms;\n+\n+  _long_term_gc_time_ratio = long_term_gc_time_ms / long_interval_ms;\n+  _long_term_gc_time_ratio = clamp(_long_term_gc_time_ratio, 0.0, 1.0);\n\n   double short_interval_ms = (end_time_sec - most_recent_gc_end_time_sec()) * 1000.0;\n-  _short_term_pause_time_ratio = pause_time_ms / short_interval_ms;\n-  _short_term_pause_time_ratio = clamp(_short_term_pause_time_ratio, 0.0, 1.0);\n+  _short_term_gc_time_ratio = gc_time_ms / short_interval_ms;\n+  _short_term_gc_time_ratio = clamp(_short_term_gc_time_ratio, 0.0, 1.0);\n+\n+  update_recent_gc_times(end_time_sec, gc_time_ms);\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/124575b4c2b52328a8efddb40e67057a53b44a04", "code_v0_no_empty_lines": "G1垃圾收集器的堆大小调整策略仅基于GC暂停时间（pause_time_ms）计算时间比率，忽略了并发GC线程在暂停期间之外消耗的CPU时间对应用程序线程的影响，导致堆大小决策可能不够准确。", "code_v1_no_empty_lines": "void G1Analytics::update_gc_time_ratios(double end_time_sec, double pause_time_ms) {\n+  // This estimates the wall-clock time \"lost\" by application mutator threads due to concurrent GC\n+  // activity. We do not account for contention on other shared resources such as memory bandwidth and\n+  // caches, therefore underestimate the impact of the concurrent GC activity on mutator threads.\n+  uint num_cpus = (uint)os::active_processor_count();\n+  double concurrent_gc_impact_time = _concurrent_gc_cpu_time_ms / num_cpus;\n+\n+  double gc_time_ms = pause_time_ms + concurrent_gc_impact_time;\n\n   double long_interval_ms = (end_time_sec - oldest_known_gc_end_time_sec()) * 1000.0;\n-  double gc_pause_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + pause_time_ms;\n-  _long_term_pause_time_ratio = gc_pause_time_ms / long_interval_ms;\n-  _long_term_pause_time_ratio = clamp(_long_term_pause_time_ratio, 0.0, 1.0);\n+  double long_term_gc_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + gc_time_ms;\n+\n+  _long_term_gc_time_ratio = long_term_gc_time_ms / long_interval_ms;\n+  _long_term_gc_time_ratio = clamp(_long_term_gc_time_ratio, 0.0, 1.0);\n\n   double short_interval_ms = (end_time_sec - most_recent_gc_end_time_sec()) * 1000.0;\n-  _short_term_pause_time_ratio = pause_time_ms / short_interval_ms;\n-  _short_term_pause_time_ratio = clamp(_short_term_pause_time_ratio, 0.0, 1.0);\n+  _short_term_gc_time_ratio = gc_time_ms / short_interval_ms;\n+  _short_term_gc_time_ratio = clamp(_short_term_gc_time_ratio, 0.0, 1.0);\n+\n+  update_recent_gc_times(end_time_sec, gc_time_ms);\n }", "target": "void G1Analytics::update_gc_time_ratios(double end_time_sec, double pause_time_ms) {\n+  // This estimates the wall-clock time \"lost\" by application mutator threads due to concurrent GC\n+  // activity. We do not account for contention on other shared resources such as memory bandwidth and\n+  // caches, therefore underestimate the impact of the concurrent GC activity on mutator threads.\n+  uint num_cpus = (uint)os::active_processor_count();\n+  double concurrent_gc_impact_time = _concurrent_gc_cpu_time_ms / num_cpus;\n+\n+  double gc_time_ms = pause_time_ms + concurrent_gc_impact_time;\n\n   double long_interval_ms = (end_time_sec - oldest_known_gc_end_time_sec()) * 1000.0;\n-  double gc_pause_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + pause_time_ms;\n-  _long_term_pause_time_ratio = gc_pause_time_ms / long_interval_ms;\n-  _long_term_pause_time_ratio = clamp(_long_term_pause_time_ratio, 0.0, 1.0);\n+  double long_term_gc_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + gc_time_ms;\n+\n+  _long_term_gc_time_ratio = long_term_gc_time_ms / long_interval_ms;\n+  _long_term_gc_time_ratio = clamp(_long_term_gc_time_ratio, 0.0, 1.0);\n\n   double short_interval_ms = (end_time_sec - most_recent_gc_end_time_sec()) * 1000.0;\n-  _short_term_pause_time_ratio = pause_time_ms / short_interval_ms;\n-  _short_term_pause_time_ratio = clamp(_short_term_pause_time_ratio, 0.0, 1.0);\n+  _short_term_gc_time_ratio = gc_time_ms / short_interval_ms;\n+  _short_term_gc_time_ratio = clamp(_short_term_gc_time_ratio, 0.0, 1.0);\n+\n+  update_recent_gc_times(end_time_sec, gc_time_ms);\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：G1垃圾收集器的堆大小调整策略仅基于GC暂停时间（pause_time_ms）计算时间比率，忽略了并发GC线程在暂停期间之外消耗的CPU时间对应用程序线程的影响，导致堆大小决策可能不够准确。\n优化后：引入并发GC CPU时间测量（_concurrent_gc_cpu_time_ms），在update_gc_time_ratios()函数中计算并发GC活动对应用程序线程造成的“损失”时间（concurrent_gc_impact_time = _concurrent_gc_cpu_time_ms / num_cpus），并将其与暂停时间相加得到总GC时间（gc_time_ms）。然后基于总GC时间重新计算长短期GC时间比率（_long_term_gc_time_ratio和_short_term_gc_time_ratio），替代原有的暂停时间比率。\n优化思路：通过更精确地量化GC活动（包括并发阶段）对系统资源的占用，改进G1堆大小调整策略的CPU使用率测量，使堆大小决策更能反映实际性能影响，从而提升整体系统效率。"}
{"id": 211, "source": "riscv-dataset-excel", "optimization_type": "内存优化+NUMA感知优化", "optimization_description": "优化前：ZGC重定位时未考虑NUMA架构，所有线程共享相同的重定位预留空间，可能导致跨NUMA节点内存访问，增加内存延迟。优化后：在ZForwarding结构中添加partition_id字段，使重定位过程能够感知NUMA节点；修改relocation_headroom计算，为每个NUMA节点预留独立的重定位空间；在页面分配时支持指定首选NUMA分区。优化思路：通过NUMA感知的内存分配和重定位，减少跨节点内存访问，提高内存局部性，降低内存访问延迟，从而提升ZGC在多NUMA节点系统上的性能。", "original_code": "ZGC重定位时未考虑NUMA架构，所有线程共享相同的重定位预留空间，可能导致跨NUMA节点内存访问，增加内存延迟。", "optimized_code": "--- a/src/hotspot/share/gc/z/zHeuristics.cpp\n+++ b/src/hotspot/share/gc/z/zHeuristics.cpp\n@@ -58,9 +59,11 @@ void ZHeuristics::set_medium_page_size() {\n }\n \n size_t ZHeuristics::relocation_headroom() {\n-  // Calculate headroom needed to avoid in-place relocation. Each worker will try\n-  // to allocate a small page, and all workers will share a single medium page.\n-  return (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  // Calculate headroom needed to avoid in-place relocation. For each NUMA node,\n+  // each worker will try to allocate a small page, and all workers will share a\n+  // single medium page.\n+  const size_t per_numa_headroom = (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  return per_numa_headroom * ZNUMA::count();\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/b39c73696d0421b218e301403d589af5a91b037f", "code_v0_no_empty_lines": "ZGC重定位时未考虑NUMA架构，所有线程共享相同的重定位预留空间，可能导致跨NUMA节点内存访问，增加内存延迟。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/gc/z/zHeuristics.cpp\n+++ b/src/hotspot/share/gc/z/zHeuristics.cpp\n@@ -58,9 +59,11 @@ void ZHeuristics::set_medium_page_size() {\n }\n \n size_t ZHeuristics::relocation_headroom() {\n-  // Calculate headroom needed to avoid in-place relocation. Each worker will try\n-  // to allocate a small page, and all workers will share a single medium page.\n-  return (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  // Calculate headroom needed to avoid in-place relocation. For each NUMA node,\n+  // each worker will try to allocate a small page, and all workers will share a\n+  // single medium page.\n+  const size_t per_numa_headroom = (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  return per_numa_headroom * ZNUMA::count();\n }", "target": "--- a/src/hotspot/share/gc/z/zHeuristics.cpp\n+++ b/src/hotspot/share/gc/z/zHeuristics.cpp\n@@ -58,9 +59,11 @@ void ZHeuristics::set_medium_page_size() {\n }\n \n size_t ZHeuristics::relocation_headroom() {\n-  // Calculate headroom needed to avoid in-place relocation. Each worker will try\n-  // to allocate a small page, and all workers will share a single medium page.\n-  return (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  // Calculate headroom needed to avoid in-place relocation. For each NUMA node,\n+  // each worker will try to allocate a small page, and all workers will share a\n+  // single medium page.\n+  const size_t per_numa_headroom = (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  return per_numa_headroom * ZNUMA::count();\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ZGC重定位时未考虑NUMA架构，所有线程共享相同的重定位预留空间，可能导致跨NUMA节点内存访问，增加内存延迟。优化后：在ZForwarding结构中添加partition_id字段，使重定位过程能够感知NUMA节点；修改relocation_headroom计算，为每个NUMA节点预留独立的重定位空间；在页面分配时支持指定首选NUMA分区。优化思路：通过NUMA感知的内存分配和重定位，减少跨节点内存访问，提高内存局部性，降低内存访问延迟，从而提升ZGC在多NUMA节点系统上的性能。"}
{"id": 212, "source": "riscv-dataset-excel", "optimization_type": "内存布局优化+代码简化", "optimization_description": "优化前：RelocIterator使用指针遍历重定位信息，需要静态dummy对象处理空情况，代码复杂且依赖特殊地址（blob_end()）。优化后：改用索引（_current, _len）和基地址（_base）表示，移除dummy对象和blob_end()依赖，简化内存管理（如_mutable_data/immutable_data使用nullptr）。思路：将指针逻辑转换为索引计算，减少特殊值处理，提高代码清晰度和内存安全性。", "original_code": "RelocIterator使用指针遍历重定位信息，需要静态dummy对象处理空情况，代码复杂且依赖特殊地址（blob_end()）。", "optimized_code": "- static relocInfo dummy_relocInfo = relocInfo(relocInfo::none, 0);\n+ _base = nm->relocation_begin();\n+ _current = -1;\n+ _len = nm->relocation_end() - _base;", "source_url": "https://github.com/openjdk/riscv-port/commit/88c39793670f2d36490530993feb60e138f43a70", "code_v0_no_empty_lines": "RelocIterator使用指针遍历重定位信息，需要静态dummy对象处理空情况，代码复杂且依赖特殊地址（blob_end()）。", "code_v1_no_empty_lines": "- static relocInfo dummy_relocInfo = relocInfo(relocInfo::none, 0);\n+ _base = nm->relocation_begin();\n+ _current = -1;\n+ _len = nm->relocation_end() - _base;", "target": "- static relocInfo dummy_relocInfo = relocInfo(relocInfo::none, 0);\n+ _base = nm->relocation_begin();\n+ _current = -1;\n+ _len = nm->relocation_end() - _base;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RelocIterator使用指针遍历重定位信息，需要静态dummy对象处理空情况，代码复杂且依赖特殊地址（blob_end()）。优化后：改用索引（_current, _len）和基地址（_base）表示，移除dummy对象和blob_end()依赖，简化内存管理（如_mutable_data/immutable_data使用nullptr）。思路：将指针逻辑转换为索引计算，减少特殊值处理，提高代码清晰度和内存安全性。"}
{"id": 213, "source": "riscv-dataset-excel", "optimization_type": "内存优化+性能优化", "optimization_description": "优化前：DigitList和FloatingDecimal使用char数组存储数字字符，每个字符占用2字节，内存开销较大且字符串转换效率不高。优化后：改用byte数组存储数字字符，每个数字仅需1字节，显著减少内存占用；同时优化字符串转换逻辑，直接使用byte数组构造字符串，避免不必要的字符数组复制和编码转换。优化思路：利用数字字符的ASCII特性（0-9在0-127范围内），可用单字节存储，减少内存分配和GC压力，提升数值转换性能。", "original_code": "DigitList和FloatingDecimal使用char数组存储数字字符，每个字符占用2字节，内存开销较大且字符串转换效率不高。", "optimized_code": "- public char[] digits = new char[MAX_COUNT];\n+ public byte[] digits = new byte[MAX_COUNT];\n- char[] data;\n+ byte[] data;\n- digits[count++] = digit;\n+ digits[count++] = (byte) digit;\n- long v = Long.parseUnsignedLong(new String(digits, 0, count));\n+ long v = Long.parseUnsignedLong(new String(digits, 0, count, StandardCharsets.ISO_8859_1));", "source_url": "https://github.com/openjdk/riscv-port/commit/dba0d545053fb73e57ea6fda829a5bf3d0135ac5", "code_v0_no_empty_lines": "DigitList和FloatingDecimal使用char数组存储数字字符，每个字符占用2字节，内存开销较大且字符串转换效率不高。", "code_v1_no_empty_lines": "- public char[] digits = new char[MAX_COUNT];\n+ public byte[] digits = new byte[MAX_COUNT];\n- char[] data;\n+ byte[] data;\n- digits[count++] = digit;\n+ digits[count++] = (byte) digit;\n- long v = Long.parseUnsignedLong(new String(digits, 0, count));\n+ long v = Long.parseUnsignedLong(new String(digits, 0, count, StandardCharsets.ISO_8859_1));", "target": "- public char[] digits = new char[MAX_COUNT];\n+ public byte[] digits = new byte[MAX_COUNT];\n- char[] data;\n+ byte[] data;\n- digits[count++] = digit;\n+ digits[count++] = (byte) digit;\n- long v = Long.parseUnsignedLong(new String(digits, 0, count));\n+ long v = Long.parseUnsignedLong(new String(digits, 0, count, StandardCharsets.ISO_8859_1));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：DigitList和FloatingDecimal使用char数组存储数字字符，每个字符占用2字节，内存开销较大且字符串转换效率不高。优化后：改用byte数组存储数字字符，每个数字仅需1字节，显著减少内存占用；同时优化字符串转换逻辑，直接使用byte数组构造字符串，避免不必要的字符数组复制和编码转换。优化思路：利用数字字符的ASCII特性（0-9在0-127范围内），可用单字节存储，减少内存分配和GC压力，提升数值转换性能。"}
{"id": 214, "source": "riscv-dataset-excel", "optimization_type": "代码重构+性能优化", "optimization_description": "优化前：adjust方法同时处理常见情况（无覆盖）和复杂情况（有覆盖），代码逻辑混合，影响JIT优化。优化后：将方法拆分为三个层次：1) adjust方法快速检查并返回常见情况；2) adjustWithOverride方法处理覆盖逻辑；3) adjustSlow方法处理复杂分支。优化思路：通过方法拆分实现热点代码分离，让JIT编译器能更好地优化常见路径，减少方法内联和分支预测的开销，同时保持代码可维护性。", "original_code": "adjust方法同时处理常见情况（无覆盖）和复杂情况（有覆盖），代码逻辑混合，影响JIT优化。", "optimized_code": "private static TemporalAccessor adjust(final TemporalAccessor temporal, DateTimeFormatter formatter) {\n    // normal case first (early return is an optimization)\n    Chronology overrideChrono = formatter.getChronology();\n    ZoneId overrideZone = formatter.getZone();\n    if (overrideChrono == null && overrideZone == null) {\n        return temporal;\n    }\n\n    // Placing the non-null cases in a separate method allows more flexible code optimizations\n    return adjustWithOverride(temporal, overrideChrono, overrideZone);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/f5f414f9fc67e55acb83e04ea270d39041cb6198", "code_v0_no_empty_lines": "adjust方法同时处理常见情况（无覆盖）和复杂情况（有覆盖），代码逻辑混合，影响JIT优化。", "code_v1_no_empty_lines": "private static TemporalAccessor adjust(final TemporalAccessor temporal, DateTimeFormatter formatter) {\n    // normal case first (early return is an optimization)\n    Chronology overrideChrono = formatter.getChronology();\n    ZoneId overrideZone = formatter.getZone();\n    if (overrideChrono == null && overrideZone == null) {\n        return temporal;\n    }\n\n    // Placing the non-null cases in a separate method allows more flexible code optimizations\n    return adjustWithOverride(temporal, overrideChrono, overrideZone);\n}", "target": "private static TemporalAccessor adjust(final TemporalAccessor temporal, DateTimeFormatter formatter) {\n    // normal case first (early return is an optimization)\n    Chronology overrideChrono = formatter.getChronology();\n    ZoneId overrideZone = formatter.getZone();\n    if (overrideChrono == null && overrideZone == null) {\n        return temporal;\n    }\n\n    // Placing the non-null cases in a separate method allows more flexible code optimizations\n    return adjustWithOverride(temporal, overrideChrono, overrideZone);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：adjust方法同时处理常见情况（无覆盖）和复杂情况（有覆盖），代码逻辑混合，影响JIT优化。优化后：将方法拆分为三个层次：1) adjust方法快速检查并返回常见情况；2) adjustWithOverride方法处理覆盖逻辑；3) adjustSlow方法处理复杂分支。优化思路：通过方法拆分实现热点代码分离，让JIT编译器能更好地优化常见路径，减少方法内联和分支预测的开销，同时保持代码可维护性。"}
{"id": 215, "source": "riscv-dataset-excel", "optimization_type": "内联优化", "optimization_description": "优化前：finalize_incremental_building()作为一个独立的空函数被调用，仅包含两个断言检查，导致额外的函数调用开销。优化后：将两个断言直接内联到调用者finalize_young_part()中，移除了函数声明和调用。优化思路：消除不必要的函数调用开销，减少代码体积，提高执行效率。", "original_code": "finalize_incremental_building()作为一个独立的空函数被调用，仅包含两个断言检查，导致额外的函数调用开销。", "optimized_code": "-void G1CollectionSet::finalize_incremental_building() {\n-  assert(_inc_build_state == Active, \"Precondition\");\n-  assert(SafepointSynchronize::is_at_safepoint(), \"should be at a safepoint\");\n-}\n...\n-  finalize_incremental_building();\n+  assert(_inc_build_state == Active, \"Precondition\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"should be at a safepoint\");", "source_url": "https://github.com/openjdk/riscv-port/commit/f61b247fe3a818fc60a61c6f42a676ad94e8e976", "code_v0_no_empty_lines": "finalize_incremental_building()作为一个独立的空函数被调用，仅包含两个断言检查，导致额外的函数调用开销。", "code_v1_no_empty_lines": "-void G1CollectionSet::finalize_incremental_building() {\n-  assert(_inc_build_state == Active, \"Precondition\");\n-  assert(SafepointSynchronize::is_at_safepoint(), \"should be at a safepoint\");\n-}\n...\n-  finalize_incremental_building();\n+  assert(_inc_build_state == Active, \"Precondition\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"should be at a safepoint\");", "target": "-void G1CollectionSet::finalize_incremental_building() {\n-  assert(_inc_build_state == Active, \"Precondition\");\n-  assert(SafepointSynchronize::is_at_safepoint(), \"should be at a safepoint\");\n-}\n...\n-  finalize_incremental_building();\n+  assert(_inc_build_state == Active, \"Precondition\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"should be at a safepoint\");", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：finalize_incremental_building()作为一个独立的空函数被调用，仅包含两个断言检查，导致额外的函数调用开销。优化后：将两个断言直接内联到调用者finalize_young_part()中，移除了函数声明和调用。优化思路：消除不必要的函数调用开销，减少代码体积，提高执行效率。"}
{"id": 216, "source": "riscv-dataset-excel", "optimization_type": "数据结构简化+内存优化", "optimization_description": "优化前：使用G1CollectionSetCandidateInfo结构体数组存储候选区域信息，包含额外元数据字段。优化后：直接使用G1HeapRegion*指针数组存储候选区域，在需要时临时创建G1CollectionSetCandidateInfo对象。优化思路：简化数据结构，减少内存分配和复制开销，提高GC集合候选计算性能。", "original_code": "使用G1CollectionSetCandidateInfo结构体数组存储候选区域信息，包含额外元数据字段。", "optimized_code": "- void G1CSetCandidateGroup::add(G1CollectionSetCandidateInfo& hr_info) {\n-   G1HeapRegion* hr = hr_info._r;\n-   _candidates.append(hr_info);\n-   hr->install_cset_group(this);\n- }\n+ void G1CSetCandidateGroup::add(G1HeapRegion* hr) {\n+   G1CollectionSetCandidateInfo c(hr);\n+   _candidates.append(c);\n+   hr->install_cset_group(this);\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/f0e706698df5ac199198b252d77d27a05abad1da", "code_v0_no_empty_lines": "使用G1CollectionSetCandidateInfo结构体数组存储候选区域信息，包含额外元数据字段。", "code_v1_no_empty_lines": "- void G1CSetCandidateGroup::add(G1CollectionSetCandidateInfo& hr_info) {\n-   G1HeapRegion* hr = hr_info._r;\n-   _candidates.append(hr_info);\n-   hr->install_cset_group(this);\n- }\n+ void G1CSetCandidateGroup::add(G1HeapRegion* hr) {\n+   G1CollectionSetCandidateInfo c(hr);\n+   _candidates.append(c);\n+   hr->install_cset_group(this);\n+ }", "target": "- void G1CSetCandidateGroup::add(G1CollectionSetCandidateInfo& hr_info) {\n-   G1HeapRegion* hr = hr_info._r;\n-   _candidates.append(hr_info);\n-   hr->install_cset_group(this);\n- }\n+ void G1CSetCandidateGroup::add(G1HeapRegion* hr) {\n+   G1CollectionSetCandidateInfo c(hr);\n+   _candidates.append(c);\n+   hr->install_cset_group(this);\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用G1CollectionSetCandidateInfo结构体数组存储候选区域信息，包含额外元数据字段。优化后：直接使用G1HeapRegion*指针数组存储候选区域，在需要时临时创建G1CollectionSetCandidateInfo对象。优化思路：简化数据结构，减少内存分配和复制开销，提高GC集合候选计算性能。"}
{"id": 217, "source": "riscv-dataset-excel", "optimization_type": "代码重构+内存访问优化", "optimization_description": "优化前：do_cset_groups()函数包含大量重复代码，分别处理年轻代和老年代组的统计信息，逻辑分散且存在硬编码的计数器引用。优化后：提取公共逻辑到accumulate_stats_for_group()函数，通过参数化计数器引用消除重复代码；统一了最大内存组的更新逻辑；添加了对保留区域的验证断言。优化思路：通过代码重构提高可维护性，减少代码重复，统一内存访问模式，同时保持原有功能不变。", "original_code": "do_cset_groups()函数包含大量重复代码，分别处理年轻代和老年代组的统计信息，逻辑分散且存在硬编码的计数器引用。", "optimized_code": "- void do_cset_groups() {\n    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n    G1CSetCandidateGroup* young_only_cset_group = g1h->young_regions_cset_group();\n\n    // If the group has only a single region, then stats were accumulated\n    // during region iteration.\n    if (young_only_cset_group->length() > 1) {\n      G1CardSet* young_only_card_set = young_only_cset_group->card_set();\n      size_t rs_mem_sz = young_only_card_set->mem_size();\n      size_t rs_unused_mem_sz = young_only_card_set->unused_mem_size();\n      size_t occupied_cards = young_only_card_set->occupied();\n\n      _max_group_cardset_mem_sz = rs_mem_sz;\n      _max_cardset_mem_sz_group = young_only_cset_group;\n\n      // Only update cardset details\n      _young.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n      _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n    }\n\n\n    G1PerRegionTypeRemSetCounters* current = &_old;\n    for (G1CSetCandidateGroup* group : g1h->policy()->candidates()->from_marking_groups()) {\n      if (group->length() > 1) {\n        G1CardSet* group_card_set = group->card_set();\n        size_t rs_mem_sz = group_card_set->mem_size();\n        size_t rs_unused_mem_sz = group_card_set->unused_mem_size();\n        size_t occupied_cards = group_card_set->occupied();\n\n        if (rs_mem_sz > _max_group_cardset_mem_sz) {\n          _max_group_cardset_mem_sz = rs_mem_sz;\n          _max_cardset_mem_sz_group = group;\n        }\n\n        // Only update cardset details\n        _old.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n        _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n      }\n    }\n  }\n+  void accumulate_stats_for_group(G1CSetCandidateGroup* group, G1PerRegionTypeRemSetCounters* gen_counter) {\n    // If the group has only a single region, then stats were accumulated\n    // during region iteration. Skip these.\n    if (group->length() > 1) {\n      G1CardSet* card_set = group->card_set();\n\n      size_t rs_mem_sz = card_set->mem_size();\n      size_t rs_unused_mem_sz = card_set->unused_mem_size();\n      size_t occupied_cards = card_set->occupied();\n\n      if (rs_mem_sz > _max_group_cardset_mem_sz) {\n        _max_group_cardset_mem_sz = rs_mem_sz;\n        _max_cardset_mem_sz_group = group;\n      }\n\n      gen_counter->add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n      _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n    }\n  }\n\n  void do_cset_groups() {\n    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n\n    accumulate_stats_for_group(g1h->young_regions_cset_group(), &_young);\n\n    G1CollectionSetCandidates* candidates = g1h->policy()->candidates();\n    for (G1CSetCandidateGroup* group : candidates->from_marking_groups()) {\n      accumulate_stats_for_group(group, &_old);\n    }\n    // Skip gathering statistics for retained regions. Just verify that they have\n    // the expected amount of regions.\n    for (G1CSetCandidateGroup* group : candidates->retained_groups()) {\n      assert(group->length() == 1, \"must be\");\n    }\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/a3fd4248b74ed800ff124cc3e7c259dca36ea446", "code_v0_no_empty_lines": "do_cset_groups()函数包含大量重复代码，分别处理年轻代和老年代组的统计信息，逻辑分散且存在硬编码的计数器引用。", "code_v1_no_empty_lines": "- void do_cset_groups() {\n    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n    G1CSetCandidateGroup* young_only_cset_group = g1h->young_regions_cset_group();\n\n    // If the group has only a single region, then stats were accumulated\n    // during region iteration.\n    if (young_only_cset_group->length() > 1) {\n      G1CardSet* young_only_card_set = young_only_cset_group->card_set();\n      size_t rs_mem_sz = young_only_card_set->mem_size();\n      size_t rs_unused_mem_sz = young_only_card_set->unused_mem_size();\n      size_t occupied_cards = young_only_card_set->occupied();\n\n      _max_group_cardset_mem_sz = rs_mem_sz;\n      _max_cardset_mem_sz_group = young_only_cset_group;\n\n      // Only update cardset details\n      _young.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n      _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n    }\n\n\n    G1PerRegionTypeRemSetCounters* current = &_old;\n    for (G1CSetCandidateGroup* group : g1h->policy()->candidates()->from_marking_groups()) {\n      if (group->length() > 1) {\n        G1CardSet* group_card_set = group->card_set();\n        size_t rs_mem_sz = group_card_set->mem_size();\n        size_t rs_unused_mem_sz = group_card_set->unused_mem_size();\n        size_t occupied_cards = group_card_set->occupied();\n\n        if (rs_mem_sz > _max_group_cardset_mem_sz) {\n          _max_group_cardset_mem_sz = rs_mem_sz;\n          _max_cardset_mem_sz_group = group;\n        }\n\n        // Only update cardset details\n        _old.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n        _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n      }\n    }\n  }\n+  void accumulate_stats_for_group(G1CSetCandidateGroup* group, G1PerRegionTypeRemSetCounters* gen_counter) {\n    // If the group has only a single region, then stats were accumulated\n    // during region iteration. Skip these.\n    if (group->length() > 1) {\n      G1CardSet* card_set = group->card_set();\n\n      size_t rs_mem_sz = card_set->mem_size();\n      size_t rs_unused_mem_sz = card_set->unused_mem_size();\n      size_t occupied_cards = card_set->occupied();\n\n      if (rs_mem_sz > _max_group_cardset_mem_sz) {\n        _max_group_cardset_mem_sz = rs_mem_sz;\n        _max_cardset_mem_sz_group = group;\n      }\n\n      gen_counter->add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n      _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n    }\n  }\n\n  void do_cset_groups() {\n    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n\n    accumulate_stats_for_group(g1h->young_regions_cset_group(), &_young);\n\n    G1CollectionSetCandidates* candidates = g1h->policy()->candidates();\n    for (G1CSetCandidateGroup* group : candidates->from_marking_groups()) {\n      accumulate_stats_for_group(group, &_old);\n    }\n    // Skip gathering statistics for retained regions. Just verify that they have\n    // the expected amount of regions.\n    for (G1CSetCandidateGroup* group : candidates->retained_groups()) {\n      assert(group->length() == 1, \"must be\");\n    }\n  }", "target": "- void do_cset_groups() {\n    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n    G1CSetCandidateGroup* young_only_cset_group = g1h->young_regions_cset_group();\n\n    // If the group has only a single region, then stats were accumulated\n    // during region iteration.\n    if (young_only_cset_group->length() > 1) {\n      G1CardSet* young_only_card_set = young_only_cset_group->card_set();\n      size_t rs_mem_sz = young_only_card_set->mem_size();\n      size_t rs_unused_mem_sz = young_only_card_set->unused_mem_size();\n      size_t occupied_cards = young_only_card_set->occupied();\n\n      _max_group_cardset_mem_sz = rs_mem_sz;\n      _max_cardset_mem_sz_group = young_only_cset_group;\n\n      // Only update cardset details\n      _young.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n      _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n    }\n\n\n    G1PerRegionTypeRemSetCounters* current = &_old;\n    for (G1CSetCandidateGroup* group : g1h->policy()->candidates()->from_marking_groups()) {\n      if (group->length() > 1) {\n        G1CardSet* group_card_set = group->card_set();\n        size_t rs_mem_sz = group_card_set->mem_size();\n        size_t rs_unused_mem_sz = group_card_set->unused_mem_size();\n        size_t occupied_cards = group_card_set->occupied();\n\n        if (rs_mem_sz > _max_group_cardset_mem_sz) {\n          _max_group_cardset_mem_sz = rs_mem_sz;\n          _max_cardset_mem_sz_group = group;\n        }\n\n        // Only update cardset details\n        _old.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n        _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n      }\n    }\n  }\n+  void accumulate_stats_for_group(G1CSetCandidateGroup* group, G1PerRegionTypeRemSetCounters* gen_counter) {\n    // If the group has only a single region, then stats were accumulated\n    // during region iteration. Skip these.\n    if (group->length() > 1) {\n      G1CardSet* card_set = group->card_set();\n\n      size_t rs_mem_sz = card_set->mem_size();\n      size_t rs_unused_mem_sz = card_set->unused_mem_size();\n      size_t occupied_cards = card_set->occupied();\n\n      if (rs_mem_sz > _max_group_cardset_mem_sz) {\n        _max_group_cardset_mem_sz = rs_mem_sz;\n        _max_cardset_mem_sz_group = group;\n      }\n\n      gen_counter->add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n      _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n    }\n  }\n\n  void do_cset_groups() {\n    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n\n    accumulate_stats_for_group(g1h->young_regions_cset_group(), &_young);\n\n    G1CollectionSetCandidates* candidates = g1h->policy()->candidates();\n    for (G1CSetCandidateGroup* group : candidates->from_marking_groups()) {\n      accumulate_stats_for_group(group, &_old);\n    }\n    // Skip gathering statistics for retained regions. Just verify that they have\n    // the expected amount of regions.\n    for (G1CSetCandidateGroup* group : candidates->retained_groups()) {\n      assert(group->length() == 1, \"must be\");\n    }\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：do_cset_groups()函数包含大量重复代码，分别处理年轻代和老年代组的统计信息，逻辑分散且存在硬编码的计数器引用。优化后：提取公共逻辑到accumulate_stats_for_group()函数，通过参数化计数器引用消除重复代码；统一了最大内存组的更新逻辑；添加了对保留区域的验证断言。优化思路：通过代码重构提高可维护性，减少代码重复，统一内存访问模式，同时保持原有功能不变。"}
{"id": 218, "source": "riscv-dataset-excel", "optimization_type": "代码重构+逻辑简化", "optimization_description": "优化前：使用成员变量_selected_groups_cur_length跟踪增量构建状态，逻辑分散在多个函数中。优化后：移除冗余成员变量，新增selected_groups_cur_length()方法动态计算长度，将update_incremental_marker()拆分为continue_incremental_building()和stop_incremental_building()，简化状态管理。思路：通过重构减少状态维护复杂度，提高代码可读性和维护性，避免潜在的状态不一致问题。", "original_code": "使用成员变量_selected_groups_cur_length跟踪增量构建状态，逻辑分散在多个函数中。", "optimized_code": "- uint _selected_groups_cur_length;\n+ uint selected_groups_cur_length() const;\n- void update_incremental_marker() {\n-   _inc_build_state = Active;\n-   _inc_part_start = _collection_set_cur_length;\n-   _selected_groups_inc_part_start = _selected_groups_cur_length;\n- }\n+ void continue_incremental_building();\n+ void stop_incremental_building();", "source_url": "https://github.com/openjdk/riscv-port/commit/b735ef99b2285ec55a68896de25d29a02fdfcaf7", "code_v0_no_empty_lines": "使用成员变量_selected_groups_cur_length跟踪增量构建状态，逻辑分散在多个函数中。", "code_v1_no_empty_lines": "- uint _selected_groups_cur_length;\n+ uint selected_groups_cur_length() const;\n- void update_incremental_marker() {\n-   _inc_build_state = Active;\n-   _inc_part_start = _collection_set_cur_length;\n-   _selected_groups_inc_part_start = _selected_groups_cur_length;\n- }\n+ void continue_incremental_building();\n+ void stop_incremental_building();", "target": "- uint _selected_groups_cur_length;\n+ uint selected_groups_cur_length() const;\n- void update_incremental_marker() {\n-   _inc_build_state = Active;\n-   _inc_part_start = _collection_set_cur_length;\n-   _selected_groups_inc_part_start = _selected_groups_cur_length;\n- }\n+ void continue_incremental_building();\n+ void stop_incremental_building();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用成员变量_selected_groups_cur_length跟踪增量构建状态，逻辑分散在多个函数中。优化后：移除冗余成员变量，新增selected_groups_cur_length()方法动态计算长度，将update_incremental_marker()拆分为continue_incremental_building()和stop_incremental_building()，简化状态管理。思路：通过重构减少状态维护复杂度，提高代码可读性和维护性，避免潜在的状态不一致问题。"}
{"id": 219, "source": "riscv-dataset-excel", "optimization_type": "构建系统优化+向量化支持修复", "optimization_description": "优化前：条件检查错误地将CPU架构与操作系统混淆（OPENJDK_TARGET_CPU与'linux'比较），导致在AArch64 Linux平台上无法正确启用SVE向量数学运算支持。优化后：修正条件为同时检查CPU架构（aarch64）和操作系统（linux），确保在正确的平台上启用SVE向量化支持。思路：修复构建配置逻辑错误，使AArch64 Linux平台能够正确检测并启用SVE向量指令集，恢复VectorAPI的数学运算功能。", "original_code": "条件检查错误地将CPU架构与操作系统混淆（OPENJDK_TARGET_CPU与'linux'比较），导致在AArch64 Linux平台上无法正确启用SVE向量数学运算支持。", "optimized_code": "-  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_CPU\" = \"xlinux\"; then\n+  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_OS\" = \"xlinux\"; then", "source_url": "https://github.com/openjdk/riscv-port/commit/51d710e3cc8ee185a0a305e8efcfd03dda41570b", "code_v0_no_empty_lines": "条件检查错误地将CPU架构与操作系统混淆（OPENJDK_TARGET_CPU与'linux'比较），导致在AArch64 Linux平台上无法正确启用SVE向量数学运算支持。", "code_v1_no_empty_lines": "-  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_CPU\" = \"xlinux\"; then\n+  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_OS\" = \"xlinux\"; then", "target": "-  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_CPU\" = \"xlinux\"; then\n+  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_OS\" = \"xlinux\"; then", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：条件检查错误地将CPU架构与操作系统混淆（OPENJDK_TARGET_CPU与'linux'比较），导致在AArch64 Linux平台上无法正确启用SVE向量数学运算支持。优化后：修正条件为同时检查CPU架构（aarch64）和操作系统（linux），确保在正确的平台上启用SVE向量化支持。思路：修复构建配置逻辑错误，使AArch64 Linux平台能够正确检测并启用SVE向量指令集，恢复VectorAPI的数学运算功能。"}
{"id": 220, "source": "riscv-dataset-excel", "optimization_type": "指令优化+内存屏障优化", "optimization_description": "优化前：在Aarch64架构的C1编译器AtomicLong方法中，无论是否使用LSE（Load-Store Exclusive）指令，都会无条件插入dmb（内存屏障）指令。优化后：通过检查UseLSE标志，当系统支持并使用LSE指令时，跳过冗余的dmb指令插入。优化思路：LSE指令本身提供原子操作的内存排序保证，无需额外的内存屏障，移除冗余指令可减少指令开销，提升原子操作的执行效率。", "original_code": "在Aarch64架构的C1编译器AtomicLong方法中，无论是否使用LSE（Load-Store Exclusive）指令，都会无条件插入dmb（内存屏障）指令。", "optimized_code": "-  __ membar(__ AnyAny);\n+  if(!UseLSE) {\n+    __ membar(__ AnyAny);\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/95577ca97f82a5a83e86ed932c7c42b644d32cca", "code_v0_no_empty_lines": "在Aarch64架构的C1编译器AtomicLong方法中，无论是否使用LSE（Load-Store Exclusive）指令，都会无条件插入dmb（内存屏障）指令。", "code_v1_no_empty_lines": "-  __ membar(__ AnyAny);\n+  if(!UseLSE) {\n+    __ membar(__ AnyAny);\n+  }", "target": "-  __ membar(__ AnyAny);\n+  if(!UseLSE) {\n+    __ membar(__ AnyAny);\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在Aarch64架构的C1编译器AtomicLong方法中，无论是否使用LSE（Load-Store Exclusive）指令，都会无条件插入dmb（内存屏障）指令。优化后：通过检查UseLSE标志，当系统支持并使用LSE指令时，跳过冗余的dmb指令插入。优化思路：LSE指令本身提供原子操作的内存排序保证，无需额外的内存屏障，移除冗余指令可减少指令开销，提升原子操作的执行效率。"}
{"id": 221, "source": "riscv-dataset-excel", "optimization_type": "循环优化+范围检查消除(RCE)", "optimization_description": "优化前：split_thru_phi函数使用简单的wins计数器判断拆分是否有利，未区分循环入口边和回边的收益差异，导致在MemorySegment.byteSize()循环退出检查中可能阻止RCE和向量化。优化后：引入SplitThruPhiWins类跟踪不同边的收益，区分循环入口边（单次收益）和回边（每次迭代收益），通过profitable()方法更精确评估拆分收益，避免破坏循环结构而阻碍RCE。思路：优先允许回边拆分（高收益），谨慎处理入口边拆分（可能破坏循环结构），确保MemorySegment相关循环能应用RCE优化。", "original_code": "split_thru_phi函数使用简单的wins计数器判断拆分是否有利，未区分循环入口边和回边的收益差异，导致在MemorySegment.byteSize()循环退出检查中可能阻止RCE和向量化。", "optimized_code": "- int wins = 0;\n+ SplitThruPhiWins wins(region);\n- if (singleton) {\n-   wins++;\n+ if (singleton) {\n+   wins.add_win(i);\n- if (y != x) {\n-   wins++;\n+ if (y != x) {\n+   wins.add_win(i);\n- if (y) {\n-   wins++;\n+ if (y) {\n+   wins.add_win(i);\n- if (wins <= policy) {\n+ if (!wins.profitable(policy)) {", "source_url": "https://github.com/openjdk/riscv-port/commit/626bea80abf1660757a12462ebc8313ef6d41f92", "code_v0_no_empty_lines": "split_thru_phi函数使用简单的wins计数器判断拆分是否有利，未区分循环入口边和回边的收益差异，导致在MemorySegment.byteSize()循环退出检查中可能阻止RCE和向量化。", "code_v1_no_empty_lines": "- int wins = 0;\n+ SplitThruPhiWins wins(region);\n- if (singleton) {\n-   wins++;\n+ if (singleton) {\n+   wins.add_win(i);\n- if (y != x) {\n-   wins++;\n+ if (y != x) {\n+   wins.add_win(i);\n- if (y) {\n-   wins++;\n+ if (y) {\n+   wins.add_win(i);\n- if (wins <= policy) {\n+ if (!wins.profitable(policy)) {", "target": "- int wins = 0;\n+ SplitThruPhiWins wins(region);\n- if (singleton) {\n-   wins++;\n+ if (singleton) {\n+   wins.add_win(i);\n- if (y != x) {\n-   wins++;\n+ if (y != x) {\n+   wins.add_win(i);\n- if (y) {\n-   wins++;\n+ if (y) {\n+   wins.add_win(i);\n- if (wins <= policy) {\n+ if (!wins.profitable(policy)) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：split_thru_phi函数使用简单的wins计数器判断拆分是否有利，未区分循环入口边和回边的收益差异，导致在MemorySegment.byteSize()循环退出检查中可能阻止RCE和向量化。优化后：引入SplitThruPhiWins类跟踪不同边的收益，区分循环入口边（单次收益）和回边（每次迭代收益），通过profitable()方法更精确评估拆分收益，避免破坏循环结构而阻碍RCE。思路：优先允许回边拆分（高收益），谨慎处理入口边拆分（可能破坏循环结构），确保MemorySegment相关循环能应用RCE优化。"}
{"id": 222, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化+内存优化", "optimization_description": "优化前：使用列表（list）作为Klass*的中间存储结构，在处理类型集合时存在O(n)查找开销和重复项处理开销。优化后：改用集合（set）作为存储结构，利用哈希表的O(1)查找特性减少重复项处理，同时优化了内存分配策略（使用固定初始大小512，并确保大小为2的幂次）。优化思路：通过数据结构替换降低算法复杂度，减少类型集合处理时的CPU和内存开销。", "original_code": "使用列表（list）作为Klass*的中间存储结构，在处理类型集合时存在O(n)查找开销和重复项处理开销。", "optimized_code": "- static JfrResourceAreaTraceIdSet* id_set = nullptr;\n- static void prepare_for_resolution() {\n-   id_set = new JfrResourceAreaTraceIdSet(initial_size);\n- }\n+ static JfrResourceAreaTraceIdSet* resolution_set = nullptr;\n+ StackTraceBlobInstaller() : _cache(JfrOptionSet::old_object_queue_size()) {\n+   resolution_set = new JfrResourceAreaTraceIdSet(initial_set_size);\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/5856dc34c82de9f840be1dc28a9917224971491f", "code_v0_no_empty_lines": "使用列表（list）作为Klass*的中间存储结构，在处理类型集合时存在O(n)查找开销和重复项处理开销。", "code_v1_no_empty_lines": "- static JfrResourceAreaTraceIdSet* id_set = nullptr;\n- static void prepare_for_resolution() {\n-   id_set = new JfrResourceAreaTraceIdSet(initial_size);\n- }\n+ static JfrResourceAreaTraceIdSet* resolution_set = nullptr;\n+ StackTraceBlobInstaller() : _cache(JfrOptionSet::old_object_queue_size()) {\n+   resolution_set = new JfrResourceAreaTraceIdSet(initial_set_size);\n+ }", "target": "- static JfrResourceAreaTraceIdSet* id_set = nullptr;\n- static void prepare_for_resolution() {\n-   id_set = new JfrResourceAreaTraceIdSet(initial_size);\n- }\n+ static JfrResourceAreaTraceIdSet* resolution_set = nullptr;\n+ StackTraceBlobInstaller() : _cache(JfrOptionSet::old_object_queue_size()) {\n+   resolution_set = new JfrResourceAreaTraceIdSet(initial_set_size);\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用列表（list）作为Klass*的中间存储结构，在处理类型集合时存在O(n)查找开销和重复项处理开销。优化后：改用集合（set）作为存储结构，利用哈希表的O(1)查找特性减少重复项处理，同时优化了内存分配策略（使用固定初始大小512，并确保大小为2的幂次）。优化思路：通过数据结构替换降低算法复杂度，减少类型集合处理时的CPU和内存开销。"}
{"id": 223, "source": "riscv-dataset-excel", "optimization_type": "编译模式优化", "optimization_description": "优化前：在AOT最终静态归档阶段使用-Xcomp模式，每个编译请求都会阻塞等待，导致编译过程串行化，效率低下。优化后：检测到-Xcomp模式时自动切换回-Xmixed模式，允许非阻塞编译请求并行执行，所有编译完成后统一等待。优化思路：AOT汇编阶段需要提交大量非阻塞编译请求并等待完成，-Xcomp的阻塞特性与此需求冲突，切换为混合模式可充分利用并行性，显著减少测试时间。", "original_code": "在AOT最终静态归档阶段使用-Xcomp模式，每个编译请求都会阻塞等待，导致编译过程串行化，效率低下。", "optimized_code": "if (Arguments::mode() == Arguments::_comp) {\n        // AOT assembly phase submits the non-blocking compilation requests\n        // for methods collected during training run, then waits for all compilations\n        // to complete. With -Xcomp, we block for each compilation request, which is\n        // counter-productive. Switching back to mixed mode improves testing time\n        // with AOT and -Xcomp.\n        Arguments::set_mode_flags(Arguments::_mixed);\n      }", "source_url": "https://github.com/openjdk/riscv-port/commit/a65f20022080e627da4782b9b643912a9dd69335", "code_v0_no_empty_lines": "在AOT最终静态归档阶段使用-Xcomp模式，每个编译请求都会阻塞等待，导致编译过程串行化，效率低下。", "code_v1_no_empty_lines": "if (Arguments::mode() == Arguments::_comp) {\n        // AOT assembly phase submits the non-blocking compilation requests\n        // for methods collected during training run, then waits for all compilations\n        // to complete. With -Xcomp, we block for each compilation request, which is\n        // counter-productive. Switching back to mixed mode improves testing time\n        // with AOT and -Xcomp.\n        Arguments::set_mode_flags(Arguments::_mixed);\n      }", "target": "if (Arguments::mode() == Arguments::_comp) {\n        // AOT assembly phase submits the non-blocking compilation requests\n        // for methods collected during training run, then waits for all compilations\n        // to complete. With -Xcomp, we block for each compilation request, which is\n        // counter-productive. Switching back to mixed mode improves testing time\n        // with AOT and -Xcomp.\n        Arguments::set_mode_flags(Arguments::_mixed);\n      }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在AOT最终静态归档阶段使用-Xcomp模式，每个编译请求都会阻塞等待，导致编译过程串行化，效率低下。优化后：检测到-Xcomp模式时自动切换回-Xmixed模式，允许非阻塞编译请求并行执行，所有编译完成后统一等待。优化思路：AOT汇编阶段需要提交大量非阻塞编译请求并等待完成，-Xcomp的阻塞特性与此需求冲突，切换为混合模式可充分利用并行性，显著减少测试时间。"}
{"id": 224, "source": "riscv-dataset-excel", "optimization_type": "内联优化", "optimization_description": "优化前：通过独立的函数set_region_short_lived_locked()设置新生代区域状态，涉及函数调用开销。优化后：将函数内联到调用点new_mutator_alloc_region()中，直接执行原函数体操作，并调整了断言和set_region_eden()的实现。优化思路：消除函数调用开销，提升内存分配路径的性能，同时简化代码结构。", "original_code": "通过独立的函数set_region_short_lived_locked()设置新生代区域状态，涉及函数调用开销。", "optimized_code": "-void G1CollectedHeap::set_region_short_lived_locked(G1HeapRegion* hr) {\n-  _eden.add(hr);\n-  _policy->set_region_eden(hr);\n-  young_regions_cset_group()->add(hr);\n-}\n\n...\n\n-      set_region_short_lived_locked(new_alloc_region);\n-      G1HeapRegionPrinter::alloc(new_alloc_region);\n+      new_alloc_region->set_eden();\n+      _eden.add(new_alloc_region);\n+      _policy->set_region_eden(new_alloc_region);\n       _policy->remset_tracker()->update_at_allocate(new_alloc_region);\n+      // Install the group cardset.\n+      young_regions_cset_group()->add(new_alloc_region);\n+      G1HeapRegionPrinter::alloc(new_alloc_region);", "source_url": "https://github.com/openjdk/riscv-port/commit/198782c957c728ed959d1fd31e2c2ff6cd1a9bb5", "code_v0_no_empty_lines": "通过独立的函数set_region_short_lived_locked()设置新生代区域状态，涉及函数调用开销。", "code_v1_no_empty_lines": "-void G1CollectedHeap::set_region_short_lived_locked(G1HeapRegion* hr) {\n-  _eden.add(hr);\n-  _policy->set_region_eden(hr);\n-  young_regions_cset_group()->add(hr);\n-}\n\n...\n\n-      set_region_short_lived_locked(new_alloc_region);\n-      G1HeapRegionPrinter::alloc(new_alloc_region);\n+      new_alloc_region->set_eden();\n+      _eden.add(new_alloc_region);\n+      _policy->set_region_eden(new_alloc_region);\n       _policy->remset_tracker()->update_at_allocate(new_alloc_region);\n+      // Install the group cardset.\n+      young_regions_cset_group()->add(new_alloc_region);\n+      G1HeapRegionPrinter::alloc(new_alloc_region);", "target": "-void G1CollectedHeap::set_region_short_lived_locked(G1HeapRegion* hr) {\n-  _eden.add(hr);\n-  _policy->set_region_eden(hr);\n-  young_regions_cset_group()->add(hr);\n-}\n\n...\n\n-      set_region_short_lived_locked(new_alloc_region);\n-      G1HeapRegionPrinter::alloc(new_alloc_region);\n+      new_alloc_region->set_eden();\n+      _eden.add(new_alloc_region);\n+      _policy->set_region_eden(new_alloc_region);\n       _policy->remset_tracker()->update_at_allocate(new_alloc_region);\n+      // Install the group cardset.\n+      young_regions_cset_group()->add(new_alloc_region);\n+      G1HeapRegionPrinter::alloc(new_alloc_region);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：通过独立的函数set_region_short_lived_locked()设置新生代区域状态，涉及函数调用开销。优化后：将函数内联到调用点new_mutator_alloc_region()中，直接执行原函数体操作，并调整了断言和set_region_eden()的实现。优化思路：消除函数调用开销，提升内存分配路径的性能，同时简化代码结构。"}
{"id": 225, "source": "riscv-dataset-excel", "optimization_type": "数学函数优化+平台特定优化", "optimization_description": "优化前：Math.sinh函数在x86 64位平台上没有专门的优化实现，可能通过解释器或通用数学库计算，性能较低。优化后：为x86 64位平台添加了专门的sinh函数实现（stubGenerator_x86_64_sinh.cpp），通过内联汇编优化双曲正弦计算，并集成到C1编译器（JIT）的数学函数调用路径中。优化思路：利用x86平台特定的指令集和数学库优化，将Math.sinh从解释执行提升为高效的本地代码执行，显著提升数学计算性能。", "original_code": "Math.sinh函数在x86 64位平台上没有专门的优化实现，可能通过解释器或通用数学库计算，性能较低。", "optimized_code": "--- a/src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp\n+++ b/src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp\n@@ -720,8 +720,8 @@ void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {\n   if (x->id() == vmIntrinsics::_dexp || x->id() == vmIntrinsics::_dlog ||\n       x->id() == vmIntrinsics::_dpow || x->id() == vmIntrinsics::_dcos ||\n       x->id() == vmIntrinsics::_dsin || x->id() == vmIntrinsics::_dtan ||\n-      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dtanh ||\n-      x->id() == vmIntrinsics::_dcbrt\n+      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dsinh ||\n+      x->id() == vmIntrinsics::_dtanh || x->id() == vmIntrinsics::_dcbrt\n       ) {\n     do_LibmIntrinsic(x);\n     return;\n@@ -835,6 +835,12 @@ void LIRGenerator::do_LibmIntrinsic(Intrinsic* x) {\n         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtan), getThreadTemp(), result_reg, cc->args());\n       }\n       break;\n+    case vmIntrinsics::_dsinh:\n+      assert(StubRoutines::dsinh() != nullptr, \"sinh intrinsic not found\");\n+      if (StubRoutines::dsinh() != nullptr) {\n+        __ call_runtime_leaf(StubRoutines::dsinh(), getThreadTemp(), result_reg, cc->args());\n+      }\n+      break;", "source_url": "https://github.com/openjdk/riscv-port/commit/05f8a6fca87d472a80e5952ddc90d8fa6589c75c", "code_v0_no_empty_lines": "Math.sinh函数在x86 64位平台上没有专门的优化实现，可能通过解释器或通用数学库计算，性能较低。", "code_v1_no_empty_lines": "--- a/src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp\n+++ b/src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp\n@@ -720,8 +720,8 @@ void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {\n   if (x->id() == vmIntrinsics::_dexp || x->id() == vmIntrinsics::_dlog ||\n       x->id() == vmIntrinsics::_dpow || x->id() == vmIntrinsics::_dcos ||\n       x->id() == vmIntrinsics::_dsin || x->id() == vmIntrinsics::_dtan ||\n-      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dtanh ||\n-      x->id() == vmIntrinsics::_dcbrt\n+      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dsinh ||\n+      x->id() == vmIntrinsics::_dtanh || x->id() == vmIntrinsics::_dcbrt\n       ) {\n     do_LibmIntrinsic(x);\n     return;\n@@ -835,6 +835,12 @@ void LIRGenerator::do_LibmIntrinsic(Intrinsic* x) {\n         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtan), getThreadTemp(), result_reg, cc->args());\n       }\n       break;\n+    case vmIntrinsics::_dsinh:\n+      assert(StubRoutines::dsinh() != nullptr, \"sinh intrinsic not found\");\n+      if (StubRoutines::dsinh() != nullptr) {\n+        __ call_runtime_leaf(StubRoutines::dsinh(), getThreadTemp(), result_reg, cc->args());\n+      }\n+      break;", "target": "--- a/src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp\n+++ b/src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp\n@@ -720,8 +720,8 @@ void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {\n   if (x->id() == vmIntrinsics::_dexp || x->id() == vmIntrinsics::_dlog ||\n       x->id() == vmIntrinsics::_dpow || x->id() == vmIntrinsics::_dcos ||\n       x->id() == vmIntrinsics::_dsin || x->id() == vmIntrinsics::_dtan ||\n-      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dtanh ||\n-      x->id() == vmIntrinsics::_dcbrt\n+      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dsinh ||\n+      x->id() == vmIntrinsics::_dtanh || x->id() == vmIntrinsics::_dcbrt\n       ) {\n     do_LibmIntrinsic(x);\n     return;\n@@ -835,6 +835,12 @@ void LIRGenerator::do_LibmIntrinsic(Intrinsic* x) {\n         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtan), getThreadTemp(), result_reg, cc->args());\n       }\n       break;\n+    case vmIntrinsics::_dsinh:\n+      assert(StubRoutines::dsinh() != nullptr, \"sinh intrinsic not found\");\n+      if (StubRoutines::dsinh() != nullptr) {\n+        __ call_runtime_leaf(StubRoutines::dsinh(), getThreadTemp(), result_reg, cc->args());\n+      }\n+      break;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Math.sinh函数在x86 64位平台上没有专门的优化实现，可能通过解释器或通用数学库计算，性能较低。优化后：为x86 64位平台添加了专门的sinh函数实现（stubGenerator_x86_64_sinh.cpp），通过内联汇编优化双曲正弦计算，并集成到C1编译器（JIT）的数学函数调用路径中。优化思路：利用x86平台特定的指令集和数学库优化，将Math.sinh从解释执行提升为高效的本地代码执行，显著提升数学计算性能。"}
{"id": 226, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+平台适配优化", "optimization_description": "优化前：使用GlobalMemoryStatusEx获取系统可用虚拟内存，无法感知Job Object（Windows作业对象）的内存限制，可能导致进程在容器化/作业环境中超出实际允许的内存限制。优化后：优先查询Job Object信息，支持进程级和作业级内存限制，当查询失败时保守返回SIZE_MAX（无限制），并添加错误日志。优化思路：增强Windows平台下内存限制检测的准确性，特别是容器化部署场景，避免因忽略作业对象限制导致的内存分配失败或进程被终止。", "original_code": "使用GlobalMemoryStatusEx获取系统可用虚拟内存，无法感知Job Object（Windows作业对象）的内存限制，可能导致进程在容器化/作业环境中超出实际允许的内存限制。", "optimized_code": "-  MEMORYSTATUSEX ms;\n-  ms.dwLength = sizeof(ms);\n-  GlobalMemoryStatusEx(&ms);\n-  return (size_t)ms.ullAvailVirtual;\n+  JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};\n+  BOOL res = QueryInformationJobObject(nullptr, JobObjectExtendedLimitInformation, &jeli, sizeof(jeli), nullptr);\n+\n+  if (!res) {\n+    char buf[512];\n+    size_t buf_len = os::lasterror(buf, sizeof(buf));\n+    warning(\"Attempt to query job object information failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+\n+    // Conservatively assume no limit when there was an error calling QueryInformationJobObject.\n+    return SIZE_MAX;\n+  }\n+\n+  if (jeli.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_PROCESS_MEMORY) {\n+    return jeli.ProcessMemoryLimit;\n+  }\n+\n+  if (jeli.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_JOB_MEMORY) {\n+    return jeli.JobMemoryLimit;\n+  }\n+\n+  // No limit\n+  return SIZE_MAX;", "source_url": "https://github.com/openjdk/riscv-port/commit/8d529bc4f361407b0b5c3ac1e62c3be0f0b8d71c", "code_v0_no_empty_lines": "使用GlobalMemoryStatusEx获取系统可用虚拟内存，无法感知Job Object（Windows作业对象）的内存限制，可能导致进程在容器化/作业环境中超出实际允许的内存限制。", "code_v1_no_empty_lines": "-  MEMORYSTATUSEX ms;\n-  ms.dwLength = sizeof(ms);\n-  GlobalMemoryStatusEx(&ms);\n-  return (size_t)ms.ullAvailVirtual;\n+  JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};\n+  BOOL res = QueryInformationJobObject(nullptr, JobObjectExtendedLimitInformation, &jeli, sizeof(jeli), nullptr);\n+\n+  if (!res) {\n+    char buf[512];\n+    size_t buf_len = os::lasterror(buf, sizeof(buf));\n+    warning(\"Attempt to query job object information failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+\n+    // Conservatively assume no limit when there was an error calling QueryInformationJobObject.\n+    return SIZE_MAX;\n+  }\n+\n+  if (jeli.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_PROCESS_MEMORY) {\n+    return jeli.ProcessMemoryLimit;\n+  }\n+\n+  if (jeli.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_JOB_MEMORY) {\n+    return jeli.JobMemoryLimit;\n+  }\n+\n+  // No limit\n+  return SIZE_MAX;", "target": "-  MEMORYSTATUSEX ms;\n-  ms.dwLength = sizeof(ms);\n-  GlobalMemoryStatusEx(&ms);\n-  return (size_t)ms.ullAvailVirtual;\n+  JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};\n+  BOOL res = QueryInformationJobObject(nullptr, JobObjectExtendedLimitInformation, &jeli, sizeof(jeli), nullptr);\n+\n+  if (!res) {\n+    char buf[512];\n+    size_t buf_len = os::lasterror(buf, sizeof(buf));\n+    warning(\"Attempt to query job object information failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+\n+    // Conservatively assume no limit when there was an error calling QueryInformationJobObject.\n+    return SIZE_MAX;\n+  }\n+\n+  if (jeli.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_PROCESS_MEMORY) {\n+    return jeli.ProcessMemoryLimit;\n+  }\n+\n+  if (jeli.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_JOB_MEMORY) {\n+    return jeli.JobMemoryLimit;\n+  }\n+\n+  // No limit\n+  return SIZE_MAX;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用GlobalMemoryStatusEx获取系统可用虚拟内存，无法感知Job Object（Windows作业对象）的内存限制，可能导致进程在容器化/作业环境中超出实际允许的内存限制。优化后：优先查询Job Object信息，支持进程级和作业级内存限制，当查询失败时保守返回SIZE_MAX（无限制），并添加错误日志。优化思路：增强Windows平台下内存限制检测的准确性，特别是容器化部署场景，避免因忽略作业对象限制导致的内存分配失败或进程被终止。"}
{"id": 227, "source": "riscv-dataset-excel", "optimization_type": "代码重构与可维护性优化", "optimization_description": "优化前：do_cset_groups()函数包含大量重复的日志记录和内存统计代码，处理三种候选组类型（年轻、标记、保留）时存在代码冗余。优化后：将重复逻辑提取为两个辅助函数log_cset_candidate_group_add_total()和log_cset_candidate_grouplist()，主函数log_cset_candidate_groups()通过调用这些辅助函数简化逻辑。优化思路：通过代码重构消除重复，提高代码可读性和可维护性，同时保持原有功能不变。", "original_code": "do_cset_groups()函数包含大量重复的日志记录和内存统计代码，处理三种候选组类型（年轻、标记、保留）时存在代码冗余。", "optimized_code": "-void G1PrintRegionLivenessInfoClosure::do_cset_groups() {\n+void G1PrintRegionLivenessInfoClosure::log_cset_candidate_groups() {\n+void G1PrintRegionLivenessInfoClosure::log_cset_candidate_group_add_total(G1CSetCandidateGroup* group, const char* type) {\n+void G1PrintRegionLivenessInfoClosure::log_cset_candidate_grouplist(G1CSetCandidateGroupList& gl, const char* type) {\n+  log_cset_candidate_group_add_total(g1h->young_regions_cset_group(), \"Y\");\n+  log_cset_candidate_grouplist(candidates->from_marking_groups(), \"M\");\n+  log_cset_candidate_grouplist(candidates->retained_groups(), \"R\");", "source_url": "https://github.com/openjdk/riscv-port/commit/d906e45026f54fe7102e531d3753adc32ff0025c", "code_v0_no_empty_lines": "do_cset_groups()函数包含大量重复的日志记录和内存统计代码，处理三种候选组类型（年轻、标记、保留）时存在代码冗余。", "code_v1_no_empty_lines": "-void G1PrintRegionLivenessInfoClosure::do_cset_groups() {\n+void G1PrintRegionLivenessInfoClosure::log_cset_candidate_groups() {\n+void G1PrintRegionLivenessInfoClosure::log_cset_candidate_group_add_total(G1CSetCandidateGroup* group, const char* type) {\n+void G1PrintRegionLivenessInfoClosure::log_cset_candidate_grouplist(G1CSetCandidateGroupList& gl, const char* type) {\n+  log_cset_candidate_group_add_total(g1h->young_regions_cset_group(), \"Y\");\n+  log_cset_candidate_grouplist(candidates->from_marking_groups(), \"M\");\n+  log_cset_candidate_grouplist(candidates->retained_groups(), \"R\");", "target": "-void G1PrintRegionLivenessInfoClosure::do_cset_groups() {\n+void G1PrintRegionLivenessInfoClosure::log_cset_candidate_groups() {\n+void G1PrintRegionLivenessInfoClosure::log_cset_candidate_group_add_total(G1CSetCandidateGroup* group, const char* type) {\n+void G1PrintRegionLivenessInfoClosure::log_cset_candidate_grouplist(G1CSetCandidateGroupList& gl, const char* type) {\n+  log_cset_candidate_group_add_total(g1h->young_regions_cset_group(), \"Y\");\n+  log_cset_candidate_grouplist(candidates->from_marking_groups(), \"M\");\n+  log_cset_candidate_grouplist(candidates->retained_groups(), \"R\");", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：do_cset_groups()函数包含大量重复的日志记录和内存统计代码，处理三种候选组类型（年轻、标记、保留）时存在代码冗余。优化后：将重复逻辑提取为两个辅助函数log_cset_candidate_group_add_total()和log_cset_candidate_grouplist()，主函数log_cset_candidate_groups()通过调用这些辅助函数简化逻辑。优化思路：通过代码重构消除重复，提高代码可读性和可维护性，同时保持原有功能不变。"}
{"id": 228, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+常量折叠", "optimization_description": "优化前：VectorMask.fromLong() 方法在处理全真（all-true）或全假（all-false）掩码时，需要执行完整的向量转换操作，包括位操作和向量生成。优化后：通过添加 is_maskall_type() 函数检测输入长整型值是否表示全真/全假掩码，如果是则直接生成 Replicate 节点（常量广播）或 MaskAll 节点，避免不必要的位操作。优化思路：识别特殊常量模式（全0或全1掩码），用更高效的常量广播操作替代通用转换，减少运行时计算开销，提升向量掩码创建性能。", "original_code": "VectorMask.fromLong() 方法在处理全真（all-true）或全假（all-false）掩码时，需要执行完整的向量转换操作，包括位操作和向量生成。", "optimized_code": "bool VectorNode::is_maskall_type(const TypeLong* type, int vlen) {\n  assert(type != nullptr, \"type must not be null\");\n  if (!type->is_con()) {\n    return false;\n  }\n  long mask = (-1ULL >> (64 - vlen));\n  long bit  = type->get_con() & mask;\n  return bit == 0 || bit == mask;\n}\n\nNode* convertFromLongToMaskAll(PhaseGVN* phase, const TypeLong* bits_type, bool is_mask, const TypeVect* vt) {\n  uint vlen = vt->length();\n  BasicType bt = vt->element_basic_type();\n  BasicType maskall_bt = (bt == T_FLOAT) ? T_INT : (bt == T_DOUBLE) ? T_LONG : bt;\n\n  if (VectorNode::is_maskall_type(bits_type, vlen) &&\n      Matcher::match_rule_supported_vector(Op_Replicate, vlen, maskall_bt)) {\n    Node* con = nullptr;\n    jlong con_value = bits_type->get_con() == 0L ? 0L : -1L;\n    if (maskall_bt == T_LONG) {\n      con = phase->longcon(con_value);\n    } else {\n      con = phase->intcon(con_value);\n    }\n    Node* res = VectorNode::scalar2vector(con, vlen, maskall_bt, is_mask);\n    if (is_floating_point_type(bt)) {\n      res = new VectorMaskCastNode(phase->transform(res), vt);\n    }\n    return res;\n  }\n  return nullptr;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/f40381e41d1356f92546a21c0d24060f8606b9b3", "code_v0_no_empty_lines": "VectorMask.fromLong() 方法在处理全真（all-true）或全假（all-false）掩码时，需要执行完整的向量转换操作，包括位操作和向量生成。", "code_v1_no_empty_lines": "bool VectorNode::is_maskall_type(const TypeLong* type, int vlen) {\n  assert(type != nullptr, \"type must not be null\");\n  if (!type->is_con()) {\n    return false;\n  }\n  long mask = (-1ULL >> (64 - vlen));\n  long bit  = type->get_con() & mask;\n  return bit == 0 || bit == mask;\n}\n\nNode* convertFromLongToMaskAll(PhaseGVN* phase, const TypeLong* bits_type, bool is_mask, const TypeVect* vt) {\n  uint vlen = vt->length();\n  BasicType bt = vt->element_basic_type();\n  BasicType maskall_bt = (bt == T_FLOAT) ? T_INT : (bt == T_DOUBLE) ? T_LONG : bt;\n\n  if (VectorNode::is_maskall_type(bits_type, vlen) &&\n      Matcher::match_rule_supported_vector(Op_Replicate, vlen, maskall_bt)) {\n    Node* con = nullptr;\n    jlong con_value = bits_type->get_con() == 0L ? 0L : -1L;\n    if (maskall_bt == T_LONG) {\n      con = phase->longcon(con_value);\n    } else {\n      con = phase->intcon(con_value);\n    }\n    Node* res = VectorNode::scalar2vector(con, vlen, maskall_bt, is_mask);\n    if (is_floating_point_type(bt)) {\n      res = new VectorMaskCastNode(phase->transform(res), vt);\n    }\n    return res;\n  }\n  return nullptr;\n}", "target": "bool VectorNode::is_maskall_type(const TypeLong* type, int vlen) {\n  assert(type != nullptr, \"type must not be null\");\n  if (!type->is_con()) {\n    return false;\n  }\n  long mask = (-1ULL >> (64 - vlen));\n  long bit  = type->get_con() & mask;\n  return bit == 0 || bit == mask;\n}\n\nNode* convertFromLongToMaskAll(PhaseGVN* phase, const TypeLong* bits_type, bool is_mask, const TypeVect* vt) {\n  uint vlen = vt->length();\n  BasicType bt = vt->element_basic_type();\n  BasicType maskall_bt = (bt == T_FLOAT) ? T_INT : (bt == T_DOUBLE) ? T_LONG : bt;\n\n  if (VectorNode::is_maskall_type(bits_type, vlen) &&\n      Matcher::match_rule_supported_vector(Op_Replicate, vlen, maskall_bt)) {\n    Node* con = nullptr;\n    jlong con_value = bits_type->get_con() == 0L ? 0L : -1L;\n    if (maskall_bt == T_LONG) {\n      con = phase->longcon(con_value);\n    } else {\n      con = phase->intcon(con_value);\n    }\n    Node* res = VectorNode::scalar2vector(con, vlen, maskall_bt, is_mask);\n    if (is_floating_point_type(bt)) {\n      res = new VectorMaskCastNode(phase->transform(res), vt);\n    }\n    return res;\n  }\n  return nullptr;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：VectorMask.fromLong() 方法在处理全真（all-true）或全假（all-false）掩码时，需要执行完整的向量转换操作，包括位操作和向量生成。优化后：通过添加 is_maskall_type() 函数检测输入长整型值是否表示全真/全假掩码，如果是则直接生成 Replicate 节点（常量广播）或 MaskAll 节点，避免不必要的位操作。优化思路：识别特殊常量模式（全0或全1掩码），用更高效的常量广播操作替代通用转换，减少运行时计算开销，提升向量掩码创建性能。"}
{"id": 229, "source": "riscv-dataset-excel", "optimization_type": "数值解析性能优化", "optimization_description": "优化前：DigitList.getDouble()通过StringBuilder构建字符串再调用Double.parseDouble()解析，存在字符串构造和解析双重开销。优化后：直接调用新增的FloatingDecimal.parseDoubleSignlessDigits()方法，避免中间字符串构造，直接处理字符数组和指数。优化思路：减少内存分配和字符串处理开销，提升DecimalFormat解析性能。", "original_code": "DigitList.getDouble()通过StringBuilder构建字符串再调用Double.parseDouble()解析，存在字符串构造和解析双重开销。", "optimized_code": "- return Double.parseDouble(getStringBuilder()\n                .append('.')\n                .append(digits, 0, count)\n                .append('E')\n                .append(decimalAt)\n                .toString());\n+ return FloatingDecimal.parseDoubleSignlessDigits(decimalAt, digits, count);", "source_url": "https://github.com/openjdk/riscv-port/commit/d19442399c004c78bff8a5ccf7c6975c7e583a07", "code_v0_no_empty_lines": "DigitList.getDouble()通过StringBuilder构建字符串再调用Double.parseDouble()解析，存在字符串构造和解析双重开销。", "code_v1_no_empty_lines": "- return Double.parseDouble(getStringBuilder()\n                .append('.')\n                .append(digits, 0, count)\n                .append('E')\n                .append(decimalAt)\n                .toString());\n+ return FloatingDecimal.parseDoubleSignlessDigits(decimalAt, digits, count);", "target": "- return Double.parseDouble(getStringBuilder()\n                .append('.')\n                .append(digits, 0, count)\n                .append('E')\n                .append(decimalAt)\n                .toString());\n+ return FloatingDecimal.parseDoubleSignlessDigits(decimalAt, digits, count);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：DigitList.getDouble()通过StringBuilder构建字符串再调用Double.parseDouble()解析，存在字符串构造和解析双重开销。优化后：直接调用新增的FloatingDecimal.parseDoubleSignlessDigits()方法，避免中间字符串构造，直接处理字符数组和指数。优化思路：减少内存分配和字符串处理开销，提升DecimalFormat解析性能。"}
{"id": 230, "source": "riscv-dataset-excel", "optimization_type": "内存复制优化", "optimization_description": "优化前：StringBuilder.append(char[]) 使用循环逐个字符复制，每次调用 putChar 方法，效率较低。优化后：使用 Unsafe.copyMemory 进行批量内存复制，一次性复制整个字符数组，减少方法调用和循环开销。优化思路：利用底层内存操作替代逐字符复制，提升大字符数组追加性能。", "original_code": "StringBuilder.append(char[]) 使用循环逐个字符复制，每次调用 putChar 方法，效率较低。", "optimized_code": "-    private static void putChars(byte[] val, int index, char[] str, int off, int end) {\n-        while (off < end) {\n-            putChar(val, index++, str[off++]);\n-        }\n-    }\n\n     public static void putCharsSB(byte[] val, int index, char[] ca, int off, int end) {\n         checkBoundsBeginEnd(index, index + end - off, val);\n-        putChars(val, index, ca, off, end);\n+        String.checkBoundsBeginEnd(off, end, ca.length);\n+        Unsafe.getUnsafe().copyMemory(\n+                ca,\n+                Unsafe.ARRAY_CHAR_BASE_OFFSET + ((long) off << 1),\n+                val,\n+                Unsafe.ARRAY_BYTE_BASE_OFFSET + ((long) index << 1),\n+                (long) (end - off) << 1);", "source_url": "https://github.com/openjdk/riscv-port/commit/e2feff85995cf2d0b8ecc2262cf4e74b74de3e31", "code_v0_no_empty_lines": "StringBuilder.append(char[]) 使用循环逐个字符复制，每次调用 putChar 方法，效率较低。", "code_v1_no_empty_lines": "-    private static void putChars(byte[] val, int index, char[] str, int off, int end) {\n-        while (off < end) {\n-            putChar(val, index++, str[off++]);\n-        }\n-    }\n\n     public static void putCharsSB(byte[] val, int index, char[] ca, int off, int end) {\n         checkBoundsBeginEnd(index, index + end - off, val);\n-        putChars(val, index, ca, off, end);\n+        String.checkBoundsBeginEnd(off, end, ca.length);\n+        Unsafe.getUnsafe().copyMemory(\n+                ca,\n+                Unsafe.ARRAY_CHAR_BASE_OFFSET + ((long) off << 1),\n+                val,\n+                Unsafe.ARRAY_BYTE_BASE_OFFSET + ((long) index << 1),\n+                (long) (end - off) << 1);", "target": "-    private static void putChars(byte[] val, int index, char[] str, int off, int end) {\n-        while (off < end) {\n-            putChar(val, index++, str[off++]);\n-        }\n-    }\n\n     public static void putCharsSB(byte[] val, int index, char[] ca, int off, int end) {\n         checkBoundsBeginEnd(index, index + end - off, val);\n-        putChars(val, index, ca, off, end);\n+        String.checkBoundsBeginEnd(off, end, ca.length);\n+        Unsafe.getUnsafe().copyMemory(\n+                ca,\n+                Unsafe.ARRAY_CHAR_BASE_OFFSET + ((long) off << 1),\n+                val,\n+                Unsafe.ARRAY_BYTE_BASE_OFFSET + ((long) index << 1),\n+                (long) (end - off) << 1);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：StringBuilder.append(char[]) 使用循环逐个字符复制，每次调用 putChar 方法，效率较低。优化后：使用 Unsafe.copyMemory 进行批量内存复制，一次性复制整个字符数组，减少方法调用和循环开销。优化思路：利用底层内存操作替代逐字符复制，提升大字符数组追加性能。"}
{"id": 231, "source": "riscv-dataset-excel", "optimization_type": "性能优化+条件检查优化", "optimization_description": "优化前：每次调用send_event()都会创建EventZPageAllocation对象并执行commit操作，即使JFR事件未被启用也会产生对象创建和参数计算的开销。优化后：1. 在函数开始时检查EventZPageAllocation::is_enabled()，如果事件未启用则立即返回，避免不必要的对象创建和参数计算；2. 将event.commit()改为EventZPageAllocation::commit()静态调用，避免创建临时对象。优化思路：通过前置条件检查避免不必要的对象创建和计算开销，减少ZGC页面分配时的性能损耗，特别是当JFR事件未被启用时能显著提升性能。", "original_code": "每次调用send_event()都会创建EventZPageAllocation对象并执行commit操作，即使JFR事件未被启用也会产生对象创建和参数计算的开销。", "optimized_code": "-    EventZPageAllocation event;\n+    if (!EventZPageAllocation::is_enabled()) {\n+      // Event not enabled, exit early\n+      return;\n+    }\n-    event.commit(_start_timestamp,\n-                 end_timestamp,\n-                 (u8)_type,\n-                 size(),\n-                 st._total_harvested,\n-                 st._total_committed_capacity,\n-                 (unsigned)st._num_harvested_vmems,\n-                 _is_multi_partition,\n-                 successful,\n-                 _flags.non_blocking());\n+    EventZPageAllocation::commit(_start_timestamp,\n+                                 end_timestamp,\n+                                 (u8)_type,\n+                                 size(),\n+                                 st._total_harvested,\n+                                 st._total_committed_capacity,\n+                                 (unsigned)st._num_harvested_vmems,\n+                                 _is_multi_partition,\n+                                 successful,\n+                                 _flags.non_blocking());", "source_url": "https://github.com/openjdk/riscv-port/commit/b9f7caed775e86e71f7d37789cb196fb1444ef12", "code_v0_no_empty_lines": "每次调用send_event()都会创建EventZPageAllocation对象并执行commit操作，即使JFR事件未被启用也会产生对象创建和参数计算的开销。", "code_v1_no_empty_lines": "-    EventZPageAllocation event;\n+    if (!EventZPageAllocation::is_enabled()) {\n+      // Event not enabled, exit early\n+      return;\n+    }\n-    event.commit(_start_timestamp,\n-                 end_timestamp,\n-                 (u8)_type,\n-                 size(),\n-                 st._total_harvested,\n-                 st._total_committed_capacity,\n-                 (unsigned)st._num_harvested_vmems,\n-                 _is_multi_partition,\n-                 successful,\n-                 _flags.non_blocking());\n+    EventZPageAllocation::commit(_start_timestamp,\n+                                 end_timestamp,\n+                                 (u8)_type,\n+                                 size(),\n+                                 st._total_harvested,\n+                                 st._total_committed_capacity,\n+                                 (unsigned)st._num_harvested_vmems,\n+                                 _is_multi_partition,\n+                                 successful,\n+                                 _flags.non_blocking());", "target": "-    EventZPageAllocation event;\n+    if (!EventZPageAllocation::is_enabled()) {\n+      // Event not enabled, exit early\n+      return;\n+    }\n-    event.commit(_start_timestamp,\n-                 end_timestamp,\n-                 (u8)_type,\n-                 size(),\n-                 st._total_harvested,\n-                 st._total_committed_capacity,\n-                 (unsigned)st._num_harvested_vmems,\n-                 _is_multi_partition,\n-                 successful,\n-                 _flags.non_blocking());\n+    EventZPageAllocation::commit(_start_timestamp,\n+                                 end_timestamp,\n+                                 (u8)_type,\n+                                 size(),\n+                                 st._total_harvested,\n+                                 st._total_committed_capacity,\n+                                 (unsigned)st._num_harvested_vmems,\n+                                 _is_multi_partition,\n+                                 successful,\n+                                 _flags.non_blocking());", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次调用send_event()都会创建EventZPageAllocation对象并执行commit操作，即使JFR事件未被启用也会产生对象创建和参数计算的开销。优化后：1. 在函数开始时检查EventZPageAllocation::is_enabled()，如果事件未启用则立即返回，避免不必要的对象创建和参数计算；2. 将event.commit()改为EventZPageAllocation::commit()静态调用，避免创建临时对象。优化思路：通过前置条件检查避免不必要的对象创建和计算开销，减少ZGC页面分配时的性能损耗，特别是当JFR事件未被启用时能显著提升性能。"}
{"id": 232, "source": "riscv-dataset-excel", "optimization_type": "冗余代码消除", "optimization_description": "优化前：PhaseIterGVN在处理ConvX2Y->ConvY2X->ConvX2Y（如ConvD2L->ConvL2D->ConvD2L）这类三节点转换链时，由于缺少通知机制，无法将冗余的转换序列优化为单个ConvX2Y操作，导致生成不必要的中间转换指令。优化后：在PhaseIterGVN::add_users_of_use_to_worklist方法中添加了对特定冗余转换模式的检测逻辑，当检测到ConvX2Y->ConvY2X->ConvX2Y模式时，将第三个节点加入工作列表，确保后续优化阶段能将其消除。优化思路：通过增强迭代全局值编号（Iterative Global Value Numbering）的通知机制，识别并标记冗余的类型转换序列，从而消除不必要的中间转换操作，减少指令数量并提升执行效率。", "original_code": "PhaseIterGVN在处理ConvX2Y->ConvY2X->ConvX2Y（如ConvD2L->ConvL2D->ConvD2L）这类三节点转换链时，由于缺少通知机制，无法将冗余的转换序列优化为单个ConvX2Y操作，导致生成不必要的中间转换指令。", "optimized_code": "+  // Check for redundant conversion patterns:\n+  // ConvD2L->ConvL2D->ConvD2L\n+  // ConvF2I->ConvI2F->ConvF2I\n+  // ConvF2L->ConvL2F->ConvF2L\n+  // ConvI2F->ConvF2I->ConvI2F\n+  // Note: there may be other 3-nodes conversion chains that would require to be added here, but these\n+  // are the only ones that are known to trigger missed optimizations otherwise\n+  if ((n->Opcode() == Op_ConvD2L && use_op == Op_ConvL2D) ||\n+      (n->Opcode() == Op_ConvF2I && use_op == Op_ConvI2F) ||\n+      (n->Opcode() == Op_ConvF2L && use_op == Op_ConvL2F) ||\n+      (n->Opcode() == Op_ConvI2F && use_op == Op_ConvF2I)) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == n->Opcode()) {\n+        worklist.push(u);\n+      }\n+    }\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/28297411b19551dd8585165200f5f8158f3d5bb3", "code_v0_no_empty_lines": "PhaseIterGVN在处理ConvX2Y->ConvY2X->ConvX2Y（如ConvD2L->ConvL2D->ConvD2L）这类三节点转换链时，由于缺少通知机制，无法将冗余的转换序列优化为单个ConvX2Y操作，导致生成不必要的中间转换指令。", "code_v1_no_empty_lines": "+  // Check for redundant conversion patterns:\n+  // ConvD2L->ConvL2D->ConvD2L\n+  // ConvF2I->ConvI2F->ConvF2I\n+  // ConvF2L->ConvL2F->ConvF2L\n+  // ConvI2F->ConvF2I->ConvI2F\n+  // Note: there may be other 3-nodes conversion chains that would require to be added here, but these\n+  // are the only ones that are known to trigger missed optimizations otherwise\n+  if ((n->Opcode() == Op_ConvD2L && use_op == Op_ConvL2D) ||\n+      (n->Opcode() == Op_ConvF2I && use_op == Op_ConvI2F) ||\n+      (n->Opcode() == Op_ConvF2L && use_op == Op_ConvL2F) ||\n+      (n->Opcode() == Op_ConvI2F && use_op == Op_ConvF2I)) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == n->Opcode()) {\n+        worklist.push(u);\n+      }\n+    }\n+  }", "target": "+  // Check for redundant conversion patterns:\n+  // ConvD2L->ConvL2D->ConvD2L\n+  // ConvF2I->ConvI2F->ConvF2I\n+  // ConvF2L->ConvL2F->ConvF2L\n+  // ConvI2F->ConvF2I->ConvI2F\n+  // Note: there may be other 3-nodes conversion chains that would require to be added here, but these\n+  // are the only ones that are known to trigger missed optimizations otherwise\n+  if ((n->Opcode() == Op_ConvD2L && use_op == Op_ConvL2D) ||\n+      (n->Opcode() == Op_ConvF2I && use_op == Op_ConvI2F) ||\n+      (n->Opcode() == Op_ConvF2L && use_op == Op_ConvL2F) ||\n+      (n->Opcode() == Op_ConvI2F && use_op == Op_ConvF2I)) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == n->Opcode()) {\n+        worklist.push(u);\n+      }\n+    }\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PhaseIterGVN在处理ConvX2Y->ConvY2X->ConvX2Y（如ConvD2L->ConvL2D->ConvD2L）这类三节点转换链时，由于缺少通知机制，无法将冗余的转换序列优化为单个ConvX2Y操作，导致生成不必要的中间转换指令。优化后：在PhaseIterGVN::add_users_of_use_to_worklist方法中添加了对特定冗余转换模式的检测逻辑，当检测到ConvX2Y->ConvY2X->ConvX2Y模式时，将第三个节点加入工作列表，确保后续优化阶段能将其消除。优化思路：通过增强迭代全局值编号（Iterative Global Value Numbering）的通知机制，识别并标记冗余的类型转换序列，从而消除不必要的中间转换操作，减少指令数量并提升执行效率。"}
{"id": 233, "source": "riscv-dataset-excel", "optimization_type": "内联优化+代码重构", "optimization_description": "优化前：通过SerialHeap::process_roots()方法统一处理GC根扫描，该方法包含条件分支和参数传递开销。优化后：将process_roots()方法内联到调用点（defNewGeneration.cpp和serialFullGC.cpp），直接调用底层根扫描函数（如ClassLoaderDataGraph::cld_do()、Threads::oops_do()等），并移除SerialHeap.cpp/hpp中的process_roots()方法及相关代码。优化思路：消除方法调用开销，简化代码结构，使根扫描逻辑更直接、高效，减少间接层，提升GC性能。", "original_code": "通过SerialHeap::process_roots()方法统一处理GC根扫描，该方法包含条件分支和参数传递开销。", "optimized_code": "- heap->process_roots(SerialHeap::SO_ScavengeCodeCache,\n                        &root_cl,\n                        &cld_cl,\n                        &cld_cl,\n                        &code_cl);\n- _old_gen->scan_old_to_young_refs(saved_top_in_old_gen);\n+ // Starting tracing from roots, there are 4 kinds of roots in young-gc.\n+ // 1. old-to-young pointers; processing them before relocating other kinds\n+ // of roots.\n+ _old_gen->scan_old_to_young_refs();\n+ // 2. CLD; visit all (strong+weak) clds with the same closure, because we\n+ // don't perform class unloading during young-gc.\n+ ClassLoaderDataGraph::cld_do(&cld_closure);\n+ // 3. Threads stack frames and nmethods.\n+ // Only nmethods that contain pointers into-young need to be processed\n+ // during young-gc, and they are tracked in ScavengableNMethods\n+ Threads::oops_do(&oop_closure, nullptr);\n+ ScavengableNMethods::nmethods_do(&nmethod_closure);\n+ // 4. VM internal roots.\n+ OopStorageSet::strong_oops_do(&oop_closure);", "source_url": "https://github.com/openjdk/riscv-port/commit/af5932efb5e873ef3beb8b8999a5ef3fbd094ff6", "code_v0_no_empty_lines": "通过SerialHeap::process_roots()方法统一处理GC根扫描，该方法包含条件分支和参数传递开销。", "code_v1_no_empty_lines": "- heap->process_roots(SerialHeap::SO_ScavengeCodeCache,\n                        &root_cl,\n                        &cld_cl,\n                        &cld_cl,\n                        &code_cl);\n- _old_gen->scan_old_to_young_refs(saved_top_in_old_gen);\n+ // Starting tracing from roots, there are 4 kinds of roots in young-gc.\n+ // 1. old-to-young pointers; processing them before relocating other kinds\n+ // of roots.\n+ _old_gen->scan_old_to_young_refs();\n+ // 2. CLD; visit all (strong+weak) clds with the same closure, because we\n+ // don't perform class unloading during young-gc.\n+ ClassLoaderDataGraph::cld_do(&cld_closure);\n+ // 3. Threads stack frames and nmethods.\n+ // Only nmethods that contain pointers into-young need to be processed\n+ // during young-gc, and they are tracked in ScavengableNMethods\n+ Threads::oops_do(&oop_closure, nullptr);\n+ ScavengableNMethods::nmethods_do(&nmethod_closure);\n+ // 4. VM internal roots.\n+ OopStorageSet::strong_oops_do(&oop_closure);", "target": "- heap->process_roots(SerialHeap::SO_ScavengeCodeCache,\n                        &root_cl,\n                        &cld_cl,\n                        &cld_cl,\n                        &code_cl);\n- _old_gen->scan_old_to_young_refs(saved_top_in_old_gen);\n+ // Starting tracing from roots, there are 4 kinds of roots in young-gc.\n+ // 1. old-to-young pointers; processing them before relocating other kinds\n+ // of roots.\n+ _old_gen->scan_old_to_young_refs();\n+ // 2. CLD; visit all (strong+weak) clds with the same closure, because we\n+ // don't perform class unloading during young-gc.\n+ ClassLoaderDataGraph::cld_do(&cld_closure);\n+ // 3. Threads stack frames and nmethods.\n+ // Only nmethods that contain pointers into-young need to be processed\n+ // during young-gc, and they are tracked in ScavengableNMethods\n+ Threads::oops_do(&oop_closure, nullptr);\n+ ScavengableNMethods::nmethods_do(&nmethod_closure);\n+ // 4. VM internal roots.\n+ OopStorageSet::strong_oops_do(&oop_closure);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：通过SerialHeap::process_roots()方法统一处理GC根扫描，该方法包含条件分支和参数传递开销。优化后：将process_roots()方法内联到调用点（defNewGeneration.cpp和serialFullGC.cpp），直接调用底层根扫描函数（如ClassLoaderDataGraph::cld_do()、Threads::oops_do()等），并移除SerialHeap.cpp/hpp中的process_roots()方法及相关代码。优化思路：消除方法调用开销，简化代码结构，使根扫描逻辑更直接、高效，减少间接层，提升GC性能。"}
{"id": 234, "source": "riscv-dataset-excel", "optimization_type": "指令调度优化+指令合并优化", "optimization_description": "优化前：1. 使用slli+add两条指令计算数组偏移地址；2. mulw指令在加载数组元素前执行，可能导致数据依赖延迟。优化后：1. 使用shadd单条指令替代slli+add，减少指令数量；2. 将mulw指令移到数组元素加载之后，利用加载延迟隐藏乘法计算时间。优化思路：通过指令合并减少指令数，通过指令重排隐藏计算延迟，提升向量化哈希码计算的性能。", "original_code": "1. 使用slli+add两条指令计算数组偏移地址；2. mulw指令在加载数组元素前执行，可能导致数据依赖延迟。", "optimized_code": "-  slli(chunks_end, chunks, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, chunks, ary, t0, chunks_end_shift);\n-  mulw(result, result, pow31_4); // 31^^4 * h\n   arrays_hashcode_elload(t0,   Address(ary, 0 * elsize), eltype);\n   arrays_hashcode_elload(t1,   Address(ary, 1 * elsize), eltype);\n   arrays_hashcode_elload(tmp5, Address(ary, 2 * elsize), eltype);\n   arrays_hashcode_elload(tmp6, Address(ary, 3 * elsize), eltype);\n+  mulw(result, result, pow31_4); // 31^^4 * h\n-  slli(chunks_end, cnt, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, cnt, ary, t0, chunks_end_shift);", "source_url": "https://github.com/openjdk/riscv-port/commit/4189fcbac40943f3b26c3a01938837b4e4762285", "code_v0_no_empty_lines": "1. 使用slli+add两条指令计算数组偏移地址；2. mulw指令在加载数组元素前执行，可能导致数据依赖延迟。", "code_v1_no_empty_lines": "-  slli(chunks_end, chunks, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, chunks, ary, t0, chunks_end_shift);\n-  mulw(result, result, pow31_4); // 31^^4 * h\n   arrays_hashcode_elload(t0,   Address(ary, 0 * elsize), eltype);\n   arrays_hashcode_elload(t1,   Address(ary, 1 * elsize), eltype);\n   arrays_hashcode_elload(tmp5, Address(ary, 2 * elsize), eltype);\n   arrays_hashcode_elload(tmp6, Address(ary, 3 * elsize), eltype);\n+  mulw(result, result, pow31_4); // 31^^4 * h\n-  slli(chunks_end, cnt, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, cnt, ary, t0, chunks_end_shift);", "target": "-  slli(chunks_end, chunks, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, chunks, ary, t0, chunks_end_shift);\n-  mulw(result, result, pow31_4); // 31^^4 * h\n   arrays_hashcode_elload(t0,   Address(ary, 0 * elsize), eltype);\n   arrays_hashcode_elload(t1,   Address(ary, 1 * elsize), eltype);\n   arrays_hashcode_elload(tmp5, Address(ary, 2 * elsize), eltype);\n   arrays_hashcode_elload(tmp6, Address(ary, 3 * elsize), eltype);\n+  mulw(result, result, pow31_4); // 31^^4 * h\n-  slli(chunks_end, cnt, chunks_end_shift);\n-  add(chunks_end, ary, chunks_end);\n+  shadd(chunks_end, cnt, ary, t0, chunks_end_shift);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 使用slli+add两条指令计算数组偏移地址；2. mulw指令在加载数组元素前执行，可能导致数据依赖延迟。优化后：1. 使用shadd单条指令替代slli+add，减少指令数量；2. 将mulw指令移到数组元素加载之后，利用加载延迟隐藏乘法计算时间。优化思路：通过指令合并减少指令数，通过指令重排隐藏计算延迟，提升向量化哈希码计算的性能。"}
{"id": 235, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+算法优化", "optimization_description": "优化前：Parallel GC使用复杂的自适应堆大小调整策略，包含多个计数器类（gcAdaptivePolicyCounters、psGCAdaptivePolicyCounters）和GC开销检查器（gcOverheadChecker），代码冗余且维护复杂。优化后：简化堆调整启发式算法，移除不必要的中间层和监控代码，直接集成核心逻辑到主要策略类中。思路：通过代码重构减少抽象层次，消除性能计数器开销，简化堆大小决策逻辑，提高GC性能并降低维护成本。", "original_code": "Parallel GC使用复杂的自适应堆大小调整策略，包含多个计数器类（gcAdaptivePolicyCounters、psGCAdaptivePolicyCounters）和GC开销检查器（gcOverheadChecker），代码冗余且维护复杂。", "optimized_code": "- 删除gcAdaptivePolicyCounters.cpp等7个文件\n- 简化psAdaptiveSizePolicy.cpp（1006行减少到约500行）\n- 重构psYoungGen.cpp（686行大幅修改）\n- 移除gcOverheadChecker相关代码", "source_url": "https://github.com/openjdk/riscv-port/commit/ad510fb25e47098d136515c355164e5177c5b419", "code_v0_no_empty_lines": "Parallel GC使用复杂的自适应堆大小调整策略，包含多个计数器类（gcAdaptivePolicyCounters、psGCAdaptivePolicyCounters）和GC开销检查器（gcOverheadChecker），代码冗余且维护复杂。", "code_v1_no_empty_lines": "- 删除gcAdaptivePolicyCounters.cpp等7个文件\n- 简化psAdaptiveSizePolicy.cpp（1006行减少到约500行）\n- 重构psYoungGen.cpp（686行大幅修改）\n- 移除gcOverheadChecker相关代码", "target": "- 删除gcAdaptivePolicyCounters.cpp等7个文件\n- 简化psAdaptiveSizePolicy.cpp（1006行减少到约500行）\n- 重构psYoungGen.cpp（686行大幅修改）\n- 移除gcOverheadChecker相关代码", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Parallel GC使用复杂的自适应堆大小调整策略，包含多个计数器类（gcAdaptivePolicyCounters、psGCAdaptivePolicyCounters）和GC开销检查器（gcOverheadChecker），代码冗余且维护复杂。优化后：简化堆调整启发式算法，移除不必要的中间层和监控代码，直接集成核心逻辑到主要策略类中。思路：通过代码重构减少抽象层次，消除性能计数器开销，简化堆大小决策逻辑，提高GC性能并降低维护成本。"}
{"id": 236, "source": "riscv-dataset-excel", "optimization_type": "循环优化+范围检查优化", "optimization_description": "优化前：对于long类型的计数循环和范围检查，即使循环迭代次数很少，也会创建循环嵌套结构，导致额外的开销。优化后：当检测到long循环的迭代次数足够少时，不再创建循环嵌套，而是将long循环转换为单个int循环。优化思路：通过添加ShortRunningLongLoop标志控制优化行为，避免为短运行的long循环创建不必要的循环嵌套结构，减少编译开销并提高性能。", "original_code": "对于long类型的计数循环和范围检查，即使循环迭代次数很少，也会创建循环嵌套结构，导致额外的开销。", "optimized_code": "+  product(bool, ShortRunningLongLoop, true, DIAGNOSTIC,                     \\\n+          \"long counted loop/long range checks: don't create loop nest if \" \\\n+          \"loop runs for small enough number of iterations. Long loop is \" \\\n+          \"converted to a single int loop.\")                                \\\n+                                                                            \\\n+  develop(bool, StressShortRunningLongLoop, false,                          \\\n+          \"Speculate all long counted loops are short running when bounds \" \\\n+          \"are unknown even if profile data doesn't say so.\")", "source_url": "https://github.com/openjdk/riscv-port/commit/f155661151fc25cde3be17878aeb24056555961c", "code_v0_no_empty_lines": "对于long类型的计数循环和范围检查，即使循环迭代次数很少，也会创建循环嵌套结构，导致额外的开销。", "code_v1_no_empty_lines": "+  product(bool, ShortRunningLongLoop, true, DIAGNOSTIC,                     \\\n+          \"long counted loop/long range checks: don't create loop nest if \" \\\n+          \"loop runs for small enough number of iterations. Long loop is \" \\\n+          \"converted to a single int loop.\")                                \\\n+                                                                            \\\n+  develop(bool, StressShortRunningLongLoop, false,                          \\\n+          \"Speculate all long counted loops are short running when bounds \" \\\n+          \"are unknown even if profile data doesn't say so.\")", "target": "+  product(bool, ShortRunningLongLoop, true, DIAGNOSTIC,                     \\\n+          \"long counted loop/long range checks: don't create loop nest if \" \\\n+          \"loop runs for small enough number of iterations. Long loop is \" \\\n+          \"converted to a single int loop.\")                                \\\n+                                                                            \\\n+  develop(bool, StressShortRunningLongLoop, false,                          \\\n+          \"Speculate all long counted loops are short running when bounds \" \\\n+          \"are unknown even if profile data doesn't say so.\")", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于long类型的计数循环和范围检查，即使循环迭代次数很少，也会创建循环嵌套结构，导致额外的开销。优化后：当检测到long循环的迭代次数足够少时，不再创建循环嵌套，而是将long循环转换为单个int循环。优化思路：通过添加ShortRunningLongLoop标志控制优化行为，避免为短运行的long循环创建不必要的循环嵌套结构，减少编译开销并提高性能。"}
{"id": 237, "source": "riscv-dataset-excel", "optimization_type": "死代码消除+中间表示优化", "optimization_description": "优化前：C2编译器中的纯函数调用（无副作用）即使结果未被使用也会保留在IR中，导致不必要的计算开销。优化后：新增CallLeafPureNode类，在IGVN阶段检测未被使用的纯函数调用，通过将其替换为输入状态和TOP返回值的元组来安全移除。优化思路：利用纯函数的无副作用特性，当检测到其返回值未被使用时，可以安全删除调用节点，避免冗余计算，同时通过元组机制确保图变换的正确性。", "original_code": "C2编译器中的纯函数调用（无副作用）即使结果未被使用也会保留在IR中，导致不必要的计算开销。", "optimized_code": "bool CallLeafPureNode::is_unused() const {\n  return proj_out_or_null(TypeFunc::Parms) == nullptr;\n}\n\nNode* CallLeafPureNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n  if (is_dead()) {\n    return nullptr;\n  }\n\n  if (can_reshape && is_unused()) {\n    return make_tuple_of_input_state_and_top_return_values(phase->C);\n  }\n\n  return CallRuntimeNode::Ideal(phase, can_reshape);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/ed70910b0f3e1b19d915ec13ac3434407d01bc5d", "code_v0_no_empty_lines": "C2编译器中的纯函数调用（无副作用）即使结果未被使用也会保留在IR中，导致不必要的计算开销。", "code_v1_no_empty_lines": "bool CallLeafPureNode::is_unused() const {\n  return proj_out_or_null(TypeFunc::Parms) == nullptr;\n}\n\nNode* CallLeafPureNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n  if (is_dead()) {\n    return nullptr;\n  }\n\n  if (can_reshape && is_unused()) {\n    return make_tuple_of_input_state_and_top_return_values(phase->C);\n  }\n\n  return CallRuntimeNode::Ideal(phase, can_reshape);\n}", "target": "bool CallLeafPureNode::is_unused() const {\n  return proj_out_or_null(TypeFunc::Parms) == nullptr;\n}\n\nNode* CallLeafPureNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n  if (is_dead()) {\n    return nullptr;\n  }\n\n  if (can_reshape && is_unused()) {\n    return make_tuple_of_input_state_and_top_return_values(phase->C);\n  }\n\n  return CallRuntimeNode::Ideal(phase, can_reshape);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器中的纯函数调用（无副作用）即使结果未被使用也会保留在IR中，导致不必要的计算开销。优化后：新增CallLeafPureNode类，在IGVN阶段检测未被使用的纯函数调用，通过将其替换为输入状态和TOP返回值的元组来安全移除。优化思路：利用纯函数的无副作用特性，当检测到其返回值未被使用时，可以安全删除调用节点，避免冗余计算，同时通过元组机制确保图变换的正确性。"}
{"id": 238, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：最小向量长度限制为64位（8字节），对于short类型向量，无法生成32位（2S）的短向量，限制了向量转换操作的范围。优化后：放宽最小向量长度限制，允许在特定情况下生成32位（2S）的短向量，特别是支持short类型向量与int/long/float/double类型向量之间的转换。优化思路：通过修改min_vector_size函数，在switch语句中为T_SHORT类型专门设置size=2，使得编译器能够生成更短的向量，从而扩展向量API的转换支持范围，提高向量化操作的灵活性和性能。", "original_code": "最小向量长度限制为64位（8字节），对于short类型向量，无法生成32位（2S）的短向量，限制了向量转换操作的范围。", "optimized_code": "int Matcher::min_vector_size(const BasicType bt) {\n-  int max_size = max_vector_size(bt);\n-  // Limit the min vector size to 8 bytes.\n-  int size = 8 / type2aelembytes(bt);\n-  if (bt == T_BYTE) {\n-    // To support vector api shuffle/rearrange.\n-    size = 4;\n-  } else if (bt == T_BOOLEAN) {\n-    // To support vector api load/store mask.\n-    size = 2;\n+  // Usually, the shortest vector length supported by AArch64 ISA and\n+  // Vector API species is 64 bits. However, we allow 32-bit or 16-bit\n+  // vectors in a few special cases.\n+  int size;\n+  switch(bt) {\n+    case T_BOOLEAN:\n+      // Load/store a vector mask with only 2 elements for vector types\n+      // such as \"2I/2F/2L/2D\".\n+      size = 2;\n+      break;\n+    case T_BYTE:\n+      // Generate a \"4B\" vector, to support vector cast between \"8B/16B\"\n+      // and \"4S/4I/4L/4F/4D\".\n+      size = 4;\n+      break;\n+    case T_SHORT:\n+      // Generate a \"2S\" vector, to support vector cast between \"4S/8S\"\n+      // and \"2I/2L/2F/2D\".\n+      size = 2;\n+      break;\n+    default:\n+      // Limit the min vector length to 64-bit.\n+      size = 8 / type2aelembytes(bt);\n+      // The number of elements in a vector should be at least 2.\n+      size = MAX2(size, 2);\n   }\n-  if (size < 2) size = 2;\n+\n+  int max_size = max_vector_size(bt);\n   return MIN2(size, max_size);\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/ac141c2fa1d818858e7a12a50837bb282282ecac", "code_v0_no_empty_lines": "最小向量长度限制为64位（8字节），对于short类型向量，无法生成32位（2S）的短向量，限制了向量转换操作的范围。", "code_v1_no_empty_lines": "int Matcher::min_vector_size(const BasicType bt) {\n-  int max_size = max_vector_size(bt);\n-  // Limit the min vector size to 8 bytes.\n-  int size = 8 / type2aelembytes(bt);\n-  if (bt == T_BYTE) {\n-    // To support vector api shuffle/rearrange.\n-    size = 4;\n-  } else if (bt == T_BOOLEAN) {\n-    // To support vector api load/store mask.\n-    size = 2;\n+  // Usually, the shortest vector length supported by AArch64 ISA and\n+  // Vector API species is 64 bits. However, we allow 32-bit or 16-bit\n+  // vectors in a few special cases.\n+  int size;\n+  switch(bt) {\n+    case T_BOOLEAN:\n+      // Load/store a vector mask with only 2 elements for vector types\n+      // such as \"2I/2F/2L/2D\".\n+      size = 2;\n+      break;\n+    case T_BYTE:\n+      // Generate a \"4B\" vector, to support vector cast between \"8B/16B\"\n+      // and \"4S/4I/4L/4F/4D\".\n+      size = 4;\n+      break;\n+    case T_SHORT:\n+      // Generate a \"2S\" vector, to support vector cast between \"4S/8S\"\n+      // and \"2I/2L/2F/2D\".\n+      size = 2;\n+      break;\n+    default:\n+      // Limit the min vector length to 64-bit.\n+      size = 8 / type2aelembytes(bt);\n+      // The number of elements in a vector should be at least 2.\n+      size = MAX2(size, 2);\n   }\n-  if (size < 2) size = 2;\n+\n+  int max_size = max_vector_size(bt);\n   return MIN2(size, max_size);\n }", "target": "int Matcher::min_vector_size(const BasicType bt) {\n-  int max_size = max_vector_size(bt);\n-  // Limit the min vector size to 8 bytes.\n-  int size = 8 / type2aelembytes(bt);\n-  if (bt == T_BYTE) {\n-    // To support vector api shuffle/rearrange.\n-    size = 4;\n-  } else if (bt == T_BOOLEAN) {\n-    // To support vector api load/store mask.\n-    size = 2;\n+  // Usually, the shortest vector length supported by AArch64 ISA and\n+  // Vector API species is 64 bits. However, we allow 32-bit or 16-bit\n+  // vectors in a few special cases.\n+  int size;\n+  switch(bt) {\n+    case T_BOOLEAN:\n+      // Load/store a vector mask with only 2 elements for vector types\n+      // such as \"2I/2F/2L/2D\".\n+      size = 2;\n+      break;\n+    case T_BYTE:\n+      // Generate a \"4B\" vector, to support vector cast between \"8B/16B\"\n+      // and \"4S/4I/4L/4F/4D\".\n+      size = 4;\n+      break;\n+    case T_SHORT:\n+      // Generate a \"2S\" vector, to support vector cast between \"4S/8S\"\n+      // and \"2I/2L/2F/2D\".\n+      size = 2;\n+      break;\n+    default:\n+      // Limit the min vector length to 64-bit.\n+      size = 8 / type2aelembytes(bt);\n+      // The number of elements in a vector should be at least 2.\n+      size = MAX2(size, 2);\n   }\n-  if (size < 2) size = 2;\n+\n+  int max_size = max_vector_size(bt);\n   return MIN2(size, max_size);\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：最小向量长度限制为64位（8字节），对于short类型向量，无法生成32位（2S）的短向量，限制了向量转换操作的范围。优化后：放宽最小向量长度限制，允许在特定情况下生成32位（2S）的短向量，特别是支持short类型向量与int/long/float/double类型向量之间的转换。优化思路：通过修改min_vector_size函数，在switch语句中为T_SHORT类型专门设置size=2，使得编译器能够生成更短的向量，从而扩展向量API的转换支持范围，提高向量化操作的灵活性和性能。"}
{"id": 239, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（模式匹配与重排序）", "optimization_description": "优化前：PhaseIterGVN在处理AndI/AndL节点输入变化时，未通知相关的右移（RShift）节点重新评估，导致\"(x & mask) >> shift\"模式（其中mask为常量）的优化机会被错过。优化后：在add_users_of_use_to_worklist函数中添加逻辑，当AndI/AndL节点输入变化时，将其右移用户节点加入工作列表，触发模式匹配优化。优化思路：通过确保工作列表包含所有可能受影响的节点，使编译器能够将\"(x & mask) >> shift\"重排序为更高效的\"(x >> shift) & (mask >> shift)\"，减少指令依赖并可能消除冗余操作。", "original_code": "PhaseIterGVN在处理AndI/AndL节点输入变化时，未通知相关的右移（RShift）节点重新评估，导致\"(x & mask) >> shift\"模式（其中mask为常量）的优化机会被错过。", "optimized_code": "// If changed AndI/AndL inputs, check RShift users for \"(x & mask) >> shift\" optimization opportunity\nif (use_op == Op_AndI || use_op == Op_AndL) {\n  for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n    Node* u = use->fast_out(i2);\n    if (u->Opcode() == Op_RShiftI || u->Opcode() == Op_RShiftL) {\n      worklist.push(u);\n    }\n  }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/62a58062e5f3d0a723608d98d2412ea779f73897", "code_v0_no_empty_lines": "PhaseIterGVN在处理AndI/AndL节点输入变化时，未通知相关的右移（RShift）节点重新评估，导致\"(x & mask) >> shift\"模式（其中mask为常量）的优化机会被错过。", "code_v1_no_empty_lines": "// If changed AndI/AndL inputs, check RShift users for \"(x & mask) >> shift\" optimization opportunity\nif (use_op == Op_AndI || use_op == Op_AndL) {\n  for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n    Node* u = use->fast_out(i2);\n    if (u->Opcode() == Op_RShiftI || u->Opcode() == Op_RShiftL) {\n      worklist.push(u);\n    }\n  }\n}", "target": "// If changed AndI/AndL inputs, check RShift users for \"(x & mask) >> shift\" optimization opportunity\nif (use_op == Op_AndI || use_op == Op_AndL) {\n  for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n    Node* u = use->fast_out(i2);\n    if (u->Opcode() == Op_RShiftI || u->Opcode() == Op_RShiftL) {\n      worklist.push(u);\n    }\n  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PhaseIterGVN在处理AndI/AndL节点输入变化时，未通知相关的右移（RShift）节点重新评估，导致\"(x & mask) >> shift\"模式（其中mask为常量）的优化机会被错过。优化后：在add_users_of_use_to_worklist函数中添加逻辑，当AndI/AndL节点输入变化时，将其右移用户节点加入工作列表，触发模式匹配优化。优化思路：通过确保工作列表包含所有可能受影响的节点，使编译器能够将\"(x & mask) >> shift\"重排序为更高效的\"(x >> shift) & (mask >> shift)\"，减少指令依赖并可能消除冗余操作。"}
{"id": 240, "source": "riscv-dataset-excel", "optimization_type": "GC性能优化", "optimization_description": "优化前：在Parallel GC的年轻代回收（young GC）中，PSThreadRootsTaskClosure会为每个线程创建MarkingNMethodClosure并调用thread->oops_do()来遍历nmethods中的根对象，这增加了不必要的开销。优化后：通过注释说明nmethods已由ScavengableNMethods处理，因此将thread->oops_do()的第二个参数从&roots_in_nmethods改为nullptr，跳过了对每个线程nmethods的遍历。优化思路：减少冗余操作，提升年轻代GC的性能，特别是在多线程环境下，避免了重复扫描nmethods的开销。", "original_code": "在Parallel GC的年轻代回收（young GC）中，PSThreadRootsTaskClosure会为每个线程创建MarkingNMethodClosure并调用thread->oops_do()来遍历nmethods中的根对象，这增加了不必要的开销。", "optimized_code": "-    MarkingNMethodClosure roots_in_nmethods(&roots_closure, NMethodToOopClosure::FixRelocations, false /* keepalive nmethods */);\n-    thread->oops_do(&roots_closure, &roots_in_nmethods);\n+    // No need to visit nmethods, because they are handled by ScavengableNMethods.\n+    thread->oops_do(&roots_closure, nullptr);", "source_url": "https://github.com/openjdk/riscv-port/commit/bc9ece9698cf13c9df3b2282bfcae2458a767713", "code_v0_no_empty_lines": "在Parallel GC的年轻代回收（young GC）中，PSThreadRootsTaskClosure会为每个线程创建MarkingNMethodClosure并调用thread->oops_do()来遍历nmethods中的根对象，这增加了不必要的开销。", "code_v1_no_empty_lines": "-    MarkingNMethodClosure roots_in_nmethods(&roots_closure, NMethodToOopClosure::FixRelocations, false /* keepalive nmethods */);\n-    thread->oops_do(&roots_closure, &roots_in_nmethods);\n+    // No need to visit nmethods, because they are handled by ScavengableNMethods.\n+    thread->oops_do(&roots_closure, nullptr);", "target": "-    MarkingNMethodClosure roots_in_nmethods(&roots_closure, NMethodToOopClosure::FixRelocations, false /* keepalive nmethods */);\n-    thread->oops_do(&roots_closure, &roots_in_nmethods);\n+    // No need to visit nmethods, because they are handled by ScavengableNMethods.\n+    thread->oops_do(&roots_closure, nullptr);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在Parallel GC的年轻代回收（young GC）中，PSThreadRootsTaskClosure会为每个线程创建MarkingNMethodClosure并调用thread->oops_do()来遍历nmethods中的根对象，这增加了不必要的开销。优化后：通过注释说明nmethods已由ScavengableNMethods处理，因此将thread->oops_do()的第二个参数从&roots_in_nmethods改为nullptr，跳过了对每个线程nmethods的遍历。优化思路：减少冗余操作，提升年轻代GC的性能，特别是在多线程环境下，避免了重复扫描nmethods的开销。"}
{"id": 241, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化+常量折叠", "optimization_description": "优化前：类型提升后的常量在UDIV优化路径中被错误拒绝，导致无法应用常量除法优化。优化后：修改isConstantOrConstantVector函数，添加AllowTruncation参数，允许类型提升后的常量参与优化；在BuildUDIV中截断除数到目标类型。优化思路：处理类型合法化过程中常量被提升到更宽类型的情况，使常量除法优化能正确识别并应用，减少除法指令，提升代码生成质量。", "original_code": "类型提升后的常量在UDIV优化路径中被错误拒绝，导致无法应用常量除法优化。", "optimized_code": "static bool isConstantOrConstantVector(SDValue N, bool NoOpaques = false,\n                                       bool AllowTruncation = false) {\n  // ...\n  if ((AllowTruncation &&\n         Const->getAPIntValue().getActiveBits() > BitWidth) ||\n        (!AllowTruncation && Const->getAPIntValue().getBitWidth() != BitWidth))\n      return false;\n}\n\n// 在visitUDIVLike中调用时添加AllowTruncation参数\nif (isConstantOrConstantVector(N1, /*NoOpaques=*/true,\n                                 /*AllowTruncation=*/true)) {\n  // ...\n}\n\n// 在TargetLowering.cpp中截断除数\nAPInt Divisor = C->getAPIntValue().trunc(EltBits);", "source_url": "https://github.com/llvm/llvm-project/commit/c5fa1f8c4bcc097ec8336bda8ef0b0a223abc2e6", "code_v0_no_empty_lines": "类型提升后的常量在UDIV优化路径中被错误拒绝，导致无法应用常量除法优化。", "code_v1_no_empty_lines": "static bool isConstantOrConstantVector(SDValue N, bool NoOpaques = false,\n                                       bool AllowTruncation = false) {\n  // ...\n  if ((AllowTruncation &&\n         Const->getAPIntValue().getActiveBits() > BitWidth) ||\n        (!AllowTruncation && Const->getAPIntValue().getBitWidth() != BitWidth))\n      return false;\n}\n\n// 在visitUDIVLike中调用时添加AllowTruncation参数\nif (isConstantOrConstantVector(N1, /*NoOpaques=*/true,\n                                 /*AllowTruncation=*/true)) {\n  // ...\n}\n\n// 在TargetLowering.cpp中截断除数\nAPInt Divisor = C->getAPIntValue().trunc(EltBits);", "target": "static bool isConstantOrConstantVector(SDValue N, bool NoOpaques = false,\n                                       bool AllowTruncation = false) {\n  // ...\n  if ((AllowTruncation &&\n         Const->getAPIntValue().getActiveBits() > BitWidth) ||\n        (!AllowTruncation && Const->getAPIntValue().getBitWidth() != BitWidth))\n      return false;\n}\n\n// 在visitUDIVLike中调用时添加AllowTruncation参数\nif (isConstantOrConstantVector(N1, /*NoOpaques=*/true,\n                                 /*AllowTruncation=*/true)) {\n  // ...\n}\n\n// 在TargetLowering.cpp中截断除数\nAPInt Divisor = C->getAPIntValue().trunc(EltBits);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：类型提升后的常量在UDIV优化路径中被错误拒绝，导致无法应用常量除法优化。优化后：修改isConstantOrConstantVector函数，添加AllowTruncation参数，允许类型提升后的常量参与优化；在BuildUDIV中截断除数到目标类型。优化思路：处理类型合法化过程中常量被提升到更宽类型的情况，使常量除法优化能正确识别并应用，减少除法指令，提升代码生成质量。"}
{"id": 242, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+成本分析优化", "optimization_description": "优化前：在foldShuffleOfIntrinsics函数中，getShuffleCost调用缺少参数，导致成本分析不准确，特别是对于常量参数的情况无法识别为免费操作。优化后：向getShuffleCost调用传递了额外的参数（包括内在函数的操作数），使成本分析更精确，能够识别常量参数的情况为免费操作。优化思路：通过提供完整的参数信息，改进向量化变换的成本评估，避免不必要的保守优化，从而生成更高效的代码。", "original_code": "在foldShuffleOfIntrinsics函数中，getShuffleCost调用缺少参数，导致成本分析不准确，特别是对于常量参数的情况无法识别为免费操作。", "optimized_code": "-      NewCost += TTI.getShuffleCost(TargetTransformInfo::SK_PermuteTwoSrc,\n-                                    ArgTy, VecTy, OldMask, CostKind);\n+      NewCost += TTI.getShuffleCost(\n+          TargetTransformInfo::SK_PermuteTwoSrc, ArgTy, VecTy, OldMask,\n+          CostKind, 0, nullptr, {II0->getArgOperand(I), II1->getArgOperand(I)});", "source_url": "https://github.com/llvm/llvm-project/commit/c2472be3fb359e640587f84ea668c98a2d86888b", "code_v0_no_empty_lines": "在foldShuffleOfIntrinsics函数中，getShuffleCost调用缺少参数，导致成本分析不准确，特别是对于常量参数的情况无法识别为免费操作。", "code_v1_no_empty_lines": "-      NewCost += TTI.getShuffleCost(TargetTransformInfo::SK_PermuteTwoSrc,\n-                                    ArgTy, VecTy, OldMask, CostKind);\n+      NewCost += TTI.getShuffleCost(\n+          TargetTransformInfo::SK_PermuteTwoSrc, ArgTy, VecTy, OldMask,\n+          CostKind, 0, nullptr, {II0->getArgOperand(I), II1->getArgOperand(I)});", "target": "-      NewCost += TTI.getShuffleCost(TargetTransformInfo::SK_PermuteTwoSrc,\n-                                    ArgTy, VecTy, OldMask, CostKind);\n+      NewCost += TTI.getShuffleCost(\n+          TargetTransformInfo::SK_PermuteTwoSrc, ArgTy, VecTy, OldMask,\n+          CostKind, 0, nullptr, {II0->getArgOperand(I), II1->getArgOperand(I)});", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在foldShuffleOfIntrinsics函数中，getShuffleCost调用缺少参数，导致成本分析不准确，特别是对于常量参数的情况无法识别为免费操作。优化后：向getShuffleCost调用传递了额外的参数（包括内在函数的操作数），使成本分析更精确，能够识别常量参数的情况为免费操作。优化思路：通过提供完整的参数信息，改进向量化变换的成本评估，避免不必要的保守优化，从而生成更高效的代码。"}
{"id": 243, "source": "riscv-dataset-excel", "optimization_type": "代码质量优化/静态分析修复", "optimization_description": "优化前：在函数调用中对const引用参数使用std::move，这是不必要的，因为const引用不能移动，反而可能阻止编译器优化。优化后：移除对const引用参数的std::move调用，遵循C++最佳实践，避免潜在的性能误导和代码质量问题。思路：应用clang-tidy的performance-move-const-arg检查，修复代码中不必要的std::move调用，提高代码可读性和潜在编译器优化机会。", "original_code": "在函数调用中对const引用参数使用std::move，这是不必要的，因为const引用不能移动，反而可能阻止编译器优化。", "optimized_code": "-  auto loads = buildMemRefLoads(b, loc, laneId, memref, std::move(indexFn));\n+  auto loads = buildMemRefLoads(b, loc, laneId, memref, indexFn);\n-  return buildMemRefStores(b, loc, toStore, laneId, memref, std::move(indexFn));\n+  return buildMemRefStores(b, loc, toStore, laneId, memref, indexFn);", "source_url": "https://github.com/llvm/llvm-project/commit/bd4c21b3c8a897e5ca467134d26ec6d831c8087a", "code_v0_no_empty_lines": "在函数调用中对const引用参数使用std::move，这是不必要的，因为const引用不能移动，反而可能阻止编译器优化。", "code_v1_no_empty_lines": "-  auto loads = buildMemRefLoads(b, loc, laneId, memref, std::move(indexFn));\n+  auto loads = buildMemRefLoads(b, loc, laneId, memref, indexFn);\n-  return buildMemRefStores(b, loc, toStore, laneId, memref, std::move(indexFn));\n+  return buildMemRefStores(b, loc, toStore, laneId, memref, indexFn);", "target": "-  auto loads = buildMemRefLoads(b, loc, laneId, memref, std::move(indexFn));\n+  auto loads = buildMemRefLoads(b, loc, laneId, memref, indexFn);\n-  return buildMemRefStores(b, loc, toStore, laneId, memref, std::move(indexFn));\n+  return buildMemRefStores(b, loc, toStore, laneId, memref, indexFn);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在函数调用中对const引用参数使用std::move，这是不必要的，因为const引用不能移动，反而可能阻止编译器优化。优化后：移除对const引用参数的std::move调用，遵循C++最佳实践，避免潜在的性能误导和代码质量问题。思路：应用clang-tidy的performance-move-const-arg检查，修复代码中不必要的std::move调用，提高代码可读性和潜在编译器优化机会。"}
{"id": 244, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：带掩码的截断存储操作需要先执行饱和运算（如vpminsq/vpmaxsq），再执行截断存储（如vpmovqd），生成两条指令序列。优化后：在X86指令选择阶段检测到饱和截断模式时，直接生成单条饱和截断存储指令（如vpmovsqd），将饱和和截断操作合并。优化思路：利用AVX-512 BWI和VLX扩展提供的单条饱和截断存储指令，减少指令数量和执行开销，提高向量存储性能。", "original_code": "带掩码的截断存储操作需要先执行饱和运算（如vpminsq/vpmaxsq），再执行截断存储（如vpmovqd），生成两条指令序列。", "optimized_code": "if (Mst->isTruncatingStore()) {\n    if (VT.isVector() && MemVT.isVector() && VT.getScalarType().isInteger() &&\n        MemVT.getScalarType().isInteger() &&\n        VT.getVectorNumElements() == MemVT.getVectorNumElements() &&\n        Subtarget.hasBWI() && Subtarget.hasVLX()) {\n\n      SDValue SatSrc;\n      unsigned Opc;\n      if (SDValue SVal = detectSSatPattern(Value, MemVT)) {\n        SatSrc = SVal;\n        Opc = X86ISD::VMTRUNCSTORES;\n      } else if (SDValue UVal = detectUSatPattern(Value, MemVT, DAG, DL)) {\n        SatSrc = UVal;\n        Opc = X86ISD::VMTRUNCSTOREUS;\n      } else {\n        return SDValue();\n      }\n\n      SDVTList VTs = DAG.getVTList(MVT::Other);\n      SDValue Ops[] = {Mst->getChain(), SatSrc, Mst->getBasePtr(), Mask};\n      MachineMemOperand *MMO = Mst->getMemOperand();\n      return DAG.getMemIntrinsicNode(Opc, DL, VTs, Ops, MemVT, MMO);\n    }\n\n    // Otherwise don't combine if this store already truncates.\n    return SDValue();\n  }", "source_url": "https://github.com/llvm/llvm-project/commit/ec6a15f84db135186f5075e15146c7f2ec532d3a", "code_v0_no_empty_lines": "带掩码的截断存储操作需要先执行饱和运算（如vpminsq/vpmaxsq），再执行截断存储（如vpmovqd），生成两条指令序列。", "code_v1_no_empty_lines": "if (Mst->isTruncatingStore()) {\n    if (VT.isVector() && MemVT.isVector() && VT.getScalarType().isInteger() &&\n        MemVT.getScalarType().isInteger() &&\n        VT.getVectorNumElements() == MemVT.getVectorNumElements() &&\n        Subtarget.hasBWI() && Subtarget.hasVLX()) {\n\n      SDValue SatSrc;\n      unsigned Opc;\n      if (SDValue SVal = detectSSatPattern(Value, MemVT)) {\n        SatSrc = SVal;\n        Opc = X86ISD::VMTRUNCSTORES;\n      } else if (SDValue UVal = detectUSatPattern(Value, MemVT, DAG, DL)) {\n        SatSrc = UVal;\n        Opc = X86ISD::VMTRUNCSTOREUS;\n      } else {\n        return SDValue();\n      }\n\n      SDVTList VTs = DAG.getVTList(MVT::Other);\n      SDValue Ops[] = {Mst->getChain(), SatSrc, Mst->getBasePtr(), Mask};\n      MachineMemOperand *MMO = Mst->getMemOperand();\n      return DAG.getMemIntrinsicNode(Opc, DL, VTs, Ops, MemVT, MMO);\n    }\n\n    // Otherwise don't combine if this store already truncates.\n    return SDValue();\n  }", "target": "if (Mst->isTruncatingStore()) {\n    if (VT.isVector() && MemVT.isVector() && VT.getScalarType().isInteger() &&\n        MemVT.getScalarType().isInteger() &&\n        VT.getVectorNumElements() == MemVT.getVectorNumElements() &&\n        Subtarget.hasBWI() && Subtarget.hasVLX()) {\n\n      SDValue SatSrc;\n      unsigned Opc;\n      if (SDValue SVal = detectSSatPattern(Value, MemVT)) {\n        SatSrc = SVal;\n        Opc = X86ISD::VMTRUNCSTORES;\n      } else if (SDValue UVal = detectUSatPattern(Value, MemVT, DAG, DL)) {\n        SatSrc = UVal;\n        Opc = X86ISD::VMTRUNCSTOREUS;\n      } else {\n        return SDValue();\n      }\n\n      SDVTList VTs = DAG.getVTList(MVT::Other);\n      SDValue Ops[] = {Mst->getChain(), SatSrc, Mst->getBasePtr(), Mask};\n      MachineMemOperand *MMO = Mst->getMemOperand();\n      return DAG.getMemIntrinsicNode(Opc, DL, VTs, Ops, MemVT, MMO);\n    }\n\n    // Otherwise don't combine if this store already truncates.\n    return SDValue();\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：带掩码的截断存储操作需要先执行饱和运算（如vpminsq/vpmaxsq），再执行截断存储（如vpmovqd），生成两条指令序列。优化后：在X86指令选择阶段检测到饱和截断模式时，直接生成单条饱和截断存储指令（如vpmovsqd），将饱和和截断操作合并。优化思路：利用AVX-512 BWI和VLX扩展提供的单条饱和截断存储指令，减少指令数量和执行开销，提高向量存储性能。"}
{"id": 245, "source": "riscv-dataset-excel", "optimization_type": "循环优化+谓词化循环支持", "optimization_description": "优化前：OptimizeLoopTermCond只能处理ICmpInst类型的循环终止条件，无法处理谓词化循环中来自get_active_lane_mask等非比较指令的条件。优化后：将FindIVUserForCond和OptimizeMax的参数类型从ICmpInst*放宽为Instruction*，并修改条件检测逻辑以支持任意指令类型（包括extractelement指令）。优化思路：放宽类型限制，使循环强度减少优化能够处理更广泛的循环终止条件，特别是SVE等向量化架构中的谓词化循环。", "original_code": "OptimizeLoopTermCond只能处理ICmpInst类型的循环终止条件，无法处理谓词化循环中来自get_active_lane_mask等非比较指令的条件。", "optimized_code": "- bool FindIVUserForCond(ICmpInst *Cond, IVStrideUse *&CondUse);\n+ bool FindIVUserForCond(Instruction *Cond, IVStrideUse *&CondUse);\n- ICmpInst *OptimizeMax(ICmpInst *Cond, IVStrideUse* &CondUse);\n+ Instruction *OptimizeMax(ICmpInst *Cond, IVStrideUse* &CondUse);\n- if (TermBr->isUnconditional() || !isa<ICmpInst>(TermBr->getCondition()))\n+ if (!Cond)\n- ICmpInst *Cond = cast<ICmpInst>(TermBr->getCondition());\n+ if (auto *Cmp = dyn_cast<ICmpInst>(Cond))\n    Cond = OptimizeMax(Cmp, CondUse);", "source_url": "https://github.com/llvm/llvm-project/commit/ccd4e7b1ed3858c64b4667787929b939513bc929", "code_v0_no_empty_lines": "OptimizeLoopTermCond只能处理ICmpInst类型的循环终止条件，无法处理谓词化循环中来自get_active_lane_mask等非比较指令的条件。", "code_v1_no_empty_lines": "- bool FindIVUserForCond(ICmpInst *Cond, IVStrideUse *&CondUse);\n+ bool FindIVUserForCond(Instruction *Cond, IVStrideUse *&CondUse);\n- ICmpInst *OptimizeMax(ICmpInst *Cond, IVStrideUse* &CondUse);\n+ Instruction *OptimizeMax(ICmpInst *Cond, IVStrideUse* &CondUse);\n- if (TermBr->isUnconditional() || !isa<ICmpInst>(TermBr->getCondition()))\n+ if (!Cond)\n- ICmpInst *Cond = cast<ICmpInst>(TermBr->getCondition());\n+ if (auto *Cmp = dyn_cast<ICmpInst>(Cond))\n    Cond = OptimizeMax(Cmp, CondUse);", "target": "- bool FindIVUserForCond(ICmpInst *Cond, IVStrideUse *&CondUse);\n+ bool FindIVUserForCond(Instruction *Cond, IVStrideUse *&CondUse);\n- ICmpInst *OptimizeMax(ICmpInst *Cond, IVStrideUse* &CondUse);\n+ Instruction *OptimizeMax(ICmpInst *Cond, IVStrideUse* &CondUse);\n- if (TermBr->isUnconditional() || !isa<ICmpInst>(TermBr->getCondition()))\n+ if (!Cond)\n- ICmpInst *Cond = cast<ICmpInst>(TermBr->getCondition());\n+ if (auto *Cmp = dyn_cast<ICmpInst>(Cond))\n    Cond = OptimizeMax(Cmp, CondUse);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：OptimizeLoopTermCond只能处理ICmpInst类型的循环终止条件，无法处理谓词化循环中来自get_active_lane_mask等非比较指令的条件。优化后：将FindIVUserForCond和OptimizeMax的参数类型从ICmpInst*放宽为Instruction*，并修改条件检测逻辑以支持任意指令类型（包括extractelement指令）。优化思路：放宽类型限制，使循环强度减少优化能够处理更广泛的循环终止条件，特别是SVE等向量化架构中的谓词化循环。"}
{"id": 246, "source": "riscv-dataset-excel", "optimization_type": "静态分析精度优化", "optimization_description": "优化前：在计算GEP偏移量的Min/Max值时，未考虑索引类型的大小（由数据布局决定），仅使用IR中的类型，导致符号扩展/截断处理不当，引发错误的UBSan警告。优化后：在aggregatePossibleConstantValues函数中新增BitWidth参数，传递索引类型大小，确保在Min/Max比较时正确进行符号扩展或截断。思路：GEP操作将索引转换为指针索引类型的偏移量，因此需要根据数据布局中的索引类型大小来正确处理偏移量计算，避免因类型不匹配导致的静态分析错误。", "original_code": "在计算GEP偏移量的Min/Max值时，未考虑索引类型的大小（由数据布局决定），仅使用IR中的类型，导致符号扩展/截断处理不当，引发错误的UBSan警告。", "optimized_code": "-    auto OffsetRangeAnalysis = [EvalMode](Value &VOffset, APInt &Offset) {\n+    auto OffsetRangeAnalysis = [EvalMode, IdxTyBits](Value &VOffset,\n+                                                     APInt &Offset) {\n       if (auto PossibleOffset =\n-              aggregatePossibleConstantValues(&VOffset, EvalMode)) {\n+              aggregatePossibleConstantValues(&VOffset, EvalMode, IdxTyBits)) {\n         Offset = *PossibleOffset;\n         return true;\n       }", "source_url": "https://github.com/llvm/llvm-project/commit/45b697e610fd24b4114d78f9d7819fa5e9461371", "code_v0_no_empty_lines": "在计算GEP偏移量的Min/Max值时，未考虑索引类型的大小（由数据布局决定），仅使用IR中的类型，导致符号扩展/截断处理不当，引发错误的UBSan警告。", "code_v1_no_empty_lines": "-    auto OffsetRangeAnalysis = [EvalMode](Value &VOffset, APInt &Offset) {\n+    auto OffsetRangeAnalysis = [EvalMode, IdxTyBits](Value &VOffset,\n+                                                     APInt &Offset) {\n       if (auto PossibleOffset =\n-              aggregatePossibleConstantValues(&VOffset, EvalMode)) {\n+              aggregatePossibleConstantValues(&VOffset, EvalMode, IdxTyBits)) {\n         Offset = *PossibleOffset;\n         return true;\n       }", "target": "-    auto OffsetRangeAnalysis = [EvalMode](Value &VOffset, APInt &Offset) {\n+    auto OffsetRangeAnalysis = [EvalMode, IdxTyBits](Value &VOffset,\n+                                                     APInt &Offset) {\n       if (auto PossibleOffset =\n-              aggregatePossibleConstantValues(&VOffset, EvalMode)) {\n+              aggregatePossibleConstantValues(&VOffset, EvalMode, IdxTyBits)) {\n         Offset = *PossibleOffset;\n         return true;\n       }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在计算GEP偏移量的Min/Max值时，未考虑索引类型的大小（由数据布局决定），仅使用IR中的类型，导致符号扩展/截断处理不当，引发错误的UBSan警告。优化后：在aggregatePossibleConstantValues函数中新增BitWidth参数，传递索引类型大小，确保在Min/Max比较时正确进行符号扩展或截断。思路：GEP操作将索引转换为指针索引类型的偏移量，因此需要根据数据布局中的索引类型大小来正确处理偏移量计算，避免因类型不匹配导致的静态分析错误。"}
{"id": 247, "source": "riscv-dataset-excel", "optimization_type": "API重构+代码简化", "optimization_description": "优化前：getGatherScatterOpCost函数使用多个独立参数（Opcode、DataTy、Ptr、VariableMask等），参数列表冗长且维护复杂。优化后：统一使用MemIntrinsicCostAttributes对象封装所有参数，简化接口并提高代码可维护性。优化思路：遵循#168029的统一接口设计，为masked/gather-scatter/strided/expand-compress成本建模提供一致的数据结构，减少代码重复和参数传递错误。", "original_code": "getGatherScatterOpCost函数使用多个独立参数（Opcode、DataTy、Ptr、VariableMask等），参数列表冗长且维护复杂。", "optimized_code": "- InstructionCost getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,\n-                         bool VariableMask, Align Alignment,\n-                         TTI::TargetCostKind CostKind,\n-                         const Instruction *I = nullptr) const {\n+ InstructionCost getGatherScatterOpCost(const MemIntrinsicCostAttributes &MICA,\n+                         TTI::TargetCostKind CostKind) const {", "source_url": "https://github.com/llvm/llvm-project/commit/1c86f4a8f1a254a6286342a5bffb13c99168267b", "code_v0_no_empty_lines": "getGatherScatterOpCost函数使用多个独立参数（Opcode、DataTy、Ptr、VariableMask等），参数列表冗长且维护复杂。", "code_v1_no_empty_lines": "- InstructionCost getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,\n-                         bool VariableMask, Align Alignment,\n-                         TTI::TargetCostKind CostKind,\n-                         const Instruction *I = nullptr) const {\n+ InstructionCost getGatherScatterOpCost(const MemIntrinsicCostAttributes &MICA,\n+                         TTI::TargetCostKind CostKind) const {", "target": "- InstructionCost getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,\n-                         bool VariableMask, Align Alignment,\n-                         TTI::TargetCostKind CostKind,\n-                         const Instruction *I = nullptr) const {\n+ InstructionCost getGatherScatterOpCost(const MemIntrinsicCostAttributes &MICA,\n+                         TTI::TargetCostKind CostKind) const {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：getGatherScatterOpCost函数使用多个独立参数（Opcode、DataTy、Ptr、VariableMask等），参数列表冗长且维护复杂。优化后：统一使用MemIntrinsicCostAttributes对象封装所有参数，简化接口并提高代码可维护性。优化思路：遵循#168029的统一接口设计，为masked/gather-scatter/strided/expand-compress成本建模提供一致的数据结构，减少代码重复和参数传递错误。"}
{"id": 248, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：对于64位算术右移(sra)和逻辑右移(srl)操作，当移位量是32位值经过and 63掩码和零扩展(zext)时，编译器需要生成额外的掩码操作。优化后：在WebAssembly后端指令选择模式中，添加了两个新的模式匹配规则，可以直接将(sra I64, (zext (and I32, 63)))映射到SHR_S_I64指令，将(srl I64, (zext (and I32, 63)))映射到SHR_U_I64指令。优化思路：利用WebAssembly移位指令本身会隐式处理移位量低6位的特性，消除显式的and 63掩码操作，减少指令数量，提高代码生成效率。", "original_code": "对于64位算术右移(sra)和逻辑右移(srl)操作，当移位量是32位值经过and 63掩码和零扩展(zext)时，编译器需要生成额外的掩码操作。", "optimized_code": "def : Pat<(sra I64:$lhs, (zext (and I32:$rhs, 63))),\n                               (SHR_S_I64 I64:$lhs, (I64_EXTEND_U_I32 I32:$rhs))>;\n+def : Pat<(srl I64:$lhs, (zext (and I32:$rhs, 63))),\n                               (SHR_U_I64 I64:$lhs, (I64_EXTEND_U_I32 I32:$rhs))>;", "source_url": "https://github.com/llvm/llvm-project/commit/e0db7f347c0afe2f1cdf3511f2e99cf5fc8541ed", "code_v0_no_empty_lines": "对于64位算术右移(sra)和逻辑右移(srl)操作，当移位量是32位值经过and 63掩码和零扩展(zext)时，编译器需要生成额外的掩码操作。", "code_v1_no_empty_lines": "def : Pat<(sra I64:$lhs, (zext (and I32:$rhs, 63))),\n                               (SHR_S_I64 I64:$lhs, (I64_EXTEND_U_I32 I32:$rhs))>;\n+def : Pat<(srl I64:$lhs, (zext (and I32:$rhs, 63))),\n                               (SHR_U_I64 I64:$lhs, (I64_EXTEND_U_I32 I32:$rhs))>;", "target": "def : Pat<(sra I64:$lhs, (zext (and I32:$rhs, 63))),\n                               (SHR_S_I64 I64:$lhs, (I64_EXTEND_U_I32 I32:$rhs))>;\n+def : Pat<(srl I64:$lhs, (zext (and I32:$rhs, 63))),\n                               (SHR_U_I64 I64:$lhs, (I64_EXTEND_U_I32 I32:$rhs))>;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于64位算术右移(sra)和逻辑右移(srl)操作，当移位量是32位值经过and 63掩码和零扩展(zext)时，编译器需要生成额外的掩码操作。优化后：在WebAssembly后端指令选择模式中，添加了两个新的模式匹配规则，可以直接将(sra I64, (zext (and I32, 63)))映射到SHR_S_I64指令，将(srl I64, (zext (and I32, 63)))映射到SHR_U_I64指令。优化思路：利用WebAssembly移位指令本身会隐式处理移位量低6位的特性，消除显式的and 63掩码操作，减少指令数量，提高代码生成效率。"}
{"id": 249, "source": "riscv-dataset-excel", "optimization_type": "表达式规范化优化", "optimization_description": "优化前：SCEV的udiv规范化仅适用于无符号加法递归表达式（AddRecs）不溢出的情况，限制了优化范围。优化后：扩展了规范化规则，当N≤C且N和C都是2的幂时，即使AddRecs可能溢出，也能安全应用{X,+,N}/C => {(X - X%N),+,N}/C变换。优化思路：利用对齐和2的幂特性，确保在偏移范围[(X - X%N), X)内除法结果保持等价，从而允许更多表达式被规范化，提升后续优化机会。", "original_code": "SCEV的udiv规范化仅适用于无符号加法递归表达式（AddRecs）不溢出的情况，限制了优化范围。", "optimized_code": "if (StartC && !DivInt.urem(StepInt) &&\n    getZeroExtendExpr(AR, ExtTy) ==\n    getAddRecExpr(getZeroExtendExpr(AR->getStart(), ExtTy),\n                  getZeroExtendExpr(Step, ExtTy),\n                  AR->getLoop(), SCEV::FlagAnyWrap)) {\n  const APInt &StartInt = StartC->getAPInt();\n  const APInt &StartRem = StartInt.urem(StepInt);\n  if (StartRem != 0) {\n    const SCEV *NewLHS =\n        getAddRecExpr(getConstant(StartInt - StartRem), Step,\n                      AR->getLoop(), SCEV::FlagNW);\n+if (StartC && !DivInt.urem(StepInt)) {\n+  const APInt &StartInt = StartC->getAPInt();\n+  const APInt &StartRem = StartInt.urem(StepInt);\n+  bool NoWrap =\n+      getZeroExtendExpr(AR, ExtTy) ==\n+      getAddRecExpr(getZeroExtendExpr(AR->getStart(), ExtTy),\n+                    getZeroExtendExpr(Step, ExtTy), AR->getLoop(),\n+                    SCEV::FlagAnyWrap);\n+\n+  // With N <= C and both N, C as powers-of-2, the transformation\n+  // {X,+,N}/C => {(X - X%N),+,N}/C preserves division results even\n+  // if wrapping occurs, as the division results remain equivalent for\n+  // all offsets in [[(X - X%N), X).\n+  bool CanFoldWithWrap = StepInt.ule(DivInt) && // N <= C\n+                         StepInt.isPowerOf2() && DivInt.isPowerOf2();\n+  if (StartRem != 0 && (NoWrap || CanFoldWithWrap)) {\n+    const SCEV *NewLHS = getAddRecExpr(\n+        getConstant(StartInt - StartRem), Step, AR->getLoop(),\n+        NoWrap ? SCEV::FlagNW : SCEV::FlagAnyWrap);", "source_url": "https://github.com/llvm/llvm-project/commit/5d876093b72182ede3d8beb551397b7fe90faa84", "code_v0_no_empty_lines": "SCEV的udiv规范化仅适用于无符号加法递归表达式（AddRecs）不溢出的情况，限制了优化范围。", "code_v1_no_empty_lines": "if (StartC && !DivInt.urem(StepInt) &&\n    getZeroExtendExpr(AR, ExtTy) ==\n    getAddRecExpr(getZeroExtendExpr(AR->getStart(), ExtTy),\n                  getZeroExtendExpr(Step, ExtTy),\n                  AR->getLoop(), SCEV::FlagAnyWrap)) {\n  const APInt &StartInt = StartC->getAPInt();\n  const APInt &StartRem = StartInt.urem(StepInt);\n  if (StartRem != 0) {\n    const SCEV *NewLHS =\n        getAddRecExpr(getConstant(StartInt - StartRem), Step,\n                      AR->getLoop(), SCEV::FlagNW);\n+if (StartC && !DivInt.urem(StepInt)) {\n+  const APInt &StartInt = StartC->getAPInt();\n+  const APInt &StartRem = StartInt.urem(StepInt);\n+  bool NoWrap =\n+      getZeroExtendExpr(AR, ExtTy) ==\n+      getAddRecExpr(getZeroExtendExpr(AR->getStart(), ExtTy),\n+                    getZeroExtendExpr(Step, ExtTy), AR->getLoop(),\n+                    SCEV::FlagAnyWrap);\n+\n+  // With N <= C and both N, C as powers-of-2, the transformation\n+  // {X,+,N}/C => {(X - X%N),+,N}/C preserves division results even\n+  // if wrapping occurs, as the division results remain equivalent for\n+  // all offsets in [[(X - X%N), X).\n+  bool CanFoldWithWrap = StepInt.ule(DivInt) && // N <= C\n+                         StepInt.isPowerOf2() && DivInt.isPowerOf2();\n+  if (StartRem != 0 && (NoWrap || CanFoldWithWrap)) {\n+    const SCEV *NewLHS = getAddRecExpr(\n+        getConstant(StartInt - StartRem), Step, AR->getLoop(),\n+        NoWrap ? SCEV::FlagNW : SCEV::FlagAnyWrap);", "target": "if (StartC && !DivInt.urem(StepInt) &&\n    getZeroExtendExpr(AR, ExtTy) ==\n    getAddRecExpr(getZeroExtendExpr(AR->getStart(), ExtTy),\n                  getZeroExtendExpr(Step, ExtTy),\n                  AR->getLoop(), SCEV::FlagAnyWrap)) {\n  const APInt &StartInt = StartC->getAPInt();\n  const APInt &StartRem = StartInt.urem(StepInt);\n  if (StartRem != 0) {\n    const SCEV *NewLHS =\n        getAddRecExpr(getConstant(StartInt - StartRem), Step,\n                      AR->getLoop(), SCEV::FlagNW);\n+if (StartC && !DivInt.urem(StepInt)) {\n+  const APInt &StartInt = StartC->getAPInt();\n+  const APInt &StartRem = StartInt.urem(StepInt);\n+  bool NoWrap =\n+      getZeroExtendExpr(AR, ExtTy) ==\n+      getAddRecExpr(getZeroExtendExpr(AR->getStart(), ExtTy),\n+                    getZeroExtendExpr(Step, ExtTy), AR->getLoop(),\n+                    SCEV::FlagAnyWrap);\n+\n+  // With N <= C and both N, C as powers-of-2, the transformation\n+  // {X,+,N}/C => {(X - X%N),+,N}/C preserves division results even\n+  // if wrapping occurs, as the division results remain equivalent for\n+  // all offsets in [[(X - X%N), X).\n+  bool CanFoldWithWrap = StepInt.ule(DivInt) && // N <= C\n+                         StepInt.isPowerOf2() && DivInt.isPowerOf2();\n+  if (StartRem != 0 && (NoWrap || CanFoldWithWrap)) {\n+    const SCEV *NewLHS = getAddRecExpr(\n+        getConstant(StartInt - StartRem), Step, AR->getLoop(),\n+        NoWrap ? SCEV::FlagNW : SCEV::FlagAnyWrap);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SCEV的udiv规范化仅适用于无符号加法递归表达式（AddRecs）不溢出的情况，限制了优化范围。优化后：扩展了规范化规则，当N≤C且N和C都是2的幂时，即使AddRecs可能溢出，也能安全应用{X,+,N}/C => {(X - X%N),+,N}/C变换。优化思路：利用对齐和2的幂特性，确保在偏移范围[(X - X%N), X)内除法结果保持等价，从而允许更多表达式被规范化，提升后续优化机会。"}
{"id": 250, "source": "riscv-dataset-excel", "optimization_type": "算法优化+条件编译优化", "optimization_description": "优化前：静态解析算法复杂度为线性O(NumCallers + NumCallees)，但无法利用当前调用者特征推断先前高优先级调用者被跳过的原因，导致可能错过跳过某些被调用者版本的机会。\n优化后：引入MaxIFuncVersions阈值控制，当调用者和被调用者版本数均小于等于阈值时，启用昂贵的立方复杂度检查（O((NumCallers^2) x NumCallees)），通过比较特征位来推断缺失特征，从而跳过更多不兼容的被调用者版本。\n优化思路：在版本数量可控时，通过额外计算推断特征可用性信息，提高静态解析精度，减少运行时开销；通过阈值控制避免在版本过多时产生不可接受的性能开销。", "original_code": "静态解析算法复杂度为线性O(NumCallers + NumCallees)，但无法利用当前调用者特征推断先前高优先级调用者被跳过的原因，导致可能错过跳过某些被调用者版本的机会。", "optimized_code": "static cl::opt<unsigned> MaxIFuncVersions(\n    \"max-ifunc-versions\", cl::Hidden, cl::init(5),\n    cl::desc(\"Maximum number of caller/callee versions that is allowed for \"\n             \"using the expensive (cubic) static resolution algorithm.\"));\n\n// ...\n\nbool AllowExpensiveChecks = CallerIsFMV &&\n                            Callers.size() <= MaxIFuncVersions &&\n                            Callees.size() <= MaxIFuncVersions;\n\n// ...\n\nauto eliminateAvailableFeatures = [&](unsigned BestCandidate) {\n  unsigned K = 0;\n  while (K < I && BestCandidate < Callees.size()) {\n    APInt MissingBits = FeatureMask[Callers[K]] & ~CallerBits;\n    if (MissingBits.isSubsetOf(FeatureMask[Callees[BestCandidate]])) {\n      ++BestCandidate;\n      // Start over.\n      K = 0;\n    } else\n      ++K;\n  }\n  return BestCandidate;\n};\n\nunsigned BestCandidate =\n    AllowExpensiveChecks ? eliminateAvailableFeatures(J) : J;", "source_url": "https://github.com/llvm/llvm-project/commit/e88a83acde69b2fc395474c905b9a17c22f61c05", "code_v0_no_empty_lines": "静态解析算法复杂度为线性O(NumCallers + NumCallees)，但无法利用当前调用者特征推断先前高优先级调用者被跳过的原因，导致可能错过跳过某些被调用者版本的机会。", "code_v1_no_empty_lines": "static cl::opt<unsigned> MaxIFuncVersions(\n    \"max-ifunc-versions\", cl::Hidden, cl::init(5),\n    cl::desc(\"Maximum number of caller/callee versions that is allowed for \"\n             \"using the expensive (cubic) static resolution algorithm.\"));\n\n// ...\n\nbool AllowExpensiveChecks = CallerIsFMV &&\n                            Callers.size() <= MaxIFuncVersions &&\n                            Callees.size() <= MaxIFuncVersions;\n\n// ...\n\nauto eliminateAvailableFeatures = [&](unsigned BestCandidate) {\n  unsigned K = 0;\n  while (K < I && BestCandidate < Callees.size()) {\n    APInt MissingBits = FeatureMask[Callers[K]] & ~CallerBits;\n    if (MissingBits.isSubsetOf(FeatureMask[Callees[BestCandidate]])) {\n      ++BestCandidate;\n      // Start over.\n      K = 0;\n    } else\n      ++K;\n  }\n  return BestCandidate;\n};\n\nunsigned BestCandidate =\n    AllowExpensiveChecks ? eliminateAvailableFeatures(J) : J;", "target": "static cl::opt<unsigned> MaxIFuncVersions(\n    \"max-ifunc-versions\", cl::Hidden, cl::init(5),\n    cl::desc(\"Maximum number of caller/callee versions that is allowed for \"\n             \"using the expensive (cubic) static resolution algorithm.\"));\n\n// ...\n\nbool AllowExpensiveChecks = CallerIsFMV &&\n                            Callers.size() <= MaxIFuncVersions &&\n                            Callees.size() <= MaxIFuncVersions;\n\n// ...\n\nauto eliminateAvailableFeatures = [&](unsigned BestCandidate) {\n  unsigned K = 0;\n  while (K < I && BestCandidate < Callees.size()) {\n    APInt MissingBits = FeatureMask[Callers[K]] & ~CallerBits;\n    if (MissingBits.isSubsetOf(FeatureMask[Callees[BestCandidate]])) {\n      ++BestCandidate;\n      // Start over.\n      K = 0;\n    } else\n      ++K;\n  }\n  return BestCandidate;\n};\n\nunsigned BestCandidate =\n    AllowExpensiveChecks ? eliminateAvailableFeatures(J) : J;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：静态解析算法复杂度为线性O(NumCallers + NumCallees)，但无法利用当前调用者特征推断先前高优先级调用者被跳过的原因，导致可能错过跳过某些被调用者版本的机会。\n优化后：引入MaxIFuncVersions阈值控制，当调用者和被调用者版本数均小于等于阈值时，启用昂贵的立方复杂度检查（O((NumCallers^2) x NumCallees)），通过比较特征位来推断缺失特征，从而跳过更多不兼容的被调用者版本。\n优化思路：在版本数量可控时，通过额外计算推断特征可用性信息，提高静态解析精度，减少运行时开销；通过阈值控制避免在版本过多时产生不可接受的性能开销。"}
{"id": 251, "source": "riscv-dataset-excel", "optimization_type": "浮点运算语义优化", "optimization_description": "优化前：LLVM对maxnum/minnum操作中的信号NaN（sNaN）进行常量折叠和优化，会将其转换为静默NaN（qNaN）。优化后：移除了对包含sNaN的maxnum/minnum操作的优化和常量折叠支持，仅保留对qNaN的优化。优化思路：由于IEEE 754标准中sNaN处理语义存在争议，为避免过早绑定具体实现，暂时禁用相关优化以保持灵活性，同时考虑到sNaN在实际代码中很少出现，对性能影响极小。", "original_code": "LLVM对maxnum/minnum操作中的信号NaN（sNaN）进行常量折叠和优化，会将其转换为静默NaN（qNaN）。", "optimized_code": "case Intrinsic::minnum:\n+        if (Op1V.isSignaling() || Op2V.isSignaling())\n+          return nullptr;\n         return ConstantFP::get(Ty->getContext(), minnum(Op1V, Op2V));\n       case Intrinsic::maxnum:\n+        if (Op1V.isSignaling() || Op2V.isSignaling())\n+          return nullptr;\n         return ConstantFP::get(Ty->getContext(), maxnum(Op1V, Op2V));", "source_url": "https://github.com/llvm/llvm-project/commit/ea3fdc5972db7f2d459e543307af05c357f2be26", "code_v0_no_empty_lines": "LLVM对maxnum/minnum操作中的信号NaN（sNaN）进行常量折叠和优化，会将其转换为静默NaN（qNaN）。", "code_v1_no_empty_lines": "case Intrinsic::minnum:\n+        if (Op1V.isSignaling() || Op2V.isSignaling())\n+          return nullptr;\n         return ConstantFP::get(Ty->getContext(), minnum(Op1V, Op2V));\n       case Intrinsic::maxnum:\n+        if (Op1V.isSignaling() || Op2V.isSignaling())\n+          return nullptr;\n         return ConstantFP::get(Ty->getContext(), maxnum(Op1V, Op2V));", "target": "case Intrinsic::minnum:\n+        if (Op1V.isSignaling() || Op2V.isSignaling())\n+          return nullptr;\n         return ConstantFP::get(Ty->getContext(), minnum(Op1V, Op2V));\n       case Intrinsic::maxnum:\n+        if (Op1V.isSignaling() || Op2V.isSignaling())\n+          return nullptr;\n         return ConstantFP::get(Ty->getContext(), maxnum(Op1V, Op2V));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：LLVM对maxnum/minnum操作中的信号NaN（sNaN）进行常量折叠和优化，会将其转换为静默NaN（qNaN）。优化后：移除了对包含sNaN的maxnum/minnum操作的优化和常量折叠支持，仅保留对qNaN的优化。优化思路：由于IEEE 754标准中sNaN处理语义存在争议，为避免过早绑定具体实现，暂时禁用相关优化以保持灵活性，同时考虑到sNaN在实际代码中很少出现，对性能影响极小。"}
{"id": 252, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：当AnyOf归约（vector.reduce.or）被规范化为掩码向量到整数的位转换时，如果标量结果小于被选择向量的元素大小，会导致标量化代码生成。优化后：在performSelectCombine中添加检查，避免在合法化前创建向量长度不匹配的向量，确保生成更优的向量指令而非标量化代码。思路：通过调整DAG组合逻辑，在特定条件下提前退出优化，防止生成低效的标量化代码。", "original_code": "当AnyOf归约（vector.reduce.or）被规范化为掩码向量到整数的位转换时，如果标量结果小于被选择向量的元素大小，会导致标量化代码生成。", "optimized_code": "- int NumMaskElts = ResVT.getSizeInBits() / SrcVT.getSizeInBits();\n+ unsigned NumMaskElts = ResVT.getSizeInBits() / SrcVT.getSizeInBits();\n+ // Avoid creating vectors with excessive VFs before legalization.\n+ if (DCI.isBeforeLegalize() && NumMaskElts != ResVT.getVectorNumElements())\n+   return SDValue();", "source_url": "https://github.com/llvm/llvm-project/commit/0e6d6127d43d6589408d5eed9b73c40238b6e741", "code_v0_no_empty_lines": "当AnyOf归约（vector.reduce.or）被规范化为掩码向量到整数的位转换时，如果标量结果小于被选择向量的元素大小，会导致标量化代码生成。", "code_v1_no_empty_lines": "- int NumMaskElts = ResVT.getSizeInBits() / SrcVT.getSizeInBits();\n+ unsigned NumMaskElts = ResVT.getSizeInBits() / SrcVT.getSizeInBits();\n+ // Avoid creating vectors with excessive VFs before legalization.\n+ if (DCI.isBeforeLegalize() && NumMaskElts != ResVT.getVectorNumElements())\n+   return SDValue();", "target": "- int NumMaskElts = ResVT.getSizeInBits() / SrcVT.getSizeInBits();\n+ unsigned NumMaskElts = ResVT.getSizeInBits() / SrcVT.getSizeInBits();\n+ // Avoid creating vectors with excessive VFs before legalization.\n+ if (DCI.isBeforeLegalize() && NumMaskElts != ResVT.getVectorNumElements())\n+   return SDValue();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当AnyOf归约（vector.reduce.or）被规范化为掩码向量到整数的位转换时，如果标量结果小于被选择向量的元素大小，会导致标量化代码生成。优化后：在performSelectCombine中添加检查，避免在合法化前创建向量长度不匹配的向量，确保生成更优的向量指令而非标量化代码。思路：通过调整DAG组合逻辑，在特定条件下提前退出优化，防止生成低效的标量化代码。"}
{"id": 253, "source": "riscv-dataset-excel", "optimization_type": "循环优化", "optimization_description": "优化前：强制展开小循环的阈值硬编码为12，无法根据具体场景调整。优化后：引入命令行参数arm-force-unroll-threshold控制阈值，默认值保持12。优化思路：提供运行时配置能力，允许开发者根据实际性能需求调整循环展开策略，平衡代码大小与执行效率。", "original_code": "强制展开小循环的阈值硬编码为12，无法根据具体场景调整。", "optimized_code": "-  if (Cost < 12)\n+  if (Cost < ArmForceUnrollThreshold)", "source_url": "https://github.com/llvm/llvm-project/commit/34c699246d9d2ad0e09306d4faed6e8d7ec87aa5", "code_v0_no_empty_lines": "强制展开小循环的阈值硬编码为12，无法根据具体场景调整。", "code_v1_no_empty_lines": "-  if (Cost < 12)\n+  if (Cost < ArmForceUnrollThreshold)", "target": "-  if (Cost < 12)\n+  if (Cost < ArmForceUnrollThreshold)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：强制展开小循环的阈值硬编码为12，无法根据具体场景调整。优化后：引入命令行参数arm-force-unroll-threshold控制阈值，默认值保持12。优化思路：提供运行时配置能力，允许开发者根据实际性能需求调整循环展开策略，平衡代码大小与执行效率。"}
{"id": 254, "source": "riscv-dataset-excel", "optimization_type": "算法优化", "optimization_description": "优化前：使用List.indexOf查找组件索引，然后通过索引调用remove(index)删除元素，需要两次遍历操作（indexOf遍历查找，remove内部可能涉及数组复制）。优化后：直接调用List.remove(Object)方法，只需一次遍历查找并删除，减少了不必要的索引查找开销。思路：利用List接口的remove(Object)方法直接删除元素，避免额外的索引查找操作，提高移除无效组件时的性能。", "original_code": "使用List.indexOf查找组件索引，然后通过索引调用remove(index)删除元素，需要两次遍历操作（indexOf遍历查找，remove内部可能涉及数组复制）。", "optimized_code": "-        if(invalidComponents != null) {\n-            int index = invalidComponents.indexOf(component);\n-            if(index != -1) {\n-                invalidComponents.remove(index);\n-            }\n+        if (invalidComponents != null) {\n+            invalidComponents.remove(component);\n         }", "source_url": "https://github.com/openjdk/riscv-port/commit/20b5f097773043068ce732e0fa30c2726273e40a", "code_v0_no_empty_lines": "使用List.indexOf查找组件索引，然后通过索引调用remove(index)删除元素，需要两次遍历操作（indexOf遍历查找，remove内部可能涉及数组复制）。", "code_v1_no_empty_lines": "-        if(invalidComponents != null) {\n-            int index = invalidComponents.indexOf(component);\n-            if(index != -1) {\n-                invalidComponents.remove(index);\n-            }\n+        if (invalidComponents != null) {\n+            invalidComponents.remove(component);\n         }", "target": "-        if(invalidComponents != null) {\n-            int index = invalidComponents.indexOf(component);\n-            if(index != -1) {\n-                invalidComponents.remove(index);\n-            }\n+        if (invalidComponents != null) {\n+            invalidComponents.remove(component);\n         }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用List.indexOf查找组件索引，然后通过索引调用remove(index)删除元素，需要两次遍历操作（indexOf遍历查找，remove内部可能涉及数组复制）。优化后：直接调用List.remove(Object)方法，只需一次遍历查找并删除，减少了不必要的索引查找开销。思路：利用List接口的remove(Object)方法直接删除元素，避免额外的索引查找操作，提高移除无效组件时的性能。"}
{"id": 255, "source": "riscv-dataset-excel", "optimization_type": "测试代码重构+锁范围优化", "optimization_description": "优化前：每个测试方法中锁的声明位置不一致，且清理操作（remove_all）分散在方法之间，可能导致测试间的状态污染。优化后：统一将锁声明移至rtree获取之后，确保锁覆盖整个测试操作；将rtree->tree().remove_all()移到每个测试方法末尾，确保测试独立性。思路：通过重构测试代码结构，确保NMT虚拟内存跟踪器测试的线程安全性和测试隔离性。", "original_code": "每个测试方法中锁的声明位置不一致，且清理操作（remove_all）分散在方法之间，可能导致测试间的状态污染。", "optimized_code": "-    MemTracker::NmtVirtualMemoryLocker nvml;\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    ReservedMemoryRegion rmr = rtree->find_reserved_region(addr);", "source_url": "https://github.com/openjdk/riscv-port/commit/10ae6029444c1381f7b1b3dcb6b6f32a4ae57efa", "code_v0_no_empty_lines": "每个测试方法中锁的声明位置不一致，且清理操作（remove_all）分散在方法之间，可能导致测试间的状态污染。", "code_v1_no_empty_lines": "-    MemTracker::NmtVirtualMemoryLocker nvml;\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    ReservedMemoryRegion rmr = rtree->find_reserved_region(addr);", "target": "-    MemTracker::NmtVirtualMemoryLocker nvml;\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    ReservedMemoryRegion rmr = rtree->find_reserved_region(addr);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每个测试方法中锁的声明位置不一致，且清理操作（remove_all）分散在方法之间，可能导致测试间的状态污染。优化后：统一将锁声明移至rtree获取之后，确保锁覆盖整个测试操作；将rtree->tree().remove_all()移到每个测试方法末尾，确保测试独立性。思路：通过重构测试代码结构，确保NMT虚拟内存跟踪器测试的线程安全性和测试隔离性。"}
{"id": 256, "source": "riscv-dataset-excel", "optimization_type": "代码清理与简化", "optimization_description": "优化前：使用int类型表示布尔状态，需要与0/1比较，代码不够直观；构造函数和成员变量声明分离；work()方法中有不必要的ResourceMark。优化后：使用bool类型直接表示布尔状态，简化原子操作比较逻辑；合并构造函数和成员变量声明；移除不必要的ResourceMark。思路：通过使用更合适的类型和简化代码结构，提高代码可读性和维护性，同时移除不必要的资源管理开销。", "original_code": "使用int类型表示布尔状态，需要与0/1比较，代码不够直观；构造函数和成员变量声明分离；work()方法中有不必要的ResourceMark。", "optimized_code": "- volatile int                            _clean_klass_tree_claimed;\n+ volatile bool _clean_klass_tree_claimed;\n-  return Atomic::cmpxchg(&_clean_klass_tree_claimed, 0, 1) == 0;\n+  return !Atomic::cmpxchg(&_clean_klass_tree_claimed, false, true);\n-  ResourceMark rm;", "source_url": "https://github.com/openjdk/riscv-port/commit/fd2ee0844a8b96491787c318f2eb6fe4d8fd75c2", "code_v0_no_empty_lines": "使用int类型表示布尔状态，需要与0/1比较，代码不够直观；构造函数和成员变量声明分离；work()方法中有不必要的ResourceMark。", "code_v1_no_empty_lines": "- volatile int                            _clean_klass_tree_claimed;\n+ volatile bool _clean_klass_tree_claimed;\n-  return Atomic::cmpxchg(&_clean_klass_tree_claimed, 0, 1) == 0;\n+  return !Atomic::cmpxchg(&_clean_klass_tree_claimed, false, true);\n-  ResourceMark rm;", "target": "- volatile int                            _clean_klass_tree_claimed;\n+ volatile bool _clean_klass_tree_claimed;\n-  return Atomic::cmpxchg(&_clean_klass_tree_claimed, 0, 1) == 0;\n+  return !Atomic::cmpxchg(&_clean_klass_tree_claimed, false, true);\n-  ResourceMark rm;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用int类型表示布尔状态，需要与0/1比较，代码不够直观；构造函数和成员变量声明分离；work()方法中有不必要的ResourceMark。优化后：使用bool类型直接表示布尔状态，简化原子操作比较逻辑；合并构造函数和成员变量声明；移除不必要的ResourceMark。思路：通过使用更合适的类型和简化代码结构，提高代码可读性和维护性，同时移除不必要的资源管理开销。"}
{"id": 257, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：min_vector_size函数对所有类型采用统一的8字节最小向量长度限制，仅对T_BYTE和T_BOOLEAN类型有特殊处理，导致短向量类型（如T_SHORT）无法生成更小的向量（如2元素向量）。\n优化后：通过switch-case结构为T_BOOLEAN、T_BYTE和T_SHORT类型分别设置更小的最小向量长度（2或4元素），其他类型保持64位最小长度但确保至少2个元素。\n优化思路：放宽RISC-V架构上短向量的最小长度限制，从固定的8字节放宽到32位（4字节），使编译器能够为短向量类型生成更小的向量（如2S、4B），从而支持更多向量类型之间的转换操作，提升向量API的灵活性和性能。", "original_code": "min_vector_size函数对所有类型采用统一的8字节最小向量长度限制，仅对T_BYTE和T_BOOLEAN类型有特殊处理，导致短向量类型（如T_SHORT）无法生成更小的向量（如2元素向量）。", "optimized_code": "int Matcher::min_vector_size(const BasicType bt) {\n-  int max_size = max_vector_size(bt);\n-  // Limit the min vector size to 8 bytes.\n-  int size = 8 / type2aelembytes(bt);\n-  if (bt == T_BYTE) {\n-    // To support vector api shuffle/rearrange.\n-    size = 4;\n-  } else if (bt == T_BOOLEAN) {\n-    // To support vector api load/store mask.\n-    size = 2;\n-  }\n-  if (size < 2) size = 2;\n+  int size;\n+  switch(bt) {\n+    case T_BOOLEAN:\n+      // Load/store a vector mask with only 2 elements for vector types\n+      // such as \"2I/2F/2L/2D\".\n+      size = 2;\n+      break;\n+    case T_BYTE:\n+      // Generate a \"4B\" vector, to support vector cast between \"8B/16B\"\n+      // and \"4S/4I/4L/4F/4D\".\n+      size = 4;\n+      break;\n+    case T_SHORT:\n+      // Generate a \"2S\" vector, to support vector cast between \"4S/8S\"\n+      // and \"2I/2L/2F/2D\".\n+      size = 2;\n+      break;\n+    default:\n+      // Limit the min vector length to 64-bit.\n+      size = 8 / type2aelembytes(bt);\n+      // The number of elements in a vector should be at least 2.\n+      size = MAX2(size, 2);\n+  }\n+\n+  int max_size = max_vector_size(bt);\n   return MIN2(size, max_size);\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/bdd37b0e5eaa984e2ad2e9010af37dcd612cc05e", "code_v0_no_empty_lines": "min_vector_size函数对所有类型采用统一的8字节最小向量长度限制，仅对T_BYTE和T_BOOLEAN类型有特殊处理，导致短向量类型（如T_SHORT）无法生成更小的向量（如2元素向量）。", "code_v1_no_empty_lines": "int Matcher::min_vector_size(const BasicType bt) {\n-  int max_size = max_vector_size(bt);\n-  // Limit the min vector size to 8 bytes.\n-  int size = 8 / type2aelembytes(bt);\n-  if (bt == T_BYTE) {\n-    // To support vector api shuffle/rearrange.\n-    size = 4;\n-  } else if (bt == T_BOOLEAN) {\n-    // To support vector api load/store mask.\n-    size = 2;\n-  }\n-  if (size < 2) size = 2;\n+  int size;\n+  switch(bt) {\n+    case T_BOOLEAN:\n+      // Load/store a vector mask with only 2 elements for vector types\n+      // such as \"2I/2F/2L/2D\".\n+      size = 2;\n+      break;\n+    case T_BYTE:\n+      // Generate a \"4B\" vector, to support vector cast between \"8B/16B\"\n+      // and \"4S/4I/4L/4F/4D\".\n+      size = 4;\n+      break;\n+    case T_SHORT:\n+      // Generate a \"2S\" vector, to support vector cast between \"4S/8S\"\n+      // and \"2I/2L/2F/2D\".\n+      size = 2;\n+      break;\n+    default:\n+      // Limit the min vector length to 64-bit.\n+      size = 8 / type2aelembytes(bt);\n+      // The number of elements in a vector should be at least 2.\n+      size = MAX2(size, 2);\n+  }\n+\n+  int max_size = max_vector_size(bt);\n   return MIN2(size, max_size);\n }", "target": "int Matcher::min_vector_size(const BasicType bt) {\n-  int max_size = max_vector_size(bt);\n-  // Limit the min vector size to 8 bytes.\n-  int size = 8 / type2aelembytes(bt);\n-  if (bt == T_BYTE) {\n-    // To support vector api shuffle/rearrange.\n-    size = 4;\n-  } else if (bt == T_BOOLEAN) {\n-    // To support vector api load/store mask.\n-    size = 2;\n-  }\n-  if (size < 2) size = 2;\n+  int size;\n+  switch(bt) {\n+    case T_BOOLEAN:\n+      // Load/store a vector mask with only 2 elements for vector types\n+      // such as \"2I/2F/2L/2D\".\n+      size = 2;\n+      break;\n+    case T_BYTE:\n+      // Generate a \"4B\" vector, to support vector cast between \"8B/16B\"\n+      // and \"4S/4I/4L/4F/4D\".\n+      size = 4;\n+      break;\n+    case T_SHORT:\n+      // Generate a \"2S\" vector, to support vector cast between \"4S/8S\"\n+      // and \"2I/2L/2F/2D\".\n+      size = 2;\n+      break;\n+    default:\n+      // Limit the min vector length to 64-bit.\n+      size = 8 / type2aelembytes(bt);\n+      // The number of elements in a vector should be at least 2.\n+      size = MAX2(size, 2);\n+  }\n+\n+  int max_size = max_vector_size(bt);\n   return MIN2(size, max_size);\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：min_vector_size函数对所有类型采用统一的8字节最小向量长度限制，仅对T_BYTE和T_BOOLEAN类型有特殊处理，导致短向量类型（如T_SHORT）无法生成更小的向量（如2元素向量）。\n优化后：通过switch-case结构为T_BOOLEAN、T_BYTE和T_SHORT类型分别设置更小的最小向量长度（2或4元素），其他类型保持64位最小长度但确保至少2个元素。\n优化思路：放宽RISC-V架构上短向量的最小长度限制，从固定的8字节放宽到32位（4字节），使编译器能够为短向量类型生成更小的向量（如2S、4B），从而支持更多向量类型之间的转换操作，提升向量API的灵活性和性能。"}
{"id": 258, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（条件传播与常量折叠）", "optimization_description": "优化前：在条件常量传播（CCP）阶段，对于特定模式“(m & x) <u (m + 1)”的布尔表达式，当输入类型发生变化时，可能无法及时重新评估，导致错过常量折叠机会。优化后：1. 在PhaseCCP中添加push_bool_with_cmpu_and_mask和push_bool_matching_case1b函数，主动检测该模式并在相关输入变化时重新评估Bool节点。2. 在BoolNode::Value中添加类型检查，避免对TOP类型进行无效转换。优化思路：通过增强CCP对特定表达式模式的感知能力，确保在类型信息更新时能重新触发优化，提高常量折叠的准确性和覆盖率。", "original_code": "在条件常量传播（CCP）阶段，对于特定模式“(m & x) <u (m + 1)”的布尔表达式，当输入类型发生变化时，可能无法及时重新评估，导致错过常量折叠机会。", "optimized_code": "void PhaseCCP::push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) {\n  push_and(worklist, parent, use);\n  push_cast_ii(worklist, parent, use);\n  push_opaque_zero_trip_guard(worklist, use);\n+ push_bool_with_cmpu_and_mask(worklist, use);\n}\n\n+void PhaseCCP::push_bool_with_cmpu_and_mask(Unique_Node_List& worklist, const Node* use) const {\n+  // 检测并处理特定模式 (m & x) <u (m + 1)\n+}\n\n+void PhaseCCP::push_bool_matching_case1b(Unique_Node_List& worklist, const Node* cmpu) const {\n+  // 匹配并重新评估符合条件的Bool节点\n+}\n\nconst Type* BoolNode::Value(PhaseGVN* phase) const {\n+  const Type* input_type = phase->type(in(1));\n+  if (input_type == Type::TOP) {\n+    return Type::TOP;\n+  }\n  const Type* t = Value_cmpu_and_mask(phase);\n  if (t != nullptr) {\n    return t;\n  }\n-  return _test.cc2logical( phase->type( in(1) ) );\n+  return _test.cc2logical(input_type);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/a56cd371a2c497e4323756f8b8a08a0bba059bf2", "code_v0_no_empty_lines": "在条件常量传播（CCP）阶段，对于特定模式“(m & x) <u (m + 1)”的布尔表达式，当输入类型发生变化时，可能无法及时重新评估，导致错过常量折叠机会。", "code_v1_no_empty_lines": "void PhaseCCP::push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) {\n  push_and(worklist, parent, use);\n  push_cast_ii(worklist, parent, use);\n  push_opaque_zero_trip_guard(worklist, use);\n+ push_bool_with_cmpu_and_mask(worklist, use);\n}\n\n+void PhaseCCP::push_bool_with_cmpu_and_mask(Unique_Node_List& worklist, const Node* use) const {\n+  // 检测并处理特定模式 (m & x) <u (m + 1)\n+}\n\n+void PhaseCCP::push_bool_matching_case1b(Unique_Node_List& worklist, const Node* cmpu) const {\n+  // 匹配并重新评估符合条件的Bool节点\n+}\n\nconst Type* BoolNode::Value(PhaseGVN* phase) const {\n+  const Type* input_type = phase->type(in(1));\n+  if (input_type == Type::TOP) {\n+    return Type::TOP;\n+  }\n  const Type* t = Value_cmpu_and_mask(phase);\n  if (t != nullptr) {\n    return t;\n  }\n-  return _test.cc2logical( phase->type( in(1) ) );\n+  return _test.cc2logical(input_type);\n}", "target": "void PhaseCCP::push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) {\n  push_and(worklist, parent, use);\n  push_cast_ii(worklist, parent, use);\n  push_opaque_zero_trip_guard(worklist, use);\n+ push_bool_with_cmpu_and_mask(worklist, use);\n}\n\n+void PhaseCCP::push_bool_with_cmpu_and_mask(Unique_Node_List& worklist, const Node* use) const {\n+  // 检测并处理特定模式 (m & x) <u (m + 1)\n+}\n\n+void PhaseCCP::push_bool_matching_case1b(Unique_Node_List& worklist, const Node* cmpu) const {\n+  // 匹配并重新评估符合条件的Bool节点\n+}\n\nconst Type* BoolNode::Value(PhaseGVN* phase) const {\n+  const Type* input_type = phase->type(in(1));\n+  if (input_type == Type::TOP) {\n+    return Type::TOP;\n+  }\n  const Type* t = Value_cmpu_and_mask(phase);\n  if (t != nullptr) {\n    return t;\n  }\n-  return _test.cc2logical( phase->type( in(1) ) );\n+  return _test.cc2logical(input_type);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在条件常量传播（CCP）阶段，对于特定模式“(m & x) <u (m + 1)”的布尔表达式，当输入类型发生变化时，可能无法及时重新评估，导致错过常量折叠机会。优化后：1. 在PhaseCCP中添加push_bool_with_cmpu_and_mask和push_bool_matching_case1b函数，主动检测该模式并在相关输入变化时重新评估Bool节点。2. 在BoolNode::Value中添加类型检查，避免对TOP类型进行无效转换。优化思路：通过增强CCP对特定表达式模式的感知能力，确保在类型信息更新时能重新触发优化，提高常量折叠的准确性和覆盖率。"}
{"id": 259, "source": "riscv-dataset-excel", "optimization_type": "内存优化+对象管理优化", "optimization_description": "优化前：多个网络客户端类（FtpClient、HttpClient等）直接使用传入的Proxy对象，可能导致内存泄漏或意外修改。优化后：新增ProxyUtil.copyProxy()方法，在设置代理时创建新的Proxy实例（除非是null、NO_PROXY、ApplicationProxy或已经是标准Proxy实例）。优化思路：通过防御性复制避免外部代码修改内部代理状态，同时减少不必要的对象创建以提高性能。", "original_code": "多个网络客户端类（FtpClient、HttpClient等）直接使用传入的Proxy对象，可能导致内存泄漏或意外修改。", "optimized_code": "public static Proxy copyProxy(Proxy proxy) {\n    return proxy == null\n            || proxy.getClass() == Proxy.class\n            || proxy instanceof ApplicationProxy\n            ? proxy\n            : new Proxy(proxy.type(), proxy.address());\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/1d8cca2b84215533a5f0ba97a6c9d3f17d810f4c", "code_v0_no_empty_lines": "多个网络客户端类（FtpClient、HttpClient等）直接使用传入的Proxy对象，可能导致内存泄漏或意外修改。", "code_v1_no_empty_lines": "public static Proxy copyProxy(Proxy proxy) {\n    return proxy == null\n            || proxy.getClass() == Proxy.class\n            || proxy instanceof ApplicationProxy\n            ? proxy\n            : new Proxy(proxy.type(), proxy.address());\n}", "target": "public static Proxy copyProxy(Proxy proxy) {\n    return proxy == null\n            || proxy.getClass() == Proxy.class\n            || proxy instanceof ApplicationProxy\n            ? proxy\n            : new Proxy(proxy.type(), proxy.address());\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多个网络客户端类（FtpClient、HttpClient等）直接使用传入的Proxy对象，可能导致内存泄漏或意外修改。优化后：新增ProxyUtil.copyProxy()方法，在设置代理时创建新的Proxy实例（除非是null、NO_PROXY、ApplicationProxy或已经是标准Proxy实例）。优化思路：通过防御性复制避免外部代码修改内部代理状态，同时减少不必要的对象创建以提高性能。"}
{"id": 260, "source": "riscv-dataset-excel", "optimization_type": "内存安全优化+边界检查优化", "optimization_description": "优化前：1. 循环中缺少边界检查，可能导致数组越界访问；2. 内存分配失败时直接抛出异常，可能导致资源泄漏；3. 内存分配计算错误（使用乘法而非加法），分配过多内存。优化后：1. 在多个像素复制循环中添加srcHeight和srcRowWidth边界检查，防止越界；2. 内存分配失败时安全地初始化canvas结构体，避免异常；3. 修正内存分配公式，使用加法计算总大小，减少内存浪费。优化思路：增强代码健壮性，防止内存越界和分配错误，提高字体渲染的稳定性。", "original_code": "1. 循环中缺少边界检查，可能导致数组越界访问；2. 内存分配失败时直接抛出异常，可能导致资源泄漏；3. 内存分配计算错误（使用乘法而非加法），分配过多内存。", "optimized_code": "1. 添加边界检查：\n- for (y = 0; y < height; y++) {\n+ for (y = 0; y < height && y < srcHeight; y++) {\n\n2. 内存分配失败处理优化：\n- [[NSException exceptionWithName:NSMallocException ...] raise];\n+ canvas->image->width = 0;\n+ canvas->image->height = 0;\n+ canvas->image->rowBytes = 0;\n+ canvas->image->data = malloc(0);\n\n3. 内存分配大小计算优化：\n- void *buffer = malloc(sizeof(CGRect) * sizeof(CGSize) * sizeof(CGGlyph) * sizeof(UnicodeScalarValue) * len);\n+ void *buffer = malloc((sizeof(CGRect) + sizeof(CGSize) + sizeof(CGGlyph) + sizeof(UnicodeScalarValue)) * len);", "source_url": "https://github.com/openjdk/riscv-port/commit/db3f6eabb559f370e0f1593f1ec202a65f096025", "code_v0_no_empty_lines": "1. 循环中缺少边界检查，可能导致数组越界访问；2. 内存分配失败时直接抛出异常，可能导致资源泄漏；3. 内存分配计算错误（使用乘法而非加法），分配过多内存。", "code_v1_no_empty_lines": "1. 添加边界检查：\n- for (y = 0; y < height; y++) {\n+ for (y = 0; y < height && y < srcHeight; y++) {\n\n2. 内存分配失败处理优化：\n- [[NSException exceptionWithName:NSMallocException ...] raise];\n+ canvas->image->width = 0;\n+ canvas->image->height = 0;\n+ canvas->image->rowBytes = 0;\n+ canvas->image->data = malloc(0);\n\n3. 内存分配大小计算优化：\n- void *buffer = malloc(sizeof(CGRect) * sizeof(CGSize) * sizeof(CGGlyph) * sizeof(UnicodeScalarValue) * len);\n+ void *buffer = malloc((sizeof(CGRect) + sizeof(CGSize) + sizeof(CGGlyph) + sizeof(UnicodeScalarValue)) * len);", "target": "1. 添加边界检查：\n- for (y = 0; y < height; y++) {\n+ for (y = 0; y < height && y < srcHeight; y++) {\n\n2. 内存分配失败处理优化：\n- [[NSException exceptionWithName:NSMallocException ...] raise];\n+ canvas->image->width = 0;\n+ canvas->image->height = 0;\n+ canvas->image->rowBytes = 0;\n+ canvas->image->data = malloc(0);\n\n3. 内存分配大小计算优化：\n- void *buffer = malloc(sizeof(CGRect) * sizeof(CGSize) * sizeof(CGGlyph) * sizeof(UnicodeScalarValue) * len);\n+ void *buffer = malloc((sizeof(CGRect) + sizeof(CGSize) + sizeof(CGGlyph) + sizeof(UnicodeScalarValue)) * len);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 循环中缺少边界检查，可能导致数组越界访问；2. 内存分配失败时直接抛出异常，可能导致资源泄漏；3. 内存分配计算错误（使用乘法而非加法），分配过多内存。优化后：1. 在多个像素复制循环中添加srcHeight和srcRowWidth边界检查，防止越界；2. 内存分配失败时安全地初始化canvas结构体，避免异常；3. 修正内存分配公式，使用加法计算总大小，减少内存浪费。优化思路：增强代码健壮性，防止内存越界和分配错误，提高字体渲染的稳定性。"}
{"id": 261, "source": "riscv-dataset-excel", "optimization_type": "内存分配优化", "optimization_description": "优化前：ProfileSymbolList::add函数在插入元素时频繁触发DenseMap的grow操作，导致9.4%的CPU时间开销，其中约一半时间用于内存重新分配。优化后：通过预先扫描数据确定预期元素数量，调用reserve预分配足够空间，避免插入过程中的多次内存重新分配。优化思路：减少动态容器增长时的内存分配开销，提升ProfileSymbolList读取效率。", "original_code": "ProfileSymbolList::add函数在插入元素时频繁触发DenseMap的grow操作，导致9.4%的CPU时间开销，其中约一半时间用于内存重新分配。", "optimized_code": "void reserve(size_t Size) { Syms.reserve(Size); }\n\n// 在read函数中添加：\nreserve(std::min<uint64_t>(ProfileSymbolListCutOff,\n                           std::count(Data, Data + ListSize, 0)));", "source_url": "https://github.com/llvm/llvm-project/commit/b9b9a239df4785b42b050b128eff18694871bc14", "code_v0_no_empty_lines": "ProfileSymbolList::add函数在插入元素时频繁触发DenseMap的grow操作，导致9.4%的CPU时间开销，其中约一半时间用于内存重新分配。", "code_v1_no_empty_lines": "void reserve(size_t Size) { Syms.reserve(Size); }\n\n// 在read函数中添加：\nreserve(std::min<uint64_t>(ProfileSymbolListCutOff,\n                           std::count(Data, Data + ListSize, 0)));", "target": "void reserve(size_t Size) { Syms.reserve(Size); }\n\n// 在read函数中添加：\nreserve(std::min<uint64_t>(ProfileSymbolListCutOff,\n                           std::count(Data, Data + ListSize, 0)));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ProfileSymbolList::add函数在插入元素时频繁触发DenseMap的grow操作，导致9.4%的CPU时间开销，其中约一半时间用于内存重新分配。优化后：通过预先扫描数据确定预期元素数量，调用reserve预分配足够空间，避免插入过程中的多次内存重新分配。优化思路：减少动态容器增长时的内存分配开销，提升ProfileSymbolList读取效率。"}
{"id": 262, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：对于shl i64指令，当移位操作数是zext(and i32 63)模式时，需要先生成and i32 63指令，然后进行零扩展，最后执行移位操作。优化后：通过添加新的模式匹配规则，直接识别zext(and i32 63)模式，将其优化为i64.extend_i32_u指令，消除了冗余的and掩码操作。优化思路：由于WebAssembly的64位移位指令会自动对移位量取模64，而63的掩码（0b111111）在取模64后效果相同，因此可以安全地移除这个冗余的and掩码操作，减少指令数量，提高代码效率。", "original_code": "对于shl i64指令，当移位操作数是zext(and i32 63)模式时，需要先生成and i32 63指令，然后进行零扩展，最后执行移位操作。", "optimized_code": "def : Pat<(shl I64:$lhs, (zext (and I32:$rhs, 63))),\n                               (SHL_I64 I64:$lhs, (I64_EXTEND_U_I32 I32:$rhs))>;", "source_url": "https://github.com/llvm/llvm-project/commit/edd1856686a44db896d64a3083619dfcc473a65f", "code_v0_no_empty_lines": "对于shl i64指令，当移位操作数是zext(and i32 63)模式时，需要先生成and i32 63指令，然后进行零扩展，最后执行移位操作。", "code_v1_no_empty_lines": "def : Pat<(shl I64:$lhs, (zext (and I32:$rhs, 63))),\n                               (SHL_I64 I64:$lhs, (I64_EXTEND_U_I32 I32:$rhs))>;", "target": "def : Pat<(shl I64:$lhs, (zext (and I32:$rhs, 63))),\n                               (SHL_I64 I64:$lhs, (I64_EXTEND_U_I32 I32:$rhs))>;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于shl i64指令，当移位操作数是zext(and i32 63)模式时，需要先生成and i32 63指令，然后进行零扩展，最后执行移位操作。优化后：通过添加新的模式匹配规则，直接识别zext(and i32 63)模式，将其优化为i64.extend_i32_u指令，消除了冗余的and掩码操作。优化思路：由于WebAssembly的64位移位指令会自动对移位量取模64，而63的掩码（0b111111）在取模64后效果相同，因此可以安全地移除这个冗余的and掩码操作，减少指令数量，提高代码效率。"}
{"id": 263, "source": "riscv-dataset-excel", "optimization_type": "同步性能优化", "optimization_description": "优化前：在获取CPU时间JFR出队锁时，使用忙等待（busy-waiting）循环，当锁竞争激烈时会导致CPU资源浪费和性能下降。优化后：引入SpinYield机制，在等待锁时调用s.wait()，在自旋等待中插入适当的延迟或让出CPU，减少CPU占用和功耗。优化思路：将纯忙等待改为更智能的自旋等待策略，在锁竞争时降低CPU使用率，提高系统整体性能。", "original_code": "在获取CPU时间JFR出队锁时，使用忙等待（busy-waiting）循环，当锁竞争激烈时会导致CPU资源浪费和性能下降。", "optimized_code": "-  while (Atomic::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, DEQUEUE) != UNLOCKED);\n+  SpinYield s;\n+  while (Atomic::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, DEQUEUE) != UNLOCKED) {\n+    s.wait();\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/d2082c58ff086eb37c6211a8d1b813cdfedc2259", "code_v0_no_empty_lines": "在获取CPU时间JFR出队锁时，使用忙等待（busy-waiting）循环，当锁竞争激烈时会导致CPU资源浪费和性能下降。", "code_v1_no_empty_lines": "-  while (Atomic::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, DEQUEUE) != UNLOCKED);\n+  SpinYield s;\n+  while (Atomic::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, DEQUEUE) != UNLOCKED) {\n+    s.wait();\n+  }", "target": "-  while (Atomic::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, DEQUEUE) != UNLOCKED);\n+  SpinYield s;\n+  while (Atomic::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, DEQUEUE) != UNLOCKED) {\n+    s.wait();\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在获取CPU时间JFR出队锁时，使用忙等待（busy-waiting）循环，当锁竞争激烈时会导致CPU资源浪费和性能下降。优化后：引入SpinYield机制，在等待锁时调用s.wait()，在自旋等待中插入适当的延迟或让出CPU，减少CPU占用和功耗。优化思路：将纯忙等待改为更智能的自旋等待策略，在锁竞争时降低CPU使用率，提高系统整体性能。"}
{"id": 264, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+类型处理优化", "optimization_description": "优化前：SuperWord向量化时错误地将byte/short类型的Integer.numberOfLeadingZeros、numberOfTrailingZeros、reverse和bitCount等操作视为可截断（truncation），导致高位比特信息丢失，产生错误向量化结果。优化后：新增can_subword_truncate()函数精确判断哪些操作支持子字截断，将不支持截断的操作（如位计数、字节反转等）排除在截断向量化之外，确保向量化正确性。优化思路：区分算术操作（可截断）与位操作（不可截断），避免因类型截断导致语义错误。", "original_code": "SuperWord向量化时错误地将byte/short类型的Integer.numberOfLeadingZeros、numberOfTrailingZeros、reverse和bitCount等操作视为可截断（truncation），导致高位比特信息丢失，产生错误向量化结果。", "optimized_code": "static bool can_subword_truncate(Node* in, const Type* type) {\n  // ... 函数实现 ...\n}\n\nvoid VLoopTypes::compute_vector_element_type() {\n  // ...\n  // 修改前：if (VectorNode::is_shift_opcode(op) || op == Op_AbsI || op == Op_ReverseBytesI) {\n  // 修改后：if (!can_subword_truncate(in, vt)) {\n  // ...\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/77bd417c9990f57525257d9df89b9df4d7991461", "code_v0_no_empty_lines": "SuperWord向量化时错误地将byte/short类型的Integer.numberOfLeadingZeros、numberOfTrailingZeros、reverse和bitCount等操作视为可截断（truncation），导致高位比特信息丢失，产生错误向量化结果。", "code_v1_no_empty_lines": "static bool can_subword_truncate(Node* in, const Type* type) {\n  // ... 函数实现 ...\n}\n\nvoid VLoopTypes::compute_vector_element_type() {\n  // ...\n  // 修改前：if (VectorNode::is_shift_opcode(op) || op == Op_AbsI || op == Op_ReverseBytesI) {\n  // 修改后：if (!can_subword_truncate(in, vt)) {\n  // ...\n}", "target": "static bool can_subword_truncate(Node* in, const Type* type) {\n  // ... 函数实现 ...\n}\n\nvoid VLoopTypes::compute_vector_element_type() {\n  // ...\n  // 修改前：if (VectorNode::is_shift_opcode(op) || op == Op_AbsI || op == Op_ReverseBytesI) {\n  // 修改后：if (!can_subword_truncate(in, vt)) {\n  // ...\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SuperWord向量化时错误地将byte/short类型的Integer.numberOfLeadingZeros、numberOfTrailingZeros、reverse和bitCount等操作视为可截断（truncation），导致高位比特信息丢失，产生错误向量化结果。优化后：新增can_subword_truncate()函数精确判断哪些操作支持子字截断，将不支持截断的操作（如位计数、字节反转等）排除在截断向量化之外，确保向量化正确性。优化思路：区分算术操作（可截断）与位操作（不可截断），避免因类型截断导致语义错误。"}
{"id": 265, "source": "riscv-dataset-excel", "optimization_type": "功能开关优化+配置优化", "optimization_description": "优化前：Intel APX功能默认启用，通过条件编译限制在非产品构建中可用。优化后：禁用Intel APX的默认启用，改为通过实验性选项-XX:+UnlockExperimentalVMOptions -XX:+UseAPX显式启用，并移除条件编译限制使APX支持在所有构建中可用。优化思路：将APX从默认启用改为可选功能，避免在不支持的CPU上自动启用可能导致的性能问题，同时统一构建配置。", "original_code": "Intel APX功能默认启用，通过条件编译限制在非产品构建中可用。", "optimized_code": "-  if (FLAG_IS_DEFAULT(UseAPX)) {\n-    FLAG_SET_DEFAULT(UseAPX, apx_supported ? true : false);\n-  }\n-#if !defined(PRODUCT)\n   if (_cpuid_info.apx_save[0] != egpr_test_value() ||\n       _cpuid_info.apx_save[1] != egpr_test_value()) {\n     return false;\n   }\n   return true;\n-#else\n-  return false;\n-#endif", "source_url": "https://github.com/openjdk/riscv-port/commit/26b002805ab235d07998eddd486fe66a69f60671", "code_v0_no_empty_lines": "Intel APX功能默认启用，通过条件编译限制在非产品构建中可用。", "code_v1_no_empty_lines": "-  if (FLAG_IS_DEFAULT(UseAPX)) {\n-    FLAG_SET_DEFAULT(UseAPX, apx_supported ? true : false);\n-  }\n-#if !defined(PRODUCT)\n   if (_cpuid_info.apx_save[0] != egpr_test_value() ||\n       _cpuid_info.apx_save[1] != egpr_test_value()) {\n     return false;\n   }\n   return true;\n-#else\n-  return false;\n-#endif", "target": "-  if (FLAG_IS_DEFAULT(UseAPX)) {\n-    FLAG_SET_DEFAULT(UseAPX, apx_supported ? true : false);\n-  }\n-#if !defined(PRODUCT)\n   if (_cpuid_info.apx_save[0] != egpr_test_value() ||\n       _cpuid_info.apx_save[1] != egpr_test_value()) {\n     return false;\n   }\n   return true;\n-#else\n-  return false;\n-#endif", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Intel APX功能默认启用，通过条件编译限制在非产品构建中可用。优化后：禁用Intel APX的默认启用，改为通过实验性选项-XX:+UnlockExperimentalVMOptions -XX:+UseAPX显式启用，并移除条件编译限制使APX支持在所有构建中可用。优化思路：将APX从默认启用改为可选功能，避免在不支持的CPU上自动启用可能导致的性能问题，同时统一构建配置。"}
{"id": 266, "source": "riscv-dataset-excel", "optimization_type": "I/O性能优化+内存优化", "optimization_description": "优化前：readAllLines()方法通过readAllCharsAsString()读取所有字符到StringBuilder，然后转换为字符串，再调用lines().toList()分割为行列表。这导致：1) 创建完整字符串的额外内存开销；2) 需要两次遍历（读取和分割）；3) 字符串拼接和分割的性能损失。\n优化后：直接逐块读取字符到缓冲区，在线检测换行符并构建行列表。关键改进：1) 使用1024字符缓冲区减少内存分配；2) 智能缓冲区管理（当剩余字符超过缓冲区一半时扩展缓冲区，否则移动字符到缓冲区开头）；3) 单次遍历同时完成读取和行分割；4) 正确处理\\r、\\n、\\r\\n等换行符。\n优化思路：避免中间字符串的创建和分割，通过流式处理直接构建行列表，减少内存分配和复制，提高大文件读取性能。", "original_code": "readAllLines()方法通过readAllCharsAsString()读取所有字符到StringBuilder，然后转换为字符串，再调用lines().toList()分割为行列表。这导致：1) 创建完整字符串的额外内存开销；2) 需要两次遍历（读取和分割）；3) 字符串拼接和分割的性能损失。", "optimized_code": "-    public List<String> readAllLines() throws IOException {\n-        return readAllCharsAsString().lines().toList();\n-    }\n+    public List<String> readAllLines() throws IOException {\n+        List<String> lines = new ArrayList<>();\n+        char[] cb = new char[1024];\n+\n+        int start = 0;\n+        int pos = 0;\n+        int limit = 0;\n+        boolean skipLF = false;\n+        int n;\n+        while ((n = read(cb, pos, cb.length - pos)) != -1) {\n+            limit = pos + n;\n+            while (pos < limit) {\n+                if (skipLF) {\n+                    if (cb[pos] == '\\n') {\n+                        pos++;\n+                        start++;\n+                    }\n+                    skipLF = false;\n+                }\n+                while (pos < limit) {\n+                    char c = cb[pos++];\n+                    if (c == '\\n' || c == '\\r') {\n+                        lines.add(new String(cb, start, pos - 1 - start));\n+                        skipLF = (c == '\\r');\n+                        start = pos;\n+                        break;\n+                    }\n+                }\n+                if (pos == limit) {\n+                    int len = limit - start;\n+                    if (len >= cb.length/2) {\n+                        // allocate larger buffer and copy chars to beginning\n+                        int newLength = ArraysSupport.newLength(cb.length,\n+                                            TRANSFER_BUFFER_SIZE, cb.length);\n+                        char[] tmp = new char[newLength];\n+                        System.arraycopy(cb, start, tmp, 0, len);\n+                        cb = tmp;\n+                    } else if (start != 0 && len != 0) {\n+                        // move fragment to beginning of buffer\n+                        System.arraycopy(cb, start, cb, 0, len);\n+                    }\n+                    pos = limit = len;\n+                    start = 0;\n+                    break;\n+                }\n+            }\n+        }\n+        // add a string if EOS terminates the last line\n+        if (limit > start)\n+            lines.add(new String(cb, start, limit - start));\n+\n+        return Collections.unmodifiableList(lines);\n+    }", "source_url": "https://github.com/openjdk/riscv-port/commit/6e203384f8777fc55081065b128bd2b0ba074729", "code_v0_no_empty_lines": "readAllLines()方法通过readAllCharsAsString()读取所有字符到StringBuilder，然后转换为字符串，再调用lines().toList()分割为行列表。这导致：1) 创建完整字符串的额外内存开销；2) 需要两次遍历（读取和分割）；3) 字符串拼接和分割的性能损失。", "code_v1_no_empty_lines": "-    public List<String> readAllLines() throws IOException {\n-        return readAllCharsAsString().lines().toList();\n-    }\n+    public List<String> readAllLines() throws IOException {\n+        List<String> lines = new ArrayList<>();\n+        char[] cb = new char[1024];\n+\n+        int start = 0;\n+        int pos = 0;\n+        int limit = 0;\n+        boolean skipLF = false;\n+        int n;\n+        while ((n = read(cb, pos, cb.length - pos)) != -1) {\n+            limit = pos + n;\n+            while (pos < limit) {\n+                if (skipLF) {\n+                    if (cb[pos] == '\\n') {\n+                        pos++;\n+                        start++;\n+                    }\n+                    skipLF = false;\n+                }\n+                while (pos < limit) {\n+                    char c = cb[pos++];\n+                    if (c == '\\n' || c == '\\r') {\n+                        lines.add(new String(cb, start, pos - 1 - start));\n+                        skipLF = (c == '\\r');\n+                        start = pos;\n+                        break;\n+                    }\n+                }\n+                if (pos == limit) {\n+                    int len = limit - start;\n+                    if (len >= cb.length/2) {\n+                        // allocate larger buffer and copy chars to beginning\n+                        int newLength = ArraysSupport.newLength(cb.length,\n+                                            TRANSFER_BUFFER_SIZE, cb.length);\n+                        char[] tmp = new char[newLength];\n+                        System.arraycopy(cb, start, tmp, 0, len);\n+                        cb = tmp;\n+                    } else if (start != 0 && len != 0) {\n+                        // move fragment to beginning of buffer\n+                        System.arraycopy(cb, start, cb, 0, len);\n+                    }\n+                    pos = limit = len;\n+                    start = 0;\n+                    break;\n+                }\n+            }\n+        }\n+        // add a string if EOS terminates the last line\n+        if (limit > start)\n+            lines.add(new String(cb, start, limit - start));\n+\n+        return Collections.unmodifiableList(lines);\n+    }", "target": "-    public List<String> readAllLines() throws IOException {\n-        return readAllCharsAsString().lines().toList();\n-    }\n+    public List<String> readAllLines() throws IOException {\n+        List<String> lines = new ArrayList<>();\n+        char[] cb = new char[1024];\n+\n+        int start = 0;\n+        int pos = 0;\n+        int limit = 0;\n+        boolean skipLF = false;\n+        int n;\n+        while ((n = read(cb, pos, cb.length - pos)) != -1) {\n+            limit = pos + n;\n+            while (pos < limit) {\n+                if (skipLF) {\n+                    if (cb[pos] == '\\n') {\n+                        pos++;\n+                        start++;\n+                    }\n+                    skipLF = false;\n+                }\n+                while (pos < limit) {\n+                    char c = cb[pos++];\n+                    if (c == '\\n' || c == '\\r') {\n+                        lines.add(new String(cb, start, pos - 1 - start));\n+                        skipLF = (c == '\\r');\n+                        start = pos;\n+                        break;\n+                    }\n+                }\n+                if (pos == limit) {\n+                    int len = limit - start;\n+                    if (len >= cb.length/2) {\n+                        // allocate larger buffer and copy chars to beginning\n+                        int newLength = ArraysSupport.newLength(cb.length,\n+                                            TRANSFER_BUFFER_SIZE, cb.length);\n+                        char[] tmp = new char[newLength];\n+                        System.arraycopy(cb, start, tmp, 0, len);\n+                        cb = tmp;\n+                    } else if (start != 0 && len != 0) {\n+                        // move fragment to beginning of buffer\n+                        System.arraycopy(cb, start, cb, 0, len);\n+                    }\n+                    pos = limit = len;\n+                    start = 0;\n+                    break;\n+                }\n+            }\n+        }\n+        // add a string if EOS terminates the last line\n+        if (limit > start)\n+            lines.add(new String(cb, start, limit - start));\n+\n+        return Collections.unmodifiableList(lines);\n+    }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：readAllLines()方法通过readAllCharsAsString()读取所有字符到StringBuilder，然后转换为字符串，再调用lines().toList()分割为行列表。这导致：1) 创建完整字符串的额外内存开销；2) 需要两次遍历（读取和分割）；3) 字符串拼接和分割的性能损失。\n优化后：直接逐块读取字符到缓冲区，在线检测换行符并构建行列表。关键改进：1) 使用1024字符缓冲区减少内存分配；2) 智能缓冲区管理（当剩余字符超过缓冲区一半时扩展缓冲区，否则移动字符到缓冲区开头）；3) 单次遍历同时完成读取和行分割；4) 正确处理\\r、\\n、\\r\\n等换行符。\n优化思路：避免中间字符串的创建和分割，通过流式处理直接构建行列表，减少内存分配和复制，提高大文件读取性能。"}
{"id": 267, "source": "riscv-dataset-excel", "optimization_type": "基准测试稳定性优化", "optimization_description": "优化前：SystemGC基准测试缺乏预热和测量迭代次数配置，且未在测试前清理无关对象，导致测试结果不稳定、不可重复。优化后：为所有基准测试类添加@Warmup(iterations=5)和@Measurement(iterations=5)注解，并在@Setup(Level.Trial)阶段添加System.gc()调用。优化思路：通过预热减少JIT编译开销，通过多次测量提高结果可靠性，通过测试前强制GC清理内存环境，确保每次测试都在相似的内存状态下开始，从而提高基准测试的稳定性和可重复性。", "original_code": "SystemGC基准测试缺乏预热和测量迭代次数配置，且未在测试前清理无关对象，导致测试结果不稳定、不可重复。", "optimized_code": "@Warmup(iterations = 5)\n@Measurement(iterations = 5)\n...\n@Setup(Level.Trial)\npublic void preRun() {\n    // Compact right now, kicking out all unrelated objects\n    System.gc();\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/a9bd1ad40cb4e275d83b2e8b15e3c4be1551f7fc", "code_v0_no_empty_lines": "SystemGC基准测试缺乏预热和测量迭代次数配置，且未在测试前清理无关对象，导致测试结果不稳定、不可重复。", "code_v1_no_empty_lines": "@Warmup(iterations = 5)\n@Measurement(iterations = 5)\n...\n@Setup(Level.Trial)\npublic void preRun() {\n    // Compact right now, kicking out all unrelated objects\n    System.gc();\n}", "target": "@Warmup(iterations = 5)\n@Measurement(iterations = 5)\n...\n@Setup(Level.Trial)\npublic void preRun() {\n    // Compact right now, kicking out all unrelated objects\n    System.gc();\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SystemGC基准测试缺乏预热和测量迭代次数配置，且未在测试前清理无关对象，导致测试结果不稳定、不可重复。优化后：为所有基准测试类添加@Warmup(iterations=5)和@Measurement(iterations=5)注解，并在@Setup(Level.Trial)阶段添加System.gc()调用。优化思路：通过预热减少JIT编译开销，通过多次测量提高结果可靠性，通过测试前强制GC清理内存环境，确保每次测试都在相似的内存状态下开始，从而提高基准测试的稳定性和可重复性。"}
{"id": 268, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化+性能优化", "optimization_description": "优化前：HVX向量浮点到整数转换使用复杂的展开代码，性能较低。优化后：在特定条件下（启用hexagon-fp-fast-convert选项时），直接使用硬件指令V6_vconv_h_hf和V6_vconv_w_sf进行快速转换。优化思路：为满足客户使用直接内在函数的需求，添加选项控制是否使用更快的非标准舍入模式转换，在V81架构上使用合规的舍入指令，在旧架构上通过选项启用快速转换。", "original_code": "HVX向量浮点到整数转换使用复杂的展开代码，性能较低。", "optimized_code": "if (InpTy == MVT::v64f16) {\n    if (Subtarget.useHVXV81Ops()) {\n      // This is c/c++ compliant\n      SDValue ConvVec =\n          getInstr(Hexagon::V6_vconv_h_hf_rnd, dl, ResTy, {Op0}, DAG);\n      return ConvVec;\n    } else if (EnableFpFastConvert) {\n      // Vd32.h=Vu32.hf same as Q6_Vh_equals_Vhf\n      SDValue ConvVec = getInstr(Hexagon::V6_vconv_h_hf, dl, ResTy, {Op0}, DAG);\n      return ConvVec;\n    }\n  } else if (EnableFpFastConvert && InpTy == MVT::v32f32) {\n    // Vd32.w=Vu32.sf same as Q6_Vw_equals_Vsf\n    SDValue ConvVec = getInstr(Hexagon::V6_vconv_w_sf, dl, ResTy, {Op0}, DAG);\n    return ConvVec;\n  }", "source_url": "https://github.com/llvm/llvm-project/commit/4715e525648dde9abc50dfc93fa2cd3a67708cc7", "code_v0_no_empty_lines": "HVX向量浮点到整数转换使用复杂的展开代码，性能较低。", "code_v1_no_empty_lines": "if (InpTy == MVT::v64f16) {\n    if (Subtarget.useHVXV81Ops()) {\n      // This is c/c++ compliant\n      SDValue ConvVec =\n          getInstr(Hexagon::V6_vconv_h_hf_rnd, dl, ResTy, {Op0}, DAG);\n      return ConvVec;\n    } else if (EnableFpFastConvert) {\n      // Vd32.h=Vu32.hf same as Q6_Vh_equals_Vhf\n      SDValue ConvVec = getInstr(Hexagon::V6_vconv_h_hf, dl, ResTy, {Op0}, DAG);\n      return ConvVec;\n    }\n  } else if (EnableFpFastConvert && InpTy == MVT::v32f32) {\n    // Vd32.w=Vu32.sf same as Q6_Vw_equals_Vsf\n    SDValue ConvVec = getInstr(Hexagon::V6_vconv_w_sf, dl, ResTy, {Op0}, DAG);\n    return ConvVec;\n  }", "target": "if (InpTy == MVT::v64f16) {\n    if (Subtarget.useHVXV81Ops()) {\n      // This is c/c++ compliant\n      SDValue ConvVec =\n          getInstr(Hexagon::V6_vconv_h_hf_rnd, dl, ResTy, {Op0}, DAG);\n      return ConvVec;\n    } else if (EnableFpFastConvert) {\n      // Vd32.h=Vu32.hf same as Q6_Vh_equals_Vhf\n      SDValue ConvVec = getInstr(Hexagon::V6_vconv_h_hf, dl, ResTy, {Op0}, DAG);\n      return ConvVec;\n    }\n  } else if (EnableFpFastConvert && InpTy == MVT::v32f32) {\n    // Vd32.w=Vu32.sf same as Q6_Vw_equals_Vsf\n    SDValue ConvVec = getInstr(Hexagon::V6_vconv_w_sf, dl, ResTy, {Op0}, DAG);\n    return ConvVec;\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：HVX向量浮点到整数转换使用复杂的展开代码，性能较低。优化后：在特定条件下（启用hexagon-fp-fast-convert选项时），直接使用硬件指令V6_vconv_h_hf和V6_vconv_w_sf进行快速转换。优化思路：为满足客户使用直接内在函数的需求，添加选项控制是否使用更快的非标准舍入模式转换，在V81架构上使用合规的舍入指令，在旧架构上通过选项启用快速转换。"}
{"id": 269, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+指令集优化", "optimization_description": "优化前：Hexagon架构缺乏对短向量操作的扩展指令支持，导致向量运算需要拆分为多个标量操作或使用低效的通用LLVM内部函数。优化后：引入Hexagon特定的向量扩展内部函数（如vadd_su、vsub_uu、vmpy_ss等），支持有符号/无符号混合模式的向量加、减、乘操作，通过LLVMTruncatedType实现操作数自动扩展。优化思路：1. 创建Hexagon_widenvec_Intrinsic基类定义扩展向量操作模式；2. 添加具体扩展向量内部函数，支持短向量到宽向量的转换；3. 配合新增的HexagonGenWideningVecInstr和HexagonGenWideningVecFloatInstr传递，在指令选择阶段将内部函数转换为高效的Hexagon硬件指令；4. 通过HexagonOptShuffleVector传递优化shufflevector指令，确保扩展过程中的数据重排正确性。", "original_code": "Hexagon架构缺乏对短向量操作的扩展指令支持，导致向量运算需要拆分为多个标量操作或使用低效的通用LLVM内部函数。", "optimized_code": "class Hexagon_widenvec_Intrinsic\n  : Hexagon_NonGCC_Intrinsic<\n       [llvm_anyvector_ty],\n       [LLVMTruncatedType<0>, LLVMTruncatedType<0>],\n       [IntrNoMem]>;\n\n// Widening vector add\ndef int_hexagon_vadd_su: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vadd_uu: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vadd_ss: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vadd_us: Hexagon_widenvec_Intrinsic;\n\n// Widening vector subtract\ndef int_hexagon_vsub_su: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vsub_uu: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vsub_ss: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vsub_us: Hexagon_widenvec_Intrinsic;\n\n// Widening vector multiply\ndef int_hexagon_vmpy_su: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vmpy_uu: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vmpy_ss: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vmpy_us: Hexagon_widenvec_Intrinsic;", "source_url": "https://github.com/llvm/llvm-project/commit/4da31b6f579925e17314ad2de2826dc171cd95f4", "code_v0_no_empty_lines": "Hexagon架构缺乏对短向量操作的扩展指令支持，导致向量运算需要拆分为多个标量操作或使用低效的通用LLVM内部函数。", "code_v1_no_empty_lines": "class Hexagon_widenvec_Intrinsic\n  : Hexagon_NonGCC_Intrinsic<\n       [llvm_anyvector_ty],\n       [LLVMTruncatedType<0>, LLVMTruncatedType<0>],\n       [IntrNoMem]>;\n\n// Widening vector add\ndef int_hexagon_vadd_su: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vadd_uu: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vadd_ss: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vadd_us: Hexagon_widenvec_Intrinsic;\n\n// Widening vector subtract\ndef int_hexagon_vsub_su: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vsub_uu: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vsub_ss: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vsub_us: Hexagon_widenvec_Intrinsic;\n\n// Widening vector multiply\ndef int_hexagon_vmpy_su: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vmpy_uu: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vmpy_ss: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vmpy_us: Hexagon_widenvec_Intrinsic;", "target": "class Hexagon_widenvec_Intrinsic\n  : Hexagon_NonGCC_Intrinsic<\n       [llvm_anyvector_ty],\n       [LLVMTruncatedType<0>, LLVMTruncatedType<0>],\n       [IntrNoMem]>;\n\n// Widening vector add\ndef int_hexagon_vadd_su: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vadd_uu: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vadd_ss: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vadd_us: Hexagon_widenvec_Intrinsic;\n\n// Widening vector subtract\ndef int_hexagon_vsub_su: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vsub_uu: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vsub_ss: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vsub_us: Hexagon_widenvec_Intrinsic;\n\n// Widening vector multiply\ndef int_hexagon_vmpy_su: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vmpy_uu: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vmpy_ss: Hexagon_widenvec_Intrinsic;\ndef int_hexagon_vmpy_us: Hexagon_widenvec_Intrinsic;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Hexagon架构缺乏对短向量操作的扩展指令支持，导致向量运算需要拆分为多个标量操作或使用低效的通用LLVM内部函数。优化后：引入Hexagon特定的向量扩展内部函数（如vadd_su、vsub_uu、vmpy_ss等），支持有符号/无符号混合模式的向量加、减、乘操作，通过LLVMTruncatedType实现操作数自动扩展。优化思路：1. 创建Hexagon_widenvec_Intrinsic基类定义扩展向量操作模式；2. 添加具体扩展向量内部函数，支持短向量到宽向量的转换；3. 配合新增的HexagonGenWideningVecInstr和HexagonGenWideningVecFloatInstr传递，在指令选择阶段将内部函数转换为高效的Hexagon硬件指令；4. 通过HexagonOptShuffleVector传递优化shufflevector指令，确保扩展过程中的数据重排正确性。"}
{"id": 270, "source": "riscv-dataset-excel", "optimization_type": "内存对齐优化", "optimization_description": "优化前：TMA批量存储操作中，源共享内存指针未设置对齐，可能导致性能下降或硬件错误。优化后：为TMA批量存储操作的源共享内存指针添加16字节对齐，与批量加载操作保持一致。优化思路：确保共享内存对齐符合CUDA TMA（Tensor Memory Accelerator）硬件要求，避免未对齐访问导致的性能损失或运行时错误，提高代码健壮性和性能。", "original_code": "TMA批量存储操作中，源共享内存指针未设置对齐，可能导致性能下降或硬件错误。", "optimized_code": "+static constexpr unsigned kTMAAlignment = 16;\n-setAlignment(dst, 16);\n+setAlignment(dst, kTMAAlignment);\n+setAlignment(src, kTMAAlignment);", "source_url": "https://github.com/llvm/llvm-project/commit/848d8657aec798b2630b8dfb57c009e7060d6d49", "code_v0_no_empty_lines": "TMA批量存储操作中，源共享内存指针未设置对齐，可能导致性能下降或硬件错误。", "code_v1_no_empty_lines": "+static constexpr unsigned kTMAAlignment = 16;\n-setAlignment(dst, 16);\n+setAlignment(dst, kTMAAlignment);\n+setAlignment(src, kTMAAlignment);", "target": "+static constexpr unsigned kTMAAlignment = 16;\n-setAlignment(dst, 16);\n+setAlignment(dst, kTMAAlignment);\n+setAlignment(src, kTMAAlignment);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：TMA批量存储操作中，源共享内存指针未设置对齐，可能导致性能下降或硬件错误。优化后：为TMA批量存储操作的源共享内存指针添加16字节对齐，与批量加载操作保持一致。优化思路：确保共享内存对齐符合CUDA TMA（Tensor Memory Accelerator）硬件要求，避免未对齐访问导致的性能损失或运行时错误，提高代码健壮性和性能。"}
{"id": 271, "source": "riscv-dataset-excel", "optimization_type": "CUDA内存访问优化", "optimization_description": "优化前：在TMA批量加载操作中，对源地址(src)和目标地址(dst)使用convertPtrToNVVMSpace函数转换为NVVM共享内存空间指针(!llvm.ptr<3>)，这会引入额外的内存空间转换开销。优化后：直接使用builder.createConvert将地址转换为通用的LLVM指针类型(!llvm.ptr)，移除了不必要的内存空间转换。优化思路：TMA批量加载指令本身支持通用指针操作，无需显式指定共享内存空间，简化指针转换过程，减少指令开销，提高CUDA内核性能。", "original_code": "在TMA批量加载操作中，对源地址(src)和目标地址(dst)使用convertPtrToNVVMSpace函数转换为NVVM共享内存空间指针(!llvm.ptr<3>)，这会引入额外的内存空间转换开销。", "optimized_code": "-  dst = convertPtrToNVVMSpace(builder, loc, dst,\n-                              mlir::NVVM::NVVMMemorySpace::Shared);\n-  src = convertPtrToNVVMSpace(builder, loc, src,\n-                              mlir::NVVM::NVVMMemorySpace::Shared);\n+  dst = builder.createConvert(loc, llvmPtrTy, dst);\n+  src = builder.createConvert(loc, llvmPtrTy, src);", "source_url": "https://github.com/llvm/llvm-project/commit/e52aece16b98a2fba9b84f411bd4c5f35dfe60c1", "code_v0_no_empty_lines": "在TMA批量加载操作中，对源地址(src)和目标地址(dst)使用convertPtrToNVVMSpace函数转换为NVVM共享内存空间指针(!llvm.ptr<3>)，这会引入额外的内存空间转换开销。", "code_v1_no_empty_lines": "-  dst = convertPtrToNVVMSpace(builder, loc, dst,\n-                              mlir::NVVM::NVVMMemorySpace::Shared);\n-  src = convertPtrToNVVMSpace(builder, loc, src,\n-                              mlir::NVVM::NVVMMemorySpace::Shared);\n+  dst = builder.createConvert(loc, llvmPtrTy, dst);\n+  src = builder.createConvert(loc, llvmPtrTy, src);", "target": "-  dst = convertPtrToNVVMSpace(builder, loc, dst,\n-                              mlir::NVVM::NVVMMemorySpace::Shared);\n-  src = convertPtrToNVVMSpace(builder, loc, src,\n-                              mlir::NVVM::NVVMMemorySpace::Shared);\n+  dst = builder.createConvert(loc, llvmPtrTy, dst);\n+  src = builder.createConvert(loc, llvmPtrTy, src);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在TMA批量加载操作中，对源地址(src)和目标地址(dst)使用convertPtrToNVVMSpace函数转换为NVVM共享内存空间指针(!llvm.ptr<3>)，这会引入额外的内存空间转换开销。优化后：直接使用builder.createConvert将地址转换为通用的LLVM指针类型(!llvm.ptr)，移除了不必要的内存空间转换。优化思路：TMA批量加载指令本身支持通用指针操作，无需显式指定共享内存空间，简化指针转换过程，减少指令开销，提高CUDA内核性能。"}
{"id": 272, "source": "riscv-dataset-excel", "optimization_type": "调度模型优化", "optimization_description": "优化前：RISCV SpacemiT-X60调度模型中的向量加载/存储指令使用默认或估计的延迟和占用周期值，未基于硬件实测数据。优化后：为所有RVV向量加载/存储指令（包括单位步长、跨步、索引、分段和全寄存器操作）添加了基于硬件实测的延迟和占用周期值，通过新定义的类（如SMX60GetLMulCycles、SMX60GetVLMAX、SMX60SegmentedLdStCycles）和变量（如VLDELatAndOcc）精确计算。优化思路：利用硬件测量数据更新调度模型，使编译器能更准确地预测指令执行时间，从而生成更优化的指令调度，提升代码性能。", "original_code": "RISCV SpacemiT-X60调度模型中的向量加载/存储指令使用默认或估计的延迟和占用周期值，未基于硬件实测数据。", "optimized_code": "defvar VLDELatAndOcc = ConstValueUntilLMULThenDoubleBase<\"M2\", 3, 4, mx>.c;\nlet Latency = VLDELatAndOcc, ReleaseAtCycles = [VLDELatAndOcc] in {\n    defm \"\" : LMULWriteResMX<\"WriteVLDE\", [SMX60_VLS], mx, IsWorstCase>;\n}\ndefvar VSTELatAndOcc = GetLMULValue<[2, 2, 2, 3, 4, 8, 19], mx>.c;\nlet Latency = VSTELatAndOcc, ReleaseAtCycles = [VSTELatAndOcc] in {\n    defm \"\" : LMULWriteResMX<\"WriteVSTE\", [SMX60_VLS], mx, IsWorstCase>;\n}\ndefvar VLDFFLatAndOcc = GetLMULValue<[4, 4, 4, 5, 7, 11, 19], mx>.c;\nlet Latency = VLDFFLatAndOcc, ReleaseAtCycles = [VLDFFLatAndOcc] in {\n    defm \"\" : LMULWriteResMX<\"WriteVLDFF\", [SMX60_VLS], mx, IsWorstCase>;\n}", "source_url": "https://github.com/llvm/llvm-project/commit/3b9a0db2615871fe6a2ae0047e97eb99fd53987a", "code_v0_no_empty_lines": "RISCV SpacemiT-X60调度模型中的向量加载/存储指令使用默认或估计的延迟和占用周期值，未基于硬件实测数据。", "code_v1_no_empty_lines": "defvar VLDELatAndOcc = ConstValueUntilLMULThenDoubleBase<\"M2\", 3, 4, mx>.c;\nlet Latency = VLDELatAndOcc, ReleaseAtCycles = [VLDELatAndOcc] in {\n    defm \"\" : LMULWriteResMX<\"WriteVLDE\", [SMX60_VLS], mx, IsWorstCase>;\n}\ndefvar VSTELatAndOcc = GetLMULValue<[2, 2, 2, 3, 4, 8, 19], mx>.c;\nlet Latency = VSTELatAndOcc, ReleaseAtCycles = [VSTELatAndOcc] in {\n    defm \"\" : LMULWriteResMX<\"WriteVSTE\", [SMX60_VLS], mx, IsWorstCase>;\n}\ndefvar VLDFFLatAndOcc = GetLMULValue<[4, 4, 4, 5, 7, 11, 19], mx>.c;\nlet Latency = VLDFFLatAndOcc, ReleaseAtCycles = [VLDFFLatAndOcc] in {\n    defm \"\" : LMULWriteResMX<\"WriteVLDFF\", [SMX60_VLS], mx, IsWorstCase>;\n}", "target": "defvar VLDELatAndOcc = ConstValueUntilLMULThenDoubleBase<\"M2\", 3, 4, mx>.c;\nlet Latency = VLDELatAndOcc, ReleaseAtCycles = [VLDELatAndOcc] in {\n    defm \"\" : LMULWriteResMX<\"WriteVLDE\", [SMX60_VLS], mx, IsWorstCase>;\n}\ndefvar VSTELatAndOcc = GetLMULValue<[2, 2, 2, 3, 4, 8, 19], mx>.c;\nlet Latency = VSTELatAndOcc, ReleaseAtCycles = [VSTELatAndOcc] in {\n    defm \"\" : LMULWriteResMX<\"WriteVSTE\", [SMX60_VLS], mx, IsWorstCase>;\n}\ndefvar VLDFFLatAndOcc = GetLMULValue<[4, 4, 4, 5, 7, 11, 19], mx>.c;\nlet Latency = VLDFFLatAndOcc, ReleaseAtCycles = [VLDFFLatAndOcc] in {\n    defm \"\" : LMULWriteResMX<\"WriteVLDFF\", [SMX60_VLS], mx, IsWorstCase>;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISCV SpacemiT-X60调度模型中的向量加载/存储指令使用默认或估计的延迟和占用周期值，未基于硬件实测数据。优化后：为所有RVV向量加载/存储指令（包括单位步长、跨步、索引、分段和全寄存器操作）添加了基于硬件实测的延迟和占用周期值，通过新定义的类（如SMX60GetLMulCycles、SMX60GetVLMAX、SMX60SegmentedLdStCycles）和变量（如VLDELatAndOcc）精确计算。优化思路：利用硬件测量数据更新调度模型，使编译器能更准确地预测指令执行时间，从而生成更优化的指令调度，提升代码性能。"}
{"id": 273, "source": "riscv-dataset-excel", "optimization_type": "代码重构+接口简化", "optimization_description": "优化前：TTIImpl中维护了多个独立的masked/gather-scatter/strided/expand-compress内存操作成本计算接口，每个接口都需要单独实现和覆盖。优化后：将这些特定内存操作的成本计算统一整合到getMemIntrinsicCost方法中，通过switch-case根据操作类型分发计算。优化思路：简化TTI接口设计，减少代码重复，将标量化成本计算逻辑集中到BaseT::getMemIntrinsicCost中，允许后端通过重写单个方法来自定义所有相关内存操作的成本计算，提高代码可维护性和扩展性。", "original_code": "TTIImpl中维护了多个独立的masked/gather-scatter/strided/expand-compress内存操作成本计算接口，每个接口都需要单独实现和覆盖。", "optimized_code": "- virtual InstructionCost\n  getMaskedMemoryOpCost(const MemIntrinsicCostAttributes &MICA,\n                        TTI::TargetCostKind CostKind) const {\n    return 1;\n  }\n\n  virtual InstructionCost\n  getGatherScatterOpCost(const MemIntrinsicCostAttributes &MICA,\n                         TTI::TargetCostKind CostKind) const {\n    return 1;\n  }\n\n  virtual InstructionCost\n  getExpandCompressMemoryOpCost(const MemIntrinsicCostAttributes &MICA,\n                                TTI::TargetCostKind CostKind) const {\n    return 1;\n  }\n\n  virtual InstructionCost\n  getStridedMemoryOpCost(const MemIntrinsicCostAttributes &MICA,\n                         TTI::TargetCostKind CostKind) const {\n    return InstructionCost::getInvalid();\n  }\n\n  virtual InstructionCost\n  getMemIntrinsicInstrCost(const MemIntrinsicCostAttributes &MICA,\n                           TTI::TargetCostKind CostKind) const {\n    return 1;\n  }", "source_url": "https://github.com/llvm/llvm-project/commit/c2409b4bcaca6662f86f7c9956f27413a7aecf0e", "code_v0_no_empty_lines": "TTIImpl中维护了多个独立的masked/gather-scatter/strided/expand-compress内存操作成本计算接口，每个接口都需要单独实现和覆盖。", "code_v1_no_empty_lines": "- virtual InstructionCost\n  getMaskedMemoryOpCost(const MemIntrinsicCostAttributes &MICA,\n                        TTI::TargetCostKind CostKind) const {\n    return 1;\n  }\n\n  virtual InstructionCost\n  getGatherScatterOpCost(const MemIntrinsicCostAttributes &MICA,\n                         TTI::TargetCostKind CostKind) const {\n    return 1;\n  }\n\n  virtual InstructionCost\n  getExpandCompressMemoryOpCost(const MemIntrinsicCostAttributes &MICA,\n                                TTI::TargetCostKind CostKind) const {\n    return 1;\n  }\n\n  virtual InstructionCost\n  getStridedMemoryOpCost(const MemIntrinsicCostAttributes &MICA,\n                         TTI::TargetCostKind CostKind) const {\n    return InstructionCost::getInvalid();\n  }\n\n  virtual InstructionCost\n  getMemIntrinsicInstrCost(const MemIntrinsicCostAttributes &MICA,\n                           TTI::TargetCostKind CostKind) const {\n    return 1;\n  }", "target": "- virtual InstructionCost\n  getMaskedMemoryOpCost(const MemIntrinsicCostAttributes &MICA,\n                        TTI::TargetCostKind CostKind) const {\n    return 1;\n  }\n\n  virtual InstructionCost\n  getGatherScatterOpCost(const MemIntrinsicCostAttributes &MICA,\n                         TTI::TargetCostKind CostKind) const {\n    return 1;\n  }\n\n  virtual InstructionCost\n  getExpandCompressMemoryOpCost(const MemIntrinsicCostAttributes &MICA,\n                                TTI::TargetCostKind CostKind) const {\n    return 1;\n  }\n\n  virtual InstructionCost\n  getStridedMemoryOpCost(const MemIntrinsicCostAttributes &MICA,\n                         TTI::TargetCostKind CostKind) const {\n    return InstructionCost::getInvalid();\n  }\n\n  virtual InstructionCost\n  getMemIntrinsicInstrCost(const MemIntrinsicCostAttributes &MICA,\n                           TTI::TargetCostKind CostKind) const {\n    return 1;\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：TTIImpl中维护了多个独立的masked/gather-scatter/strided/expand-compress内存操作成本计算接口，每个接口都需要单独实现和覆盖。优化后：将这些特定内存操作的成本计算统一整合到getMemIntrinsicCost方法中，通过switch-case根据操作类型分发计算。优化思路：简化TTI接口设计，减少代码重复，将标量化成本计算逻辑集中到BaseT::getMemIntrinsicCost中，允许后端通过重写单个方法来自定义所有相关内存操作的成本计算，提高代码可维护性和扩展性。"}
{"id": 274, "source": "riscv-dataset-excel", "optimization_type": "内存安全优化+指令优化", "optimization_description": "优化前：InstCombine的foldPHIArgLoadIntoPHI优化会尝试将phi节点的load参数合并，但未考虑llvm.protected.field.ptr保护指针的情况，可能导致保护指针地址泄露。优化后：1. 修改foldPHIArgLoadIntoPHI函数，统一使用canReplaceOperandWithVariable检查操作数是否可替换；2. 在canReplaceOperandWithVariable函数中添加对protected_field_ptr内禀的检查，阻止通过phi节点进行load/store折叠。优化思路：确保保护指针字段的load/store操作始终与对应的内禀调用配对，避免不必要的地址逃逸，增强内存安全性。", "original_code": "InstCombine的foldPHIArgLoadIntoPHI优化会尝试将phi节点的load参数合并，但未考虑llvm.protected.field.ptr保护指针的情况，可能导致保护指针地址泄露。", "optimized_code": "--- a/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp\n@@ -698,8 +698,7 @@ static bool isSafeAndProfitableToSinkLoad(LoadInst *L) {\n Instruction *InstCombinerImpl::foldPHIArgLoadIntoPHI(PHINode &PN) {\n   LoadInst *FirstLI = cast<LoadInst>(PN.getIncomingValue(0));\n \n-  // Can't forward swifterror through a phi.\n-  if (FirstLI->getOperand(0)->isSwiftError())\n+  if (!canReplaceOperandWithVariable(FirstLI, 0))\n     return nullptr;\n \n   // FIXME: This is overconservative; this transform is allowed in some cases\n@@ -738,8 +737,7 @@ Instruction *InstCombinerImpl::foldPHIArgLoadIntoPHI(PHINode &PN) {\n         LI->getPointerAddressSpace() != LoadAddrSpace)\n       return nullptr;\n \n-    // Can't forward swifterror through a phi.\n-    if (LI->getOperand(0)->isSwiftError())\n+    if (!canReplaceOperandWithVariable(LI, 0))\n       return nullptr;\n \n     // We can't sink the load if the loaded value could be modified between\n--- a/llvm/lib/Transforms/Utils/Local.cpp\n+++ b/llvm/lib/Transforms/Utils/Local.cpp\n@@ -3884,6 +3884,12 @@ bool llvm::canReplaceOperandWithVariable(const Instruction *I, unsigned OpIdx) {\n   if (Op->isSwiftError())\n     return false;\n \n+  // Protected pointer field loads/stores should be paired with the intrinsic\n+  // to avoid unnecessary address escapes.\n+  if (auto *II = dyn_cast<IntrinsicInst>(Op))\n+    if (II->getIntrinsicID() == Intrinsic::protected_field_ptr)\n+      return false;\n+\n   // Cannot replace alloca argument with phi/select.\n   if (I->isLifetimeStartOrEnd())\n     return false;", "source_url": "https://github.com/llvm/llvm-project/commit/e60d62b90f83210f43816fb528e6557ab1770683", "code_v0_no_empty_lines": "InstCombine的foldPHIArgLoadIntoPHI优化会尝试将phi节点的load参数合并，但未考虑llvm.protected.field.ptr保护指针的情况，可能导致保护指针地址泄露。", "code_v1_no_empty_lines": "--- a/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp\n@@ -698,8 +698,7 @@ static bool isSafeAndProfitableToSinkLoad(LoadInst *L) {\n Instruction *InstCombinerImpl::foldPHIArgLoadIntoPHI(PHINode &PN) {\n   LoadInst *FirstLI = cast<LoadInst>(PN.getIncomingValue(0));\n \n-  // Can't forward swifterror through a phi.\n-  if (FirstLI->getOperand(0)->isSwiftError())\n+  if (!canReplaceOperandWithVariable(FirstLI, 0))\n     return nullptr;\n \n   // FIXME: This is overconservative; this transform is allowed in some cases\n@@ -738,8 +737,7 @@ Instruction *InstCombinerImpl::foldPHIArgLoadIntoPHI(PHINode &PN) {\n         LI->getPointerAddressSpace() != LoadAddrSpace)\n       return nullptr;\n \n-    // Can't forward swifterror through a phi.\n-    if (LI->getOperand(0)->isSwiftError())\n+    if (!canReplaceOperandWithVariable(LI, 0))\n       return nullptr;\n \n     // We can't sink the load if the loaded value could be modified between\n--- a/llvm/lib/Transforms/Utils/Local.cpp\n+++ b/llvm/lib/Transforms/Utils/Local.cpp\n@@ -3884,6 +3884,12 @@ bool llvm::canReplaceOperandWithVariable(const Instruction *I, unsigned OpIdx) {\n   if (Op->isSwiftError())\n     return false;\n \n+  // Protected pointer field loads/stores should be paired with the intrinsic\n+  // to avoid unnecessary address escapes.\n+  if (auto *II = dyn_cast<IntrinsicInst>(Op))\n+    if (II->getIntrinsicID() == Intrinsic::protected_field_ptr)\n+      return false;\n+\n   // Cannot replace alloca argument with phi/select.\n   if (I->isLifetimeStartOrEnd())\n     return false;", "target": "--- a/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp\n@@ -698,8 +698,7 @@ static bool isSafeAndProfitableToSinkLoad(LoadInst *L) {\n Instruction *InstCombinerImpl::foldPHIArgLoadIntoPHI(PHINode &PN) {\n   LoadInst *FirstLI = cast<LoadInst>(PN.getIncomingValue(0));\n \n-  // Can't forward swifterror through a phi.\n-  if (FirstLI->getOperand(0)->isSwiftError())\n+  if (!canReplaceOperandWithVariable(FirstLI, 0))\n     return nullptr;\n \n   // FIXME: This is overconservative; this transform is allowed in some cases\n@@ -738,8 +737,7 @@ Instruction *InstCombinerImpl::foldPHIArgLoadIntoPHI(PHINode &PN) {\n         LI->getPointerAddressSpace() != LoadAddrSpace)\n       return nullptr;\n \n-    // Can't forward swifterror through a phi.\n-    if (LI->getOperand(0)->isSwiftError())\n+    if (!canReplaceOperandWithVariable(LI, 0))\n       return nullptr;\n \n     // We can't sink the load if the loaded value could be modified between\n--- a/llvm/lib/Transforms/Utils/Local.cpp\n+++ b/llvm/lib/Transforms/Utils/Local.cpp\n@@ -3884,6 +3884,12 @@ bool llvm::canReplaceOperandWithVariable(const Instruction *I, unsigned OpIdx) {\n   if (Op->isSwiftError())\n     return false;\n \n+  // Protected pointer field loads/stores should be paired with the intrinsic\n+  // to avoid unnecessary address escapes.\n+  if (auto *II = dyn_cast<IntrinsicInst>(Op))\n+    if (II->getIntrinsicID() == Intrinsic::protected_field_ptr)\n+      return false;\n+\n   // Cannot replace alloca argument with phi/select.\n   if (I->isLifetimeStartOrEnd())\n     return false;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：InstCombine的foldPHIArgLoadIntoPHI优化会尝试将phi节点的load参数合并，但未考虑llvm.protected.field.ptr保护指针的情况，可能导致保护指针地址泄露。优化后：1. 修改foldPHIArgLoadIntoPHI函数，统一使用canReplaceOperandWithVariable检查操作数是否可替换；2. 在canReplaceOperandWithVariable函数中添加对protected_field_ptr内禀的检查，阻止通过phi节点进行load/store折叠。优化思路：确保保护指针字段的load/store操作始终与对应的内禀调用配对，避免不必要的地址逃逸，增强内存安全性。"}
{"id": 275, "source": "riscv-dataset-excel", "optimization_type": "算法优化+计算复杂度优化", "optimization_description": "优化前：在计算变量边界时，Fourier-Motzkin消元和Gaussian消元会对所有约束进行重复计算，包括与目标变量无关的约束，导致不必要的计算开销。优化后：通过图遍历算法识别约束图中的连通分量，在计算变量边界前预先剪枝与目标变量正交（无关）的约束，减少后续消元计算的数据规模。优化思路：将约束系统建模为无向图（变量为节点，约束为边），利用连通分量原理识别无关约束，在bound computation前进行两次剪枝（投影前和投影后），显著减少计算复杂度。", "original_code": "在计算变量边界时，Fourier-Motzkin消元和Gaussian消元会对所有约束进行重复计算，包括与目标变量无关的约束，导致不必要的计算开销。", "optimized_code": "void IntegerRelation::pruneOrthogonalConstraints(unsigned pos) {\n  llvm::DenseSet<unsigned> relatedCols({pos}), relatedRows;\n  \n  // Early exit if constraints is empty.\n  unsigned numConstraints = getNumConstraints();\n  if (numConstraints == 0)\n    return;\n  \n  llvm::SmallVector<unsigned> rowStack, colStack({pos});\n  // The following code performs a graph traversal, starting from the target\n  // variable, to identify all variables(recorded in relatedCols) and\n  // constraints (recorded in relatedRows) belonging to the same connected\n  // component.\n  while (!rowStack.empty() || !colStack.empty()) {\n    if (!rowStack.empty()) {\n      unsigned currentRow = rowStack.pop_back_val();\n      // Push all variable that accociated to this constraints to relatedCols\n      // and colStack.\n      for (unsigned colIndex = 0; colIndex < getNumVars(); ++colIndex) {\n        if (atConstraint(currentRow, colIndex) != 0 &&\n            relatedCols.insert(colIndex).second) {\n          colStack.push_back(colIndex);\n        }\n      }\n    } else {\n      unsigned currentCol = colStack.pop_back_val();\n      // Push all constraints that are associated with this variable to related\n      // rows and the row stack.\n      for (unsigned rowIndex = 0; rowIndex < numConstraints; ++rowIndex) {\n        if (atConstraint(rowIndex, currentCol) != 0 &&\n            relatedRows.insert(rowIndex).second) {\n          rowStack.push_back(rowIndex);\n        }\n      }\n    }\n  }\n  \n  // Prune all constraints not related to target variable.\n  for (int constraintId = numConstraints - 1; constraintId >= 0;\n       --constraintId) {\n    if (!relatedRows.contains(constraintId))\n      removeConstraint((unsigned)constraintId);\n  }\n}", "source_url": "https://github.com/llvm/llvm-project/commit/dc0fa08d336a505dffa8445c5e19e508806c38d3", "code_v0_no_empty_lines": "在计算变量边界时，Fourier-Motzkin消元和Gaussian消元会对所有约束进行重复计算，包括与目标变量无关的约束，导致不必要的计算开销。", "code_v1_no_empty_lines": "void IntegerRelation::pruneOrthogonalConstraints(unsigned pos) {\n  llvm::DenseSet<unsigned> relatedCols({pos}), relatedRows;\n  \n  // Early exit if constraints is empty.\n  unsigned numConstraints = getNumConstraints();\n  if (numConstraints == 0)\n    return;\n  \n  llvm::SmallVector<unsigned> rowStack, colStack({pos});\n  // The following code performs a graph traversal, starting from the target\n  // variable, to identify all variables(recorded in relatedCols) and\n  // constraints (recorded in relatedRows) belonging to the same connected\n  // component.\n  while (!rowStack.empty() || !colStack.empty()) {\n    if (!rowStack.empty()) {\n      unsigned currentRow = rowStack.pop_back_val();\n      // Push all variable that accociated to this constraints to relatedCols\n      // and colStack.\n      for (unsigned colIndex = 0; colIndex < getNumVars(); ++colIndex) {\n        if (atConstraint(currentRow, colIndex) != 0 &&\n            relatedCols.insert(colIndex).second) {\n          colStack.push_back(colIndex);\n        }\n      }\n    } else {\n      unsigned currentCol = colStack.pop_back_val();\n      // Push all constraints that are associated with this variable to related\n      // rows and the row stack.\n      for (unsigned rowIndex = 0; rowIndex < numConstraints; ++rowIndex) {\n        if (atConstraint(rowIndex, currentCol) != 0 &&\n            relatedRows.insert(rowIndex).second) {\n          rowStack.push_back(rowIndex);\n        }\n      }\n    }\n  }\n  \n  // Prune all constraints not related to target variable.\n  for (int constraintId = numConstraints - 1; constraintId >= 0;\n       --constraintId) {\n    if (!relatedRows.contains(constraintId))\n      removeConstraint((unsigned)constraintId);\n  }\n}", "target": "void IntegerRelation::pruneOrthogonalConstraints(unsigned pos) {\n  llvm::DenseSet<unsigned> relatedCols({pos}), relatedRows;\n  \n  // Early exit if constraints is empty.\n  unsigned numConstraints = getNumConstraints();\n  if (numConstraints == 0)\n    return;\n  \n  llvm::SmallVector<unsigned> rowStack, colStack({pos});\n  // The following code performs a graph traversal, starting from the target\n  // variable, to identify all variables(recorded in relatedCols) and\n  // constraints (recorded in relatedRows) belonging to the same connected\n  // component.\n  while (!rowStack.empty() || !colStack.empty()) {\n    if (!rowStack.empty()) {\n      unsigned currentRow = rowStack.pop_back_val();\n      // Push all variable that accociated to this constraints to relatedCols\n      // and colStack.\n      for (unsigned colIndex = 0; colIndex < getNumVars(); ++colIndex) {\n        if (atConstraint(currentRow, colIndex) != 0 &&\n            relatedCols.insert(colIndex).second) {\n          colStack.push_back(colIndex);\n        }\n      }\n    } else {\n      unsigned currentCol = colStack.pop_back_val();\n      // Push all constraints that are associated with this variable to related\n      // rows and the row stack.\n      for (unsigned rowIndex = 0; rowIndex < numConstraints; ++rowIndex) {\n        if (atConstraint(rowIndex, currentCol) != 0 &&\n            relatedRows.insert(rowIndex).second) {\n          rowStack.push_back(rowIndex);\n        }\n      }\n    }\n  }\n  \n  // Prune all constraints not related to target variable.\n  for (int constraintId = numConstraints - 1; constraintId >= 0;\n       --constraintId) {\n    if (!relatedRows.contains(constraintId))\n      removeConstraint((unsigned)constraintId);\n  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在计算变量边界时，Fourier-Motzkin消元和Gaussian消元会对所有约束进行重复计算，包括与目标变量无关的约束，导致不必要的计算开销。优化后：通过图遍历算法识别约束图中的连通分量，在计算变量边界前预先剪枝与目标变量正交（无关）的约束，减少后续消元计算的数据规模。优化思路：将约束系统建模为无向图（变量为节点，约束为边），利用连通分量原理识别无关约束，在bound computation前进行两次剪枝（投影前和投影后），显著减少计算复杂度。"}
{"id": 276, "source": "riscv-dataset-excel", "optimization_type": "指令优化+代码简化", "optimization_description": "优化前：sve.dup(V, all_active, S) 需要处理谓词参数。优化后：当谓词为 all_active 时，直接转换为 splat(S) 指令，简化了操作。思路：识别全激活谓词的特殊情况，用更高效的向量广播指令替代通用复制操作，同时重构代码使用 match 模式简化逻辑。", "original_code": "sve.dup(V, all_active, S) 需要处理谓词参数。", "optimized_code": "// sve.dup(V, all_active, X) ==> splat(X)\n  if (isAllActivePredicate(Pg)) {\n    auto *RetTy = cast<ScalableVectorType>(II.getType());\n    Value *Splat = IC.Builder.CreateVectorSplat(RetTy->getElementCount(),\n                                                II.getArgOperand(2));\n    return IC.replaceInstUsesWith(II, Splat);\n  }", "source_url": "https://github.com/llvm/llvm-project/commit/b4b369a6bf2d9103bac619172ee1bdec992d6730", "code_v0_no_empty_lines": "sve.dup(V, all_active, S) 需要处理谓词参数。", "code_v1_no_empty_lines": "// sve.dup(V, all_active, X) ==> splat(X)\n  if (isAllActivePredicate(Pg)) {\n    auto *RetTy = cast<ScalableVectorType>(II.getType());\n    Value *Splat = IC.Builder.CreateVectorSplat(RetTy->getElementCount(),\n                                                II.getArgOperand(2));\n    return IC.replaceInstUsesWith(II, Splat);\n  }", "target": "// sve.dup(V, all_active, X) ==> splat(X)\n  if (isAllActivePredicate(Pg)) {\n    auto *RetTy = cast<ScalableVectorType>(II.getType());\n    Value *Splat = IC.Builder.CreateVectorSplat(RetTy->getElementCount(),\n                                                II.getArgOperand(2));\n    return IC.replaceInstUsesWith(II, Splat);\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：sve.dup(V, all_active, S) 需要处理谓词参数。优化后：当谓词为 all_active 时，直接转换为 splat(S) 指令，简化了操作。思路：识别全激活谓词的特殊情况，用更高效的向量广播指令替代通用复制操作，同时重构代码使用 match 模式简化逻辑。"}
{"id": 277, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化+谓词保持优化", "optimization_description": "优化前：aarch64.sve.[s,u]abd.u 内在函数被降级为无谓词的 ISD::ABDS/ABDU 节点，丢失了谓词信息，导致生成的汇编代码中需要插入额外的 ptrue 指令来设置全真谓词。优化后：通过 convertMergedOpToPredOp 尝试转换为谓词操作，如果失败则直接生成 AArch64ISD::ABDS_PRED/ABDU_PRED 节点，保持原有的谓词操作数。优化思路：在指令选择阶段维护谓词信息，避免生成不必要的 ptrue 指令，减少指令数量和执行开销，提高 SVE 向量操作的性能。", "original_code": "aarch64.sve.[s,u]abd.u 内在函数被降级为无谓词的 ISD::ABDS/ABDU 节点，丢失了谓词信息，导致生成的汇编代码中需要插入额外的 ptrue 指令来设置全真谓词。", "optimized_code": "case Intrinsic::aarch64_sve_sabd_u:\n-    return DAG.getNode(ISD::ABDS, SDLoc(N), N->getValueType(0),\n-                       N->getOperand(2), N->getOperand(3));\n+    if (SDValue V = convertMergedOpToPredOp(N, ISD::ABDS, DAG, true))\n+      return V;\n+    return DAG.getNode(AArch64ISD::ABDS_PRED, SDLoc(N), N->getValueType(0),\n+                       N->getOperand(1), N->getOperand(2), N->getOperand(3));\n   case Intrinsic::aarch64_sve_uabd_u:\n-    return DAG.getNode(ISD::ABDU, SDLoc(N), N->getValueType(0),\n-                       N->getOperand(2), N->getOperand(3));\n+    if (SDValue V = convertMergedOpToPredOp(N, ISD::ABDU, DAG, true))\n+      return V;\n+    return DAG.getNode(AArch64ISD::ABDU_PRED, SDLoc(N), N->getValueType(0),\n+                       N->getOperand(1), N->getOperand(2), N->getOperand(3));", "source_url": "https://github.com/llvm/llvm-project/commit/adb7275995ba84cc4ee79fe7b670af2b504a0e6c", "code_v0_no_empty_lines": "aarch64.sve.[s,u]abd.u 内在函数被降级为无谓词的 ISD::ABDS/ABDU 节点，丢失了谓词信息，导致生成的汇编代码中需要插入额外的 ptrue 指令来设置全真谓词。", "code_v1_no_empty_lines": "case Intrinsic::aarch64_sve_sabd_u:\n-    return DAG.getNode(ISD::ABDS, SDLoc(N), N->getValueType(0),\n-                       N->getOperand(2), N->getOperand(3));\n+    if (SDValue V = convertMergedOpToPredOp(N, ISD::ABDS, DAG, true))\n+      return V;\n+    return DAG.getNode(AArch64ISD::ABDS_PRED, SDLoc(N), N->getValueType(0),\n+                       N->getOperand(1), N->getOperand(2), N->getOperand(3));\n   case Intrinsic::aarch64_sve_uabd_u:\n-    return DAG.getNode(ISD::ABDU, SDLoc(N), N->getValueType(0),\n-                       N->getOperand(2), N->getOperand(3));\n+    if (SDValue V = convertMergedOpToPredOp(N, ISD::ABDU, DAG, true))\n+      return V;\n+    return DAG.getNode(AArch64ISD::ABDU_PRED, SDLoc(N), N->getValueType(0),\n+                       N->getOperand(1), N->getOperand(2), N->getOperand(3));", "target": "case Intrinsic::aarch64_sve_sabd_u:\n-    return DAG.getNode(ISD::ABDS, SDLoc(N), N->getValueType(0),\n-                       N->getOperand(2), N->getOperand(3));\n+    if (SDValue V = convertMergedOpToPredOp(N, ISD::ABDS, DAG, true))\n+      return V;\n+    return DAG.getNode(AArch64ISD::ABDS_PRED, SDLoc(N), N->getValueType(0),\n+                       N->getOperand(1), N->getOperand(2), N->getOperand(3));\n   case Intrinsic::aarch64_sve_uabd_u:\n-    return DAG.getNode(ISD::ABDU, SDLoc(N), N->getValueType(0),\n-                       N->getOperand(2), N->getOperand(3));\n+    if (SDValue V = convertMergedOpToPredOp(N, ISD::ABDU, DAG, true))\n+      return V;\n+    return DAG.getNode(AArch64ISD::ABDU_PRED, SDLoc(N), N->getValueType(0),\n+                       N->getOperand(1), N->getOperand(2), N->getOperand(3));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：aarch64.sve.[s,u]abd.u 内在函数被降级为无谓词的 ISD::ABDS/ABDU 节点，丢失了谓词信息，导致生成的汇编代码中需要插入额外的 ptrue 指令来设置全真谓词。优化后：通过 convertMergedOpToPredOp 尝试转换为谓词操作，如果失败则直接生成 AArch64ISD::ABDS_PRED/ABDU_PRED 节点，保持原有的谓词操作数。优化思路：在指令选择阶段维护谓词信息，避免生成不必要的 ptrue 指令，减少指令数量和执行开销，提高 SVE 向量操作的性能。"}
{"id": 278, "source": "riscv-dataset-excel", "optimization_type": "指令调度优化", "optimization_description": "优化前：所有带有FLAT标志的指令（包括LDS DMA指令）都被视为flat内存操作，需要创建pending flat事件，导致不必要的waitcnt(0)等待指令插入。优化后：通过添加!SIInstrInfo::isLDSDMA(Inst)条件，将LDS DMA指令排除在flat操作处理之外，避免为这些指令创建不必要的pending flat事件。优化思路：LDS DMA指令虽然设置了FLAT标志，但实际只更新VM_CNT计数器，不需要像真正的flat指令那样同时等待VMEM和LDS访问完成，因此可以优化调度以减少不必要的等待指令。", "original_code": "所有带有FLAT标志的指令（包括LDS DMA指令）都被视为flat内存操作，需要创建pending flat事件，导致不必要的waitcnt(0)等待指令插入。", "optimized_code": "-    if (FlatASCount > 1)\n+    if (!SIInstrInfo::isLDSDMA(Inst) && FlatASCount > 1)", "source_url": "https://github.com/llvm/llvm-project/commit/cb8ce283e173464b2c8ea833c279cfaec8a2350b", "code_v0_no_empty_lines": "所有带有FLAT标志的指令（包括LDS DMA指令）都被视为flat内存操作，需要创建pending flat事件，导致不必要的waitcnt(0)等待指令插入。", "code_v1_no_empty_lines": "-    if (FlatASCount > 1)\n+    if (!SIInstrInfo::isLDSDMA(Inst) && FlatASCount > 1)", "target": "-    if (FlatASCount > 1)\n+    if (!SIInstrInfo::isLDSDMA(Inst) && FlatASCount > 1)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：所有带有FLAT标志的指令（包括LDS DMA指令）都被视为flat内存操作，需要创建pending flat事件，导致不必要的waitcnt(0)等待指令插入。优化后：通过添加!SIInstrInfo::isLDSDMA(Inst)条件，将LDS DMA指令排除在flat操作处理之外，避免为这些指令创建不必要的pending flat事件。优化思路：LDS DMA指令虽然设置了FLAT标志，但实际只更新VM_CNT计数器，不需要像真正的flat指令那样同时等待VMEM和LDS访问完成，因此可以优化调度以减少不必要的等待指令。"}
{"id": 279, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：vmerge_vl指令在掩码为全1时仍执行合并操作，vmv_v_v指令在源操作数为splat时仍执行向量复制。优化后：1. 当vmerge_vl的掩码为全1时，直接转换为vmv_v_v指令，避免不必要的合并操作；2. 当vmv_v_v的源操作数为splat（广播）时，转换为vmv_v_x指令，直接使用标量值进行广播。优化思路：通过模式匹配识别可简化的指令序列，将复杂的向量操作转换为更高效的专用指令，减少指令数量和执行开销，为后续移除llvm.experimental.vp.splat内在函数做准备。", "original_code": "vmerge_vl指令在掩码为全1时仍执行合并操作，vmv_v_v指令在源操作数为splat时仍执行向量复制。", "optimized_code": "case RISCVISD::VMERGE_VL: {\n    // vmerge_vl allones, x, y, passthru, vl -> vmv_v_v passthru, x, vl\n    SDValue Mask = N->getOperand(0);\n    SDValue True = N->getOperand(1);\n    SDValue Passthru = N->getOperand(3);\n    SDValue VL = N->getOperand(4);\n\n    // Fixed vectors are wrapped in scalable containers, unwrap them.\n    using namespace SDPatternMatch;\n    SDValue SubVec;\n    if (sd_match(Mask, m_InsertSubvector(m_Undef(), m_Value(SubVec), m_Zero())))\n      Mask = SubVec;\n\n    if (!isOneOrOneSplat(Mask))\n      break;\n\n    return DAG.getNode(RISCVISD::VMV_V_V_VL, SDLoc(N), N->getSimpleValueType(0),\n                       Passthru, True, VL);\n  }\n  case RISCVISD::VMV_V_V_VL: {\n    // vmv_v_v passthru, splat(x), vl -> vmv_v_x passthru, x, vl\n    SDValue Passthru = N->getOperand(0);\n    SDValue Src = N->getOperand(1);\n    SDValue VL = N->getOperand(2);\n\n    // Fixed vectors are wrapped in scalable containers, unwrap them.\n    using namespace SDPatternMatch;\n    SDValue SubVec;\n    if (sd_match(Src, m_InsertSubvector(m_Undef(), m_Value(SubVec), m_Zero())))\n      Src = SubVec;\n\n    SDValue SplatVal = DAG.getSplatValue(Src);\n    if (!SplatVal)\n      break;\n    MVT VT = N->getSimpleValueType(0);\n    return lowerScalarSplat(Passthru, SplatVal, VL, VT, SDLoc(N), DAG,\n                            Subtarget);\n  }", "source_url": "https://github.com/llvm/llvm-project/commit/6584e47101b0631b44518742efbd4f13020c3dff", "code_v0_no_empty_lines": "vmerge_vl指令在掩码为全1时仍执行合并操作，vmv_v_v指令在源操作数为splat时仍执行向量复制。", "code_v1_no_empty_lines": "case RISCVISD::VMERGE_VL: {\n    // vmerge_vl allones, x, y, passthru, vl -> vmv_v_v passthru, x, vl\n    SDValue Mask = N->getOperand(0);\n    SDValue True = N->getOperand(1);\n    SDValue Passthru = N->getOperand(3);\n    SDValue VL = N->getOperand(4);\n\n    // Fixed vectors are wrapped in scalable containers, unwrap them.\n    using namespace SDPatternMatch;\n    SDValue SubVec;\n    if (sd_match(Mask, m_InsertSubvector(m_Undef(), m_Value(SubVec), m_Zero())))\n      Mask = SubVec;\n\n    if (!isOneOrOneSplat(Mask))\n      break;\n\n    return DAG.getNode(RISCVISD::VMV_V_V_VL, SDLoc(N), N->getSimpleValueType(0),\n                       Passthru, True, VL);\n  }\n  case RISCVISD::VMV_V_V_VL: {\n    // vmv_v_v passthru, splat(x), vl -> vmv_v_x passthru, x, vl\n    SDValue Passthru = N->getOperand(0);\n    SDValue Src = N->getOperand(1);\n    SDValue VL = N->getOperand(2);\n\n    // Fixed vectors are wrapped in scalable containers, unwrap them.\n    using namespace SDPatternMatch;\n    SDValue SubVec;\n    if (sd_match(Src, m_InsertSubvector(m_Undef(), m_Value(SubVec), m_Zero())))\n      Src = SubVec;\n\n    SDValue SplatVal = DAG.getSplatValue(Src);\n    if (!SplatVal)\n      break;\n    MVT VT = N->getSimpleValueType(0);\n    return lowerScalarSplat(Passthru, SplatVal, VL, VT, SDLoc(N), DAG,\n                            Subtarget);\n  }", "target": "case RISCVISD::VMERGE_VL: {\n    // vmerge_vl allones, x, y, passthru, vl -> vmv_v_v passthru, x, vl\n    SDValue Mask = N->getOperand(0);\n    SDValue True = N->getOperand(1);\n    SDValue Passthru = N->getOperand(3);\n    SDValue VL = N->getOperand(4);\n\n    // Fixed vectors are wrapped in scalable containers, unwrap them.\n    using namespace SDPatternMatch;\n    SDValue SubVec;\n    if (sd_match(Mask, m_InsertSubvector(m_Undef(), m_Value(SubVec), m_Zero())))\n      Mask = SubVec;\n\n    if (!isOneOrOneSplat(Mask))\n      break;\n\n    return DAG.getNode(RISCVISD::VMV_V_V_VL, SDLoc(N), N->getSimpleValueType(0),\n                       Passthru, True, VL);\n  }\n  case RISCVISD::VMV_V_V_VL: {\n    // vmv_v_v passthru, splat(x), vl -> vmv_v_x passthru, x, vl\n    SDValue Passthru = N->getOperand(0);\n    SDValue Src = N->getOperand(1);\n    SDValue VL = N->getOperand(2);\n\n    // Fixed vectors are wrapped in scalable containers, unwrap them.\n    using namespace SDPatternMatch;\n    SDValue SubVec;\n    if (sd_match(Src, m_InsertSubvector(m_Undef(), m_Value(SubVec), m_Zero())))\n      Src = SubVec;\n\n    SDValue SplatVal = DAG.getSplatValue(Src);\n    if (!SplatVal)\n      break;\n    MVT VT = N->getSimpleValueType(0);\n    return lowerScalarSplat(Passthru, SplatVal, VL, VT, SDLoc(N), DAG,\n                            Subtarget);\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：vmerge_vl指令在掩码为全1时仍执行合并操作，vmv_v_v指令在源操作数为splat时仍执行向量复制。优化后：1. 当vmerge_vl的掩码为全1时，直接转换为vmv_v_v指令，避免不必要的合并操作；2. 当vmv_v_v的源操作数为splat（广播）时，转换为vmv_v_x指令，直接使用标量值进行广播。优化思路：通过模式匹配识别可简化的指令序列，将复杂的向量操作转换为更高效的专用指令，减少指令数量和执行开销，为后续移除llvm.experimental.vp.splat内在函数做准备。"}
{"id": 280, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：在SDIV exact lowering中，当除数为类型提升后的常量时，使用被除数的标量类型（SVT）来构建乘法因子常量，可能导致类型不匹配或生成次优代码。优化后：改为使用除数常量自身的值类型（CT）来构建乘法因子常量，并允许matchUnaryPredicate进行截断匹配。优化思路：扩展对类型提升常量的处理，确保在常量提升场景下也能正确生成乘法优化模式，避免不必要的类型转换，提升代码生成质量。", "original_code": "在SDIV exact lowering中，当除数为类型提升后的常量时，使用被除数的标量类型（SVT）来构建乘法因子常量，可能导致类型不匹配或生成次优代码。", "optimized_code": "-  EVT SVT = VT.getScalarType();\n+  EVT CT = C->getValueType(0);\n-  Factors.push_back(DAG.getConstant(Factor, dl, SVT));\n+  Factors.push_back(DAG.getConstant(Factor, dl, CT));\n-  if (!ISD::matchUnaryPredicate(Op1, BuildSDIVPattern))\n+  if (!ISD::matchUnaryPredicate(Op1, BuildSDIVPattern, /*AllowUndefs=*/false,\n+                                /*AllowTruncation=*/true))", "source_url": "https://github.com/llvm/llvm-project/commit/e7f3226e4f70f502cbd60ca5e999a6680850a50e", "code_v0_no_empty_lines": "在SDIV exact lowering中，当除数为类型提升后的常量时，使用被除数的标量类型（SVT）来构建乘法因子常量，可能导致类型不匹配或生成次优代码。", "code_v1_no_empty_lines": "-  EVT SVT = VT.getScalarType();\n+  EVT CT = C->getValueType(0);\n-  Factors.push_back(DAG.getConstant(Factor, dl, SVT));\n+  Factors.push_back(DAG.getConstant(Factor, dl, CT));\n-  if (!ISD::matchUnaryPredicate(Op1, BuildSDIVPattern))\n+  if (!ISD::matchUnaryPredicate(Op1, BuildSDIVPattern, /*AllowUndefs=*/false,\n+                                /*AllowTruncation=*/true))", "target": "-  EVT SVT = VT.getScalarType();\n+  EVT CT = C->getValueType(0);\n-  Factors.push_back(DAG.getConstant(Factor, dl, SVT));\n+  Factors.push_back(DAG.getConstant(Factor, dl, CT));\n-  if (!ISD::matchUnaryPredicate(Op1, BuildSDIVPattern))\n+  if (!ISD::matchUnaryPredicate(Op1, BuildSDIVPattern, /*AllowUndefs=*/false,\n+                                /*AllowTruncation=*/true))", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在SDIV exact lowering中，当除数为类型提升后的常量时，使用被除数的标量类型（SVT）来构建乘法因子常量，可能导致类型不匹配或生成次优代码。优化后：改为使用除数常量自身的值类型（CT）来构建乘法因子常量，并允许matchUnaryPredicate进行截断匹配。优化思路：扩展对类型提升常量的处理，确保在常量提升场景下也能正确生成乘法优化模式，避免不必要的类型转换，提升代码生成质量。"}
{"id": 281, "source": "riscv-dataset-excel", "optimization_type": "代码重构+性能优化", "optimization_description": "优化前：代码逻辑分散，存在冗余的S指针检查（如if(S && ...)），条件判断顺序不够高效，重复的检查调用。优化后：1. 提前计算并缓存BB指针，避免重复调用getParent()；2. 重新组织检查顺序，将向量类型检查、catchswitch检查等提前；3. 移除冗余的S指针空值检查，简化逻辑；4. 优化递归深度检查条件逻辑。优化思路：通过代码重构简化标量分析逻辑，减少函数调用和条件判断，使代码更清晰且执行更快，属于NFC（无功能变更）的性能优化。", "original_code": "代码逻辑分散，存在冗余的S指针检查（如if(S && ...)），条件判断顺序不够高效，重复的检查调用。", "optimized_code": "-  if (S && isa<CatchSwitchInst>(S.getMainOp()->getParent()->getTerminator())) {\n+  if (isa<CatchSwitchInst>(BB->getTerminator())) {\n-  if (Depth >= RecursionMaxDepth &&\n-      !(S && !S.isAltShuffle() && VL.size() >= 4 &&\n-        (match(S.getMainOp(), m_Load(m_Value())) ||\n+  if (Depth >= RecursionMaxDepth &&\n+      (S.isAltShuffle() || VL.size() < 4 ||\n+       !(match(S.getMainOp(), m_Load(m_Value())) ||\n-  // Check if this is a duplicate of another entry.\n-  if (S) {\n-    LLVM_DEBUG(dbgs() << \"SLP: \\tChecking bundle: \" << *S.getMainOp() << \".\\n\");\n-    for (TreeEntry *E : getTreeEntries(S.getMainOp())) {\n-      if (E->isSame(VL)) {\n-        LLVM_DEBUG(dbgs() << \"SLP: Perfect diamond merge at \" << *S.getMainOp()\n-                          << \".\\n\");\n-        return ScalarsVectorizationLegality(S, /*IsLegal=*/false);\n-      }\n-      SmallPtrSet<Value *, 8> Values(llvm::from_range, E->Scalars);\n-      if (all_of(VL, [&](Value *V) {\n-            return isa<PoisonValue>(V) || Values.contains(V) ||\n-                   (S.getOpcode() == Instruction::PHI && isa<PHINode>(V) &&\n-                    LI->getLoopFor(S.getMainOp()->getParent()) &&\n-                    isVectorized(V));\n-          })) {\n-        LLVM_DEBUG(dbgs() << \"SLP: Gathering due to full overlap.\\n\");\n-        return ScalarsVectorizationLegality(S, /*IsLegal=*/false);\n-      }\n-    }\n+  // Check if this is a duplicate of another entry.\n+  LLVM_DEBUG(dbgs() << \"SLP: \\tChecking bundle: \" << *S.getMainOp() << \".\\n\");\n+  for (TreeEntry *E : getTreeEntries(S.getMainOp())) {\n+    if (E->isSame(VL)) {\n+      LLVM_DEBUG(dbgs() << \"SLP: Perfect diamond merge at \" << *S.getMainOp()\n+                        << \".\\n\");\n+      return ScalarsVectorizationLegality(S, /*IsLegal=*/false);\n+    }\n+    SmallPtrSet<Value *, 8> Values(llvm::from_range, E->Scalars);\n+    if (all_of(VL, [&](Value *V) {\n+          return isa<PoisonValue>(V) || Values.contains(V) ||\n+                 (S.getOpcode() == Instruction::PHI && isa<PHINode>(V) &&\n+                  LI->getLoopFor(S.getMainOp()->getParent()) &&\n+                  isVectorized(V));\n+        })) {\n+      LLVM_DEBUG(dbgs() << \"SLP: Gathering due to full overlap.\\n\")\n+      return ScalarsVectorizationLegality(S, /*IsLegal=*/false);\n+    }\n   }", "source_url": "https://github.com/llvm/llvm-project/commit/e502dce8b5a014afce2b00a7d54b34fbb4eff353", "code_v0_no_empty_lines": "代码逻辑分散，存在冗余的S指针检查（如if(S && ...)），条件判断顺序不够高效，重复的检查调用。", "code_v1_no_empty_lines": "-  if (S && isa<CatchSwitchInst>(S.getMainOp()->getParent()->getTerminator())) {\n+  if (isa<CatchSwitchInst>(BB->getTerminator())) {\n-  if (Depth >= RecursionMaxDepth &&\n-      !(S && !S.isAltShuffle() && VL.size() >= 4 &&\n-        (match(S.getMainOp(), m_Load(m_Value())) ||\n+  if (Depth >= RecursionMaxDepth &&\n+      (S.isAltShuffle() || VL.size() < 4 ||\n+       !(match(S.getMainOp(), m_Load(m_Value())) ||\n-  // Check if this is a duplicate of another entry.\n-  if (S) {\n-    LLVM_DEBUG(dbgs() << \"SLP: \\tChecking bundle: \" << *S.getMainOp() << \".\\n\");\n-    for (TreeEntry *E : getTreeEntries(S.getMainOp())) {\n-      if (E->isSame(VL)) {\n-        LLVM_DEBUG(dbgs() << \"SLP: Perfect diamond merge at \" << *S.getMainOp()\n-                          << \".\\n\");\n-        return ScalarsVectorizationLegality(S, /*IsLegal=*/false);\n-      }\n-      SmallPtrSet<Value *, 8> Values(llvm::from_range, E->Scalars);\n-      if (all_of(VL, [&](Value *V) {\n-            return isa<PoisonValue>(V) || Values.contains(V) ||\n-                   (S.getOpcode() == Instruction::PHI && isa<PHINode>(V) &&\n-                    LI->getLoopFor(S.getMainOp()->getParent()) &&\n-                    isVectorized(V));\n-          })) {\n-        LLVM_DEBUG(dbgs() << \"SLP: Gathering due to full overlap.\\n\");\n-        return ScalarsVectorizationLegality(S, /*IsLegal=*/false);\n-      }\n-    }\n+  // Check if this is a duplicate of another entry.\n+  LLVM_DEBUG(dbgs() << \"SLP: \\tChecking bundle: \" << *S.getMainOp() << \".\\n\");\n+  for (TreeEntry *E : getTreeEntries(S.getMainOp())) {\n+    if (E->isSame(VL)) {\n+      LLVM_DEBUG(dbgs() << \"SLP: Perfect diamond merge at \" << *S.getMainOp()\n+                        << \".\\n\");\n+      return ScalarsVectorizationLegality(S, /*IsLegal=*/false);\n+    }\n+    SmallPtrSet<Value *, 8> Values(llvm::from_range, E->Scalars);\n+    if (all_of(VL, [&](Value *V) {\n+          return isa<PoisonValue>(V) || Values.contains(V) ||\n+                 (S.getOpcode() == Instruction::PHI && isa<PHINode>(V) &&\n+                  LI->getLoopFor(S.getMainOp()->getParent()) &&\n+                  isVectorized(V));\n+        })) {\n+      LLVM_DEBUG(dbgs() << \"SLP: Gathering due to full overlap.\\n\")\n+      return ScalarsVectorizationLegality(S, /*IsLegal=*/false);\n+    }\n   }", "target": "-  if (S && isa<CatchSwitchInst>(S.getMainOp()->getParent()->getTerminator())) {\n+  if (isa<CatchSwitchInst>(BB->getTerminator())) {\n-  if (Depth >= RecursionMaxDepth &&\n-      !(S && !S.isAltShuffle() && VL.size() >= 4 &&\n-        (match(S.getMainOp(), m_Load(m_Value())) ||\n+  if (Depth >= RecursionMaxDepth &&\n+      (S.isAltShuffle() || VL.size() < 4 ||\n+       !(match(S.getMainOp(), m_Load(m_Value())) ||\n-  // Check if this is a duplicate of another entry.\n-  if (S) {\n-    LLVM_DEBUG(dbgs() << \"SLP: \\tChecking bundle: \" << *S.getMainOp() << \".\\n\");\n-    for (TreeEntry *E : getTreeEntries(S.getMainOp())) {\n-      if (E->isSame(VL)) {\n-        LLVM_DEBUG(dbgs() << \"SLP: Perfect diamond merge at \" << *S.getMainOp()\n-                          << \".\\n\");\n-        return ScalarsVectorizationLegality(S, /*IsLegal=*/false);\n-      }\n-      SmallPtrSet<Value *, 8> Values(llvm::from_range, E->Scalars);\n-      if (all_of(VL, [&](Value *V) {\n-            return isa<PoisonValue>(V) || Values.contains(V) ||\n-                   (S.getOpcode() == Instruction::PHI && isa<PHINode>(V) &&\n-                    LI->getLoopFor(S.getMainOp()->getParent()) &&\n-                    isVectorized(V));\n-          })) {\n-        LLVM_DEBUG(dbgs() << \"SLP: Gathering due to full overlap.\\n\");\n-        return ScalarsVectorizationLegality(S, /*IsLegal=*/false);\n-      }\n-    }\n+  // Check if this is a duplicate of another entry.\n+  LLVM_DEBUG(dbgs() << \"SLP: \\tChecking bundle: \" << *S.getMainOp() << \".\\n\");\n+  for (TreeEntry *E : getTreeEntries(S.getMainOp())) {\n+    if (E->isSame(VL)) {\n+      LLVM_DEBUG(dbgs() << \"SLP: Perfect diamond merge at \" << *S.getMainOp()\n+                        << \".\\n\");\n+      return ScalarsVectorizationLegality(S, /*IsLegal=*/false);\n+    }\n+    SmallPtrSet<Value *, 8> Values(llvm::from_range, E->Scalars);\n+    if (all_of(VL, [&](Value *V) {\n+          return isa<PoisonValue>(V) || Values.contains(V) ||\n+                 (S.getOpcode() == Instruction::PHI && isa<PHINode>(V) &&\n+                  LI->getLoopFor(S.getMainOp()->getParent()) &&\n+                  isVectorized(V));\n+        })) {\n+      LLVM_DEBUG(dbgs() << \"SLP: Gathering due to full overlap.\\n\")\n+      return ScalarsVectorizationLegality(S, /*IsLegal=*/false);\n+    }\n   }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：代码逻辑分散，存在冗余的S指针检查（如if(S && ...)），条件判断顺序不够高效，重复的检查调用。优化后：1. 提前计算并缓存BB指针，避免重复调用getParent()；2. 重新组织检查顺序，将向量类型检查、catchswitch检查等提前；3. 移除冗余的S指针空值检查，简化逻辑；4. 优化递归深度检查条件逻辑。优化思路：通过代码重构简化标量分析逻辑，减少函数调用和条件判断，使代码更清晰且执行更快，属于NFC（无功能变更）的性能优化。"}
{"id": 282, "source": "riscv-dataset-excel", "optimization_type": "对齐优化", "optimization_description": "优化前：InferAlignment传递无法处理and(ptrtoint, const)模式，导致无法推断对齐信息。优化后：新增模式匹配，当检测到and(ptrtoint/ptrtoaddr, const)时，计算指针实际对齐度，若常量小于对齐度，则将and结果替换为零。思路：利用已知对齐信息优化位运算，消除冗余计算，提升代码生成质量。", "original_code": "InferAlignment传递无法处理and(ptrtoint, const)模式，导致无法推断对齐信息。", "optimized_code": "Value *PtrOp;\n  const APInt *Const;\n  if (match(I, m_And(m_PtrToIntOrAddr(m_Value(PtrOp)), m_APInt(Const)))) {\n    Align ActualAlign = Fn(PtrOp, Align(1), Align(1));\n    if (Const->ult(ActualAlign.value())) {\n      I->replaceAllUsesWith(Constant::getNullValue(I->getType()));\n      return true;\n    }\n  }", "source_url": "https://github.com/llvm/llvm-project/commit/bc2a64f7fca159f3441e98bcaaef9efa86ec728e", "code_v0_no_empty_lines": "InferAlignment传递无法处理and(ptrtoint, const)模式，导致无法推断对齐信息。", "code_v1_no_empty_lines": "Value *PtrOp;\n  const APInt *Const;\n  if (match(I, m_And(m_PtrToIntOrAddr(m_Value(PtrOp)), m_APInt(Const)))) {\n    Align ActualAlign = Fn(PtrOp, Align(1), Align(1));\n    if (Const->ult(ActualAlign.value())) {\n      I->replaceAllUsesWith(Constant::getNullValue(I->getType()));\n      return true;\n    }\n  }", "target": "Value *PtrOp;\n  const APInt *Const;\n  if (match(I, m_And(m_PtrToIntOrAddr(m_Value(PtrOp)), m_APInt(Const)))) {\n    Align ActualAlign = Fn(PtrOp, Align(1), Align(1));\n    if (Const->ult(ActualAlign.value())) {\n      I->replaceAllUsesWith(Constant::getNullValue(I->getType()));\n      return true;\n    }\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：InferAlignment传递无法处理and(ptrtoint, const)模式，导致无法推断对齐信息。优化后：新增模式匹配，当检测到and(ptrtoint/ptrtoaddr, const)时，计算指针实际对齐度，若常量小于对齐度，则将and结果替换为零。思路：利用已知对齐信息优化位运算，消除冗余计算，提升代码生成质量。"}
{"id": 283, "source": "riscv-dataset-excel", "optimization_type": "指令优化+常量折叠", "optimization_description": "优化前：MULHU优化mulhu x, (1 << c) -> x >> (bitwidth - c)在类型合法化提升常量操作数时失败，因为isConstantOrConstantVector和matchUnaryPredicate拒绝被提升的常量。优化后：在isConstantOrConstantVector和matchUnaryPredicate中添加AllowTruncation=true参数，允许处理被提升的常量。优化思路：遵循最近UDIV修复的模式，使优化能够识别和处理类型合法化后的提升常量，将乘法高位运算转换为更高效的右移操作。", "original_code": "MULHU优化mulhu x, (1 << c) -> x >> (bitwidth - c)在类型合法化提升常量操作数时失败，因为isConstantOrConstantVector和matchUnaryPredicate拒绝被提升的常量。", "optimized_code": "-  if (isConstantOrConstantVector(N1, /*NoOpaques*/ true) &&\n+  if (isConstantOrConstantVector(N1, /*NoOpaques=*/true,\n+                                 /*AllowTruncation=*/true) &&\n-  if (ISD::matchUnaryPredicate(Op, IsPowerOfTwo)) {\n+  if (ISD::matchUnaryPredicate(Op, IsPowerOfTwo, /*AllowUndefs=*/false,\n+                               /*AllowTruncation=*/true)) {", "source_url": "https://github.com/llvm/llvm-project/commit/5c6918f24dc65d03c534e88150452db88c4cc630", "code_v0_no_empty_lines": "MULHU优化mulhu x, (1 << c) -> x >> (bitwidth - c)在类型合法化提升常量操作数时失败，因为isConstantOrConstantVector和matchUnaryPredicate拒绝被提升的常量。", "code_v1_no_empty_lines": "-  if (isConstantOrConstantVector(N1, /*NoOpaques*/ true) &&\n+  if (isConstantOrConstantVector(N1, /*NoOpaques=*/true,\n+                                 /*AllowTruncation=*/true) &&\n-  if (ISD::matchUnaryPredicate(Op, IsPowerOfTwo)) {\n+  if (ISD::matchUnaryPredicate(Op, IsPowerOfTwo, /*AllowUndefs=*/false,\n+                               /*AllowTruncation=*/true)) {", "target": "-  if (isConstantOrConstantVector(N1, /*NoOpaques*/ true) &&\n+  if (isConstantOrConstantVector(N1, /*NoOpaques=*/true,\n+                                 /*AllowTruncation=*/true) &&\n-  if (ISD::matchUnaryPredicate(Op, IsPowerOfTwo)) {\n+  if (ISD::matchUnaryPredicate(Op, IsPowerOfTwo, /*AllowUndefs=*/false,\n+                               /*AllowTruncation=*/true)) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：MULHU优化mulhu x, (1 << c) -> x >> (bitwidth - c)在类型合法化提升常量操作数时失败，因为isConstantOrConstantVector和matchUnaryPredicate拒绝被提升的常量。优化后：在isConstantOrConstantVector和matchUnaryPredicate中添加AllowTruncation=true参数，允许处理被提升的常量。优化思路：遵循最近UDIV修复的模式，使优化能够识别和处理类型合法化后的提升常量，将乘法高位运算转换为更高效的右移操作。"}
{"id": 284, "source": "riscv-dataset-excel", "optimization_type": "循环优化", "optimization_description": "优化前：在循环内部调用SLP.getTreeEntries(User)获取Entries，每次循环迭代都重复执行相同的函数调用。优化后：将Entries的获取和空检查提升到循环外部，避免在循环中重复计算不变值。优化思路：识别循环不变表达式（invariant expression）并将其移出循环，减少不必要的函数调用开销，提高代码执行效率。", "original_code": "在循环内部调用SLP.getTreeEntries(User)获取Entries，每次循环迭代都重复执行相同的函数调用。", "optimized_code": "-      for (const Use &U : User->operands()) {\n         if (U.get() != Op)\n           continue;\n-        ArrayRef<TreeEntry *> Entries = SLP.getTreeEntries(User);\n-        if (Entries.empty())\n-          return false;\n+      ArrayRef<TreeEntry *> Entries = SLP.getTreeEntries(User);\n+      if (Entries.empty())\n+        return false;\n+      for (const Use &U : User->operands()) {\n+        if (U.get() != Op)\n+          continue;", "source_url": "https://github.com/llvm/llvm-project/commit/a2a3d89e0833f545af7189aa038eb87223a3189a", "code_v0_no_empty_lines": "在循环内部调用SLP.getTreeEntries(User)获取Entries，每次循环迭代都重复执行相同的函数调用。", "code_v1_no_empty_lines": "-      for (const Use &U : User->operands()) {\n         if (U.get() != Op)\n           continue;\n-        ArrayRef<TreeEntry *> Entries = SLP.getTreeEntries(User);\n-        if (Entries.empty())\n-          return false;\n+      ArrayRef<TreeEntry *> Entries = SLP.getTreeEntries(User);\n+      if (Entries.empty())\n+        return false;\n+      for (const Use &U : User->operands()) {\n+        if (U.get() != Op)\n+          continue;", "target": "-      for (const Use &U : User->operands()) {\n         if (U.get() != Op)\n           continue;\n-        ArrayRef<TreeEntry *> Entries = SLP.getTreeEntries(User);\n-        if (Entries.empty())\n-          return false;\n+      ArrayRef<TreeEntry *> Entries = SLP.getTreeEntries(User);\n+      if (Entries.empty())\n+        return false;\n+      for (const Use &U : User->operands()) {\n+        if (U.get() != Op)\n+          continue;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在循环内部调用SLP.getTreeEntries(User)获取Entries，每次循环迭代都重复执行相同的函数调用。优化后：将Entries的获取和空检查提升到循环外部，避免在循环中重复计算不变值。优化思路：识别循环不变表达式（invariant expression）并将其移出循环，减少不必要的函数调用开销，提高代码执行效率。"}
{"id": 285, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化+代码生成优化", "optimization_description": "优化前：在Windows AArch64目标（long==i32）上，lround/lrint的i32标量变体在GlobalISel中未正确处理，导致需要回退到libcall或产生次优代码。优化后：重新组织G_LROUND/G_INTRINSIC_LRINT和G_LLROUND/G_INTRINSIC_LLRINT的合法化规则，明确支持i32标量类型，使其能够直接生成fcvtas指令。优化思路：统一处理lround/llround和lrint/llrint的合法化逻辑，为Windows AArch64目标添加i32标量支持，消除回退路径，提高代码生成效率。", "original_code": "在Windows AArch64目标（long==i32）上，lround/lrint的i32标量变体在GlobalISel中未正确处理，导致需要回退到libcall或产生次优代码。", "optimized_code": "-  getActionDefinitionsBuilder({G_INTRINSIC_LRINT, G_INTRINSIC_LLRINT})\n      .legalFor({{s64, MinFPScalar}, {s64, s32}, {s64, s64}})\n      .libcallFor({{s64, s128}})\n      .minScalarOrElt(1, MinFPScalar);\n\n-  getActionDefinitionsBuilder({G_LROUND, G_LLROUND})\n      .legalFor({{s64, s32}, {s64, s64}})\n      .legalFor(HasFP16, {{s64, s16}})\n      .minScalar(0, s64)\n      .libcallFor({{s64, s128}});\n+  getActionDefinitionsBuilder({G_LROUND, G_INTRINSIC_LRINT})\n      .legalFor({{s32, s32}, {s32, s64}, {s64, s32}, {s64, s64}})\n      .legalFor(HasFP16, {{s32, s16}, {s64, s16}})\n      .minScalar(1, s32)\n      .libcallFor({{s64, s128}});\n+  getActionDefinitionsBuilder({G_LLROUND, G_INTRINSIC_LLRINT})\n      .legalFor({{s64, s32}, {s64, s64}})\n      .legalFor(HasFP16, {{s64, s16}})\n      .minScalar(0, s64)\n      .libcallFor({{s64, s128}});", "source_url": "https://github.com/llvm/llvm-project/commit/4f2d20992d0ed4938956072d909679a66544ca61", "code_v0_no_empty_lines": "在Windows AArch64目标（long==i32）上，lround/lrint的i32标量变体在GlobalISel中未正确处理，导致需要回退到libcall或产生次优代码。", "code_v1_no_empty_lines": "-  getActionDefinitionsBuilder({G_INTRINSIC_LRINT, G_INTRINSIC_LLRINT})\n      .legalFor({{s64, MinFPScalar}, {s64, s32}, {s64, s64}})\n      .libcallFor({{s64, s128}})\n      .minScalarOrElt(1, MinFPScalar);\n\n-  getActionDefinitionsBuilder({G_LROUND, G_LLROUND})\n      .legalFor({{s64, s32}, {s64, s64}})\n      .legalFor(HasFP16, {{s64, s16}})\n      .minScalar(0, s64)\n      .libcallFor({{s64, s128}});\n+  getActionDefinitionsBuilder({G_LROUND, G_INTRINSIC_LRINT})\n      .legalFor({{s32, s32}, {s32, s64}, {s64, s32}, {s64, s64}})\n      .legalFor(HasFP16, {{s32, s16}, {s64, s16}})\n      .minScalar(1, s32)\n      .libcallFor({{s64, s128}});\n+  getActionDefinitionsBuilder({G_LLROUND, G_INTRINSIC_LLRINT})\n      .legalFor({{s64, s32}, {s64, s64}})\n      .legalFor(HasFP16, {{s64, s16}})\n      .minScalar(0, s64)\n      .libcallFor({{s64, s128}});", "target": "-  getActionDefinitionsBuilder({G_INTRINSIC_LRINT, G_INTRINSIC_LLRINT})\n      .legalFor({{s64, MinFPScalar}, {s64, s32}, {s64, s64}})\n      .libcallFor({{s64, s128}})\n      .minScalarOrElt(1, MinFPScalar);\n\n-  getActionDefinitionsBuilder({G_LROUND, G_LLROUND})\n      .legalFor({{s64, s32}, {s64, s64}})\n      .legalFor(HasFP16, {{s64, s16}})\n      .minScalar(0, s64)\n      .libcallFor({{s64, s128}});\n+  getActionDefinitionsBuilder({G_LROUND, G_INTRINSIC_LRINT})\n      .legalFor({{s32, s32}, {s32, s64}, {s64, s32}, {s64, s64}})\n      .legalFor(HasFP16, {{s32, s16}, {s64, s16}})\n      .minScalar(1, s32)\n      .libcallFor({{s64, s128}});\n+  getActionDefinitionsBuilder({G_LLROUND, G_INTRINSIC_LLRINT})\n      .legalFor({{s64, s32}, {s64, s64}})\n      .legalFor(HasFP16, {{s64, s16}})\n      .minScalar(0, s64)\n      .libcallFor({{s64, s128}});", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在Windows AArch64目标（long==i32）上，lround/lrint的i32标量变体在GlobalISel中未正确处理，导致需要回退到libcall或产生次优代码。优化后：重新组织G_LROUND/G_INTRINSIC_LRINT和G_LLROUND/G_INTRINSIC_LLRINT的合法化规则，明确支持i32标量类型，使其能够直接生成fcvtas指令。优化思路：统一处理lround/llround和lrint/llrint的合法化逻辑，为Windows AArch64目标添加i32标量支持，消除回退路径，提高代码生成效率。"}
{"id": 286, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：对于模式 (and (shl X, 8), 0xff00) 使用两条指令序列（左移+逻辑与）实现。优化后：当目标支持Zbkb扩展时，选择单条PACKH指令（packh zero, X）替代。优化思路：利用RISC-V Zbkb扩展中的PACKH指令，将原本需要两条指令的操作合并为一条，减少指令数量，提高代码密度和执行效率。", "original_code": "对于模式 (and (shl X, 8), 0xff00) 使用两条指令序列（左移+逻辑与）实现。", "optimized_code": "if (Subtarget->hasStdExtZbkb() && C1 == 0xff00 && C2 == 8) {\n  SDNode *PACKH = CurDAG->getMachineNode(\n      RISCV::PACKH, DL, VT,\n      CurDAG->getRegister(RISCV::X0, Subtarget->getXLenVT()), X);\n  ReplaceNode(Node, PACKH);\n  return;\n}", "source_url": "https://github.com/llvm/llvm-project/commit/d5072b94ddc0e9311b67fe4742857c7d2f306e9a", "code_v0_no_empty_lines": "对于模式 (and (shl X, 8), 0xff00) 使用两条指令序列（左移+逻辑与）实现。", "code_v1_no_empty_lines": "if (Subtarget->hasStdExtZbkb() && C1 == 0xff00 && C2 == 8) {\n  SDNode *PACKH = CurDAG->getMachineNode(\n      RISCV::PACKH, DL, VT,\n      CurDAG->getRegister(RISCV::X0, Subtarget->getXLenVT()), X);\n  ReplaceNode(Node, PACKH);\n  return;\n}", "target": "if (Subtarget->hasStdExtZbkb() && C1 == 0xff00 && C2 == 8) {\n  SDNode *PACKH = CurDAG->getMachineNode(\n      RISCV::PACKH, DL, VT,\n      CurDAG->getRegister(RISCV::X0, Subtarget->getXLenVT()), X);\n  ReplaceNode(Node, PACKH);\n  return;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于模式 (and (shl X, 8), 0xff00) 使用两条指令序列（左移+逻辑与）实现。优化后：当目标支持Zbkb扩展时，选择单条PACKH指令（packh zero, X）替代。优化思路：利用RISC-V Zbkb扩展中的PACKH指令，将原本需要两条指令的操作合并为一条，减少指令数量，提高代码密度和执行效率。"}
{"id": 287, "source": "riscv-dataset-excel", "optimization_type": "调度优化+依赖关系修复", "optimization_description": "优化前：在依赖PHI节点调度中，错误地将SU1作为SU0的后继节点，导致SU0可能先于SU1被调度，产生无效IR（后续指令引用未定义的值）。优化后：修正依赖关系，使SU0正确依赖SU1（SU0成为SU1的后继），确保调度顺序正确，避免生成无效IR。思路：识别并修复依赖PHI节点间的调度边方向，确保数据流依赖关系在调度图中正确表示。", "original_code": "在依赖PHI节点调度中，错误地将SU1作为SU0的后继节点，导致SU0可能先于SU1被调度，产生无效IR（后续指令引用未定义的值）。", "optimized_code": "-              if (SU->NodeNum < I.NodeNum && !I.isPred(SU))\n-                I.addPred(SDep(SU, SDep::Barrier));\n+              if (SU->NodeNum < I.NodeNum && !SU->isPred(&I))\n+                SU->addPred(SDep(&I, SDep::Barrier));", "source_url": "https://github.com/llvm/llvm-project/commit/78ee4a59764720875f51ccfb8086c656e745bec6", "code_v0_no_empty_lines": "在依赖PHI节点调度中，错误地将SU1作为SU0的后继节点，导致SU0可能先于SU1被调度，产生无效IR（后续指令引用未定义的值）。", "code_v1_no_empty_lines": "-              if (SU->NodeNum < I.NodeNum && !I.isPred(SU))\n-                I.addPred(SDep(SU, SDep::Barrier));\n+              if (SU->NodeNum < I.NodeNum && !SU->isPred(&I))\n+                SU->addPred(SDep(&I, SDep::Barrier));", "target": "-              if (SU->NodeNum < I.NodeNum && !I.isPred(SU))\n-                I.addPred(SDep(SU, SDep::Barrier));\n+              if (SU->NodeNum < I.NodeNum && !SU->isPred(&I))\n+                SU->addPred(SDep(&I, SDep::Barrier));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在依赖PHI节点调度中，错误地将SU1作为SU0的后继节点，导致SU0可能先于SU1被调度，产生无效IR（后续指令引用未定义的值）。优化后：修正依赖关系，使SU0正确依赖SU1（SU0成为SU1的后继），确保调度顺序正确，避免生成无效IR。思路：识别并修复依赖PHI节点间的调度边方向，确保数据流依赖关系在调度图中正确表示。"}
{"id": 288, "source": "riscv-dataset-excel", "optimization_type": "代码清理", "optimization_description": "优化前：函数genACC包含大量未实现（TODO）的OpenACC缓存指令处理代码，这些代码在TODO语句后无法执行，属于死代码。优化后：移除了TODO语句后的所有死代码，仅保留TODO调用。优化思路：清理代码库，移除无法到达的代码，减少二进制大小，提高代码可读性和维护性。", "original_code": "函数genACC包含大量未实现（TODO）的OpenACC缓存指令处理代码，这些代码在TODO语句后无法执行，属于死代码。", "optimized_code": "-  fir::FirOpBuilder &builder = converter.getFirOpBuilder();\n   mlir::Location loc = converter.genLocation(cacheConstruct.source);\n   TODO(loc, \"OpenACC cache directive\");\n-  auto loopOp = builder.getRegion().getParentOfType<mlir::acc::LoopOp>();\n-  auto crtPos = builder.saveInsertionPoint();\n-  if (loopOp) {\n-    builder.setInsertionPoint(loopOp);\n-    Fortran::lower::StatementContext stmtCtx;\n-    llvm::SmallVector<mlir::Value> cacheOperands;\n-    const Fortran::parser::AccObjectListWithModifier &listWithModifier =\n-        std::get<Fortran::parser::AccObjectListWithModifier>(cacheConstruct.t);\n-    const auto &accObjectList =\n-        std::get<Fortran::parser::AccObjectList>(listWithModifier.t);\n-    const auto &modifier =\n-        std::get<std::optional<Fortran::parser::AccDataModifier>>(\n-            listWithModifier.t);\n-\n-    mlir::acc::DataClause dataClause = mlir::acc::DataClause::acc_cache;\n-    if (modifier &&\n-        (*modifier).v == Fortran::parser::AccDataModifier::Modifier::ReadOnly)\n-      dataClause = mlir::acc::DataClause::acc_cache_readonly;\n-    genDataOperandOperations<mlir::acc::CacheOp>(\n-        accObjectList, converter, semanticsContext, stmtCtx, cacheOperands,\n-        dataClause,\n-        /*structured=*/true, /*implicit=*/false,\n-        /*async=*/{}, /*asyncDeviceTypes=*/{}, /*asyncOnlyDeviceTypes=*/{},\n-        /*setDeclareAttr*/ false);\n-    loopOp.getCacheOperandsMutable().append(cacheOperands);\n-  } else {\n-    llvm::report_fatal_error(\n-        \"could not find loop to attach OpenACC cache information.\");\n-  }\n-  builder.restoreInsertionPoint(crtPos);", "source_url": "https://github.com/llvm/llvm-project/commit/edbf154d16a346bd7659a565dead173846871d2f", "code_v0_no_empty_lines": "函数genACC包含大量未实现（TODO）的OpenACC缓存指令处理代码，这些代码在TODO语句后无法执行，属于死代码。", "code_v1_no_empty_lines": "-  fir::FirOpBuilder &builder = converter.getFirOpBuilder();\n   mlir::Location loc = converter.genLocation(cacheConstruct.source);\n   TODO(loc, \"OpenACC cache directive\");\n-  auto loopOp = builder.getRegion().getParentOfType<mlir::acc::LoopOp>();\n-  auto crtPos = builder.saveInsertionPoint();\n-  if (loopOp) {\n-    builder.setInsertionPoint(loopOp);\n-    Fortran::lower::StatementContext stmtCtx;\n-    llvm::SmallVector<mlir::Value> cacheOperands;\n-    const Fortran::parser::AccObjectListWithModifier &listWithModifier =\n-        std::get<Fortran::parser::AccObjectListWithModifier>(cacheConstruct.t);\n-    const auto &accObjectList =\n-        std::get<Fortran::parser::AccObjectList>(listWithModifier.t);\n-    const auto &modifier =\n-        std::get<std::optional<Fortran::parser::AccDataModifier>>(\n-            listWithModifier.t);\n-\n-    mlir::acc::DataClause dataClause = mlir::acc::DataClause::acc_cache;\n-    if (modifier &&\n-        (*modifier).v == Fortran::parser::AccDataModifier::Modifier::ReadOnly)\n-      dataClause = mlir::acc::DataClause::acc_cache_readonly;\n-    genDataOperandOperations<mlir::acc::CacheOp>(\n-        accObjectList, converter, semanticsContext, stmtCtx, cacheOperands,\n-        dataClause,\n-        /*structured=*/true, /*implicit=*/false,\n-        /*async=*/{}, /*asyncDeviceTypes=*/{}, /*asyncOnlyDeviceTypes=*/{},\n-        /*setDeclareAttr*/ false);\n-    loopOp.getCacheOperandsMutable().append(cacheOperands);\n-  } else {\n-    llvm::report_fatal_error(\n-        \"could not find loop to attach OpenACC cache information.\");\n-  }\n-  builder.restoreInsertionPoint(crtPos);", "target": "-  fir::FirOpBuilder &builder = converter.getFirOpBuilder();\n   mlir::Location loc = converter.genLocation(cacheConstruct.source);\n   TODO(loc, \"OpenACC cache directive\");\n-  auto loopOp = builder.getRegion().getParentOfType<mlir::acc::LoopOp>();\n-  auto crtPos = builder.saveInsertionPoint();\n-  if (loopOp) {\n-    builder.setInsertionPoint(loopOp);\n-    Fortran::lower::StatementContext stmtCtx;\n-    llvm::SmallVector<mlir::Value> cacheOperands;\n-    const Fortran::parser::AccObjectListWithModifier &listWithModifier =\n-        std::get<Fortran::parser::AccObjectListWithModifier>(cacheConstruct.t);\n-    const auto &accObjectList =\n-        std::get<Fortran::parser::AccObjectList>(listWithModifier.t);\n-    const auto &modifier =\n-        std::get<std::optional<Fortran::parser::AccDataModifier>>(\n-            listWithModifier.t);\n-\n-    mlir::acc::DataClause dataClause = mlir::acc::DataClause::acc_cache;\n-    if (modifier &&\n-        (*modifier).v == Fortran::parser::AccDataModifier::Modifier::ReadOnly)\n-      dataClause = mlir::acc::DataClause::acc_cache_readonly;\n-    genDataOperandOperations<mlir::acc::CacheOp>(\n-        accObjectList, converter, semanticsContext, stmtCtx, cacheOperands,\n-        dataClause,\n-        /*structured=*/true, /*implicit=*/false,\n-        /*async=*/{}, /*asyncDeviceTypes=*/{}, /*asyncOnlyDeviceTypes=*/{},\n-        /*setDeclareAttr*/ false);\n-    loopOp.getCacheOperandsMutable().append(cacheOperands);\n-  } else {\n-    llvm::report_fatal_error(\n-        \"could not find loop to attach OpenACC cache information.\");\n-  }\n-  builder.restoreInsertionPoint(crtPos);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：函数genACC包含大量未实现（TODO）的OpenACC缓存指令处理代码，这些代码在TODO语句后无法执行，属于死代码。优化后：移除了TODO语句后的所有死代码，仅保留TODO调用。优化思路：清理代码库，移除无法到达的代码，减少二进制大小，提高代码可读性和维护性。"}
{"id": 289, "source": "riscv-dataset-excel", "optimization_type": "代码下沉优化", "optimization_description": "优化前：llvm-reduce 工具缺少将定义指令下沉到使用点的优化通道，无法有效减少变量的活跃范围。优化后：新增了 ReduceSinkDefsToUses 通道，能够将定义指令（如函数调用）尽可能下沉到其使用点附近，从而缩短变量的活跃范围，减少对后续调度的影响。优化思路：通过代码下沉技术减少寄存器压力，提高代码局部性，为后续优化创造更好条件。", "original_code": "llvm-reduce 工具缺少将定义指令下沉到使用点的优化通道，无法有效减少变量的活跃范围。", "optimized_code": "新增文件 llvm/tools/llvm-reduce/deltas/ReduceSinkDefsToUses.cpp 和对应的测试文件，在 DeltaPasses.def 中添加了 sink-defs-to-uses 选项，并在 CMakeLists.txt 中添加了 ReduceSinkDefsToUses.cpp 到构建列表。", "source_url": "https://github.com/llvm/llvm-project/commit/097e0e116aa42f114d6e7dd166069f90d85cce97", "code_v0_no_empty_lines": "llvm-reduce 工具缺少将定义指令下沉到使用点的优化通道，无法有效减少变量的活跃范围。", "code_v1_no_empty_lines": "新增文件 llvm/tools/llvm-reduce/deltas/ReduceSinkDefsToUses.cpp 和对应的测试文件，在 DeltaPasses.def 中添加了 sink-defs-to-uses 选项，并在 CMakeLists.txt 中添加了 ReduceSinkDefsToUses.cpp 到构建列表。", "target": "新增文件 llvm/tools/llvm-reduce/deltas/ReduceSinkDefsToUses.cpp 和对应的测试文件，在 DeltaPasses.def 中添加了 sink-defs-to-uses 选项，并在 CMakeLists.txt 中添加了 ReduceSinkDefsToUses.cpp 到构建列表。", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：llvm-reduce 工具缺少将定义指令下沉到使用点的优化通道，无法有效减少变量的活跃范围。优化后：新增了 ReduceSinkDefsToUses 通道，能够将定义指令（如函数调用）尽可能下沉到其使用点附近，从而缩短变量的活跃范围，减少对后续调度的影响。优化思路：通过代码下沉技术减少寄存器压力，提高代码局部性，为后续优化创造更好条件。"}
{"id": 290, "source": "riscv-dataset-excel", "optimization_type": "返回值优化框架", "optimization_description": "优化前：CIR代码生成器缺少NRVO（命名返回值优化）框架，无法正确处理需要析构的非平凡类型变量的返回值优化场景，遇到NRVO候选变量时会抛出未实现错误。优化后：1. 为NRVO候选变量创建标志变量（初始为false），记录在nrvoFlags映射中；2. 在return语句中，如果应用NRVO，则将标志变量设置为true；3. 在清理阶段，根据标志变量决定是否调用析构函数（当前框架已搭建，实际析构调用尚未实现）。优化思路：建立NRVO框架，通过标志变量跟踪优化状态，避免不必要的对象拷贝和析构，为后续完整实现NRVO优化奠定基础。", "original_code": "CIR代码生成器缺少NRVO（命名返回值优化）框架，无法正确处理需要析构的非平凡类型变量的返回值优化场景，遇到NRVO候选变量时会抛出未实现错误。", "optimized_code": "diff --git a/clang/lib/CIR/CodeGen/CIRGenDecl.cpp b/clang/lib/CIR/CodeGen/CIRGenDecl.cpp\nindex e0e4f67df87b2..c9e10840778b4 100644\n--- a/clang/lib/CIR/CodeGen/CIRGenDecl.cpp\n+++ b/clang/lib/CIR/CodeGen/CIRGenDecl.cpp\n@@ -98,8 +98,22 @@ CIRGenFunction::emitAutoVarAlloca(const VarDecl &d,\n       if (const RecordDecl *rd = ty->getAsRecordDecl()) {\n         if (const auto *cxxrd = dyn_cast<CXXRecordDecl>(rd);\n             (cxxrd && !cxxrd->hasTrivialDestructor()) ||\n-            rd->isNonTrivialToPrimitiveDestroy())\n-          cgm.errorNYI(d.getSourceRange(), \"emitAutoVarAlloca: set NRVO flag\");\n+            rd->isNonTrivialToPrimitiveDestroy()) {\n+          // In LLVM: Create a flag that is used to indicate when the NRVO was\n+          // applied to this variable. Set it to zero to indicate that NRVO was\n+          // not applied. For now, use the same approach for CIRGen until we can\n+          // be sure it's worth doing something more aggressive.\n+          cir::ConstantOp falseNVRO = builder.getFalse(loc);\n+          Address nrvoFlag = createTempAlloca(falseNVRO.getType(),\n+                                              CharUnits::One(), loc, \"nrvo\",\n+                                              /*arraySize=*/nullptr, &address);\n+          assert(builder.getInsertionBlock());\n+          builder.createStore(loc, falseNVRO, nrvoFlag);\n+\n+          // Record the NRVO flag for this variable.\n+          nrvoFlags[&d] = nrvoFlag.getPointer();\n+          emission.nrvoFlag = nrvoFlag.getPointer();\n+        }\n       }\n     } else {\n       // A normal fixed sized variable becomes an alloca in the entry block,\n@@ -965,7 +1008,10 @@ void CIRGenFunction::emitAutoVarTypeCleanup(\n     // If there's an NRVO flag on the emission, we need a different\n     // cleanup.\n     if (emission.nrvoFlag) {\n-      cgm.errorNYI(var->getSourceRange(), \"emitAutoVarTypeCleanup: NRVO\");\n+      assert(!type->isArrayType());\n+      CXXDestructorDecl *dtor = type->getAsCXXRecordDecl()->getDestructor();\n+      ehStack.pushCleanup<DestroyNRVOVariableCXX>(cleanupKind, addr, type, dtor,\n+                                                  emission.nrvoFlag);\n       return;\n     }\n     // Otherwise, this is handled below.\ndiff --git a/clang/lib/CIR/CodeGen/CIRGenStmt.cpp b/clang/lib/CIR/CodeGen/CIRGenStmt.cpp\nindex 7bb8c2153056a..9f4f681eb9a79 100644\n--- a/clang/lib/CIR/CodeGen/CIRGenStmt.cpp\n+++ b/clang/lib/CIR/CodeGen/CIRGenStmt.cpp\n@@ -458,7 +458,14 @@ mlir::LogicalResult CIRGenFunction::emitReturnStmt(const ReturnStmt &s) {\n     if (getContext().getLangOpts().ElideConstructors && s.getNRVOCandidate() &&\n         s.getNRVOCandidate()->isNRVOVariable()) {\n       assert(!cir::MissingFeatures::openMP());\n-      assert(!cir::MissingFeatures::nrvo());\n+      // Apply the named return value optimization for this return statement,\n+      // which means doing nothing: the appropriate result has already been\n+      // constructed into the NRVO variable.\n+\n+      // If there is an NRVO flag for this variable, set it to 1 into indicate\n+      // that the cleanup code should not destroy the variable.\n+      if (auto nrvoFlag = nrvoFlags[s.getNRVOCandidate()])\n+        builder.createFlagStore(loc, true, nrvoFlag);\n     } else if (!rv) {\n       // No return expression. Do nothing.\n     } else if (rv->getType()->isVoidType()) {", "source_url": "https://github.com/llvm/llvm-project/commit/c456fd83f25276cf5819c2dafc687c78f03b2ab5", "code_v0_no_empty_lines": "CIR代码生成器缺少NRVO（命名返回值优化）框架，无法正确处理需要析构的非平凡类型变量的返回值优化场景，遇到NRVO候选变量时会抛出未实现错误。", "code_v1_no_empty_lines": "diff --git a/clang/lib/CIR/CodeGen/CIRGenDecl.cpp b/clang/lib/CIR/CodeGen/CIRGenDecl.cpp\nindex e0e4f67df87b2..c9e10840778b4 100644\n--- a/clang/lib/CIR/CodeGen/CIRGenDecl.cpp\n+++ b/clang/lib/CIR/CodeGen/CIRGenDecl.cpp\n@@ -98,8 +98,22 @@ CIRGenFunction::emitAutoVarAlloca(const VarDecl &d,\n       if (const RecordDecl *rd = ty->getAsRecordDecl()) {\n         if (const auto *cxxrd = dyn_cast<CXXRecordDecl>(rd);\n             (cxxrd && !cxxrd->hasTrivialDestructor()) ||\n-            rd->isNonTrivialToPrimitiveDestroy())\n-          cgm.errorNYI(d.getSourceRange(), \"emitAutoVarAlloca: set NRVO flag\");\n+            rd->isNonTrivialToPrimitiveDestroy()) {\n+          // In LLVM: Create a flag that is used to indicate when the NRVO was\n+          // applied to this variable. Set it to zero to indicate that NRVO was\n+          // not applied. For now, use the same approach for CIRGen until we can\n+          // be sure it's worth doing something more aggressive.\n+          cir::ConstantOp falseNVRO = builder.getFalse(loc);\n+          Address nrvoFlag = createTempAlloca(falseNVRO.getType(),\n+                                              CharUnits::One(), loc, \"nrvo\",\n+                                              /*arraySize=*/nullptr, &address);\n+          assert(builder.getInsertionBlock());\n+          builder.createStore(loc, falseNVRO, nrvoFlag);\n+\n+          // Record the NRVO flag for this variable.\n+          nrvoFlags[&d] = nrvoFlag.getPointer();\n+          emission.nrvoFlag = nrvoFlag.getPointer();\n+        }\n       }\n     } else {\n       // A normal fixed sized variable becomes an alloca in the entry block,\n@@ -965,7 +1008,10 @@ void CIRGenFunction::emitAutoVarTypeCleanup(\n     // If there's an NRVO flag on the emission, we need a different\n     // cleanup.\n     if (emission.nrvoFlag) {\n-      cgm.errorNYI(var->getSourceRange(), \"emitAutoVarTypeCleanup: NRVO\");\n+      assert(!type->isArrayType());\n+      CXXDestructorDecl *dtor = type->getAsCXXRecordDecl()->getDestructor();\n+      ehStack.pushCleanup<DestroyNRVOVariableCXX>(cleanupKind, addr, type, dtor,\n+                                                  emission.nrvoFlag);\n       return;\n     }\n     // Otherwise, this is handled below.\ndiff --git a/clang/lib/CIR/CodeGen/CIRGenStmt.cpp b/clang/lib/CIR/CodeGen/CIRGenStmt.cpp\nindex 7bb8c2153056a..9f4f681eb9a79 100644\n--- a/clang/lib/CIR/CodeGen/CIRGenStmt.cpp\n+++ b/clang/lib/CIR/CodeGen/CIRGenStmt.cpp\n@@ -458,7 +458,14 @@ mlir::LogicalResult CIRGenFunction::emitReturnStmt(const ReturnStmt &s) {\n     if (getContext().getLangOpts().ElideConstructors && s.getNRVOCandidate() &&\n         s.getNRVOCandidate()->isNRVOVariable()) {\n       assert(!cir::MissingFeatures::openMP());\n-      assert(!cir::MissingFeatures::nrvo());\n+      // Apply the named return value optimization for this return statement,\n+      // which means doing nothing: the appropriate result has already been\n+      // constructed into the NRVO variable.\n+\n+      // If there is an NRVO flag for this variable, set it to 1 into indicate\n+      // that the cleanup code should not destroy the variable.\n+      if (auto nrvoFlag = nrvoFlags[s.getNRVOCandidate()])\n+        builder.createFlagStore(loc, true, nrvoFlag);\n     } else if (!rv) {\n       // No return expression. Do nothing.\n     } else if (rv->getType()->isVoidType()) {", "target": "diff --git a/clang/lib/CIR/CodeGen/CIRGenDecl.cpp b/clang/lib/CIR/CodeGen/CIRGenDecl.cpp\nindex e0e4f67df87b2..c9e10840778b4 100644\n--- a/clang/lib/CIR/CodeGen/CIRGenDecl.cpp\n+++ b/clang/lib/CIR/CodeGen/CIRGenDecl.cpp\n@@ -98,8 +98,22 @@ CIRGenFunction::emitAutoVarAlloca(const VarDecl &d,\n       if (const RecordDecl *rd = ty->getAsRecordDecl()) {\n         if (const auto *cxxrd = dyn_cast<CXXRecordDecl>(rd);\n             (cxxrd && !cxxrd->hasTrivialDestructor()) ||\n-            rd->isNonTrivialToPrimitiveDestroy())\n-          cgm.errorNYI(d.getSourceRange(), \"emitAutoVarAlloca: set NRVO flag\");\n+            rd->isNonTrivialToPrimitiveDestroy()) {\n+          // In LLVM: Create a flag that is used to indicate when the NRVO was\n+          // applied to this variable. Set it to zero to indicate that NRVO was\n+          // not applied. For now, use the same approach for CIRGen until we can\n+          // be sure it's worth doing something more aggressive.\n+          cir::ConstantOp falseNVRO = builder.getFalse(loc);\n+          Address nrvoFlag = createTempAlloca(falseNVRO.getType(),\n+                                              CharUnits::One(), loc, \"nrvo\",\n+                                              /*arraySize=*/nullptr, &address);\n+          assert(builder.getInsertionBlock());\n+          builder.createStore(loc, falseNVRO, nrvoFlag);\n+\n+          // Record the NRVO flag for this variable.\n+          nrvoFlags[&d] = nrvoFlag.getPointer();\n+          emission.nrvoFlag = nrvoFlag.getPointer();\n+        }\n       }\n     } else {\n       // A normal fixed sized variable becomes an alloca in the entry block,\n@@ -965,7 +1008,10 @@ void CIRGenFunction::emitAutoVarTypeCleanup(\n     // If there's an NRVO flag on the emission, we need a different\n     // cleanup.\n     if (emission.nrvoFlag) {\n-      cgm.errorNYI(var->getSourceRange(), \"emitAutoVarTypeCleanup: NRVO\");\n+      assert(!type->isArrayType());\n+      CXXDestructorDecl *dtor = type->getAsCXXRecordDecl()->getDestructor();\n+      ehStack.pushCleanup<DestroyNRVOVariableCXX>(cleanupKind, addr, type, dtor,\n+                                                  emission.nrvoFlag);\n       return;\n     }\n     // Otherwise, this is handled below.\ndiff --git a/clang/lib/CIR/CodeGen/CIRGenStmt.cpp b/clang/lib/CIR/CodeGen/CIRGenStmt.cpp\nindex 7bb8c2153056a..9f4f681eb9a79 100644\n--- a/clang/lib/CIR/CodeGen/CIRGenStmt.cpp\n+++ b/clang/lib/CIR/CodeGen/CIRGenStmt.cpp\n@@ -458,7 +458,14 @@ mlir::LogicalResult CIRGenFunction::emitReturnStmt(const ReturnStmt &s) {\n     if (getContext().getLangOpts().ElideConstructors && s.getNRVOCandidate() &&\n         s.getNRVOCandidate()->isNRVOVariable()) {\n       assert(!cir::MissingFeatures::openMP());\n-      assert(!cir::MissingFeatures::nrvo());\n+      // Apply the named return value optimization for this return statement,\n+      // which means doing nothing: the appropriate result has already been\n+      // constructed into the NRVO variable.\n+\n+      // If there is an NRVO flag for this variable, set it to 1 into indicate\n+      // that the cleanup code should not destroy the variable.\n+      if (auto nrvoFlag = nrvoFlags[s.getNRVOCandidate()])\n+        builder.createFlagStore(loc, true, nrvoFlag);\n     } else if (!rv) {\n       // No return expression. Do nothing.\n     } else if (rv->getType()->isVoidType()) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CIR代码生成器缺少NRVO（命名返回值优化）框架，无法正确处理需要析构的非平凡类型变量的返回值优化场景，遇到NRVO候选变量时会抛出未实现错误。优化后：1. 为NRVO候选变量创建标志变量（初始为false），记录在nrvoFlags映射中；2. 在return语句中，如果应用NRVO，则将标志变量设置为true；3. 在清理阶段，根据标志变量决定是否调用析构函数（当前框架已搭建，实际析构调用尚未实现）。优化思路：建立NRVO框架，通过标志变量跟踪优化状态，避免不必要的对象拷贝和析构，为后续完整实现NRVO优化奠定基础。"}
{"id": 291, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+代码提升优化", "optimization_description": "优化前：在向量化计划（VPlan）中，对一阶递归（first-order recurrence）进行代码提升（hoisting）时，未处理多值定义（multi-defs）的指令（如VPInterleaveRecipe），导致断言失败。优化后：在hoistPreviousBeforeFORUsers函数中，添加检查条件，当指令定义的值数量不等于1时，直接返回false，避免尝试提升多值定义的指令。优化思路：修复向量化过程中的断言错误，确保代码提升只处理单值定义的指令，为后续支持多值定义指令的提升预留TODO接口。", "original_code": "在向量化计划（VPlan）中，对一阶递归（first-order recurrence）进行代码提升（hoisting）时，未处理多值定义（multi-defs）的指令（如VPInterleaveRecipe），导致断言失败。", "optimized_code": "if (auto *R = NeedsHoisting(Op)) {\n        // Bail out if the recipe defines multiple values.\n        // TODO: Hoisting such recipes requires additional handling.\n        if (R->getNumDefinedValues() != 1)\n          return false;\n        HoistCandidates.push_back(R);\n      }", "source_url": "https://github.com/llvm/llvm-project/commit/f02dc4d19869f91ac967f231abb35e221efba357", "code_v0_no_empty_lines": "在向量化计划（VPlan）中，对一阶递归（first-order recurrence）进行代码提升（hoisting）时，未处理多值定义（multi-defs）的指令（如VPInterleaveRecipe），导致断言失败。", "code_v1_no_empty_lines": "if (auto *R = NeedsHoisting(Op)) {\n        // Bail out if the recipe defines multiple values.\n        // TODO: Hoisting such recipes requires additional handling.\n        if (R->getNumDefinedValues() != 1)\n          return false;\n        HoistCandidates.push_back(R);\n      }", "target": "if (auto *R = NeedsHoisting(Op)) {\n        // Bail out if the recipe defines multiple values.\n        // TODO: Hoisting such recipes requires additional handling.\n        if (R->getNumDefinedValues() != 1)\n          return false;\n        HoistCandidates.push_back(R);\n      }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在向量化计划（VPlan）中，对一阶递归（first-order recurrence）进行代码提升（hoisting）时，未处理多值定义（multi-defs）的指令（如VPInterleaveRecipe），导致断言失败。优化后：在hoistPreviousBeforeFORUsers函数中，添加检查条件，当指令定义的值数量不等于1时，直接返回false，避免尝试提升多值定义的指令。优化思路：修复向量化过程中的断言错误，确保代码提升只处理单值定义的指令，为后续支持多值定义指令的提升预留TODO接口。"}
{"id": 292, "source": "riscv-dataset-excel", "optimization_type": "配置优化+性能优化", "optimization_description": "优化前：使用单一的LIBC_CONF_STRING_UNSAFE_WIDE_READ布尔标志控制所有字符串高性能函数，粒度较粗，无法为不同函数选择不同实现。优化后：引入LIBC_CONF_STRING_LENGTH_IMPL和LIBC_CONF_FIND_FIRST_CHARACTER_IMPL配置项，支持为strlen和find-first-character相关函数分别选择四种实现（element/word/clang_vector/arch_vector）。优化思路：提供细粒度控制，允许用户根据具体函数和架构选择最优实现，提升字符串操作性能的灵活性和针对性。", "original_code": "使用单一的LIBC_CONF_STRING_UNSAFE_WIDE_READ布尔标志控制所有字符串高性能函数，粒度较粗，无法为不同函数选择不同实现。", "optimized_code": "- if(LIBC_CONF_STRING_UNSAFE_WIDE_READ)\n-   list(APPEND config_options \"-DLIBC_COPT_STRING_UNSAFE_WIDE_READ\")\n- endif()\n+ list(APPEND config_options \"-DLIBC_COPT_STRING_LENGTH_IMPL=${LIBC_CONF_STRING_LENGTH_IMPL}\")\n+ list(APPEND config_options \"-DLIBC_COPT_FIND_FIRST_CHARACTER_IMPL=${LIBC_CONF_FIND_FIRST_CHARACTER_IMPL}\")", "source_url": "https://github.com/llvm/llvm-project/commit/ed7e66a41d084ca442e6425a29dddfab1e647751", "code_v0_no_empty_lines": "使用单一的LIBC_CONF_STRING_UNSAFE_WIDE_READ布尔标志控制所有字符串高性能函数，粒度较粗，无法为不同函数选择不同实现。", "code_v1_no_empty_lines": "- if(LIBC_CONF_STRING_UNSAFE_WIDE_READ)\n-   list(APPEND config_options \"-DLIBC_COPT_STRING_UNSAFE_WIDE_READ\")\n- endif()\n+ list(APPEND config_options \"-DLIBC_COPT_STRING_LENGTH_IMPL=${LIBC_CONF_STRING_LENGTH_IMPL}\")\n+ list(APPEND config_options \"-DLIBC_COPT_FIND_FIRST_CHARACTER_IMPL=${LIBC_CONF_FIND_FIRST_CHARACTER_IMPL}\")", "target": "- if(LIBC_CONF_STRING_UNSAFE_WIDE_READ)\n-   list(APPEND config_options \"-DLIBC_COPT_STRING_UNSAFE_WIDE_READ\")\n- endif()\n+ list(APPEND config_options \"-DLIBC_COPT_STRING_LENGTH_IMPL=${LIBC_CONF_STRING_LENGTH_IMPL}\")\n+ list(APPEND config_options \"-DLIBC_COPT_FIND_FIRST_CHARACTER_IMPL=${LIBC_CONF_FIND_FIRST_CHARACTER_IMPL}\")", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用单一的LIBC_CONF_STRING_UNSAFE_WIDE_READ布尔标志控制所有字符串高性能函数，粒度较粗，无法为不同函数选择不同实现。优化后：引入LIBC_CONF_STRING_LENGTH_IMPL和LIBC_CONF_FIND_FIRST_CHARACTER_IMPL配置项，支持为strlen和find-first-character相关函数分别选择四种实现（element/word/clang_vector/arch_vector）。优化思路：提供细粒度控制，允许用户根据具体函数和架构选择最优实现，提升字符串操作性能的灵活性和针对性。"}
{"id": 293, "source": "riscv-dataset-excel", "optimization_type": "指令集扩展+代码生成优化", "optimization_description": "优化前：RISC-V P扩展不支持向量移位指令，当遇到向量移位操作时无法生成高效代码。优化后：1. 添加对SHL操作的自定义处理，当检测到P扩展启用且为定长向量时，若移位量为标量（通过SPLAT_VECTOR广播），则直接使用新增的PSLL指令模式生成高效代码；若移位量为向量，则回退到标量展开计算。2. 在指令定义文件中添加8位、16位、32位逻辑左移的指令模式匹配，支持标量移位量的向量移位操作。优化思路：利用P扩展的打包指令特性，通过新增指令模式匹配和代码生成逻辑，将原本需要标量展开的向量移位操作转换为单条P扩展指令执行，显著提升向量移位性能。", "original_code": "RISC-V P扩展不支持向量移位指令，当遇到向量移位操作时无法生成高效代码。", "optimized_code": "1. RISCVISelLowering.cpp:\n   + setOperationAction(ISD::SHL, VTs, Custom);\n   + case ISD::SHL:\n     if (Subtarget.enablePExtCodeGen() && Op.getSimpleValueType().isFixedLengthVector()) {\n       if (Op.getOperand(1)->getOpcode() == ISD::SPLAT_VECTOR) return Op;\n       return DAG.UnrollVectorOp(Op.getNode());\n     }\n2. RISCVInstrInfoP.td:\n   + def: Pat<(XLenVecI8VT (shl GPR:$rs1, (XLenVecI8VT (splat_vector (XLenVT GPR:$rs2))))), (PSLL_BS GPR:$rs1, GPR:$rs2)>;\n   + def: Pat<(XLenVecI16VT (shl GPR:$rs1, (XLenVecI16VT (splat_vector (XLenVT GPR:$rs2))))), (PSLL_HS GPR:$rs1, GPR:$rs2)>;\n   + def: Pat<(v2i32 (shl GPR:$rs1, (v2i32 (splat_vector (XLenVT GPR:$rs2))))), (PSLL_WS GPR:$rs1, GPR:$rs2)>;", "source_url": "https://github.com/llvm/llvm-project/commit/af4098b45a753a317d6a36aa76235fe30a401733", "code_v0_no_empty_lines": "RISC-V P扩展不支持向量移位指令，当遇到向量移位操作时无法生成高效代码。", "code_v1_no_empty_lines": "1. RISCVISelLowering.cpp:\n   + setOperationAction(ISD::SHL, VTs, Custom);\n   + case ISD::SHL:\n     if (Subtarget.enablePExtCodeGen() && Op.getSimpleValueType().isFixedLengthVector()) {\n       if (Op.getOperand(1)->getOpcode() == ISD::SPLAT_VECTOR) return Op;\n       return DAG.UnrollVectorOp(Op.getNode());\n     }\n2. RISCVInstrInfoP.td:\n   + def: Pat<(XLenVecI8VT (shl GPR:$rs1, (XLenVecI8VT (splat_vector (XLenVT GPR:$rs2))))), (PSLL_BS GPR:$rs1, GPR:$rs2)>;\n   + def: Pat<(XLenVecI16VT (shl GPR:$rs1, (XLenVecI16VT (splat_vector (XLenVT GPR:$rs2))))), (PSLL_HS GPR:$rs1, GPR:$rs2)>;\n   + def: Pat<(v2i32 (shl GPR:$rs1, (v2i32 (splat_vector (XLenVT GPR:$rs2))))), (PSLL_WS GPR:$rs1, GPR:$rs2)>;", "target": "1. RISCVISelLowering.cpp:\n   + setOperationAction(ISD::SHL, VTs, Custom);\n   + case ISD::SHL:\n     if (Subtarget.enablePExtCodeGen() && Op.getSimpleValueType().isFixedLengthVector()) {\n       if (Op.getOperand(1)->getOpcode() == ISD::SPLAT_VECTOR) return Op;\n       return DAG.UnrollVectorOp(Op.getNode());\n     }\n2. RISCVInstrInfoP.td:\n   + def: Pat<(XLenVecI8VT (shl GPR:$rs1, (XLenVecI8VT (splat_vector (XLenVT GPR:$rs2))))), (PSLL_BS GPR:$rs1, GPR:$rs2)>;\n   + def: Pat<(XLenVecI16VT (shl GPR:$rs1, (XLenVecI16VT (splat_vector (XLenVT GPR:$rs2))))), (PSLL_HS GPR:$rs1, GPR:$rs2)>;\n   + def: Pat<(v2i32 (shl GPR:$rs1, (v2i32 (splat_vector (XLenVT GPR:$rs2))))), (PSLL_WS GPR:$rs1, GPR:$rs2)>;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V P扩展不支持向量移位指令，当遇到向量移位操作时无法生成高效代码。优化后：1. 添加对SHL操作的自定义处理，当检测到P扩展启用且为定长向量时，若移位量为标量（通过SPLAT_VECTOR广播），则直接使用新增的PSLL指令模式生成高效代码；若移位量为向量，则回退到标量展开计算。2. 在指令定义文件中添加8位、16位、32位逻辑左移的指令模式匹配，支持标量移位量的向量移位操作。优化思路：利用P扩展的打包指令特性，通过新增指令模式匹配和代码生成逻辑，将原本需要标量展开的向量移位操作转换为单条P扩展指令执行，显著提升向量移位性能。"}
{"id": 294, "source": "riscv-dataset-excel", "optimization_type": "指令集扩展支持", "optimization_description": "优化前：RISCV后端不支持Zvfbfa扩展的VFADD、VFSUB、VFMUL指令生成，相关浮点运算需要软件模拟或降级处理。优化后：在RISCVISelLowering.cpp中将FADD、FSUB、FMUL操作添加到ZvfbfaOps数组，使其在Zvfbfa扩展下合法化；在RISCVInstrInfoVSDPatterns.td中修改模式匹配模板，支持BF16向量类型；新增测试文件验证代码生成。优化思路：通过扩展LLVM后端的合法化规则和模式匹配，直接利用硬件指令加速BF16浮点向量运算，提升计算性能。", "original_code": "RISCV后端不支持Zvfbfa扩展的VFADD、VFSUB、VFMUL指令生成，相关浮点运算需要软件模拟或降级处理。", "optimized_code": "static const unsigned ZvfbfaOps[] = {\n    ISD::FNEG, ISD::FABS, ISD::FCOPYSIGN, ISD::SPLAT_VECTOR,\n    ISD::FADD, ISD::FSUB, ISD::FMUL};\n\nmulticlass VPatBinaryFPSDNode_VV_VF_RM<SDPatternOperator vop, string instruction_name,\n                                       bit isSEWAware = 0, bit isBF16 = 0> {\n  foreach vti = !if(isBF16, AllBF16Vectors, AllFloatVectors) in {", "source_url": "https://github.com/llvm/llvm-project/commit/e48d49fd6d09dd7082590360544f801460aee96a", "code_v0_no_empty_lines": "RISCV后端不支持Zvfbfa扩展的VFADD、VFSUB、VFMUL指令生成，相关浮点运算需要软件模拟或降级处理。", "code_v1_no_empty_lines": "static const unsigned ZvfbfaOps[] = {\n    ISD::FNEG, ISD::FABS, ISD::FCOPYSIGN, ISD::SPLAT_VECTOR,\n    ISD::FADD, ISD::FSUB, ISD::FMUL};\n\nmulticlass VPatBinaryFPSDNode_VV_VF_RM<SDPatternOperator vop, string instruction_name,\n                                       bit isSEWAware = 0, bit isBF16 = 0> {\n  foreach vti = !if(isBF16, AllBF16Vectors, AllFloatVectors) in {", "target": "static const unsigned ZvfbfaOps[] = {\n    ISD::FNEG, ISD::FABS, ISD::FCOPYSIGN, ISD::SPLAT_VECTOR,\n    ISD::FADD, ISD::FSUB, ISD::FMUL};\n\nmulticlass VPatBinaryFPSDNode_VV_VF_RM<SDPatternOperator vop, string instruction_name,\n                                       bit isSEWAware = 0, bit isBF16 = 0> {\n  foreach vti = !if(isBF16, AllBF16Vectors, AllFloatVectors) in {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISCV后端不支持Zvfbfa扩展的VFADD、VFSUB、VFMUL指令生成，相关浮点运算需要软件模拟或降级处理。优化后：在RISCVISelLowering.cpp中将FADD、FSUB、FMUL操作添加到ZvfbfaOps数组，使其在Zvfbfa扩展下合法化；在RISCVInstrInfoVSDPatterns.td中修改模式匹配模板，支持BF16向量类型；新增测试文件验证代码生成。优化思路：通过扩展LLVM后端的合法化规则和模式匹配，直接利用硬件指令加速BF16浮点向量运算，提升计算性能。"}
{"id": 295, "source": "riscv-dataset-excel", "optimization_type": "常量折叠优化", "optimization_description": "优化前：在SelectionDAG的getNode函数中，当乘法操作被扩展为多个部分并可能转换为库调用时，即使乘数为0，也无法优化掉整个乘法操作。优化后：在getNode函数中增加检查，当检测到乘数为0时，直接返回0作为结果，避免不必要的计算和库调用。优化思路：在DAG构建阶段尽早识别并折叠mul 0 -> 0的常量表达式，确保扩展乘法操作能正确优化。", "original_code": "在SelectionDAG的getNode函数中，当乘法操作被扩展为多个部分并可能转换为库调用时，即使乘数为0，也无法优化掉整个乘法操作。", "optimized_code": "+    if (N2CV && N2CV->isZero())\n+      return N2;", "source_url": "https://github.com/llvm/llvm-project/commit/4c6b8825e84067c44780b2720429032d054af59a", "code_v0_no_empty_lines": "在SelectionDAG的getNode函数中，当乘法操作被扩展为多个部分并可能转换为库调用时，即使乘数为0，也无法优化掉整个乘法操作。", "code_v1_no_empty_lines": "+    if (N2CV && N2CV->isZero())\n+      return N2;", "target": "+    if (N2CV && N2CV->isZero())\n+      return N2;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在SelectionDAG的getNode函数中，当乘法操作被扩展为多个部分并可能转换为库调用时，即使乘数为0，也无法优化掉整个乘法操作。优化后：在getNode函数中增加检查，当检测到乘数为0时，直接返回0作为结果，避免不必要的计算和库调用。优化思路：在DAG构建阶段尽早识别并折叠mul 0 -> 0的常量表达式，确保扩展乘法操作能正确优化。"}
{"id": 296, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化", "optimization_description": "优化前：在LowerShuffle中无条件调用canonicalizeShuffleMaskWithHorizOp，导致某些全通道洗牌（如VPERM2F128）被错误规范化，陷入无限循环或生成低效代码。优化后：添加条件判断，仅当洗牌无法扩展时才调用规范化函数，避免破坏全通道洗牌模式。思路：识别并保护能够生成高效指令（如VPERM2F128）的洗牌模式，防止不必要的规范化干扰代码生成。", "original_code": "在LowerShuffle中无条件调用canonicalizeShuffleMaskWithHorizOp，导致某些全通道洗牌（如VPERM2F128）被错误规范化，陷入无限循环或生成低效代码。", "optimized_code": "if (!canWidenShuffleElements(Mask)) {\n    if (SDValue HOp = canonicalizeShuffleMaskWithHorizOp(\n            Ops, Mask, VT.getSizeInBits(), DL, DAG, Subtarget))\n      return DAG.getBitcast(VT, HOp);\n\n    V1 = DAG.getBitcast(VT, Ops[0]);\n    V2 = DAG.getBitcast(VT, Ops[1]);\n    assert(NumElements == (int)Mask.size() &&\n           \"canonicalizeShuffleMaskWithHorizOp \"\n           \"shouldn't alter the shuffle mask size\");\n  }", "source_url": "https://github.com/llvm/llvm-project/commit/990289ccd598e252101368c7f34ed70db8bc4bdd", "code_v0_no_empty_lines": "在LowerShuffle中无条件调用canonicalizeShuffleMaskWithHorizOp，导致某些全通道洗牌（如VPERM2F128）被错误规范化，陷入无限循环或生成低效代码。", "code_v1_no_empty_lines": "if (!canWidenShuffleElements(Mask)) {\n    if (SDValue HOp = canonicalizeShuffleMaskWithHorizOp(\n            Ops, Mask, VT.getSizeInBits(), DL, DAG, Subtarget))\n      return DAG.getBitcast(VT, HOp);\n\n    V1 = DAG.getBitcast(VT, Ops[0]);\n    V2 = DAG.getBitcast(VT, Ops[1]);\n    assert(NumElements == (int)Mask.size() &&\n           \"canonicalizeShuffleMaskWithHorizOp \"\n           \"shouldn't alter the shuffle mask size\");\n  }", "target": "if (!canWidenShuffleElements(Mask)) {\n    if (SDValue HOp = canonicalizeShuffleMaskWithHorizOp(\n            Ops, Mask, VT.getSizeInBits(), DL, DAG, Subtarget))\n      return DAG.getBitcast(VT, HOp);\n\n    V1 = DAG.getBitcast(VT, Ops[0]);\n    V2 = DAG.getBitcast(VT, Ops[1]);\n    assert(NumElements == (int)Mask.size() &&\n           \"canonicalizeShuffleMaskWithHorizOp \"\n           \"shouldn't alter the shuffle mask size\");\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在LowerShuffle中无条件调用canonicalizeShuffleMaskWithHorizOp，导致某些全通道洗牌（如VPERM2F128）被错误规范化，陷入无限循环或生成低效代码。优化后：添加条件判断，仅当洗牌无法扩展时才调用规范化函数，避免破坏全通道洗牌模式。思路：识别并保护能够生成高效指令（如VPERM2F128）的洗牌模式，防止不必要的规范化干扰代码生成。"}
{"id": 297, "source": "riscv-dataset-excel", "optimization_type": "指令优化+代码重构", "optimization_description": "优化前：exp10(f16) 的实现通过两个乘法（0x40549000 和 0x3a2784bc）和两个指数运算（v_exp_f32）来计算，然后相乘，产生冗余计算。优化后：引入 lowerFEXPUnsafeImpl 函数，统一处理 exp 和 exp10 的 lowering，对于 exp10(f16) 直接使用单个常数 0x40549a78（log2(10)）进行乘法，然后调用一次指数运算。优化思路：通过代码重构消除冗余计算，减少指令数量，提高半精度浮点指数运算的性能。", "original_code": "exp10(f16) 的实现通过两个乘法（0x40549000 和 0x3a2784bc）和两个指数运算（v_exp_f32）来计算，然后相乘，产生冗余计算。", "optimized_code": "SDValue AMDGPUTargetLowering::lowerFEXPUnsafeImpl(SDValue X, const SDLoc &SL,\n                                                  SelectionDAG &DAG,\n                                                  SDNodeFlags Flags,\n                                                  bool IsExp10) const {\n  // exp(x) -> exp2(M_LOG2E_F * x);\n  // exp10(x) -> exp2(log2(10) * x);\n  EVT VT = X.getValueType();\n  SDValue Const =\n      DAG.getConstantFP(IsExp10 ? 0x1.a934f0p+1f : numbers::log2e, SL, VT);\n\n  SDValue Mul = DAG.getNode(ISD::FMUL, SL, VT, X, Const, Flags);\n  return DAG.getNode(VT == MVT::f32 ? (unsigned)AMDGPUISD::EXP\n                                    : (unsigned)ISD::FEXP2,\n                     SL, VT, Mul, Flags);\n}", "source_url": "https://github.com/llvm/llvm-project/commit/63e9d607866f70d25d93fbdf4c4cd217efba195f", "code_v0_no_empty_lines": "exp10(f16) 的实现通过两个乘法（0x40549000 和 0x3a2784bc）和两个指数运算（v_exp_f32）来计算，然后相乘，产生冗余计算。", "code_v1_no_empty_lines": "SDValue AMDGPUTargetLowering::lowerFEXPUnsafeImpl(SDValue X, const SDLoc &SL,\n                                                  SelectionDAG &DAG,\n                                                  SDNodeFlags Flags,\n                                                  bool IsExp10) const {\n  // exp(x) -> exp2(M_LOG2E_F * x);\n  // exp10(x) -> exp2(log2(10) * x);\n  EVT VT = X.getValueType();\n  SDValue Const =\n      DAG.getConstantFP(IsExp10 ? 0x1.a934f0p+1f : numbers::log2e, SL, VT);\n\n  SDValue Mul = DAG.getNode(ISD::FMUL, SL, VT, X, Const, Flags);\n  return DAG.getNode(VT == MVT::f32 ? (unsigned)AMDGPUISD::EXP\n                                    : (unsigned)ISD::FEXP2,\n                     SL, VT, Mul, Flags);\n}", "target": "SDValue AMDGPUTargetLowering::lowerFEXPUnsafeImpl(SDValue X, const SDLoc &SL,\n                                                  SelectionDAG &DAG,\n                                                  SDNodeFlags Flags,\n                                                  bool IsExp10) const {\n  // exp(x) -> exp2(M_LOG2E_F * x);\n  // exp10(x) -> exp2(log2(10) * x);\n  EVT VT = X.getValueType();\n  SDValue Const =\n      DAG.getConstantFP(IsExp10 ? 0x1.a934f0p+1f : numbers::log2e, SL, VT);\n\n  SDValue Mul = DAG.getNode(ISD::FMUL, SL, VT, X, Const, Flags);\n  return DAG.getNode(VT == MVT::f32 ? (unsigned)AMDGPUISD::EXP\n                                    : (unsigned)ISD::FEXP2,\n                     SL, VT, Mul, Flags);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：exp10(f16) 的实现通过两个乘法（0x40549000 和 0x3a2784bc）和两个指数运算（v_exp_f32）来计算，然后相乘，产生冗余计算。优化后：引入 lowerFEXPUnsafeImpl 函数，统一处理 exp 和 exp10 的 lowering，对于 exp10(f16) 直接使用单个常数 0x40549a78（log2(10)）进行乘法，然后调用一次指数运算。优化思路：通过代码重构消除冗余计算，减少指令数量，提高半精度浮点指数运算的性能。"}
{"id": 298, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+寄存器分配优化", "optimization_description": "优化前：SVE饱和/舍入左移内在函数只有单一版本，无法根据寄存器分配情况选择最优指令变体。优化后：为SVE饱和/舍入左移内在函数添加\"u\"变体（如sqrshl_u），这些变体保持非活动通道结果\"don't care\"的特性，允许编译器根据寄存器分配情况在反向（reversed）和movprfx变体之间选择最佳实现。优化思路：通过提供更多指令变体，让寄存器分配器有更多选择空间，从而生成更高效的代码序列。", "original_code": "SVE饱和/舍入左移内在函数只有单一版本，无法根据寄存器分配情况选择最优指令变体。", "optimized_code": "multiclass SInstZPZxZ<string name, string types, string pat_v, string pat_n, string m_intrinsic, string x_intrinsic, list<FlagType> flags=[]> {\n  def _M   : SInst<name # \"[_{d}]\", pat_v, types, MergeOp1,  m_intrinsic, flags>;\n  def _X   : SInst<name # \"[_{d}]\", pat_v, types, MergeAny,  x_intrinsic, flags>;\n  def _Z   : SInst<name # \"[_{d}]\", pat_v, types, MergeZero, m_intrinsic, flags>;\n\n  def _N_M : SInst<name # \"[_n_{d}]\", pat_n, types, MergeOp1,  m_intrinsic, flags>;\n  def _N_X : SInst<name # \"[_n_{d}]\", pat_n, types, MergeAny,  x_intrinsic, flags>;\n  def _N_Z : SInst<name # \"[_n_{d}]\", pat_n, types, MergeZero, m_intrinsic, flags>;\n}\n\ndefm SVQRSHL_S : SInstZPZxZ<\"svqrshl\", \"csil\",     \"dPdx\", \"dPdK\", \"aarch64_sve_sqrshl\", \"aarch64_sve_sqrshl_u\", [VerifyRuntimeMode]>;", "source_url": "https://github.com/llvm/llvm-project/commit/f1998360c3b1613440103101bce2b24b71695a4a", "code_v0_no_empty_lines": "SVE饱和/舍入左移内在函数只有单一版本，无法根据寄存器分配情况选择最优指令变体。", "code_v1_no_empty_lines": "multiclass SInstZPZxZ<string name, string types, string pat_v, string pat_n, string m_intrinsic, string x_intrinsic, list<FlagType> flags=[]> {\n  def _M   : SInst<name # \"[_{d}]\", pat_v, types, MergeOp1,  m_intrinsic, flags>;\n  def _X   : SInst<name # \"[_{d}]\", pat_v, types, MergeAny,  x_intrinsic, flags>;\n  def _Z   : SInst<name # \"[_{d}]\", pat_v, types, MergeZero, m_intrinsic, flags>;\n\n  def _N_M : SInst<name # \"[_n_{d}]\", pat_n, types, MergeOp1,  m_intrinsic, flags>;\n  def _N_X : SInst<name # \"[_n_{d}]\", pat_n, types, MergeAny,  x_intrinsic, flags>;\n  def _N_Z : SInst<name # \"[_n_{d}]\", pat_n, types, MergeZero, m_intrinsic, flags>;\n}\n\ndefm SVQRSHL_S : SInstZPZxZ<\"svqrshl\", \"csil\",     \"dPdx\", \"dPdK\", \"aarch64_sve_sqrshl\", \"aarch64_sve_sqrshl_u\", [VerifyRuntimeMode]>;", "target": "multiclass SInstZPZxZ<string name, string types, string pat_v, string pat_n, string m_intrinsic, string x_intrinsic, list<FlagType> flags=[]> {\n  def _M   : SInst<name # \"[_{d}]\", pat_v, types, MergeOp1,  m_intrinsic, flags>;\n  def _X   : SInst<name # \"[_{d}]\", pat_v, types, MergeAny,  x_intrinsic, flags>;\n  def _Z   : SInst<name # \"[_{d}]\", pat_v, types, MergeZero, m_intrinsic, flags>;\n\n  def _N_M : SInst<name # \"[_n_{d}]\", pat_n, types, MergeOp1,  m_intrinsic, flags>;\n  def _N_X : SInst<name # \"[_n_{d}]\", pat_n, types, MergeAny,  x_intrinsic, flags>;\n  def _N_Z : SInst<name # \"[_n_{d}]\", pat_n, types, MergeZero, m_intrinsic, flags>;\n}\n\ndefm SVQRSHL_S : SInstZPZxZ<\"svqrshl\", \"csil\",     \"dPdx\", \"dPdK\", \"aarch64_sve_sqrshl\", \"aarch64_sve_sqrshl_u\", [VerifyRuntimeMode]>;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SVE饱和/舍入左移内在函数只有单一版本，无法根据寄存器分配情况选择最优指令变体。优化后：为SVE饱和/舍入左移内在函数添加\"u\"变体（如sqrshl_u），这些变体保持非活动通道结果\"don't care\"的特性，允许编译器根据寄存器分配情况在反向（reversed）和movprfx变体之间选择最佳实现。优化思路：通过提供更多指令变体，让寄存器分配器有更多选择空间，从而生成更高效的代码序列。"}
{"id": 299, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：FNEG+FMA序列需要两个独立操作（FNEG指令后跟FMA指令）。优化后：通过LowerFMA函数识别FNEG+FMA模式，将其合并为单个FNML[A|S]指令。优化思路：在指令选择阶段检测向量浮点乘加操作中的取反操作数，利用AArch64架构的融合乘加-取反指令（FNMLS/FNMLA/FNMSB/FNMAD）减少指令数量，提高执行效率。", "original_code": "FNEG+FMA序列需要两个独立操作（FNEG指令后跟FMA指令）。", "optimized_code": "case ISD::FMA:\n-    return LowerToPredicatedOp(Op, DAG, AArch64ISD::FMA_PRED);\n+    return LowerFMA(Op, DAG);", "source_url": "https://github.com/llvm/llvm-project/commit/ccfe7e09540f94e0419c607396e270f8d456e608", "code_v0_no_empty_lines": "FNEG+FMA序列需要两个独立操作（FNEG指令后跟FMA指令）。", "code_v1_no_empty_lines": "case ISD::FMA:\n-    return LowerToPredicatedOp(Op, DAG, AArch64ISD::FMA_PRED);\n+    return LowerFMA(Op, DAG);", "target": "case ISD::FMA:\n-    return LowerToPredicatedOp(Op, DAG, AArch64ISD::FMA_PRED);\n+    return LowerFMA(Op, DAG);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：FNEG+FMA序列需要两个独立操作（FNEG指令后跟FMA指令）。优化后：通过LowerFMA函数识别FNEG+FMA模式，将其合并为单个FNML[A|S]指令。优化思路：在指令选择阶段检测向量浮点乘加操作中的取反操作数，利用AArch64架构的融合乘加-取反指令（FNMLS/FNMLA/FNMSB/FNMAD）减少指令数量，提高执行效率。"}
{"id": 300, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化", "optimization_description": "优化前：zext(X86setcc ...) 模式没有对应的指令选择模式，可能导致生成效率较低的指令序列。优化后：添加了新的指令选择模式，将 zext(X86setcc ...) 直接映射到 SETZUCCr 指令，利用 X86 APX 扩展的零扩展条件设置指令。思路：通过添加模式匹配，编译器能够识别这种常见模式并直接生成更高效的 SETZUCCr 指令，减少指令数量和寄存器操作。", "original_code": "zext(X86setcc ...) 模式没有对应的指令选择模式，可能导致生成效率较低的指令序列。", "optimized_code": "let Predicates = [HasZU] in\n  def : Pat<(i32 (zext (X86setcc timm:$cond, EFLAGS))),\n            (INSERT_SUBREG (i32 (IMPLICIT_DEF)), (SETZUCCr ccode:$cond), sub_8bit)>;", "source_url": "https://github.com/llvm/llvm-project/commit/2612dc9b5faeaeb180c5a5e0c282642faef8891b", "code_v0_no_empty_lines": "zext(X86setcc ...) 模式没有对应的指令选择模式，可能导致生成效率较低的指令序列。", "code_v1_no_empty_lines": "let Predicates = [HasZU] in\n  def : Pat<(i32 (zext (X86setcc timm:$cond, EFLAGS))),\n            (INSERT_SUBREG (i32 (IMPLICIT_DEF)), (SETZUCCr ccode:$cond), sub_8bit)>;", "target": "let Predicates = [HasZU] in\n  def : Pat<(i32 (zext (X86setcc timm:$cond, EFLAGS))),\n            (INSERT_SUBREG (i32 (IMPLICIT_DEF)), (SETZUCCr ccode:$cond), sub_8bit)>;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：zext(X86setcc ...) 模式没有对应的指令选择模式，可能导致生成效率较低的指令序列。优化后：添加了新的指令选择模式，将 zext(X86setcc ...) 直接映射到 SETZUCCr 指令，利用 X86 APX 扩展的零扩展条件设置指令。思路：通过添加模式匹配，编译器能够识别这种常见模式并直接生成更高效的 SETZUCCr 指令，减少指令数量和寄存器操作。"}
{"id": 301, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+GC性能优化", "optimization_description": "优化前：1) G1在年轻代收集期间可能执行内存取消提交，增加开销；2) 默认GCTimeRatio为12（约8% GC开销），可能导致堆过度扩展；3) 在Remark阶段进行堆大小调整。优化后：1) 移除年轻代收集期间的内存取消提交，减少GC暂停时间；2) 将默认GCTimeRatio调整为24（约4% GC开销），降低堆扩展频率；3) 重构堆大小调整逻辑，分离完整收集和年轻代收集的调整策略。优化思路：通过减少不必要的内存操作和调整GC开销目标，降低GC开销，提高应用吞吐量。", "original_code": "1) G1在年轻代收集期间可能执行内存取消提交，增加开销；2) 默认GCTimeRatio为12（约8% GC开销），可能导致堆过度扩展；3) 在Remark阶段进行堆大小调整。", "optimized_code": "--- a/src/hotspot/share/gc/g1/g1Arguments.cpp\n+++ b/src/hotspot/share/gc/g1/g1Arguments.cpp\n@@ -196,8 +196,8 @@ void G1Arguments::initialize() {\n   if (FLAG_IS_DEFAULT(GCTimeRatio) || GCTimeRatio == 0) {\n     // In G1, we want the default GC overhead goal to be higher than\n     // it is for PS, or the heap might be expanded too aggressively.\n-    // We set it here to ~8%.\n-    FLAG_SET_DEFAULT(GCTimeRatio, 12);\n+    // We set it here to 4%.\n+    FLAG_SET_DEFAULT(GCTimeRatio, 24);\n   }", "source_url": "https://github.com/openjdk/riscv-port/commit/4761479608d5a8ecc504e343109900b0d0c77171", "code_v0_no_empty_lines": "1) G1在年轻代收集期间可能执行内存取消提交，增加开销；2) 默认GCTimeRatio为12（约8% GC开销），可能导致堆过度扩展；3) 在Remark阶段进行堆大小调整。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/gc/g1/g1Arguments.cpp\n+++ b/src/hotspot/share/gc/g1/g1Arguments.cpp\n@@ -196,8 +196,8 @@ void G1Arguments::initialize() {\n   if (FLAG_IS_DEFAULT(GCTimeRatio) || GCTimeRatio == 0) {\n     // In G1, we want the default GC overhead goal to be higher than\n     // it is for PS, or the heap might be expanded too aggressively.\n-    // We set it here to ~8%.\n-    FLAG_SET_DEFAULT(GCTimeRatio, 12);\n+    // We set it here to 4%.\n+    FLAG_SET_DEFAULT(GCTimeRatio, 24);\n   }", "target": "--- a/src/hotspot/share/gc/g1/g1Arguments.cpp\n+++ b/src/hotspot/share/gc/g1/g1Arguments.cpp\n@@ -196,8 +196,8 @@ void G1Arguments::initialize() {\n   if (FLAG_IS_DEFAULT(GCTimeRatio) || GCTimeRatio == 0) {\n     // In G1, we want the default GC overhead goal to be higher than\n     // it is for PS, or the heap might be expanded too aggressively.\n-    // We set it here to ~8%.\n-    FLAG_SET_DEFAULT(GCTimeRatio, 12);\n+    // We set it here to 4%.\n+    FLAG_SET_DEFAULT(GCTimeRatio, 24);\n   }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1) G1在年轻代收集期间可能执行内存取消提交，增加开销；2) 默认GCTimeRatio为12（约8% GC开销），可能导致堆过度扩展；3) 在Remark阶段进行堆大小调整。优化后：1) 移除年轻代收集期间的内存取消提交，减少GC暂停时间；2) 将默认GCTimeRatio调整为24（约4% GC开销），降低堆扩展频率；3) 重构堆大小调整逻辑，分离完整收集和年轻代收集的调整策略。优化思路：通过减少不必要的内存操作和调整GC开销目标，降低GC开销，提高应用吞吐量。"}
{"id": 302, "source": "riscv-dataset-excel", "optimization_type": "代码重构+API增强", "optimization_description": "优化前：Site类的hashCode()方法抛出UnsupportedOperationException，导致无法在哈希集合中使用。优化后：实现基于pcOffset的哈希计算，使Site对象可用于哈希数据结构。思路：为支持重放编译，需要让编译中间表示对象具备完整的对象语义，包括正确的equals/hashCode实现。", "original_code": "Site类的hashCode()方法抛出UnsupportedOperationException，导致无法在哈希集合中使用。", "optimized_code": "public int hashCode() {\n    return 41 * pcOffset;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/963b83fcf158d273e9433b6845380184b3ad0de5", "code_v0_no_empty_lines": "Site类的hashCode()方法抛出UnsupportedOperationException，导致无法在哈希集合中使用。", "code_v1_no_empty_lines": "public int hashCode() {\n    return 41 * pcOffset;\n}", "target": "public int hashCode() {\n    return 41 * pcOffset;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Site类的hashCode()方法抛出UnsupportedOperationException，导致无法在哈希集合中使用。优化后：实现基于pcOffset的哈希计算，使Site对象可用于哈希数据结构。思路：为支持重放编译，需要让编译中间表示对象具备完整的对象语义，包括正确的equals/hashCode实现。"}
{"id": 303, "source": "riscv-dataset-excel", "optimization_type": "指令集支持优化", "optimization_description": "优化前：AVX512掩码操作（kadd、kand、kor、kxor、knot、kmov等）在CIR代码生成中未实现，导致相关内置函数调用无法正确生成目标代码。优化后：新增emitX86MaskAddLogic和emitX86MaskLogic辅助函数，为AVX512掩码操作提供统一的代码生成路径，将内置函数映射到对应的LLVM内部函数或CIR操作。优化思路：通过提取公共逻辑、重用位转换和向量化处理，实现对AVX512掩码指令集的完整支持，确保生成的CIR中间表示能正确匹配LLVM语义，为后续优化和代码生成奠定基础。", "original_code": "AVX512掩码操作（kadd、kand、kor、kxor、knot、kmov等）在CIR代码生成中未实现，导致相关内置函数调用无法正确生成目标代码。", "optimized_code": "case X86::BI__builtin_ia32_kaddqi:\n+    return emitX86MaskAddLogic(builder, getLoc(expr->getExprLoc()),\n+                               \"x86.avx512.kadd.b\", ops);\n  case X86::BI__builtin_ia32_kandqi:\n  case X86::BI__builtin_ia32_kandhi:\n  case X86::BI__builtin_ia32_kandsi:\n  case X86::BI__builtin_ia32_kanddi:\n+    return emitX86MaskLogic(builder, getLoc(expr->getExprLoc()),\n+                            cir::BinOpKind::And, ops);", "source_url": "https://github.com/llvm/llvm-project/commit/435bafd0d534c8888783f0610afb86ed20d34fa7", "code_v0_no_empty_lines": "AVX512掩码操作（kadd、kand、kor、kxor、knot、kmov等）在CIR代码生成中未实现，导致相关内置函数调用无法正确生成目标代码。", "code_v1_no_empty_lines": "case X86::BI__builtin_ia32_kaddqi:\n+    return emitX86MaskAddLogic(builder, getLoc(expr->getExprLoc()),\n+                               \"x86.avx512.kadd.b\", ops);\n  case X86::BI__builtin_ia32_kandqi:\n  case X86::BI__builtin_ia32_kandhi:\n  case X86::BI__builtin_ia32_kandsi:\n  case X86::BI__builtin_ia32_kanddi:\n+    return emitX86MaskLogic(builder, getLoc(expr->getExprLoc()),\n+                            cir::BinOpKind::And, ops);", "target": "case X86::BI__builtin_ia32_kaddqi:\n+    return emitX86MaskAddLogic(builder, getLoc(expr->getExprLoc()),\n+                               \"x86.avx512.kadd.b\", ops);\n  case X86::BI__builtin_ia32_kandqi:\n  case X86::BI__builtin_ia32_kandhi:\n  case X86::BI__builtin_ia32_kandsi:\n  case X86::BI__builtin_ia32_kanddi:\n+    return emitX86MaskLogic(builder, getLoc(expr->getExprLoc()),\n+                            cir::BinOpKind::And, ops);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AVX512掩码操作（kadd、kand、kor、kxor、knot、kmov等）在CIR代码生成中未实现，导致相关内置函数调用无法正确生成目标代码。优化后：新增emitX86MaskAddLogic和emitX86MaskLogic辅助函数，为AVX512掩码操作提供统一的代码生成路径，将内置函数映射到对应的LLVM内部函数或CIR操作。优化思路：通过提取公共逻辑、重用位转换和向量化处理，实现对AVX512掩码指令集的完整支持，确保生成的CIR中间表示能正确匹配LLVM语义，为后续优化和代码生成奠定基础。"}
{"id": 304, "source": "riscv-dataset-excel", "optimization_type": "代码重构与维护性优化", "optimization_description": "优化前：各架构的stub、blob和entry使用分散的枚举和声明，导致代码重复和维护困难。优化后：引入全局统一的StubId枚举（如将C1StubId::counter_overflow_id改为StubId::c1_counter_overflow_id），并创建stubInfo.cpp/hpp集中管理所有stub信息。思路：通过统一枚举和集中管理，消除代码重复，提高可维护性，为后续优化（如AOT编译、代码缓存管理）提供基础。", "original_code": "各架构的stub、blob和entry使用分散的枚举和声明，导致代码重复和维护困难。", "optimized_code": "- __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));\n+ __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_counter_overflow_id)));", "source_url": "https://github.com/openjdk/riscv-port/commit/b1fa1ecc988fb07f191892a459625c2c8f2de3b5", "code_v0_no_empty_lines": "各架构的stub、blob和entry使用分散的枚举和声明，导致代码重复和维护困难。", "code_v1_no_empty_lines": "- __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));\n+ __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_counter_overflow_id)));", "target": "- __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));\n+ __ far_call(RuntimeAddress(Runtime1::entry_for(StubId::c1_counter_overflow_id)));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：各架构的stub、blob和entry使用分散的枚举和声明，导致代码重复和维护困难。优化后：引入全局统一的StubId枚举（如将C1StubId::counter_overflow_id改为StubId::c1_counter_overflow_id），并创建stubInfo.cpp/hpp集中管理所有stub信息。思路：通过统一枚举和集中管理，消除代码重复，提高可维护性，为后续优化（如AOT编译、代码缓存管理）提供基础。"}
{"id": 305, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "问题：在向量化的循环体中，会同时处理多个数据 lane。如果同一个向量内的多个元素都满足条件（例如都是当前最大值），简单的向量选择操作会不确定地选择其中一个索引，而不是像标量循环那样顺序执行，从而选择最后一个。\n\n解决方案（如提交描述所述）：\n\n第1步：在向量循环体内，为每个lane记录其对应的索引（例如 i, i+1, i+2, i+3）。\n\n第2步：在循环体内，使用比较结果作为掩码，选择性地更新“最大值向量”和“索引向量”。\n\n关键的缩减后处理：在循环结束后，需要将多个部分结果合并：\n\n首先，找到全局的最终最大值。\n\n然后，比较每个部分结果的最大值是否等于这个全局最大值。\n\n最后，在所有等于全局最大值的部分结果索引中，选择最大的那个索引，这自然就对应了原循环中最后一个出现的最大值的位置。", "original_code": "// No original code extracted from description\n", "optimized_code": "优化前（标量循环）\n\nint64_t max_val = 0;\nint64_t max_idx = 0;\nfor (int64_t i = 0; i < n; i++) {\n    if (src[i] >= max_val) {  // 比较：寻找最大值\n        max_val = src[i];     // 更新最大值\n        max_idx = i;          // 更新索引（选择最后一个满足条件的i）\n    }\n}\nreturn max_idx;\n工作方式：循环逐个元素处理，需要n次迭代。\n\n优化后（向量化循环）\n\n// 向量化处理（假设向量宽度为4）\nfor (int i = 0; i < n; i += 4) {\n    // 一次性加载4个元素\n    <4 x i64> vec_vals = load4(&src[i]);\n    <4 x i64> vec_indices = {i, i+1, i+2, i+3};\n    \n    // 向量化比较和\n    <4 x i1> cmp_mask = (vec_vals >= current_max_vals);\n    current_max_vals = select(cmp_mask, vec_vals, current_max_vals);\n    current_max_indices = select(cmp_mask, vec_indices, current_max_indices);\n}\n\n// 最后缩减阶段：从4个局部结果中找出最终的全局最大值和索引\n工作方式：每次迭代处理4个元素，只需要n/4次迭代，充分利用了现代CPU的SIMD并行能力。", "source_url": "https://github.com/llvm/llvm-project/commit/99addbf73db596403a1702ac5c3f92e58f9e9f55", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "优化前（标量循环）\n\nint64_t max_val = 0;\nint64_t max_idx = 0;\nfor (int64_t i = 0; i < n; i++) {\n    if (src[i] >= max_val) {  // 比较：寻找最大值\n        max_val = src[i];     // 更新最大值\n        max_idx = i;          // 更新索引（选择最后一个满足条件的i）\n    }\n}\nreturn max_idx;\n工作方式：循环逐个元素处理，需要n次迭代。\n\n优化后（向量化循环）\n\n// 向量化处理（假设向量宽度为4）\nfor (int i = 0; i < n; i += 4) {\n    // 一次性加载4个元素\n    <4 x i64> vec_vals = load4(&src[i]);\n    <4 x i64> vec_indices = {i, i+1, i+2, i+3};\n    \n    // 向量化比较和\n    <4 x i1> cmp_mask = (vec_vals >= current_max_vals);\n    current_max_vals = select(cmp_mask, vec_vals, current_max_vals);\n    current_max_indices = select(cmp_mask, vec_indices, current_max_indices);\n}\n\n// 最后缩减阶段：从4个局部结果中找出最终的全局最大值和索引\n工作方式：每次迭代处理4个元素，只需要n/4次迭代，充分利用了现代CPU的SIMD并行能力。", "target": "优化前（标量循环）\n\nint64_t max_val = 0;\nint64_t max_idx = 0;\nfor (int64_t i = 0; i < n; i++) {\n    if (src[i] >= max_val) {  // 比较：寻找最大值\n        max_val = src[i];     // 更新最大值\n        max_idx = i;          // 更新索引（选择最后一个满足条件的i）\n    }\n}\nreturn max_idx;\n工作方式：循环逐个元素处理，需要n次迭代。\n\n优化后（向量化循环）\n\n// 向量化处理（假设向量宽度为4）\nfor (int i = 0; i < n; i += 4) {\n    // 一次性加载4个元素\n    <4 x i64> vec_vals = load4(&src[i]);\n    <4 x i64> vec_indices = {i, i+1, i+2, i+3};\n    \n    // 向量化比较和\n    <4 x i1> cmp_mask = (vec_vals >= current_max_vals);\n    current_max_vals = select(cmp_mask, vec_vals, current_max_vals);\n    current_max_indices = select(cmp_mask, vec_indices, current_max_indices);\n}\n\n// 最后缩减阶段：从4个局部结果中找出最终的全局最大值和索引\n工作方式：每次迭代处理4个元素，只需要n/4次迭代，充分利用了现代CPU的SIMD并行能力。", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "问题：在向量化的循环体中，会同时处理多个数据 lane。如果同一个向量内的多个元素都满足条件（例如都是当前最大值），简单的向量选择操作会不确定地选择其中一个索引，而不是像标量循环那样顺序执行，从而选择最后一个。\n\n解决方案（如提交描述所述）：\n\n第1步：在向量循环体内，为每个lane记录其对应的索引（例如 i, i+1, i+2, i+3）。\n\n第2步：在循环体内，使用比较结果作为掩码，选择性地更新“最大值向量”和“索引向量”。\n\n关键的缩减后处理：在循环结束后，需要将多个部分结果合并：\n\n首先，找到全局的最终最大值。\n\n然后，比较每个部分结果的最大值是否等于这个全局最大值。\n\n最后，在所有等于全局最大值的部分结果索引中，选择最大的那个索引，这自然就对应了原循环中最后一个出现的最大值的位置。"}
{"id": 306, "source": "riscv-dataset-excel", "optimization_type": "调度模型优化", "optimization_description": "优化前：64位SVE gather load指令（非时序和立即数寻址）的吞吐量模型不正确，显示为2/3，与Neoverse N3优化指南中记录的4/5不符。优化后：添加新的资源组N3UnitVL（包含L01、V0、V1单元）并创建新的调度写入资源N3Write_6c_2L01_2V，将相关指令的调度模型更新为该新资源。优化思路：根据硬件文档修正调度模型，使LLVM的指令调度器能更准确地模拟实际硬件性能，从而生成更优化的代码调度。", "original_code": "64位SVE gather load指令（非时序和立即数寻址）的吞吐量模型不正确，显示为2/3，与Neoverse N3优化指南中记录的4/5不符。", "optimized_code": "def N3Write_6c_2L01_2V : SchedWriteRes<[N3UnitVL]> {\n    let Latency = 6;\n    let NumMicroOps = 4;\n    let ReleaseAtCycles = [5];\n}\n\ndef : InstRW<[N3Write_6c_2L01_2V], (instregex \"^LDNT1S?[BHW]_ZZR_D$\")>;\ndef : InstRW<[N3Write_6c_2L01_2V], (instrs LDNT1D_ZZR_D)>;\n\ndef : InstRW<[N3Write_6c_2L01_2V], (instregex \"^GLD(FF)?1S?[BHW]_D_IMM$\",\n                                         \"^GLD(FF)?1D_IMM$\")>;\n\ndef : InstRW<[NWrite_6c_2L01_2V],\n             (instregex \"^GLD(FF)?1S?[BHW]_D_[SU]XTW(_SCALED)?$\",\n                        \"^GLD(FF)?1S?[BHW]_D(_SCALED)?$\",\n                        \"^GLD(FF)?1D_[SU]XTW(_SCALED)?$\",", "source_url": "https://github.com/llvm/llvm-project/commit/3a766dcbc462946ad34c1306be70cbbdc1dc868b", "code_v0_no_empty_lines": "64位SVE gather load指令（非时序和立即数寻址）的吞吐量模型不正确，显示为2/3，与Neoverse N3优化指南中记录的4/5不符。", "code_v1_no_empty_lines": "def N3Write_6c_2L01_2V : SchedWriteRes<[N3UnitVL]> {\n    let Latency = 6;\n    let NumMicroOps = 4;\n    let ReleaseAtCycles = [5];\n}\n\ndef : InstRW<[N3Write_6c_2L01_2V], (instregex \"^LDNT1S?[BHW]_ZZR_D$\")>;\ndef : InstRW<[N3Write_6c_2L01_2V], (instrs LDNT1D_ZZR_D)>;\n\ndef : InstRW<[N3Write_6c_2L01_2V], (instregex \"^GLD(FF)?1S?[BHW]_D_IMM$\",\n                                         \"^GLD(FF)?1D_IMM$\")>;\n\ndef : InstRW<[NWrite_6c_2L01_2V],\n             (instregex \"^GLD(FF)?1S?[BHW]_D_[SU]XTW(_SCALED)?$\",\n                        \"^GLD(FF)?1S?[BHW]_D(_SCALED)?$\",\n                        \"^GLD(FF)?1D_[SU]XTW(_SCALED)?$\",", "target": "def N3Write_6c_2L01_2V : SchedWriteRes<[N3UnitVL]> {\n    let Latency = 6;\n    let NumMicroOps = 4;\n    let ReleaseAtCycles = [5];\n}\n\ndef : InstRW<[N3Write_6c_2L01_2V], (instregex \"^LDNT1S?[BHW]_ZZR_D$\")>;\ndef : InstRW<[N3Write_6c_2L01_2V], (instrs LDNT1D_ZZR_D)>;\n\ndef : InstRW<[N3Write_6c_2L01_2V], (instregex \"^GLD(FF)?1S?[BHW]_D_IMM$\",\n                                         \"^GLD(FF)?1D_IMM$\")>;\n\ndef : InstRW<[NWrite_6c_2L01_2V],\n             (instregex \"^GLD(FF)?1S?[BHW]_D_[SU]XTW(_SCALED)?$\",\n                        \"^GLD(FF)?1S?[BHW]_D(_SCALED)?$\",\n                        \"^GLD(FF)?1D_[SU]XTW(_SCALED)?$\",", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：64位SVE gather load指令（非时序和立即数寻址）的吞吐量模型不正确，显示为2/3，与Neoverse N3优化指南中记录的4/5不符。优化后：添加新的资源组N3UnitVL（包含L01、V0、V1单元）并创建新的调度写入资源N3Write_6c_2L01_2V，将相关指令的调度模型更新为该新资源。优化思路：根据硬件文档修正调度模型，使LLVM的指令调度器能更准确地模拟实际硬件性能，从而生成更优化的代码调度。"}
{"id": 307, "source": "riscv-dataset-excel", "optimization_type": "指令成本模型优化", "optimization_description": "优化前：AArch64目标转换信息中未正确处理ROTR/ROTL指令的成本计算，导致编译器对旋转操作的成本估计过高（如测试中显示成本为5）。优化后：识别funnel shift指令中前两个操作数相等的情况为旋转操作，针对AArch64架构的ror指令特性，为32位和64位整数旋转操作提供准确成本计算：ROTR（fshr）成本为1，ROTL（fshl）在常量移位时成本为1，变量移位时成本为2（需要额外neg指令）。优化思路：利用AArch64硬件指令特性，为旋转操作提供更精确的成本模型，使编译器能做出更好的优化决策。", "original_code": "AArch64目标转换信息中未正确处理ROTR/ROTL指令的成本计算，导致编译器对旋转操作的成本估计过高（如测试中显示成本为5）。", "optimized_code": "// ROTR / ROTL is a funnel shift with equal first and second operand. For\n    // ROTR on integer registers (i32/i64) this can be done in a single ror\n    // instruction. A fshl with a non-constant shift uses a neg + ror.\n    if (RetTy->isIntegerTy() && ICA.getArgs()[0] == ICA.getArgs()[1] &&\n        (RetTy->getPrimitiveSizeInBits() == 32 ||\n         RetTy->getPrimitiveSizeInBits() == 64)) {\n      InstructionCost NegCost =\n          (ICA.getID() == Intrinsic::fshl && !OpInfoZ.isConstant()) ? 1 : 0;\n      return 1 + NegCost;\n    }", "source_url": "https://github.com/llvm/llvm-project/commit/0085ecaa5e16edbc6426b91f97a85de8e32f962c", "code_v0_no_empty_lines": "AArch64目标转换信息中未正确处理ROTR/ROTL指令的成本计算，导致编译器对旋转操作的成本估计过高（如测试中显示成本为5）。", "code_v1_no_empty_lines": "// ROTR / ROTL is a funnel shift with equal first and second operand. For\n    // ROTR on integer registers (i32/i64) this can be done in a single ror\n    // instruction. A fshl with a non-constant shift uses a neg + ror.\n    if (RetTy->isIntegerTy() && ICA.getArgs()[0] == ICA.getArgs()[1] &&\n        (RetTy->getPrimitiveSizeInBits() == 32 ||\n         RetTy->getPrimitiveSizeInBits() == 64)) {\n      InstructionCost NegCost =\n          (ICA.getID() == Intrinsic::fshl && !OpInfoZ.isConstant()) ? 1 : 0;\n      return 1 + NegCost;\n    }", "target": "// ROTR / ROTL is a funnel shift with equal first and second operand. For\n    // ROTR on integer registers (i32/i64) this can be done in a single ror\n    // instruction. A fshl with a non-constant shift uses a neg + ror.\n    if (RetTy->isIntegerTy() && ICA.getArgs()[0] == ICA.getArgs()[1] &&\n        (RetTy->getPrimitiveSizeInBits() == 32 ||\n         RetTy->getPrimitiveSizeInBits() == 64)) {\n      InstructionCost NegCost =\n          (ICA.getID() == Intrinsic::fshl && !OpInfoZ.isConstant()) ? 1 : 0;\n      return 1 + NegCost;\n    }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AArch64目标转换信息中未正确处理ROTR/ROTL指令的成本计算，导致编译器对旋转操作的成本估计过高（如测试中显示成本为5）。优化后：识别funnel shift指令中前两个操作数相等的情况为旋转操作，针对AArch64架构的ror指令特性，为32位和64位整数旋转操作提供准确成本计算：ROTR（fshr）成本为1，ROTL（fshl）在常量移位时成本为1，变量移位时成本为2（需要额外neg指令）。优化思路：利用AArch64硬件指令特性，为旋转操作提供更精确的成本模型，使编译器能做出更好的优化决策。"}
{"id": 308, "source": "riscv-dataset-excel", "optimization_type": "循环展开优化+浮点运算优化", "optimization_description": "优化前：浮点归约循环展开时无法使用并行累加器，限制了指令级并行性。优化后：当浮点归约操作具有reassoc标志且无精确浮点数学要求时，引入并行累加器PHI节点，允许循环展开后多个浮点加法并行执行。优化思路：放宽并行化条件，允许浮点归约在满足关联性条件下使用并行累加器，同时确保IRBuilder正确设置FastMathFlags以保持浮点语义。", "original_code": "浮点归约循环展开时无法使用并行累加器，限制了指令级并行性。", "optimized_code": "@@ -1093,6 +1093,7 @@ llvm::UnrollLoop(Loop *L, UnrollLoopOptions ULO, LoopInfo *LI,\n       if (!RdxResult) {\n         RdxResult = PartialReductions.front();\n         IRBuilder Builder(ExitBlock, ExitBlock->getFirstNonPHIIt());\n+        Builder.setFastMathFlags(Reductions.begin()->second.getFastMathFlags());\n         RecurKind RK = Reductions.begin()->second.getRecurrenceKind();\n         for (Instruction *RdxPart : drop_begin(PartialReductions)) {\n           RdxResult = Builder.CreateBinOp(\n@@ -1255,14 +1256,15 @@ llvm::canParallelizeReductionWhenUnrolling(PHINode &Phi, Loop *L,\n     return std::nullopt;\n   RecurKind RK = RdxDesc.getRecurrenceKind();\n   // Skip unsupported reductions.\n-  // TODO: Handle additional reductions, including FP and min-max\n-  // reductions.\n-  if (!RecurrenceDescriptor::isIntegerRecurrenceKind(RK) ||\n-      RecurrenceDescriptor::isAnyOfRecurrenceKind(RK) ||\n+  // TODO: Handle additional reductions, including min-max reductions.\n+  if (RecurrenceDescriptor::isAnyOfRecurrenceKind(RK) ||\n       RecurrenceDescriptor::isFindIVRecurrenceKind(RK) ||\n       RecurrenceDescriptor::isMinMaxRecurrenceKind(RK))\n     return std::nullopt;\n \n+  if (RdxDesc.hasExactFPMath())\n+    return std::nullopt;\n+\n   if (RdxDesc.IntermediateStore)\n     return std::nullopt;", "source_url": "https://github.com/llvm/llvm-project/commit/b64150963733d04e524f501cdd736963a7a3ba6d", "code_v0_no_empty_lines": "浮点归约循环展开时无法使用并行累加器，限制了指令级并行性。", "code_v1_no_empty_lines": "@@ -1093,6 +1093,7 @@ llvm::UnrollLoop(Loop *L, UnrollLoopOptions ULO, LoopInfo *LI,\n       if (!RdxResult) {\n         RdxResult = PartialReductions.front();\n         IRBuilder Builder(ExitBlock, ExitBlock->getFirstNonPHIIt());\n+        Builder.setFastMathFlags(Reductions.begin()->second.getFastMathFlags());\n         RecurKind RK = Reductions.begin()->second.getRecurrenceKind();\n         for (Instruction *RdxPart : drop_begin(PartialReductions)) {\n           RdxResult = Builder.CreateBinOp(\n@@ -1255,14 +1256,15 @@ llvm::canParallelizeReductionWhenUnrolling(PHINode &Phi, Loop *L,\n     return std::nullopt;\n   RecurKind RK = RdxDesc.getRecurrenceKind();\n   // Skip unsupported reductions.\n-  // TODO: Handle additional reductions, including FP and min-max\n-  // reductions.\n-  if (!RecurrenceDescriptor::isIntegerRecurrenceKind(RK) ||\n-      RecurrenceDescriptor::isAnyOfRecurrenceKind(RK) ||\n+  // TODO: Handle additional reductions, including min-max reductions.\n+  if (RecurrenceDescriptor::isAnyOfRecurrenceKind(RK) ||\n       RecurrenceDescriptor::isFindIVRecurrenceKind(RK) ||\n       RecurrenceDescriptor::isMinMaxRecurrenceKind(RK))\n     return std::nullopt;\n \n+  if (RdxDesc.hasExactFPMath())\n+    return std::nullopt;\n+\n   if (RdxDesc.IntermediateStore)\n     return std::nullopt;", "target": "@@ -1093,6 +1093,7 @@ llvm::UnrollLoop(Loop *L, UnrollLoopOptions ULO, LoopInfo *LI,\n       if (!RdxResult) {\n         RdxResult = PartialReductions.front();\n         IRBuilder Builder(ExitBlock, ExitBlock->getFirstNonPHIIt());\n+        Builder.setFastMathFlags(Reductions.begin()->second.getFastMathFlags());\n         RecurKind RK = Reductions.begin()->second.getRecurrenceKind();\n         for (Instruction *RdxPart : drop_begin(PartialReductions)) {\n           RdxResult = Builder.CreateBinOp(\n@@ -1255,14 +1256,15 @@ llvm::canParallelizeReductionWhenUnrolling(PHINode &Phi, Loop *L,\n     return std::nullopt;\n   RecurKind RK = RdxDesc.getRecurrenceKind();\n   // Skip unsupported reductions.\n-  // TODO: Handle additional reductions, including FP and min-max\n-  // reductions.\n-  if (!RecurrenceDescriptor::isIntegerRecurrenceKind(RK) ||\n-      RecurrenceDescriptor::isAnyOfRecurrenceKind(RK) ||\n+  // TODO: Handle additional reductions, including min-max reductions.\n+  if (RecurrenceDescriptor::isAnyOfRecurrenceKind(RK) ||\n       RecurrenceDescriptor::isFindIVRecurrenceKind(RK) ||\n       RecurrenceDescriptor::isMinMaxRecurrenceKind(RK))\n     return std::nullopt;\n \n+  if (RdxDesc.hasExactFPMath())\n+    return std::nullopt;\n+\n   if (RdxDesc.IntermediateStore)\n     return std::nullopt;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：浮点归约循环展开时无法使用并行累加器，限制了指令级并行性。优化后：当浮点归约操作具有reassoc标志且无精确浮点数学要求时，引入并行累加器PHI节点，允许循环展开后多个浮点加法并行执行。优化思路：放宽并行化条件，允许浮点归约在满足关联性条件下使用并行累加器，同时确保IRBuilder正确设置FastMathFlags以保持浮点语义。"}
{"id": 309, "source": "riscv-dataset-excel", "optimization_type": "测试覆盖优化", "optimization_description": "优化前：测试文件仅覆盖SSE4.1、AVX1、AVX2三种指令集架构，CPU覆盖范围有限。优化后：扩展测试覆盖范围，新增SSE2、SSE4.1、AVX1、AVX2和x86-64-v4（AVX512）五个测试级别，并重构了check-prefixes标签体系（如将AVX拆分为AVX1OR2和AVX512）。优化思路：通过增加测试用例和细化标签分类，确保有符号/无符号向量取余操作在所有主流x86-64指令集级别都能得到充分测试验证，提高编译器测试的全面性和可靠性。", "original_code": "测试文件仅覆盖SSE4.1、AVX1、AVX2三种指令集架构，CPU覆盖范围有限。", "optimized_code": "; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+sse2    | FileCheck %s --check-prefixes=SSE,SSE2\n; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+sse4.1  | FileCheck %s --check-prefixes=SSE,SSE4\n; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx     | FileCheck %s --check-prefixes=AVX,AVX1OR2,AVX1\n; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx2    | FileCheck %s --check-prefixes=AVX,AVX1OR2,AVX2\n; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mcpu=x86-64-v4 | FileCheck %s --check-prefixes=AVX,AVX512", "source_url": "https://github.com/llvm/llvm-project/commit/adcc557ef176ee36a1e5df12b60789b6fa2fe73c", "code_v0_no_empty_lines": "测试文件仅覆盖SSE4.1、AVX1、AVX2三种指令集架构，CPU覆盖范围有限。", "code_v1_no_empty_lines": "; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+sse2    | FileCheck %s --check-prefixes=SSE,SSE2\n; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+sse4.1  | FileCheck %s --check-prefixes=SSE,SSE4\n; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx     | FileCheck %s --check-prefixes=AVX,AVX1OR2,AVX1\n; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx2    | FileCheck %s --check-prefixes=AVX,AVX1OR2,AVX2\n; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mcpu=x86-64-v4 | FileCheck %s --check-prefixes=AVX,AVX512", "target": "; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+sse2    | FileCheck %s --check-prefixes=SSE,SSE2\n; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+sse4.1  | FileCheck %s --check-prefixes=SSE,SSE4\n; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx     | FileCheck %s --check-prefixes=AVX,AVX1OR2,AVX1\n; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx2    | FileCheck %s --check-prefixes=AVX,AVX1OR2,AVX2\n; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mcpu=x86-64-v4 | FileCheck %s --check-prefixes=AVX,AVX512", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：测试文件仅覆盖SSE4.1、AVX1、AVX2三种指令集架构，CPU覆盖范围有限。优化后：扩展测试覆盖范围，新增SSE2、SSE4.1、AVX1、AVX2和x86-64-v4（AVX512）五个测试级别，并重构了check-prefixes标签体系（如将AVX拆分为AVX1OR2和AVX512）。优化思路：通过增加测试用例和细化标签分类，确保有符号/无符号向量取余操作在所有主流x86-64指令集级别都能得到充分测试验证，提高编译器测试的全面性和可靠性。"}
{"id": 310, "source": "riscv-dataset-excel", "optimization_type": "指令选择优化+模式识别优化", "optimization_description": "优化前：LLVM无法识别手动实现的饱和水平加法/减法模式（shufflevector + sadd.sat/ssub.sat），导致生成低效的shuffle和标量操作序列。优化后：在DAGCombine阶段扩展combineToHorizontalAddSub函数，新增对ISD::SADDSAT和ISD::SSUBSAT操作码的处理，将其识别为水平饱和操作并转换为对应的X86ISD::HADDS/HSUBS节点，最终生成高效的phaddsw/phsubsw单指令。优化思路：通过模式匹配将通用的向量操作转换为特定架构的SIMD指令，减少指令数量并利用硬件加速。", "original_code": "LLVM无法识别手动实现的饱和水平加法/减法模式（shufflevector + sadd.sat/ssub.sat），导致生成低效的shuffle和标量操作序列。", "optimized_code": "case ISD::SADDSAT:\ncase ISD::SSUBSAT:        return combineToHorizontalAddSub(N, DAG, Subtarget);\n\n...\n\nbool IsAdd = (Opcode == ISD::FADD) || (Opcode == ISD::ADD) || (Opcode == ISD::SADDSAT);\nbool IsSat = (Opcode == ISD::SADDSAT) || (Opcode == ISD::SSUBSAT);\n\n...\n\nauto HorizOpcode = IsSat ? (IsAdd ? X86ISD::HADDS : X86ISD::HSUBS) : (IsAdd ? X86ISD::HADD : X86ISD::HSUB);", "source_url": "https://github.com/llvm/llvm-project/commit/bec726f6a6d37bdfb90d1330d4b5e947ce017046", "code_v0_no_empty_lines": "LLVM无法识别手动实现的饱和水平加法/减法模式（shufflevector + sadd.sat/ssub.sat），导致生成低效的shuffle和标量操作序列。", "code_v1_no_empty_lines": "case ISD::SADDSAT:\ncase ISD::SSUBSAT:        return combineToHorizontalAddSub(N, DAG, Subtarget);\n\n...\n\nbool IsAdd = (Opcode == ISD::FADD) || (Opcode == ISD::ADD) || (Opcode == ISD::SADDSAT);\nbool IsSat = (Opcode == ISD::SADDSAT) || (Opcode == ISD::SSUBSAT);\n\n...\n\nauto HorizOpcode = IsSat ? (IsAdd ? X86ISD::HADDS : X86ISD::HSUBS) : (IsAdd ? X86ISD::HADD : X86ISD::HSUB);", "target": "case ISD::SADDSAT:\ncase ISD::SSUBSAT:        return combineToHorizontalAddSub(N, DAG, Subtarget);\n\n...\n\nbool IsAdd = (Opcode == ISD::FADD) || (Opcode == ISD::ADD) || (Opcode == ISD::SADDSAT);\nbool IsSat = (Opcode == ISD::SADDSAT) || (Opcode == ISD::SSUBSAT);\n\n...\n\nauto HorizOpcode = IsSat ? (IsAdd ? X86ISD::HADDS : X86ISD::HSUBS) : (IsAdd ? X86ISD::HADD : X86ISD::HSUB);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：LLVM无法识别手动实现的饱和水平加法/减法模式（shufflevector + sadd.sat/ssub.sat），导致生成低效的shuffle和标量操作序列。优化后：在DAGCombine阶段扩展combineToHorizontalAddSub函数，新增对ISD::SADDSAT和ISD::SSUBSAT操作码的处理，将其识别为水平饱和操作并转换为对应的X86ISD::HADDS/HSUBS节点，最终生成高效的phaddsw/phsubsw单指令。优化思路：通过模式匹配将通用的向量操作转换为特定架构的SIMD指令，减少指令数量并利用硬件加速。"}
{"id": 311, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+指令优化", "optimization_description": "优化前：在RISC-V向量化循环中，LastActiveLane通过生成头掩码（header mask）并使用vfirst.m指令计算最后一个活动通道，产生额外指令开销。优化后：利用EVL（有效向量长度）尾折叠特性，直接将LastActiveLane计算为EVL - 1，无需头掩码和vfirst.m指令。优化思路：识别LastActiveLane模式，替换为简单的减法操作，减少指令数量和计算开销，提升向量化循环性能。", "original_code": "在RISC-V向量化循环中，LastActiveLane通过生成头掩码（header mask）并使用vfirst.m指令计算最后一个活动通道，产生额外指令开销。", "optimized_code": "if (match(&CurRecipe, m_LastActiveLane(m_Specific(HeaderMask)))) {\n    Type *Ty = TypeInfo.inferScalarType(CurRecipe.getVPSingleValue());\n    VPValue *ZExt =\n        VPBuilder(&CurRecipe).createScalarCast(Instruction::ZExt, &EVL, Ty, DL);\n    return new VPInstruction(Instruction::Sub,\n                             {ZExt, Plan->getConstantInt(Ty, 1)}, {}, {}, DL);\n  }", "source_url": "https://github.com/llvm/llvm-project/commit/1c7ec06b16dc59b5b52cff95bde7d5330ffa0293", "code_v0_no_empty_lines": "在RISC-V向量化循环中，LastActiveLane通过生成头掩码（header mask）并使用vfirst.m指令计算最后一个活动通道，产生额外指令开销。", "code_v1_no_empty_lines": "if (match(&CurRecipe, m_LastActiveLane(m_Specific(HeaderMask)))) {\n    Type *Ty = TypeInfo.inferScalarType(CurRecipe.getVPSingleValue());\n    VPValue *ZExt =\n        VPBuilder(&CurRecipe).createScalarCast(Instruction::ZExt, &EVL, Ty, DL);\n    return new VPInstruction(Instruction::Sub,\n                             {ZExt, Plan->getConstantInt(Ty, 1)}, {}, {}, DL);\n  }", "target": "if (match(&CurRecipe, m_LastActiveLane(m_Specific(HeaderMask)))) {\n    Type *Ty = TypeInfo.inferScalarType(CurRecipe.getVPSingleValue());\n    VPValue *ZExt =\n        VPBuilder(&CurRecipe).createScalarCast(Instruction::ZExt, &EVL, Ty, DL);\n    return new VPInstruction(Instruction::Sub,\n                             {ZExt, Plan->getConstantInt(Ty, 1)}, {}, {}, DL);\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在RISC-V向量化循环中，LastActiveLane通过生成头掩码（header mask）并使用vfirst.m指令计算最后一个活动通道，产生额外指令开销。优化后：利用EVL（有效向量长度）尾折叠特性，直接将LastActiveLane计算为EVL - 1，无需头掩码和vfirst.m指令。优化思路：识别LastActiveLane模式，替换为简单的减法操作，减少指令数量和计算开销，提升向量化循环性能。"}
{"id": 312, "source": "riscv-dataset-excel", "optimization_type": "指令折叠优化", "optimization_description": "优化前：当循环向量化后，@llvm.experimental.get.vector.length 内在函数在已知 trip count 小于等于最大向量通道数时仍保留调用，产生额外开销。优化后：在 InstCombine 阶段添加折叠规则，当通过常量范围分析确定 Cnt <= MaxLanes 时，直接将内在函数替换为 Cnt 值（可能进行零扩展或截断）。优化思路：基于语言参考手册的推论，当循环次数不超过最大向量通道数时，get.vector.length 的返回值等于循环次数，通过静态分析消除不必要的内在函数调用，减少运行时开销。", "original_code": "当循环向量化后，@llvm.experimental.get.vector.length 内在函数在已知 trip count 小于等于最大向量通道数时仍保留调用，产生额外开销。", "optimized_code": "case Intrinsic::experimental_get_vector_length: {\n    // get.vector.length(Cnt, MaxLanes) --> Cnt when Cnt <= MaxLanes\n    unsigned BitWidth =\n        std::max(II->getArgOperand(0)->getType()->getScalarSizeInBits(),\n                 II->getType()->getScalarSizeInBits());\n    ConstantRange Cnt =\n        computeConstantRangeIncludingKnownBits(II->getArgOperand(0), false,\n                                               SQ.getWithInstruction(II))\n            .zextOrTrunc(BitWidth);\n    ConstantRange MaxLanes = cast<ConstantInt>(II->getArgOperand(1))\n                                 ->getValue()\n                                 .zextOrTrunc(Cnt.getBitWidth());\n    if (cast<ConstantInt>(II->getArgOperand(2))->isOne())\n      MaxLanes = MaxLanes.multiply(\n          getVScaleRange(II->getFunction(), Cnt.getBitWidth()));\n\n    if (Cnt.icmp(CmpInst::ICMP_ULE, MaxLanes))\n      return replaceInstUsesWith(\n          *II, Builder.CreateZExtOrTrunc(II->getArgOperand(0), II->getType()));\n    return nullptr;\n  }", "source_url": "https://github.com/llvm/llvm-project/commit/bb9449d5bbd72441d8f95052ddfd29e2d29297d7", "code_v0_no_empty_lines": "当循环向量化后，@llvm.experimental.get.vector.length 内在函数在已知 trip count 小于等于最大向量通道数时仍保留调用，产生额外开销。", "code_v1_no_empty_lines": "case Intrinsic::experimental_get_vector_length: {\n    // get.vector.length(Cnt, MaxLanes) --> Cnt when Cnt <= MaxLanes\n    unsigned BitWidth =\n        std::max(II->getArgOperand(0)->getType()->getScalarSizeInBits(),\n                 II->getType()->getScalarSizeInBits());\n    ConstantRange Cnt =\n        computeConstantRangeIncludingKnownBits(II->getArgOperand(0), false,\n                                               SQ.getWithInstruction(II))\n            .zextOrTrunc(BitWidth);\n    ConstantRange MaxLanes = cast<ConstantInt>(II->getArgOperand(1))\n                                 ->getValue()\n                                 .zextOrTrunc(Cnt.getBitWidth());\n    if (cast<ConstantInt>(II->getArgOperand(2))->isOne())\n      MaxLanes = MaxLanes.multiply(\n          getVScaleRange(II->getFunction(), Cnt.getBitWidth()));\n\n    if (Cnt.icmp(CmpInst::ICMP_ULE, MaxLanes))\n      return replaceInstUsesWith(\n          *II, Builder.CreateZExtOrTrunc(II->getArgOperand(0), II->getType()));\n    return nullptr;\n  }", "target": "case Intrinsic::experimental_get_vector_length: {\n    // get.vector.length(Cnt, MaxLanes) --> Cnt when Cnt <= MaxLanes\n    unsigned BitWidth =\n        std::max(II->getArgOperand(0)->getType()->getScalarSizeInBits(),\n                 II->getType()->getScalarSizeInBits());\n    ConstantRange Cnt =\n        computeConstantRangeIncludingKnownBits(II->getArgOperand(0), false,\n                                               SQ.getWithInstruction(II))\n            .zextOrTrunc(BitWidth);\n    ConstantRange MaxLanes = cast<ConstantInt>(II->getArgOperand(1))\n                                 ->getValue()\n                                 .zextOrTrunc(Cnt.getBitWidth());\n    if (cast<ConstantInt>(II->getArgOperand(2))->isOne())\n      MaxLanes = MaxLanes.multiply(\n          getVScaleRange(II->getFunction(), Cnt.getBitWidth()));\n\n    if (Cnt.icmp(CmpInst::ICMP_ULE, MaxLanes))\n      return replaceInstUsesWith(\n          *II, Builder.CreateZExtOrTrunc(II->getArgOperand(0), II->getType()));\n    return nullptr;\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当循环向量化后，@llvm.experimental.get.vector.length 内在函数在已知 trip count 小于等于最大向量通道数时仍保留调用，产生额外开销。优化后：在 InstCombine 阶段添加折叠规则，当通过常量范围分析确定 Cnt <= MaxLanes 时，直接将内在函数替换为 Cnt 值（可能进行零扩展或截断）。优化思路：基于语言参考手册的推论，当循环次数不超过最大向量通道数时，get.vector.length 的返回值等于循环次数，通过静态分析消除不必要的内在函数调用，减少运行时开销。"}
{"id": 313, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：在range-based for循环中使用值捕获（const auto [Type, Count]），每次迭代都会复制Other容器中的元素，产生不必要的拷贝开销。优化后：改为使用常量引用捕获（const auto &[Type, Count]），避免元素拷贝，减少内存分配和复制操作，提升性能。思路：通过引用传递避免容器元素的深拷贝，特别适用于包含复杂类型或大型对象的容器迭代。", "original_code": "在range-based for循环中使用值捕获（const auto [Type, Count]），每次迭代都会复制Other容器中的元素，产生不必要的拷贝开销。", "optimized_code": "-    for (const auto [Type, Count] : Other) {\n+    for (const auto &[Type, Count] : Other) {", "source_url": "https://github.com/llvm/llvm-project/commit/a9cc7fe3caf6e14ae755689df8ccde2edc4c8a43", "code_v0_no_empty_lines": "在range-based for循环中使用值捕获（const auto [Type, Count]），每次迭代都会复制Other容器中的元素，产生不必要的拷贝开销。", "code_v1_no_empty_lines": "-    for (const auto [Type, Count] : Other) {\n+    for (const auto &[Type, Count] : Other) {", "target": "-    for (const auto [Type, Count] : Other) {\n+    for (const auto &[Type, Count] : Other) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在range-based for循环中使用值捕获（const auto [Type, Count]），每次迭代都会复制Other容器中的元素，产生不必要的拷贝开销。优化后：改为使用常量引用捕获（const auto &[Type, Count]），避免元素拷贝，减少内存分配和复制操作，提升性能。思路：通过引用传递避免容器元素的深拷贝，特别适用于包含复杂类型或大型对象的容器迭代。"}
{"id": 314, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化", "optimization_description": "优化前：先调用HashMap.get()获取旧值，再调用HashMap.put()设置新值，导致两次哈希查找操作。优化后：直接使用HashMap.put()方法返回旧值，只需一次哈希查找操作。思路：利用HashMap.put()方法返回旧值的特性，减少冗余的哈希查找，提高性能。", "original_code": "先调用HashMap.get()获取旧值，再调用HashMap.put()设置新值，导致两次哈希查找操作。", "optimized_code": "-            oldValue = desktopProperties.get(name);\n-            desktopProperties.put(name, newValue);\n+            oldValue = desktopProperties.put(name, newValue);", "source_url": "https://github.com/openjdk/riscv-port/commit/e557b6956bdf9b0d89ad69427c7b4a97a65868ea", "code_v0_no_empty_lines": "先调用HashMap.get()获取旧值，再调用HashMap.put()设置新值，导致两次哈希查找操作。", "code_v1_no_empty_lines": "-            oldValue = desktopProperties.get(name);\n-            desktopProperties.put(name, newValue);\n+            oldValue = desktopProperties.put(name, newValue);", "target": "-            oldValue = desktopProperties.get(name);\n-            desktopProperties.put(name, newValue);\n+            oldValue = desktopProperties.put(name, newValue);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：先调用HashMap.get()获取旧值，再调用HashMap.put()设置新值，导致两次哈希查找操作。优化后：直接使用HashMap.put()方法返回旧值，只需一次哈希查找操作。思路：利用HashMap.put()方法返回旧值的特性，减少冗余的哈希查找，提高性能。"}
{"id": 315, "source": "riscv-dataset-excel", "optimization_type": "性能优化+内存优化", "optimization_description": "优化前：BigDecimal.valueOf(double) 通过 Double.toString(val) 创建字符串，然后解析字符串构造 BigDecimal，涉及字符串格式化和解析双重开销。优化后：直接使用 FormattedFPDecimal.valueForDoubleToString 获取双精度浮点数的有效数字、指数和精度，然后调用 valueOf(long, int, int) 构造 BigDecimal，避免了字符串中间转换。优化思路：重用 Double.toString 的内部格式化逻辑，直接获取数值组件，消除冗余的字符串创建和解析步骤，提升性能和减少内存分配。", "original_code": "BigDecimal.valueOf(double) 通过 Double.toString(val) 创建字符串，然后解析字符串构造 BigDecimal，涉及字符串格式化和解析双重开销。", "optimized_code": "public static BigDecimal valueOf(double val) {\n-        return new BigDecimal(Double.toString(val));\n+        if (!Double.isFinite(val)) {\n+            throw new NumberFormatException(\"Infinite or NaN\");\n+        }\n+\n+        var fmt = FormattedFPDecimal.valueForDoubleToString(Math.abs(val));\n+        long s = fmt.getSignificand();\n+        if (val < 0) {\n+            s = -s;\n+        }\n+\n+        return valueOf(s, -fmt.getExp(), fmt.getPrecision());\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/1e61352b54e1ac85fbc6b54a7a29e8782dd42d2c", "code_v0_no_empty_lines": "BigDecimal.valueOf(double) 通过 Double.toString(val) 创建字符串，然后解析字符串构造 BigDecimal，涉及字符串格式化和解析双重开销。", "code_v1_no_empty_lines": "public static BigDecimal valueOf(double val) {\n-        return new BigDecimal(Double.toString(val));\n+        if (!Double.isFinite(val)) {\n+            throw new NumberFormatException(\"Infinite or NaN\");\n+        }\n+\n+        var fmt = FormattedFPDecimal.valueForDoubleToString(Math.abs(val));\n+        long s = fmt.getSignificand();\n+        if (val < 0) {\n+            s = -s;\n+        }\n+\n+        return valueOf(s, -fmt.getExp(), fmt.getPrecision());\n     }", "target": "public static BigDecimal valueOf(double val) {\n-        return new BigDecimal(Double.toString(val));\n+        if (!Double.isFinite(val)) {\n+            throw new NumberFormatException(\"Infinite or NaN\");\n+        }\n+\n+        var fmt = FormattedFPDecimal.valueForDoubleToString(Math.abs(val));\n+        long s = fmt.getSignificand();\n+        if (val < 0) {\n+            s = -s;\n+        }\n+\n+        return valueOf(s, -fmt.getExp(), fmt.getPrecision());\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：BigDecimal.valueOf(double) 通过 Double.toString(val) 创建字符串，然后解析字符串构造 BigDecimal，涉及字符串格式化和解析双重开销。优化后：直接使用 FormattedFPDecimal.valueForDoubleToString 获取双精度浮点数的有效数字、指数和精度，然后调用 valueOf(long, int, int) 构造 BigDecimal，避免了字符串中间转换。优化思路：重用 Double.toString 的内部格式化逻辑，直接获取数值组件，消除冗余的字符串创建和解析步骤，提升性能和减少内存分配。"}
{"id": 316, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+内存操作优化", "optimization_description": "优化前：Unsafe::setMemory操作通过Java代码实现，性能较低，特别是在AArch64架构上。优化后：为AArch64架构实现了Unsafe::setMemory的汇编级intrinsic函数，使用SIMD指令（如stpq、strq等）进行批量内存填充，支持64字节块操作和尾部处理。优化思路：通过硬件特定的汇编实现替代通用Java代码，利用AArch64的向量寄存器（v0）和批量存储指令，显著提升内存填充操作的性能，同时保持原子性保证。", "original_code": "Unsafe::setMemory操作通过Java代码实现，性能较低，特别是在AArch64架构上。", "optimized_code": "address generate_unsafe_setmemory() {\n    __ align(CodeEntryAlignment);\n    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n    address start = __ pc();\n\n    Register dest = c_rarg0, count = c_rarg1, value = c_rarg2;\n    Label tail;\n\n    UnsafeMemoryAccessMark umam(this, true, false);\n\n    __ enter(); // required for proper stackwalking of RuntimeStub frame\n\n    __ dup(v0, __ T16B, value);\n\n    if (AvoidUnalignedAccesses) {\n      __ cmp(count, (u1)16);\n      __ br(__ LO, tail);\n\n      __ mov(rscratch1, 16);\n      __ andr(rscratch2, dest, 15);\n      __ sub(rscratch1, rscratch1, rscratch2);  // Bytes needed to 16-align dest\n      __ strq(v0, Address(dest));\n      __ sub(count, count, rscratch1);\n      __ add(dest, dest, rscratch1);\n    }\n\n    __ subs(count, count, (u1)64);\n    __ br(__ LO, tail);\n    {\n      Label again;\n      __ bind(again);\n      __ stpq(v0, v0, Address(dest));\n      __ stpq(v0, v0, Address(dest, 32));\n\n      __ subs(count, count, 64);\n      __ add(dest, dest, 64);\n      __ br(__ HS, again);\n    }\n\n    __ bind(tail);\n    // The count of bytes is off by 64, but we don't need to correct\n    // it because we're only going to use the least-significant few\n    // count bits from here on.\n    // __ add(count, count, 64);\n\n    {\n      Label dont;\n      __ tbz(count, exact_log2(32), dont);\n      __ stpq(v0, v0, __ post(dest, 32));\n      __ bind(dont);\n    }\n    {\n      Label dont;\n      __ tbz(count, exact_log2(16), dont);\n      __ strq(v0, __ post(dest, 16));\n      __ bind(dont);\n    }\n    {\n      Label dont;\n      __ tbz(count, exact_log2(8), dont);\n      __ strd(v0, __ post(dest, 8));\n      __ bind(dont);\n    }\n\n    Label finished;\n    __ tst(count, 7);\n    __ br(__ EQ, finished);\n\n    {\n      Label dont;\n      __ tbz(count, exact_log2(4), dont);\n      __ strs(v0, __ post(dest, 4));\n      __ bind(dont);\n    }\n    {\n      Label dont;\n      __ tbz(count, exact_log2(2), dont);\n      __ bfi(value, value, 8, 8);\n      __ strh(value, __ post(dest, 2));\n      __ bind(dont);\n    }\n    {\n      Label dont;\n      __ tbz(count, exact_log2(1), dont);\n      __ strb(value, Address(dest));\n      __ bind(dont);\n    }\n\n    __ bind(finished);\n    __ leave();\n    __ ret(lr);\n\n    return start;\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/a6ebcf61eb522a1bcfc9f2169d42974af3883b00", "code_v0_no_empty_lines": "Unsafe::setMemory操作通过Java代码实现，性能较低，特别是在AArch64架构上。", "code_v1_no_empty_lines": "address generate_unsafe_setmemory() {\n    __ align(CodeEntryAlignment);\n    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n    address start = __ pc();\n\n    Register dest = c_rarg0, count = c_rarg1, value = c_rarg2;\n    Label tail;\n\n    UnsafeMemoryAccessMark umam(this, true, false);\n\n    __ enter(); // required for proper stackwalking of RuntimeStub frame\n\n    __ dup(v0, __ T16B, value);\n\n    if (AvoidUnalignedAccesses) {\n      __ cmp(count, (u1)16);\n      __ br(__ LO, tail);\n\n      __ mov(rscratch1, 16);\n      __ andr(rscratch2, dest, 15);\n      __ sub(rscratch1, rscratch1, rscratch2);  // Bytes needed to 16-align dest\n      __ strq(v0, Address(dest));\n      __ sub(count, count, rscratch1);\n      __ add(dest, dest, rscratch1);\n    }\n\n    __ subs(count, count, (u1)64);\n    __ br(__ LO, tail);\n    {\n      Label again;\n      __ bind(again);\n      __ stpq(v0, v0, Address(dest));\n      __ stpq(v0, v0, Address(dest, 32));\n\n      __ subs(count, count, 64);\n      __ add(dest, dest, 64);\n      __ br(__ HS, again);\n    }\n\n    __ bind(tail);\n    // The count of bytes is off by 64, but we don't need to correct\n    // it because we're only going to use the least-significant few\n    // count bits from here on.\n    // __ add(count, count, 64);\n\n    {\n      Label dont;\n      __ tbz(count, exact_log2(32), dont);\n      __ stpq(v0, v0, __ post(dest, 32));\n      __ bind(dont);\n    }\n    {\n      Label dont;\n      __ tbz(count, exact_log2(16), dont);\n      __ strq(v0, __ post(dest, 16));\n      __ bind(dont);\n    }\n    {\n      Label dont;\n      __ tbz(count, exact_log2(8), dont);\n      __ strd(v0, __ post(dest, 8));\n      __ bind(dont);\n    }\n\n    Label finished;\n    __ tst(count, 7);\n    __ br(__ EQ, finished);\n\n    {\n      Label dont;\n      __ tbz(count, exact_log2(4), dont);\n      __ strs(v0, __ post(dest, 4));\n      __ bind(dont);\n    }\n    {\n      Label dont;\n      __ tbz(count, exact_log2(2), dont);\n      __ bfi(value, value, 8, 8);\n      __ strh(value, __ post(dest, 2));\n      __ bind(dont);\n    }\n    {\n      Label dont;\n      __ tbz(count, exact_log2(1), dont);\n      __ strb(value, Address(dest));\n      __ bind(dont);\n    }\n\n    __ bind(finished);\n    __ leave();\n    __ ret(lr);\n\n    return start;\n  }", "target": "address generate_unsafe_setmemory() {\n    __ align(CodeEntryAlignment);\n    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n    address start = __ pc();\n\n    Register dest = c_rarg0, count = c_rarg1, value = c_rarg2;\n    Label tail;\n\n    UnsafeMemoryAccessMark umam(this, true, false);\n\n    __ enter(); // required for proper stackwalking of RuntimeStub frame\n\n    __ dup(v0, __ T16B, value);\n\n    if (AvoidUnalignedAccesses) {\n      __ cmp(count, (u1)16);\n      __ br(__ LO, tail);\n\n      __ mov(rscratch1, 16);\n      __ andr(rscratch2, dest, 15);\n      __ sub(rscratch1, rscratch1, rscratch2);  // Bytes needed to 16-align dest\n      __ strq(v0, Address(dest));\n      __ sub(count, count, rscratch1);\n      __ add(dest, dest, rscratch1);\n    }\n\n    __ subs(count, count, (u1)64);\n    __ br(__ LO, tail);\n    {\n      Label again;\n      __ bind(again);\n      __ stpq(v0, v0, Address(dest));\n      __ stpq(v0, v0, Address(dest, 32));\n\n      __ subs(count, count, 64);\n      __ add(dest, dest, 64);\n      __ br(__ HS, again);\n    }\n\n    __ bind(tail);\n    // The count of bytes is off by 64, but we don't need to correct\n    // it because we're only going to use the least-significant few\n    // count bits from here on.\n    // __ add(count, count, 64);\n\n    {\n      Label dont;\n      __ tbz(count, exact_log2(32), dont);\n      __ stpq(v0, v0, __ post(dest, 32));\n      __ bind(dont);\n    }\n    {\n      Label dont;\n      __ tbz(count, exact_log2(16), dont);\n      __ strq(v0, __ post(dest, 16));\n      __ bind(dont);\n    }\n    {\n      Label dont;\n      __ tbz(count, exact_log2(8), dont);\n      __ strd(v0, __ post(dest, 8));\n      __ bind(dont);\n    }\n\n    Label finished;\n    __ tst(count, 7);\n    __ br(__ EQ, finished);\n\n    {\n      Label dont;\n      __ tbz(count, exact_log2(4), dont);\n      __ strs(v0, __ post(dest, 4));\n      __ bind(dont);\n    }\n    {\n      Label dont;\n      __ tbz(count, exact_log2(2), dont);\n      __ bfi(value, value, 8, 8);\n      __ strh(value, __ post(dest, 2));\n      __ bind(dont);\n    }\n    {\n      Label dont;\n      __ tbz(count, exact_log2(1), dont);\n      __ strb(value, Address(dest));\n      __ bind(dont);\n    }\n\n    __ bind(finished);\n    __ leave();\n    __ ret(lr);\n\n    return start;\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Unsafe::setMemory操作通过Java代码实现，性能较低，特别是在AArch64架构上。优化后：为AArch64架构实现了Unsafe::setMemory的汇编级intrinsic函数，使用SIMD指令（如stpq、strq等）进行批量内存填充，支持64字节块操作和尾部处理。优化思路：通过硬件特定的汇编实现替代通用Java代码，利用AArch64的向量寄存器（v0）和批量存储指令，显著提升内存填充操作的性能，同时保持原子性保证。"}
{"id": 317, "source": "riscv-dataset-excel", "optimization_type": "编译器测试/调试优化", "optimization_description": "优化前：C2编译器中的循环剥离（loop peeling）决策完全基于启发式算法，当循环体大小超过255时自动禁止剥离，缺乏随机化测试机制。优化后：添加了StressLoopPeeling压力测试模式，当启用时：1. 放宽了255节点数的限制条件；2. 在安全的情况下随机决定是否进行循环剥离（50%概率）；3. 限制每个循环最多尝试5次随机剥离决策。优化思路：通过随机化循环剥离决策，在压力测试模式下暴露更多代码路径，帮助发现编译器优化中的潜在问题和边界情况，提高编译器鲁棒性。", "original_code": "C2编译器中的循环剥离（loop peeling）决策完全基于启发式算法，当循环体大小超过255时自动禁止剥离，缺乏随机化测试机制。", "optimized_code": "diff --git a/src/hotspot/share/opto/loopTransform.cpp b/src/hotspot/share/opto/loopTransform.cpp\nindex f7783e19c9c..d4e5ff0bd0a 100644\n--- a/src/hotspot/share/opto/loopTransform.cpp\n+++ b/src/hotspot/share/opto/loopTransform.cpp\n@@ -491,7 +491,7 @@ uint IdealLoopTree::estimate_peeling(PhaseIdealLoop *phase) {\n   assert(!phase->exceeding_node_budget(), \"sanity\");\n \n   // Peeling does loop cloning which can result in O(N^2) node construction.\n-  if (_body.size() > 255) {\n+  if (_body.size() > 255 && !StressLoopPeeling) {\n     return 0;   // Suppress too large body size.\n   }\n   // Optimistic estimate that approximates loop body complexity via data and\n@@ -506,10 +506,26 @@ uint IdealLoopTree::estimate_peeling(PhaseIdealLoop *phase) {\n   if (_head->is_CountedLoop()) {\n     CountedLoopNode* cl = _head->as_CountedLoop();\n     if (cl->is_unroll_only() || cl->trip_count() == 1) {\n+      // Peeling is not legal here (cf. assert in do_peeling), we don't even stress peel!\n       return 0;\n     }\n   }\n \n+#ifndef PRODUCT\n+  // It is now safe to peel or not.\n+  if (StressLoopPeeling) {\n+    LoopNode* loop_head = _head->as_Loop();\n+    static constexpr uint max_peeling_opportunities = 5;\n+    if (loop_head->_stress_peeling_attempts < max_peeling_opportunities) {\n+      loop_head->_stress_peeling_attempts++;\n+      // In case of stress, let's just pick randomly...\n+      return ((phase->C->random() % 2) == 0) ? estimate : 0;\n+    }\n+    return 0;\n+  }\n+  // ...otherwise, let's apply our heuristic.\n+#endif\n+\n   Node* test = tail();", "source_url": "https://github.com/openjdk/riscv-port/commit/0d8675780f28d25ed538589480cc208b48fe7e93", "code_v0_no_empty_lines": "C2编译器中的循环剥离（loop peeling）决策完全基于启发式算法，当循环体大小超过255时自动禁止剥离，缺乏随机化测试机制。", "code_v1_no_empty_lines": "diff --git a/src/hotspot/share/opto/loopTransform.cpp b/src/hotspot/share/opto/loopTransform.cpp\nindex f7783e19c9c..d4e5ff0bd0a 100644\n--- a/src/hotspot/share/opto/loopTransform.cpp\n+++ b/src/hotspot/share/opto/loopTransform.cpp\n@@ -491,7 +491,7 @@ uint IdealLoopTree::estimate_peeling(PhaseIdealLoop *phase) {\n   assert(!phase->exceeding_node_budget(), \"sanity\");\n \n   // Peeling does loop cloning which can result in O(N^2) node construction.\n-  if (_body.size() > 255) {\n+  if (_body.size() > 255 && !StressLoopPeeling) {\n     return 0;   // Suppress too large body size.\n   }\n   // Optimistic estimate that approximates loop body complexity via data and\n@@ -506,10 +506,26 @@ uint IdealLoopTree::estimate_peeling(PhaseIdealLoop *phase) {\n   if (_head->is_CountedLoop()) {\n     CountedLoopNode* cl = _head->as_CountedLoop();\n     if (cl->is_unroll_only() || cl->trip_count() == 1) {\n+      // Peeling is not legal here (cf. assert in do_peeling), we don't even stress peel!\n       return 0;\n     }\n   }\n \n+#ifndef PRODUCT\n+  // It is now safe to peel or not.\n+  if (StressLoopPeeling) {\n+    LoopNode* loop_head = _head->as_Loop();\n+    static constexpr uint max_peeling_opportunities = 5;\n+    if (loop_head->_stress_peeling_attempts < max_peeling_opportunities) {\n+      loop_head->_stress_peeling_attempts++;\n+      // In case of stress, let's just pick randomly...\n+      return ((phase->C->random() % 2) == 0) ? estimate : 0;\n+    }\n+    return 0;\n+  }\n+  // ...otherwise, let's apply our heuristic.\n+#endif\n+\n   Node* test = tail();", "target": "diff --git a/src/hotspot/share/opto/loopTransform.cpp b/src/hotspot/share/opto/loopTransform.cpp\nindex f7783e19c9c..d4e5ff0bd0a 100644\n--- a/src/hotspot/share/opto/loopTransform.cpp\n+++ b/src/hotspot/share/opto/loopTransform.cpp\n@@ -491,7 +491,7 @@ uint IdealLoopTree::estimate_peeling(PhaseIdealLoop *phase) {\n   assert(!phase->exceeding_node_budget(), \"sanity\");\n \n   // Peeling does loop cloning which can result in O(N^2) node construction.\n-  if (_body.size() > 255) {\n+  if (_body.size() > 255 && !StressLoopPeeling) {\n     return 0;   // Suppress too large body size.\n   }\n   // Optimistic estimate that approximates loop body complexity via data and\n@@ -506,10 +506,26 @@ uint IdealLoopTree::estimate_peeling(PhaseIdealLoop *phase) {\n   if (_head->is_CountedLoop()) {\n     CountedLoopNode* cl = _head->as_CountedLoop();\n     if (cl->is_unroll_only() || cl->trip_count() == 1) {\n+      // Peeling is not legal here (cf. assert in do_peeling), we don't even stress peel!\n       return 0;\n     }\n   }\n \n+#ifndef PRODUCT\n+  // It is now safe to peel or not.\n+  if (StressLoopPeeling) {\n+    LoopNode* loop_head = _head->as_Loop();\n+    static constexpr uint max_peeling_opportunities = 5;\n+    if (loop_head->_stress_peeling_attempts < max_peeling_opportunities) {\n+      loop_head->_stress_peeling_attempts++;\n+      // In case of stress, let's just pick randomly...\n+      return ((phase->C->random() % 2) == 0) ? estimate : 0;\n+    }\n+    return 0;\n+  }\n+  // ...otherwise, let's apply our heuristic.\n+#endif\n+\n   Node* test = tail();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器中的循环剥离（loop peeling）决策完全基于启发式算法，当循环体大小超过255时自动禁止剥离，缺乏随机化测试机制。优化后：添加了StressLoopPeeling压力测试模式，当启用时：1. 放宽了255节点数的限制条件；2. 在安全的情况下随机决定是否进行循环剥离（50%概率）；3. 限制每个循环最多尝试5次随机剥离决策。优化思路：通过随机化循环剥离决策，在压力测试模式下暴露更多代码路径，帮助发现编译器优化中的潜在问题和边界情况，提高编译器鲁棒性。"}
{"id": 318, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码简化", "optimization_description": "优化前：在SerialHeap和ParallelScavengeHeap的collect方法中，使用while循环和条件检查来确保显式Full GC操作完成，增加了不必要的复杂性和潜在的性能开销。优化后：移除了while循环和相关的条件检查，直接执行GC操作，简化了代码逻辑。优化思路：通过分析发现循环重试机制是不必要的，因为VMThread::execute()操作本身是同步的，移除循环可以减少函数调用开销、避免不必要的锁操作，从而提高GC触发时的性能。", "original_code": "在SerialHeap和ParallelScavengeHeap的collect方法中，使用while循环和条件检查来确保显式Full GC操作完成，增加了不必要的复杂性和潜在的性能开销。", "optimized_code": "- while (true) {\n    VM_ParallelGCCollect op(gc_count, full_gc_count, cause);\n    VMThread::execute(&op);\n\n    if (!GCCause::is_explicit_full_gc(cause)) {\n      return;\n    }\n\n    {\n      MutexLocker ml(Heap_lock);\n      if (full_gc_count != total_full_collections()) {\n        return;\n      }\n    }\n  }\n+ VM_ParallelGCCollect op(gc_count, full_gc_count, cause);\n+ VMThread::execute(&op);", "source_url": "https://github.com/openjdk/riscv-port/commit/969708bd8f0de49f641eab3881cb15712aa34f1e", "code_v0_no_empty_lines": "在SerialHeap和ParallelScavengeHeap的collect方法中，使用while循环和条件检查来确保显式Full GC操作完成，增加了不必要的复杂性和潜在的性能开销。", "code_v1_no_empty_lines": "- while (true) {\n    VM_ParallelGCCollect op(gc_count, full_gc_count, cause);\n    VMThread::execute(&op);\n\n    if (!GCCause::is_explicit_full_gc(cause)) {\n      return;\n    }\n\n    {\n      MutexLocker ml(Heap_lock);\n      if (full_gc_count != total_full_collections()) {\n        return;\n      }\n    }\n  }\n+ VM_ParallelGCCollect op(gc_count, full_gc_count, cause);\n+ VMThread::execute(&op);", "target": "- while (true) {\n    VM_ParallelGCCollect op(gc_count, full_gc_count, cause);\n    VMThread::execute(&op);\n\n    if (!GCCause::is_explicit_full_gc(cause)) {\n      return;\n    }\n\n    {\n      MutexLocker ml(Heap_lock);\n      if (full_gc_count != total_full_collections()) {\n        return;\n      }\n    }\n  }\n+ VM_ParallelGCCollect op(gc_count, full_gc_count, cause);\n+ VMThread::execute(&op);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在SerialHeap和ParallelScavengeHeap的collect方法中，使用while循环和条件检查来确保显式Full GC操作完成，增加了不必要的复杂性和潜在的性能开销。优化后：移除了while循环和相关的条件检查，直接执行GC操作，简化了代码逻辑。优化思路：通过分析发现循环重试机制是不必要的，因为VMThread::execute()操作本身是同步的，移除循环可以减少函数调用开销、避免不必要的锁操作，从而提高GC触发时的性能。"}
{"id": 319, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码简化", "optimization_description": "优化前：increment_mdp_data_at函数支持递增和递减操作，包含复杂的溢出处理逻辑（条件分支和回退操作），代码量较大且执行路径复杂。优化后：移除了递减功能，简化了函数签名，只保留递增操作，直接使用addptr指令完成计数器递增，无需溢出检查。优化思路：由于实际使用场景中主要需要递增操作，移除不常用的递减功能可以简化代码、减少分支预测失败、提高指令缓存效率，从而优化解释器性能。", "original_code": "increment_mdp_data_at函数支持递增和递减操作，包含复杂的溢出处理逻辑（条件分支和回退操作），代码量较大且执行路径复杂。", "optimized_code": "-void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n-                                                      int constant,\n-                                                      bool decrement) {\n-  // Counter address\n-  Address data(mdp_in, constant);\n-\n-  increment_mdp_data_at(data, decrement);\n-}\n-\n-void InterpreterMacroAssembler::increment_mdp_data_at(Address data,\n-                                                      bool decrement) {\n+void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n+                                                      int constant) {\n   assert(ProfileInterpreter, \"must be profiling interpreter\");\n-  // %%% this does 64bit counters at best it is wasting space\n-  // at worst it is a rare bug when counters overflow\n-\n-  if (decrement) {\n-    // Decrement the register.  Set condition codes.\n-    addptr(data, -DataLayout::counter_increment);\n-    // If the decrement causes the counter to overflow, stay negative\n-    Label L;\n-    jcc(Assembler::negative, L);\n-    addptr(data, DataLayout::counter_increment);\n-    bind(L);\n-  } else {\n-    assert(DataLayout::counter_increment == 1,\n-           \"flow-free idiom only works with 1\");\n-    // Increment the register.  Set carry flag.\n-    addptr(data, DataLayout::counter_increment);\n-    // If the increment causes the counter to overflow, pull back by 1.\n-    sbbptr(data, 0);\n-  }\n+  Address data(mdp_in, constant);\n+  addptr(data, DataLayout::counter_increment);\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/67fb1ee7f11c840a28ace21d381c86353fd9b22b", "code_v0_no_empty_lines": "increment_mdp_data_at函数支持递增和递减操作，包含复杂的溢出处理逻辑（条件分支和回退操作），代码量较大且执行路径复杂。", "code_v1_no_empty_lines": "-void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n-                                                      int constant,\n-                                                      bool decrement) {\n-  // Counter address\n-  Address data(mdp_in, constant);\n-\n-  increment_mdp_data_at(data, decrement);\n-}\n-\n-void InterpreterMacroAssembler::increment_mdp_data_at(Address data,\n-                                                      bool decrement) {\n+void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n+                                                      int constant) {\n   assert(ProfileInterpreter, \"must be profiling interpreter\");\n-  // %%% this does 64bit counters at best it is wasting space\n-  // at worst it is a rare bug when counters overflow\n-\n-  if (decrement) {\n-    // Decrement the register.  Set condition codes.\n-    addptr(data, -DataLayout::counter_increment);\n-    // If the decrement causes the counter to overflow, stay negative\n-    Label L;\n-    jcc(Assembler::negative, L);\n-    addptr(data, DataLayout::counter_increment);\n-    bind(L);\n-  } else {\n-    assert(DataLayout::counter_increment == 1,\n-           \"flow-free idiom only works with 1\");\n-    // Increment the register.  Set carry flag.\n-    addptr(data, DataLayout::counter_increment);\n-    // If the increment causes the counter to overflow, pull back by 1.\n-    sbbptr(data, 0);\n-  }\n+  Address data(mdp_in, constant);\n+  addptr(data, DataLayout::counter_increment);\n }", "target": "-void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n-                                                      int constant,\n-                                                      bool decrement) {\n-  // Counter address\n-  Address data(mdp_in, constant);\n-\n-  increment_mdp_data_at(data, decrement);\n-}\n-\n-void InterpreterMacroAssembler::increment_mdp_data_at(Address data,\n-                                                      bool decrement) {\n+void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n+                                                      int constant) {\n   assert(ProfileInterpreter, \"must be profiling interpreter\");\n-  // %%% this does 64bit counters at best it is wasting space\n-  // at worst it is a rare bug when counters overflow\n-\n-  if (decrement) {\n-    // Decrement the register.  Set condition codes.\n-    addptr(data, -DataLayout::counter_increment);\n-    // If the decrement causes the counter to overflow, stay negative\n-    Label L;\n-    jcc(Assembler::negative, L);\n-    addptr(data, DataLayout::counter_increment);\n-    bind(L);\n-  } else {\n-    assert(DataLayout::counter_increment == 1,\n-           \"flow-free idiom only works with 1\");\n-    // Increment the register.  Set carry flag.\n-    addptr(data, DataLayout::counter_increment);\n-    // If the increment causes the counter to overflow, pull back by 1.\n-    sbbptr(data, 0);\n-  }\n+  Address data(mdp_in, constant);\n+  addptr(data, DataLayout::counter_increment);\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：increment_mdp_data_at函数支持递增和递减操作，包含复杂的溢出处理逻辑（条件分支和回退操作），代码量较大且执行路径复杂。优化后：移除了递减功能，简化了函数签名，只保留递增操作，直接使用addptr指令完成计数器递增，无需溢出检查。优化思路：由于实际使用场景中主要需要递增操作，移除不常用的递减功能可以简化代码、减少分支预测失败、提高指令缓存效率，从而优化解释器性能。"}
{"id": 320, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+指令集扩展", "optimization_description": "优化前：RISC-V后端缺少对Float16向量操作的支持，无法利用硬件向量指令加速半精度浮点运算。优化后：为RISC-V后端添加了完整的Float16向量操作支持，包括加法、减法、乘法、除法、最大值、最小值、平方根、融合乘加等操作，通过匹配新的Op_VectorCastHF2F、Op_VectorCastF2HF等操作码，并生成对应的RISC-V向量指令（如vfadd_vv、vfsub_vv等）。优化思路：利用RISC-V的Zvfh扩展指令集，通过向量化技术将多个半精度浮点操作并行执行，显著提升计算密集型应用的性能。", "original_code": "RISC-V后端缺少对Float16向量操作的支持，无法利用硬件向量指令加速半精度浮点运算。", "optimized_code": "instruct vadd_hfp(vReg dst, vReg src1, vReg src2) %{\n  match(Set dst (AddVHF src1 src2));\n  ins_cost(VEC_COST);\n  format %{ \"vadd_hfp $dst, $src1, $src2\" %};\n  ins_encode %{\n    assert(UseZvfh, \"must\");\n    assert(Matcher::vector_element_basic_type(this) == T_SHORT, \"must\");\n    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n    __ vfadd_vv(as_VectorRegister($dst$$reg),\n                as_VectorRegister($src1$$reg),\n                as_VectorRegister($src2$$reg));\n  %}\n  ins_pipe(pipe_slow);\n%}", "source_url": "https://github.com/openjdk/riscv-port/commit/92fd44992b9326fa10ec8303394dac17bb81b168", "code_v0_no_empty_lines": "RISC-V后端缺少对Float16向量操作的支持，无法利用硬件向量指令加速半精度浮点运算。", "code_v1_no_empty_lines": "instruct vadd_hfp(vReg dst, vReg src1, vReg src2) %{\n  match(Set dst (AddVHF src1 src2));\n  ins_cost(VEC_COST);\n  format %{ \"vadd_hfp $dst, $src1, $src2\" %};\n  ins_encode %{\n    assert(UseZvfh, \"must\");\n    assert(Matcher::vector_element_basic_type(this) == T_SHORT, \"must\");\n    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n    __ vfadd_vv(as_VectorRegister($dst$$reg),\n                as_VectorRegister($src1$$reg),\n                as_VectorRegister($src2$$reg));\n  %}\n  ins_pipe(pipe_slow);\n%}", "target": "instruct vadd_hfp(vReg dst, vReg src1, vReg src2) %{\n  match(Set dst (AddVHF src1 src2));\n  ins_cost(VEC_COST);\n  format %{ \"vadd_hfp $dst, $src1, $src2\" %};\n  ins_encode %{\n    assert(UseZvfh, \"must\");\n    assert(Matcher::vector_element_basic_type(this) == T_SHORT, \"must\");\n    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n    __ vfadd_vv(as_VectorRegister($dst$$reg),\n                as_VectorRegister($src1$$reg),\n                as_VectorRegister($src2$$reg));\n  %}\n  ins_pipe(pipe_slow);\n%}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V后端缺少对Float16向量操作的支持，无法利用硬件向量指令加速半精度浮点运算。优化后：为RISC-V后端添加了完整的Float16向量操作支持，包括加法、减法、乘法、除法、最大值、最小值、平方根、融合乘加等操作，通过匹配新的Op_VectorCastHF2F、Op_VectorCastF2HF等操作码，并生成对应的RISC-V向量指令（如vfadd_vv、vfsub_vv等）。优化思路：利用RISC-V的Zvfh扩展指令集，通过向量化技术将多个半精度浮点操作并行执行，显著提升计算密集型应用的性能。"}
{"id": 321, "source": "riscv-dataset-excel", "optimization_type": "线程创建优化+错误处理优化", "optimization_description": "优化前：当pthread_create返回EAGAIN错误时，采用固定次数的重试（最多3次），重试之间没有延迟，可能导致系统资源紧张时持续快速重试，增加系统负载。优化后：采用指数退避策略，初始延迟1ms（Windows为1ms，Unix为1000us），每次重试延迟加倍，最多重试4次，并在重试时添加调试日志。优化思路：通过指数退避算法减少在系统资源紧张时的重试频率，避免雪崩效应，提高线程创建的成功率，同时添加日志便于问题诊断。", "original_code": "当pthread_create返回EAGAIN错误时，采用固定次数的重试（最多3次），重试之间没有延迟，可能导致系统资源紧张时持续快速重试，增加系统负载。", "optimized_code": "- int limit = 3;\n- do {\n    ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n  } while (ret == EAGAIN && limit-- > 0);\n+ int trials_remaining = 4;\n+ useconds_t next_delay = 1000;\n+ while (true) {\n    ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n    if (ret != EAGAIN) {\n      break;\n    }\n    if (--trials_remaining <= 0) {\n      break;\n    }\n    log_debug(os, thread)(\"Failed to start native thread (%s), retrying after %dus.\", os::errno_name(ret), next_delay);\n    ::usleep(next_delay);\n    next_delay *= 2;\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/27a4243561e31d6f2858dd0c0bd356e2849ed87c", "code_v0_no_empty_lines": "当pthread_create返回EAGAIN错误时，采用固定次数的重试（最多3次），重试之间没有延迟，可能导致系统资源紧张时持续快速重试，增加系统负载。", "code_v1_no_empty_lines": "- int limit = 3;\n- do {\n    ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n  } while (ret == EAGAIN && limit-- > 0);\n+ int trials_remaining = 4;\n+ useconds_t next_delay = 1000;\n+ while (true) {\n    ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n    if (ret != EAGAIN) {\n      break;\n    }\n    if (--trials_remaining <= 0) {\n      break;\n    }\n    log_debug(os, thread)(\"Failed to start native thread (%s), retrying after %dus.\", os::errno_name(ret), next_delay);\n    ::usleep(next_delay);\n    next_delay *= 2;\n  }", "target": "- int limit = 3;\n- do {\n    ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n  } while (ret == EAGAIN && limit-- > 0);\n+ int trials_remaining = 4;\n+ useconds_t next_delay = 1000;\n+ while (true) {\n    ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n    if (ret != EAGAIN) {\n      break;\n    }\n    if (--trials_remaining <= 0) {\n      break;\n    }\n    log_debug(os, thread)(\"Failed to start native thread (%s), retrying after %dus.\", os::errno_name(ret), next_delay);\n    ::usleep(next_delay);\n    next_delay *= 2;\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当pthread_create返回EAGAIN错误时，采用固定次数的重试（最多3次），重试之间没有延迟，可能导致系统资源紧张时持续快速重试，增加系统负载。优化后：采用指数退避策略，初始延迟1ms（Windows为1ms，Unix为1000us），每次重试延迟加倍，最多重试4次，并在重试时添加调试日志。优化思路：通过指数退避算法减少在系统资源紧张时的重试频率，避免雪崩效应，提高线程创建的成功率，同时添加日志便于问题诊断。"}
{"id": 322, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化", "optimization_description": "优化前：Color.createContext()方法和ColorPaintContext.getRaster()方法都使用了synchronized关键字进行同步，这在高并发场景下会带来不必要的锁竞争开销。优化后：移除了这两个方法的synchronized关键字，因为ColorPaintContext类被改为final且内部状态（color字段为final，savedTile使用volatile）保证了线程安全，无需同步。优化思路：通过分析发现ColorPaintContext的线程安全性可以通过final类和volatile字段保证，从而消除不必要的同步开销，提高多线程环境下的性能。", "original_code": "Color.createContext()方法和ColorPaintContext.getRaster()方法都使用了synchronized关键字进行同步，这在高并发场景下会带来不必要的锁竞争开销。", "optimized_code": "-    public synchronized PaintContext createContext(ColorModel cm, Rectangle r,\n-                                                   Rectangle2D r2d,\n-                                                   AffineTransform xform,\n-                                                   RenderingHints hints) {\n-        return new ColorPaintContext(getRGB(), cm);\n+    public PaintContext createContext(ColorModel cm, Rectangle r,\n+                                      Rectangle2D r2d, AffineTransform xform,\n+                                      RenderingHints hints) {\n+        return new ColorPaintContext(getRGB());\n     }\n\n-    public synchronized Raster getRaster(int x, int y, int w, int h) {\n+    public Raster getRaster(int x, int y, int w, int h) {", "source_url": "https://github.com/openjdk/riscv-port/commit/890456f0f78cc37c72b438a50ddf2605e1dfd91b", "code_v0_no_empty_lines": "Color.createContext()方法和ColorPaintContext.getRaster()方法都使用了synchronized关键字进行同步，这在高并发场景下会带来不必要的锁竞争开销。", "code_v1_no_empty_lines": "-    public synchronized PaintContext createContext(ColorModel cm, Rectangle r,\n-                                                   Rectangle2D r2d,\n-                                                   AffineTransform xform,\n-                                                   RenderingHints hints) {\n-        return new ColorPaintContext(getRGB(), cm);\n+    public PaintContext createContext(ColorModel cm, Rectangle r,\n+                                      Rectangle2D r2d, AffineTransform xform,\n+                                      RenderingHints hints) {\n+        return new ColorPaintContext(getRGB());\n     }\n\n-    public synchronized Raster getRaster(int x, int y, int w, int h) {\n+    public Raster getRaster(int x, int y, int w, int h) {", "target": "-    public synchronized PaintContext createContext(ColorModel cm, Rectangle r,\n-                                                   Rectangle2D r2d,\n-                                                   AffineTransform xform,\n-                                                   RenderingHints hints) {\n-        return new ColorPaintContext(getRGB(), cm);\n+    public PaintContext createContext(ColorModel cm, Rectangle r,\n+                                      Rectangle2D r2d, AffineTransform xform,\n+                                      RenderingHints hints) {\n+        return new ColorPaintContext(getRGB());\n     }\n\n-    public synchronized Raster getRaster(int x, int y, int w, int h) {\n+    public Raster getRaster(int x, int y, int w, int h) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Color.createContext()方法和ColorPaintContext.getRaster()方法都使用了synchronized关键字进行同步，这在高并发场景下会带来不必要的锁竞争开销。优化后：移除了这两个方法的synchronized关键字，因为ColorPaintContext类被改为final且内部状态（color字段为final，savedTile使用volatile）保证了线程安全，无需同步。优化思路：通过分析发现ColorPaintContext的线程安全性可以通过final类和volatile字段保证，从而消除不必要的同步开销，提高多线程环境下的性能。"}
{"id": 323, "source": "riscv-dataset-excel", "optimization_type": "循环优化+代码简化", "optimization_description": "优化前：try_collect_fullgc函数包含一个while(true)无限循环，用于处理显式Full GC请求，循环内包含锁操作和条件检查，增加了复杂性和潜在开销。优化后：完全移除try_collect_fullgc函数及其循环逻辑，直接在try_collect函数中内联创建并执行VM_G1CollectFull操作，简化了Full GC的调度流程。优化思路：消除不必要的循环结构，减少函数调用层次和锁操作，简化代码逻辑，提高可维护性并可能减少轻微运行时开销。", "original_code": "try_collect_fullgc函数包含一个while(true)无限循环，用于处理显式Full GC请求，循环内包含锁操作和条件检查，增加了复杂性和潜在开销。", "optimized_code": "-bool G1CollectedHeap::try_collect_fullgc(GCCause::Cause cause,\n-                                         const G1GCCounters& counters_before) {\n-  assert_heap_not_locked();\n-\n-  while(true) {\n-    VM_G1CollectFull op(counters_before.total_collections(),\n-                        counters_before.total_full_collections(),\n-                        cause);\n-    VMThread::execute(&op);\n-\n-    // Request is trivially finished.\n-    if (!GCCause::is_explicit_full_gc(cause) || op.gc_succeeded()) {\n-      return op.gc_succeeded();\n-    }\n-\n-    {\n-      MutexLocker ml(Heap_lock);\n-      if (counters_before.total_full_collections() != total_full_collections()) {\n-        return true;\n-      }\n-    }\n-  }\n-}\n+    // Schedule a Full GC.\n+    VM_G1CollectFull op(counters_before.total_collections(),\n+                        counters_before.total_full_collections(),\n+                        cause);\n+    VMThread::execute(&op);\n+    return op.gc_succeeded();", "source_url": "https://github.com/openjdk/riscv-port/commit/e6750a5bb0580733820a0885d40704e050baf97d", "code_v0_no_empty_lines": "try_collect_fullgc函数包含一个while(true)无限循环，用于处理显式Full GC请求，循环内包含锁操作和条件检查，增加了复杂性和潜在开销。", "code_v1_no_empty_lines": "-bool G1CollectedHeap::try_collect_fullgc(GCCause::Cause cause,\n-                                         const G1GCCounters& counters_before) {\n-  assert_heap_not_locked();\n-\n-  while(true) {\n-    VM_G1CollectFull op(counters_before.total_collections(),\n-                        counters_before.total_full_collections(),\n-                        cause);\n-    VMThread::execute(&op);\n-\n-    // Request is trivially finished.\n-    if (!GCCause::is_explicit_full_gc(cause) || op.gc_succeeded()) {\n-      return op.gc_succeeded();\n-    }\n-\n-    {\n-      MutexLocker ml(Heap_lock);\n-      if (counters_before.total_full_collections() != total_full_collections()) {\n-        return true;\n-      }\n-    }\n-  }\n-}\n+    // Schedule a Full GC.\n+    VM_G1CollectFull op(counters_before.total_collections(),\n+                        counters_before.total_full_collections(),\n+                        cause);\n+    VMThread::execute(&op);\n+    return op.gc_succeeded();", "target": "-bool G1CollectedHeap::try_collect_fullgc(GCCause::Cause cause,\n-                                         const G1GCCounters& counters_before) {\n-  assert_heap_not_locked();\n-\n-  while(true) {\n-    VM_G1CollectFull op(counters_before.total_collections(),\n-                        counters_before.total_full_collections(),\n-                        cause);\n-    VMThread::execute(&op);\n-\n-    // Request is trivially finished.\n-    if (!GCCause::is_explicit_full_gc(cause) || op.gc_succeeded()) {\n-      return op.gc_succeeded();\n-    }\n-\n-    {\n-      MutexLocker ml(Heap_lock);\n-      if (counters_before.total_full_collections() != total_full_collections()) {\n-        return true;\n-      }\n-    }\n-  }\n-}\n+    // Schedule a Full GC.\n+    VM_G1CollectFull op(counters_before.total_collections(),\n+                        counters_before.total_full_collections(),\n+                        cause);\n+    VMThread::execute(&op);\n+    return op.gc_succeeded();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：try_collect_fullgc函数包含一个while(true)无限循环，用于处理显式Full GC请求，循环内包含锁操作和条件检查，增加了复杂性和潜在开销。优化后：完全移除try_collect_fullgc函数及其循环逻辑，直接在try_collect函数中内联创建并执行VM_G1CollectFull操作，简化了Full GC的调度流程。优化思路：消除不必要的循环结构，减少函数调用层次和锁操作，简化代码逻辑，提高可维护性并可能减少轻微运行时开销。"}
{"id": 324, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：G1堆大小调整策略在Full GC后计算调整量时未考虑即将发生的分配请求大小，可能导致堆收缩后立即需要扩展以满足分配。优化后：在full_collection_resize_amount方法中增加allocation_word_size参数，使堆大小调整能考虑即将发生的分配需求，避免不必要的堆扩展操作。优化思路：通过传递分配请求大小给堆大小调整策略，使堆收缩决策更加智能，减少后续扩展开销。", "original_code": "G1堆大小调整策略在Full GC后计算调整量时未考虑即将发生的分配请求大小，可能导致堆收缩后立即需要扩展以满足分配。", "optimized_code": "- size_t resize_amount = _heap_sizing_policy->full_collection_resize_amount(should_expand);\n+ size_t resize_amount = _heap_sizing_policy->full_collection_resize_amount(should_expand, allocation_word_size);", "source_url": "https://github.com/openjdk/riscv-port/commit/91194517c75a96fe7bcc2dcf5e9c42af9cf5975a", "code_v0_no_empty_lines": "G1堆大小调整策略在Full GC后计算调整量时未考虑即将发生的分配请求大小，可能导致堆收缩后立即需要扩展以满足分配。", "code_v1_no_empty_lines": "- size_t resize_amount = _heap_sizing_policy->full_collection_resize_amount(should_expand);\n+ size_t resize_amount = _heap_sizing_policy->full_collection_resize_amount(should_expand, allocation_word_size);", "target": "- size_t resize_amount = _heap_sizing_policy->full_collection_resize_amount(should_expand);\n+ size_t resize_amount = _heap_sizing_policy->full_collection_resize_amount(should_expand, allocation_word_size);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：G1堆大小调整策略在Full GC后计算调整量时未考虑即将发生的分配请求大小，可能导致堆收缩后立即需要扩展以满足分配。优化后：在full_collection_resize_amount方法中增加allocation_word_size参数，使堆大小调整能考虑即将发生的分配需求，避免不必要的堆扩展操作。优化思路：通过传递分配请求大小给堆大小调整策略，使堆收缩决策更加智能，减少后续扩展开销。"}
{"id": 325, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+加密算法加速", "optimization_description": "优化前：ML-KEM（Kyber）算法使用通用指令实现，性能受限。优化后：新增AVX-512向量化指令集专用实现，通过生成Kyber加密算法的汇编存根（stubs），利用AVX-512的512位宽向量寄存器并行处理多个数据元素，大幅提升数论变换（NTT）等核心运算性能。思路：针对后量子加密算法ML-KEM，开发硬件加速指令集优化，通过专用汇编代码替代通用实现，减少指令数并提高并行度。", "original_code": "ML-KEM（Kyber）算法使用通用指令实现，性能受限。", "optimized_code": "+  generate_kyber_stubs();\n+  // Kyber stubs\n+  void generate_kyber_stubs();\n+  // 新增952行AVX-512汇编代码文件stubGenerator_x86_64_kyber.cpp", "source_url": "https://github.com/openjdk/riscv-port/commit/972f2ebe978280d22531a70116e79837632f6ebc", "code_v0_no_empty_lines": "ML-KEM（Kyber）算法使用通用指令实现，性能受限。", "code_v1_no_empty_lines": "+  generate_kyber_stubs();\n+  // Kyber stubs\n+  void generate_kyber_stubs();\n+  // 新增952行AVX-512汇编代码文件stubGenerator_x86_64_kyber.cpp", "target": "+  generate_kyber_stubs();\n+  // Kyber stubs\n+  void generate_kyber_stubs();\n+  // 新增952行AVX-512汇编代码文件stubGenerator_x86_64_kyber.cpp", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ML-KEM（Kyber）算法使用通用指令实现，性能受限。优化后：新增AVX-512向量化指令集专用实现，通过生成Kyber加密算法的汇编存根（stubs），利用AVX-512的512位宽向量寄存器并行处理多个数据元素，大幅提升数论变换（NTT）等核心运算性能。思路：针对后量子加密算法ML-KEM，开发硬件加速指令集优化，通过专用汇编代码替代通用实现，减少指令数并提高并行度。"}
{"id": 326, "source": "riscv-dataset-excel", "optimization_type": "字符串处理优化", "optimization_description": "优化前：使用substring方法创建新的字符串对象，然后传递给Integer.parseInt进行解析，产生额外的内存分配和复制开销。优化后：直接调用Integer.parseInt的重载版本，传入原始字符串和位置参数，避免创建中间子字符串对象，减少内存分配和垃圾回收压力，提高HTTP响应码解析性能。", "original_code": "使用substring方法创建新的字符串对象，然后传递给Integer.parseInt进行解析，产生额外的内存分配和复制开销。", "optimized_code": "- (statusLine.substring(codePos+1, phrasePos));\n+ (statusLine, codePos+1, phrasePos, 10);", "source_url": "https://github.com/openjdk/riscv-port/commit/e9d1d87b34f636747065c01128a12fc057070e09", "code_v0_no_empty_lines": "使用substring方法创建新的字符串对象，然后传递给Integer.parseInt进行解析，产生额外的内存分配和复制开销。", "code_v1_no_empty_lines": "- (statusLine.substring(codePos+1, phrasePos));\n+ (statusLine, codePos+1, phrasePos, 10);", "target": "- (statusLine.substring(codePos+1, phrasePos));\n+ (statusLine, codePos+1, phrasePos, 10);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用substring方法创建新的字符串对象，然后传递给Integer.parseInt进行解析，产生额外的内存分配和复制开销。优化后：直接调用Integer.parseInt的重载版本，传入原始字符串和位置参数，避免创建中间子字符串对象，减少内存分配和垃圾回收压力，提高HTTP响应码解析性能。"}
{"id": 327, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+内存对齐优化", "optimization_description": "优化前：自动向量化时，内存操作（load/store）可能因未对齐缓存行而被拆分，导致性能下降，特别是store拆分影响更大（CPU通常每周期支持2 loads/1 store）。优化后：引入SuperWordAutomaticAlignment选项（默认=1），优先将向量与store操作对齐，避免store拆分；当存在多个最大宽度内存操作时，根据配置选择对齐load或store。优化思路：通过智能对齐策略减少内存操作拆分，提升向量化代码性能。", "original_code": "自动向量化时，内存操作（load/store）可能因未对齐缓存行而被拆分，导致性能下降，特别是store拆分影响更大（CPU通常每周期支持2 loads/1 store）。", "optimized_code": "if (vw > max_aw) {\n+    // Generally, we prefer to align with the largest memory op (load or store).\n+    // If there are multiple, then SuperWordAutomaticAlignment determines if we\n+    // prefer loads or stores.\n+    // When a load or store is misaligned, this can lead to the load or store\n+    // being split, when it goes over a cache line. Most CPUs can schedule\n+    // more loads than stores per cycle (often 2 loads and 1 store). Hence,\n+    // it is worse if a store is split, and less bad if a load is split.\n+    // By default, we have SuperWordAutomaticAlignment=1, i.e. we align with a\n+    // store if possible, to avoid splitting that store.\n+    bool prefer_store = mem_ref != nullptr && SuperWordAutomaticAlignment == 1 && mem_ref->is_Load() && p0->is_Store();\n+    bool prefer_load  = mem_ref != nullptr && SuperWordAutomaticAlignment == 2 && mem_ref->is_Store() && p0->is_Load();\n+    if (vw > max_aw || (vw == max_aw && (prefer_load || prefer_store))) {\n       max_aw = vw;\n       mem_ref = p0;\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/277bb208a2c6de888c57285854b6f5d030021f94", "code_v0_no_empty_lines": "自动向量化时，内存操作（load/store）可能因未对齐缓存行而被拆分，导致性能下降，特别是store拆分影响更大（CPU通常每周期支持2 loads/1 store）。", "code_v1_no_empty_lines": "if (vw > max_aw) {\n+    // Generally, we prefer to align with the largest memory op (load or store).\n+    // If there are multiple, then SuperWordAutomaticAlignment determines if we\n+    // prefer loads or stores.\n+    // When a load or store is misaligned, this can lead to the load or store\n+    // being split, when it goes over a cache line. Most CPUs can schedule\n+    // more loads than stores per cycle (often 2 loads and 1 store). Hence,\n+    // it is worse if a store is split, and less bad if a load is split.\n+    // By default, we have SuperWordAutomaticAlignment=1, i.e. we align with a\n+    // store if possible, to avoid splitting that store.\n+    bool prefer_store = mem_ref != nullptr && SuperWordAutomaticAlignment == 1 && mem_ref->is_Load() && p0->is_Store();\n+    bool prefer_load  = mem_ref != nullptr && SuperWordAutomaticAlignment == 2 && mem_ref->is_Store() && p0->is_Load();\n+    if (vw > max_aw || (vw == max_aw && (prefer_load || prefer_store))) {\n       max_aw = vw;\n       mem_ref = p0;\n     }", "target": "if (vw > max_aw) {\n+    // Generally, we prefer to align with the largest memory op (load or store).\n+    // If there are multiple, then SuperWordAutomaticAlignment determines if we\n+    // prefer loads or stores.\n+    // When a load or store is misaligned, this can lead to the load or store\n+    // being split, when it goes over a cache line. Most CPUs can schedule\n+    // more loads than stores per cycle (often 2 loads and 1 store). Hence,\n+    // it is worse if a store is split, and less bad if a load is split.\n+    // By default, we have SuperWordAutomaticAlignment=1, i.e. we align with a\n+    // store if possible, to avoid splitting that store.\n+    bool prefer_store = mem_ref != nullptr && SuperWordAutomaticAlignment == 1 && mem_ref->is_Load() && p0->is_Store();\n+    bool prefer_load  = mem_ref != nullptr && SuperWordAutomaticAlignment == 2 && mem_ref->is_Store() && p0->is_Load();\n+    if (vw > max_aw || (vw == max_aw && (prefer_load || prefer_store))) {\n       max_aw = vw;\n       mem_ref = p0;\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：自动向量化时，内存操作（load/store）可能因未对齐缓存行而被拆分，导致性能下降，特别是store拆分影响更大（CPU通常每周期支持2 loads/1 store）。优化后：引入SuperWordAutomaticAlignment选项（默认=1），优先将向量与store操作对齐，避免store拆分；当存在多个最大宽度内存操作时，根据配置选择对齐load或store。优化思路：通过智能对齐策略减少内存操作拆分，提升向量化代码性能。"}
{"id": 328, "source": "riscv-dataset-excel", "optimization_type": "I/O性能优化", "optimization_description": "优化前：在构造zipfs文件系统时，默认会读取ZIP文件中未存储在中央目录的时间戳信息，导致额外的I/O开销。优化后：通过设置zipinfo-time=false环境参数，忽略这些时间戳信息，减少文件系统初始化时的I/O操作。优化思路：通过配置ZipFileSystem的行为，避免不必要的元数据读取，提升Javac文件管理器处理ZIP/JAR文件时的性能。", "original_code": "在构造zipfs文件系统时，默认会读取ZIP文件中未存储在中央目录的时间戳信息，导致额外的I/O开销。", "optimized_code": "+            Map<String,String> env = new HashMap<>();\n+            // ignores timestamps not stored in ZIP central directory, reducing I/O\n+            // This key is handled by ZipFileSystem only.\n+            env.put(\"zipinfo-time\", \"false\");\n             if (multiReleaseValue != null && archivePath.toString().endsWith(\".jar\")) {\n-                Map<String,String> env = Collections.singletonMap(\"multi-release\", multiReleaseValue);\n+                env.put(\"multi-release\", multiReleaseValue);\n                 FileSystemProvider jarFSProvider = fsInfo.getJarFSProvider();\n                 Assert.checkNonNull(jarFSProvider, \"should have been caught before!\");\n                 try {\n@@ -571,7 +576,9 @@ public ArchiveContainer(Path archivePath) throws IOException, ProviderNotFoundEx\n                     throw new IOException(\"ZipException opening \\\"\" + archivePath.getFileName() + \"\\\": \" + ze.getMessage(), ze);\n                 }\n             } else {\n-                this.fileSystem = FileSystems.newFileSystem(archivePath, (ClassLoader)null);\n+                // Less common case is possible if the file manager was not initialized in JavacTask,\n+                // or if non \"*.jar\" files are on the classpath.\n+                this.fileSystem = FileSystems.newFileSystem(archivePath, env, (ClassLoader)null);\n             }", "source_url": "https://github.com/openjdk/riscv-port/commit/d9b6e4b13200684b69a161e288b9883ff0d96bec", "code_v0_no_empty_lines": "在构造zipfs文件系统时，默认会读取ZIP文件中未存储在中央目录的时间戳信息，导致额外的I/O开销。", "code_v1_no_empty_lines": "+            Map<String,String> env = new HashMap<>();\n+            // ignores timestamps not stored in ZIP central directory, reducing I/O\n+            // This key is handled by ZipFileSystem only.\n+            env.put(\"zipinfo-time\", \"false\");\n             if (multiReleaseValue != null && archivePath.toString().endsWith(\".jar\")) {\n-                Map<String,String> env = Collections.singletonMap(\"multi-release\", multiReleaseValue);\n+                env.put(\"multi-release\", multiReleaseValue);\n                 FileSystemProvider jarFSProvider = fsInfo.getJarFSProvider();\n                 Assert.checkNonNull(jarFSProvider, \"should have been caught before!\");\n                 try {\n@@ -571,7 +576,9 @@ public ArchiveContainer(Path archivePath) throws IOException, ProviderNotFoundEx\n                     throw new IOException(\"ZipException opening \\\"\" + archivePath.getFileName() + \"\\\": \" + ze.getMessage(), ze);\n                 }\n             } else {\n-                this.fileSystem = FileSystems.newFileSystem(archivePath, (ClassLoader)null);\n+                // Less common case is possible if the file manager was not initialized in JavacTask,\n+                // or if non \"*.jar\" files are on the classpath.\n+                this.fileSystem = FileSystems.newFileSystem(archivePath, env, (ClassLoader)null);\n             }", "target": "+            Map<String,String> env = new HashMap<>();\n+            // ignores timestamps not stored in ZIP central directory, reducing I/O\n+            // This key is handled by ZipFileSystem only.\n+            env.put(\"zipinfo-time\", \"false\");\n             if (multiReleaseValue != null && archivePath.toString().endsWith(\".jar\")) {\n-                Map<String,String> env = Collections.singletonMap(\"multi-release\", multiReleaseValue);\n+                env.put(\"multi-release\", multiReleaseValue);\n                 FileSystemProvider jarFSProvider = fsInfo.getJarFSProvider();\n                 Assert.checkNonNull(jarFSProvider, \"should have been caught before!\");\n                 try {\n@@ -571,7 +576,9 @@ public ArchiveContainer(Path archivePath) throws IOException, ProviderNotFoundEx\n                     throw new IOException(\"ZipException opening \\\"\" + archivePath.getFileName() + \"\\\": \" + ze.getMessage(), ze);\n                 }\n             } else {\n-                this.fileSystem = FileSystems.newFileSystem(archivePath, (ClassLoader)null);\n+                // Less common case is possible if the file manager was not initialized in JavacTask,\n+                // or if non \"*.jar\" files are on the classpath.\n+                this.fileSystem = FileSystems.newFileSystem(archivePath, env, (ClassLoader)null);\n             }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在构造zipfs文件系统时，默认会读取ZIP文件中未存储在中央目录的时间戳信息，导致额外的I/O开销。优化后：通过设置zipinfo-time=false环境参数，忽略这些时间戳信息，减少文件系统初始化时的I/O操作。优化思路：通过配置ZipFileSystem的行为，避免不必要的元数据读取，提升Javac文件管理器处理ZIP/JAR文件时的性能。"}
{"id": 329, "source": "riscv-dataset-excel", "optimization_type": "性能优化+内存优化", "optimization_description": "优化前：每次调用getSubset()方法都会创建新的ExtendedTextSourceLabel对象，即使请求的是完整文本且方向未变，导致不必要的对象创建和文本整形开销。优化后：添加条件检查，当请求的是完整文本（start=0, limit=总长度）且方向未变时，直接返回当前对象，避免创建新对象和重复的文本整形操作。优化思路：通过短路优化，在常见的不需要子集的情况下避免昂贵的对象创建和文本处理，提升LineBreakMeasurer.nextLayout()方法的性能。", "original_code": "每次调用getSubset()方法都会创建新的ExtendedTextSourceLabel对象，即使请求的是完整文本且方向未变，导致不必要的对象创建和文本整形开销。", "optimized_code": "-    return new ExtendedTextSourceLabel(source.getSubSource(start, limit-start, dir), decorator);\n+    if (start == 0 &&\n+        limit == source.getLength() &&\n+        (dir == source.getBidiLevel() || dir == TextLineComponent.UNCHANGED)) {\n+        return this; // avoid unnecessary object creation and text shaping\n+    } else {\n+        TextSource subSource = source.getSubSource(start, limit-start, dir);\n+        return new ExtendedTextSourceLabel(subSource, decorator);\n+    }", "source_url": "https://github.com/openjdk/riscv-port/commit/fdda7661906eab63d939e9f482449e21cc143c8f", "code_v0_no_empty_lines": "每次调用getSubset()方法都会创建新的ExtendedTextSourceLabel对象，即使请求的是完整文本且方向未变，导致不必要的对象创建和文本整形开销。", "code_v1_no_empty_lines": "-    return new ExtendedTextSourceLabel(source.getSubSource(start, limit-start, dir), decorator);\n+    if (start == 0 &&\n+        limit == source.getLength() &&\n+        (dir == source.getBidiLevel() || dir == TextLineComponent.UNCHANGED)) {\n+        return this; // avoid unnecessary object creation and text shaping\n+    } else {\n+        TextSource subSource = source.getSubSource(start, limit-start, dir);\n+        return new ExtendedTextSourceLabel(subSource, decorator);\n+    }", "target": "-    return new ExtendedTextSourceLabel(source.getSubSource(start, limit-start, dir), decorator);\n+    if (start == 0 &&\n+        limit == source.getLength() &&\n+        (dir == source.getBidiLevel() || dir == TextLineComponent.UNCHANGED)) {\n+        return this; // avoid unnecessary object creation and text shaping\n+    } else {\n+        TextSource subSource = source.getSubSource(start, limit-start, dir);\n+        return new ExtendedTextSourceLabel(subSource, decorator);\n+    }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次调用getSubset()方法都会创建新的ExtendedTextSourceLabel对象，即使请求的是完整文本且方向未变，导致不必要的对象创建和文本整形开销。优化后：添加条件检查，当请求的是完整文本（start=0, limit=总长度）且方向未变时，直接返回当前对象，避免创建新对象和重复的文本整形操作。优化思路：通过短路优化，在常见的不需要子集的情况下避免昂贵的对象创建和文本处理，提升LineBreakMeasurer.nextLayout()方法的性能。"}
{"id": 330, "source": "riscv-dataset-excel", "optimization_type": "算法优化+内存访问优化", "optimization_description": "优化前：使用HexDigits.put4()方法进行16进制转换，需要多次查表（DIGITS数组）和逐字节写入操作，存在内存访问开销和分支操作。优化后：1. 新增hex8()方法使用SIMD风格的向量运算，通过Long.expand()扩展4位到8位，利用位运算和整数算术并行处理8个16进制数字，避免查表和分支；2. 使用ByteArrayLittleEndian进行内存写入，优化小端架构的内存访问模式。优化思路：将串行的查表转换改为并行的向量运算，减少内存访问次数，利用CPU的向量处理能力提升性能。", "original_code": "使用HexDigits.put4()方法进行16进制转换，需要多次查表（DIGITS数组）和逐字节写入操作，存在内存访问开销和分支操作。", "optimized_code": "- import jdk.internal.util.HexDigits;\n+ import jdk.internal.util.ByteArrayLittleEndian;\n- int i0 = (int) (mostSigBits >> 32);\n- int i1 = (int) mostSigBits;\n- int i2 = (int) (leastSigBits >> 32);\n- int i3 = (int) leastSigBits;\n- HexDigits.put4(buf, 0, i0 >> 16);\n- HexDigits.put4(buf, 4, i0);\n- HexDigits.put4(buf, 9, i1 >> 16);\n- HexDigits.put4(buf, 14, i1);\n- HexDigits.put4(buf, 19, i2 >> 16);\n- HexDigits.put4(buf, 24, i2);\n- HexDigits.put4(buf, 28, i3 >> 16);\n- HexDigits.put4(buf, 32, i3);\n+ ByteArrayLittleEndian.setLong(buf, 0, hex8(mostSigBits >>> 32));\n+ long x0 = hex8(mostSigBits);\n+ ByteArrayLittleEndian.setInt(buf, 9, (int) x0);\n+ ByteArrayLittleEndian.setInt(buf, 14, (int) (x0 >>> 32));\n+ long x1 = hex8(leastSigBits >>> 32);\n+ ByteArrayLittleEndian.setInt(buf, 19, (int) (x1));\n+ ByteArrayLittleEndian.setInt(buf, 24, (int) (x1 >>> 32));\n+ ByteArrayLittleEndian.setLong(buf, 28, hex8(leastSigBits));\n+ private static long hex8(long i) {\n+     i = Long.expand(i, 0x0F0F_0F0F_0F0F_0F0FL);\n+     long m = (i + 0x0606_0606_0606_0606L) & 0x1010_1010_1010_1010L;\n+     return Long.reverseBytes(\n+             ((m << 1) + (m >> 1) - (m >> 4))\n+             + 0x3030_3030_3030_3030L\n+             + i\n+     );\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/796ec5e7cfcfb20d76a3b48c0b369dc73250f7e4", "code_v0_no_empty_lines": "使用HexDigits.put4()方法进行16进制转换，需要多次查表（DIGITS数组）和逐字节写入操作，存在内存访问开销和分支操作。", "code_v1_no_empty_lines": "- import jdk.internal.util.HexDigits;\n+ import jdk.internal.util.ByteArrayLittleEndian;\n- int i0 = (int) (mostSigBits >> 32);\n- int i1 = (int) mostSigBits;\n- int i2 = (int) (leastSigBits >> 32);\n- int i3 = (int) leastSigBits;\n- HexDigits.put4(buf, 0, i0 >> 16);\n- HexDigits.put4(buf, 4, i0);\n- HexDigits.put4(buf, 9, i1 >> 16);\n- HexDigits.put4(buf, 14, i1);\n- HexDigits.put4(buf, 19, i2 >> 16);\n- HexDigits.put4(buf, 24, i2);\n- HexDigits.put4(buf, 28, i3 >> 16);\n- HexDigits.put4(buf, 32, i3);\n+ ByteArrayLittleEndian.setLong(buf, 0, hex8(mostSigBits >>> 32));\n+ long x0 = hex8(mostSigBits);\n+ ByteArrayLittleEndian.setInt(buf, 9, (int) x0);\n+ ByteArrayLittleEndian.setInt(buf, 14, (int) (x0 >>> 32));\n+ long x1 = hex8(leastSigBits >>> 32);\n+ ByteArrayLittleEndian.setInt(buf, 19, (int) (x1));\n+ ByteArrayLittleEndian.setInt(buf, 24, (int) (x1 >>> 32));\n+ ByteArrayLittleEndian.setLong(buf, 28, hex8(leastSigBits));\n+ private static long hex8(long i) {\n+     i = Long.expand(i, 0x0F0F_0F0F_0F0F_0F0FL);\n+     long m = (i + 0x0606_0606_0606_0606L) & 0x1010_1010_1010_1010L;\n+     return Long.reverseBytes(\n+             ((m << 1) + (m >> 1) - (m >> 4))\n+             + 0x3030_3030_3030_3030L\n+             + i\n+     );\n+ }", "target": "- import jdk.internal.util.HexDigits;\n+ import jdk.internal.util.ByteArrayLittleEndian;\n- int i0 = (int) (mostSigBits >> 32);\n- int i1 = (int) mostSigBits;\n- int i2 = (int) (leastSigBits >> 32);\n- int i3 = (int) leastSigBits;\n- HexDigits.put4(buf, 0, i0 >> 16);\n- HexDigits.put4(buf, 4, i0);\n- HexDigits.put4(buf, 9, i1 >> 16);\n- HexDigits.put4(buf, 14, i1);\n- HexDigits.put4(buf, 19, i2 >> 16);\n- HexDigits.put4(buf, 24, i2);\n- HexDigits.put4(buf, 28, i3 >> 16);\n- HexDigits.put4(buf, 32, i3);\n+ ByteArrayLittleEndian.setLong(buf, 0, hex8(mostSigBits >>> 32));\n+ long x0 = hex8(mostSigBits);\n+ ByteArrayLittleEndian.setInt(buf, 9, (int) x0);\n+ ByteArrayLittleEndian.setInt(buf, 14, (int) (x0 >>> 32));\n+ long x1 = hex8(leastSigBits >>> 32);\n+ ByteArrayLittleEndian.setInt(buf, 19, (int) (x1));\n+ ByteArrayLittleEndian.setInt(buf, 24, (int) (x1 >>> 32));\n+ ByteArrayLittleEndian.setLong(buf, 28, hex8(leastSigBits));\n+ private static long hex8(long i) {\n+     i = Long.expand(i, 0x0F0F_0F0F_0F0F_0F0FL);\n+     long m = (i + 0x0606_0606_0606_0606L) & 0x1010_1010_1010_1010L;\n+     return Long.reverseBytes(\n+             ((m << 1) + (m >> 1) - (m >> 4))\n+             + 0x3030_3030_3030_3030L\n+             + i\n+     );\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用HexDigits.put4()方法进行16进制转换，需要多次查表（DIGITS数组）和逐字节写入操作，存在内存访问开销和分支操作。优化后：1. 新增hex8()方法使用SIMD风格的向量运算，通过Long.expand()扩展4位到8位，利用位运算和整数算术并行处理8个16进制数字，避免查表和分支；2. 使用ByteArrayLittleEndian进行内存写入，优化小端架构的内存访问模式。优化思路：将串行的查表转换改为并行的向量运算，减少内存访问次数，利用CPU的向量处理能力提升性能。"}
{"id": 331, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+内存操作优化", "optimization_description": "优化前：Unsafe::setMemory 操作在 RISC-V 平台上没有专门的硬件指令支持，需要通过软件循环逐字节填充内存，效率较低。优化后：为 RISC-V 平台实现了 Unsafe::setMemory 的硬件指令集优化（intrinsify），通过生成专门的汇编代码来高效处理内存填充操作。优化思路：1) 使用位操作将单字节值扩展到64位宽度，2) 对目标地址进行8字节对齐处理，3) 对大于8字节的数据块使用批量填充指令（fill_words），4) 对剩余字节使用优化的逐字节/逐字填充策略。这显著提升了内存填充操作的性能，特别是对大块内存的操作。", "original_code": "Unsafe::setMemory 操作在 RISC-V 平台上没有专门的硬件指令支持，需要通过软件循环逐字节填充内存，效率较低。", "optimized_code": "address generate_unsafe_setmemory() {\n    __ align(CodeEntryAlignment);\n    StubGenStubId stub_id = StubGenStubId::unsafe_setmemory_id;\n    StubCodeMark mark(this, stub_id);\n    address start = __ pc();\n\n    // bump this on entry, not on exit:\n    // inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n\n    Label L_fill_elements;\n\n    const Register dest = c_rarg0;\n    const Register count = c_rarg1;\n    const Register value = c_rarg2;\n    const Register cnt_words = x28; // temp register\n    const Register tmp_reg   = x29; // temp register\n\n    // Mark remaining code as such which performs Unsafe accesses.\n    UnsafeMemoryAccessMark umam(this, true, false);\n\n    __ enter(); // required for proper stackwalking of RuntimeStub frame\n\n    // if count < 8, jump to L_fill_elements\n    __ mv(tmp_reg, 8); // 8 bytes fill by element\n    __ bltu(count, tmp_reg, L_fill_elements);\n\n    // Propagate byte to 64-bit width\n    // 8 bit -> 16 bit\n    __ zext(value, value, 8);\n    __ slli(tmp_reg, value, 8);\n    __ orr(value, value, tmp_reg);\n    // 16 bit -> 32 bit\n    __ slli(tmp_reg, value, 16);\n    __ orr(value, value, tmp_reg);\n    // 32 bit -> 64 bit\n    __ slli(tmp_reg, value, 32);\n    __ orr(value, value, tmp_reg);\n\n    // Align source address at 8 bytes address boundary.\n    Label L_skip_align1, L_skip_align2, L_skip_align4;\n    // One byte misalignment happens.\n    __ test_bit(tmp_reg, dest, 0);\n    __ beqz(tmp_reg, L_skip_align1);\n    __ sb(value, Address(dest, 0));\n    __ addi(dest, dest, 1);\n    __ subi(count, count, 1);\n\n    __ bind(L_skip_align1);\n    // Two bytes misalignment happens.\n    __ test_bit(tmp_reg, dest, 1);\n    __ beqz(tmp_reg, L_skip_align2);\n    __ sh(value, Address(dest, 0));\n    __ addi(dest, dest, 2);\n    __ subi(count, count, 2);\n\n    __ bind(L_skip_align2);\n    // Four bytes misalignment happens.\n    __ test_bit(tmp_reg, dest, 2);\n    __ beqz(tmp_reg, L_skip_align4);\n    __ sw(value, Address(dest, 0));\n    __ addi(dest, dest, 4);\n    __ subi(count, count, 4);\n    __ bind(L_skip_align4);\n\n    //  Fill large chunks\n    __ srli(cnt_words, count, 3); // number of words\n    __ slli(tmp_reg, cnt_words, 3);\n    __ sub(count, count, tmp_reg);\n    {\n      __ fill_words(dest, cnt_words, value);\n    }\n\n    // Handle copies less than 8 bytes\n    __ bind(L_fill_elements);\n    Label L_fill_2, L_fill_1, L_exit;\n    __ test_bit(tmp_reg, count, 2);\n    __ beqz(tmp_reg, L_fill_2);\n    __ sb(value, Address(dest, 0));\n    __ sb(value, Address(dest, 1));\n    __ sb(value, Address(dest, 2));\n    __ sb(value, Address(dest, 3));\n    __ addi(dest, dest, 4);\n\n    __ bind(L_fill_2);\n    __ test_bit(tmp_reg, count, 1);\n    __ beqz(tmp_reg, L_fill_1);\n    __ sb(value, Address(dest, 0));\n    __ sb(value, Address(dest, 1));\n    __ addi(dest, dest, 2);\n\n    __ bind(L_fill_1);\n    __ test_bit(tmp_reg, count, 0);\n    __ beqz(tmp_reg, L_exit);\n    __ sb(value, Address(dest, 0));\n\n    __ bind(L_exit);\n    __ leave();\n    __ ret();\n\n    return start;\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/1fd65b7a7b0ec38fde79aa4f5e53506d28893439", "code_v0_no_empty_lines": "Unsafe::setMemory 操作在 RISC-V 平台上没有专门的硬件指令支持，需要通过软件循环逐字节填充内存，效率较低。", "code_v1_no_empty_lines": "address generate_unsafe_setmemory() {\n    __ align(CodeEntryAlignment);\n    StubGenStubId stub_id = StubGenStubId::unsafe_setmemory_id;\n    StubCodeMark mark(this, stub_id);\n    address start = __ pc();\n\n    // bump this on entry, not on exit:\n    // inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n\n    Label L_fill_elements;\n\n    const Register dest = c_rarg0;\n    const Register count = c_rarg1;\n    const Register value = c_rarg2;\n    const Register cnt_words = x28; // temp register\n    const Register tmp_reg   = x29; // temp register\n\n    // Mark remaining code as such which performs Unsafe accesses.\n    UnsafeMemoryAccessMark umam(this, true, false);\n\n    __ enter(); // required for proper stackwalking of RuntimeStub frame\n\n    // if count < 8, jump to L_fill_elements\n    __ mv(tmp_reg, 8); // 8 bytes fill by element\n    __ bltu(count, tmp_reg, L_fill_elements);\n\n    // Propagate byte to 64-bit width\n    // 8 bit -> 16 bit\n    __ zext(value, value, 8);\n    __ slli(tmp_reg, value, 8);\n    __ orr(value, value, tmp_reg);\n    // 16 bit -> 32 bit\n    __ slli(tmp_reg, value, 16);\n    __ orr(value, value, tmp_reg);\n    // 32 bit -> 64 bit\n    __ slli(tmp_reg, value, 32);\n    __ orr(value, value, tmp_reg);\n\n    // Align source address at 8 bytes address boundary.\n    Label L_skip_align1, L_skip_align2, L_skip_align4;\n    // One byte misalignment happens.\n    __ test_bit(tmp_reg, dest, 0);\n    __ beqz(tmp_reg, L_skip_align1);\n    __ sb(value, Address(dest, 0));\n    __ addi(dest, dest, 1);\n    __ subi(count, count, 1);\n\n    __ bind(L_skip_align1);\n    // Two bytes misalignment happens.\n    __ test_bit(tmp_reg, dest, 1);\n    __ beqz(tmp_reg, L_skip_align2);\n    __ sh(value, Address(dest, 0));\n    __ addi(dest, dest, 2);\n    __ subi(count, count, 2);\n\n    __ bind(L_skip_align2);\n    // Four bytes misalignment happens.\n    __ test_bit(tmp_reg, dest, 2);\n    __ beqz(tmp_reg, L_skip_align4);\n    __ sw(value, Address(dest, 0));\n    __ addi(dest, dest, 4);\n    __ subi(count, count, 4);\n    __ bind(L_skip_align4);\n\n    //  Fill large chunks\n    __ srli(cnt_words, count, 3); // number of words\n    __ slli(tmp_reg, cnt_words, 3);\n    __ sub(count, count, tmp_reg);\n    {\n      __ fill_words(dest, cnt_words, value);\n    }\n\n    // Handle copies less than 8 bytes\n    __ bind(L_fill_elements);\n    Label L_fill_2, L_fill_1, L_exit;\n    __ test_bit(tmp_reg, count, 2);\n    __ beqz(tmp_reg, L_fill_2);\n    __ sb(value, Address(dest, 0));\n    __ sb(value, Address(dest, 1));\n    __ sb(value, Address(dest, 2));\n    __ sb(value, Address(dest, 3));\n    __ addi(dest, dest, 4);\n\n    __ bind(L_fill_2);\n    __ test_bit(tmp_reg, count, 1);\n    __ beqz(tmp_reg, L_fill_1);\n    __ sb(value, Address(dest, 0));\n    __ sb(value, Address(dest, 1));\n    __ addi(dest, dest, 2);\n\n    __ bind(L_fill_1);\n    __ test_bit(tmp_reg, count, 0);\n    __ beqz(tmp_reg, L_exit);\n    __ sb(value, Address(dest, 0));\n\n    __ bind(L_exit);\n    __ leave();\n    __ ret();\n\n    return start;\n  }", "target": "address generate_unsafe_setmemory() {\n    __ align(CodeEntryAlignment);\n    StubGenStubId stub_id = StubGenStubId::unsafe_setmemory_id;\n    StubCodeMark mark(this, stub_id);\n    address start = __ pc();\n\n    // bump this on entry, not on exit:\n    // inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n\n    Label L_fill_elements;\n\n    const Register dest = c_rarg0;\n    const Register count = c_rarg1;\n    const Register value = c_rarg2;\n    const Register cnt_words = x28; // temp register\n    const Register tmp_reg   = x29; // temp register\n\n    // Mark remaining code as such which performs Unsafe accesses.\n    UnsafeMemoryAccessMark umam(this, true, false);\n\n    __ enter(); // required for proper stackwalking of RuntimeStub frame\n\n    // if count < 8, jump to L_fill_elements\n    __ mv(tmp_reg, 8); // 8 bytes fill by element\n    __ bltu(count, tmp_reg, L_fill_elements);\n\n    // Propagate byte to 64-bit width\n    // 8 bit -> 16 bit\n    __ zext(value, value, 8);\n    __ slli(tmp_reg, value, 8);\n    __ orr(value, value, tmp_reg);\n    // 16 bit -> 32 bit\n    __ slli(tmp_reg, value, 16);\n    __ orr(value, value, tmp_reg);\n    // 32 bit -> 64 bit\n    __ slli(tmp_reg, value, 32);\n    __ orr(value, value, tmp_reg);\n\n    // Align source address at 8 bytes address boundary.\n    Label L_skip_align1, L_skip_align2, L_skip_align4;\n    // One byte misalignment happens.\n    __ test_bit(tmp_reg, dest, 0);\n    __ beqz(tmp_reg, L_skip_align1);\n    __ sb(value, Address(dest, 0));\n    __ addi(dest, dest, 1);\n    __ subi(count, count, 1);\n\n    __ bind(L_skip_align1);\n    // Two bytes misalignment happens.\n    __ test_bit(tmp_reg, dest, 1);\n    __ beqz(tmp_reg, L_skip_align2);\n    __ sh(value, Address(dest, 0));\n    __ addi(dest, dest, 2);\n    __ subi(count, count, 2);\n\n    __ bind(L_skip_align2);\n    // Four bytes misalignment happens.\n    __ test_bit(tmp_reg, dest, 2);\n    __ beqz(tmp_reg, L_skip_align4);\n    __ sw(value, Address(dest, 0));\n    __ addi(dest, dest, 4);\n    __ subi(count, count, 4);\n    __ bind(L_skip_align4);\n\n    //  Fill large chunks\n    __ srli(cnt_words, count, 3); // number of words\n    __ slli(tmp_reg, cnt_words, 3);\n    __ sub(count, count, tmp_reg);\n    {\n      __ fill_words(dest, cnt_words, value);\n    }\n\n    // Handle copies less than 8 bytes\n    __ bind(L_fill_elements);\n    Label L_fill_2, L_fill_1, L_exit;\n    __ test_bit(tmp_reg, count, 2);\n    __ beqz(tmp_reg, L_fill_2);\n    __ sb(value, Address(dest, 0));\n    __ sb(value, Address(dest, 1));\n    __ sb(value, Address(dest, 2));\n    __ sb(value, Address(dest, 3));\n    __ addi(dest, dest, 4);\n\n    __ bind(L_fill_2);\n    __ test_bit(tmp_reg, count, 1);\n    __ beqz(tmp_reg, L_fill_1);\n    __ sb(value, Address(dest, 0));\n    __ sb(value, Address(dest, 1));\n    __ addi(dest, dest, 2);\n\n    __ bind(L_fill_1);\n    __ test_bit(tmp_reg, count, 0);\n    __ beqz(tmp_reg, L_exit);\n    __ sb(value, Address(dest, 0));\n\n    __ bind(L_exit);\n    __ leave();\n    __ ret();\n\n    return start;\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Unsafe::setMemory 操作在 RISC-V 平台上没有专门的硬件指令支持，需要通过软件循环逐字节填充内存，效率较低。优化后：为 RISC-V 平台实现了 Unsafe::setMemory 的硬件指令集优化（intrinsify），通过生成专门的汇编代码来高效处理内存填充操作。优化思路：1) 使用位操作将单字节值扩展到64位宽度，2) 对目标地址进行8字节对齐处理，3) 对大于8字节的数据块使用批量填充指令（fill_words），4) 对剩余字节使用优化的逐字节/逐字填充策略。这显著提升了内存填充操作的性能，特别是对大块内存的操作。"}
{"id": 332, "source": "riscv-dataset-excel", "optimization_type": "并行GC性能优化", "optimization_description": "优化前：PartialArraySplitter构造函数使用固定的ParGCArrayScanChunk作为块大小，导致在并行GC（Parallel GC）中数组扫描时工作负载分配不均衡，造成JDK-8339668引入的性能退化（最多3.7倍减速）。优化后：修改PartialArraySplitter构造函数，增加chunk_size参数，允许G1 GC使用ParGCArrayScanChunk，并行GC使用ObjArrayMarkingStride作为块大小，使不同GC算法能根据自身特性调整数组扫描的并行粒度。优化思路：通过参数化块大小配置，解决通用块大小在不同GC算法中的性能不匹配问题，恢复并行GC的数组扫描性能。", "original_code": "PartialArraySplitter构造函数使用固定的ParGCArrayScanChunk作为块大小，导致在并行GC（Parallel GC）中数组扫描时工作负载分配不均衡，造成JDK-8339668引入的性能退化（最多3.7倍减速）。", "optimized_code": "- PartialArraySplitter(PartialArrayStateManager* manager, uint num_workers)\n+ PartialArraySplitter(PartialArrayStateManager* manager, uint num_workers, size_t chunk_size)\n- _stepper(num_workers, ParGCArrayScanChunk)\n+ _stepper(num_workers, chunk_size)\n- _partial_array_splitter(g1h->partial_array_state_manager(), num_workers)\n+ _partial_array_splitter(g1h->partial_array_state_manager(), num_workers, ParGCArrayScanChunk)\n- _partial_array_splitter(_partial_array_state_manager, parallel_gc_threads)\n+ _partial_array_splitter(_partial_array_state_manager, parallel_gc_threads, ObjArrayMarkingStride)\n- _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads)\n+ _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads, ParGCArrayScanChunk)", "source_url": "https://github.com/openjdk/riscv-port/commit/36f6d155e3b9d0b279be33414573217ea38551ac", "code_v0_no_empty_lines": "PartialArraySplitter构造函数使用固定的ParGCArrayScanChunk作为块大小，导致在并行GC（Parallel GC）中数组扫描时工作负载分配不均衡，造成JDK-8339668引入的性能退化（最多3.7倍减速）。", "code_v1_no_empty_lines": "- PartialArraySplitter(PartialArrayStateManager* manager, uint num_workers)\n+ PartialArraySplitter(PartialArrayStateManager* manager, uint num_workers, size_t chunk_size)\n- _stepper(num_workers, ParGCArrayScanChunk)\n+ _stepper(num_workers, chunk_size)\n- _partial_array_splitter(g1h->partial_array_state_manager(), num_workers)\n+ _partial_array_splitter(g1h->partial_array_state_manager(), num_workers, ParGCArrayScanChunk)\n- _partial_array_splitter(_partial_array_state_manager, parallel_gc_threads)\n+ _partial_array_splitter(_partial_array_state_manager, parallel_gc_threads, ObjArrayMarkingStride)\n- _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads)\n+ _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads, ParGCArrayScanChunk)", "target": "- PartialArraySplitter(PartialArrayStateManager* manager, uint num_workers)\n+ PartialArraySplitter(PartialArrayStateManager* manager, uint num_workers, size_t chunk_size)\n- _stepper(num_workers, ParGCArrayScanChunk)\n+ _stepper(num_workers, chunk_size)\n- _partial_array_splitter(g1h->partial_array_state_manager(), num_workers)\n+ _partial_array_splitter(g1h->partial_array_state_manager(), num_workers, ParGCArrayScanChunk)\n- _partial_array_splitter(_partial_array_state_manager, parallel_gc_threads)\n+ _partial_array_splitter(_partial_array_state_manager, parallel_gc_threads, ObjArrayMarkingStride)\n- _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads)\n+ _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads, ParGCArrayScanChunk)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PartialArraySplitter构造函数使用固定的ParGCArrayScanChunk作为块大小，导致在并行GC（Parallel GC）中数组扫描时工作负载分配不均衡，造成JDK-8339668引入的性能退化（最多3.7倍减速）。优化后：修改PartialArraySplitter构造函数，增加chunk_size参数，允许G1 GC使用ParGCArrayScanChunk，并行GC使用ObjArrayMarkingStride作为块大小，使不同GC算法能根据自身特性调整数组扫描的并行粒度。优化思路：通过参数化块大小配置，解决通用块大小在不同GC算法中的性能不匹配问题，恢复并行GC的数组扫描性能。"}
{"id": 333, "source": "riscv-dataset-excel", "optimization_type": "代码优化+性能优化", "optimization_description": "优化前：处理小于8字节的数组填充时，代码分为两个独立部分（L_exit1和L_fill_elements），使用循环处理剩余字节，导致分支跳转和循环开销。优化后：合并处理逻辑，直接根据count的位测试结果展开填充操作（如对T_BYTE类型直接使用多个sb指令填充4/2/1字节），消除了循环和冗余分支。优化思路：针对小尺寸数组填充，通过展开循环减少指令执行次数和分支预测开销，提升性能。", "original_code": "处理小于8字节的数组填充时，代码分为两个独立部分（L_exit1和L_fill_elements），使用循环处理剩余字节，导致分支跳转和循环开销。", "optimized_code": "@@ -2241,69 +2241,51 @@ class StubGenerator: public StubCodeGenerator {\n       __ fill_words(to, cnt_words, value);\n     }\n \n-    // Remaining count is less than 8 bytes and address is heapword aligned.\n-    Label L_fill_1, L_fill_2, L_exit1;\n+    // Handle copies less than 8 bytes.\n+    // Address may not be heapword aligned.\n+    Label L_fill_1, L_fill_2, L_exit;\n+    __ bind(L_fill_elements);\n     switch (t) {\n       case T_BYTE:\n-        __ test_bit(t0, count, 2);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 2);\n+        __ beqz(tmp_reg, L_fill_2);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n+        __ sb(value, Address(to, 2));\n+        __ sb(value, Address(to, 3));\n         __ addi(to, to, 4);\n+\n         __ bind(L_fill_2);\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_1);\n-        __ sh(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_1);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n         __ addi(to, to, 2);\n+\n         __ bind(L_fill_1);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n         __ sb(value, Address(to, 0));\n         break;\n       case T_SHORT:\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n-        __ addi(to, to, 4);\n-        __ bind(L_fill_2);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_2);\n         __ sh(value, Address(to, 0));\n-        break;\n-      case T_INT:\n-        __ beqz(count, L_exit1);\n-        __ sw(value, Address(to, 0));\n-        break;\n-      default: ShouldNotReachHere();\n-    }\n-    __ bind(L_exit1);\n-    __ leave();\n-    __ ret();\n+        __ sh(value, Address(to, 2));\n+        __ addi(to, to, 4);\n \n-    // Handle copies less than 8 bytes.\n-    Label L_loop1, L_loop2, L_exit2;\n-    __ bind(L_fill_elements);\n-    __ beqz(count, L_exit2);\n-    switch (t) {\n-      case T_BYTE:\n-        __ bind(L_loop1);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n-        __ subiw(count, count, 1);\n-        __ bnez(count, L_loop1);\n-        break;\n-      case T_SHORT:\n-        __ bind(L_loop2);\n+        __ bind(L_fill_2);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n         __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ subiw(count, count, 2 >> shift);\n-        __ bnez(count, L_loop2);\n         break;\n       case T_INT:\n+        __ beqz(count, L_exit);\n         __ sw(value, Address(to, 0));\n         break;\n       default: ShouldNotReachHere();\n     }\n-    __ bind(L_exit2);\n+    __ bind(L_exit);\n     __ leave();\n     __ ret();", "source_url": "https://github.com/openjdk/riscv-port/commit/78d0dc75029dba7b4ba388f9a7f5f7b22e4b838e", "code_v0_no_empty_lines": "处理小于8字节的数组填充时，代码分为两个独立部分（L_exit1和L_fill_elements），使用循环处理剩余字节，导致分支跳转和循环开销。", "code_v1_no_empty_lines": "@@ -2241,69 +2241,51 @@ class StubGenerator: public StubCodeGenerator {\n       __ fill_words(to, cnt_words, value);\n     }\n \n-    // Remaining count is less than 8 bytes and address is heapword aligned.\n-    Label L_fill_1, L_fill_2, L_exit1;\n+    // Handle copies less than 8 bytes.\n+    // Address may not be heapword aligned.\n+    Label L_fill_1, L_fill_2, L_exit;\n+    __ bind(L_fill_elements);\n     switch (t) {\n       case T_BYTE:\n-        __ test_bit(t0, count, 2);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 2);\n+        __ beqz(tmp_reg, L_fill_2);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n+        __ sb(value, Address(to, 2));\n+        __ sb(value, Address(to, 3));\n         __ addi(to, to, 4);\n+\n         __ bind(L_fill_2);\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_1);\n-        __ sh(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_1);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n         __ addi(to, to, 2);\n+\n         __ bind(L_fill_1);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n         __ sb(value, Address(to, 0));\n         break;\n       case T_SHORT:\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n-        __ addi(to, to, 4);\n-        __ bind(L_fill_2);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_2);\n         __ sh(value, Address(to, 0));\n-        break;\n-      case T_INT:\n-        __ beqz(count, L_exit1);\n-        __ sw(value, Address(to, 0));\n-        break;\n-      default: ShouldNotReachHere();\n-    }\n-    __ bind(L_exit1);\n-    __ leave();\n-    __ ret();\n+        __ sh(value, Address(to, 2));\n+        __ addi(to, to, 4);\n \n-    // Handle copies less than 8 bytes.\n-    Label L_loop1, L_loop2, L_exit2;\n-    __ bind(L_fill_elements);\n-    __ beqz(count, L_exit2);\n-    switch (t) {\n-      case T_BYTE:\n-        __ bind(L_loop1);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n-        __ subiw(count, count, 1);\n-        __ bnez(count, L_loop1);\n-        break;\n-      case T_SHORT:\n-        __ bind(L_loop2);\n+        __ bind(L_fill_2);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n         __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ subiw(count, count, 2 >> shift);\n-        __ bnez(count, L_loop2);\n         break;\n       case T_INT:\n+        __ beqz(count, L_exit);\n         __ sw(value, Address(to, 0));\n         break;\n       default: ShouldNotReachHere();\n     }\n-    __ bind(L_exit2);\n+    __ bind(L_exit);\n     __ leave();\n     __ ret();", "target": "@@ -2241,69 +2241,51 @@ class StubGenerator: public StubCodeGenerator {\n       __ fill_words(to, cnt_words, value);\n     }\n \n-    // Remaining count is less than 8 bytes and address is heapword aligned.\n-    Label L_fill_1, L_fill_2, L_exit1;\n+    // Handle copies less than 8 bytes.\n+    // Address may not be heapword aligned.\n+    Label L_fill_1, L_fill_2, L_exit;\n+    __ bind(L_fill_elements);\n     switch (t) {\n       case T_BYTE:\n-        __ test_bit(t0, count, 2);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 2);\n+        __ beqz(tmp_reg, L_fill_2);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n+        __ sb(value, Address(to, 2));\n+        __ sb(value, Address(to, 3));\n         __ addi(to, to, 4);\n+\n         __ bind(L_fill_2);\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_1);\n-        __ sh(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_1);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n         __ addi(to, to, 2);\n+\n         __ bind(L_fill_1);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n         __ sb(value, Address(to, 0));\n         break;\n       case T_SHORT:\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n-        __ addi(to, to, 4);\n-        __ bind(L_fill_2);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_2);\n         __ sh(value, Address(to, 0));\n-        break;\n-      case T_INT:\n-        __ beqz(count, L_exit1);\n-        __ sw(value, Address(to, 0));\n-        break;\n-      default: ShouldNotReachHere();\n-    }\n-    __ bind(L_exit1);\n-    __ leave();\n-    __ ret();\n+        __ sh(value, Address(to, 2));\n+        __ addi(to, to, 4);\n \n-    // Handle copies less than 8 bytes.\n-    Label L_loop1, L_loop2, L_exit2;\n-    __ bind(L_fill_elements);\n-    __ beqz(count, L_exit2);\n-    switch (t) {\n-      case T_BYTE:\n-        __ bind(L_loop1);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n-        __ subiw(count, count, 1);\n-        __ bnez(count, L_loop1);\n-        break;\n-      case T_SHORT:\n-        __ bind(L_loop2);\n+        __ bind(L_fill_2);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n         __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ subiw(count, count, 2 >> shift);\n-        __ bnez(count, L_loop2);\n         break;\n       case T_INT:\n+        __ beqz(count, L_exit);\n         __ sw(value, Address(to, 0));\n         break;\n       default: ShouldNotReachHere();\n     }\n-    __ bind(L_exit2);\n+    __ bind(L_exit);\n     __ leave();\n     __ ret();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：处理小于8字节的数组填充时，代码分为两个独立部分（L_exit1和L_fill_elements），使用循环处理剩余字节，导致分支跳转和循环开销。优化后：合并处理逻辑，直接根据count的位测试结果展开填充操作（如对T_BYTE类型直接使用多个sb指令填充4/2/1字节），消除了循环和冗余分支。优化思路：针对小尺寸数组填充，通过展开循环减少指令执行次数和分支预测开销，提升性能。"}
{"id": 334, "source": "riscv-dataset-excel", "optimization_type": "功能状态优化", "optimization_description": "优化前：Shenandoah GC的Generational模式被标记为实验性功能，需要通过特殊标志启用。优化后：将Generational模式从实验性状态升级为生产就绪状态，用户可以直接使用该模式而无需额外实验性标志。优化思路：根据JEP 521的实现进展，Generational Shenandoah已经达到稳定状态，可以正式提供给用户使用，这减少了用户配置复杂度并提高了功能可用性。", "original_code": "Shenandoah GC的Generational模式被标记为实验性功能，需要通过特殊标志启用。", "optimized_code": "-  virtual bool is_experimental() { return true; }\n+  virtual bool is_experimental() { return false; }\n-        testWith(\"-XX:ShenandoahGCMode=generational\", Mode.EXPERIMENTAL);\n+        testWith(\"-XX:ShenandoahGCMode=generational\", Mode.PRODUCT);", "source_url": "https://github.com/openjdk/riscv-port/commit/2e8b195a96e3b2a4ca27c64a923adc4334073128", "code_v0_no_empty_lines": "Shenandoah GC的Generational模式被标记为实验性功能，需要通过特殊标志启用。", "code_v1_no_empty_lines": "-  virtual bool is_experimental() { return true; }\n+  virtual bool is_experimental() { return false; }\n-        testWith(\"-XX:ShenandoahGCMode=generational\", Mode.EXPERIMENTAL);\n+        testWith(\"-XX:ShenandoahGCMode=generational\", Mode.PRODUCT);", "target": "-  virtual bool is_experimental() { return true; }\n+  virtual bool is_experimental() { return false; }\n-        testWith(\"-XX:ShenandoahGCMode=generational\", Mode.EXPERIMENTAL);\n+        testWith(\"-XX:ShenandoahGCMode=generational\", Mode.PRODUCT);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Shenandoah GC的Generational模式被标记为实验性功能，需要通过特殊标志启用。优化后：将Generational模式从实验性状态升级为生产就绪状态，用户可以直接使用该模式而无需额外实验性标志。优化思路：根据JEP 521的实现进展，Generational Shenandoah已经达到稳定状态，可以正式提供给用户使用，这减少了用户配置复杂度并提高了功能可用性。"}
{"id": 335, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+性能优化", "optimization_description": "优化前：ZGC只支持单一的中等页面大小（ZPageSizeMedium），内存分配灵活性受限，可能导致内存碎片或浪费。优化后：引入多个中等页面大小（ZPageSizeMediumMin到ZPageSizeMediumMax），通过ZPageSizeMediumEnabled控制启用，并添加fast_medium标志优化分配路径。优化思路：增强内存分配灵活性，允许根据对象大小选择更合适的中等页面，减少内存碎片，提高内存利用率，同时通过标志位优化分配性能。", "original_code": "ZGC只支持单一的中等页面大小（ZPageSizeMedium），内存分配灵活性受限，可能导致内存碎片或浪费。", "optimized_code": "- extern size_t     ZPageSizeMediumShift;\n- extern size_t     ZPageSizeMedium;\n+ extern int        ZPageSizeMediumMaxShift;\n+ extern size_t     ZPageSizeMediumMax;\n+ extern size_t     ZPageSizeMediumMin;\n+ extern bool       ZPageSizeMediumEnabled;\n\n- const size_t      ZPageSizeMediumShift;\n+ const int         ZPageSizeSmallShift           = (int)ZGranuleSizeShift;\n+ extern int        ZPageSizeMediumMaxShift;\n\n- const size_t      ZPageSizeMedium;\n+ extern size_t     ZPageSizeMediumMax;\n+ extern size_t     ZPageSizeMediumMin;\n+ extern bool       ZPageSizeMediumEnabled;", "source_url": "https://github.com/openjdk/riscv-port/commit/f74fbfe5de9dc5b90652956935642670c085938c", "code_v0_no_empty_lines": "ZGC只支持单一的中等页面大小（ZPageSizeMedium），内存分配灵活性受限，可能导致内存碎片或浪费。", "code_v1_no_empty_lines": "- extern size_t     ZPageSizeMediumShift;\n- extern size_t     ZPageSizeMedium;\n+ extern int        ZPageSizeMediumMaxShift;\n+ extern size_t     ZPageSizeMediumMax;\n+ extern size_t     ZPageSizeMediumMin;\n+ extern bool       ZPageSizeMediumEnabled;\n\n- const size_t      ZPageSizeMediumShift;\n+ const int         ZPageSizeSmallShift           = (int)ZGranuleSizeShift;\n+ extern int        ZPageSizeMediumMaxShift;\n\n- const size_t      ZPageSizeMedium;\n+ extern size_t     ZPageSizeMediumMax;\n+ extern size_t     ZPageSizeMediumMin;\n+ extern bool       ZPageSizeMediumEnabled;", "target": "- extern size_t     ZPageSizeMediumShift;\n- extern size_t     ZPageSizeMedium;\n+ extern int        ZPageSizeMediumMaxShift;\n+ extern size_t     ZPageSizeMediumMax;\n+ extern size_t     ZPageSizeMediumMin;\n+ extern bool       ZPageSizeMediumEnabled;\n\n- const size_t      ZPageSizeMediumShift;\n+ const int         ZPageSizeSmallShift           = (int)ZGranuleSizeShift;\n+ extern int        ZPageSizeMediumMaxShift;\n\n- const size_t      ZPageSizeMedium;\n+ extern size_t     ZPageSizeMediumMax;\n+ extern size_t     ZPageSizeMediumMin;\n+ extern bool       ZPageSizeMediumEnabled;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ZGC只支持单一的中等页面大小（ZPageSizeMedium），内存分配灵活性受限，可能导致内存碎片或浪费。优化后：引入多个中等页面大小（ZPageSizeMediumMin到ZPageSizeMediumMax），通过ZPageSizeMediumEnabled控制启用，并添加fast_medium标志优化分配路径。优化思路：增强内存分配灵活性，允许根据对象大小选择更合适的中等页面，减少内存碎片，提高内存利用率，同时通过标志位优化分配性能。"}
{"id": 336, "source": "riscv-dataset-excel", "optimization_type": "内联优化", "optimization_description": "优化前：PSOldGen::initialize_performance_counters函数接受perf_data_name和level两个参数，这些参数在调用时总是传递固定值（\"old\"和1）。优化后：将这两个参数内联到函数内部作为常量，简化了函数签名和调用接口。优化思路：通过内联常量参数，减少了函数调用时的参数传递开销，简化了代码结构，同时保持了原有功能不变。", "original_code": "PSOldGen::initialize_performance_counters函数接受perf_data_name和level两个参数，这些参数在调用时总是传递固定值（\"old\"和1）。", "optimized_code": "-void PSOldGen::initialize_performance_counters(const char* perf_data_name, int level) {\n-  // Generation Counters, generation 'level', 1 subspace\n-  _gen_counters = new GenerationCounters(perf_data_name, level, 1, min_gen_size(),\n+void PSOldGen::initialize_performance_counters() {\n+  const char* perf_data_name = \"old\";\n+  _gen_counters = new GenerationCounters(perf_data_name, 1, 1, min_gen_size(),", "source_url": "https://github.com/openjdk/riscv-port/commit/1e0caedb9ab1c56e3986764ce260b94e423d4948", "code_v0_no_empty_lines": "PSOldGen::initialize_performance_counters函数接受perf_data_name和level两个参数，这些参数在调用时总是传递固定值（\"old\"和1）。", "code_v1_no_empty_lines": "-void PSOldGen::initialize_performance_counters(const char* perf_data_name, int level) {\n-  // Generation Counters, generation 'level', 1 subspace\n-  _gen_counters = new GenerationCounters(perf_data_name, level, 1, min_gen_size(),\n+void PSOldGen::initialize_performance_counters() {\n+  const char* perf_data_name = \"old\";\n+  _gen_counters = new GenerationCounters(perf_data_name, 1, 1, min_gen_size(),", "target": "-void PSOldGen::initialize_performance_counters(const char* perf_data_name, int level) {\n-  // Generation Counters, generation 'level', 1 subspace\n-  _gen_counters = new GenerationCounters(perf_data_name, level, 1, min_gen_size(),\n+void PSOldGen::initialize_performance_counters() {\n+  const char* perf_data_name = \"old\";\n+  _gen_counters = new GenerationCounters(perf_data_name, 1, 1, min_gen_size(),", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PSOldGen::initialize_performance_counters函数接受perf_data_name和level两个参数，这些参数在调用时总是传递固定值（\"old\"和1）。优化后：将这两个参数内联到函数内部作为常量，简化了函数签名和调用接口。优化思路：通过内联常量参数，减少了函数调用时的参数传递开销，简化了代码结构，同时保持了原有功能不变。"}
{"id": 337, "source": "riscv-dataset-excel", "optimization_type": "API稳定性优化+空值处理优化", "optimization_description": "优化前：ScopedValue.orElse()方法允许传入null参数，当未绑定时返回null，这可能导致空指针异常传播到调用链中。优化后：在orElse()方法开头添加Objects.requireNonNull(other)检查，强制要求传入非空参数，提高API的健壮性和可预测性。同时移除了所有PreviewFeature注解和相关测试标记，将Scoped Values从预览特性升级为正式API（从Java 21预览版升级为Java 25正式版）。", "original_code": "ScopedValue.orElse()方法允许传入null参数，当未绑定时返回null，这可能导致空指针异常传播到调用链中。", "optimized_code": "-    public T orElse(T other) {\n+    public T orElse(T other) {\n+        Objects.requireNonNull(other);", "source_url": "https://github.com/openjdk/riscv-port/commit/4e1878ca452d1e781eb61610a94064c0c4798073", "code_v0_no_empty_lines": "ScopedValue.orElse()方法允许传入null参数，当未绑定时返回null，这可能导致空指针异常传播到调用链中。", "code_v1_no_empty_lines": "-    public T orElse(T other) {\n+    public T orElse(T other) {\n+        Objects.requireNonNull(other);", "target": "-    public T orElse(T other) {\n+    public T orElse(T other) {\n+        Objects.requireNonNull(other);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ScopedValue.orElse()方法允许传入null参数，当未绑定时返回null，这可能导致空指针异常传播到调用链中。优化后：在orElse()方法开头添加Objects.requireNonNull(other)检查，强制要求传入非空参数，提高API的健壮性和可预测性。同时移除了所有PreviewFeature注解和相关测试标记，将Scoped Values从预览特性升级为正式API（从Java 21预览版升级为Java 25正式版）。"}
{"id": 338, "source": "riscv-dataset-excel", "optimization_type": "指令优化+内存布局优化", "optimization_description": "优化前：当压缩类指针基地址（narrow klass base）大于32位时，使用64位立即数加载指令（mov64），导致指令长度增加（10字节）和潜在性能开销。优化后：通过优先在4G以下地址空间分配类元数据，确保基地址能用32位表示，从而使用32位立即数加载指令（movptr），指令长度缩短至7字节。优化思路：修改地址空间分配策略，优先尝试4G以下分配；在汇编代码中将64位立即数加载改为32位加载，减少指令大小，提高代码密度和缓存效率。", "original_code": "当压缩类指针基地址（narrow klass base）大于32位时，使用64位立即数加载指令（mov64），导致指令长度增加（10字节）和潜在性能开销。", "optimized_code": "- mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+ movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n- mov64(dst, -(int64_t)CompressedKlassPointers::base());\n+ movptr(dst, -(intptr_t)CompressedKlassPointers::base());\n- mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+ movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n- mov64(dst, (int64_t)CompressedKlassPointers::base());\n+ movptr(dst, (intptr_t)CompressedKlassPointers::base());\n- const uint64_t base_right_shifted = (uint64_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n+ const intptr_t base_right_shifted = (intptr_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n- mov64(dst, base_right_shifted);\n+ movptr(dst, base_right_shifted);", "source_url": "https://github.com/openjdk/riscv-port/commit/4cf729cfac57c9aec692a52c1f3f95f2403e7958", "code_v0_no_empty_lines": "当压缩类指针基地址（narrow klass base）大于32位时，使用64位立即数加载指令（mov64），导致指令长度增加（10字节）和潜在性能开销。", "code_v1_no_empty_lines": "- mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+ movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n- mov64(dst, -(int64_t)CompressedKlassPointers::base());\n+ movptr(dst, -(intptr_t)CompressedKlassPointers::base());\n- mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+ movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n- mov64(dst, (int64_t)CompressedKlassPointers::base());\n+ movptr(dst, (intptr_t)CompressedKlassPointers::base());\n- const uint64_t base_right_shifted = (uint64_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n+ const intptr_t base_right_shifted = (intptr_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n- mov64(dst, base_right_shifted);\n+ movptr(dst, base_right_shifted);", "target": "- mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+ movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n- mov64(dst, -(int64_t)CompressedKlassPointers::base());\n+ movptr(dst, -(intptr_t)CompressedKlassPointers::base());\n- mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+ movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n- mov64(dst, (int64_t)CompressedKlassPointers::base());\n+ movptr(dst, (intptr_t)CompressedKlassPointers::base());\n- const uint64_t base_right_shifted = (uint64_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n+ const intptr_t base_right_shifted = (intptr_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n- mov64(dst, base_right_shifted);\n+ movptr(dst, base_right_shifted);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当压缩类指针基地址（narrow klass base）大于32位时，使用64位立即数加载指令（mov64），导致指令长度增加（10字节）和潜在性能开销。优化后：通过优先在4G以下地址空间分配类元数据，确保基地址能用32位表示，从而使用32位立即数加载指令（movptr），指令长度缩短至7字节。优化思路：修改地址空间分配策略，优先尝试4G以下分配；在汇编代码中将64位立即数加载改为32位加载，减少指令大小，提高代码密度和缓存效率。"}
{"id": 339, "source": "riscv-dataset-excel", "optimization_type": "指令优化+寄存器重用优化", "optimization_description": "优化前：每次需要ConstMethod*时都从xmethod重新加载（Method::const_offset()），导致重复的内存访问指令。优化后：在函数入口处一次性加载ConstMethod*到x15寄存器，后续所有使用都直接复用该寄存器值。同时将ConstantPool*加载到x28寄存器复用，避免重复计算地址链。优化思路：通过寄存器重用减少内存访问指令数量，降低指令缓存压力，提升模板解释器方法入口的执行效率。", "original_code": "每次需要ConstMethod*时都从xmethod重新加载（Method::const_offset()），导致重复的内存访问指令。", "optimized_code": "+  // Save ConstMethod* in x15_const_method for later use to avoid loading multiple times\n+  Register x15_const_method = x15;\n+  __ ld(x15_const_method, Address(xmethod, Method::const_offset()));\n-    __ ld(t0, Address(xmethod, Method::const_offset()));     // get ConstMethod\n-    __ add(xbcp, t0, in_bytes(ConstMethod::codes_offset())); // get codebase\n+    __ add(xbcp, x15_const_method, in_bytes(ConstMethod::codes_offset())); // get codebase\n-  __ ld(xcpool, Address(xmethod, Method::const_offset()));\n-  __ ld(xcpool, Address(xcpool, ConstMethod::constants_offset()));\n-  __ ld(xcpool, Address(xcpool, ConstantPool::cache_offset()));\n+  // Save ConstantPool* in x28_constants for later use to avoid loading multiple times\n+  Register x28_constants = x28;\n+  __ ld(x28_constants, Address(x15_const_method, ConstMethod::constants_offset()));\n+  __ ld(xcpool, Address(x28_constants, ConstantPool::cache_offset()));\n-  __ load_mirror(t2, xmethod, x15, t1);\n+  // Get mirror, Resolve ConstantPool* -> InstanceKlass* -> Java mirror\n+  __ ld(t2, Address(x28_constants, ConstantPool::pool_holder_offset()));\n+  __ ld(t2, Address(t2, in_bytes(Klass::java_mirror_offset())));\n+  __ resolve_oop_handle(t2, t0, t1);\n-    __ ld(t0, Address(xmethod, Method::const_offset()));\n-    __ lhu(t0, Address(t0, ConstMethod::max_stack_offset()));\n+    __ lhu(t0, Address(x15_const_method, ConstMethod::max_stack_offset()));", "source_url": "https://github.com/openjdk/riscv-port/commit/acd64ba24afd508689803adaa6714a784946979c", "code_v0_no_empty_lines": "每次需要ConstMethod*时都从xmethod重新加载（Method::const_offset()），导致重复的内存访问指令。", "code_v1_no_empty_lines": "+  // Save ConstMethod* in x15_const_method for later use to avoid loading multiple times\n+  Register x15_const_method = x15;\n+  __ ld(x15_const_method, Address(xmethod, Method::const_offset()));\n-    __ ld(t0, Address(xmethod, Method::const_offset()));     // get ConstMethod\n-    __ add(xbcp, t0, in_bytes(ConstMethod::codes_offset())); // get codebase\n+    __ add(xbcp, x15_const_method, in_bytes(ConstMethod::codes_offset())); // get codebase\n-  __ ld(xcpool, Address(xmethod, Method::const_offset()));\n-  __ ld(xcpool, Address(xcpool, ConstMethod::constants_offset()));\n-  __ ld(xcpool, Address(xcpool, ConstantPool::cache_offset()));\n+  // Save ConstantPool* in x28_constants for later use to avoid loading multiple times\n+  Register x28_constants = x28;\n+  __ ld(x28_constants, Address(x15_const_method, ConstMethod::constants_offset()));\n+  __ ld(xcpool, Address(x28_constants, ConstantPool::cache_offset()));\n-  __ load_mirror(t2, xmethod, x15, t1);\n+  // Get mirror, Resolve ConstantPool* -> InstanceKlass* -> Java mirror\n+  __ ld(t2, Address(x28_constants, ConstantPool::pool_holder_offset()));\n+  __ ld(t2, Address(t2, in_bytes(Klass::java_mirror_offset())));\n+  __ resolve_oop_handle(t2, t0, t1);\n-    __ ld(t0, Address(xmethod, Method::const_offset()));\n-    __ lhu(t0, Address(t0, ConstMethod::max_stack_offset()));\n+    __ lhu(t0, Address(x15_const_method, ConstMethod::max_stack_offset()));", "target": "+  // Save ConstMethod* in x15_const_method for later use to avoid loading multiple times\n+  Register x15_const_method = x15;\n+  __ ld(x15_const_method, Address(xmethod, Method::const_offset()));\n-    __ ld(t0, Address(xmethod, Method::const_offset()));     // get ConstMethod\n-    __ add(xbcp, t0, in_bytes(ConstMethod::codes_offset())); // get codebase\n+    __ add(xbcp, x15_const_method, in_bytes(ConstMethod::codes_offset())); // get codebase\n-  __ ld(xcpool, Address(xmethod, Method::const_offset()));\n-  __ ld(xcpool, Address(xcpool, ConstMethod::constants_offset()));\n-  __ ld(xcpool, Address(xcpool, ConstantPool::cache_offset()));\n+  // Save ConstantPool* in x28_constants for later use to avoid loading multiple times\n+  Register x28_constants = x28;\n+  __ ld(x28_constants, Address(x15_const_method, ConstMethod::constants_offset()));\n+  __ ld(xcpool, Address(x28_constants, ConstantPool::cache_offset()));\n-  __ load_mirror(t2, xmethod, x15, t1);\n+  // Get mirror, Resolve ConstantPool* -> InstanceKlass* -> Java mirror\n+  __ ld(t2, Address(x28_constants, ConstantPool::pool_holder_offset()));\n+  __ ld(t2, Address(t2, in_bytes(Klass::java_mirror_offset())));\n+  __ resolve_oop_handle(t2, t0, t1);\n-    __ ld(t0, Address(xmethod, Method::const_offset()));\n-    __ lhu(t0, Address(t0, ConstMethod::max_stack_offset()));\n+    __ lhu(t0, Address(x15_const_method, ConstMethod::max_stack_offset()));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次需要ConstMethod*时都从xmethod重新加载（Method::const_offset()），导致重复的内存访问指令。优化后：在函数入口处一次性加载ConstMethod*到x15寄存器，后续所有使用都直接复用该寄存器值。同时将ConstantPool*加载到x28寄存器复用，避免重复计算地址链。优化思路：通过寄存器重用减少内存访问指令数量，降低指令缓存压力，提升模板解释器方法入口的执行效率。"}
{"id": 340, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+内存操作优化", "optimization_description": "优化前：Unsafe::setMemory 在 s390x 架构上使用通用循环实现，效率较低。优化后：新增 generate_unsafe_setmemory 函数，利用 s390x 向量指令（如 z_vst、z_vrepb）实现内存填充，通过向量化处理 32 字节块提升性能，并针对剩余字节使用位测试（testbit）进行精细化处理。优化思路：通过硬件指令集优化，将内存操作从标量循环升级为向量化批量处理，显著提升内存填充速度。", "original_code": "Unsafe::setMemory 在 s390x 架构上使用通用循环实现，效率较低。", "optimized_code": "address generate_unsafe_setmemory(address unsafe_byte_fill) {\n    __ align(CodeEntryAlignment);\n    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n    unsigned int start_off = __ offset();\n\n    // bump this on entry, not on exit:\n    // inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n\n    const Register dest = Z_ARG1;\n    const Register size = Z_ARG2;\n    const Register byteVal = Z_ARG3;\n    NearLabel tail, finished;\n    // fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n\n    // Mark remaining code as such which performs Unsafe accesses.\n    UnsafeMemoryAccessMark umam(this, true, false);\n\n    __ z_vlvgb(Z_V0, byteVal, 0);\n    __ z_vrepb(Z_V0, Z_V0, 0);\n\n    __ z_aghi(size, -32);\n    __ z_brl(tail);\n\n    {\n      NearLabel again;\n      __ bind(again);\n      __ z_vst(Z_V0, Address(dest, 0));\n      __ z_vst(Z_V0, Address(dest, 16));\n      __ z_aghi(dest, 32);\n      __ z_aghi(size, -32);\n      __ z_brnl(again);\n    }\n\n    __ bind(tail);\n\n    {\n      NearLabel dont;\n      __ testbit(size, 4);\n      __ z_brz(dont);\n      __ z_vst(Z_V0, Address(dest, 0));\n      __ z_aghi(dest, 16);\n      __ bind(dont);\n    }\n\n    {\n      NearLabel dont;\n      __ testbit(size, 3);\n      __ z_brz(dont);\n      __ z_vsteg(Z_V0, 0, Z_R0, dest, 0);\n      __ z_aghi(dest, 8);\n      __ bind(dont);\n    }\n\n    __ z_tmll(size, 7);\n    __ z_brc(Assembler::bcondAllZero, finished);\n\n    {\n      NearLabel dont;\n      __ testbit(size, 2);\n      __ z_brz(dont);\n      __ z_vstef(Z_V0, 0, Z_R0, dest, 0);\n      __ z_aghi(dest, 4);\n      __ bind(dont);\n    }\n\n    {\n      NearLabel dont;\n      __ testbit(size, 1);\n      __ z_brz(dont);\n      __ z_vsteh(Z_V0, 0, Z_R0, dest, 0);\n      __ z_aghi(dest, 2);\n      __ bind(dont);\n    }\n\n    {\n      NearLabel dont;\n      __ testbit(size, 0);\n      __ z_brz(dont);\n      __ z_vsteb(Z_V0, 0, Z_R0, dest, 0);\n      __ bind(dont);\n    }\n\n    __ bind(finished);\n    __ z_br(Z_R14);\n\n    return __ addr_at(start_off);\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/20005511e3612d6a5f12fa83066f02c88c628e8b", "code_v0_no_empty_lines": "Unsafe::setMemory 在 s390x 架构上使用通用循环实现，效率较低。", "code_v1_no_empty_lines": "address generate_unsafe_setmemory(address unsafe_byte_fill) {\n    __ align(CodeEntryAlignment);\n    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n    unsigned int start_off = __ offset();\n\n    // bump this on entry, not on exit:\n    // inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n\n    const Register dest = Z_ARG1;\n    const Register size = Z_ARG2;\n    const Register byteVal = Z_ARG3;\n    NearLabel tail, finished;\n    // fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n\n    // Mark remaining code as such which performs Unsafe accesses.\n    UnsafeMemoryAccessMark umam(this, true, false);\n\n    __ z_vlvgb(Z_V0, byteVal, 0);\n    __ z_vrepb(Z_V0, Z_V0, 0);\n\n    __ z_aghi(size, -32);\n    __ z_brl(tail);\n\n    {\n      NearLabel again;\n      __ bind(again);\n      __ z_vst(Z_V0, Address(dest, 0));\n      __ z_vst(Z_V0, Address(dest, 16));\n      __ z_aghi(dest, 32);\n      __ z_aghi(size, -32);\n      __ z_brnl(again);\n    }\n\n    __ bind(tail);\n\n    {\n      NearLabel dont;\n      __ testbit(size, 4);\n      __ z_brz(dont);\n      __ z_vst(Z_V0, Address(dest, 0));\n      __ z_aghi(dest, 16);\n      __ bind(dont);\n    }\n\n    {\n      NearLabel dont;\n      __ testbit(size, 3);\n      __ z_brz(dont);\n      __ z_vsteg(Z_V0, 0, Z_R0, dest, 0);\n      __ z_aghi(dest, 8);\n      __ bind(dont);\n    }\n\n    __ z_tmll(size, 7);\n    __ z_brc(Assembler::bcondAllZero, finished);\n\n    {\n      NearLabel dont;\n      __ testbit(size, 2);\n      __ z_brz(dont);\n      __ z_vstef(Z_V0, 0, Z_R0, dest, 0);\n      __ z_aghi(dest, 4);\n      __ bind(dont);\n    }\n\n    {\n      NearLabel dont;\n      __ testbit(size, 1);\n      __ z_brz(dont);\n      __ z_vsteh(Z_V0, 0, Z_R0, dest, 0);\n      __ z_aghi(dest, 2);\n      __ bind(dont);\n    }\n\n    {\n      NearLabel dont;\n      __ testbit(size, 0);\n      __ z_brz(dont);\n      __ z_vsteb(Z_V0, 0, Z_R0, dest, 0);\n      __ bind(dont);\n    }\n\n    __ bind(finished);\n    __ z_br(Z_R14);\n\n    return __ addr_at(start_off);\n  }", "target": "address generate_unsafe_setmemory(address unsafe_byte_fill) {\n    __ align(CodeEntryAlignment);\n    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n    unsigned int start_off = __ offset();\n\n    // bump this on entry, not on exit:\n    // inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n\n    const Register dest = Z_ARG1;\n    const Register size = Z_ARG2;\n    const Register byteVal = Z_ARG3;\n    NearLabel tail, finished;\n    // fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n\n    // Mark remaining code as such which performs Unsafe accesses.\n    UnsafeMemoryAccessMark umam(this, true, false);\n\n    __ z_vlvgb(Z_V0, byteVal, 0);\n    __ z_vrepb(Z_V0, Z_V0, 0);\n\n    __ z_aghi(size, -32);\n    __ z_brl(tail);\n\n    {\n      NearLabel again;\n      __ bind(again);\n      __ z_vst(Z_V0, Address(dest, 0));\n      __ z_vst(Z_V0, Address(dest, 16));\n      __ z_aghi(dest, 32);\n      __ z_aghi(size, -32);\n      __ z_brnl(again);\n    }\n\n    __ bind(tail);\n\n    {\n      NearLabel dont;\n      __ testbit(size, 4);\n      __ z_brz(dont);\n      __ z_vst(Z_V0, Address(dest, 0));\n      __ z_aghi(dest, 16);\n      __ bind(dont);\n    }\n\n    {\n      NearLabel dont;\n      __ testbit(size, 3);\n      __ z_brz(dont);\n      __ z_vsteg(Z_V0, 0, Z_R0, dest, 0);\n      __ z_aghi(dest, 8);\n      __ bind(dont);\n    }\n\n    __ z_tmll(size, 7);\n    __ z_brc(Assembler::bcondAllZero, finished);\n\n    {\n      NearLabel dont;\n      __ testbit(size, 2);\n      __ z_brz(dont);\n      __ z_vstef(Z_V0, 0, Z_R0, dest, 0);\n      __ z_aghi(dest, 4);\n      __ bind(dont);\n    }\n\n    {\n      NearLabel dont;\n      __ testbit(size, 1);\n      __ z_brz(dont);\n      __ z_vsteh(Z_V0, 0, Z_R0, dest, 0);\n      __ z_aghi(dest, 2);\n      __ bind(dont);\n    }\n\n    {\n      NearLabel dont;\n      __ testbit(size, 0);\n      __ z_brz(dont);\n      __ z_vsteb(Z_V0, 0, Z_R0, dest, 0);\n      __ bind(dont);\n    }\n\n    __ bind(finished);\n    __ z_br(Z_R14);\n\n    return __ addr_at(start_off);\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Unsafe::setMemory 在 s390x 架构上使用通用循环实现，效率较低。优化后：新增 generate_unsafe_setmemory 函数，利用 s390x 向量指令（如 z_vst、z_vrepb）实现内存填充，通过向量化处理 32 字节块提升性能，并针对剩余字节使用位测试（testbit）进行精细化处理。优化思路：通过硬件指令集优化，将内存操作从标量循环升级为向量化批量处理，显著提升内存填充速度。"}
{"id": 341, "source": "riscv-dataset-excel", "optimization_type": "启动性能优化+代码简化", "optimization_description": "优化前：多个枚举项使用匿名内部类覆盖registerNames()方法返回false，避免注册别名。优化后：新增构造函数参数registerNames，直接传递布尔值控制别名注册。思路：消除嵌套类（匿名内部类）的创建开销，减少类加载和初始化时间，提升Java应用启动速度，同时简化代码结构。", "original_code": "多个枚举项使用匿名内部类覆盖registerNames()方法返回false，避免注册别名。", "optimized_code": "-    KP_TimeStamping(\"1.3.6.1.5.5.7.3.8\", \"timeStamping\") {\n-        @Override\n-        boolean registerNames() { return false; }\n-    },\n+    KP_TimeStamping(\"1.3.6.1.5.5.7.3.8\", \"timeStamping\", false),", "source_url": "https://github.com/openjdk/riscv-port/commit/d922e318bc2104d69c46403bceb609d538f3259a", "code_v0_no_empty_lines": "多个枚举项使用匿名内部类覆盖registerNames()方法返回false，避免注册别名。", "code_v1_no_empty_lines": "-    KP_TimeStamping(\"1.3.6.1.5.5.7.3.8\", \"timeStamping\") {\n-        @Override\n-        boolean registerNames() { return false; }\n-    },\n+    KP_TimeStamping(\"1.3.6.1.5.5.7.3.8\", \"timeStamping\", false),", "target": "-    KP_TimeStamping(\"1.3.6.1.5.5.7.3.8\", \"timeStamping\") {\n-        @Override\n-        boolean registerNames() { return false; }\n-    },\n+    KP_TimeStamping(\"1.3.6.1.5.5.7.3.8\", \"timeStamping\", false),", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多个枚举项使用匿名内部类覆盖registerNames()方法返回false，避免注册别名。优化后：新增构造函数参数registerNames，直接传递布尔值控制别名注册。思路：消除嵌套类（匿名内部类）的创建开销，减少类加载和初始化时间，提升Java应用启动速度，同时简化代码结构。"}
{"id": 342, "source": "riscv-dataset-excel", "optimization_type": "数学函数优化+指令集优化", "optimization_description": "优化前：Math.cbrt函数在x86 64位平台上使用通用软件实现，性能较低。优化后：为x86 64位平台添加了专门的立方根计算指令（如movapd、orpd等）和汇编实现，通过创建新的stubGenerator_x86_64_cbrt.cpp文件提供硬件加速的立方根计算。优化思路是利用x86平台的SIMD指令集特性，为立方根计算提供专门的硬件加速路径，减少函数调用开销并提高计算性能。", "original_code": "Math.cbrt函数在x86 64位平台上使用通用软件实现，性能较低。", "optimized_code": "case vmIntrinsics::_dcbrt:\n      assert(StubRoutines::dcbrt() != nullptr, \"cbrt intrinsic not found\");\n      if (StubRoutines::dcbrt() != nullptr) {\n        __ call_runtime_leaf(StubRoutines::dcbrt(), getThreadTemp(), result_reg, cc->args());\n      }\n      break;", "source_url": "https://github.com/openjdk/riscv-port/commit/0df8c9684b8782ef830e2bd425217864c3f51784", "code_v0_no_empty_lines": "Math.cbrt函数在x86 64位平台上使用通用软件实现，性能较低。", "code_v1_no_empty_lines": "case vmIntrinsics::_dcbrt:\n      assert(StubRoutines::dcbrt() != nullptr, \"cbrt intrinsic not found\");\n      if (StubRoutines::dcbrt() != nullptr) {\n        __ call_runtime_leaf(StubRoutines::dcbrt(), getThreadTemp(), result_reg, cc->args());\n      }\n      break;", "target": "case vmIntrinsics::_dcbrt:\n      assert(StubRoutines::dcbrt() != nullptr, \"cbrt intrinsic not found\");\n      if (StubRoutines::dcbrt() != nullptr) {\n        __ call_runtime_leaf(StubRoutines::dcbrt(), getThreadTemp(), result_reg, cc->args());\n      }\n      break;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Math.cbrt函数在x86 64位平台上使用通用软件实现，性能较低。优化后：为x86 64位平台添加了专门的立方根计算指令（如movapd、orpd等）和汇编实现，通过创建新的stubGenerator_x86_64_cbrt.cpp文件提供硬件加速的立方根计算。优化思路是利用x86平台的SIMD指令集特性，为立方根计算提供专门的硬件加速路径，减少函数调用开销并提高计算性能。"}
{"id": 343, "source": "riscv-dataset-excel", "optimization_type": "代码精简/维护优化", "optimization_description": "优化前：VM_Version::determine_features()函数包含大量旧指令检测代码（如fsqrt、isel、vcipher等），用于检测PPC64 CPU特性。优化后：移除了17个旧指令的检测，仅保留darn和brw两个指令的检测。优化思路：这些被移除的指令在现代PPC64处理器上已成为标准支持，无需运行时检测，删除冗余代码可减少二进制大小、简化维护，并略微提升启动时的CPU特性检测速度。", "original_code": "VM_Version::determine_features()函数包含大量旧指令检测代码（如fsqrt、isel、vcipher等），用于检测PPC64 CPU特性。", "optimized_code": "- a->fsqrt(F3, F4);                            // code[0]  -> fsqrt_m\n- a->fsqrts(F3, F4);                           // code[1]  -> fsqrts_m\n- a->isel(R7, R5, R6, 0);                      // code[2]  -> isel_m\n- a->ldarx_unchecked(R7, R3_ARG1, R4_ARG2, 1); // code[3]  -> lxarx_m\n- a->cmpb(R7, R5, R6);                         // code[4]  -> cmpb\n- a->popcntb(R7, R5);                          // code[5]  -> popcntb\n- a->popcntw(R7, R5);                          // code[6]  -> popcntw\n- a->fcfids(F3, F4);                           // code[7]  -> fcfids\n- a->vand(VR0, VR0, VR0);                      // code[8]  -> vand\n- a->lqarx_unchecked(R6, R3_ARG1, R4_ARG2, 1); // code[9]  -> lqarx_m\n- a->vcipher(VR0, VR1, VR2);                   // code[10] -> vcipher\n- a->vpmsumb(VR0, VR1, VR2);                   // code[11] -> vpmsumb\n- a->mfdscr(R0);                               // code[12] -> mfdscr\n- a->lxvd2x(VSR0, R3_ARG1);                    // code[13] -> vsx\n- a->ldbrx(R7, R3_ARG1, R4_ARG2);              // code[14] -> ldbrx\n- a->stdbrx(R7, R3_ARG1, R4_ARG2);             // code[15] -> stdbrx\n- a->vshasigmaw(VR0, VR1, 1, 0xF);             // code[16] -> vshasig\n+ a->darn(R7);\n+ a->brw(R5, R6);", "source_url": "https://github.com/openjdk/riscv-port/commit/612f2c0c0b75466c60d4b54dab6aa793a810c846", "code_v0_no_empty_lines": "VM_Version::determine_features()函数包含大量旧指令检测代码（如fsqrt、isel、vcipher等），用于检测PPC64 CPU特性。", "code_v1_no_empty_lines": "- a->fsqrt(F3, F4);                            // code[0]  -> fsqrt_m\n- a->fsqrts(F3, F4);                           // code[1]  -> fsqrts_m\n- a->isel(R7, R5, R6, 0);                      // code[2]  -> isel_m\n- a->ldarx_unchecked(R7, R3_ARG1, R4_ARG2, 1); // code[3]  -> lxarx_m\n- a->cmpb(R7, R5, R6);                         // code[4]  -> cmpb\n- a->popcntb(R7, R5);                          // code[5]  -> popcntb\n- a->popcntw(R7, R5);                          // code[6]  -> popcntw\n- a->fcfids(F3, F4);                           // code[7]  -> fcfids\n- a->vand(VR0, VR0, VR0);                      // code[8]  -> vand\n- a->lqarx_unchecked(R6, R3_ARG1, R4_ARG2, 1); // code[9]  -> lqarx_m\n- a->vcipher(VR0, VR1, VR2);                   // code[10] -> vcipher\n- a->vpmsumb(VR0, VR1, VR2);                   // code[11] -> vpmsumb\n- a->mfdscr(R0);                               // code[12] -> mfdscr\n- a->lxvd2x(VSR0, R3_ARG1);                    // code[13] -> vsx\n- a->ldbrx(R7, R3_ARG1, R4_ARG2);              // code[14] -> ldbrx\n- a->stdbrx(R7, R3_ARG1, R4_ARG2);             // code[15] -> stdbrx\n- a->vshasigmaw(VR0, VR1, 1, 0xF);             // code[16] -> vshasig\n+ a->darn(R7);\n+ a->brw(R5, R6);", "target": "- a->fsqrt(F3, F4);                            // code[0]  -> fsqrt_m\n- a->fsqrts(F3, F4);                           // code[1]  -> fsqrts_m\n- a->isel(R7, R5, R6, 0);                      // code[2]  -> isel_m\n- a->ldarx_unchecked(R7, R3_ARG1, R4_ARG2, 1); // code[3]  -> lxarx_m\n- a->cmpb(R7, R5, R6);                         // code[4]  -> cmpb\n- a->popcntb(R7, R5);                          // code[5]  -> popcntb\n- a->popcntw(R7, R5);                          // code[6]  -> popcntw\n- a->fcfids(F3, F4);                           // code[7]  -> fcfids\n- a->vand(VR0, VR0, VR0);                      // code[8]  -> vand\n- a->lqarx_unchecked(R6, R3_ARG1, R4_ARG2, 1); // code[9]  -> lqarx_m\n- a->vcipher(VR0, VR1, VR2);                   // code[10] -> vcipher\n- a->vpmsumb(VR0, VR1, VR2);                   // code[11] -> vpmsumb\n- a->mfdscr(R0);                               // code[12] -> mfdscr\n- a->lxvd2x(VSR0, R3_ARG1);                    // code[13] -> vsx\n- a->ldbrx(R7, R3_ARG1, R4_ARG2);              // code[14] -> ldbrx\n- a->stdbrx(R7, R3_ARG1, R4_ARG2);             // code[15] -> stdbrx\n- a->vshasigmaw(VR0, VR1, 1, 0xF);             // code[16] -> vshasig\n+ a->darn(R7);\n+ a->brw(R5, R6);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：VM_Version::determine_features()函数包含大量旧指令检测代码（如fsqrt、isel、vcipher等），用于检测PPC64 CPU特性。优化后：移除了17个旧指令的检测，仅保留darn和brw两个指令的检测。优化思路：这些被移除的指令在现代PPC64处理器上已成为标准支持，无需运行时检测，删除冗余代码可减少二进制大小、简化维护，并略微提升启动时的CPU特性检测速度。"}
{"id": 344, "source": "riscv-dataset-excel", "optimization_type": "代码清理/无用代码移除", "optimization_description": "优化前：JFR（Java Flight Recorder）模块中保留了未使用的数组分配相关代码，包括JfrJavaArguments类中的array_length成员变量和相关方法，以及JfrJavaSupport中的new_string_array函数和array_construction辅助函数。这些代码增加了二进制大小和维护复杂度。优化后：完全移除了这些未使用的数组分配代码，包括成员变量声明、方法实现和相关的静态函数。优化思路：通过代码审查发现这些数组分配功能从未被使用，属于dead code，移除它们可以简化代码库，减少二进制大小，提高代码可读性和维护性，同时消除潜在的维护负担。", "original_code": "JFR（Java Flight Recorder）模块中保留了未使用的数组分配相关代码，包括JfrJavaArguments类中的array_length成员变量和相关方法，以及JfrJavaSupport中的new_string_array函数和array_construction辅助函数。这些代码增加了二进制大小和维护复杂度。", "optimized_code": "-  int array_length() const;\n-  void set_array_length(int length);\n-  int _array_length;\n-  static jobjectArray new_string_array(int length, TRAPS);\n-  static void array_construction(JfrJavaArguments* args, JavaValue* result, InstanceKlass* klass, int array_length, TRAPS);", "source_url": "https://github.com/openjdk/riscv-port/commit/c22af0c29ea89857c5cf57dd127b5c739130b2f1", "code_v0_no_empty_lines": "JFR（Java Flight Recorder）模块中保留了未使用的数组分配相关代码，包括JfrJavaArguments类中的array_length成员变量和相关方法，以及JfrJavaSupport中的new_string_array函数和array_construction辅助函数。这些代码增加了二进制大小和维护复杂度。", "code_v1_no_empty_lines": "-  int array_length() const;\n-  void set_array_length(int length);\n-  int _array_length;\n-  static jobjectArray new_string_array(int length, TRAPS);\n-  static void array_construction(JfrJavaArguments* args, JavaValue* result, InstanceKlass* klass, int array_length, TRAPS);", "target": "-  int array_length() const;\n-  void set_array_length(int length);\n-  int _array_length;\n-  static jobjectArray new_string_array(int length, TRAPS);\n-  static void array_construction(JfrJavaArguments* args, JavaValue* result, InstanceKlass* klass, int array_length, TRAPS);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：JFR（Java Flight Recorder）模块中保留了未使用的数组分配相关代码，包括JfrJavaArguments类中的array_length成员变量和相关方法，以及JfrJavaSupport中的new_string_array函数和array_construction辅助函数。这些代码增加了二进制大小和维护复杂度。优化后：完全移除了这些未使用的数组分配代码，包括成员变量声明、方法实现和相关的静态函数。优化思路：通过代码审查发现这些数组分配功能从未被使用，属于dead code，移除它们可以简化代码库，减少二进制大小，提高代码可读性和维护性，同时消除潜在的维护负担。"}
{"id": 345, "source": "riscv-dataset-excel", "optimization_type": "内存优化+同步优化", "optimization_description": "优化前：每个CompileTask对象都拥有自己的Monitor锁（_lock），用于同步等待编译完成，导致大量Monitor对象创建和内存开销。优化后：引入全局共享的CompileTaskWait_lock，所有CompileTask共享同一个锁进行等待/通知操作。优化思路：将每个任务独立的锁替换为全局共享锁，减少Monitor对象创建数量，降低内存占用和同步开销，同时保持正确的同步语义。", "original_code": "每个CompileTask对象都拥有自己的Monitor锁（_lock），用于同步等待编译完成，导致大量Monitor对象创建和内存开销。", "optimized_code": "- MutexLocker notifier(thread, task->lock());\n+ MutexLocker notifier(thread, CompileTaskWait_lock);\n- task->lock()->notify_all();\n+ CompileTaskWait_lock->notify_all();\n- Monitor*             _lock;\n- _lock = new Monitor(Mutex::safepoint-1, \"CompileTask_lock\");\n+ Monitor* CompileTaskWait_lock         = nullptr;\n+ MUTEX_DEFL(CompileTaskWait_lock           , PaddedMonitor, MethodCompileQueue_lock);", "source_url": "https://github.com/openjdk/riscv-port/commit/b3594c9e5508101a39d10099830f04b0c09ad41f", "code_v0_no_empty_lines": "每个CompileTask对象都拥有自己的Monitor锁（_lock），用于同步等待编译完成，导致大量Monitor对象创建和内存开销。", "code_v1_no_empty_lines": "- MutexLocker notifier(thread, task->lock());\n+ MutexLocker notifier(thread, CompileTaskWait_lock);\n- task->lock()->notify_all();\n+ CompileTaskWait_lock->notify_all();\n- Monitor*             _lock;\n- _lock = new Monitor(Mutex::safepoint-1, \"CompileTask_lock\");\n+ Monitor* CompileTaskWait_lock         = nullptr;\n+ MUTEX_DEFL(CompileTaskWait_lock           , PaddedMonitor, MethodCompileQueue_lock);", "target": "- MutexLocker notifier(thread, task->lock());\n+ MutexLocker notifier(thread, CompileTaskWait_lock);\n- task->lock()->notify_all();\n+ CompileTaskWait_lock->notify_all();\n- Monitor*             _lock;\n- _lock = new Monitor(Mutex::safepoint-1, \"CompileTask_lock\");\n+ Monitor* CompileTaskWait_lock         = nullptr;\n+ MUTEX_DEFL(CompileTaskWait_lock           , PaddedMonitor, MethodCompileQueue_lock);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每个CompileTask对象都拥有自己的Monitor锁（_lock），用于同步等待编译完成，导致大量Monitor对象创建和内存开销。优化后：引入全局共享的CompileTaskWait_lock，所有CompileTask共享同一个锁进行等待/通知操作。优化思路：将每个任务独立的锁替换为全局共享锁，减少Monitor对象创建数量，降低内存占用和同步开销，同时保持正确的同步语义。"}
{"id": 346, "source": "riscv-dataset-excel", "optimization_type": "性能优化+内存优化", "optimization_description": "优化前：每次调用Pem.decode()方法时，都会通过input.replaceAll(\"\\\\s+\", \"\")创建新的Pattern对象来去除空白字符，导致重复编译正则表达式，增加性能开销。优化后：将空白字符匹配的Pattern编译为静态常量STRIP_WHITESPACE_PATTERN，在类初始化时一次性编译，后续decode()方法直接复用该Pattern对象。同时将原有的pbePattern重命名为PBE_PATTERN以符合命名规范。优化思路：通过缓存频繁使用的Pattern对象，避免重复编译正则表达式，减少方法调用时的开销，提升性能并降低内存分配。", "original_code": "每次调用Pem.decode()方法时，都会通过input.replaceAll(\"\\\\s+\", \"\")创建新的Pattern对象来去除空白字符，导致重复编译正则表达式，增加性能开销。", "optimized_code": "-        pbePattern = Pattern.compile(\"^PBEWith.*And.*\",\n+        PBE_PATTERN = Pattern.compile(\"^PBEWith.*And.*\",\n             Pattern.CASE_INSENSITIVE);\n+        STRIP_WHITESPACE_PATTERN = Pattern.compile(\"\\\\s+\");\n...\n-        byte[] src = input.replaceAll(\"\\\\s+\", \"\").\n+        byte[] src = STRIP_WHITESPACE_PATTERN.matcher(input).replaceAll(\"\").\n             getBytes(StandardCharsets.ISO_8859_1);", "source_url": "https://github.com/openjdk/riscv-port/commit/6f783e5fab0e98da6c41e3c22d4523733f060d68", "code_v0_no_empty_lines": "每次调用Pem.decode()方法时，都会通过input.replaceAll(\"\\\\s+\", \"\")创建新的Pattern对象来去除空白字符，导致重复编译正则表达式，增加性能开销。", "code_v1_no_empty_lines": "-        pbePattern = Pattern.compile(\"^PBEWith.*And.*\",\n+        PBE_PATTERN = Pattern.compile(\"^PBEWith.*And.*\",\n             Pattern.CASE_INSENSITIVE);\n+        STRIP_WHITESPACE_PATTERN = Pattern.compile(\"\\\\s+\");\n...\n-        byte[] src = input.replaceAll(\"\\\\s+\", \"\").\n+        byte[] src = STRIP_WHITESPACE_PATTERN.matcher(input).replaceAll(\"\").\n             getBytes(StandardCharsets.ISO_8859_1);", "target": "-        pbePattern = Pattern.compile(\"^PBEWith.*And.*\",\n+        PBE_PATTERN = Pattern.compile(\"^PBEWith.*And.*\",\n             Pattern.CASE_INSENSITIVE);\n+        STRIP_WHITESPACE_PATTERN = Pattern.compile(\"\\\\s+\");\n...\n-        byte[] src = input.replaceAll(\"\\\\s+\", \"\").\n+        byte[] src = STRIP_WHITESPACE_PATTERN.matcher(input).replaceAll(\"\").\n             getBytes(StandardCharsets.ISO_8859_1);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次调用Pem.decode()方法时，都会通过input.replaceAll(\"\\\\s+\", \"\")创建新的Pattern对象来去除空白字符，导致重复编译正则表达式，增加性能开销。优化后：将空白字符匹配的Pattern编译为静态常量STRIP_WHITESPACE_PATTERN，在类初始化时一次性编译，后续decode()方法直接复用该Pattern对象。同时将原有的pbePattern重命名为PBE_PATTERN以符合命名规范。优化思路：通过缓存频繁使用的Pattern对象，避免重复编译正则表达式，减少方法调用时的开销，提升性能并降低内存分配。"}
{"id": 347, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前：G1垃圾收集器对运行时IN_NATIVE原子操作（如CAS和交换操作）未应用SATB（Snapshot-At-The-Beginning）屏障，可能导致并发扫描时遗漏非堆引用，影响垃圾回收的正确性和性能。优化后：新增了两个原子操作函数（oop_atomic_cmpxchg_not_in_heap和oop_atomic_xchg_not_in_heap），在非堆引用上应用SATB屏障，确保并发扫描能正确跟踪这些引用。优化思路：通过添加内存屏障来保证垃圾收集器在并发扫描期间能正确处理非堆内存中的原子操作，避免潜在的数据不一致和性能问题，提升G1垃圾收集器的可靠性和效率。", "original_code": "G1垃圾收集器对运行时IN_NATIVE原子操作（如CAS和交换操作）未应用SATB（Snapshot-At-The-Beginning）屏障，可能导致并发扫描时遗漏非堆引用，影响垃圾回收的正确性和性能。", "optimized_code": "template <typename T>\nstatic oop oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value);\ntemplate <typename T>\nstatic oop oop_atomic_xchg_not_in_heap(T* addr, oop new_value);\n\n...\n\ntemplate <DecoratorSet decorators, typename BarrierSetT>\ntemplate <typename T>\ninline oop G1BarrierSet::AccessBarrier<decorators, BarrierSetT>::\noop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value) {\n  // Apply SATB barriers for all non-heap references, to allow\n  // concurrent scanning of such references.\n  G1BarrierSet *bs = barrier_set_cast<G1BarrierSet>(BarrierSet::barrier_set());\n  bs->write_ref_field_pre<decorators>(addr);\n  return Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);\n}\n\ntemplate <DecoratorSet decorators, typename BarrierSetT>\ntemplate <typename T>\ninline oop G1BarrierSet::AccessBarrier<decorators, BarrierSetT>::\noop_atomic_xchg_not_in_heap(T* addr, oop new_value) {\n  // Apply SATB barriers for all non-heap references, to allow\n  // concurrent scanning of such references.\n  G1BarrierSet *bs = barrier_set_cast<G1BarrierSet>(BarrierSet::barrier_set());\n  bs->write_ref_field_pre<decorators>(addr);\n  return Raw::oop_atomic_xchg(addr, new_value);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/d3f54dae30e377b9fb4aaa06bc123b71de444a74", "code_v0_no_empty_lines": "G1垃圾收集器对运行时IN_NATIVE原子操作（如CAS和交换操作）未应用SATB（Snapshot-At-The-Beginning）屏障，可能导致并发扫描时遗漏非堆引用，影响垃圾回收的正确性和性能。", "code_v1_no_empty_lines": "template <typename T>\nstatic oop oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value);\ntemplate <typename T>\nstatic oop oop_atomic_xchg_not_in_heap(T* addr, oop new_value);\n\n...\n\ntemplate <DecoratorSet decorators, typename BarrierSetT>\ntemplate <typename T>\ninline oop G1BarrierSet::AccessBarrier<decorators, BarrierSetT>::\noop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value) {\n  // Apply SATB barriers for all non-heap references, to allow\n  // concurrent scanning of such references.\n  G1BarrierSet *bs = barrier_set_cast<G1BarrierSet>(BarrierSet::barrier_set());\n  bs->write_ref_field_pre<decorators>(addr);\n  return Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);\n}\n\ntemplate <DecoratorSet decorators, typename BarrierSetT>\ntemplate <typename T>\ninline oop G1BarrierSet::AccessBarrier<decorators, BarrierSetT>::\noop_atomic_xchg_not_in_heap(T* addr, oop new_value) {\n  // Apply SATB barriers for all non-heap references, to allow\n  // concurrent scanning of such references.\n  G1BarrierSet *bs = barrier_set_cast<G1BarrierSet>(BarrierSet::barrier_set());\n  bs->write_ref_field_pre<decorators>(addr);\n  return Raw::oop_atomic_xchg(addr, new_value);\n}", "target": "template <typename T>\nstatic oop oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value);\ntemplate <typename T>\nstatic oop oop_atomic_xchg_not_in_heap(T* addr, oop new_value);\n\n...\n\ntemplate <DecoratorSet decorators, typename BarrierSetT>\ntemplate <typename T>\ninline oop G1BarrierSet::AccessBarrier<decorators, BarrierSetT>::\noop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value) {\n  // Apply SATB barriers for all non-heap references, to allow\n  // concurrent scanning of such references.\n  G1BarrierSet *bs = barrier_set_cast<G1BarrierSet>(BarrierSet::barrier_set());\n  bs->write_ref_field_pre<decorators>(addr);\n  return Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);\n}\n\ntemplate <DecoratorSet decorators, typename BarrierSetT>\ntemplate <typename T>\ninline oop G1BarrierSet::AccessBarrier<decorators, BarrierSetT>::\noop_atomic_xchg_not_in_heap(T* addr, oop new_value) {\n  // Apply SATB barriers for all non-heap references, to allow\n  // concurrent scanning of such references.\n  G1BarrierSet *bs = barrier_set_cast<G1BarrierSet>(BarrierSet::barrier_set());\n  bs->write_ref_field_pre<decorators>(addr);\n  return Raw::oop_atomic_xchg(addr, new_value);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：G1垃圾收集器对运行时IN_NATIVE原子操作（如CAS和交换操作）未应用SATB（Snapshot-At-The-Beginning）屏障，可能导致并发扫描时遗漏非堆引用，影响垃圾回收的正确性和性能。优化后：新增了两个原子操作函数（oop_atomic_cmpxchg_not_in_heap和oop_atomic_xchg_not_in_heap），在非堆引用上应用SATB屏障，确保并发扫描能正确跟踪这些引用。优化思路：通过添加内存屏障来保证垃圾收集器在并发扫描期间能正确处理非堆内存中的原子操作，避免潜在的数据不一致和性能问题，提升G1垃圾收集器的可靠性和效率。"}
{"id": 348, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+自旋锁优化", "optimization_description": "优化前：在ZLiveMap::reset的spin-loop中，多个线程可能同时竞争重置标记信息，失败线程会持续自旋检查，造成CPU资源浪费和性能下降。优化后：引入SpinYield机制，在自旋等待时调用yielder.wait()主动让出CPU，减少不必要的CPU占用，同时通过条件判断优化了代码结构，将seqnum检查与cmpxchg操作分离，提高代码可读性。优化思路：通过退避策略减少线程竞争时的CPU空转开销，提升系统整体并发性能。", "original_code": "在ZLiveMap::reset的spin-loop中，多个线程可能同时竞争重置标记信息，失败线程会持续自旋检查，造成CPU资源浪费和性能下降。", "optimized_code": "+  SpinYield yielder(0, 0, 1000);\n+    // \"Yield\" to allow the thread that's resetting the livemap to finish\n+    yielder.wait();", "source_url": "https://github.com/openjdk/riscv-port/commit/78a392aa3b0cda52cfacfa15250fa61010519424", "code_v0_no_empty_lines": "在ZLiveMap::reset的spin-loop中，多个线程可能同时竞争重置标记信息，失败线程会持续自旋检查，造成CPU资源浪费和性能下降。", "code_v1_no_empty_lines": "+  SpinYield yielder(0, 0, 1000);\n+    // \"Yield\" to allow the thread that's resetting the livemap to finish\n+    yielder.wait();", "target": "+  SpinYield yielder(0, 0, 1000);\n+    // \"Yield\" to allow the thread that's resetting the livemap to finish\n+    yielder.wait();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在ZLiveMap::reset的spin-loop中，多个线程可能同时竞争重置标记信息，失败线程会持续自旋检查，造成CPU资源浪费和性能下降。优化后：引入SpinYield机制，在自旋等待时调用yielder.wait()主动让出CPU，减少不必要的CPU占用，同时通过条件判断优化了代码结构，将seqnum检查与cmpxchg操作分离，提高代码可读性。优化思路：通过退避策略减少线程竞争时的CPU空转开销，提升系统整体并发性能。"}
{"id": 349, "source": "riscv-dataset-excel", "optimization_type": "指令编码优化", "optimization_description": "优化前：psllq指令的InstructionAttr构造函数中rex_w参数固定为true，强制使用VEX3前缀编码。优化后：根据CPU是否支持EVEX指令集动态设置rex_w参数（支持EVEX时设为true，否则为false），并调用set_rex_vex_w_reverted()方法。优化思路：在支持EVEX的CPU上保持原有VEX3编码，在不支持EVEX的CPU上改用更短的VEX2前缀编码，减少指令长度，提升代码密度和执行效率。", "original_code": "psllq指令的InstructionAttr构造函数中rex_w参数固定为true，强制使用VEX3前缀编码。", "optimized_code": "-  InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_rex_vex_w_reverted();", "source_url": "https://github.com/openjdk/riscv-port/commit/faf19abd312ac461f9f74035fec61af7d834ffc1", "code_v0_no_empty_lines": "psllq指令的InstructionAttr构造函数中rex_w参数固定为true，强制使用VEX3前缀编码。", "code_v1_no_empty_lines": "-  InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_rex_vex_w_reverted();", "target": "-  InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_rex_vex_w_reverted();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：psllq指令的InstructionAttr构造函数中rex_w参数固定为true，强制使用VEX3前缀编码。优化后：根据CPU是否支持EVEX指令集动态设置rex_w参数（支持EVEX时设为true，否则为false），并调用set_rex_vex_w_reverted()方法。优化思路：在支持EVEX的CPU上保持原有VEX3编码，在不支持EVEX的CPU上改用更短的VEX2前缀编码，减少指令长度，提升代码密度和执行效率。"}
{"id": 350, "source": "riscv-dataset-excel", "optimization_type": "代码简化+性能优化", "optimization_description": "优化前：increment_mdp_data_at函数包含复杂的条件分支逻辑，支持递增和递减操作，需要处理计数器溢出/下溢情况，代码量较大（约50行）。优化后：移除了decrement参数和相关的条件分支逻辑，统一使用increment()函数处理递增操作，简化了代码结构（减少到约10行）。优化思路：通过移除不常用的递减功能（decrement参数）和简化计数器更新逻辑，减少代码复杂度和执行路径，提高解释器性能分析代码的执行效率，同时保持核心递增功能不变。", "original_code": "increment_mdp_data_at函数包含复杂的条件分支逻辑，支持递增和递减操作，需要处理计数器溢出/下溢情况，代码量较大（约50行）。", "optimized_code": "-void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n-                                                      Register reg,\n-                                                      int constant,\n-                                                      bool decrement) {\n+void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n+                                                      Register index,\n+                                                      int constant) {\n   assert(ProfileInterpreter, \"must be profiling interpreter\");\n-  // %%% this does 64bit counters at best it is wasting space\n-  // at worst it is a rare bug when counters overflow\n \n-  assert_different_registers(rscratch2, rscratch1, mdp_in, reg);\n+  assert_different_registers(rscratch2, rscratch1, mdp_in, index);\n \n   Address addr1(mdp_in, constant);\n-  Address addr2(rscratch2, reg, Address::lsl(0));\n+  Address addr2(rscratch2, index, Address::lsl(0));\n   Address &addr = addr1;\n-  if (reg != noreg) {\n+  if (index != noreg) {\n     lea(rscratch2, addr1);\n     addr = addr2;\n   }\n \n-  if (decrement) {\n-    // Decrement the register.  Set condition codes.\n-    // Intel does this\n-    // addptr(data, (int32_t) -DataLayout::counter_increment);\n-    // If the decrement causes the counter to overflow, stay negative\n-    // Label L;\n-    // jcc(Assembler::negative, L);\n-    // addptr(data, (int32_t) DataLayout::counter_increment);\n-    // so we do this\n-    ldr(rscratch1, addr);\n-    subs(rscratch1, rscratch1, (unsigned)DataLayout::counter_increment);\n-    Label L;\n-    br(Assembler::LO, L);       // skip store if counter underflow\n-    str(rscratch1, addr);\n-    bind(L);\n-  } else {\n-    assert(DataLayout::counter_increment == 1,\n-           \"flow-free idiom only works with 1\");\n-    // Intel does this\n-    // Increment the register.  Set carry flag.\n-    // addptr(data, DataLayout::counter_increment);\n-    // If the increment causes the counter to overflow, pull back by 1.\n-    // sbbptr(data, (int32_t)0);\n-    // so we do this\n-    ldr(rscratch1, addr);\n-    adds(rscratch1, rscratch1, DataLayout::counter_increment);\n-    Label L;\n-    br(Assembler::CS, L);       // skip store if counter overflow\n-    str(rscratch1, addr);\n-    bind(L);\n-  }\n+  increment(addr, DataLayout::counter_increment);\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/4402527683ed08eebf4953a9d83f72f64a5ff4fa", "code_v0_no_empty_lines": "increment_mdp_data_at函数包含复杂的条件分支逻辑，支持递增和递减操作，需要处理计数器溢出/下溢情况，代码量较大（约50行）。", "code_v1_no_empty_lines": "-void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n-                                                      Register reg,\n-                                                      int constant,\n-                                                      bool decrement) {\n+void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n+                                                      Register index,\n+                                                      int constant) {\n   assert(ProfileInterpreter, \"must be profiling interpreter\");\n-  // %%% this does 64bit counters at best it is wasting space\n-  // at worst it is a rare bug when counters overflow\n \n-  assert_different_registers(rscratch2, rscratch1, mdp_in, reg);\n+  assert_different_registers(rscratch2, rscratch1, mdp_in, index);\n \n   Address addr1(mdp_in, constant);\n-  Address addr2(rscratch2, reg, Address::lsl(0));\n+  Address addr2(rscratch2, index, Address::lsl(0));\n   Address &addr = addr1;\n-  if (reg != noreg) {\n+  if (index != noreg) {\n     lea(rscratch2, addr1);\n     addr = addr2;\n   }\n \n-  if (decrement) {\n-    // Decrement the register.  Set condition codes.\n-    // Intel does this\n-    // addptr(data, (int32_t) -DataLayout::counter_increment);\n-    // If the decrement causes the counter to overflow, stay negative\n-    // Label L;\n-    // jcc(Assembler::negative, L);\n-    // addptr(data, (int32_t) DataLayout::counter_increment);\n-    // so we do this\n-    ldr(rscratch1, addr);\n-    subs(rscratch1, rscratch1, (unsigned)DataLayout::counter_increment);\n-    Label L;\n-    br(Assembler::LO, L);       // skip store if counter underflow\n-    str(rscratch1, addr);\n-    bind(L);\n-  } else {\n-    assert(DataLayout::counter_increment == 1,\n-           \"flow-free idiom only works with 1\");\n-    // Intel does this\n-    // Increment the register.  Set carry flag.\n-    // addptr(data, DataLayout::counter_increment);\n-    // If the increment causes the counter to overflow, pull back by 1.\n-    // sbbptr(data, (int32_t)0);\n-    // so we do this\n-    ldr(rscratch1, addr);\n-    adds(rscratch1, rscratch1, DataLayout::counter_increment);\n-    Label L;\n-    br(Assembler::CS, L);       // skip store if counter overflow\n-    str(rscratch1, addr);\n-    bind(L);\n-  }\n+  increment(addr, DataLayout::counter_increment);\n }", "target": "-void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n-                                                      Register reg,\n-                                                      int constant,\n-                                                      bool decrement) {\n+void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n+                                                      Register index,\n+                                                      int constant) {\n   assert(ProfileInterpreter, \"must be profiling interpreter\");\n-  // %%% this does 64bit counters at best it is wasting space\n-  // at worst it is a rare bug when counters overflow\n \n-  assert_different_registers(rscratch2, rscratch1, mdp_in, reg);\n+  assert_different_registers(rscratch2, rscratch1, mdp_in, index);\n \n   Address addr1(mdp_in, constant);\n-  Address addr2(rscratch2, reg, Address::lsl(0));\n+  Address addr2(rscratch2, index, Address::lsl(0));\n   Address &addr = addr1;\n-  if (reg != noreg) {\n+  if (index != noreg) {\n     lea(rscratch2, addr1);\n     addr = addr2;\n   }\n \n-  if (decrement) {\n-    // Decrement the register.  Set condition codes.\n-    // Intel does this\n-    // addptr(data, (int32_t) -DataLayout::counter_increment);\n-    // If the decrement causes the counter to overflow, stay negative\n-    // Label L;\n-    // jcc(Assembler::negative, L);\n-    // addptr(data, (int32_t) DataLayout::counter_increment);\n-    // so we do this\n-    ldr(rscratch1, addr);\n-    subs(rscratch1, rscratch1, (unsigned)DataLayout::counter_increment);\n-    Label L;\n-    br(Assembler::LO, L);       // skip store if counter underflow\n-    str(rscratch1, addr);\n-    bind(L);\n-  } else {\n-    assert(DataLayout::counter_increment == 1,\n-           \"flow-free idiom only works with 1\");\n-    // Intel does this\n-    // Increment the register.  Set carry flag.\n-    // addptr(data, DataLayout::counter_increment);\n-    // If the increment causes the counter to overflow, pull back by 1.\n-    // sbbptr(data, (int32_t)0);\n-    // so we do this\n-    ldr(rscratch1, addr);\n-    adds(rscratch1, rscratch1, DataLayout::counter_increment);\n-    Label L;\n-    br(Assembler::CS, L);       // skip store if counter overflow\n-    str(rscratch1, addr);\n-    bind(L);\n-  }\n+  increment(addr, DataLayout::counter_increment);\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：increment_mdp_data_at函数包含复杂的条件分支逻辑，支持递增和递减操作，需要处理计数器溢出/下溢情况，代码量较大（约50行）。优化后：移除了decrement参数和相关的条件分支逻辑，统一使用increment()函数处理递增操作，简化了代码结构（减少到约10行）。优化思路：通过移除不常用的递减功能（decrement参数）和简化计数器更新逻辑，减少代码复杂度和执行路径，提高解释器性能分析代码的执行效率，同时保持核心递增功能不变。"}
{"id": 351, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+平台特定优化", "optimization_description": "优化前：SuperwordUseVSX标志默认启用（true），导致在Power8及以下平台上使用VSX指令进行超字优化时性能不佳。优化后：将SuperwordUseVSX默认值改为false，但针对Power9及以上架构自动启用（true）。优化思路：识别Power8的VSX指令性能问题，通过平台检测动态启用优化，避免在低性能硬件上使用VSX指令，同时保持Power9及以上的向量化性能优势。", "original_code": "SuperwordUseVSX标志默认启用（true），导致在Power8及以下平台上使用VSX指令进行超字优化时性能不佳。", "optimized_code": "--- a/src/hotspot/cpu/ppc/globals_ppc.hpp\n+++ b/src/hotspot/cpu/ppc/globals_ppc.hpp\n@@ -115,8 +115,8 @@ define_pd_global(intx, InitArrayShortSize, 9*BytesPerLong);\n           \"Use static branch prediction hints for uncommon paths.\")         \\\n                                                                             \\\n   /* special instructions */                                                \\\n-  product(bool, SuperwordUseVSX, true,                                      \\\n-          \"Use Power8 VSX instructions for superword optimization.\")        \\\n+  product(bool, SuperwordUseVSX, false,                                     \\\n+          \"Use VSX instructions for superword optimization.\")               \\\n                                                                             \\\n   product(bool, UseByteReverseInstructions, false, DIAGNOSTIC,              \\\n           \"Use byte reverse instructions.\")                                 \\\n--- a/src/hotspot/cpu/ppc/vm_version_ppc.cpp\n+++ b/src/hotspot/cpu/ppc/vm_version_ppc.cpp\n@@ -95,6 +95,13 @@ void VM_Version::initialize() {\n     FLAG_SET_ERGO(TrapBasedRangeChecks, false);\n   }\n \n+  if (PowerArchitecturePPC64 >= 9) {\n+    // Performance is good since Power9.\n+    if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {\n+      FLAG_SET_ERGO(SuperwordUseVSX, true);\n+    }\n+  }\n+", "source_url": "https://github.com/openjdk/riscv-port/commit/457d9de81d0f65455e3292fafea03f0e83184029", "code_v0_no_empty_lines": "SuperwordUseVSX标志默认启用（true），导致在Power8及以下平台上使用VSX指令进行超字优化时性能不佳。", "code_v1_no_empty_lines": "--- a/src/hotspot/cpu/ppc/globals_ppc.hpp\n+++ b/src/hotspot/cpu/ppc/globals_ppc.hpp\n@@ -115,8 +115,8 @@ define_pd_global(intx, InitArrayShortSize, 9*BytesPerLong);\n           \"Use static branch prediction hints for uncommon paths.\")         \\\n                                                                             \\\n   /* special instructions */                                                \\\n-  product(bool, SuperwordUseVSX, true,                                      \\\n-          \"Use Power8 VSX instructions for superword optimization.\")        \\\n+  product(bool, SuperwordUseVSX, false,                                     \\\n+          \"Use VSX instructions for superword optimization.\")               \\\n                                                                             \\\n   product(bool, UseByteReverseInstructions, false, DIAGNOSTIC,              \\\n           \"Use byte reverse instructions.\")                                 \\\n--- a/src/hotspot/cpu/ppc/vm_version_ppc.cpp\n+++ b/src/hotspot/cpu/ppc/vm_version_ppc.cpp\n@@ -95,6 +95,13 @@ void VM_Version::initialize() {\n     FLAG_SET_ERGO(TrapBasedRangeChecks, false);\n   }\n \n+  if (PowerArchitecturePPC64 >= 9) {\n+    // Performance is good since Power9.\n+    if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {\n+      FLAG_SET_ERGO(SuperwordUseVSX, true);\n+    }\n+  }\n+", "target": "--- a/src/hotspot/cpu/ppc/globals_ppc.hpp\n+++ b/src/hotspot/cpu/ppc/globals_ppc.hpp\n@@ -115,8 +115,8 @@ define_pd_global(intx, InitArrayShortSize, 9*BytesPerLong);\n           \"Use static branch prediction hints for uncommon paths.\")         \\\n                                                                             \\\n   /* special instructions */                                                \\\n-  product(bool, SuperwordUseVSX, true,                                      \\\n-          \"Use Power8 VSX instructions for superword optimization.\")        \\\n+  product(bool, SuperwordUseVSX, false,                                     \\\n+          \"Use VSX instructions for superword optimization.\")               \\\n                                                                             \\\n   product(bool, UseByteReverseInstructions, false, DIAGNOSTIC,              \\\n           \"Use byte reverse instructions.\")                                 \\\n--- a/src/hotspot/cpu/ppc/vm_version_ppc.cpp\n+++ b/src/hotspot/cpu/ppc/vm_version_ppc.cpp\n@@ -95,6 +95,13 @@ void VM_Version::initialize() {\n     FLAG_SET_ERGO(TrapBasedRangeChecks, false);\n   }\n \n+  if (PowerArchitecturePPC64 >= 9) {\n+    // Performance is good since Power9.\n+    if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {\n+      FLAG_SET_ERGO(SuperwordUseVSX, true);\n+    }\n+  }\n+", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SuperwordUseVSX标志默认启用（true），导致在Power8及以下平台上使用VSX指令进行超字优化时性能不佳。优化后：将SuperwordUseVSX默认值改为false，但针对Power9及以上架构自动启用（true）。优化思路：识别Power8的VSX指令性能问题，通过平台检测动态启用优化，避免在低性能硬件上使用VSX指令，同时保持Power9及以上的向量化性能优势。"}
{"id": 352, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码简化", "optimization_description": "优化前：increment_mdp_data_at函数支持递增和递减操作，包含复杂的溢出/下溢检查逻辑，代码冗余且执行路径长。优化后：移除递减功能（decrement参数）和所有溢出检查，简化为核心的三条指令（加载、递增、存储）。优化思路：根据实际使用场景分析，解释器性能分析只需要递增计数器，移除不必要的递减逻辑和检查可以显著减少指令数量，提高热点代码执行效率，同时简化代码维护。", "original_code": "increment_mdp_data_at函数支持递增和递减操作，包含复杂的溢出/下溢检查逻辑，代码冗余且执行路径长。", "optimized_code": "-void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n-                                                      Register reg,\n-                                                      int constant,\n-                                                      bool decrement) {\n+void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n+                                                      Register index,\n+                                                      int constant) {\n   assert(ProfileInterpreter, \"must be profiling interpreter\");\n-  // %%% this does 64bit counters at best it is wasting space\n-  // at worst it is a rare bug when counters overflow\n \n-  assert_different_registers(t1, t0, mdp_in, reg);\n+  assert_different_registers(t1, t0, mdp_in, index);\n \n   Address addr1(mdp_in, constant);\n   Address addr2(t1, 0);\n   Address &addr = addr1;\n-  if (reg != noreg) {\n+  if (index != noreg) {\n     la(t1, addr1);\n-    add(t1, t1, reg);\n+    add(t1, t1, index);\n     addr = addr2;\n   }\n \n-  if (decrement) {\n-    ld(t0, addr);\n-    subi(t0, t0, DataLayout::counter_increment);\n-    Label L;\n-    bltz(t0, L);      // skip store if counter underflow\n-    sd(t0, addr);\n-    bind(L);\n-  } else {\n-    assert(DataLayout::counter_increment == 1,\n-           \"flow-free idiom only works with 1\");\n-    ld(t0, addr);\n-    addi(t0, t0, DataLayout::counter_increment);\n-    Label L;\n-    blez(t0, L);       // skip store if counter overflow\n-    sd(t0, addr);\n-    bind(L);\n-  }\n+  ld(t0, addr);\n+  addi(t0, t0, DataLayout::counter_increment);\n+  sd(t0, addr);\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/939521b8e4120357108220d177228b683af3334f", "code_v0_no_empty_lines": "increment_mdp_data_at函数支持递增和递减操作，包含复杂的溢出/下溢检查逻辑，代码冗余且执行路径长。", "code_v1_no_empty_lines": "-void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n-                                                      Register reg,\n-                                                      int constant,\n-                                                      bool decrement) {\n+void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n+                                                      Register index,\n+                                                      int constant) {\n   assert(ProfileInterpreter, \"must be profiling interpreter\");\n-  // %%% this does 64bit counters at best it is wasting space\n-  // at worst it is a rare bug when counters overflow\n \n-  assert_different_registers(t1, t0, mdp_in, reg);\n+  assert_different_registers(t1, t0, mdp_in, index);\n \n   Address addr1(mdp_in, constant);\n   Address addr2(t1, 0);\n   Address &addr = addr1;\n-  if (reg != noreg) {\n+  if (index != noreg) {\n     la(t1, addr1);\n-    add(t1, t1, reg);\n+    add(t1, t1, index);\n     addr = addr2;\n   }\n \n-  if (decrement) {\n-    ld(t0, addr);\n-    subi(t0, t0, DataLayout::counter_increment);\n-    Label L;\n-    bltz(t0, L);      // skip store if counter underflow\n-    sd(t0, addr);\n-    bind(L);\n-  } else {\n-    assert(DataLayout::counter_increment == 1,\n-           \"flow-free idiom only works with 1\");\n-    ld(t0, addr);\n-    addi(t0, t0, DataLayout::counter_increment);\n-    Label L;\n-    blez(t0, L);       // skip store if counter overflow\n-    sd(t0, addr);\n-    bind(L);\n-  }\n+  ld(t0, addr);\n+  addi(t0, t0, DataLayout::counter_increment);\n+  sd(t0, addr);\n }", "target": "-void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n-                                                      Register reg,\n-                                                      int constant,\n-                                                      bool decrement) {\n+void InterpreterMacroAssembler::increment_mdp_data_at(Register mdp_in,\n+                                                      Register index,\n+                                                      int constant) {\n   assert(ProfileInterpreter, \"must be profiling interpreter\");\n-  // %%% this does 64bit counters at best it is wasting space\n-  // at worst it is a rare bug when counters overflow\n \n-  assert_different_registers(t1, t0, mdp_in, reg);\n+  assert_different_registers(t1, t0, mdp_in, index);\n \n   Address addr1(mdp_in, constant);\n   Address addr2(t1, 0);\n   Address &addr = addr1;\n-  if (reg != noreg) {\n+  if (index != noreg) {\n     la(t1, addr1);\n-    add(t1, t1, reg);\n+    add(t1, t1, index);\n     addr = addr2;\n   }\n \n-  if (decrement) {\n-    ld(t0, addr);\n-    subi(t0, t0, DataLayout::counter_increment);\n-    Label L;\n-    bltz(t0, L);      // skip store if counter underflow\n-    sd(t0, addr);\n-    bind(L);\n-  } else {\n-    assert(DataLayout::counter_increment == 1,\n-           \"flow-free idiom only works with 1\");\n-    ld(t0, addr);\n-    addi(t0, t0, DataLayout::counter_increment);\n-    Label L;\n-    blez(t0, L);       // skip store if counter overflow\n-    sd(t0, addr);\n-    bind(L);\n-  }\n+  ld(t0, addr);\n+  addi(t0, t0, DataLayout::counter_increment);\n+  sd(t0, addr);\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：increment_mdp_data_at函数支持递增和递减操作，包含复杂的溢出/下溢检查逻辑，代码冗余且执行路径长。优化后：移除递减功能（decrement参数）和所有溢出检查，简化为核心的三条指令（加载、递增、存储）。优化思路：根据实际使用场景分析，解释器性能分析只需要递增计数器，移除不必要的递减逻辑和检查可以显著减少指令数量，提高热点代码执行效率，同时简化代码维护。"}
{"id": 353, "source": "riscv-dataset-excel", "optimization_type": "代码简化+性能优化", "optimization_description": "优化前：profile_taken_branch函数手动内联increment_mdp_data_at操作，使用复杂的手动计数逻辑（movptr/addptr/sbbptr/movptr序列），需要额外的bumped_count寄存器参数。优化后：直接调用现有的increment_mdp_data_at辅助函数，简化代码逻辑，减少指令数量，消除对额外寄存器的依赖。优化思路：移除冗余的手动内联代码，复用现有辅助函数，简化实现同时减少寄存器压力。", "original_code": "profile_taken_branch函数手动内联increment_mdp_data_at操作，使用复杂的手动计数逻辑（movptr/addptr/sbbptr/movptr序列），需要额外的bumped_count寄存器参数。", "optimized_code": "-void InterpreterMacroAssembler::profile_taken_branch(Register mdp,\n-                                                     Register bumped_count) {\n+void InterpreterMacroAssembler::profile_taken_branch(Register mdp) {\n-    // We are taking a branch.  Increment the taken count.\n-    // We inline increment_mdp_data_at to return bumped_count in a register\n-    //increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));\n-    Address data(mdp, in_bytes(JumpData::taken_offset()));\n-    movptr(bumped_count, data);\n-    assert(DataLayout::counter_increment == 1,\n-            \"flow-free idiom only works with 1\");\n-    addptr(bumped_count, DataLayout::counter_increment);\n-    sbbptr(bumped_count, 0);\n-    movptr(data, bumped_count); // Store back out\n+    // We are taking a branch.  Increment the taken count.\n+    increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));", "source_url": "https://github.com/openjdk/riscv-port/commit/b918dc84ec8364321a5a6d9f6835edcb1d9ad62f", "code_v0_no_empty_lines": "profile_taken_branch函数手动内联increment_mdp_data_at操作，使用复杂的手动计数逻辑（movptr/addptr/sbbptr/movptr序列），需要额外的bumped_count寄存器参数。", "code_v1_no_empty_lines": "-void InterpreterMacroAssembler::profile_taken_branch(Register mdp,\n-                                                     Register bumped_count) {\n+void InterpreterMacroAssembler::profile_taken_branch(Register mdp) {\n-    // We are taking a branch.  Increment the taken count.\n-    // We inline increment_mdp_data_at to return bumped_count in a register\n-    //increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));\n-    Address data(mdp, in_bytes(JumpData::taken_offset()));\n-    movptr(bumped_count, data);\n-    assert(DataLayout::counter_increment == 1,\n-            \"flow-free idiom only works with 1\");\n-    addptr(bumped_count, DataLayout::counter_increment);\n-    sbbptr(bumped_count, 0);\n-    movptr(data, bumped_count); // Store back out\n+    // We are taking a branch.  Increment the taken count.\n+    increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));", "target": "-void InterpreterMacroAssembler::profile_taken_branch(Register mdp,\n-                                                     Register bumped_count) {\n+void InterpreterMacroAssembler::profile_taken_branch(Register mdp) {\n-    // We are taking a branch.  Increment the taken count.\n-    // We inline increment_mdp_data_at to return bumped_count in a register\n-    //increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));\n-    Address data(mdp, in_bytes(JumpData::taken_offset()));\n-    movptr(bumped_count, data);\n-    assert(DataLayout::counter_increment == 1,\n-            \"flow-free idiom only works with 1\");\n-    addptr(bumped_count, DataLayout::counter_increment);\n-    sbbptr(bumped_count, 0);\n-    movptr(data, bumped_count); // Store back out\n+    // We are taking a branch.  Increment the taken count.\n+    increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：profile_taken_branch函数手动内联increment_mdp_data_at操作，使用复杂的手动计数逻辑（movptr/addptr/sbbptr/movptr序列），需要额外的bumped_count寄存器参数。优化后：直接调用现有的increment_mdp_data_at辅助函数，简化代码逻辑，减少指令数量，消除对额外寄存器的依赖。优化思路：移除冗余的手动内联代码，复用现有辅助函数，简化实现同时减少寄存器压力。"}
{"id": 354, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+代码简化", "optimization_description": "优化前：epoch切换需要两个阶段（begin_epoch_shift和end_epoch_shift），使用_synchronizing标志和内存屏障来同步线程状态，增加了同步开销。优化后：合并为单个shift_epoch()方法，移除了_synchronizing标志和相关同步机制，简化了代码。优化思路：由于epoch切换只在安全点（safepoint）进行，此时所有Java线程都已暂停，无需额外的同步机制，直接切换epoch状态即可，减少了不必要的内存屏障和原子操作，提升了并发性能。", "original_code": "epoch切换需要两个阶段（begin_epoch_shift和end_epoch_shift），使用_synchronizing标志和内存屏障来同步线程状态，增加了同步开销。", "optimized_code": "-void JfrTraceIdEpoch::begin_epoch_shift() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-  _synchronizing = true;\n-  OrderAccess::fence();\n-}\n-\n-void JfrTraceIdEpoch::end_epoch_shift() {\n+void JfrTraceIdEpoch::shift_epoch() {\n   assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-  assert(_synchronizing, \"invariant\");\n   _epoch_state = !_epoch_state;\n-  ++_generation;\n-  if (epoch_generation_overflow == _generation) {\n+  if (++_generation == epoch_generation_overflow) {\n     _generation = 1;\n   }\n   assert(_generation != 0, \"invariant\");\n   assert(_generation < epoch_generation_overflow, \"invariant\");\n-  OrderAccess::storestore();\n-  _synchronizing = false;\n-}\n-\n-bool JfrTraceIdEpoch::is_synchronizing() {\n-  return Atomic::load_acquire(&_synchronizing);\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/955bfcd5502b3555c2c91db876be8e7535f2289a", "code_v0_no_empty_lines": "epoch切换需要两个阶段（begin_epoch_shift和end_epoch_shift），使用_synchronizing标志和内存屏障来同步线程状态，增加了同步开销。", "code_v1_no_empty_lines": "-void JfrTraceIdEpoch::begin_epoch_shift() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-  _synchronizing = true;\n-  OrderAccess::fence();\n-}\n-\n-void JfrTraceIdEpoch::end_epoch_shift() {\n+void JfrTraceIdEpoch::shift_epoch() {\n   assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-  assert(_synchronizing, \"invariant\");\n   _epoch_state = !_epoch_state;\n-  ++_generation;\n-  if (epoch_generation_overflow == _generation) {\n+  if (++_generation == epoch_generation_overflow) {\n     _generation = 1;\n   }\n   assert(_generation != 0, \"invariant\");\n   assert(_generation < epoch_generation_overflow, \"invariant\");\n-  OrderAccess::storestore();\n-  _synchronizing = false;\n-}\n-\n-bool JfrTraceIdEpoch::is_synchronizing() {\n-  return Atomic::load_acquire(&_synchronizing);\n }", "target": "-void JfrTraceIdEpoch::begin_epoch_shift() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-  _synchronizing = true;\n-  OrderAccess::fence();\n-}\n-\n-void JfrTraceIdEpoch::end_epoch_shift() {\n+void JfrTraceIdEpoch::shift_epoch() {\n   assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-  assert(_synchronizing, \"invariant\");\n   _epoch_state = !_epoch_state;\n-  ++_generation;\n-  if (epoch_generation_overflow == _generation) {\n+  if (++_generation == epoch_generation_overflow) {\n     _generation = 1;\n   }\n   assert(_generation != 0, \"invariant\");\n   assert(_generation < epoch_generation_overflow, \"invariant\");\n-  OrderAccess::storestore();\n-  _synchronizing = false;\n-}\n-\n-bool JfrTraceIdEpoch::is_synchronizing() {\n-  return Atomic::load_acquire(&_synchronizing);\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：epoch切换需要两个阶段（begin_epoch_shift和end_epoch_shift），使用_synchronizing标志和内存屏障来同步线程状态，增加了同步开销。优化后：合并为单个shift_epoch()方法，移除了_synchronizing标志和相关同步机制，简化了代码。优化思路：由于epoch切换只在安全点（safepoint）进行，此时所有Java线程都已暂停，无需额外的同步机制，直接切换epoch状态即可，减少了不必要的内存屏障和原子操作，提升了并发性能。"}
{"id": 355, "source": "riscv-dataset-excel", "optimization_type": "锁优化+并发性能优化", "optimization_description": "优化前：在JFR线程采样过程中，整个采样循环都在Threads_lock全局锁的保护下执行，导致锁持有时间过长，影响并发性能。优化后：引入JfrSampleMonitor类，将锁的持有范围缩小到必要的临界区，只在需要访问线程状态时获取锁，并在采样循环中检查安全点状态，避免在安全点时获取锁。优化思路：减少锁的持有时间，降低锁竞争，提高采样效率和系统整体并发性能。", "original_code": "在JFR线程采样过程中，整个采样循环都在Threads_lock全局锁的保护下执行，导致锁持有时间过长，影响并发性能。", "optimized_code": "-  MutexLocker tlock(Threads_lock);\n+  // 移除了Threads_lock的全局锁定，改为在JfrSampleMonitor类中细粒度控制", "source_url": "https://github.com/openjdk/riscv-port/commit/b6d60280e789436c7f9e3cd1447c8f77b77e77b4", "code_v0_no_empty_lines": "在JFR线程采样过程中，整个采样循环都在Threads_lock全局锁的保护下执行，导致锁持有时间过长，影响并发性能。", "code_v1_no_empty_lines": "-  MutexLocker tlock(Threads_lock);\n+  // 移除了Threads_lock的全局锁定，改为在JfrSampleMonitor类中细粒度控制", "target": "-  MutexLocker tlock(Threads_lock);\n+  // 移除了Threads_lock的全局锁定，改为在JfrSampleMonitor类中细粒度控制", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在JFR线程采样过程中，整个采样循环都在Threads_lock全局锁的保护下执行，导致锁持有时间过长，影响并发性能。优化后：引入JfrSampleMonitor类，将锁的持有范围缩小到必要的临界区，只在需要访问线程状态时获取锁，并在采样循环中检查安全点状态，避免在安全点时获取锁。优化思路：减少锁的持有时间，降低锁竞争，提高采样效率和系统整体并发性能。"}
{"id": 356, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+指令集优化", "optimization_description": "指令级并行：\n单条向量指令处理多个数据元素（如4个float或2个double）\n相比标量循环，吞吐量提升可达向量宽度的倍数\n\n专用指令优势：\n使用vfsgnjx指令直接实现绝对值，无需条件判断\n比软件实现（位操作或条件分支）更高效\n\n内存访问优化：\n向量化减少内存访问次数\n提升缓存利用率", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 核心向量化实现（c2_MacroAssembler_riscv.cpp）\n// 浮点绝对值向量化实现\nvoid C2_MacroAssembler::vabs_f(FloatRegister Vd, FloatRegister Vj, BasicType bt, int vector_len) {\n    assert(bt == T_FLOAT || bt == T_DOUBLE, \"must be float or double\");\n    // 使用RVV的vfsgnjx指令实现绝对值\n    vfsgnjx_vv(Vd, Vj, Vj, vector_len);\n}\n2. 编译器指令模式添加（riscv.ad）\n// 单精度浮点向量绝对值指令模式\ninstruct vabsF(vReg dst, vReg src) %{\n    predicate(UseRVV > 0 && n->as_Vector()->length() >= 4 &&\n              n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n    match(Set dst (AbsVF src));\n    ins_cost(INSN_COST);\n    format %{ \"vabs_f $dst, $src\\t# vector float abs\" %}\n    ins_encode %{\n        __ vabs_f(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), T_FLOAT, Matcher::vector_length(this));\n    %}\n    ins_pipe(pipe_class_vector);\n%}\n\n// 双精度浮点向量绝对值指令模式\ninstruct vabsD(vReg dst, vReg src) %{\n    predicate(UseRVV > 0 && n->as_Vector()->length() >= 2 &&\n              n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n    match(Set dst (AbsVD src));\n    ins_cost(INSN_COST);\n    format %{ \"vabs_d $dst, $src\\t# vector double abs\" %}\n    ins_encode %{\n        __ vabs_f(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), T_DOUBLE, Matcher::vector_length(this));\n    %}\n    ins_pipe(pipe_class_vector);\n%}", "source_url": "https://github.com/openjdk/riscv-port/commit/4e314cb9e025672b2f7b68cc021fa516ee219ad8", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 核心向量化实现（c2_MacroAssembler_riscv.cpp）\n// 浮点绝对值向量化实现\nvoid C2_MacroAssembler::vabs_f(FloatRegister Vd, FloatRegister Vj, BasicType bt, int vector_len) {\n    assert(bt == T_FLOAT || bt == T_DOUBLE, \"must be float or double\");\n    // 使用RVV的vfsgnjx指令实现绝对值\n    vfsgnjx_vv(Vd, Vj, Vj, vector_len);\n}\n2. 编译器指令模式添加（riscv.ad）\n// 单精度浮点向量绝对值指令模式\ninstruct vabsF(vReg dst, vReg src) %{\n    predicate(UseRVV > 0 && n->as_Vector()->length() >= 4 &&\n              n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n    match(Set dst (AbsVF src));\n    ins_cost(INSN_COST);\n    format %{ \"vabs_f $dst, $src\\t# vector float abs\" %}\n    ins_encode %{\n        __ vabs_f(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), T_FLOAT, Matcher::vector_length(this));\n    %}\n    ins_pipe(pipe_class_vector);\n%}\n\n// 双精度浮点向量绝对值指令模式\ninstruct vabsD(vReg dst, vReg src) %{\n    predicate(UseRVV > 0 && n->as_Vector()->length() >= 2 &&\n              n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n    match(Set dst (AbsVD src));\n    ins_cost(INSN_COST);\n    format %{ \"vabs_d $dst, $src\\t# vector double abs\" %}\n    ins_encode %{\n        __ vabs_f(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), T_DOUBLE, Matcher::vector_length(this));\n    %}\n    ins_pipe(pipe_class_vector);\n%}", "target": "1. 核心向量化实现（c2_MacroAssembler_riscv.cpp）\n// 浮点绝对值向量化实现\nvoid C2_MacroAssembler::vabs_f(FloatRegister Vd, FloatRegister Vj, BasicType bt, int vector_len) {\n    assert(bt == T_FLOAT || bt == T_DOUBLE, \"must be float or double\");\n    // 使用RVV的vfsgnjx指令实现绝对值\n    vfsgnjx_vv(Vd, Vj, Vj, vector_len);\n}\n2. 编译器指令模式添加（riscv.ad）\n// 单精度浮点向量绝对值指令模式\ninstruct vabsF(vReg dst, vReg src) %{\n    predicate(UseRVV > 0 && n->as_Vector()->length() >= 4 &&\n              n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n    match(Set dst (AbsVF src));\n    ins_cost(INSN_COST);\n    format %{ \"vabs_f $dst, $src\\t# vector float abs\" %}\n    ins_encode %{\n        __ vabs_f(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), T_FLOAT, Matcher::vector_length(this));\n    %}\n    ins_pipe(pipe_class_vector);\n%}\n\n// 双精度浮点向量绝对值指令模式\ninstruct vabsD(vReg dst, vReg src) %{\n    predicate(UseRVV > 0 && n->as_Vector()->length() >= 2 &&\n              n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n    match(Set dst (AbsVD src));\n    ins_cost(INSN_COST);\n    format %{ \"vabs_d $dst, $src\\t# vector double abs\" %}\n    ins_encode %{\n        __ vabs_f(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), T_DOUBLE, Matcher::vector_length(this));\n    %}\n    ins_pipe(pipe_class_vector);\n%}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "指令级并行：\n单条向量指令处理多个数据元素（如4个float或2个double）\n相比标量循环，吞吐量提升可达向量宽度的倍数\n\n专用指令优势：\n使用vfsgnjx指令直接实现绝对值，无需条件判断\n比软件实现（位操作或条件分支）更高效\n\n内存访问优化：\n向量化减少内存访问次数\n提升缓存利用率"}
{"id": 357, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "减少迭代范围：\n优化前：遍历所有旧代页面（数量可能很大）\n优化后：只遍历包含指向年轻代引用的页面（数量通常很少）\n\n内存访问优化：\n减少缓存失效：只访问相关页面，提高缓存局部性\n减少内存带宽消耗：避免扫描不包含相关引用的页面\n\n并行效率提升：\n更均衡的工作负载分配\n减少线程间的竞争和同步开销", "original_code": "遍历所有旧代页面（数量可能很大）", "optimized_code": "优化前：遍历所有旧代页面，效率低下\n// 原始代码：遍历所有旧代页面\n_old_pages_parallel_iterator.do_pages([&](ZPage* page) {\n    // 对每个页面执行操作，无论是否包含指向年轻代的引用\n    page->oops_do_current_remembered(ZBarrier::load_barrier_on_oop_field);\n    return true;\n});\n\n优化后：只迭代包含指向年轻代引用的页面（通过记忆集）\n// 优化后：只处理记忆集中记录的页面\nvoid ZRemembered::remap_current(ZRemsetTableIterator* iter) {\n    for (ZRemsetTableEntry entry; iter->next(&entry);) {\n        // 只处理实际包含年轻代引用的页面\n        entry._page->oops_do_current_remembered(ZBarrier::load_bar_barrier_on_oop_field);\n    }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/c90921644643bc731cab4c014a5144a74e670df1", "code_v0_no_empty_lines": "遍历所有旧代页面（数量可能很大）", "code_v1_no_empty_lines": "优化前：遍历所有旧代页面，效率低下\n// 原始代码：遍历所有旧代页面\n_old_pages_parallel_iterator.do_pages([&](ZPage* page) {\n    // 对每个页面执行操作，无论是否包含指向年轻代的引用\n    page->oops_do_current_remembered(ZBarrier::load_barrier_on_oop_field);\n    return true;\n});\n\n优化后：只迭代包含指向年轻代引用的页面（通过记忆集）\n// 优化后：只处理记忆集中记录的页面\nvoid ZRemembered::remap_current(ZRemsetTableIterator* iter) {\n    for (ZRemsetTableEntry entry; iter->next(&entry);) {\n        // 只处理实际包含年轻代引用的页面\n        entry._page->oops_do_current_remembered(ZBarrier::load_bar_barrier_on_oop_field);\n    }\n}", "target": "优化前：遍历所有旧代页面，效率低下\n// 原始代码：遍历所有旧代页面\n_old_pages_parallel_iterator.do_pages([&](ZPage* page) {\n    // 对每个页面执行操作，无论是否包含指向年轻代的引用\n    page->oops_do_current_remembered(ZBarrier::load_barrier_on_oop_field);\n    return true;\n});\n\n优化后：只迭代包含指向年轻代引用的页面（通过记忆集）\n// 优化后：只处理记忆集中记录的页面\nvoid ZRemembered::remap_current(ZRemsetTableIterator* iter) {\n    for (ZRemsetTableEntry entry; iter->next(&entry);) {\n        // 只处理实际包含年轻代引用的页面\n        entry._page->oops_do_current_remembered(ZBarrier::load_bar_barrier_on_oop_field);\n    }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "减少迭代范围：\n优化前：遍历所有旧代页面（数量可能很大）\n优化后：只遍历包含指向年轻代引用的页面（数量通常很少）\n\n内存访问优化：\n减少缓存失效：只访问相关页面，提高缓存局部性\n减少内存带宽消耗：避免扫描不包含相关引用的页面\n\n并行效率提升：\n更均衡的工作负载分配\n减少线程间的竞争和同步开销"}
{"id": 358, "source": "riscv-dataset-excel", "optimization_type": "性能分析功能增强", "optimization_description": "优化前：JFR（Java Flight Recorder）缺少CPU时间分析功能，无法准确测量线程的CPU使用时间。优化后：实现了JEP 509的CPU时间分析功能，通过新增jfrCPUTimeThreadSampler模块、信号处理增强和JNI接口扩展，支持CPU时间采样和节流控制。优化思路：通过操作系统信号机制获取线程CPU时间，集成到JFR框架中，提供更精确的性能分析数据，同时保持低开销。", "original_code": "JFR（Java Flight Recorder）缺少CPU时间分析功能，无法准确测量线程的CPU使用时间。", "optimized_code": "+  static void* get_signal_handler_for_signal(int sig);\n+  return tl->has_sample_request() || tl->has_cpu_time_jfr_requests();\n+  JfrEventSetting::set_enabled(JfrCPUTimeSampleEvent, rate > 0);\n+  JfrCPUTimeThreadSampling::set_rate(rate, auto_adapt == JNI_TRUE);\n+  (char*)\"setCPUThrottle\", (char*)\"(DZ)V\", (void*)jfr_set_cpu_throttle,", "source_url": "https://github.com/openjdk/riscv-port/commit/5b27e9c2df8b386b38b0553d941469cd8aa65c28", "code_v0_no_empty_lines": "JFR（Java Flight Recorder）缺少CPU时间分析功能，无法准确测量线程的CPU使用时间。", "code_v1_no_empty_lines": "+  static void* get_signal_handler_for_signal(int sig);\n+  return tl->has_sample_request() || tl->has_cpu_time_jfr_requests();\n+  JfrEventSetting::set_enabled(JfrCPUTimeSampleEvent, rate > 0);\n+  JfrCPUTimeThreadSampling::set_rate(rate, auto_adapt == JNI_TRUE);\n+  (char*)\"setCPUThrottle\", (char*)\"(DZ)V\", (void*)jfr_set_cpu_throttle,", "target": "+  static void* get_signal_handler_for_signal(int sig);\n+  return tl->has_sample_request() || tl->has_cpu_time_jfr_requests();\n+  JfrEventSetting::set_enabled(JfrCPUTimeSampleEvent, rate > 0);\n+  JfrCPUTimeThreadSampling::set_rate(rate, auto_adapt == JNI_TRUE);\n+  (char*)\"setCPUThrottle\", (char*)\"(DZ)V\", (void*)jfr_set_cpu_throttle,", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：JFR（Java Flight Recorder）缺少CPU时间分析功能，无法准确测量线程的CPU使用时间。优化后：实现了JEP 509的CPU时间分析功能，通过新增jfrCPUTimeThreadSampler模块、信号处理增强和JNI接口扩展，支持CPU时间采样和节流控制。优化思路：通过操作系统信号机制获取线程CPU时间，集成到JFR框架中，提供更精确的性能分析数据，同时保持低开销。"}
{"id": 359, "source": "riscv-dataset-excel", "optimization_type": "解释器帧修复", "optimization_description": "优化前：在JFR协同采样期间，当从去优化帧返回时，解释器帧的字节码指针（BCP）可能处于不一致状态，导致JVMTI PopFrame操作出现问题。优化后：在_remove_activation_preserving_args_entry入口点添加__restore_bcp()调用，确保从去优化返回后正确恢复BCP寄存器。思路：修复解释器帧状态一致性，确保JVMTI PopFrame操作在JFR采样场景下能正确处理帧状态。", "original_code": "在JFR协同采样期间，当从去优化帧返回时，解释器帧的字节码指针（BCP）可能处于不一致状态，导致JVMTI PopFrame操作出现问题。", "optimized_code": "+  __ restore_bcp(); // We could have returned from deoptimizing this frame, so restore rbcp.", "source_url": "https://github.com/openjdk/riscv-port/commit/d450e341c7af910b618f3dd3e1f77e2e37702c5f", "code_v0_no_empty_lines": "在JFR协同采样期间，当从去优化帧返回时，解释器帧的字节码指针（BCP）可能处于不一致状态，导致JVMTI PopFrame操作出现问题。", "code_v1_no_empty_lines": "+  __ restore_bcp(); // We could have returned from deoptimizing this frame, so restore rbcp.", "target": "+  __ restore_bcp(); // We could have returned from deoptimizing this frame, so restore rbcp.", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在JFR协同采样期间，当从去优化帧返回时，解释器帧的字节码指针（BCP）可能处于不一致状态，导致JVMTI PopFrame操作出现问题。优化后：在_remove_activation_preserving_args_entry入口点添加__restore_bcp()调用，确保从去优化返回后正确恢复BCP寄存器。思路：修复解释器帧状态一致性，确保JVMTI PopFrame操作在JFR采样场景下能正确处理帧状态。"}
{"id": 360, "source": "riscv-dataset-excel", "optimization_type": "性能分析优化", "optimization_description": "优化前：JFR（Java Flight Recorder）缺乏CPU时间分析功能，无法准确测量线程实际CPU使用时间。优化后：实现了JEP 509的CPU时间分析功能，通过新增jfrCPUTimeThreadSampler模块，在信号处理层添加get_signal_handler_for_signal()支持，扩展JNI接口jfr_set_cpu_throttle()进行采样率控制，并修改线程本地状态检查逻辑以同时处理CPU时间采样请求。优化思路：通过操作系统信号机制和采样技术，在低开销下实现精确的CPU时间分析，为性能调优提供关键数据。", "original_code": "JFR（Java Flight Recorder）缺乏CPU时间分析功能，无法准确测量线程实际CPU使用时间。", "optimized_code": "+  static void* get_signal_handler_for_signal(int sig);\n+  JfrEventSetting::set_enabled(JfrCPUTimeSampleEvent, rate > 0);\n+  JfrCPUTimeThreadSampling::set_rate(rate, auto_adapt == JNI_TRUE);\n+  return tl->has_sample_request() || tl->has_cpu_time_jfr_requests();", "source_url": "https://github.com/openjdk/riscv-port/commit/ace70a6d6aca619da34b2f9cac2586cc88cefb5a", "code_v0_no_empty_lines": "JFR（Java Flight Recorder）缺乏CPU时间分析功能，无法准确测量线程实际CPU使用时间。", "code_v1_no_empty_lines": "+  static void* get_signal_handler_for_signal(int sig);\n+  JfrEventSetting::set_enabled(JfrCPUTimeSampleEvent, rate > 0);\n+  JfrCPUTimeThreadSampling::set_rate(rate, auto_adapt == JNI_TRUE);\n+  return tl->has_sample_request() || tl->has_cpu_time_jfr_requests();", "target": "+  static void* get_signal_handler_for_signal(int sig);\n+  JfrEventSetting::set_enabled(JfrCPUTimeSampleEvent, rate > 0);\n+  JfrCPUTimeThreadSampling::set_rate(rate, auto_adapt == JNI_TRUE);\n+  return tl->has_sample_request() || tl->has_cpu_time_jfr_requests();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：JFR（Java Flight Recorder）缺乏CPU时间分析功能，无法准确测量线程实际CPU使用时间。优化后：实现了JEP 509的CPU时间分析功能，通过新增jfrCPUTimeThreadSampler模块，在信号处理层添加get_signal_handler_for_signal()支持，扩展JNI接口jfr_set_cpu_throttle()进行采样率控制，并修改线程本地状态检查逻辑以同时处理CPU时间采样请求。优化思路：通过操作系统信号机制和采样技术，在低开销下实现精确的CPU时间分析，为性能调优提供关键数据。"}
{"id": 361, "source": "riscv-dataset-excel", "optimization_type": "性能优化+事件采样优化", "optimization_description": "优化前：每个文件I/O操作都计算持续时间并调用shouldCommit()检查是否提交事件，产生额外开销。优化后：引入速率限制采样机制，通过offer()方法内部处理采样逻辑，减少不必要的检查调用。思路：通过Throttler类实现滑动窗口采样，避免高频事件产生过多JFR事件，降低运行时开销。", "original_code": "每个文件I/O操作都计算持续时间并调用shouldCommit()检查是否提交事件，产生额外开销。", "optimized_code": "- long duration = FileReadEvent.timestamp() - start;\n- if (FileReadEvent.shouldCommit(duration)) {\n-     FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n- }\n+ FileReadEvent.offer(start, path, bytesRead);", "source_url": "https://github.com/openjdk/riscv-port/commit/eb770a060ad86d69b38df7d11622e9e25a528e1d", "code_v0_no_empty_lines": "每个文件I/O操作都计算持续时间并调用shouldCommit()检查是否提交事件，产生额外开销。", "code_v1_no_empty_lines": "- long duration = FileReadEvent.timestamp() - start;\n- if (FileReadEvent.shouldCommit(duration)) {\n-     FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n- }\n+ FileReadEvent.offer(start, path, bytesRead);", "target": "- long duration = FileReadEvent.timestamp() - start;\n- if (FileReadEvent.shouldCommit(duration)) {\n-     FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n- }\n+ FileReadEvent.offer(start, path, bytesRead);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每个文件I/O操作都计算持续时间并调用shouldCommit()检查是否提交事件，产生额外开销。优化后：引入速率限制采样机制，通过offer()方法内部处理采样逻辑，减少不必要的检查调用。思路：通过Throttler类实现滑动窗口采样，避免高频事件产生过多JFR事件，降低运行时开销。"}
{"id": 362, "source": "riscv-dataset-excel", "optimization_type": "功能增强+性能监控优化", "optimization_description": "优化前：MethodTiming事件仅包含平均执行时间统计，缺少最小和最大执行时间信息，限制了性能分析能力。优化后：在TimedMethod记录类中新增minimum和maximum原子变量，添加updateMinMax()方法使用CAS操作高效更新极值，同时在事件元数据、事件类、查询视图和发射逻辑中相应扩展。优化思路：增强JFR性能监控功能，提供更全面的方法执行时间分布信息（最小、平均、最大时间），帮助开发者更精确地识别性能瓶颈和异常情况。", "original_code": "MethodTiming事件仅包含平均执行时间统计，缺少最小和最大执行时间信息，限制了性能分析能力。", "optimized_code": "record TimedMethod(AtomicLong invocations, AtomicLong time, AtomicLong minimum, AtomicLong maximum, Method method, AtomicBoolean published) {\n    TimedMethod(Method method) {\n        this(new AtomicLong(), new AtomicLong(), new AtomicLong(Long.MAX_VALUE), new AtomicLong(Long.MIN_VALUE), method, new AtomicBoolean());\n    }\n\n    public void updateMinMax(long duration) {\n        if (duration > maximum.getPlain()) {\n            while (true) {\n                long max = maximum.get();\n                if (duration <= max) {\n                    return;\n                }\n                if (maximum.weakCompareAndSetVolatile(max, duration)) {\n                    return;\n                }\n            }\n        }\n        if (duration < minimum.getPlain()) {\n            while (true) {\n                long min = minimum.get();\n                if (duration >= min) {\n                    return;\n                }\n                if (minimum.weakCompareAndSetVolatile(min, duration)) {\n                    return;\n                }\n            }\n        }\n    }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/6cdfd36ac80ad889ddbcfc702115b750a32d9645", "code_v0_no_empty_lines": "MethodTiming事件仅包含平均执行时间统计，缺少最小和最大执行时间信息，限制了性能分析能力。", "code_v1_no_empty_lines": "record TimedMethod(AtomicLong invocations, AtomicLong time, AtomicLong minimum, AtomicLong maximum, Method method, AtomicBoolean published) {\n    TimedMethod(Method method) {\n        this(new AtomicLong(), new AtomicLong(), new AtomicLong(Long.MAX_VALUE), new AtomicLong(Long.MIN_VALUE), method, new AtomicBoolean());\n    }\n\n    public void updateMinMax(long duration) {\n        if (duration > maximum.getPlain()) {\n            while (true) {\n                long max = maximum.get();\n                if (duration <= max) {\n                    return;\n                }\n                if (maximum.weakCompareAndSetVolatile(max, duration)) {\n                    return;\n                }\n            }\n        }\n        if (duration < minimum.getPlain()) {\n            while (true) {\n                long min = minimum.get();\n                if (duration >= min) {\n                    return;\n                }\n                if (minimum.weakCompareAndSetVolatile(min, duration)) {\n                    return;\n                }\n            }\n        }\n    }\n}", "target": "record TimedMethod(AtomicLong invocations, AtomicLong time, AtomicLong minimum, AtomicLong maximum, Method method, AtomicBoolean published) {\n    TimedMethod(Method method) {\n        this(new AtomicLong(), new AtomicLong(), new AtomicLong(Long.MAX_VALUE), new AtomicLong(Long.MIN_VALUE), method, new AtomicBoolean());\n    }\n\n    public void updateMinMax(long duration) {\n        if (duration > maximum.getPlain()) {\n            while (true) {\n                long max = maximum.get();\n                if (duration <= max) {\n                    return;\n                }\n                if (maximum.weakCompareAndSetVolatile(max, duration)) {\n                    return;\n                }\n            }\n        }\n        if (duration < minimum.getPlain()) {\n            while (true) {\n                long min = minimum.get();\n                if (duration >= min) {\n                    return;\n                }\n                if (minimum.weakCompareAndSetVolatile(min, duration)) {\n                    return;\n                }\n            }\n        }\n    }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：MethodTiming事件仅包含平均执行时间统计，缺少最小和最大执行时间信息，限制了性能分析能力。优化后：在TimedMethod记录类中新增minimum和maximum原子变量，添加updateMinMax()方法使用CAS操作高效更新极值，同时在事件元数据、事件类、查询视图和发射逻辑中相应扩展。优化思路：增强JFR性能监控功能，提供更全面的方法执行时间分布信息（最小、平均、最大时间），帮助开发者更精确地识别性能瓶颈和异常情况。"}
{"id": 363, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+SIMD优化", "optimization_description": "优化前：AArch64平台缺少SHA3算法的GPR（通用寄存器）硬件加速实现，依赖软件计算或未优化的指令序列。优化后：新增SHA3 GPR intrinsic实现，包括rolw/rol旋转指令、rax1/eor3位操作指令的封装，并添加UseSIMDForSHA3Intrinsic控制标志。优化思路：利用AArch64指令集特性实现SHA3算法的硬件加速，通过专用intrinsic函数减少指令数量、提高并行度，显著提升SHA3哈希计算的性能。", "original_code": "AArch64平台缺少SHA3算法的GPR（通用寄存器）硬件加速实现，依赖软件计算或未优化的指令序列。", "optimized_code": "inline void rolw(Register Rd, Register Rn, unsigned imm) {\n    extrw(Rd, Rn, Rn, (32 - imm));\n}\n\ninline void rol(Register Rd, Register Rn, unsigned imm) {\n    extr(Rd, Rn, Rn, (64 - imm));\n}\n\nusing Assembler::rax1;\nusing Assembler::eor3;\n\ninline void rax1(Register Rd, Register Rn, Register Rm) {\n    eor(Rd, Rn, Rm, ROR, 63); // Rd = Rn ^ rol(Rm, 1)\n}\n\ninline void eor3(Register Rd, Register Rn, Register Rm, Register Rk) {\n    assert(Rd != Rn, \"Use tmp register\");\n    eor(Rd, Rm, Rk);\n    eor(Rd, Rd, Rn);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/23f1d4f9a993033596ff17751c877f2bb3f792ed", "code_v0_no_empty_lines": "AArch64平台缺少SHA3算法的GPR（通用寄存器）硬件加速实现，依赖软件计算或未优化的指令序列。", "code_v1_no_empty_lines": "inline void rolw(Register Rd, Register Rn, unsigned imm) {\n    extrw(Rd, Rn, Rn, (32 - imm));\n}\n\ninline void rol(Register Rd, Register Rn, unsigned imm) {\n    extr(Rd, Rn, Rn, (64 - imm));\n}\n\nusing Assembler::rax1;\nusing Assembler::eor3;\n\ninline void rax1(Register Rd, Register Rn, Register Rm) {\n    eor(Rd, Rn, Rm, ROR, 63); // Rd = Rn ^ rol(Rm, 1)\n}\n\ninline void eor3(Register Rd, Register Rn, Register Rm, Register Rk) {\n    assert(Rd != Rn, \"Use tmp register\");\n    eor(Rd, Rm, Rk);\n    eor(Rd, Rd, Rn);\n}", "target": "inline void rolw(Register Rd, Register Rn, unsigned imm) {\n    extrw(Rd, Rn, Rn, (32 - imm));\n}\n\ninline void rol(Register Rd, Register Rn, unsigned imm) {\n    extr(Rd, Rn, Rn, (64 - imm));\n}\n\nusing Assembler::rax1;\nusing Assembler::eor3;\n\ninline void rax1(Register Rd, Register Rn, Register Rm) {\n    eor(Rd, Rn, Rm, ROR, 63); // Rd = Rn ^ rol(Rm, 1)\n}\n\ninline void eor3(Register Rd, Register Rn, Register Rm, Register Rk) {\n    assert(Rd != Rn, \"Use tmp register\");\n    eor(Rd, Rm, Rk);\n    eor(Rd, Rd, Rn);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AArch64平台缺少SHA3算法的GPR（通用寄存器）硬件加速实现，依赖软件计算或未优化的指令序列。优化后：新增SHA3 GPR intrinsic实现，包括rolw/rol旋转指令、rax1/eor3位操作指令的封装，并添加UseSIMDForSHA3Intrinsic控制标志。优化思路：利用AArch64指令集特性实现SHA3算法的硬件加速，通过专用intrinsic函数减少指令数量、提高并行度，显著提升SHA3哈希计算的性能。"}
{"id": 364, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化+性能优化", "optimization_description": "优化前：使用List.get(0)获取第一个元素，然后调用remove(0)移除该元素，这需要两次操作且remove(0)会导致后续元素移动，时间复杂度为O(n)。优化后：直接使用removeFirst()方法，一次性完成获取和移除操作，避免了不必要的元素移动，时间复杂度为O(1)（对于LinkedList）或更高效。思路：消除冗余操作，利用List接口的removeFirst()方法简化代码并提升性能。", "original_code": "使用List.get(0)获取第一个元素，然后调用remove(0)移除该元素，这需要两次操作且remove(0)会导致后续元素移动，时间复杂度为O(n)。", "optimized_code": "- if (cache.size() > 0) {\n-     HeavyWeightPopup r = cache.get(0);\n-     cache.remove(0);\n-     return r;\n+ if (!cache.isEmpty()) {\n+     return cache.removeFirst();", "source_url": "https://github.com/openjdk/riscv-port/commit/15178aa298e43be3e27121343432f25884db4e5d", "code_v0_no_empty_lines": "使用List.get(0)获取第一个元素，然后调用remove(0)移除该元素，这需要两次操作且remove(0)会导致后续元素移动，时间复杂度为O(n)。", "code_v1_no_empty_lines": "- if (cache.size() > 0) {\n-     HeavyWeightPopup r = cache.get(0);\n-     cache.remove(0);\n-     return r;\n+ if (!cache.isEmpty()) {\n+     return cache.removeFirst();", "target": "- if (cache.size() > 0) {\n-     HeavyWeightPopup r = cache.get(0);\n-     cache.remove(0);\n-     return r;\n+ if (!cache.isEmpty()) {\n+     return cache.removeFirst();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用List.get(0)获取第一个元素，然后调用remove(0)移除该元素，这需要两次操作且remove(0)会导致后续元素移动，时间复杂度为O(n)。优化后：直接使用removeFirst()方法，一次性完成获取和移除操作，避免了不必要的元素移动，时间复杂度为O(1)（对于LinkedList）或更高效。思路：消除冗余操作，利用List接口的removeFirst()方法简化代码并提升性能。"}
{"id": 365, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（隐式空检查）", "optimization_description": "优化前：ZGC读取操作无法使用隐式空检查，需要显式空检查指令，增加指令开销。优化后：为ZGC读取操作启用隐式空检查，通过ins_is_late_expanded_null_check_candidate属性标记候选指令，当内存操作数满足条件（如immLoffset8）时，加载指令可同时执行空检查。优化思路：利用硬件特性，将空检查与内存访问合并，减少指令数量，提升性能。", "original_code": "ZGC读取操作无法使用隐式空检查，需要显式空检查指令，增加指令开销。", "optimized_code": "ins_is_late_expanded_null_check_candidate(opnd_array(1)->opcode() == INDOFFL8);", "source_url": "https://github.com/openjdk/riscv-port/commit/91f12600d2b188ca98c5c575a34b85f5835399a0", "code_v0_no_empty_lines": "ZGC读取操作无法使用隐式空检查，需要显式空检查指令，增加指令开销。", "code_v1_no_empty_lines": "ins_is_late_expanded_null_check_candidate(opnd_array(1)->opcode() == INDOFFL8);", "target": "ins_is_late_expanded_null_check_candidate(opnd_array(1)->opcode() == INDOFFL8);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ZGC读取操作无法使用隐式空检查，需要显式空检查指令，增加指令开销。优化后：为ZGC读取操作启用隐式空检查，通过ins_is_late_expanded_null_check_candidate属性标记候选指令，当内存操作数满足条件（如immLoffset8）时，加载指令可同时执行空检查。优化思路：利用硬件特性，将空检查与内存访问合并，减少指令数量，提升性能。"}
{"id": 366, "source": "riscv-dataset-excel", "optimization_type": "代码重构+API统一", "optimization_description": "优化前：数组分配存在两种方式，直接调用Klass的allocate()方法和通过oopFactory工厂方法。优化后：统一使用oopFactory工厂方法进行数组分配，并将Klass的allocate()方法重命名为allocate_instance()以明确语义。优化思路：通过统一API接口，提高代码可维护性和一致性，减少直接调用底层Klass方法的复杂度，同时保持功能不变。", "original_code": "数组分配存在两种方式，直接调用Klass的allocate()方法和通过oopFactory工厂方法。", "optimized_code": "-  return Universe::boolArrayKlass()->allocate(length, THREAD);\n+  return Universe::boolArrayKlass()->allocate_instance(length, THREAD);\n\n-  objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) ->allocate(length, CHECK_(JVMCIObject()));\n+  objArrayOop result = oopFactory::new_objArray(Universe::byteArrayKlass(), length, CHECK_(JVMCIObject()));", "source_url": "https://github.com/openjdk/riscv-port/commit/eb256deb8021d5b243ef782eb9e2622472909e97", "code_v0_no_empty_lines": "数组分配存在两种方式，直接调用Klass的allocate()方法和通过oopFactory工厂方法。", "code_v1_no_empty_lines": "-  return Universe::boolArrayKlass()->allocate(length, THREAD);\n+  return Universe::boolArrayKlass()->allocate_instance(length, THREAD);\n\n-  objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) ->allocate(length, CHECK_(JVMCIObject()));\n+  objArrayOop result = oopFactory::new_objArray(Universe::byteArrayKlass(), length, CHECK_(JVMCIObject()));", "target": "-  return Universe::boolArrayKlass()->allocate(length, THREAD);\n+  return Universe::boolArrayKlass()->allocate_instance(length, THREAD);\n\n-  objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) ->allocate(length, CHECK_(JVMCIObject()));\n+  objArrayOop result = oopFactory::new_objArray(Universe::byteArrayKlass(), length, CHECK_(JVMCIObject()));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：数组分配存在两种方式，直接调用Klass的allocate()方法和通过oopFactory工厂方法。优化后：统一使用oopFactory工厂方法进行数组分配，并将Klass的allocate()方法重命名为allocate_instance()以明确语义。优化思路：通过统一API接口，提高代码可维护性和一致性，减少直接调用底层Klass方法的复杂度，同时保持功能不变。"}
{"id": 367, "source": "riscv-dataset-excel", "optimization_type": "延迟计算优化+内存优化", "optimization_description": "优化前：使用双重检查锁定（double-checked locking）实现延迟初始化，每次访问keySet时都需要进行空值检查和同步操作，存在并发开销和内存屏障。优化后：使用StableValue.supplier包装Supplier实现延迟计算，将keySet字段改为final Supplier类型，通过函数式接口实现按需计算。优化思路：1. 消除同步开销，避免锁竞争；2. 利用StableValue的线程安全特性保证单次计算；3. 简化代码结构，提高可读性；4. 减少内存访问开销，避免volatile变量的内存屏障。", "original_code": "使用双重检查锁定（double-checked locking）实现延迟初始化，每次访问keySet时都需要进行空值检查和同步操作，存在并发开销和内存屏障。", "optimized_code": "- private volatile Set<String> keySet;\n+ private final Supplier<Set<String>> keySet = StableValue.supplier(\n+         new Supplier<>() { public Set<String> get() { return keySet0(); }});\n- if (keySet == null) {\n-     synchronized (this) {\n-         if (keySet == null) {\n-             Set<String> keys = new HashSet<>();\n-             Enumeration<String> enumKeys = getKeys();\n-             while (enumKeys.hasMoreElements()) {\n-                 String key = enumKeys.nextElement();\n-                 if (handleGetObject(key) != null) {\n-                     keys.add(key);\n-                 }\n-             }\n-             keySet = keys;\n-         }\n-     }\n- }\n- return keySet;\n+ return keySet.get();", "source_url": "https://github.com/openjdk/riscv-port/commit/52338c94f610611a9e89a6ccbe6f2c6cd768b50a", "code_v0_no_empty_lines": "使用双重检查锁定（double-checked locking）实现延迟初始化，每次访问keySet时都需要进行空值检查和同步操作，存在并发开销和内存屏障。", "code_v1_no_empty_lines": "- private volatile Set<String> keySet;\n+ private final Supplier<Set<String>> keySet = StableValue.supplier(\n+         new Supplier<>() { public Set<String> get() { return keySet0(); }});\n- if (keySet == null) {\n-     synchronized (this) {\n-         if (keySet == null) {\n-             Set<String> keys = new HashSet<>();\n-             Enumeration<String> enumKeys = getKeys();\n-             while (enumKeys.hasMoreElements()) {\n-                 String key = enumKeys.nextElement();\n-                 if (handleGetObject(key) != null) {\n-                     keys.add(key);\n-                 }\n-             }\n-             keySet = keys;\n-         }\n-     }\n- }\n- return keySet;\n+ return keySet.get();", "target": "- private volatile Set<String> keySet;\n+ private final Supplier<Set<String>> keySet = StableValue.supplier(\n+         new Supplier<>() { public Set<String> get() { return keySet0(); }});\n- if (keySet == null) {\n-     synchronized (this) {\n-         if (keySet == null) {\n-             Set<String> keys = new HashSet<>();\n-             Enumeration<String> enumKeys = getKeys();\n-             while (enumKeys.hasMoreElements()) {\n-                 String key = enumKeys.nextElement();\n-                 if (handleGetObject(key) != null) {\n-                     keys.add(key);\n-                 }\n-             }\n-             keySet = keys;\n-         }\n-     }\n- }\n- return keySet;\n+ return keySet.get();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用双重检查锁定（double-checked locking）实现延迟初始化，每次访问keySet时都需要进行空值检查和同步操作，存在并发开销和内存屏障。优化后：使用StableValue.supplier包装Supplier实现延迟计算，将keySet字段改为final Supplier类型，通过函数式接口实现按需计算。优化思路：1. 消除同步开销，避免锁竞争；2. 利用StableValue的线程安全特性保证单次计算；3. 简化代码结构，提高可读性；4. 减少内存访问开销，避免volatile变量的内存屏障。"}
{"id": 368, "source": "riscv-dataset-excel", "optimization_type": "延迟计算优化+内存优化", "optimization_description": "优化前：IsoCountryCode枚举使用抽象方法和ConcurrentHashMap进行延迟计算，Locale缓存使用静态内部类LocaleCache管理。优化后：IsoCountryCode枚举简化为普通枚举，通过switch直接调用LocaleISOData中的Supplier获取数据；Locale缓存重构为使用Supplier和StableValue，实现真正的延迟初始化。优化思路：消除不必要的抽象层次和并发数据结构，简化代码结构，减少内存占用和初始化开销，提高首次访问性能。", "original_code": "IsoCountryCode枚举使用抽象方法和ConcurrentHashMap进行延迟计算，Locale缓存使用静态内部类LocaleCache管理。", "optimized_code": "- private static final class LocaleCache implements Function<Object, Locale> {\n-     private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n-             = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n- \n-     private static final Function<Object, Locale> LOCALE_CREATOR = new LocaleCache();\n- \n-     public static Locale cache(Object key) {\n-         return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n-     }\n+ private static final Supplier<ReferencedKeyMap<Object, Locale>> LOCALE_CACHE =\n+         StableValue.supplier(new Supplier<>() {\n+             @Override\n+             public ReferencedKeyMap<Object, Locale> get() {\n+                 return ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+             }\n+         });\n+ \n+ private static final Function<Object, Locale> LOCALE_CREATOR = new Function<>() {\n      @Override\n      public Locale apply(Object key) {\n          if (key instanceof BaseLocale base) {\n              return new Locale(base, null);\n          }\n          LocaleKey lk = (LocaleKey)key;\n          return new Locale(lk.base, lk.exts);\n      }\n- }\n+ };", "source_url": "https://github.com/openjdk/riscv-port/commit/cd9b1bc820540184c79dd1957edc7ad4e8e469dc", "code_v0_no_empty_lines": "IsoCountryCode枚举使用抽象方法和ConcurrentHashMap进行延迟计算，Locale缓存使用静态内部类LocaleCache管理。", "code_v1_no_empty_lines": "- private static final class LocaleCache implements Function<Object, Locale> {\n-     private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n-             = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n- \n-     private static final Function<Object, Locale> LOCALE_CREATOR = new LocaleCache();\n- \n-     public static Locale cache(Object key) {\n-         return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n-     }\n+ private static final Supplier<ReferencedKeyMap<Object, Locale>> LOCALE_CACHE =\n+         StableValue.supplier(new Supplier<>() {\n+             @Override\n+             public ReferencedKeyMap<Object, Locale> get() {\n+                 return ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+             }\n+         });\n+ \n+ private static final Function<Object, Locale> LOCALE_CREATOR = new Function<>() {\n      @Override\n      public Locale apply(Object key) {\n          if (key instanceof BaseLocale base) {\n              return new Locale(base, null);\n          }\n          LocaleKey lk = (LocaleKey)key;\n          return new Locale(lk.base, lk.exts);\n      }\n- }\n+ };", "target": "- private static final class LocaleCache implements Function<Object, Locale> {\n-     private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n-             = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n- \n-     private static final Function<Object, Locale> LOCALE_CREATOR = new LocaleCache();\n- \n-     public static Locale cache(Object key) {\n-         return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n-     }\n+ private static final Supplier<ReferencedKeyMap<Object, Locale>> LOCALE_CACHE =\n+         StableValue.supplier(new Supplier<>() {\n+             @Override\n+             public ReferencedKeyMap<Object, Locale> get() {\n+                 return ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+             }\n+         });\n+ \n+ private static final Function<Object, Locale> LOCALE_CREATOR = new Function<>() {\n      @Override\n      public Locale apply(Object key) {\n          if (key instanceof BaseLocale base) {\n              return new Locale(base, null);\n          }\n          LocaleKey lk = (LocaleKey)key;\n          return new Locale(lk.base, lk.exts);\n      }\n- }\n+ };", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：IsoCountryCode枚举使用抽象方法和ConcurrentHashMap进行延迟计算，Locale缓存使用静态内部类LocaleCache管理。优化后：IsoCountryCode枚举简化为普通枚举，通过switch直接调用LocaleISOData中的Supplier获取数据；Locale缓存重构为使用Supplier和StableValue，实现真正的延迟初始化。优化思路：消除不必要的抽象层次和并发数据结构，简化代码结构，减少内存占用和初始化开销，提高首次访问性能。"}
{"id": 369, "source": "riscv-dataset-excel", "optimization_type": "代码健壮性优化", "optimization_description": "优化前：多个Vector API内在函数的输入检查存在逻辑缺陷，条件判断语句将null检查与const_oop()检查混合在单行中，可能导致空指针解引用。优化后：重构条件判断逻辑，将每个变量的null检查和const_oop()检查分组排列，确保先检查指针非空再访问其成员，提高了代码的健壮性和安全性。优化思路：通过重新组织条件语句结构，消除潜在的空指针解引用风险，使代码更符合防御性编程原则。", "original_code": "多个Vector API内在函数的输入检查存在逻辑缺陷，条件判断语句将null检查与const_oop()检查混合在单行中，可能导致空指针解引用。", "optimized_code": "-  if (opr == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n-      !opr->is_con() || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n+  if (opr          == nullptr || !opr->is_con() ||\n+      vector_klass == nullptr || vector_klass->const_oop() == nullptr ||\n+      elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||\n+      vlen         == nullptr || !vlen->is_con()) {", "source_url": "https://github.com/openjdk/riscv-port/commit/ca7b885873712a5ae503cb82c915d709034a69f7", "code_v0_no_empty_lines": "多个Vector API内在函数的输入检查存在逻辑缺陷，条件判断语句将null检查与const_oop()检查混合在单行中，可能导致空指针解引用。", "code_v1_no_empty_lines": "-  if (opr == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n-      !opr->is_con() || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n+  if (opr          == nullptr || !opr->is_con() ||\n+      vector_klass == nullptr || vector_klass->const_oop() == nullptr ||\n+      elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||\n+      vlen         == nullptr || !vlen->is_con()) {", "target": "-  if (opr == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n-      !opr->is_con() || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n+  if (opr          == nullptr || !opr->is_con() ||\n+      vector_klass == nullptr || vector_klass->const_oop() == nullptr ||\n+      elem_klass   == nullptr || elem_klass->const_oop()   == nullptr ||\n+      vlen         == nullptr || !vlen->is_con()) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多个Vector API内在函数的输入检查存在逻辑缺陷，条件判断语句将null检查与const_oop()检查混合在单行中，可能导致空指针解引用。优化后：重构条件判断逻辑，将每个变量的null检查和const_oop()检查分组排列，确保先检查指针非空再访问其成员，提高了代码的健壮性和安全性。优化思路：通过重新组织条件语句结构，消除潜在的空指针解引用风险，使代码更符合防御性编程原则。"}
{"id": 370, "source": "riscv-dataset-excel", "optimization_type": "循环优化+代码移动", "optimization_description": "优化前：Type节点无法从循环中下沉（sink），导致循环内保留不必要的类型检查计算。优化后：通过条件判断（KillPathsReachableByDeadTypeNode标志）允许Type节点下沉出循环，减少循环内计算开销。同时添加对raw-to-oop强制转换的检查，避免延长raw oop的生命周期。优化思路：将循环不变的类型检查移出循环体，减少每次迭代的计算量，提升循环执行效率。", "original_code": "Type节点无法从循环中下沉（sink），导致循环内保留不必要的类型检查计算。", "optimized_code": "bool is_raw_to_oop_cast = n->is_ConstraintCast() &&\n                            n->in(1)->bottom_type()->isa_rawptr() &&\n                            !n->bottom_type()->isa_rawptr();\n\nif (has_ctrl(n) &&\n      !n->is_Phi() &&\n      !n->is_Bool() &&\n      !n->is_CMove() &&\n      !n->is_ConstraintCast() &&\n      !n->is_Opaque1() &&\n      !n->is_Opaque2() &&\n      !n->is_OpaqueNotNull() &&\n      !n->is_OpaqueInitializedAssertionPredicate() &&\n      !n->is_OpaqueTemplateAssertionPredicate() &&\n      !is_raw_to_oop_cast && // don't extend live ranges of raw oops\n      (KillPathsReachableByDeadTypeNode || !n->is_Type())\n      ) {", "source_url": "https://github.com/openjdk/riscv-port/commit/a2f99fd88bd03337e1ba73b413ffe4e39f3584cf", "code_v0_no_empty_lines": "Type节点无法从循环中下沉（sink），导致循环内保留不必要的类型检查计算。", "code_v1_no_empty_lines": "bool is_raw_to_oop_cast = n->is_ConstraintCast() &&\n                            n->in(1)->bottom_type()->isa_rawptr() &&\n                            !n->bottom_type()->isa_rawptr();\n\nif (has_ctrl(n) &&\n      !n->is_Phi() &&\n      !n->is_Bool() &&\n      !n->is_CMove() &&\n      !n->is_ConstraintCast() &&\n      !n->is_Opaque1() &&\n      !n->is_Opaque2() &&\n      !n->is_OpaqueNotNull() &&\n      !n->is_OpaqueInitializedAssertionPredicate() &&\n      !n->is_OpaqueTemplateAssertionPredicate() &&\n      !is_raw_to_oop_cast && // don't extend live ranges of raw oops\n      (KillPathsReachableByDeadTypeNode || !n->is_Type())\n      ) {", "target": "bool is_raw_to_oop_cast = n->is_ConstraintCast() &&\n                            n->in(1)->bottom_type()->isa_rawptr() &&\n                            !n->bottom_type()->isa_rawptr();\n\nif (has_ctrl(n) &&\n      !n->is_Phi() &&\n      !n->is_Bool() &&\n      !n->is_CMove() &&\n      !n->is_ConstraintCast() &&\n      !n->is_Opaque1() &&\n      !n->is_Opaque2() &&\n      !n->is_OpaqueNotNull() &&\n      !n->is_OpaqueInitializedAssertionPredicate() &&\n      !n->is_OpaqueTemplateAssertionPredicate() &&\n      !is_raw_to_oop_cast && // don't extend live ranges of raw oops\n      (KillPathsReachableByDeadTypeNode || !n->is_Type())\n      ) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Type节点无法从循环中下沉（sink），导致循环内保留不必要的类型检查计算。优化后：通过条件判断（KillPathsReachableByDeadTypeNode标志）允许Type节点下沉出循环，减少循环内计算开销。同时添加对raw-to-oop强制转换的检查，避免延长raw oop的生命周期。优化思路：将循环不变的类型检查移出循环体，减少每次迭代的计算量，提升循环执行效率。"}
{"id": 371, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化+查找性能优化", "optimization_description": "优化前：字段查找通过线性扫描FieldInfoStream数组，时间复杂度为O(n)。优化后：引入PackedTable作为搜索表（fieldinfo_search_table），实现O(1)或O(log n)的快速字段查找。关键修改包括：1）在ClassFileParser中创建并存储搜索表；2）更新AllFieldStream构造函数直接使用InstanceKlass；3）在类重定义时同步更新搜索表。这解决了字段访问的性能回归问题。", "original_code": "字段查找通过线性扫描FieldInfoStream数组，时间复杂度为O(n)。", "optimized_code": "+  _fieldinfo_search_table = FieldInfoStream::create_search_table(_cp, _fieldinfo_stream, _loader_data, CHECK);\n+  ik->set_fieldinfo_search_table(search_table);\n-  for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(ik); !fs.done(); fs.next()) {", "source_url": "https://github.com/openjdk/riscv-port/commit/e18277b470a162b9668297e8e286c812c4b0b604", "code_v0_no_empty_lines": "字段查找通过线性扫描FieldInfoStream数组，时间复杂度为O(n)。", "code_v1_no_empty_lines": "+  _fieldinfo_search_table = FieldInfoStream::create_search_table(_cp, _fieldinfo_stream, _loader_data, CHECK);\n+  ik->set_fieldinfo_search_table(search_table);\n-  for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(ik); !fs.done(); fs.next()) {", "target": "+  _fieldinfo_search_table = FieldInfoStream::create_search_table(_cp, _fieldinfo_stream, _loader_data, CHECK);\n+  ik->set_fieldinfo_search_table(search_table);\n-  for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(ik); !fs.done(); fs.next()) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：字段查找通过线性扫描FieldInfoStream数组，时间复杂度为O(n)。优化后：引入PackedTable作为搜索表（fieldinfo_search_table），实现O(1)或O(log n)的快速字段查找。关键修改包括：1）在ClassFileParser中创建并存储搜索表；2）更新AllFieldStream构造函数直接使用InstanceKlass；3）在类重定义时同步更新搜索表。这解决了字段访问的性能回归问题。"}
{"id": 372, "source": "riscv-dataset-excel", "optimization_type": "代码简化+性能优化", "optimization_description": "优化前：CharBuffer.append方法中对String、StringBuilder、StringBuffer类型进行instanceof检查，分别调用各自的getChars方法。优化后：直接调用CharSequence接口的getChars方法，利用多态特性。优化思路：移除冗余的类型检查，简化代码逻辑，减少分支预测开销，同时保持功能不变。", "original_code": "CharBuffer.append方法中对String、StringBuilder、StringBuffer类型进行instanceof检查，分别调用各自的getChars方法。", "optimized_code": "- if (csq instanceof String str) {\n    str.getChars(start, start + count, buf, 0);\n} else if (csq instanceof StringBuilder sb) {\n    sb.getChars(start, start + count, buf, 0);\n} else if (csq instanceof StringBuffer sb) {\n    sb.getChars(start, start + count, buf, 0);\n}\n+ csq.getChars(start, start + count, buf, 0);", "source_url": "https://github.com/openjdk/riscv-port/commit/0dd7c69b9e4307e6e8f290b84828f6de8a79e644", "code_v0_no_empty_lines": "CharBuffer.append方法中对String、StringBuilder、StringBuffer类型进行instanceof检查，分别调用各自的getChars方法。", "code_v1_no_empty_lines": "- if (csq instanceof String str) {\n    str.getChars(start, start + count, buf, 0);\n} else if (csq instanceof StringBuilder sb) {\n    sb.getChars(start, start + count, buf, 0);\n} else if (csq instanceof StringBuffer sb) {\n    sb.getChars(start, start + count, buf, 0);\n}\n+ csq.getChars(start, start + count, buf, 0);", "target": "- if (csq instanceof String str) {\n    str.getChars(start, start + count, buf, 0);\n} else if (csq instanceof StringBuilder sb) {\n    sb.getChars(start, start + count, buf, 0);\n} else if (csq instanceof StringBuffer sb) {\n    sb.getChars(start, start + count, buf, 0);\n}\n+ csq.getChars(start, start + count, buf, 0);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CharBuffer.append方法中对String、StringBuilder、StringBuffer类型进行instanceof检查，分别调用各自的getChars方法。优化后：直接调用CharSequence接口的getChars方法，利用多态特性。优化思路：移除冗余的类型检查，简化代码逻辑，减少分支预测开销，同时保持功能不变。"}
{"id": 373, "source": "riscv-dataset-excel", "optimization_type": "类型系统优化+范围推断优化", "optimization_description": "优化前：TypeInt/Long类型系统缺少无符号边界和已知位信息，导致编译器无法精确推断整数变量的取值范围和位模式，限制了优化机会。\n优化后：为TypeInt/Long类型添加无符号边界和已知位信息，实现新的范围推断系统（rangeinference），通过更精确的类型信息消除冗余检查、优化转换操作。\n优化思路：扩展类型系统以捕获更多语义信息，通过静态分析推断变量的可能取值范围和位模式，基于这些信息进行更激进的优化，如消除不必要的边界检查、优化整数转换、改进常量折叠等。", "original_code": "TypeInt/Long类型系统缺少无符号边界和已知位信息，导致编译器无法精确推断整数变量的取值范围和位模式，限制了优化机会。", "optimized_code": "新增文件: src/hotspot/share/opto/rangeinference.cpp\n新增文件: src/hotspot/share/opto/rangeinference.hpp\n新增文件: src/hotspot/share/utilities/intn_t.hpp\n修改: src/hotspot/share/opto/type.cpp (716行修改)\n修改: src/hotspot/share/opto/type.hpp (330行修改)\n关键代码片段:\n- const TypeInteger* this_type = this->type()->is_integer(bt);\n+ const TypeInteger* this_type = this->type()->isa_integer(bt);\n+ if (this_type == nullptr) {\n+   return nullptr;\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/991097b7bf08cc1a4ceedb0c555b12948ae71885", "code_v0_no_empty_lines": "TypeInt/Long类型系统缺少无符号边界和已知位信息，导致编译器无法精确推断整数变量的取值范围和位模式，限制了优化机会。", "code_v1_no_empty_lines": "新增文件: src/hotspot/share/opto/rangeinference.cpp\n新增文件: src/hotspot/share/opto/rangeinference.hpp\n新增文件: src/hotspot/share/utilities/intn_t.hpp\n修改: src/hotspot/share/opto/type.cpp (716行修改)\n修改: src/hotspot/share/opto/type.hpp (330行修改)\n关键代码片段:\n- const TypeInteger* this_type = this->type()->is_integer(bt);\n+ const TypeInteger* this_type = this->type()->isa_integer(bt);\n+ if (this_type == nullptr) {\n+   return nullptr;\n+ }", "target": "新增文件: src/hotspot/share/opto/rangeinference.cpp\n新增文件: src/hotspot/share/opto/rangeinference.hpp\n新增文件: src/hotspot/share/utilities/intn_t.hpp\n修改: src/hotspot/share/opto/type.cpp (716行修改)\n修改: src/hotspot/share/opto/type.hpp (330行修改)\n关键代码片段:\n- const TypeInteger* this_type = this->type()->is_integer(bt);\n+ const TypeInteger* this_type = this->type()->isa_integer(bt);\n+ if (this_type == nullptr) {\n+   return nullptr;\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：TypeInt/Long类型系统缺少无符号边界和已知位信息，导致编译器无法精确推断整数变量的取值范围和位模式，限制了优化机会。\n优化后：为TypeInt/Long类型添加无符号边界和已知位信息，实现新的范围推断系统（rangeinference），通过更精确的类型信息消除冗余检查、优化转换操作。\n优化思路：扩展类型系统以捕获更多语义信息，通过静态分析推断变量的可能取值范围和位模式，基于这些信息进行更激进的优化，如消除不必要的边界检查、优化整数转换、改进常量折叠等。"}
{"id": 374, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前：在JNI调用期间的安全点轮询中，当acquire参数为true时会插入获取内存屏障（LoadLoad|LoadStore），以确保后续对全局SafepointSynchronize::_state标志的加载有序。优化后：移除了acquire参数及相关内存屏障，因为在RISC-V架构下，JNI调用期间的安全点轮询不需要额外的获取屏障，线程本地轮询字的加载本身已提供足够的内存顺序保证。优化思路：基于RISC-V内存模型特性，简化代码并消除不必要的内存屏障开销，提升JNI调用性能。", "original_code": "在JNI调用期间的安全点轮询中，当acquire参数为true时会插入获取内存屏障（LoadLoad|LoadStore），以确保后续对全局SafepointSynchronize::_state标志的加载有序。", "optimized_code": "-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp_reg) {\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp_reg) {\n   ld(tmp_reg, Address(xthread, JavaThread::polling_word_offset()));\n-  if (acquire) {\n-    membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n-  }", "source_url": "https://github.com/openjdk/riscv-port/commit/1a01839f8c0522a90710e101cce6ecc479a77529", "code_v0_no_empty_lines": "在JNI调用期间的安全点轮询中，当acquire参数为true时会插入获取内存屏障（LoadLoad|LoadStore），以确保后续对全局SafepointSynchronize::_state标志的加载有序。", "code_v1_no_empty_lines": "-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp_reg) {\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp_reg) {\n   ld(tmp_reg, Address(xthread, JavaThread::polling_word_offset()));\n-  if (acquire) {\n-    membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n-  }", "target": "-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp_reg) {\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp_reg) {\n   ld(tmp_reg, Address(xthread, JavaThread::polling_word_offset()));\n-  if (acquire) {\n-    membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n-  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在JNI调用期间的安全点轮询中，当acquire参数为true时会插入获取内存屏障（LoadLoad|LoadStore），以确保后续对全局SafepointSynchronize::_state标志的加载有序。优化后：移除了acquire参数及相关内存屏障，因为在RISC-V架构下，JNI调用期间的安全点轮询不需要额外的获取屏障，线程本地轮询字的加载本身已提供足够的内存顺序保证。优化思路：基于RISC-V内存模型特性，简化代码并消除不必要的内存屏障开销，提升JNI调用性能。"}
{"id": 375, "source": "riscv-dataset-excel", "optimization_type": "代码精简与寄存器定义优化", "optimization_description": "优化前：在PPC64架构的寄存器定义文件中，为每个向量标量寄存器（VSR）定义了多个冗余的寄存器条目（如VSR0、VSR0_H、VSR0_J、VSR0_K），导致代码臃肿且维护复杂。优化后：移除了大量冗余的VSR寄存器定义，改为使用注释说明VSR与FPR的别名关系，同时将is_VectorSRegister()检查统一为is_VectorRegister()并添加类型转换。优化思路：通过减少不必要的寄存器定义来简化代码结构，降低编译器处理开销，提高代码可维护性，同时保持功能不变。", "original_code": "在PPC64架构的寄存器定义文件中，为每个向量标量寄存器（VSR）定义了多个冗余的寄存器条目（如VSR0、VSR0_H、VSR0_J、VSR0_K），导致代码臃肿且维护复杂。", "optimized_code": "-  reg_def VSR0   (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_H (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_J (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_K (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n+  // 1st 32 VSRs are aliases for the FPRs which are already defined above.", "source_url": "https://github.com/openjdk/riscv-port/commit/a08208283bcfe395c9962c8de3ba19fdd8cab985", "code_v0_no_empty_lines": "在PPC64架构的寄存器定义文件中，为每个向量标量寄存器（VSR）定义了多个冗余的寄存器条目（如VSR0、VSR0_H、VSR0_J、VSR0_K），导致代码臃肿且维护复杂。", "code_v1_no_empty_lines": "-  reg_def VSR0   (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_H (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_J (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_K (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n+  // 1st 32 VSRs are aliases for the FPRs which are already defined above.", "target": "-  reg_def VSR0   (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_H (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_J (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_K (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n+  // 1st 32 VSRs are aliases for the FPRs which are already defined above.", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在PPC64架构的寄存器定义文件中，为每个向量标量寄存器（VSR）定义了多个冗余的寄存器条目（如VSR0、VSR0_H、VSR0_J、VSR0_K），导致代码臃肿且维护复杂。优化后：移除了大量冗余的VSR寄存器定义，改为使用注释说明VSR与FPR的别名关系，同时将is_VectorSRegister()检查统一为is_VectorRegister()并添加类型转换。优化思路：通过减少不必要的寄存器定义来简化代码结构，降低编译器处理开销，提高代码可维护性，同时保持功能不变。"}
{"id": 376, "source": "riscv-dataset-excel", "optimization_type": "指令优化+内存屏障优化", "optimization_description": "优化前：safepoint_poll函数包含acquire参数，当acquire为true时使用ldar（加载-获取）指令进行内存屏障操作。优化后：移除acquire参数及相关条件分支，统一使用ldr（普通加载）指令。优化思路：在AArch64架构的FFM（Foreign Function & Memory）场景下，Java线程在安全点轮询时总是自行解除武装，无需获取语义的内存屏障，移除冗余的acquire检查可减少指令执行和分支预测开销，提升性能。", "original_code": "safepoint_poll函数包含acquire参数，当acquire为true时使用ldar（加载-获取）指令进行内存屏障操作。", "optimized_code": "-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp) {\n-  if (acquire) {\n-    lea(tmp, Address(rthread, JavaThread::polling_word_offset()));\n-    ldar(tmp, tmp);\n-  } else {\n-    ldr(tmp, Address(rthread, JavaThread::polling_word_offset()));\n-  }\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp) {\n+  ldr(tmp, Address(rthread, JavaThread::polling_word_offset()));", "source_url": "https://github.com/openjdk/riscv-port/commit/c1deb9eebf1adecffe5b205486477009ec2f7348", "code_v0_no_empty_lines": "safepoint_poll函数包含acquire参数，当acquire为true时使用ldar（加载-获取）指令进行内存屏障操作。", "code_v1_no_empty_lines": "-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp) {\n-  if (acquire) {\n-    lea(tmp, Address(rthread, JavaThread::polling_word_offset()));\n-    ldar(tmp, tmp);\n-  } else {\n-    ldr(tmp, Address(rthread, JavaThread::polling_word_offset()));\n-  }\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp) {\n+  ldr(tmp, Address(rthread, JavaThread::polling_word_offset()));", "target": "-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp) {\n-  if (acquire) {\n-    lea(tmp, Address(rthread, JavaThread::polling_word_offset()));\n-    ldar(tmp, tmp);\n-  } else {\n-    ldr(tmp, Address(rthread, JavaThread::polling_word_offset()));\n-  }\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp) {\n+  ldr(tmp, Address(rthread, JavaThread::polling_word_offset()));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：safepoint_poll函数包含acquire参数，当acquire为true时使用ldar（加载-获取）指令进行内存屏障操作。优化后：移除acquire参数及相关条件分支，统一使用ldr（普通加载）指令。优化思路：在AArch64架构的FFM（Foreign Function & Memory）场景下，Java线程在安全点轮询时总是自行解除武装，无需获取语义的内存屏障，移除冗余的acquire检查可减少指令执行和分支预测开销，提升性能。"}
{"id": 377, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+性能优化", "optimization_description": "优化前：静态调用存根（static call stub）总是生成远跳转指令序列（8条指令），包括movptr加载目标地址和br跳转，即使在小代码缓存场景下也使用相同指令序列。优化后：根据代码缓存大小判断，当代码缓存较小（≤250MB）时，使用直接分支指令（b指令）替代远跳转序列，将指令数从8条减少到5条。优化思路：在小代码缓存场景下，目标地址在分支指令的偏移范围内，可以直接使用b指令跳转，避免了加载目标地址的额外指令，减少了代码大小和分支延迟，提高了性能。", "original_code": "静态调用存根（static call stub）总是生成远跳转指令序列（8条指令），包括movptr加载目标地址和br跳转，即使在小代码缓存场景下也使用相同指令序列。", "optimized_code": "--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp\n+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp\n@@ -984,11 +984,19 @@ void MacroAssembler::emit_static_call_stub() {\n   mov_metadata(rmethod, nullptr);\n \n   // Jump to the entry point of the c2i stub.\n-  movptr(rscratch1, 0);\n-  br(rscratch1);\n+  if (codestub_branch_needs_far_jump()) {\n+    movptr(rscratch1, 0);\n+    br(rscratch1);\n+  } else {\n+    b(pc());\n+  }\n }\n \n int MacroAssembler::static_call_stub_size() {\n+  if (!codestub_branch_needs_far_jump()) {\n+    // isb; movk; movz; movz; b\n+    return 5 * NativeInstruction::instruction_size;\n+  }\n   // isb; movk; movz; movz; movk; movz; movz; br\n   return 8 * NativeInstruction::instruction_size;\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/ba32b78bfaf83f69003f83333ab6975b35343fde", "code_v0_no_empty_lines": "静态调用存根（static call stub）总是生成远跳转指令序列（8条指令），包括movptr加载目标地址和br跳转，即使在小代码缓存场景下也使用相同指令序列。", "code_v1_no_empty_lines": "--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp\n+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp\n@@ -984,11 +984,19 @@ void MacroAssembler::emit_static_call_stub() {\n   mov_metadata(rmethod, nullptr);\n \n   // Jump to the entry point of the c2i stub.\n-  movptr(rscratch1, 0);\n-  br(rscratch1);\n+  if (codestub_branch_needs_far_jump()) {\n+    movptr(rscratch1, 0);\n+    br(rscratch1);\n+  } else {\n+    b(pc());\n+  }\n }\n \n int MacroAssembler::static_call_stub_size() {\n+  if (!codestub_branch_needs_far_jump()) {\n+    // isb; movk; movz; movz; b\n+    return 5 * NativeInstruction::instruction_size;\n+  }\n   // isb; movk; movz; movz; movk; movz; movz; br\n   return 8 * NativeInstruction::instruction_size;\n }", "target": "--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp\n+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp\n@@ -984,11 +984,19 @@ void MacroAssembler::emit_static_call_stub() {\n   mov_metadata(rmethod, nullptr);\n \n   // Jump to the entry point of the c2i stub.\n-  movptr(rscratch1, 0);\n-  br(rscratch1);\n+  if (codestub_branch_needs_far_jump()) {\n+    movptr(rscratch1, 0);\n+    br(rscratch1);\n+  } else {\n+    b(pc());\n+  }\n }\n \n int MacroAssembler::static_call_stub_size() {\n+  if (!codestub_branch_needs_far_jump()) {\n+    // isb; movk; movz; movz; b\n+    return 5 * NativeInstruction::instruction_size;\n+  }\n   // isb; movk; movz; movz; movk; movz; movz; br\n   return 8 * NativeInstruction::instruction_size;\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：静态调用存根（static call stub）总是生成远跳转指令序列（8条指令），包括movptr加载目标地址和br跳转，即使在小代码缓存场景下也使用相同指令序列。优化后：根据代码缓存大小判断，当代码缓存较小（≤250MB）时，使用直接分支指令（b指令）替代远跳转序列，将指令数从8条减少到5条。优化思路：在小代码缓存场景下，目标地址在分支指令的偏移范围内，可以直接使用b指令跳转，避免了加载目标地址的额外指令，减少了代码大小和分支延迟，提高了性能。"}
{"id": 379, "source": "riscv-dataset-excel", "optimization_type": "循环优化+内存优化", "optimization_description": "优化前：在strip mining循环展开时，当store操作从内层循环下沉到外层循环后，C2编译器未能正确处理这些下沉的store节点，导致外层循环缺少必要的Phi节点或Phi节点连接不正确，违反C2 IR规则。优化后：新增了两个关键方法：1) fix_sunk_stores_when_back_to_counted_loop() 用于在循环优化阶段处理下沉的store链；2) handle_sunk_stores_when_finishing_construction() 用于在完成外层循环构造时专门处理下沉的store节点。优化思路：通过识别下沉到外层循环的store节点链，为每个内存切片正确添加外层循环Phi节点，并确保Phi节点的backedge输入正确连接到外层循环中的最后一个store操作，从而保证strip mining优化后IR的正确性和性能。", "original_code": "在strip mining循环展开时，当store操作从内层循环下沉到外层循环后，C2编译器未能正确处理这些下沉的store节点，导致外层循环缺少必要的Phi节点或Phi节点连接不正确，违反C2 IR规则。", "optimized_code": "void OuterStripMinedLoopNode::fix_sunk_stores_when_back_to_counted_loop(PhaseIterGVN* igvn,\n                                                                        PhaseIdealLoop* iloop) const {\n  CountedLoopNode* inner_cl = inner_counted_loop();\n  IfFalseNode* cle_out = inner_loop_exit();\n\n  if (cle_out->outcnt() > 1) {\n    // Look for chains of stores that were sunk\n    // out of the inner loop and are in the outer loop\n    // ...\n  }\n}\n\nvoid OuterStripMinedLoopNode::handle_sunk_stores_when_finishing_construction(PhaseIterGVN* igvn) {\n  IfFalseNode* cle_exit_proj = inner_loop_exit();\n\n  // Find Sunk stores: Sunk stores are pinned on the loop exit", "source_url": "https://github.com/openjdk/riscv-port/commit/c11f36e6200b6c39fd59530f28e9318c4153db49", "code_v0_no_empty_lines": "在strip mining循环展开时，当store操作从内层循环下沉到外层循环后，C2编译器未能正确处理这些下沉的store节点，导致外层循环缺少必要的Phi节点或Phi节点连接不正确，违反C2 IR规则。", "code_v1_no_empty_lines": "void OuterStripMinedLoopNode::fix_sunk_stores_when_back_to_counted_loop(PhaseIterGVN* igvn,\n                                                                        PhaseIdealLoop* iloop) const {\n  CountedLoopNode* inner_cl = inner_counted_loop();\n  IfFalseNode* cle_out = inner_loop_exit();\n\n  if (cle_out->outcnt() > 1) {\n    // Look for chains of stores that were sunk\n    // out of the inner loop and are in the outer loop\n    // ...\n  }\n}\n\nvoid OuterStripMinedLoopNode::handle_sunk_stores_when_finishing_construction(PhaseIterGVN* igvn) {\n  IfFalseNode* cle_exit_proj = inner_loop_exit();\n\n  // Find Sunk stores: Sunk stores are pinned on the loop exit", "target": "void OuterStripMinedLoopNode::fix_sunk_stores_when_back_to_counted_loop(PhaseIterGVN* igvn,\n                                                                        PhaseIdealLoop* iloop) const {\n  CountedLoopNode* inner_cl = inner_counted_loop();\n  IfFalseNode* cle_out = inner_loop_exit();\n\n  if (cle_out->outcnt() > 1) {\n    // Look for chains of stores that were sunk\n    // out of the inner loop and are in the outer loop\n    // ...\n  }\n}\n\nvoid OuterStripMinedLoopNode::handle_sunk_stores_when_finishing_construction(PhaseIterGVN* igvn) {\n  IfFalseNode* cle_exit_proj = inner_loop_exit();\n\n  // Find Sunk stores: Sunk stores are pinned on the loop exit", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在strip mining循环展开时，当store操作从内层循环下沉到外层循环后，C2编译器未能正确处理这些下沉的store节点，导致外层循环缺少必要的Phi节点或Phi节点连接不正确，违反C2 IR规则。优化后：新增了两个关键方法：1) fix_sunk_stores_when_back_to_counted_loop() 用于在循环优化阶段处理下沉的store链；2) handle_sunk_stores_when_finishing_construction() 用于在完成外层循环构造时专门处理下沉的store节点。优化思路：通过识别下沉到外层循环的store节点链，为每个内存切片正确添加外层循环Phi节点，并确保Phi节点的backedge输入正确连接到外层循环中的最后一个store操作，从而保证strip mining优化后IR的正确性和性能。"}
{"id": 380, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+内存对齐优化", "optimization_description": "优化前：在arraycopy运行时调用选择中，对齐检查仅考虑元素偏移量，忽略了数组对象头部的base offset，导致在某些情况下错误判断对齐状态，可能选择次优的arraycopy函数。优化后：在计算内存地址对齐时，同时考虑base offset和元素偏移量，确保准确判断内存对齐状态，从而选择更高效的arraycopy运行时函数（如使用SIMD指令的优化版本）。优化思路：修复对齐检查逻辑，确保在计算内存地址时包含完整的对象布局信息，提高arraycopy操作的性能。", "original_code": "在arraycopy运行时调用选择中，对齐检查仅考虑元素偏移量，忽略了数组对象头部的base offset，导致在某些情况下错误判断对齐状态，可能选择次优的arraycopy函数。", "optimized_code": "- bool aligned = toffset->is_con() && ((toffset->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+ bool aligned = (arrayOopDesc::base_offset_in_bytes(T_BYTE) % HeapWordSize == 0);\n+ if (aligned) {\n+   const TypeInt* toffset = gvn().type(offset)->is_int();\n+   aligned = toffset->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_CHAR) +\n+                                    toffset->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/6b4393917ae689818d67fcaf9cc61ca16ea6d426", "code_v0_no_empty_lines": "在arraycopy运行时调用选择中，对齐检查仅考虑元素偏移量，忽略了数组对象头部的base offset，导致在某些情况下错误判断对齐状态，可能选择次优的arraycopy函数。", "code_v1_no_empty_lines": "- bool aligned = toffset->is_con() && ((toffset->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+ bool aligned = (arrayOopDesc::base_offset_in_bytes(T_BYTE) % HeapWordSize == 0);\n+ if (aligned) {\n+   const TypeInt* toffset = gvn().type(offset)->is_int();\n+   aligned = toffset->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_CHAR) +\n+                                    toffset->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+ }", "target": "- bool aligned = toffset->is_con() && ((toffset->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+ bool aligned = (arrayOopDesc::base_offset_in_bytes(T_BYTE) % HeapWordSize == 0);\n+ if (aligned) {\n+   const TypeInt* toffset = gvn().type(offset)->is_int();\n+   aligned = toffset->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_CHAR) +\n+                                    toffset->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在arraycopy运行时调用选择中，对齐检查仅考虑元素偏移量，忽略了数组对象头部的base offset，导致在某些情况下错误判断对齐状态，可能选择次优的arraycopy函数。优化后：在计算内存地址对齐时，同时考虑base offset和元素偏移量，确保准确判断内存对齐状态，从而选择更高效的arraycopy运行时函数（如使用SIMD指令的优化版本）。优化思路：修复对齐检查逻辑，确保在计算内存地址时包含完整的对象布局信息，提高arraycopy操作的性能。"}
{"id": 381, "source": "riscv-dataset-excel", "optimization_type": "代码简化+性能优化", "optimization_description": "优化前：profile_taken_branch函数需要两个寄存器参数（mdp和bumped_count），手动加载分支计数、检查溢出并存储，代码复杂且需要额外的寄存器。优化后：简化函数签名为单个mdp参数，重用现有的increment_mdp_data_at函数处理计数递增，减少了代码行数、寄存器使用和指令数量。优化思路：消除冗余代码，统一使用现有的计数递增工具函数，提高代码可维护性和执行效率。", "original_code": "profile_taken_branch函数需要两个寄存器参数（mdp和bumped_count），手动加载分支计数、检查溢出并存储，代码复杂且需要额外的寄存器。", "optimized_code": "-void InterpreterMacroAssembler::profile_taken_branch(Register mdp,\n-                                                     Register bumped_count) {\n+void InterpreterMacroAssembler::profile_taken_branch(Register mdp) {\n   if (ProfileInterpreter) {\n     Label profile_continue;\n \n     // If no method data exists, go to profile_continue.\n-    // Otherwise, assign to mdp\n     test_method_data_pointer(mdp, profile_continue);\n \n     // We are taking a branch.  Increment the taken count.\n-    Address data(mdp, in_bytes(JumpData::taken_offset()));\n-    ld(bumped_count, data);\n-    assert(DataLayout::counter_increment == 1,\n-            \"flow-free idiom only works with 1\");\n-    addi(bumped_count, bumped_count, DataLayout::counter_increment);\n-    Label L;\n-    // eg: bumped_count=0x7fff ffff ffff ffff  + 1 < 0. so we use <= 0;\n-    blez(bumped_count, L);       // skip store if counter overflow,\n-    sd(bumped_count, data);\n-    bind(L);\n+    increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));", "source_url": "https://github.com/openjdk/riscv-port/commit/620df7ec348598580884e3b9d45066495f0c40e5", "code_v0_no_empty_lines": "profile_taken_branch函数需要两个寄存器参数（mdp和bumped_count），手动加载分支计数、检查溢出并存储，代码复杂且需要额外的寄存器。", "code_v1_no_empty_lines": "-void InterpreterMacroAssembler::profile_taken_branch(Register mdp,\n-                                                     Register bumped_count) {\n+void InterpreterMacroAssembler::profile_taken_branch(Register mdp) {\n   if (ProfileInterpreter) {\n     Label profile_continue;\n \n     // If no method data exists, go to profile_continue.\n-    // Otherwise, assign to mdp\n     test_method_data_pointer(mdp, profile_continue);\n \n     // We are taking a branch.  Increment the taken count.\n-    Address data(mdp, in_bytes(JumpData::taken_offset()));\n-    ld(bumped_count, data);\n-    assert(DataLayout::counter_increment == 1,\n-            \"flow-free idiom only works with 1\");\n-    addi(bumped_count, bumped_count, DataLayout::counter_increment);\n-    Label L;\n-    // eg: bumped_count=0x7fff ffff ffff ffff  + 1 < 0. so we use <= 0;\n-    blez(bumped_count, L);       // skip store if counter overflow,\n-    sd(bumped_count, data);\n-    bind(L);\n+    increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));", "target": "-void InterpreterMacroAssembler::profile_taken_branch(Register mdp,\n-                                                     Register bumped_count) {\n+void InterpreterMacroAssembler::profile_taken_branch(Register mdp) {\n   if (ProfileInterpreter) {\n     Label profile_continue;\n \n     // If no method data exists, go to profile_continue.\n-    // Otherwise, assign to mdp\n     test_method_data_pointer(mdp, profile_continue);\n \n     // We are taking a branch.  Increment the taken count.\n-    Address data(mdp, in_bytes(JumpData::taken_offset()));\n-    ld(bumped_count, data);\n-    assert(DataLayout::counter_increment == 1,\n-            \"flow-free idiom only works with 1\");\n-    addi(bumped_count, bumped_count, DataLayout::counter_increment);\n-    Label L;\n-    // eg: bumped_count=0x7fff ffff ffff ffff  + 1 < 0. so we use <= 0;\n-    blez(bumped_count, L);       // skip store if counter overflow,\n-    sd(bumped_count, data);\n-    bind(L);\n+    increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：profile_taken_branch函数需要两个寄存器参数（mdp和bumped_count），手动加载分支计数、检查溢出并存储，代码复杂且需要额外的寄存器。优化后：简化函数签名为单个mdp参数，重用现有的increment_mdp_data_at函数处理计数递增，减少了代码行数、寄存器使用和指令数量。优化思路：消除冗余代码，统一使用现有的计数递增工具函数，提高代码可维护性和执行效率。"}
{"id": 382, "source": "riscv-dataset-excel", "optimization_type": "循环优化", "optimization_description": "优化前：C2编译器在识别计数循环时，如果循环归纳变量（IV）被类型转换节点（CastII/CastLL）包裹，只能处理单层转换，导致无法识别为计数循环，从而错过循环优化机会。优化后：通过将单次判断改为while循环，迭代地去除归纳变量上的所有类型转换节点，使编译器能够识别包含多层类型转换的计数循环。优化思路：扩展计数循环识别逻辑，处理归纳变量上的嵌套类型转换，从而应用循环展开、向量化等优化。", "original_code": "C2编译器在识别计数循环时，如果循环归纳变量（IV）被类型转换节点（CastII/CastLL）包裹，只能处理单层转换，导致无法识别为计数循环，从而错过循环优化机会。", "optimized_code": "-  if (xphi->Opcode() == Op_Cast(iv_bt)) {\n+  // Iteratively uncast the loop induction variable\n+  // until no more CastII/CastLL nodes are found.\n+  while (xphi->Opcode() == Op_Cast(iv_bt)) {", "source_url": "https://github.com/openjdk/riscv-port/commit/7d6c902ce8ffb9b42c264ecff56d4b54206e101b", "code_v0_no_empty_lines": "C2编译器在识别计数循环时，如果循环归纳变量（IV）被类型转换节点（CastII/CastLL）包裹，只能处理单层转换，导致无法识别为计数循环，从而错过循环优化机会。", "code_v1_no_empty_lines": "-  if (xphi->Opcode() == Op_Cast(iv_bt)) {\n+  // Iteratively uncast the loop induction variable\n+  // until no more CastII/CastLL nodes are found.\n+  while (xphi->Opcode() == Op_Cast(iv_bt)) {", "target": "-  if (xphi->Opcode() == Op_Cast(iv_bt)) {\n+  // Iteratively uncast the loop induction variable\n+  // until no more CastII/CastLL nodes are found.\n+  while (xphi->Opcode() == Op_Cast(iv_bt)) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器在识别计数循环时，如果循环归纳变量（IV）被类型转换节点（CastII/CastLL）包裹，只能处理单层转换，导致无法识别为计数循环，从而错过循环优化机会。优化后：通过将单次判断改为while循环，迭代地去除归纳变量上的所有类型转换节点，使编译器能够识别包含多层类型转换的计数循环。优化思路：扩展计数循环识别逻辑，处理归纳变量上的嵌套类型转换，从而应用循环展开、向量化等优化。"}
{"id": 383, "source": "riscv-dataset-excel", "optimization_type": "内存分配优化", "optimization_description": "优化前：TLAB（线程本地分配缓冲区）大小默认较大，可能导致内存分配不均衡和启动性能问题。优化后：1) 在非分代模式下将TLABAllocationWeight设为90（原默认35），在分代模式下保持35；2) 设置默认TLABSize为区域大小的1/256或32KB中的较大值；3) 限制MaxTLABSize为区域大小的1/32或256KB中的较小值。优化思路：通过减小TLAB默认大小，改善启动行为，提高竞争线程间的内存分配公平性，减少内存碎片，同时保持分代模式原有的分配策略。", "original_code": "TLAB（线程本地分配缓冲区）大小默认较大，可能导致内存分配不均衡和启动性能问题。", "optimized_code": "1. src/hotspot/share/gc/shenandoah/shenandoahArguments.cpp:\n   - if (FLAG_IS_DEFAULT(TLABAllocationWeight)) {\n   + if (strcmp(ShenandoahGCMode, \"generational\") && FLAG_IS_DEFAULT(TLABAllocationWeight)) {\n   + // In generational mode, let TLABAllocationWeight keeps its default value of 35.\n   + if (FLAG_IS_DEFAULT(TLABSize)) {\n   +   TLABSize = MAX2(ShenandoahHeapRegion::region_size_bytes() / 256, (size_t) 32 * 1024);\n   + }\n\n2. src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp:\n   - MaxTLABSizeWords = align_down(RegionSizeWords, MinObjAlignment);\n   + MaxTLABSizeWords = align_down(MIN2(RegionSizeWords, MAX2(RegionSizeWords / 32, (size_t) (256 * 1024) / HeapWordSize)), MinObjAlignment);\n   + // Limit TLAB size for better startup behavior and more equitable distribution of memory between contending mutator threads.", "source_url": "https://github.com/openjdk/riscv-port/commit/a0c3efa6a80fe95e22faf5a732e42f1e1291fb4c", "code_v0_no_empty_lines": "TLAB（线程本地分配缓冲区）大小默认较大，可能导致内存分配不均衡和启动性能问题。", "code_v1_no_empty_lines": "1. src/hotspot/share/gc/shenandoah/shenandoahArguments.cpp:\n   - if (FLAG_IS_DEFAULT(TLABAllocationWeight)) {\n   + if (strcmp(ShenandoahGCMode, \"generational\") && FLAG_IS_DEFAULT(TLABAllocationWeight)) {\n   + // In generational mode, let TLABAllocationWeight keeps its default value of 35.\n   + if (FLAG_IS_DEFAULT(TLABSize)) {\n   +   TLABSize = MAX2(ShenandoahHeapRegion::region_size_bytes() / 256, (size_t) 32 * 1024);\n   + }\n\n2. src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp:\n   - MaxTLABSizeWords = align_down(RegionSizeWords, MinObjAlignment);\n   + MaxTLABSizeWords = align_down(MIN2(RegionSizeWords, MAX2(RegionSizeWords / 32, (size_t) (256 * 1024) / HeapWordSize)), MinObjAlignment);\n   + // Limit TLAB size for better startup behavior and more equitable distribution of memory between contending mutator threads.", "target": "1. src/hotspot/share/gc/shenandoah/shenandoahArguments.cpp:\n   - if (FLAG_IS_DEFAULT(TLABAllocationWeight)) {\n   + if (strcmp(ShenandoahGCMode, \"generational\") && FLAG_IS_DEFAULT(TLABAllocationWeight)) {\n   + // In generational mode, let TLABAllocationWeight keeps its default value of 35.\n   + if (FLAG_IS_DEFAULT(TLABSize)) {\n   +   TLABSize = MAX2(ShenandoahHeapRegion::region_size_bytes() / 256, (size_t) 32 * 1024);\n   + }\n\n2. src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp:\n   - MaxTLABSizeWords = align_down(RegionSizeWords, MinObjAlignment);\n   + MaxTLABSizeWords = align_down(MIN2(RegionSizeWords, MAX2(RegionSizeWords / 32, (size_t) (256 * 1024) / HeapWordSize)), MinObjAlignment);\n   + // Limit TLAB size for better startup behavior and more equitable distribution of memory between contending mutator threads.", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：TLAB（线程本地分配缓冲区）大小默认较大，可能导致内存分配不均衡和启动性能问题。优化后：1) 在非分代模式下将TLABAllocationWeight设为90（原默认35），在分代模式下保持35；2) 设置默认TLABSize为区域大小的1/256或32KB中的较大值；3) 限制MaxTLABSize为区域大小的1/32或256KB中的较小值。优化思路：通过减小TLAB默认大小，改善启动行为，提高竞争线程间的内存分配公平性，减少内存碎片，同时保持分代模式原有的分配策略。"}
{"id": 384, "source": "riscv-dataset-excel", "optimization_type": "常量折叠优化+指令选择优化", "optimization_description": "优化前：Float16操作涉及常量输入时，编译器需要先将常量从Float16提升到Float32进行计算，然后再将结果转换回Float16，这产生了额外的转换开销。优化后：编译器能够识别包含常量输入的Float16操作模式（ConvF2HF(binopF(conF, ConvHF2F(varS)))），并直接将其转换为Float16级别的操作（ReinterpretHF2SNode(binopHF(conHF, ReinterpretS2HFNode(varS)))），避免了中间转换。优化思路：通过模式匹配识别可优化的常量Float16操作图，在满足精度和NaN处理要求的前提下，直接在Float16精度下执行操作，减少类型转换开销，提高性能。", "original_code": "Float16操作涉及常量输入时，编译器需要先将常量从Float16提升到Float32进行计算，然后再将结果转换回Float16，这产生了额外的转换开销。", "optimized_code": "Node* ConvF2HFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n  // Detects following ideal graph pattern\n  //      ConvF2HF(binopF(conF, ConvHF2F(varS))) =>\n  //              ReinterpretHF2SNode(binopHF(conHF, ReinterpretS2HFNode(varS)))\n  if (Float16NodeFactory::is_float32_binary_oper(in(1)->Opcode())) {\n    Node* binopF = in(1);\n    // Check if the incoming binary operation has one floating point constant\n    // input and the other input is a half precision to single precision upcasting node.\n    // We land here because a prior HalfFloat to Float conversion promotes\n    // an integral constant holding Float16 value to a floating point constant.\n    // i.e. ConvHF2F ConI(short) => ConF\n    Node* conF = nullptr;\n    Node* varS = nullptr;\n    if (binopF->in(1)->is_Con() && binopF->in(2)->Opcode() == Op_ConvHF2F) {\n      conF = binopF->in(1);\n      varS = binopF->in(2)->in(1);\n    } else if (binopF->in(2)->is_Con() &&  binopF->in(1)->Opcode() == Op_ConvHF2F) {\n      conF = binopF->in(2);\n      varS = binopF->in(1)->in(1);\n    }\n\n    if (conF != nullptr &&\n        varS != nullptr &&\n        conF->bottom_type()->isa_float_constant() != nullptr &&\n        Matcher::match_rule_supported(Float16NodeFactory::get_float16_binary_oper(binopF->Opcode())) &&\n        Matcher::match_rule_supported(Op_ReinterpretS2HF) &&\n        Matcher::match_rule_supported(Op_ReinterpretHF2S) &&\n        StubRoutines::hf2f_adr() != nullptr &&\n        StubRoutines::f2hf_adr() != nullptr) {\n      jfloat con = conF->bottom_type()->getf();\n      // Conditions under which floating point constant can be considered for a pattern match.\n      // 1. conF must lie within Float16 value range, otherwise we would have rounding issues:\n      //    Doing the operation in float32 and then rounding is not the same as\n      //    rounding first and doing the operation in float16.\n      // 2. If a constant value is one of the valid IEEE 754 binary32 NaN bit patterns\n      // then it's safe to consider it for pattern match because of the following reasons:\n      //   a. As per section 2.8 of JVMS, Java Virtual Machine does not support\n      //   signaling NaN value.\n      //   b. Any signaling NaN which takes part in a non-comparison expression\n      //   results in a quiet NaN but preserves the significand bits of signaling NaN.\n      //   c. The pattern being matched includes a Float to Float16 conversion after binary\n      //   expression, this downcast will still preserve the significand bits of binary32 NaN.\n      bool isnan = g_isnan((jdouble)con);\n      if (StubRoutines::hf2f(StubRoutines::f2hf(con)) == con || isnan) {\n        Node* newVarHF = phase->transform(new ReinterpretS2HFNode(varS));\n        Node* conHF = phase->makecon(TypeH::make(con));\n        Node* binopHF = nullptr;\n        // Preserving original input order for semantic correctness\n        // of non-commutative operation.\n        if (binopF->in(1) == conF) {\n          binopHF = phase->transform(Float16NodeFactory::make(binopF->Opcode(), binopF->in(0), conHF, newVarHF));\n        } else {\n          binopHF = phase->transform(Float16NodeFactory::make(binopF->Opcode(), binopF->in(0), newVarHF, conHF));\n        }\n        return new ReinterpretHF2SNode(binopHF);\n      }\n    }\n  }\n\n  return nullptr;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/a49ecb26c5ff2f949851937f3bb036d7946a103e", "code_v0_no_empty_lines": "Float16操作涉及常量输入时，编译器需要先将常量从Float16提升到Float32进行计算，然后再将结果转换回Float16，这产生了额外的转换开销。", "code_v1_no_empty_lines": "Node* ConvF2HFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n  // Detects following ideal graph pattern\n  //      ConvF2HF(binopF(conF, ConvHF2F(varS))) =>\n  //              ReinterpretHF2SNode(binopHF(conHF, ReinterpretS2HFNode(varS)))\n  if (Float16NodeFactory::is_float32_binary_oper(in(1)->Opcode())) {\n    Node* binopF = in(1);\n    // Check if the incoming binary operation has one floating point constant\n    // input and the other input is a half precision to single precision upcasting node.\n    // We land here because a prior HalfFloat to Float conversion promotes\n    // an integral constant holding Float16 value to a floating point constant.\n    // i.e. ConvHF2F ConI(short) => ConF\n    Node* conF = nullptr;\n    Node* varS = nullptr;\n    if (binopF->in(1)->is_Con() && binopF->in(2)->Opcode() == Op_ConvHF2F) {\n      conF = binopF->in(1);\n      varS = binopF->in(2)->in(1);\n    } else if (binopF->in(2)->is_Con() &&  binopF->in(1)->Opcode() == Op_ConvHF2F) {\n      conF = binopF->in(2);\n      varS = binopF->in(1)->in(1);\n    }\n\n    if (conF != nullptr &&\n        varS != nullptr &&\n        conF->bottom_type()->isa_float_constant() != nullptr &&\n        Matcher::match_rule_supported(Float16NodeFactory::get_float16_binary_oper(binopF->Opcode())) &&\n        Matcher::match_rule_supported(Op_ReinterpretS2HF) &&\n        Matcher::match_rule_supported(Op_ReinterpretHF2S) &&\n        StubRoutines::hf2f_adr() != nullptr &&\n        StubRoutines::f2hf_adr() != nullptr) {\n      jfloat con = conF->bottom_type()->getf();\n      // Conditions under which floating point constant can be considered for a pattern match.\n      // 1. conF must lie within Float16 value range, otherwise we would have rounding issues:\n      //    Doing the operation in float32 and then rounding is not the same as\n      //    rounding first and doing the operation in float16.\n      // 2. If a constant value is one of the valid IEEE 754 binary32 NaN bit patterns\n      // then it's safe to consider it for pattern match because of the following reasons:\n      //   a. As per section 2.8 of JVMS, Java Virtual Machine does not support\n      //   signaling NaN value.\n      //   b. Any signaling NaN which takes part in a non-comparison expression\n      //   results in a quiet NaN but preserves the significand bits of signaling NaN.\n      //   c. The pattern being matched includes a Float to Float16 conversion after binary\n      //   expression, this downcast will still preserve the significand bits of binary32 NaN.\n      bool isnan = g_isnan((jdouble)con);\n      if (StubRoutines::hf2f(StubRoutines::f2hf(con)) == con || isnan) {\n        Node* newVarHF = phase->transform(new ReinterpretS2HFNode(varS));\n        Node* conHF = phase->makecon(TypeH::make(con));\n        Node* binopHF = nullptr;\n        // Preserving original input order for semantic correctness\n        // of non-commutative operation.\n        if (binopF->in(1) == conF) {\n          binopHF = phase->transform(Float16NodeFactory::make(binopF->Opcode(), binopF->in(0), conHF, newVarHF));\n        } else {\n          binopHF = phase->transform(Float16NodeFactory::make(binopF->Opcode(), binopF->in(0), newVarHF, conHF));\n        }\n        return new ReinterpretHF2SNode(binopHF);\n      }\n    }\n  }\n\n  return nullptr;\n}", "target": "Node* ConvF2HFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n  // Detects following ideal graph pattern\n  //      ConvF2HF(binopF(conF, ConvHF2F(varS))) =>\n  //              ReinterpretHF2SNode(binopHF(conHF, ReinterpretS2HFNode(varS)))\n  if (Float16NodeFactory::is_float32_binary_oper(in(1)->Opcode())) {\n    Node* binopF = in(1);\n    // Check if the incoming binary operation has one floating point constant\n    // input and the other input is a half precision to single precision upcasting node.\n    // We land here because a prior HalfFloat to Float conversion promotes\n    // an integral constant holding Float16 value to a floating point constant.\n    // i.e. ConvHF2F ConI(short) => ConF\n    Node* conF = nullptr;\n    Node* varS = nullptr;\n    if (binopF->in(1)->is_Con() && binopF->in(2)->Opcode() == Op_ConvHF2F) {\n      conF = binopF->in(1);\n      varS = binopF->in(2)->in(1);\n    } else if (binopF->in(2)->is_Con() &&  binopF->in(1)->Opcode() == Op_ConvHF2F) {\n      conF = binopF->in(2);\n      varS = binopF->in(1)->in(1);\n    }\n\n    if (conF != nullptr &&\n        varS != nullptr &&\n        conF->bottom_type()->isa_float_constant() != nullptr &&\n        Matcher::match_rule_supported(Float16NodeFactory::get_float16_binary_oper(binopF->Opcode())) &&\n        Matcher::match_rule_supported(Op_ReinterpretS2HF) &&\n        Matcher::match_rule_supported(Op_ReinterpretHF2S) &&\n        StubRoutines::hf2f_adr() != nullptr &&\n        StubRoutines::f2hf_adr() != nullptr) {\n      jfloat con = conF->bottom_type()->getf();\n      // Conditions under which floating point constant can be considered for a pattern match.\n      // 1. conF must lie within Float16 value range, otherwise we would have rounding issues:\n      //    Doing the operation in float32 and then rounding is not the same as\n      //    rounding first and doing the operation in float16.\n      // 2. If a constant value is one of the valid IEEE 754 binary32 NaN bit patterns\n      // then it's safe to consider it for pattern match because of the following reasons:\n      //   a. As per section 2.8 of JVMS, Java Virtual Machine does not support\n      //   signaling NaN value.\n      //   b. Any signaling NaN which takes part in a non-comparison expression\n      //   results in a quiet NaN but preserves the significand bits of signaling NaN.\n      //   c. The pattern being matched includes a Float to Float16 conversion after binary\n      //   expression, this downcast will still preserve the significand bits of binary32 NaN.\n      bool isnan = g_isnan((jdouble)con);\n      if (StubRoutines::hf2f(StubRoutines::f2hf(con)) == con || isnan) {\n        Node* newVarHF = phase->transform(new ReinterpretS2HFNode(varS));\n        Node* conHF = phase->makecon(TypeH::make(con));\n        Node* binopHF = nullptr;\n        // Preserving original input order for semantic correctness\n        // of non-commutative operation.\n        if (binopF->in(1) == conF) {\n          binopHF = phase->transform(Float16NodeFactory::make(binopF->Opcode(), binopF->in(0), conHF, newVarHF));\n        } else {\n          binopHF = phase->transform(Float16NodeFactory::make(binopF->Opcode(), binopF->in(0), newVarHF, conHF));\n        }\n        return new ReinterpretHF2SNode(binopHF);\n      }\n    }\n  }\n\n  return nullptr;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Float16操作涉及常量输入时，编译器需要先将常量从Float16提升到Float32进行计算，然后再将结果转换回Float16，这产生了额外的转换开销。优化后：编译器能够识别包含常量输入的Float16操作模式（ConvF2HF(binopF(conF, ConvHF2F(varS)))），并直接将其转换为Float16级别的操作（ReinterpretHF2SNode(binopHF(conHF, ReinterpretS2HFNode(varS)))），避免了中间转换。优化思路：通过模式匹配识别可优化的常量Float16操作图，在满足精度和NaN处理要求的前提下，直接在Float16精度下执行操作，减少类型转换开销，提高性能。"}
{"id": 385, "source": "riscv-dataset-excel", "optimization_type": "延迟加载优化", "optimization_description": "优化前：PlatformTracer 类在 JFR 启动时立即初始化，即使没有使用 MethodTrace 或 MethodTiming 事件也会执行初始化逻辑（耗时 1-10 毫秒）。优化后：通过延迟加载机制，只有当 MethodSetting 被实际使用时（即设置了方法过滤器）才初始化 PlatformTracer。优化思路：减少不必要的类加载和初始化开销，提升 JFR 启动性能，特别是对于不使用方法追踪功能的场景。", "original_code": "PlatformTracer 类在 JFR 启动时立即初始化，即使没有使用 MethodTrace 或 MethodTiming 事件也会执行初始化逻辑（耗时 1-10 毫秒）。", "optimized_code": "1. MethodSetting.java:\n   - 添加 volatile static boolean initialized 字段\n   - 添加 ensureInitialized() 方法，调用 PlatformTracer.initialize()\n   - 添加 isInitialized() 方法\n2. PlatformTracer.java:\n   - 移除 initialized 字段\n   - 移除 ensureInitialized() 方法\n   - 将 initialize() 方法改为 public\n3. JDKEvents.java:\n   - 修改 emitMethodTiming() 中的条件判断：if (MethodTimingEvent.enabled()) → if (MethodSetting.isInitialized() && MethodTimingEvent.enabled())", "source_url": "https://github.com/openjdk/riscv-port/commit/8ea544c33fc502208577249fb83544f8d876bc17", "code_v0_no_empty_lines": "PlatformTracer 类在 JFR 启动时立即初始化，即使没有使用 MethodTrace 或 MethodTiming 事件也会执行初始化逻辑（耗时 1-10 毫秒）。", "code_v1_no_empty_lines": "1. MethodSetting.java:\n   - 添加 volatile static boolean initialized 字段\n   - 添加 ensureInitialized() 方法，调用 PlatformTracer.initialize()\n   - 添加 isInitialized() 方法\n2. PlatformTracer.java:\n   - 移除 initialized 字段\n   - 移除 ensureInitialized() 方法\n   - 将 initialize() 方法改为 public\n3. JDKEvents.java:\n   - 修改 emitMethodTiming() 中的条件判断：if (MethodTimingEvent.enabled()) → if (MethodSetting.isInitialized() && MethodTimingEvent.enabled())", "target": "1. MethodSetting.java:\n   - 添加 volatile static boolean initialized 字段\n   - 添加 ensureInitialized() 方法，调用 PlatformTracer.initialize()\n   - 添加 isInitialized() 方法\n2. PlatformTracer.java:\n   - 移除 initialized 字段\n   - 移除 ensureInitialized() 方法\n   - 将 initialize() 方法改为 public\n3. JDKEvents.java:\n   - 修改 emitMethodTiming() 中的条件判断：if (MethodTimingEvent.enabled()) → if (MethodSetting.isInitialized() && MethodTimingEvent.enabled())", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PlatformTracer 类在 JFR 启动时立即初始化，即使没有使用 MethodTrace 或 MethodTiming 事件也会执行初始化逻辑（耗时 1-10 毫秒）。优化后：通过延迟加载机制，只有当 MethodSetting 被实际使用时（即设置了方法过滤器）才初始化 PlatformTracer。优化思路：减少不必要的类加载和初始化开销，提升 JFR 启动性能，特别是对于不使用方法追踪功能的场景。"}
{"id": 386, "source": "riscv-dataset-excel", "optimization_type": "代码简化+性能优化", "optimization_description": "优化前：先调用indexOf查找元素索引，再检查索引有效性，最后调用remove(index)删除元素，需要两次列表操作。优化后：直接调用remove(Object)方法删除元素，只需一次列表操作。思路：利用List.remove(Object)方法直接删除指定对象，避免不必要的索引查找和检查，简化代码逻辑并提升性能。", "original_code": "先调用indexOf查找元素索引，再检查索引有效性，最后调用remove(index)删除元素，需要两次列表操作。", "optimized_code": "-                int index = transmitters.indexOf(t);\n-                if (index >= 0) {\n-                    transmitters.remove(index);\n-                }\n+                transmitters.remove(t);", "source_url": "https://github.com/openjdk/riscv-port/commit/20e983a97c66902c61ee2fa1959a7e612266732b", "code_v0_no_empty_lines": "先调用indexOf查找元素索引，再检查索引有效性，最后调用remove(index)删除元素，需要两次列表操作。", "code_v1_no_empty_lines": "-                int index = transmitters.indexOf(t);\n-                if (index >= 0) {\n-                    transmitters.remove(index);\n-                }\n+                transmitters.remove(t);", "target": "-                int index = transmitters.indexOf(t);\n-                if (index >= 0) {\n-                    transmitters.remove(index);\n-                }\n+                transmitters.remove(t);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：先调用indexOf查找元素索引，再检查索引有效性，最后调用remove(index)删除元素，需要两次列表操作。优化后：直接调用remove(Object)方法删除元素，只需一次列表操作。思路：利用List.remove(Object)方法直接删除指定对象，避免不必要的索引查找和检查，简化代码逻辑并提升性能。"}
{"id": 387, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+自旋等待优化", "optimization_description": "优化前：AArch64架构的spin_wait实现仅支持NOP、ISB、YIELD三种指令选项，缺少对SB（Speculation Barrier）指令的支持。优化后：在MacroAssembler中添加SB指令支持，扩展SpinWait枚举包含SB选项，在spin_wait()函数中增加SB指令分支，并在VM版本检测中增加对SB指令的硬件支持检查。优化思路：通过支持SB指令作为自旋等待选项，为支持该指令的AArch64 CPU提供更优化的自旋等待实现，SB指令可以防止推测执行，在自旋等待场景中可能提供更好的性能和功耗特性。", "original_code": "AArch64架构的spin_wait实现仅支持NOP、ISB、YIELD三种指令选项，缺少对SB（Speculation Barrier）指令的支持。", "optimized_code": "void sb() {\n    system(0b00, 0b011, 0b00011, 0b0000, 0b111);\n}\n\ncase SpinWait::SB:\n    sb();\n    break;", "source_url": "https://github.com/openjdk/riscv-port/commit/ecd2d83096a1fea7d5086736306770bcffa4fdb6", "code_v0_no_empty_lines": "AArch64架构的spin_wait实现仅支持NOP、ISB、YIELD三种指令选项，缺少对SB（Speculation Barrier）指令的支持。", "code_v1_no_empty_lines": "void sb() {\n    system(0b00, 0b011, 0b00011, 0b0000, 0b111);\n}\n\ncase SpinWait::SB:\n    sb();\n    break;", "target": "void sb() {\n    system(0b00, 0b011, 0b00011, 0b0000, 0b111);\n}\n\ncase SpinWait::SB:\n    sb();\n    break;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AArch64架构的spin_wait实现仅支持NOP、ISB、YIELD三种指令选项，缺少对SB（Speculation Barrier）指令的支持。优化后：在MacroAssembler中添加SB指令支持，扩展SpinWait枚举包含SB选项，在spin_wait()函数中增加SB指令分支，并在VM版本检测中增加对SB指令的硬件支持检查。优化思路：通过支持SB指令作为自旋等待选项，为支持该指令的AArch64 CPU提供更优化的自旋等待实现，SB指令可以防止推测执行，在自旋等待场景中可能提供更好的性能和功耗特性。"}
{"id": 388, "source": "riscv-dataset-excel", "optimization_type": "代码重构+可维护性优化", "optimization_description": "优化前：String构造函数包含大量内联的字符集处理逻辑（UTF-8、ISO-8859-1、US-ASCII等），代码冗长且难以维护。优化后：将不同字符集的解码逻辑拆分为独立的私有静态方法（utf8、iso88591、ascii、decode），主构造函数仅负责分发调用。优化思路：通过方法分解提高代码可读性、可维护性和可测试性，同时保持原有性能特性，便于后续优化和扩展。", "original_code": "String构造函数包含大量内联的字符集处理逻辑（UTF-8、ISO-8859-1、US-ASCII等），代码冗长且难以维护。", "optimized_code": "private String(Charset charset, byte[] bytes, int offset, int length) {\n+        String str;\n         if (length == 0) {\n-            this.value = \"\".value;\n-            this.coder = \"\".coder;\n+            str = \"\";\n         } else if (charset == UTF_8.INSTANCE) {\n-            if (COMPACT_STRINGS) {\n-                int dp = StringCoding.countPositives(bytes, offset, length);\n-                if (dp == length) {\n-                    this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                    this.coder = LATIN1;\n-                    return;\n-                }\n-                // ... 大量内联代码 ...\n-                this.value = utf16;\n-                this.coder = UTF16;\n-            } else { // !COMPACT_STRINGS\n-                byte[] dst = StringUTF16.newBytesFor(length);\n-                int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n-                if (dp != length) {\n-                    dst = Arrays.copyOf(dst, dp << 1);\n-                }\n-                this.value = dst;\n-                this.coder = UTF16;\n-            }\n+            str = utf8(bytes, offset, length);\n         } else if (charset == ISO_8859_1.INSTANCE) {\n-            if (COMPACT_STRINGS) {\n-                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                this.coder = LATIN1;\n-            } else {\n-                this.value = StringLatin1.inflate(bytes, offset, length);\n-                this.coder = UTF16;\n-            }\n+            str = iso88591(bytes, offset, length);\n         } else if (charset == US_ASCII.INSTANCE) {\n-            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n-                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                this.coder = LATIN1;\n-            } else {\n-                byte[] dst = StringUTF16.newBytesFor(length);\n-                int dp = 0;\n-                while (dp < length) {\n-                    int b = bytes[offset++];\n-                    StringUTF16.putChar(dst, dp++, (b >= 0) ? (char) b : REPL);\n-                }\n-                this.value = dst;\n-                this.coder = UTF16;\n-            }\n+            str = ascii(bytes, offset, length);\n         } else {\n-            // ... 注释说明 ...\n+            str = decode(charset, bytes, offset, length);\n         }\n+        this(str);\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/839cede1a46b05d27abeaffbbd82c241910035cd", "code_v0_no_empty_lines": "String构造函数包含大量内联的字符集处理逻辑（UTF-8、ISO-8859-1、US-ASCII等），代码冗长且难以维护。", "code_v1_no_empty_lines": "private String(Charset charset, byte[] bytes, int offset, int length) {\n+        String str;\n         if (length == 0) {\n-            this.value = \"\".value;\n-            this.coder = \"\".coder;\n+            str = \"\";\n         } else if (charset == UTF_8.INSTANCE) {\n-            if (COMPACT_STRINGS) {\n-                int dp = StringCoding.countPositives(bytes, offset, length);\n-                if (dp == length) {\n-                    this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                    this.coder = LATIN1;\n-                    return;\n-                }\n-                // ... 大量内联代码 ...\n-                this.value = utf16;\n-                this.coder = UTF16;\n-            } else { // !COMPACT_STRINGS\n-                byte[] dst = StringUTF16.newBytesFor(length);\n-                int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n-                if (dp != length) {\n-                    dst = Arrays.copyOf(dst, dp << 1);\n-                }\n-                this.value = dst;\n-                this.coder = UTF16;\n-            }\n+            str = utf8(bytes, offset, length);\n         } else if (charset == ISO_8859_1.INSTANCE) {\n-            if (COMPACT_STRINGS) {\n-                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                this.coder = LATIN1;\n-            } else {\n-                this.value = StringLatin1.inflate(bytes, offset, length);\n-                this.coder = UTF16;\n-            }\n+            str = iso88591(bytes, offset, length);\n         } else if (charset == US_ASCII.INSTANCE) {\n-            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n-                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                this.coder = LATIN1;\n-            } else {\n-                byte[] dst = StringUTF16.newBytesFor(length);\n-                int dp = 0;\n-                while (dp < length) {\n-                    int b = bytes[offset++];\n-                    StringUTF16.putChar(dst, dp++, (b >= 0) ? (char) b : REPL);\n-                }\n-                this.value = dst;\n-                this.coder = UTF16;\n-            }\n+            str = ascii(bytes, offset, length);\n         } else {\n-            // ... 注释说明 ...\n+            str = decode(charset, bytes, offset, length);\n         }\n+        this(str);\n     }", "target": "private String(Charset charset, byte[] bytes, int offset, int length) {\n+        String str;\n         if (length == 0) {\n-            this.value = \"\".value;\n-            this.coder = \"\".coder;\n+            str = \"\";\n         } else if (charset == UTF_8.INSTANCE) {\n-            if (COMPACT_STRINGS) {\n-                int dp = StringCoding.countPositives(bytes, offset, length);\n-                if (dp == length) {\n-                    this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                    this.coder = LATIN1;\n-                    return;\n-                }\n-                // ... 大量内联代码 ...\n-                this.value = utf16;\n-                this.coder = UTF16;\n-            } else { // !COMPACT_STRINGS\n-                byte[] dst = StringUTF16.newBytesFor(length);\n-                int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n-                if (dp != length) {\n-                    dst = Arrays.copyOf(dst, dp << 1);\n-                }\n-                this.value = dst;\n-                this.coder = UTF16;\n-            }\n+            str = utf8(bytes, offset, length);\n         } else if (charset == ISO_8859_1.INSTANCE) {\n-            if (COMPACT_STRINGS) {\n-                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                this.coder = LATIN1;\n-            } else {\n-                this.value = StringLatin1.inflate(bytes, offset, length);\n-                this.coder = UTF16;\n-            }\n+            str = iso88591(bytes, offset, length);\n         } else if (charset == US_ASCII.INSTANCE) {\n-            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n-                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                this.coder = LATIN1;\n-            } else {\n-                byte[] dst = StringUTF16.newBytesFor(length);\n-                int dp = 0;\n-                while (dp < length) {\n-                    int b = bytes[offset++];\n-                    StringUTF16.putChar(dst, dp++, (b >= 0) ? (char) b : REPL);\n-                }\n-                this.value = dst;\n-                this.coder = UTF16;\n-            }\n+            str = ascii(bytes, offset, length);\n         } else {\n-            // ... 注释说明 ...\n+            str = decode(charset, bytes, offset, length);\n         }\n+        this(str);\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：String构造函数包含大量内联的字符集处理逻辑（UTF-8、ISO-8859-1、US-ASCII等），代码冗长且难以维护。优化后：将不同字符集的解码逻辑拆分为独立的私有静态方法（utf8、iso88591、ascii、decode），主构造函数仅负责分发调用。优化思路：通过方法分解提高代码可读性、可维护性和可测试性，同时保持原有性能特性，便于后续优化和扩展。"}
{"id": 389, "source": "riscv-dataset-excel", "optimization_type": "算法优化+代码重构", "optimization_description": "优化前：balance_queues函数使用复杂的嵌套循环和条件判断，通过move_all标志和多次长度检查来控制引用移动逻辑，代码结构复杂且存在冗余计算。优化后：重构算法，预先计算每个队列需要移动的引用数量（remaining_to_move），简化循环条件，移除move_all标志，使用更清晰的逻辑处理队列平衡。优化思路：通过预先计算和简化控制流，减少每次迭代的条件判断，提高代码可读性和潜在的执行效率，特别是在多队列场景下减少不必要的循环和分支。", "original_code": "balance_queues函数使用复杂的嵌套循环和条件判断，通过move_all标志和多次长度检查来控制引用移动逻辑，代码结构复杂且存在冗余计算。", "optimized_code": "-    bool move_all = false;\n+    size_t from_len = ref_lists[from_idx].length();\n+\n+    size_t remaining_to_move;\n     if (from_idx >= _num_queues) {\n-      move_all = ref_lists[from_idx].length() > 0;\n+      // Move all\n+      remaining_to_move = from_len;\n     } else {\n-      while ((ref_lists[from_idx].length() > avg_refs) ||\n-             move_all) {\n+      // Move those above avg_refs\n+      remaining_to_move = from_len > avg_refs\n+                        ? from_len - avg_refs\n+                        : 0;\n     }\n+\n+    while (remaining_to_move > 0) {\n       assert(to_idx < _num_queues, \"Sanity Check!\");\n-      if (ref_lists[to_idx].length() < avg_refs) {\n-        // move superfluous refs\n-        size_t refs_to_move;\n-        // Move all the Ref's if the from queue will not be processed.\n-        if (move_all) {\n-          refs_to_move = MIN2(ref_lists[from_idx].length(),\n-                              avg_refs - ref_lists[to_idx].length());\n-        } else {\n-          refs_to_move = MIN2(ref_lists[from_idx].length() - avg_refs,\n-                              avg_refs - ref_lists[to_idx].length());\n-        }\n-\n-        assert(refs_to_move > 0, \"otherwise the code below will fail\");\n-\n-        oop move_head = ref_lists[from_idx].head();\n-        oop move_tail = move_head;\n-        oop new_head  = move_head;\n-        // find an element to split the list on\n-        for (size_t j = 0; j < refs_to_move; ++j) {\n-          move_tail = new_head;\n-          new_head = java_lang_ref_Reference::discovered(new_head);\n-        }\n-\n-        // Add the chain to the to list.\n-        if (ref_lists[to_idx].head() == nullptr) {\n-          // to list is empty. Make a loop at the end.\n-          java_lang_ref_Reference::set_discovered_raw(move_tail, move_tail);\n-        } else {\n-          java_lang_ref_Reference::set_discovered_raw(move_tail, ref_lists[to_idx].head());\n-        }\n-        ref_lists[to_idx].set_head(move_head);\n-        ref_lists[to_idx].inc_length(refs_to_move);\n-\n-        // Remove the chain from the from list.\n-        if (move_tail == new_head) {\n-          // We found the end of the from list.\n-          ref_lists[from_idx].set_head(nullptr);\n-        } else {\n-          ref_lists[from_idx].set_head(new_head);\n-        }\n-        ref_lists[from_idx].dec_length(refs_to_move);\n-        if (ref_lists[from_idx].length() == 0) {\n-          break;\n-        }\n+\n+      size_t to_len = ref_lists[to_idx].length();\n+      if (to_len >= avg_refs) {\n+        // this list is full enough; move on to next\n+        to_idx++;\n+        continue;\n+      }\n+      size_t refs_to_move = MIN2(remaining_to_move, avg_refs - to_len);\n+      assert(refs_to_move > 0, \"otherwise the code below will fail\");\n+\n+      oop move_head = ref_lists[from_idx].head();\n+      oop move_tail = move_head;\n+      oop new_head  = move_head;\n+      // find an element to split the list on\n+      for (size_t j = 0; j < refs_to_move; ++j) {\n+        move_tail = new_head;\n+        new_head = java_lang_ref_Reference::discovered(new_head);\n+      }\n+\n+      // Add the chain to the to list.\n+      if (ref_lists[to_idx].head() == nullptr) {\n+        // to list is empty. Make a loop at the end.\n+        java_lang_ref_Reference::set_discovered_raw(move_tail, move_tail);\n       } else {\n-        to_idx = (to_idx + 1) % _num_queues;\n+        java_lang_ref_Reference::set_discovered_raw(move_tail, ref_lists[to_idx].head());\n       }\n+      ref_lists[to_idx].set_head(move_head);\n+      ref_lists[to_idx].inc_length(refs_to_move);\n+\n+      // Remove the chain from the from list.\n+      if (move_tail == new_head) {\n+        // We found the end of the from list.\n+        ref_lists[from_idx].set_head(nullptr);\n+      } else {\n+        ref_lists[from_idx].set_head(new_head);\n+      }\n+      ref_lists[from_idx].dec_length(refs_to_move);\n+\n+      remaining_to_move -= refs_to_move;\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/fc739fee5360ec052c2b51b3e30ce1c34df71714", "code_v0_no_empty_lines": "balance_queues函数使用复杂的嵌套循环和条件判断，通过move_all标志和多次长度检查来控制引用移动逻辑，代码结构复杂且存在冗余计算。", "code_v1_no_empty_lines": "-    bool move_all = false;\n+    size_t from_len = ref_lists[from_idx].length();\n+\n+    size_t remaining_to_move;\n     if (from_idx >= _num_queues) {\n-      move_all = ref_lists[from_idx].length() > 0;\n+      // Move all\n+      remaining_to_move = from_len;\n     } else {\n-      while ((ref_lists[from_idx].length() > avg_refs) ||\n-             move_all) {\n+      // Move those above avg_refs\n+      remaining_to_move = from_len > avg_refs\n+                        ? from_len - avg_refs\n+                        : 0;\n     }\n+\n+    while (remaining_to_move > 0) {\n       assert(to_idx < _num_queues, \"Sanity Check!\");\n-      if (ref_lists[to_idx].length() < avg_refs) {\n-        // move superfluous refs\n-        size_t refs_to_move;\n-        // Move all the Ref's if the from queue will not be processed.\n-        if (move_all) {\n-          refs_to_move = MIN2(ref_lists[from_idx].length(),\n-                              avg_refs - ref_lists[to_idx].length());\n-        } else {\n-          refs_to_move = MIN2(ref_lists[from_idx].length() - avg_refs,\n-                              avg_refs - ref_lists[to_idx].length());\n-        }\n-\n-        assert(refs_to_move > 0, \"otherwise the code below will fail\");\n-\n-        oop move_head = ref_lists[from_idx].head();\n-        oop move_tail = move_head;\n-        oop new_head  = move_head;\n-        // find an element to split the list on\n-        for (size_t j = 0; j < refs_to_move; ++j) {\n-          move_tail = new_head;\n-          new_head = java_lang_ref_Reference::discovered(new_head);\n-        }\n-\n-        // Add the chain to the to list.\n-        if (ref_lists[to_idx].head() == nullptr) {\n-          // to list is empty. Make a loop at the end.\n-          java_lang_ref_Reference::set_discovered_raw(move_tail, move_tail);\n-        } else {\n-          java_lang_ref_Reference::set_discovered_raw(move_tail, ref_lists[to_idx].head());\n-        }\n-        ref_lists[to_idx].set_head(move_head);\n-        ref_lists[to_idx].inc_length(refs_to_move);\n-\n-        // Remove the chain from the from list.\n-        if (move_tail == new_head) {\n-          // We found the end of the from list.\n-          ref_lists[from_idx].set_head(nullptr);\n-        } else {\n-          ref_lists[from_idx].set_head(new_head);\n-        }\n-        ref_lists[from_idx].dec_length(refs_to_move);\n-        if (ref_lists[from_idx].length() == 0) {\n-          break;\n-        }\n+\n+      size_t to_len = ref_lists[to_idx].length();\n+      if (to_len >= avg_refs) {\n+        // this list is full enough; move on to next\n+        to_idx++;\n+        continue;\n+      }\n+      size_t refs_to_move = MIN2(remaining_to_move, avg_refs - to_len);\n+      assert(refs_to_move > 0, \"otherwise the code below will fail\");\n+\n+      oop move_head = ref_lists[from_idx].head();\n+      oop move_tail = move_head;\n+      oop new_head  = move_head;\n+      // find an element to split the list on\n+      for (size_t j = 0; j < refs_to_move; ++j) {\n+        move_tail = new_head;\n+        new_head = java_lang_ref_Reference::discovered(new_head);\n+      }\n+\n+      // Add the chain to the to list.\n+      if (ref_lists[to_idx].head() == nullptr) {\n+        // to list is empty. Make a loop at the end.\n+        java_lang_ref_Reference::set_discovered_raw(move_tail, move_tail);\n       } else {\n-        to_idx = (to_idx + 1) % _num_queues;\n+        java_lang_ref_Reference::set_discovered_raw(move_tail, ref_lists[to_idx].head());\n       }\n+      ref_lists[to_idx].set_head(move_head);\n+      ref_lists[to_idx].inc_length(refs_to_move);\n+\n+      // Remove the chain from the from list.\n+      if (move_tail == new_head) {\n+        // We found the end of the from list.\n+        ref_lists[from_idx].set_head(nullptr);\n+      } else {\n+        ref_lists[from_idx].set_head(new_head);\n+      }\n+      ref_lists[from_idx].dec_length(refs_to_move);\n+\n+      remaining_to_move -= refs_to_move;\n     }", "target": "-    bool move_all = false;\n+    size_t from_len = ref_lists[from_idx].length();\n+\n+    size_t remaining_to_move;\n     if (from_idx >= _num_queues) {\n-      move_all = ref_lists[from_idx].length() > 0;\n+      // Move all\n+      remaining_to_move = from_len;\n     } else {\n-      while ((ref_lists[from_idx].length() > avg_refs) ||\n-             move_all) {\n+      // Move those above avg_refs\n+      remaining_to_move = from_len > avg_refs\n+                        ? from_len - avg_refs\n+                        : 0;\n     }\n+\n+    while (remaining_to_move > 0) {\n       assert(to_idx < _num_queues, \"Sanity Check!\");\n-      if (ref_lists[to_idx].length() < avg_refs) {\n-        // move superfluous refs\n-        size_t refs_to_move;\n-        // Move all the Ref's if the from queue will not be processed.\n-        if (move_all) {\n-          refs_to_move = MIN2(ref_lists[from_idx].length(),\n-                              avg_refs - ref_lists[to_idx].length());\n-        } else {\n-          refs_to_move = MIN2(ref_lists[from_idx].length() - avg_refs,\n-                              avg_refs - ref_lists[to_idx].length());\n-        }\n-\n-        assert(refs_to_move > 0, \"otherwise the code below will fail\");\n-\n-        oop move_head = ref_lists[from_idx].head();\n-        oop move_tail = move_head;\n-        oop new_head  = move_head;\n-        // find an element to split the list on\n-        for (size_t j = 0; j < refs_to_move; ++j) {\n-          move_tail = new_head;\n-          new_head = java_lang_ref_Reference::discovered(new_head);\n-        }\n-\n-        // Add the chain to the to list.\n-        if (ref_lists[to_idx].head() == nullptr) {\n-          // to list is empty. Make a loop at the end.\n-          java_lang_ref_Reference::set_discovered_raw(move_tail, move_tail);\n-        } else {\n-          java_lang_ref_Reference::set_discovered_raw(move_tail, ref_lists[to_idx].head());\n-        }\n-        ref_lists[to_idx].set_head(move_head);\n-        ref_lists[to_idx].inc_length(refs_to_move);\n-\n-        // Remove the chain from the from list.\n-        if (move_tail == new_head) {\n-          // We found the end of the from list.\n-          ref_lists[from_idx].set_head(nullptr);\n-        } else {\n-          ref_lists[from_idx].set_head(new_head);\n-        }\n-        ref_lists[from_idx].dec_length(refs_to_move);\n-        if (ref_lists[from_idx].length() == 0) {\n-          break;\n-        }\n+\n+      size_t to_len = ref_lists[to_idx].length();\n+      if (to_len >= avg_refs) {\n+        // this list is full enough; move on to next\n+        to_idx++;\n+        continue;\n+      }\n+      size_t refs_to_move = MIN2(remaining_to_move, avg_refs - to_len);\n+      assert(refs_to_move > 0, \"otherwise the code below will fail\");\n+\n+      oop move_head = ref_lists[from_idx].head();\n+      oop move_tail = move_head;\n+      oop new_head  = move_head;\n+      // find an element to split the list on\n+      for (size_t j = 0; j < refs_to_move; ++j) {\n+        move_tail = new_head;\n+        new_head = java_lang_ref_Reference::discovered(new_head);\n+      }\n+\n+      // Add the chain to the to list.\n+      if (ref_lists[to_idx].head() == nullptr) {\n+        // to list is empty. Make a loop at the end.\n+        java_lang_ref_Reference::set_discovered_raw(move_tail, move_tail);\n       } else {\n-        to_idx = (to_idx + 1) % _num_queues;\n+        java_lang_ref_Reference::set_discovered_raw(move_tail, ref_lists[to_idx].head());\n       }\n+      ref_lists[to_idx].set_head(move_head);\n+      ref_lists[to_idx].inc_length(refs_to_move);\n+\n+      // Remove the chain from the from list.\n+      if (move_tail == new_head) {\n+        // We found the end of the from list.\n+        ref_lists[from_idx].set_head(nullptr);\n+      } else {\n+        ref_lists[from_idx].set_head(new_head);\n+      }\n+      ref_lists[from_idx].dec_length(refs_to_move);\n+\n+      remaining_to_move -= refs_to_move;\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：balance_queues函数使用复杂的嵌套循环和条件判断，通过move_all标志和多次长度检查来控制引用移动逻辑，代码结构复杂且存在冗余计算。优化后：重构算法，预先计算每个队列需要移动的引用数量（remaining_to_move），简化循环条件，移除move_all标志，使用更清晰的逻辑处理队列平衡。优化思路：通过预先计算和简化控制流，减少每次迭代的条件判断，提高代码可读性和潜在的执行效率，特别是在多队列场景下减少不必要的循环和分支。"}
{"id": 390, "source": "riscv-dataset-excel", "optimization_type": "代码重构/命名优化", "optimization_description": "优化前：类名RegionTypeCounter和HRRSStatsIter含义不够清晰，不符合G1垃圾收集器的命名规范，可读性较差。优化后：将RegionTypeCounter重命名为G1PerRegionTypeRemSetCounters，将HRRSStatsIter重命名为G1HeapRegionStatsClosure，使类名更准确地反映其功能（G1按区域类型的记忆集计数器、G1堆区域统计闭包）。优化思路：通过改进命名规范增强代码可读性和维护性，遵循项目命名约定，使类名更直观地表达其用途，便于开发者理解和后续维护。", "original_code": "类名RegionTypeCounter和HRRSStatsIter含义不够清晰，不符合G1垃圾收集器的命名规范，可读性较差。", "optimized_code": "-class RegionTypeCounter {\n+class G1PerRegionTypeRemSetCounters {\n\n-class HRRSStatsIter: public G1HeapRegionClosure {\n+class G1HeapRegionStatsClosure: public G1HeapRegionClosure {\n\n-  RegionTypeCounter _young;\n+  G1PerRegionTypeRemSetCounters _young;\n\n-  HRRSStatsIter() : _young(\"Young\"), _humongous(\"Humongous\"),\n+  G1HeapRegionStatsClosure() : _young(\"Young\"), _humongous(\"Humongous\"),\n\n-  RegionTypeCounter* current = nullptr;\n+  G1PerRegionTypeRemSetCounters* current = nullptr;\n\n-  HRRSStatsIter blk;\n+  G1HeapRegionStatsClosure blk;", "source_url": "https://github.com/openjdk/riscv-port/commit/e85c7d09df67728ddcf852a96e5b2baa57c502f1", "code_v0_no_empty_lines": "类名RegionTypeCounter和HRRSStatsIter含义不够清晰，不符合G1垃圾收集器的命名规范，可读性较差。", "code_v1_no_empty_lines": "-class RegionTypeCounter {\n+class G1PerRegionTypeRemSetCounters {\n\n-class HRRSStatsIter: public G1HeapRegionClosure {\n+class G1HeapRegionStatsClosure: public G1HeapRegionClosure {\n\n-  RegionTypeCounter _young;\n+  G1PerRegionTypeRemSetCounters _young;\n\n-  HRRSStatsIter() : _young(\"Young\"), _humongous(\"Humongous\"),\n+  G1HeapRegionStatsClosure() : _young(\"Young\"), _humongous(\"Humongous\"),\n\n-  RegionTypeCounter* current = nullptr;\n+  G1PerRegionTypeRemSetCounters* current = nullptr;\n\n-  HRRSStatsIter blk;\n+  G1HeapRegionStatsClosure blk;", "target": "-class RegionTypeCounter {\n+class G1PerRegionTypeRemSetCounters {\n\n-class HRRSStatsIter: public G1HeapRegionClosure {\n+class G1HeapRegionStatsClosure: public G1HeapRegionClosure {\n\n-  RegionTypeCounter _young;\n+  G1PerRegionTypeRemSetCounters _young;\n\n-  HRRSStatsIter() : _young(\"Young\"), _humongous(\"Humongous\"),\n+  G1HeapRegionStatsClosure() : _young(\"Young\"), _humongous(\"Humongous\"),\n\n-  RegionTypeCounter* current = nullptr;\n+  G1PerRegionTypeRemSetCounters* current = nullptr;\n\n-  HRRSStatsIter blk;\n+  G1HeapRegionStatsClosure blk;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：类名RegionTypeCounter和HRRSStatsIter含义不够清晰，不符合G1垃圾收集器的命名规范，可读性较差。优化后：将RegionTypeCounter重命名为G1PerRegionTypeRemSetCounters，将HRRSStatsIter重命名为G1HeapRegionStatsClosure，使类名更准确地反映其功能（G1按区域类型的记忆集计数器、G1堆区域统计闭包）。优化思路：通过改进命名规范增强代码可读性和维护性，遵循项目命名约定，使类名更直观地表达其用途，便于开发者理解和后续维护。"}
{"id": 391, "source": "riscv-dataset-excel", "optimization_type": "数学函数性能优化", "optimization_description": "优化前：Math.cbrt函数在处理特殊值（零、无穷大、NaN）时，通过栈操作和复杂条件分支实现，涉及多次内存访问和冗余检查。优化后：1. 引入_ABS_MASK常量，使用andpd指令直接处理绝对值；2. 移除栈操作（subq/addq），改为寄存器操作；3. 简化特殊值处理逻辑，减少分支和标签数量（从7个减少到3个）；4. 通过ucomisd指令直接比较特殊值，避免内存加载。优化思路：减少内存访问、简化控制流、利用SIMD指令优化特殊值处理路径，从而修复性能回归。", "original_code": "Math.cbrt函数在处理特殊值（零、无穷大、NaN）时，通过栈操作和复杂条件分支实现，涉及多次内存访问和冗余检查。", "optimized_code": "- __ subq(rsp, 24);\n- __ movsd(Address(rsp), xmm0);\n+ __ ucomisd(xmm0, ExternalAddress(ZERON), r11 /*rscratch*/);\n+ __ jcc(Assembler::equal, L_2TAG_PACKET_1_0_1);\n+ __ movq(xmm1, xmm0);\n+ __ andpd(xmm1, ExternalAddress(ABS_MASK), r11 /*rscratch*/);\n+ __ ucomisd(xmm1, ExternalAddress(INF), r11 /*rscratch*/);\n+ __ jcc(Assembler::equal, B1_4);\n- __ cmpl(rdx, 524032);\n- __ jcc(Assembler::equal, L_2TAG_PACKET_1_0_1);\n- __ cmpl(rdx, 0);\n- __ jcc(Assembler::equal, L_2TAG_PACKET_3_0_1);\n- __ bind(L_2TAG_PACKET_3_0_1);\n- __ cmpq(r9, 0);\n- __ jcc(Assembler::notEqual, L_2TAG_PACKET_4_0_1);\n- __ xorpd(xmm0, xmm0);\n- __ jmp(B1_4);\n- __ bind(L_2TAG_PACKET_4_0_1);\n- __ movsd(xmm0, ExternalAddress(ZERON), r11 /*rscratch*/);\n- __ jmp(B1_4);\n- __ bind(L_2TAG_PACKET_5_0_1);\n- __ movsd(xmm0, Address(rsp));\n- __ addsd(xmm0, xmm0);\n- __ movq(Address(rsp, 8), xmm0);\n- __ addq(rsp, 24);", "source_url": "https://github.com/openjdk/riscv-port/commit/38f59f84c98dfd974eec0c05541b2138b149def7", "code_v0_no_empty_lines": "Math.cbrt函数在处理特殊值（零、无穷大、NaN）时，通过栈操作和复杂条件分支实现，涉及多次内存访问和冗余检查。", "code_v1_no_empty_lines": "- __ subq(rsp, 24);\n- __ movsd(Address(rsp), xmm0);\n+ __ ucomisd(xmm0, ExternalAddress(ZERON), r11 /*rscratch*/);\n+ __ jcc(Assembler::equal, L_2TAG_PACKET_1_0_1);\n+ __ movq(xmm1, xmm0);\n+ __ andpd(xmm1, ExternalAddress(ABS_MASK), r11 /*rscratch*/);\n+ __ ucomisd(xmm1, ExternalAddress(INF), r11 /*rscratch*/);\n+ __ jcc(Assembler::equal, B1_4);\n- __ cmpl(rdx, 524032);\n- __ jcc(Assembler::equal, L_2TAG_PACKET_1_0_1);\n- __ cmpl(rdx, 0);\n- __ jcc(Assembler::equal, L_2TAG_PACKET_3_0_1);\n- __ bind(L_2TAG_PACKET_3_0_1);\n- __ cmpq(r9, 0);\n- __ jcc(Assembler::notEqual, L_2TAG_PACKET_4_0_1);\n- __ xorpd(xmm0, xmm0);\n- __ jmp(B1_4);\n- __ bind(L_2TAG_PACKET_4_0_1);\n- __ movsd(xmm0, ExternalAddress(ZERON), r11 /*rscratch*/);\n- __ jmp(B1_4);\n- __ bind(L_2TAG_PACKET_5_0_1);\n- __ movsd(xmm0, Address(rsp));\n- __ addsd(xmm0, xmm0);\n- __ movq(Address(rsp, 8), xmm0);\n- __ addq(rsp, 24);", "target": "- __ subq(rsp, 24);\n- __ movsd(Address(rsp), xmm0);\n+ __ ucomisd(xmm0, ExternalAddress(ZERON), r11 /*rscratch*/);\n+ __ jcc(Assembler::equal, L_2TAG_PACKET_1_0_1);\n+ __ movq(xmm1, xmm0);\n+ __ andpd(xmm1, ExternalAddress(ABS_MASK), r11 /*rscratch*/);\n+ __ ucomisd(xmm1, ExternalAddress(INF), r11 /*rscratch*/);\n+ __ jcc(Assembler::equal, B1_4);\n- __ cmpl(rdx, 524032);\n- __ jcc(Assembler::equal, L_2TAG_PACKET_1_0_1);\n- __ cmpl(rdx, 0);\n- __ jcc(Assembler::equal, L_2TAG_PACKET_3_0_1);\n- __ bind(L_2TAG_PACKET_3_0_1);\n- __ cmpq(r9, 0);\n- __ jcc(Assembler::notEqual, L_2TAG_PACKET_4_0_1);\n- __ xorpd(xmm0, xmm0);\n- __ jmp(B1_4);\n- __ bind(L_2TAG_PACKET_4_0_1);\n- __ movsd(xmm0, ExternalAddress(ZERON), r11 /*rscratch*/);\n- __ jmp(B1_4);\n- __ bind(L_2TAG_PACKET_5_0_1);\n- __ movsd(xmm0, Address(rsp));\n- __ addsd(xmm0, xmm0);\n- __ movq(Address(rsp, 8), xmm0);\n- __ addq(rsp, 24);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Math.cbrt函数在处理特殊值（零、无穷大、NaN）时，通过栈操作和复杂条件分支实现，涉及多次内存访问和冗余检查。优化后：1. 引入_ABS_MASK常量，使用andpd指令直接处理绝对值；2. 移除栈操作（subq/addq），改为寄存器操作；3. 简化特殊值处理逻辑，减少分支和标签数量（从7个减少到3个）；4. 通过ucomisd指令直接比较特殊值，避免内存加载。优化思路：减少内存访问、简化控制流、利用SIMD指令优化特殊值处理路径，从而修复性能回归。"}
{"id": 392, "source": "riscv-dataset-excel", "optimization_type": "测试精度优化", "optimization_description": "优化前：测试代码使用valueOf(float)方法进行浮点数到Float16的转换，该方法允许精度损失，可能导致测试结果不准确。优化后：引入valueOfExact(float)方法，该方法在转换不精确时抛出ArithmeticException，确保测试中使用的Float16值精确对应原始float值。优化思路：提高测试的准确性和可靠性，确保测试用例能正确验证Float16运算的精确行为。", "original_code": "测试代码使用valueOf(float)方法进行浮点数到Float16的转换，该方法允许精度损失，可能导致测试结果不准确。", "optimized_code": "- Float16 result =  negate(valueOf(arg));\n+ Float16 result =  negate(valueOfExact(arg));", "source_url": "https://github.com/openjdk/riscv-port/commit/549b8758661e760a7475fb398fd5b036e561fed6", "code_v0_no_empty_lines": "测试代码使用valueOf(float)方法进行浮点数到Float16的转换，该方法允许精度损失，可能导致测试结果不准确。", "code_v1_no_empty_lines": "- Float16 result =  negate(valueOf(arg));\n+ Float16 result =  negate(valueOfExact(arg));", "target": "- Float16 result =  negate(valueOf(arg));\n+ Float16 result =  negate(valueOfExact(arg));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：测试代码使用valueOf(float)方法进行浮点数到Float16的转换，该方法允许精度损失，可能导致测试结果不准确。优化后：引入valueOfExact(float)方法，该方法在转换不精确时抛出ArithmeticException，确保测试中使用的Float16值精确对应原始float值。优化思路：提高测试的准确性和可靠性，确保测试用例能正确验证Float16运算的精确行为。"}
{"id": 393, "source": "riscv-dataset-excel", "optimization_type": "编译器阶段重构+调试优化", "optimization_description": "优化前：宏展开阶段（expand_macro_nodes）同时处理宏节点消除和展开，逻辑耦合度高，调试信息不完整。优化后：将宏节点消除逻辑从expand_macro_nodes中分离出来，新增eliminate_opaque_looplimit_macro_nodes方法专门处理Opaque和LoopLimit节点消除，并在编译流程中显式调用消除方法。优化思路：1）重构编译器阶段，使宏消除和宏展开成为独立的可调试单元；2）增加StressMacroElimination调试标志和对应的PHASE_AFTER_MACRO_ELIMINATION调试阶段，提升调试能力；3）在宏展开前进行最后一次消除尝试，确保优化效果。", "original_code": "宏展开阶段（expand_macro_nodes）同时处理宏节点消除和展开，逻辑耦合度高，调试信息不完整。", "optimized_code": "--- a/src/hotspot/share/opto/compile.cpp\n+++ b/src/hotspot/share/opto/compile.cpp\n@@ -2421,6 +2422,7 @@ void Compile::Optimize() {\n         PhaseMacroExpand mexp(igvn);\n         mexp.eliminate_macro_nodes();\n         if (failing()) return;\n+        print_method(PHASE_AFTER_MACRO_ELIMINATION, 2);\n \n         igvn.set_delay_transform(false);\n         igvn.optimize();\n@@ -2520,6 +2522,18 @@ void Compile::Optimize() {\n     TracePhase tp(_t_macroExpand);\n     print_method(PHASE_BEFORE_MACRO_EXPANSION, 3);\n     PhaseMacroExpand  mex(igvn);\n+    // Do not allow new macro nodes once we start to eliminate and expand\n+    C->reset_allow_macro_nodes();\n+    // Last attempt to eliminate macro nodes before expand\n+    mex.eliminate_macro_nodes();\n+    if (failing()) {\n+      return;\n+    }\n+    mex.eliminate_opaque_looplimit_macro_nodes();\n+    if (failing()) {\n+      return;\n+    }\n+    print_method(PHASE_AFTER_MACRO_ELIMINATION, 2);\n     if (mex.expand_macro_nodes()) {\n       assert(failing(), \"must bail out w/ explicit message\");\n       return;\n--- a/src/hotspot/share/opto/macro.cpp\n+++ b/src/hotspot/share/opto/macro.cpp\n@@ -2462,19 +2472,11 @@ void PhaseMacroExpand::eliminate_macro_nodes() {\n #endif\n }\n \n-//------------------------------expand_macro_nodes----------------------\n-//  Returns true if a failure occurred.\n-bool PhaseMacroExpand::expand_macro_nodes() {\n-  refine_strip_mined_loop_macro_nodes();\n-  // Do not allow new macro nodes once we started to expand\n-  C->reset_allow_macro_nodes();\n-  if (StressMacroExpansion) {\n-    C->shuffle_macro_nodes();\n+void PhaseMacroExpand::eliminate_opaque_looplimit_macro_nodes() {\n+  if (C->macro_count() == 0) {\n+    return;\n   }\n-  // Last attempt to eliminate macro nodes.\n-  eliminate_macro_nodes();\n-  if (C->failing())  return true;\n-\n+  refine_strip_mined_loop_macro_nodes();\n   // Eliminate Opaque and LoopLimit nodes. Do it after all loop optimizations.\n   bool progress = true;\n   while (progress) {\n@@ -2536,10 +2538,18 @@ bool PhaseMacroExpand::expand_macro_nodes() {\n       assert(!success || (C->macro_count() == (old_macro_count - 1)), \"elimination must have deleted one node from macro list\");\n       progress = progress || success;\n       if (success) {\n-        C->print_method(PHASE_AFTER_MACRO_EXPANSION_STEP, 5, n);\n+        C->print_method(PHASE_AFTER_MACRO_ELIMINATION_STEP, 5, n);\n       }\n     }\n   }\n+}\n+\n+//------------------------------expand_macro_nodes----------------------\n+//  Returns true if a failure occurred.\n+bool PhaseMacroExpand::expand_macro_nodes() {\n+  if (StressMacroExpansion) {\n+    C->shuffle_macro_nodes();\n+  }\n \n   // Clean up the graph so we're less likely to hit the maximum node\n   // limit", "source_url": "https://github.com/openjdk/riscv-port/commit/eac8f5d2c99e1bcc526da0f6a05af76e815c2db9", "code_v0_no_empty_lines": "宏展开阶段（expand_macro_nodes）同时处理宏节点消除和展开，逻辑耦合度高，调试信息不完整。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/opto/compile.cpp\n+++ b/src/hotspot/share/opto/compile.cpp\n@@ -2421,6 +2422,7 @@ void Compile::Optimize() {\n         PhaseMacroExpand mexp(igvn);\n         mexp.eliminate_macro_nodes();\n         if (failing()) return;\n+        print_method(PHASE_AFTER_MACRO_ELIMINATION, 2);\n \n         igvn.set_delay_transform(false);\n         igvn.optimize();\n@@ -2520,6 +2522,18 @@ void Compile::Optimize() {\n     TracePhase tp(_t_macroExpand);\n     print_method(PHASE_BEFORE_MACRO_EXPANSION, 3);\n     PhaseMacroExpand  mex(igvn);\n+    // Do not allow new macro nodes once we start to eliminate and expand\n+    C->reset_allow_macro_nodes();\n+    // Last attempt to eliminate macro nodes before expand\n+    mex.eliminate_macro_nodes();\n+    if (failing()) {\n+      return;\n+    }\n+    mex.eliminate_opaque_looplimit_macro_nodes();\n+    if (failing()) {\n+      return;\n+    }\n+    print_method(PHASE_AFTER_MACRO_ELIMINATION, 2);\n     if (mex.expand_macro_nodes()) {\n       assert(failing(), \"must bail out w/ explicit message\");\n       return;\n--- a/src/hotspot/share/opto/macro.cpp\n+++ b/src/hotspot/share/opto/macro.cpp\n@@ -2462,19 +2472,11 @@ void PhaseMacroExpand::eliminate_macro_nodes() {\n #endif\n }\n \n-//------------------------------expand_macro_nodes----------------------\n-//  Returns true if a failure occurred.\n-bool PhaseMacroExpand::expand_macro_nodes() {\n-  refine_strip_mined_loop_macro_nodes();\n-  // Do not allow new macro nodes once we started to expand\n-  C->reset_allow_macro_nodes();\n-  if (StressMacroExpansion) {\n-    C->shuffle_macro_nodes();\n+void PhaseMacroExpand::eliminate_opaque_looplimit_macro_nodes() {\n+  if (C->macro_count() == 0) {\n+    return;\n   }\n-  // Last attempt to eliminate macro nodes.\n-  eliminate_macro_nodes();\n-  if (C->failing())  return true;\n-\n+  refine_strip_mined_loop_macro_nodes();\n   // Eliminate Opaque and LoopLimit nodes. Do it after all loop optimizations.\n   bool progress = true;\n   while (progress) {\n@@ -2536,10 +2538,18 @@ bool PhaseMacroExpand::expand_macro_nodes() {\n       assert(!success || (C->macro_count() == (old_macro_count - 1)), \"elimination must have deleted one node from macro list\");\n       progress = progress || success;\n       if (success) {\n-        C->print_method(PHASE_AFTER_MACRO_EXPANSION_STEP, 5, n);\n+        C->print_method(PHASE_AFTER_MACRO_ELIMINATION_STEP, 5, n);\n       }\n     }\n   }\n+}\n+\n+//------------------------------expand_macro_nodes----------------------\n+//  Returns true if a failure occurred.\n+bool PhaseMacroExpand::expand_macro_nodes() {\n+  if (StressMacroExpansion) {\n+    C->shuffle_macro_nodes();\n+  }\n \n   // Clean up the graph so we're less likely to hit the maximum node\n   // limit", "target": "--- a/src/hotspot/share/opto/compile.cpp\n+++ b/src/hotspot/share/opto/compile.cpp\n@@ -2421,6 +2422,7 @@ void Compile::Optimize() {\n         PhaseMacroExpand mexp(igvn);\n         mexp.eliminate_macro_nodes();\n         if (failing()) return;\n+        print_method(PHASE_AFTER_MACRO_ELIMINATION, 2);\n \n         igvn.set_delay_transform(false);\n         igvn.optimize();\n@@ -2520,6 +2522,18 @@ void Compile::Optimize() {\n     TracePhase tp(_t_macroExpand);\n     print_method(PHASE_BEFORE_MACRO_EXPANSION, 3);\n     PhaseMacroExpand  mex(igvn);\n+    // Do not allow new macro nodes once we start to eliminate and expand\n+    C->reset_allow_macro_nodes();\n+    // Last attempt to eliminate macro nodes before expand\n+    mex.eliminate_macro_nodes();\n+    if (failing()) {\n+      return;\n+    }\n+    mex.eliminate_opaque_looplimit_macro_nodes();\n+    if (failing()) {\n+      return;\n+    }\n+    print_method(PHASE_AFTER_MACRO_ELIMINATION, 2);\n     if (mex.expand_macro_nodes()) {\n       assert(failing(), \"must bail out w/ explicit message\");\n       return;\n--- a/src/hotspot/share/opto/macro.cpp\n+++ b/src/hotspot/share/opto/macro.cpp\n@@ -2462,19 +2472,11 @@ void PhaseMacroExpand::eliminate_macro_nodes() {\n #endif\n }\n \n-//------------------------------expand_macro_nodes----------------------\n-//  Returns true if a failure occurred.\n-bool PhaseMacroExpand::expand_macro_nodes() {\n-  refine_strip_mined_loop_macro_nodes();\n-  // Do not allow new macro nodes once we started to expand\n-  C->reset_allow_macro_nodes();\n-  if (StressMacroExpansion) {\n-    C->shuffle_macro_nodes();\n+void PhaseMacroExpand::eliminate_opaque_looplimit_macro_nodes() {\n+  if (C->macro_count() == 0) {\n+    return;\n   }\n-  // Last attempt to eliminate macro nodes.\n-  eliminate_macro_nodes();\n-  if (C->failing())  return true;\n-\n+  refine_strip_mined_loop_macro_nodes();\n   // Eliminate Opaque and LoopLimit nodes. Do it after all loop optimizations.\n   bool progress = true;\n   while (progress) {\n@@ -2536,10 +2538,18 @@ bool PhaseMacroExpand::expand_macro_nodes() {\n       assert(!success || (C->macro_count() == (old_macro_count - 1)), \"elimination must have deleted one node from macro list\");\n       progress = progress || success;\n       if (success) {\n-        C->print_method(PHASE_AFTER_MACRO_EXPANSION_STEP, 5, n);\n+        C->print_method(PHASE_AFTER_MACRO_ELIMINATION_STEP, 5, n);\n       }\n     }\n   }\n+}\n+\n+//------------------------------expand_macro_nodes----------------------\n+//  Returns true if a failure occurred.\n+bool PhaseMacroExpand::expand_macro_nodes() {\n+  if (StressMacroExpansion) {\n+    C->shuffle_macro_nodes();\n+  }\n \n   // Clean up the graph so we're less likely to hit the maximum node\n   // limit", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：宏展开阶段（expand_macro_nodes）同时处理宏节点消除和展开，逻辑耦合度高，调试信息不完整。优化后：将宏节点消除逻辑从expand_macro_nodes中分离出来，新增eliminate_opaque_looplimit_macro_nodes方法专门处理Opaque和LoopLimit节点消除，并在编译流程中显式调用消除方法。优化思路：1）重构编译器阶段，使宏消除和宏展开成为独立的可调试单元；2）增加StressMacroElimination调试标志和对应的PHASE_AFTER_MACRO_ELIMINATION调试阶段，提升调试能力；3）在宏展开前进行最后一次消除尝试，确保优化效果。"}
{"id": 394, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "优化前：缺少对AVX10.2指令集中浮点minmax指令的支持，无法利用新硬件特性进行向量化最小值/最大值计算。优化后：添加了eminmaxsh、evminmaxps、evminmaxpd、eminmaxss、eminmaxsd、evminmaxph等函数实现，支持AVX10.2的浮点minmax指令，通过imm8参数控制最小值或最大值操作。优化思路：利用AVX10.2指令集的新特性，提供更高效的向量化浮点最小值/最大值计算，减少指令数量，提高SIMD运算性能。", "original_code": "缺少对AVX10.2指令集中浮点minmax指令的支持，无法利用新硬件特性进行向量化最小值/最大值计算。", "optimized_code": "+void Assembler::eminmaxsh(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x53, (0xC0 | encode), imm8);\n+}\n\n+void Assembler::evminmaxps(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int imm8, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x52, (0xC0 | encode), imm8);\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/5e30bf68353d989aadc2d8176181226b2debd283", "code_v0_no_empty_lines": "缺少对AVX10.2指令集中浮点minmax指令的支持，无法利用新硬件特性进行向量化最小值/最大值计算。", "code_v1_no_empty_lines": "+void Assembler::eminmaxsh(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x53, (0xC0 | encode), imm8);\n+}\n\n+void Assembler::evminmaxps(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int imm8, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x52, (0xC0 | encode), imm8);\n+}", "target": "+void Assembler::eminmaxsh(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x53, (0xC0 | encode), imm8);\n+}\n\n+void Assembler::evminmaxps(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int imm8, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x52, (0xC0 | encode), imm8);\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：缺少对AVX10.2指令集中浮点minmax指令的支持，无法利用新硬件特性进行向量化最小值/最大值计算。优化后：添加了eminmaxsh、evminmaxps、evminmaxpd、eminmaxss、eminmaxsd、evminmaxph等函数实现，支持AVX10.2的浮点minmax指令，通过imm8参数控制最小值或最大值操作。优化思路：利用AVX10.2指令集的新特性，提供更高效的向量化浮点最小值/最大值计算，减少指令数量，提高SIMD运算性能。"}
{"id": 395, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码质量优化", "optimization_description": "优化前：所有JVMCI编译的方法在反优化时都会增加decompile_count计数器，包括非默认（非CompilerBroker触发）的编译。这会导致CompileBroker基于该计数器的编译决策被非相关编译污染。优化后：通过为JVMCINMethodData添加is_default标志，并在nmethod::inc_decompile_count()中跳过非默认JVMCI编译的方法，避免计数器被污染。优化思路：分离不同编译来源的统计信息，确保CompileBroker只基于其管理的编译进行优化决策，提高编译系统决策的准确性。", "original_code": "所有JVMCI编译的方法在反优化时都会增加decompile_count计数器，包括非默认（非CompilerBroker触发）的编译。这会导致CompileBroker基于该计数器的编译决策被非相关编译污染。", "optimized_code": "--- a/src/hotspot/share/code/nmethod.cpp\n+++ b/src/hotspot/share/code/nmethod.cpp\n@@ -1935,6 +1935,14 @@ bool nmethod::is_maybe_on_stack() {\n void nmethod::inc_decompile_count() {\n   if (!is_compiled_by_c2() && !is_compiled_by_jvmci()) return;\n   // Could be gated by ProfileTraps, but do not bother...\n+#if INCLUDE_JVMCI\n+  // Deoptimization count is used by the CompileBroker to reason about compilations\n+  // it requests so do not pollute the count for deoptimizations in non-default (i.e.\n+  // non-CompilerBroker) compilations.\n+  if (is_jvmci_hosted()) {\n+    return;\n+  }\n+#endif\n   Method* m = method();\n   if (m == nullptr)  return;\n   MethodData* mdo = m->method_data();\n@@ -4056,4 +4064,8 @@ const char* nmethod::jvmci_name() {\n   }\n   return nullptr;\n }\n+\n+bool nmethod::is_jvmci_hosted() const {\n+  return jvmci_nmethod_data() != nullptr && !jvmci_nmethod_data()->is_default();\n+}\n #endif", "source_url": "https://github.com/openjdk/riscv-port/commit/ea86a20e6d74baea54df32415d9096d3b7bba1d7", "code_v0_no_empty_lines": "所有JVMCI编译的方法在反优化时都会增加decompile_count计数器，包括非默认（非CompilerBroker触发）的编译。这会导致CompileBroker基于该计数器的编译决策被非相关编译污染。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/code/nmethod.cpp\n+++ b/src/hotspot/share/code/nmethod.cpp\n@@ -1935,6 +1935,14 @@ bool nmethod::is_maybe_on_stack() {\n void nmethod::inc_decompile_count() {\n   if (!is_compiled_by_c2() && !is_compiled_by_jvmci()) return;\n   // Could be gated by ProfileTraps, but do not bother...\n+#if INCLUDE_JVMCI\n+  // Deoptimization count is used by the CompileBroker to reason about compilations\n+  // it requests so do not pollute the count for deoptimizations in non-default (i.e.\n+  // non-CompilerBroker) compilations.\n+  if (is_jvmci_hosted()) {\n+    return;\n+  }\n+#endif\n   Method* m = method();\n   if (m == nullptr)  return;\n   MethodData* mdo = m->method_data();\n@@ -4056,4 +4064,8 @@ const char* nmethod::jvmci_name() {\n   }\n   return nullptr;\n }\n+\n+bool nmethod::is_jvmci_hosted() const {\n+  return jvmci_nmethod_data() != nullptr && !jvmci_nmethod_data()->is_default();\n+}\n #endif", "target": "--- a/src/hotspot/share/code/nmethod.cpp\n+++ b/src/hotspot/share/code/nmethod.cpp\n@@ -1935,6 +1935,14 @@ bool nmethod::is_maybe_on_stack() {\n void nmethod::inc_decompile_count() {\n   if (!is_compiled_by_c2() && !is_compiled_by_jvmci()) return;\n   // Could be gated by ProfileTraps, but do not bother...\n+#if INCLUDE_JVMCI\n+  // Deoptimization count is used by the CompileBroker to reason about compilations\n+  // it requests so do not pollute the count for deoptimizations in non-default (i.e.\n+  // non-CompilerBroker) compilations.\n+  if (is_jvmci_hosted()) {\n+    return;\n+  }\n+#endif\n   Method* m = method();\n   if (m == nullptr)  return;\n   MethodData* mdo = m->method_data();\n@@ -4056,4 +4064,8 @@ const char* nmethod::jvmci_name() {\n   }\n   return nullptr;\n }\n+\n+bool nmethod::is_jvmci_hosted() const {\n+  return jvmci_nmethod_data() != nullptr && !jvmci_nmethod_data()->is_default();\n+}\n #endif", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：所有JVMCI编译的方法在反优化时都会增加decompile_count计数器，包括非默认（非CompilerBroker触发）的编译。这会导致CompileBroker基于该计数器的编译决策被非相关编译污染。优化后：通过为JVMCINMethodData添加is_default标志，并在nmethod::inc_decompile_count()中跳过非默认JVMCI编译的方法，避免计数器被污染。优化思路：分离不同编译来源的统计信息，确保CompileBroker只基于其管理的编译进行优化决策，提高编译系统决策的准确性。"}
{"id": 396, "source": "riscv-dataset-excel", "optimization_type": "编译器优化机制改进", "optimization_description": "优化前：当CCP（条件常量传播）阶段更新节点类型时，缺少通知机制，导致依赖输入类型的ideal/identity优化被错过。优化后：在transform_once方法中，当节点类型提升时，通过add_users_to_worklist(n)通知所有使用该节点的用户重新进入工作列表，确保后续优化能基于新类型进行。思路：修复CCP阶段的通知机制缺失问题，使类型变化能正确触发依赖该类型的优化（如ModI节点的控制输入折叠）。", "original_code": "当CCP（条件常量传播）阶段更新节点类型时，缺少通知机制，导致依赖输入类型的ideal/identity优化被错过。", "optimized_code": "+    add_users_to_worklist(n);   // if ideal or identity optimizations depend on the input type, users need to be notified", "source_url": "https://github.com/openjdk/riscv-port/commit/c75df634be9a0073fa246d42e5c362a09f1734f3", "code_v0_no_empty_lines": "当CCP（条件常量传播）阶段更新节点类型时，缺少通知机制，导致依赖输入类型的ideal/identity优化被错过。", "code_v1_no_empty_lines": "+    add_users_to_worklist(n);   // if ideal or identity optimizations depend on the input type, users need to be notified", "target": "+    add_users_to_worklist(n);   // if ideal or identity optimizations depend on the input type, users need to be notified", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当CCP（条件常量传播）阶段更新节点类型时，缺少通知机制，导致依赖输入类型的ideal/identity优化被错过。优化后：在transform_once方法中，当节点类型提升时，通过add_users_to_worklist(n)通知所有使用该节点的用户重新进入工作列表，确保后续优化能基于新类型进行。思路：修复CCP阶段的通知机制缺失问题，使类型变化能正确触发依赖该类型的优化（如ModI节点的控制输入折叠）。"}
{"id": 397, "source": "riscv-dataset-excel", "optimization_type": "数值精度优化+测试增强", "optimization_description": "优化前：使用整数移位（1 << 62/63）可能导致整数溢出，因为1是int类型，左移超过31位会产生未定义行为。优化后：使用长整型字面量（1L << 62/63）确保在64位long类型中正确计算掩码值，避免潜在的数值精度问题。同时增强测试逻辑，添加对事件开始时间和持续时间的验证，确保throttled事件正确处理时间戳。", "original_code": "使用整数移位（1 << 62/63）可能导致整数溢出，因为1是int类型，左移超过31位会产生未定义行为。", "optimized_code": "- public static final long MASK_THROTTLE               = 1 << 62;\n- public static final long MASK_THROTTLE_CHECK         = 1 << 63;\n+ public static final long MASK_THROTTLE               = 1L << 62;\n+ public static final long MASK_THROTTLE_CHECK         = 1L << 63;", "source_url": "https://github.com/openjdk/riscv-port/commit/77e69e02ebd280636859dd698423db6ac3bc7f5c", "code_v0_no_empty_lines": "使用整数移位（1 << 62/63）可能导致整数溢出，因为1是int类型，左移超过31位会产生未定义行为。", "code_v1_no_empty_lines": "- public static final long MASK_THROTTLE               = 1 << 62;\n- public static final long MASK_THROTTLE_CHECK         = 1 << 63;\n+ public static final long MASK_THROTTLE               = 1L << 62;\n+ public static final long MASK_THROTTLE_CHECK         = 1L << 63;", "target": "- public static final long MASK_THROTTLE               = 1 << 62;\n- public static final long MASK_THROTTLE_CHECK         = 1 << 63;\n+ public static final long MASK_THROTTLE               = 1L << 62;\n+ public static final long MASK_THROTTLE_CHECK         = 1L << 63;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用整数移位（1 << 62/63）可能导致整数溢出，因为1是int类型，左移超过31位会产生未定义行为。优化后：使用长整型字面量（1L << 62/63）确保在64位long类型中正确计算掩码值，避免潜在的数值精度问题。同时增强测试逻辑，添加对事件开始时间和持续时间的验证，确保throttled事件正确处理时间戳。"}
{"id": 398, "source": "riscv-dataset-excel", "optimization_type": "内存优化+性能优化", "optimization_description": "优化前：在getInstance方法中创建临时byte数组并复制数据头进行验证，在getData方法中先获取数据再克隆返回。优化后：直接使用原始数据数组进行验证，避免不必要的数组复制；重构getData方法，直接调用内部方法并克隆，简化逻辑。思路：减少内存分配和数据复制操作，提高ICC配置文件处理的性能，同时保持API兼容性。", "original_code": "在getInstance方法中创建临时byte数组并复制数据头进行验证，在getData方法中先获取数据再克隆返回。", "optimized_code": "- byte[] theHeader = new byte[HEADER_SIZE];\n- System.arraycopy(data, 0, theHeader, 0, HEADER_SIZE);\n- verifyHeader(theHeader);\n+ verifyHeader(data);\n\n- byte[] t = getData(cmmProfile(), tagSignature);\n- return t != null ? t.clone() : null;\n+ return getData(cmmProfile(), tagSignature).clone();", "source_url": "https://github.com/openjdk/riscv-port/commit/ec3bb93d7901c7756d7ff4cc18e4ae9d88942f93", "code_v0_no_empty_lines": "在getInstance方法中创建临时byte数组并复制数据头进行验证，在getData方法中先获取数据再克隆返回。", "code_v1_no_empty_lines": "- byte[] theHeader = new byte[HEADER_SIZE];\n- System.arraycopy(data, 0, theHeader, 0, HEADER_SIZE);\n- verifyHeader(theHeader);\n+ verifyHeader(data);\n\n- byte[] t = getData(cmmProfile(), tagSignature);\n- return t != null ? t.clone() : null;\n+ return getData(cmmProfile(), tagSignature).clone();", "target": "- byte[] theHeader = new byte[HEADER_SIZE];\n- System.arraycopy(data, 0, theHeader, 0, HEADER_SIZE);\n- verifyHeader(theHeader);\n+ verifyHeader(data);\n\n- byte[] t = getData(cmmProfile(), tagSignature);\n- return t != null ? t.clone() : null;\n+ return getData(cmmProfile(), tagSignature).clone();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在getInstance方法中创建临时byte数组并复制数据头进行验证，在getData方法中先获取数据再克隆返回。优化后：直接使用原始数据数组进行验证，避免不必要的数组复制；重构getData方法，直接调用内部方法并克隆，简化逻辑。思路：减少内存分配和数据复制操作，提高ICC配置文件处理的性能，同时保持API兼容性。"}
{"id": 399, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+内存访问优化", "optimization_description": "优化前：在向量化循环中，存在多个带掩码的加载指令（predicated loads），这些加载使用互补的掩码（complementary masks）访问相同地址。由于每个加载都带有掩码条件，导致每次迭代都需要执行掩码检查，增加了指令开销。\n\n优化后：新增VPlanTransforms::hoistPredicatedLoads变换，识别具有相同地址SCEV且掩码互补的加载指令组。通过检查内存别名依赖（使用scoped noalias元数据），确保在第一个和最后一个加载之间没有可能冲突的存储操作。然后创建一个无掩码的VPReplicateRecipe，放置在最早的加载位置，并用它替换组中所有加载的用户。\n\n优化思路：当两个加载使用互补掩码访问相同地址时，每个迭代中必然有一个加载会执行（因为掩码互补）。因此可以安全地将加载提升为无掩码操作，消除掩码检查的开销。这减少了向量化循环中的指令数量，提高了内存访问效率，特别是在SIMD执行环境中。", "original_code": "在向量化循环中，存在多个带掩码的加载指令（predicated loads），这些加载使用互补的掩码（complementary masks）访问相同地址。由于每个加载都带有掩码条件，导致每次迭代都需要执行掩码检查，增加了指令开销。", "optimized_code": "+      VPlanTransforms::hoistPredicatedLoads(*Plan, *PSE.getSE(), OrigLoop);\n+static bool canHoistLoadWithNoAliasCheck(VPReplicateRecipe *Load,\n+                                         VPBasicBlock *FirstBB,\n+                                         VPBasicBlock *LastBB) {\n+  // Get the load's memory location and check if it aliases with any stores\n+  // using scoped noalias metadata.\n+  auto LoadLoc = vputils::getMemoryLocation(*Load);\n+  if (!LoadLoc || !LoadLoc->AATags.Scope)\n+    return false;\n+\n+  const AAMDNodes &LoadAA = LoadLoc->AATags;\n+  for (VPBlockBase *Block = FirstBB; Block;\n+       Block = Block->getSingleSuccessor()) {\n+    // This function assumes a simple linear chain of blocks. If there are\n+    // multiple successors, we would need more complex analysis.\n+    assert(Block->getNumSuccessors() <= 1 &&\n+           \"Expected at most one successor in block chain\");\n+    auto *VPBB = cast<VPBasicBlock>(Block);\n+    for (VPRecipeBase &R : *VPBB) {\n+      if (R.mayWriteToMemory()) {\n+        auto Loc = vputils::getMemoryLocation(R);\n+        // Bail out if we can't get the location or if the scoped noalias\n+        // metadata indicates potential aliasing.\n+        if (!Loc || ScopedNoAliasAAResult::mayAliasInScopes(\n+                        LoadAA.Scope, Loc->AATags.NoAlias))\n+          return false;\n+      }\n+    }\n+    if (Block == LastBB)\n+      break;\n+  }\n+  return true;\n+}\n+void VPlanTransforms::hoistPredicatedLoads(VPlan &Plan, ScalarEvolution &SE,\n+                                           const Loop *L) {\n+  // Group predicated loads by their address SCEV.\n+  DenseMap<const SCEV *, SmallVector<VPReplicateRecipe *>> LoadsByAddress;\n+  // ... (grouping logic)\n+  // For each address, collect loads with complementary masks, sort by\n+  // dominance, and use the earliest load.\n+  for (auto &[Addr, Loads] : LoadsByAddress) {\n+    if (Loads.size() < 2)\n+      continue;\n+\n+    // Collect groups of loads with complementary masks.\n+    SmallVector<SmallVector<VPReplicateRecipe *, 4>> LoadGroups;\n+    // ... (grouping by complementary masks)\n+    // For each group, check memory dependencies and hoist the earliest load.\n+    for (auto &Group : LoadGroups) {\n+      // Sort loads by dominance order, with earliest (most dominating) first.\n+      sort(Group, [&VPDT](VPReplicateRecipe *A, VPReplicateRecipe *B) {\n+        return VPDT.properlyDominates(A, B);\n+      });\n+\n+      VPReplicateRecipe *EarliestLoad = Group.front();\n+      VPBasicBlock *FirstBB = EarliestLoad->getParent();\n+      VPBasicBlock *LastBB = Group.back()->getParent();\n+\n+      // Check that the load doesn't alias with stores between first and last load.\n+      if (!canHoistLoadWithNoAliasCheck(EarliestLoad, FirstBB, LastBB))\n+        continue;\n+\n+      // Create an unpredicated VPReplicateRecipe at the position of the first load.\n+      VPReplicateRecipe *HoistedLoad = new VPReplicateRecipe(\n+          Instruction::Load, EarliestLoad->operands(),\n+          getCommonLoadMetadata(Group), /*IsPredicated=*/false);\n+      FirstBB->insert(HoistedLoad, EarliestLoad->getIterator());\n+\n+      // Replace all users of the grouped loads with the hoisted load.\n+      for (VPReplicateRecipe *Load : Group)\n+        Load->replaceAllUsesWith(HoistedLoad);\n+    }\n+  }\n+}", "source_url": "https://github.com/llvm/llvm-project/commit/4cc8cc81e3aa10e01ce6d54321cbddbc64f1bd15", "code_v0_no_empty_lines": "在向量化循环中，存在多个带掩码的加载指令（predicated loads），这些加载使用互补的掩码（complementary masks）访问相同地址。由于每个加载都带有掩码条件，导致每次迭代都需要执行掩码检查，增加了指令开销。", "code_v1_no_empty_lines": "+      VPlanTransforms::hoistPredicatedLoads(*Plan, *PSE.getSE(), OrigLoop);\n+static bool canHoistLoadWithNoAliasCheck(VPReplicateRecipe *Load,\n+                                         VPBasicBlock *FirstBB,\n+                                         VPBasicBlock *LastBB) {\n+  // Get the load's memory location and check if it aliases with any stores\n+  // using scoped noalias metadata.\n+  auto LoadLoc = vputils::getMemoryLocation(*Load);\n+  if (!LoadLoc || !LoadLoc->AATags.Scope)\n+    return false;\n+\n+  const AAMDNodes &LoadAA = LoadLoc->AATags;\n+  for (VPBlockBase *Block = FirstBB; Block;\n+       Block = Block->getSingleSuccessor()) {\n+    // This function assumes a simple linear chain of blocks. If there are\n+    // multiple successors, we would need more complex analysis.\n+    assert(Block->getNumSuccessors() <= 1 &&\n+           \"Expected at most one successor in block chain\");\n+    auto *VPBB = cast<VPBasicBlock>(Block);\n+    for (VPRecipeBase &R : *VPBB) {\n+      if (R.mayWriteToMemory()) {\n+        auto Loc = vputils::getMemoryLocation(R);\n+        // Bail out if we can't get the location or if the scoped noalias\n+        // metadata indicates potential aliasing.\n+        if (!Loc || ScopedNoAliasAAResult::mayAliasInScopes(\n+                        LoadAA.Scope, Loc->AATags.NoAlias))\n+          return false;\n+      }\n+    }\n+    if (Block == LastBB)\n+      break;\n+  }\n+  return true;\n+}\n+void VPlanTransforms::hoistPredicatedLoads(VPlan &Plan, ScalarEvolution &SE,\n+                                           const Loop *L) {\n+  // Group predicated loads by their address SCEV.\n+  DenseMap<const SCEV *, SmallVector<VPReplicateRecipe *>> LoadsByAddress;\n+  // ... (grouping logic)\n+  // For each address, collect loads with complementary masks, sort by\n+  // dominance, and use the earliest load.\n+  for (auto &[Addr, Loads] : LoadsByAddress) {\n+    if (Loads.size() < 2)\n+      continue;\n+\n+    // Collect groups of loads with complementary masks.\n+    SmallVector<SmallVector<VPReplicateRecipe *, 4>> LoadGroups;\n+    // ... (grouping by complementary masks)\n+    // For each group, check memory dependencies and hoist the earliest load.\n+    for (auto &Group : LoadGroups) {\n+      // Sort loads by dominance order, with earliest (most dominating) first.\n+      sort(Group, [&VPDT](VPReplicateRecipe *A, VPReplicateRecipe *B) {\n+        return VPDT.properlyDominates(A, B);\n+      });\n+\n+      VPReplicateRecipe *EarliestLoad = Group.front();\n+      VPBasicBlock *FirstBB = EarliestLoad->getParent();\n+      VPBasicBlock *LastBB = Group.back()->getParent();\n+\n+      // Check that the load doesn't alias with stores between first and last load.\n+      if (!canHoistLoadWithNoAliasCheck(EarliestLoad, FirstBB, LastBB))\n+        continue;\n+\n+      // Create an unpredicated VPReplicateRecipe at the position of the first load.\n+      VPReplicateRecipe *HoistedLoad = new VPReplicateRecipe(\n+          Instruction::Load, EarliestLoad->operands(),\n+          getCommonLoadMetadata(Group), /*IsPredicated=*/false);\n+      FirstBB->insert(HoistedLoad, EarliestLoad->getIterator());\n+\n+      // Replace all users of the grouped loads with the hoisted load.\n+      for (VPReplicateRecipe *Load : Group)\n+        Load->replaceAllUsesWith(HoistedLoad);\n+    }\n+  }\n+}", "target": "+      VPlanTransforms::hoistPredicatedLoads(*Plan, *PSE.getSE(), OrigLoop);\n+static bool canHoistLoadWithNoAliasCheck(VPReplicateRecipe *Load,\n+                                         VPBasicBlock *FirstBB,\n+                                         VPBasicBlock *LastBB) {\n+  // Get the load's memory location and check if it aliases with any stores\n+  // using scoped noalias metadata.\n+  auto LoadLoc = vputils::getMemoryLocation(*Load);\n+  if (!LoadLoc || !LoadLoc->AATags.Scope)\n+    return false;\n+\n+  const AAMDNodes &LoadAA = LoadLoc->AATags;\n+  for (VPBlockBase *Block = FirstBB; Block;\n+       Block = Block->getSingleSuccessor()) {\n+    // This function assumes a simple linear chain of blocks. If there are\n+    // multiple successors, we would need more complex analysis.\n+    assert(Block->getNumSuccessors() <= 1 &&\n+           \"Expected at most one successor in block chain\");\n+    auto *VPBB = cast<VPBasicBlock>(Block);\n+    for (VPRecipeBase &R : *VPBB) {\n+      if (R.mayWriteToMemory()) {\n+        auto Loc = vputils::getMemoryLocation(R);\n+        // Bail out if we can't get the location or if the scoped noalias\n+        // metadata indicates potential aliasing.\n+        if (!Loc || ScopedNoAliasAAResult::mayAliasInScopes(\n+                        LoadAA.Scope, Loc->AATags.NoAlias))\n+          return false;\n+      }\n+    }\n+    if (Block == LastBB)\n+      break;\n+  }\n+  return true;\n+}\n+void VPlanTransforms::hoistPredicatedLoads(VPlan &Plan, ScalarEvolution &SE,\n+                                           const Loop *L) {\n+  // Group predicated loads by their address SCEV.\n+  DenseMap<const SCEV *, SmallVector<VPReplicateRecipe *>> LoadsByAddress;\n+  // ... (grouping logic)\n+  // For each address, collect loads with complementary masks, sort by\n+  // dominance, and use the earliest load.\n+  for (auto &[Addr, Loads] : LoadsByAddress) {\n+    if (Loads.size() < 2)\n+      continue;\n+\n+    // Collect groups of loads with complementary masks.\n+    SmallVector<SmallVector<VPReplicateRecipe *, 4>> LoadGroups;\n+    // ... (grouping by complementary masks)\n+    // For each group, check memory dependencies and hoist the earliest load.\n+    for (auto &Group : LoadGroups) {\n+      // Sort loads by dominance order, with earliest (most dominating) first.\n+      sort(Group, [&VPDT](VPReplicateRecipe *A, VPReplicateRecipe *B) {\n+        return VPDT.properlyDominates(A, B);\n+      });\n+\n+      VPReplicateRecipe *EarliestLoad = Group.front();\n+      VPBasicBlock *FirstBB = EarliestLoad->getParent();\n+      VPBasicBlock *LastBB = Group.back()->getParent();\n+\n+      // Check that the load doesn't alias with stores between first and last load.\n+      if (!canHoistLoadWithNoAliasCheck(EarliestLoad, FirstBB, LastBB))\n+        continue;\n+\n+      // Create an unpredicated VPReplicateRecipe at the position of the first load.\n+      VPReplicateRecipe *HoistedLoad = new VPReplicateRecipe(\n+          Instruction::Load, EarliestLoad->operands(),\n+          getCommonLoadMetadata(Group), /*IsPredicated=*/false);\n+      FirstBB->insert(HoistedLoad, EarliestLoad->getIterator());\n+\n+      // Replace all users of the grouped loads with the hoisted load.\n+      for (VPReplicateRecipe *Load : Group)\n+        Load->replaceAllUsesWith(HoistedLoad);\n+    }\n+  }\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在向量化循环中，存在多个带掩码的加载指令（predicated loads），这些加载使用互补的掩码（complementary masks）访问相同地址。由于每个加载都带有掩码条件，导致每次迭代都需要执行掩码检查，增加了指令开销。\n\n优化后：新增VPlanTransforms::hoistPredicatedLoads变换，识别具有相同地址SCEV且掩码互补的加载指令组。通过检查内存别名依赖（使用scoped noalias元数据），确保在第一个和最后一个加载之间没有可能冲突的存储操作。然后创建一个无掩码的VPReplicateRecipe，放置在最早的加载位置，并用它替换组中所有加载的用户。\n\n优化思路：当两个加载使用互补掩码访问相同地址时，每个迭代中必然有一个加载会执行（因为掩码互补）。因此可以安全地将加载提升为无掩码操作，消除掩码检查的开销。这减少了向量化循环中的指令数量，提高了内存访问效率，特别是在SIMD执行环境中。"}
{"id": 400, "source": "riscv-dataset-excel", "optimization_type": "向量操作优化+SIMT分发优化", "optimization_description": "优化前：vector.extract/insert_strided_slice操作在SIMT分发时存在限制，要求分布式维度必须完全提取，无法处理部分提取的复杂情况（如从8x32xf16中提取8x16xf16）。\n优化后：新增基于布局的SIMT分发支持，通过分析数据在SIMT通道间的分布布局，允许在分布式维度上进行部分提取操作。\n优化思路：在XeGPU侧实现新的分发模式，利用布局信息判断数据在SIMT通道间的分布方式，调整源类型、大小和偏移量，使复杂提取操作能够正确分发到各个计算通道。", "original_code": "vector.extract/insert_strided_slice操作在SIMT分发时存在限制，要求分布式维度必须完全提取，无法处理部分提取的复杂情况（如从8x32xf16中提取8x16xf16）。", "optimized_code": "struct VectorExtractStridedSliceDistribution\n    : public gpu::WarpDistributionPattern {\n  using gpu::WarpDistributionPattern::WarpDistributionPattern;\n  LogicalResult matchAndRewrite(gpu::WarpExecuteOnLane0Op warpOp,\n                                PatternRewriter &rewriter) const override {\n    OpOperand *operand =\n        getWarpResult(warpOp, llvm::IsaPred<vector::ExtractStridedSliceOp>);\n    if (!operand)\n      return failure();\n    auto extractOp =\n        cast<vector::ExtractStridedSliceOp>(operand->get().getDefiningOp());\n    unsigned operandIdx = operand->getOperandNumber();\n    auto distributedType =\n        cast<VectorType>(warpOp.getResult(operandIdx).getType());\n    // Find the distributed dimensions.\n    auto extractResultType = cast<VectorType>(operand->get().getType());\n    auto distributedDims =\n        getDistributedDims(extractResultType, distributedType);\n    // Collect updated source type, sizes and offsets. They may be adjusted\n    // later if the data is distributed to lanes (as opposed to being owned by\n    // all lanes uniformly).\n    VectorType updatedSourceType = extractOp.getSourceVectorType();\n    SmallVector<Attribute> updatedSizes = llvm::map_to_vector(\n        extractOp.getSizes(), [](Attribute attr) { return attr; });\n    SmallVector<Attribute> updatedOffsets = llvm::map_to_vector(\n        extractOp.getOffsets(), [](Attribute attr) { return attr; });\n    // If the result is distributed, it must be distributed in exactly one\n    // dimension. In this case, we adjust the sourceDistType, distributedSizes\n    // and distributedOffsets accordingly.\n    if (distributedDims.size() > 0) {\n      if (distributedDims.size() != 1)\n        return rewriter.notifyMatchFailure(\n            warpOp, \"Source can not be distributed in multiple dimensions.\");\n      int64_t distributedDim = distributedDims[0];\n      int sourceDistrDimSize =\n          extractOp.getSourceVectorType().getShape()[distributedDim];\n      auto sourceLayout =\n          xegpu::getDistributeLayoutAttr(extractOp->getOpOperand(0));\n      if (!sourceLayout || sourceLayout.getEffectiveLaneLayoutAsInt().empty())\n        return rewriter.notifyMatchFailure(\n            warpOp, \"the source of extract_strided_slice op lacks distribution \"\n                    \"layout\");\n      auto sourceLaneLayout = sourceLayout.getEffectiveLaneLayoutAsInt();\n      // Because only single dimension distribution is supported, lane layout\n      // size at the distributed dim must be the subgroup size.\n      int subgroupSize = sourceLaneLayout[distributedDim];\n      // Check if the source size in the distributed dimension is a multiple of\n      // subgroup size.\n      if (sourceDistrDimSize % subgroupSize != 0)\n        return rewriter.notifyMatchFailure(\n            warpOp,\n            \"Source size along distributed dimension is not a multiple of \"\n            \"subgroup size.\");\n      auto sourceLaneData = sourceLayout.getEffectiveLaneDataAsInt();\n      // We expect lane data to be all ones in this case.\n      if (!llvm::all_of(sourceLaneData, [](int64_t v) { return v == 1; }))\n        return rewriter.notifyMatchFailure(\n            warpOp, \"Expecting unit lane data in source layout\");\n      // The offsets in the distributed dimention must be a multiple of subgroup\n      // size.\n      int64_t distrDimOffset =\n          cast<IntegerAttr>(extractOp.getOffsets()[distributedDim]).getInt();\n      if (distrDimOffset % subgroupSize != 0)\n        return rewriter.notifyMatchFailure(\n            warpOp, \"Offset along distributed dimension \"\n                    \"is not a multiple of subgroup size.\");\n      updatedSourceType = getDistVecTypeBasedOnLaneLayout(\n                              sourceLayout, extractOp.getSourceVectorType())\n                              .value();\n      // Update the distributed sizes to match the distributed type.\n      updatedSizes[distributedDim] = rewriter.getI64IntegerAttr(\n          distributedType.getDimSize(distributedDim));\n      // Update the distributed offsets to match round robin distribution (i.e.\n      // each lane owns data at `subgroupSize` stride given unit lane data).\n      updatedOffsets[distributedDim] =\n          rewriter.getI64IntegerAttr(distrDimOffset / subgroupSize);\n    }\n    // Do the distribution by yielding the source of the extract op from\n    // the warp op and creating a new extract op outside the warp op.\n    SmallVector<size_t> newRetIndices;\n    auto newWarpOp = moveRegionToNewWarpOpAndAppendReturns(\n        rewriter, warpOp, {extractOp.getSource()}, {updatedSourceType},\n        newRetIndices);\n    rewriter.setInsertionPointAfter(newWarpOp);\n    Value source = newWarpOp.getResult(newRetIndices[0]);\n    // Create a new extract op outside the warp op.\n    Value newExtractOp = vector::ExtractStridedSliceOp::create(\n        rewriter, extractOp.getLoc(), distributedType, source,", "source_url": "https://github.com/llvm/llvm-project/commit/c333f7dab9f89734777f7d19bc7b68c86f393216", "code_v0_no_empty_lines": "vector.extract/insert_strided_slice操作在SIMT分发时存在限制，要求分布式维度必须完全提取，无法处理部分提取的复杂情况（如从8x32xf16中提取8x16xf16）。", "code_v1_no_empty_lines": "struct VectorExtractStridedSliceDistribution\n    : public gpu::WarpDistributionPattern {\n  using gpu::WarpDistributionPattern::WarpDistributionPattern;\n  LogicalResult matchAndRewrite(gpu::WarpExecuteOnLane0Op warpOp,\n                                PatternRewriter &rewriter) const override {\n    OpOperand *operand =\n        getWarpResult(warpOp, llvm::IsaPred<vector::ExtractStridedSliceOp>);\n    if (!operand)\n      return failure();\n    auto extractOp =\n        cast<vector::ExtractStridedSliceOp>(operand->get().getDefiningOp());\n    unsigned operandIdx = operand->getOperandNumber();\n    auto distributedType =\n        cast<VectorType>(warpOp.getResult(operandIdx).getType());\n    // Find the distributed dimensions.\n    auto extractResultType = cast<VectorType>(operand->get().getType());\n    auto distributedDims =\n        getDistributedDims(extractResultType, distributedType);\n    // Collect updated source type, sizes and offsets. They may be adjusted\n    // later if the data is distributed to lanes (as opposed to being owned by\n    // all lanes uniformly).\n    VectorType updatedSourceType = extractOp.getSourceVectorType();\n    SmallVector<Attribute> updatedSizes = llvm::map_to_vector(\n        extractOp.getSizes(), [](Attribute attr) { return attr; });\n    SmallVector<Attribute> updatedOffsets = llvm::map_to_vector(\n        extractOp.getOffsets(), [](Attribute attr) { return attr; });\n    // If the result is distributed, it must be distributed in exactly one\n    // dimension. In this case, we adjust the sourceDistType, distributedSizes\n    // and distributedOffsets accordingly.\n    if (distributedDims.size() > 0) {\n      if (distributedDims.size() != 1)\n        return rewriter.notifyMatchFailure(\n            warpOp, \"Source can not be distributed in multiple dimensions.\");\n      int64_t distributedDim = distributedDims[0];\n      int sourceDistrDimSize =\n          extractOp.getSourceVectorType().getShape()[distributedDim];\n      auto sourceLayout =\n          xegpu::getDistributeLayoutAttr(extractOp->getOpOperand(0));\n      if (!sourceLayout || sourceLayout.getEffectiveLaneLayoutAsInt().empty())\n        return rewriter.notifyMatchFailure(\n            warpOp, \"the source of extract_strided_slice op lacks distribution \"\n                    \"layout\");\n      auto sourceLaneLayout = sourceLayout.getEffectiveLaneLayoutAsInt();\n      // Because only single dimension distribution is supported, lane layout\n      // size at the distributed dim must be the subgroup size.\n      int subgroupSize = sourceLaneLayout[distributedDim];\n      // Check if the source size in the distributed dimension is a multiple of\n      // subgroup size.\n      if (sourceDistrDimSize % subgroupSize != 0)\n        return rewriter.notifyMatchFailure(\n            warpOp,\n            \"Source size along distributed dimension is not a multiple of \"\n            \"subgroup size.\");\n      auto sourceLaneData = sourceLayout.getEffectiveLaneDataAsInt();\n      // We expect lane data to be all ones in this case.\n      if (!llvm::all_of(sourceLaneData, [](int64_t v) { return v == 1; }))\n        return rewriter.notifyMatchFailure(\n            warpOp, \"Expecting unit lane data in source layout\");\n      // The offsets in the distributed dimention must be a multiple of subgroup\n      // size.\n      int64_t distrDimOffset =\n          cast<IntegerAttr>(extractOp.getOffsets()[distributedDim]).getInt();\n      if (distrDimOffset % subgroupSize != 0)\n        return rewriter.notifyMatchFailure(\n            warpOp, \"Offset along distributed dimension \"\n                    \"is not a multiple of subgroup size.\");\n      updatedSourceType = getDistVecTypeBasedOnLaneLayout(\n                              sourceLayout, extractOp.getSourceVectorType())\n                              .value();\n      // Update the distributed sizes to match the distributed type.\n      updatedSizes[distributedDim] = rewriter.getI64IntegerAttr(\n          distributedType.getDimSize(distributedDim));\n      // Update the distributed offsets to match round robin distribution (i.e.\n      // each lane owns data at `subgroupSize` stride given unit lane data).\n      updatedOffsets[distributedDim] =\n          rewriter.getI64IntegerAttr(distrDimOffset / subgroupSize);\n    }\n    // Do the distribution by yielding the source of the extract op from\n    // the warp op and creating a new extract op outside the warp op.\n    SmallVector<size_t> newRetIndices;\n    auto newWarpOp = moveRegionToNewWarpOpAndAppendReturns(\n        rewriter, warpOp, {extractOp.getSource()}, {updatedSourceType},\n        newRetIndices);\n    rewriter.setInsertionPointAfter(newWarpOp);\n    Value source = newWarpOp.getResult(newRetIndices[0]);\n    // Create a new extract op outside the warp op.\n    Value newExtractOp = vector::ExtractStridedSliceOp::create(\n        rewriter, extractOp.getLoc(), distributedType, source,", "target": "struct VectorExtractStridedSliceDistribution\n    : public gpu::WarpDistributionPattern {\n  using gpu::WarpDistributionPattern::WarpDistributionPattern;\n  LogicalResult matchAndRewrite(gpu::WarpExecuteOnLane0Op warpOp,\n                                PatternRewriter &rewriter) const override {\n    OpOperand *operand =\n        getWarpResult(warpOp, llvm::IsaPred<vector::ExtractStridedSliceOp>);\n    if (!operand)\n      return failure();\n    auto extractOp =\n        cast<vector::ExtractStridedSliceOp>(operand->get().getDefiningOp());\n    unsigned operandIdx = operand->getOperandNumber();\n    auto distributedType =\n        cast<VectorType>(warpOp.getResult(operandIdx).getType());\n    // Find the distributed dimensions.\n    auto extractResultType = cast<VectorType>(operand->get().getType());\n    auto distributedDims =\n        getDistributedDims(extractResultType, distributedType);\n    // Collect updated source type, sizes and offsets. They may be adjusted\n    // later if the data is distributed to lanes (as opposed to being owned by\n    // all lanes uniformly).\n    VectorType updatedSourceType = extractOp.getSourceVectorType();\n    SmallVector<Attribute> updatedSizes = llvm::map_to_vector(\n        extractOp.getSizes(), [](Attribute attr) { return attr; });\n    SmallVector<Attribute> updatedOffsets = llvm::map_to_vector(\n        extractOp.getOffsets(), [](Attribute attr) { return attr; });\n    // If the result is distributed, it must be distributed in exactly one\n    // dimension. In this case, we adjust the sourceDistType, distributedSizes\n    // and distributedOffsets accordingly.\n    if (distributedDims.size() > 0) {\n      if (distributedDims.size() != 1)\n        return rewriter.notifyMatchFailure(\n            warpOp, \"Source can not be distributed in multiple dimensions.\");\n      int64_t distributedDim = distributedDims[0];\n      int sourceDistrDimSize =\n          extractOp.getSourceVectorType().getShape()[distributedDim];\n      auto sourceLayout =\n          xegpu::getDistributeLayoutAttr(extractOp->getOpOperand(0));\n      if (!sourceLayout || sourceLayout.getEffectiveLaneLayoutAsInt().empty())\n        return rewriter.notifyMatchFailure(\n            warpOp, \"the source of extract_strided_slice op lacks distribution \"\n                    \"layout\");\n      auto sourceLaneLayout = sourceLayout.getEffectiveLaneLayoutAsInt();\n      // Because only single dimension distribution is supported, lane layout\n      // size at the distributed dim must be the subgroup size.\n      int subgroupSize = sourceLaneLayout[distributedDim];\n      // Check if the source size in the distributed dimension is a multiple of\n      // subgroup size.\n      if (sourceDistrDimSize % subgroupSize != 0)\n        return rewriter.notifyMatchFailure(\n            warpOp,\n            \"Source size along distributed dimension is not a multiple of \"\n            \"subgroup size.\");\n      auto sourceLaneData = sourceLayout.getEffectiveLaneDataAsInt();\n      // We expect lane data to be all ones in this case.\n      if (!llvm::all_of(sourceLaneData, [](int64_t v) { return v == 1; }))\n        return rewriter.notifyMatchFailure(\n            warpOp, \"Expecting unit lane data in source layout\");\n      // The offsets in the distributed dimention must be a multiple of subgroup\n      // size.\n      int64_t distrDimOffset =\n          cast<IntegerAttr>(extractOp.getOffsets()[distributedDim]).getInt();\n      if (distrDimOffset % subgroupSize != 0)\n        return rewriter.notifyMatchFailure(\n            warpOp, \"Offset along distributed dimension \"\n                    \"is not a multiple of subgroup size.\");\n      updatedSourceType = getDistVecTypeBasedOnLaneLayout(\n                              sourceLayout, extractOp.getSourceVectorType())\n                              .value();\n      // Update the distributed sizes to match the distributed type.\n      updatedSizes[distributedDim] = rewriter.getI64IntegerAttr(\n          distributedType.getDimSize(distributedDim));\n      // Update the distributed offsets to match round robin distribution (i.e.\n      // each lane owns data at `subgroupSize` stride given unit lane data).\n      updatedOffsets[distributedDim] =\n          rewriter.getI64IntegerAttr(distrDimOffset / subgroupSize);\n    }\n    // Do the distribution by yielding the source of the extract op from\n    // the warp op and creating a new extract op outside the warp op.\n    SmallVector<size_t> newRetIndices;\n    auto newWarpOp = moveRegionToNewWarpOpAndAppendReturns(\n        rewriter, warpOp, {extractOp.getSource()}, {updatedSourceType},\n        newRetIndices);\n    rewriter.setInsertionPointAfter(newWarpOp);\n    Value source = newWarpOp.getResult(newRetIndices[0]);\n    // Create a new extract op outside the warp op.\n    Value newExtractOp = vector::ExtractStridedSliceOp::create(\n        rewriter, extractOp.getLoc(), distributedType, source,", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：vector.extract/insert_strided_slice操作在SIMT分发时存在限制，要求分布式维度必须完全提取，无法处理部分提取的复杂情况（如从8x32xf16中提取8x16xf16）。\n优化后：新增基于布局的SIMT分发支持，通过分析数据在SIMT通道间的分布布局，允许在分布式维度上进行部分提取操作。\n优化思路：在XeGPU侧实现新的分发模式，利用布局信息判断数据在SIMT通道间的分布方式，调整源类型、大小和偏移量，使复杂提取操作能够正确分发到各个计算通道。"}
{"id": 401, "source": "riscv-dataset-excel", "optimization_type": "内存分配优化", "optimization_description": "优化前：使用Java的多维数组初始化语法 new short[first][second] 一次性分配内存，这种方式在分配大数组时可能产生额外的开销。优化后：通过新增的 shortMatrixAlloc 和 byteMatrixAlloc 方法，手动循环分配每个子数组，减少了内存分配的开销。优化思路：手动分配多维数组的每个维度比一次性分配更高效，提升了ML-KEM算法的性能。", "original_code": "使用Java的多维数组初始化语法 new short[first][second] 一次性分配内存，这种方式在分配大数组时可能产生额外的开销。", "optimized_code": "- short[][] zeroes = new short[mlKem_k][ML_KEM_N];\n+ short[][] zeroes = shortMatrixAlloc(mlKem_k, ML_KEM_N);\n- byte[][] xofBufArr = new byte[nrPar][XOF_BLOCK_LEN + XOF_PAD];\n+ byte[][] xofBufArr = byteMatrixAlloc(nrPar, XOF_BLOCK_LEN + XOF_PAD);", "source_url": "https://github.com/openjdk/riscv-port/commit/ecabea6cd315eaf08571ef61ff267318140d147b", "code_v0_no_empty_lines": "使用Java的多维数组初始化语法 new short[first][second] 一次性分配内存，这种方式在分配大数组时可能产生额外的开销。", "code_v1_no_empty_lines": "- short[][] zeroes = new short[mlKem_k][ML_KEM_N];\n+ short[][] zeroes = shortMatrixAlloc(mlKem_k, ML_KEM_N);\n- byte[][] xofBufArr = new byte[nrPar][XOF_BLOCK_LEN + XOF_PAD];\n+ byte[][] xofBufArr = byteMatrixAlloc(nrPar, XOF_BLOCK_LEN + XOF_PAD);", "target": "- short[][] zeroes = new short[mlKem_k][ML_KEM_N];\n+ short[][] zeroes = shortMatrixAlloc(mlKem_k, ML_KEM_N);\n- byte[][] xofBufArr = new byte[nrPar][XOF_BLOCK_LEN + XOF_PAD];\n+ byte[][] xofBufArr = byteMatrixAlloc(nrPar, XOF_BLOCK_LEN + XOF_PAD);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用Java的多维数组初始化语法 new short[first][second] 一次性分配内存，这种方式在分配大数组时可能产生额外的开销。优化后：通过新增的 shortMatrixAlloc 和 byteMatrixAlloc 方法，手动循环分配每个子数组，减少了内存分配的开销。优化思路：手动分配多维数组的每个维度比一次性分配更高效，提升了ML-KEM算法的性能。"}
{"id": 402, "source": "riscv-dataset-excel", "optimization_type": "寄存器分配优化", "optimization_description": "优化前：PPC64架构的非易失性向量寄存器在C2编译器（服务器端编译器）的寄存器分配中不可用，限制了向量化代码的寄存器资源。优化后：通过修改汇编器、宏汇编器、寄存器定义和编译器后端（ppc.ad）等多个组件，使非易失性向量寄存器可用于C2寄存器分配，增加了寄存器分配池，提升了向量化代码的性能和寄存器利用率。优化思路：扩展寄存器分配器以利用更多硬件寄存器资源，减少寄存器压力，提高代码生成质量。", "original_code": "PPC64架构的非易失性向量寄存器在C2编译器（服务器端编译器）的寄存器分配中不可用，限制了向量化代码的寄存器资源。", "optimized_code": "- // 优化前：非易失性向量寄存器未用于C2寄存器分配\n+ // 优化后：使非易失性向量寄存器可用于C2寄存器分配，增加寄存器分配池", "source_url": "https://github.com/openjdk/riscv-port/commit/fc6f4da8e72db4385c96fe0139ce43ec8c8ca2e6", "code_v0_no_empty_lines": "PPC64架构的非易失性向量寄存器在C2编译器（服务器端编译器）的寄存器分配中不可用，限制了向量化代码的寄存器资源。", "code_v1_no_empty_lines": "- // 优化前：非易失性向量寄存器未用于C2寄存器分配\n+ // 优化后：使非易失性向量寄存器可用于C2寄存器分配，增加寄存器分配池", "target": "- // 优化前：非易失性向量寄存器未用于C2寄存器分配\n+ // 优化后：使非易失性向量寄存器可用于C2寄存器分配，增加寄存器分配池", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PPC64架构的非易失性向量寄存器在C2编译器（服务器端编译器）的寄存器分配中不可用，限制了向量化代码的寄存器资源。优化后：通过修改汇编器、宏汇编器、寄存器定义和编译器后端（ppc.ad）等多个组件，使非易失性向量寄存器可用于C2寄存器分配，增加了寄存器分配池，提升了向量化代码的性能和寄存器利用率。优化思路：扩展寄存器分配器以利用更多硬件寄存器资源，减少寄存器压力，提高代码生成质量。"}
{"id": 403, "source": "riscv-dataset-excel", "optimization_type": "指令优化+内存访问优化", "optimization_description": "优化前：数组填充stub在处理尾部剩余元素时，按字节、半字、字的顺序处理，可能导致多次小内存访问和分支跳转。优化后：重新排序处理逻辑，优先处理较大内存块（4字节），减少内存访问次数和分支预测开销。思路：通过调整位测试顺序和内存操作顺序，优化尾部处理的指令流水线和内存访问模式，提高数组填充性能。", "original_code": "数组填充stub在处理尾部剩余元素时，按字节、半字、字的顺序处理，可能导致多次小内存访问和分支跳转。", "optimized_code": "-    Label L_fill_2, L_fill_4, L_exit1;\n+    Label L_fill_1, L_fill_2, L_exit1;\n       case T_BYTE:\n-        __ test_bit(t0, count, 0);\n+        __ test_bit(t0, count, 2);\n         __ beqz(t0, L_fill_2);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n+        __ sw(value, Address(to, 0));\n+        __ addi(to, to, 4);\n         __ bind(L_fill_2);\n         __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_4);\n+        __ beqz(t0, L_fill_1);\n         __ sh(value, Address(to, 0));\n         __ addi(to, to, 2);\n-        __ bind(L_fill_4);\n-        __ test_bit(t0, count, 2);\n+        __ bind(L_fill_1);\n+        __ test_bit(t0, count, 0);\n         __ beqz(t0, L_exit1);\n-        __ sw(value, Address(to, 0));\n+        __ sb(value, Address(to, 0));\n         break;\n       case T_SHORT:\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_fill_4);\n-        __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ bind(L_fill_4);\n         __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_exit1);\n+        __ beqz(t0, L_fill_2);\n         __ sw(value, Address(to, 0));\n+        __ addi(to, to, 4);\n+        __ bind(L_fill_2);\n+        __ test_bit(t0, count, 0);\n+        __ beqz(t0, L_exit1);\n+        __ sh(value, Address(to, 0));", "source_url": "https://github.com/openjdk/riscv-port/commit/b76b610788cea7149a04faeeba01067272b6e046", "code_v0_no_empty_lines": "数组填充stub在处理尾部剩余元素时，按字节、半字、字的顺序处理，可能导致多次小内存访问和分支跳转。", "code_v1_no_empty_lines": "-    Label L_fill_2, L_fill_4, L_exit1;\n+    Label L_fill_1, L_fill_2, L_exit1;\n       case T_BYTE:\n-        __ test_bit(t0, count, 0);\n+        __ test_bit(t0, count, 2);\n         __ beqz(t0, L_fill_2);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n+        __ sw(value, Address(to, 0));\n+        __ addi(to, to, 4);\n         __ bind(L_fill_2);\n         __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_4);\n+        __ beqz(t0, L_fill_1);\n         __ sh(value, Address(to, 0));\n         __ addi(to, to, 2);\n-        __ bind(L_fill_4);\n-        __ test_bit(t0, count, 2);\n+        __ bind(L_fill_1);\n+        __ test_bit(t0, count, 0);\n         __ beqz(t0, L_exit1);\n-        __ sw(value, Address(to, 0));\n+        __ sb(value, Address(to, 0));\n         break;\n       case T_SHORT:\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_fill_4);\n-        __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ bind(L_fill_4);\n         __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_exit1);\n+        __ beqz(t0, L_fill_2);\n         __ sw(value, Address(to, 0));\n+        __ addi(to, to, 4);\n+        __ bind(L_fill_2);\n+        __ test_bit(t0, count, 0);\n+        __ beqz(t0, L_exit1);\n+        __ sh(value, Address(to, 0));", "target": "-    Label L_fill_2, L_fill_4, L_exit1;\n+    Label L_fill_1, L_fill_2, L_exit1;\n       case T_BYTE:\n-        __ test_bit(t0, count, 0);\n+        __ test_bit(t0, count, 2);\n         __ beqz(t0, L_fill_2);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n+        __ sw(value, Address(to, 0));\n+        __ addi(to, to, 4);\n         __ bind(L_fill_2);\n         __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_4);\n+        __ beqz(t0, L_fill_1);\n         __ sh(value, Address(to, 0));\n         __ addi(to, to, 2);\n-        __ bind(L_fill_4);\n-        __ test_bit(t0, count, 2);\n+        __ bind(L_fill_1);\n+        __ test_bit(t0, count, 0);\n         __ beqz(t0, L_exit1);\n-        __ sw(value, Address(to, 0));\n+        __ sb(value, Address(to, 0));\n         break;\n       case T_SHORT:\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_fill_4);\n-        __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ bind(L_fill_4);\n         __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_exit1);\n+        __ beqz(t0, L_fill_2);\n         __ sw(value, Address(to, 0));\n+        __ addi(to, to, 4);\n+        __ bind(L_fill_2);\n+        __ test_bit(t0, count, 0);\n+        __ beqz(t0, L_exit1);\n+        __ sh(value, Address(to, 0));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：数组填充stub在处理尾部剩余元素时，按字节、半字、字的顺序处理，可能导致多次小内存访问和分支跳转。优化后：重新排序处理逻辑，优先处理较大内存块（4字节），减少内存访问次数和分支预测开销。思路：通过调整位测试顺序和内存操作顺序，优化尾部处理的指令流水线和内存访问模式，提高数组填充性能。"}
{"id": 404, "source": "riscv-dataset-excel", "optimization_type": "内存分配优化", "optimization_description": "优化前：代码中大量使用直接的多维数组初始化（如 new int[mlDsa_l][ML_DSA_N]），这可能导致内存分配开销较大且缺乏缓存优化。优化后：1. 将整数矩阵分配统一替换为 integerMatrixAlloc() 方法调用，将布尔矩阵分配替换为 booleanMatrixAlloc() 方法调用，这些方法内部可能实现了更高效的内存分配策略（如对象池、缓存对齐等）。2. 对于三维数组 generateA() 方法，将一次性初始化改为手动循环初始化，避免可能的多维数组初始化开销。优化思路：通过统一的内存分配接口和手动控制多维数组初始化，减少内存分配开销，提高缓存效率，从而提升 ML-DSA 算法的整体性能。", "original_code": "代码中大量使用直接的多维数组初始化（如 new int[mlDsa_l][ML_DSA_N]），这可能导致内存分配开销较大且缺乏缓存优化。", "optimized_code": "- int[][] s1 = new int[mlDsa_l][ML_DSA_N];\n+ int[][] s1 = integerMatrixAlloc(mlDsa_l, ML_DSA_N);\n- boolean[][] h = new boolean[mlDsa_k][ML_DSA_N];\n+ boolean[][] h = booleanMatrixAlloc(mlDsa_k, ML_DSA_N);\n- int[][][] a = new int[mlDsa_k][mlDsa_l][];\n+ int[][][] a = new int[mlDsa_k][][];\n+ for (int i = 0; i < mlDsa_k; i++) {\n+     a[i] = new int[mlDsa_l][];\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/10dcdf1b4738efc6b4deaf96f4d123aff4dab832", "code_v0_no_empty_lines": "代码中大量使用直接的多维数组初始化（如 new int[mlDsa_l][ML_DSA_N]），这可能导致内存分配开销较大且缺乏缓存优化。", "code_v1_no_empty_lines": "- int[][] s1 = new int[mlDsa_l][ML_DSA_N];\n+ int[][] s1 = integerMatrixAlloc(mlDsa_l, ML_DSA_N);\n- boolean[][] h = new boolean[mlDsa_k][ML_DSA_N];\n+ boolean[][] h = booleanMatrixAlloc(mlDsa_k, ML_DSA_N);\n- int[][][] a = new int[mlDsa_k][mlDsa_l][];\n+ int[][][] a = new int[mlDsa_k][][];\n+ for (int i = 0; i < mlDsa_k; i++) {\n+     a[i] = new int[mlDsa_l][];\n+ }", "target": "- int[][] s1 = new int[mlDsa_l][ML_DSA_N];\n+ int[][] s1 = integerMatrixAlloc(mlDsa_l, ML_DSA_N);\n- boolean[][] h = new boolean[mlDsa_k][ML_DSA_N];\n+ boolean[][] h = booleanMatrixAlloc(mlDsa_k, ML_DSA_N);\n- int[][][] a = new int[mlDsa_k][mlDsa_l][];\n+ int[][][] a = new int[mlDsa_k][][];\n+ for (int i = 0; i < mlDsa_k; i++) {\n+     a[i] = new int[mlDsa_l][];\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：代码中大量使用直接的多维数组初始化（如 new int[mlDsa_l][ML_DSA_N]），这可能导致内存分配开销较大且缺乏缓存优化。优化后：1. 将整数矩阵分配统一替换为 integerMatrixAlloc() 方法调用，将布尔矩阵分配替换为 booleanMatrixAlloc() 方法调用，这些方法内部可能实现了更高效的内存分配策略（如对象池、缓存对齐等）。2. 对于三维数组 generateA() 方法，将一次性初始化改为手动循环初始化，避免可能的多维数组初始化开销。优化思路：通过统一的内存分配接口和手动控制多维数组初始化，减少内存分配开销，提高缓存效率，从而提升 ML-DSA 算法的整体性能。"}
{"id": 405, "source": "riscv-dataset-excel", "optimization_type": "启动性能优化+配置优化", "optimization_description": "优化前：EagerJVMCI默认值为false，JVMCI初始化延迟，可能导致首次编译请求时产生额外开销。优化后：当UseJVMCICompiler为true时，EagerJVMCI默认值改为true，强制JVMCI在启动时立即初始化，减少首次编译的延迟。思路：通过提前初始化JVMCI组件，避免运行时首次编译请求时的初始化开销，提升启动性能和响应速度。", "original_code": "EagerJVMCI默认值为false，JVMCI初始化延迟，可能导致首次编译请求时产生额外开销。", "optimized_code": "FLAG_SET_ERGO_IF_DEFAULT(EagerJVMCI, true);", "source_url": "https://github.com/openjdk/riscv-port/commit/08b2df80c68e182fbf6b1fc94e991c02b23040ec", "code_v0_no_empty_lines": "EagerJVMCI默认值为false，JVMCI初始化延迟，可能导致首次编译请求时产生额外开销。", "code_v1_no_empty_lines": "FLAG_SET_ERGO_IF_DEFAULT(EagerJVMCI, true);", "target": "FLAG_SET_ERGO_IF_DEFAULT(EagerJVMCI, true);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：EagerJVMCI默认值为false，JVMCI初始化延迟，可能导致首次编译请求时产生额外开销。优化后：当UseJVMCICompiler为true时，EagerJVMCI默认值改为true，强制JVMCI在启动时立即初始化，减少首次编译的延迟。思路：通过提前初始化JVMCI组件，避免运行时首次编译请求时的初始化开销，提升启动性能和响应速度。"}
{"id": 406, "source": "riscv-dataset-excel", "optimization_type": "代码简化+内存优化", "optimization_description": "优化前：CompilerTask中维护了hot_method字段，用于追踪热点方法，但该字段实际上与method字段重复（hot_method总是等于method或为null）。优化后：移除了hot_method参数和相关字段，简化了API接口和数据结构。优化思路：通过分析发现hot_method是冗余的，移除后减少了内存占用和参数传递开销，同时简化了代码逻辑。", "original_code": "CompilerTask中维护了hot_method字段，用于追踪热点方法，但该字段实际上与method字段重复（hot_method总是等于method或为null）。", "optimized_code": "-void CompileBroker::compile_method_base(const methodHandle& method,\n                                        int osr_bci,\n                                        int comp_level,\n                                        const methodHandle& hot_method,\n                                        int hot_count,\n                                        CompileTask::CompileReason compile_reason,\n                                        bool blocking,\n                                        TRAPS)\n+void CompileBroker::compile_method_base(const methodHandle& method,\n                                        int osr_bci,\n                                        int comp_level,\n                                        int hot_count,\n                                        CompileTask::CompileReason compile_reason,\n                                        bool blocking,\n                                        TRAPS)", "source_url": "https://github.com/openjdk/riscv-port/commit/48d2acb3860f742eb1c06b89f8a7208d0d7a01e7", "code_v0_no_empty_lines": "CompilerTask中维护了hot_method字段，用于追踪热点方法，但该字段实际上与method字段重复（hot_method总是等于method或为null）。", "code_v1_no_empty_lines": "-void CompileBroker::compile_method_base(const methodHandle& method,\n                                        int osr_bci,\n                                        int comp_level,\n                                        const methodHandle& hot_method,\n                                        int hot_count,\n                                        CompileTask::CompileReason compile_reason,\n                                        bool blocking,\n                                        TRAPS)\n+void CompileBroker::compile_method_base(const methodHandle& method,\n                                        int osr_bci,\n                                        int comp_level,\n                                        int hot_count,\n                                        CompileTask::CompileReason compile_reason,\n                                        bool blocking,\n                                        TRAPS)", "target": "-void CompileBroker::compile_method_base(const methodHandle& method,\n                                        int osr_bci,\n                                        int comp_level,\n                                        const methodHandle& hot_method,\n                                        int hot_count,\n                                        CompileTask::CompileReason compile_reason,\n                                        bool blocking,\n                                        TRAPS)\n+void CompileBroker::compile_method_base(const methodHandle& method,\n                                        int osr_bci,\n                                        int comp_level,\n                                        int hot_count,\n                                        CompileTask::CompileReason compile_reason,\n                                        bool blocking,\n                                        TRAPS)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CompilerTask中维护了hot_method字段，用于追踪热点方法，但该字段实际上与method字段重复（hot_method总是等于method或为null）。优化后：移除了hot_method参数和相关字段，简化了API接口和数据结构。优化思路：通过分析发现hot_method是冗余的，移除后减少了内存占用和参数传递开销，同时简化了代码逻辑。"}
{"id": 407, "source": "riscv-dataset-excel", "optimization_type": "延迟初始化优化+并发性能优化", "optimization_description": "优化前：available字段为普通HashSet，通过synchronized的getCurrencies()方法实现延迟初始化，每次调用需要同步锁开销。优化后：使用Supplier和StableValue.supplier实现线程安全的延迟初始化，移除了synchronized同步锁，通过computeAllCurrencies()方法直接计算并返回集合。优化思路：利用StableValue.supplier的线程安全特性，避免同步锁竞争，提高多线程环境下的性能，同时保持延迟初始化的特性。", "original_code": "available字段为普通HashSet，通过synchronized的getCurrencies()方法实现延迟初始化，每次调用需要同步锁开销。", "optimized_code": "- private static HashSet<Currency> available;\n+ private static final Supplier<HashSet<Currency>> available =\n+            StableValue.supplier(Currency::computeAllCurrencies);\n\n- private static synchronized HashSet<Currency> getCurrencies() {\n-     if (available == null) {\n-         // 初始化逻辑\n-     }\n-     return available;\n- }\n+ private static HashSet<Currency> computeAllCurrencies() {\n+     // 初始化逻辑\n+     return available;\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/b6b5ac1ef9042ed62a8358aa6943b8dc87dcf0ab", "code_v0_no_empty_lines": "available字段为普通HashSet，通过synchronized的getCurrencies()方法实现延迟初始化，每次调用需要同步锁开销。", "code_v1_no_empty_lines": "- private static HashSet<Currency> available;\n+ private static final Supplier<HashSet<Currency>> available =\n+            StableValue.supplier(Currency::computeAllCurrencies);\n\n- private static synchronized HashSet<Currency> getCurrencies() {\n-     if (available == null) {\n-         // 初始化逻辑\n-     }\n-     return available;\n- }\n+ private static HashSet<Currency> computeAllCurrencies() {\n+     // 初始化逻辑\n+     return available;\n+ }", "target": "- private static HashSet<Currency> available;\n+ private static final Supplier<HashSet<Currency>> available =\n+            StableValue.supplier(Currency::computeAllCurrencies);\n\n- private static synchronized HashSet<Currency> getCurrencies() {\n-     if (available == null) {\n-         // 初始化逻辑\n-     }\n-     return available;\n- }\n+ private static HashSet<Currency> computeAllCurrencies() {\n+     // 初始化逻辑\n+     return available;\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：available字段为普通HashSet，通过synchronized的getCurrencies()方法实现延迟初始化，每次调用需要同步锁开销。优化后：使用Supplier和StableValue.supplier实现线程安全的延迟初始化，移除了synchronized同步锁，通过computeAllCurrencies()方法直接计算并返回集合。优化思路：利用StableValue.supplier的线程安全特性，避免同步锁竞争，提高多线程环境下的性能，同时保持延迟初始化的特性。"}
{"id": 408, "source": "riscv-dataset-excel", "optimization_type": "常量折叠优化", "optimization_description": "优化前：ReverseBytes节点（字节反转操作）在编译时无法对常量输入进行折叠，需要在运行时计算。优化后：新增ReverseBytesNode基类并实现Value()方法，当输入为常量时，在编译阶段直接计算字节反转结果并替换为常量节点。优化思路：通过常量折叠消除运行时计算开销，减少生成的机器指令数量，提升编译后代码的执行效率。", "original_code": "ReverseBytes节点（字节反转操作）在编译时无法对常量输入进行折叠，需要在运行时计算。", "optimized_code": "static const Type* reverse_bytes(int opcode, const Type* con) {\n  switch (opcode) {\n    case Op_ReverseBytesS:  return TypeInt::make(byteswap(checked_cast<jshort>(con->is_int()->get_con())));\n    case Op_ReverseBytesUS: return TypeInt::make(byteswap(checked_cast<jchar>(con->is_int()->get_con())));\n    case Op_ReverseBytesI:  return TypeInt::make(byteswap(checked_cast<jint>(con->is_int()->get_con())));\n    case Op_ReverseBytesL:  return TypeLong::make(byteswap(checked_cast<jlong>(con->is_long()->get_con())));\n    default: ShouldNotReachHere();\n  }\n}\n\nconst Type* ReverseBytesNode::Value(PhaseGVN* phase) const {\n  const Type* type = phase->type(in(1));\n  if (type == Type::TOP) {\n    return Type::TOP;\n  }\n  if (type->singleton()) {\n    return reverse_bytes(Opcode(), type);\n  }\n  return bottom_type();\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/de801fea76b1328f3bda503088618162388eb119", "code_v0_no_empty_lines": "ReverseBytes节点（字节反转操作）在编译时无法对常量输入进行折叠，需要在运行时计算。", "code_v1_no_empty_lines": "static const Type* reverse_bytes(int opcode, const Type* con) {\n  switch (opcode) {\n    case Op_ReverseBytesS:  return TypeInt::make(byteswap(checked_cast<jshort>(con->is_int()->get_con())));\n    case Op_ReverseBytesUS: return TypeInt::make(byteswap(checked_cast<jchar>(con->is_int()->get_con())));\n    case Op_ReverseBytesI:  return TypeInt::make(byteswap(checked_cast<jint>(con->is_int()->get_con())));\n    case Op_ReverseBytesL:  return TypeLong::make(byteswap(checked_cast<jlong>(con->is_long()->get_con())));\n    default: ShouldNotReachHere();\n  }\n}\n\nconst Type* ReverseBytesNode::Value(PhaseGVN* phase) const {\n  const Type* type = phase->type(in(1));\n  if (type == Type::TOP) {\n    return Type::TOP;\n  }\n  if (type->singleton()) {\n    return reverse_bytes(Opcode(), type);\n  }\n  return bottom_type();\n}", "target": "static const Type* reverse_bytes(int opcode, const Type* con) {\n  switch (opcode) {\n    case Op_ReverseBytesS:  return TypeInt::make(byteswap(checked_cast<jshort>(con->is_int()->get_con())));\n    case Op_ReverseBytesUS: return TypeInt::make(byteswap(checked_cast<jchar>(con->is_int()->get_con())));\n    case Op_ReverseBytesI:  return TypeInt::make(byteswap(checked_cast<jint>(con->is_int()->get_con())));\n    case Op_ReverseBytesL:  return TypeLong::make(byteswap(checked_cast<jlong>(con->is_long()->get_con())));\n    default: ShouldNotReachHere();\n  }\n}\n\nconst Type* ReverseBytesNode::Value(PhaseGVN* phase) const {\n  const Type* type = phase->type(in(1));\n  if (type == Type::TOP) {\n    return Type::TOP;\n  }\n  if (type->singleton()) {\n    return reverse_bytes(Opcode(), type);\n  }\n  return bottom_type();\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ReverseBytes节点（字节反转操作）在编译时无法对常量输入进行折叠，需要在运行时计算。优化后：新增ReverseBytesNode基类并实现Value()方法，当输入为常量时，在编译阶段直接计算字节反转结果并替换为常量节点。优化思路：通过常量折叠消除运行时计算开销，减少生成的机器指令数量，提升编译后代码的执行效率。"}
{"id": 409, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+性能优化", "optimization_description": "优化前：数组填充stub在处理小于8字节的短数组时，代码逻辑分散，包含冗余的标签和条件检查，且对BYTE/SHORT类型有额外的未对齐访问处理分支。优化后：1) 重构控制流，将短数组处理逻辑集中到L_fill_elements标签处，使用循环填充元素；2) 移除未对齐访问的特殊处理分支，简化代码；3) 调整标签使用，减少冗余标签。优化思路：通过代码重组减少分支跳转和标签数量，提高指令缓存局部性，简化维护，提升小数组填充性能。", "original_code": "数组填充stub在处理小于8字节的短数组时，代码逻辑分散，包含冗余的标签和条件检查，且对BYTE/SHORT类型有额外的未对齐访问处理分支。", "optimized_code": "-    Label L_fill_elements, L_exit1;\n+    Label L_fill_elements;\n...\n-    // Handle copies less than 8 bytes.\n-    Label L_fill_2, L_fill_4, L_exit2;\n-    __ bind(L_fill_elements);\n+    // Remaining count is less than 8 bytes and address is heapword aligned.\n+    Label L_fill_2, L_fill_4, L_exit1;\n...\n-    __ bind(L_exit2);\n+    __ bind(L_exit1);\n...\n+    // Handle copies less than 8 bytes.\n+    Label L_loop1, L_loop2, L_exit2;\n+    __ bind(L_fill_elements);\n+    __ beqz(count, L_exit2);", "source_url": "https://github.com/openjdk/riscv-port/commit/d7cb933b89839b692f5562aeeb92076cd25a99f6", "code_v0_no_empty_lines": "数组填充stub在处理小于8字节的短数组时，代码逻辑分散，包含冗余的标签和条件检查，且对BYTE/SHORT类型有额外的未对齐访问处理分支。", "code_v1_no_empty_lines": "-    Label L_fill_elements, L_exit1;\n+    Label L_fill_elements;\n...\n-    // Handle copies less than 8 bytes.\n-    Label L_fill_2, L_fill_4, L_exit2;\n-    __ bind(L_fill_elements);\n+    // Remaining count is less than 8 bytes and address is heapword aligned.\n+    Label L_fill_2, L_fill_4, L_exit1;\n...\n-    __ bind(L_exit2);\n+    __ bind(L_exit1);\n...\n+    // Handle copies less than 8 bytes.\n+    Label L_loop1, L_loop2, L_exit2;\n+    __ bind(L_fill_elements);\n+    __ beqz(count, L_exit2);", "target": "-    Label L_fill_elements, L_exit1;\n+    Label L_fill_elements;\n...\n-    // Handle copies less than 8 bytes.\n-    Label L_fill_2, L_fill_4, L_exit2;\n-    __ bind(L_fill_elements);\n+    // Remaining count is less than 8 bytes and address is heapword aligned.\n+    Label L_fill_2, L_fill_4, L_exit1;\n...\n-    __ bind(L_exit2);\n+    __ bind(L_exit1);\n...\n+    // Handle copies less than 8 bytes.\n+    Label L_loop1, L_loop2, L_exit2;\n+    __ bind(L_fill_elements);\n+    __ beqz(count, L_exit2);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：数组填充stub在处理小于8字节的短数组时，代码逻辑分散，包含冗余的标签和条件检查，且对BYTE/SHORT类型有额外的未对齐访问处理分支。优化后：1) 重构控制流，将短数组处理逻辑集中到L_fill_elements标签处，使用循环填充元素；2) 移除未对齐访问的特殊处理分支，简化代码；3) 调整标签使用，减少冗余标签。优化思路：通过代码重组减少分支跳转和标签数量，提高指令缓存局部性，简化维护，提升小数组填充性能。"}
{"id": 410, "source": "riscv-dataset-excel", "optimization_type": "内存优化+算法优化", "optimization_description": "优化前：BigInteger.pow()方法在处理小指数时使用通用的大数乘法算法，内存分配和计算开销较大。优化后：1. 重构构造函数，提取toMagArray()方法减少重复代码；2. 优化pow()算法：添加快速路径处理指数为0/1或基数为0/1的情况；3. 对小指数场景使用unsignedLongPow()方法，避免创建中间BigInteger对象；4. 通过new BigInteger(long mag, int signum)构造函数直接创建结果，减少内存分配。思路：针对常见的小指数场景进行特殊优化，减少对象创建和内存消耗，同时保持大数计算的正确性。", "original_code": "BigInteger.pow()方法在处理小指数时使用通用的大数乘法算法，内存分配和计算开销较大。", "optimized_code": "private static int[] toMagArray(long mag) {\n    int highWord = (int) (mag >>> 32);\n    return highWord == 0\n            ? new int[] { (int) mag }\n            : new int[] { highWord, (int) mag };\n}\n\nfinal long result = unsignedLongPow(base.mag[0] & LONG_MASK, exponent);\n\nreturn bitsToShift + scaleFactor <= Long.SIZE  // Fits in long?\n        ? new BigInteger(result << bitsToShift, newSign)\n        : new BigInteger(result, newSign).shiftLeft(bitsToShift);", "source_url": "https://github.com/openjdk/riscv-port/commit/1c5eb370b7dbe7558b535bf27c9df292c2007b9b", "code_v0_no_empty_lines": "BigInteger.pow()方法在处理小指数时使用通用的大数乘法算法，内存分配和计算开销较大。", "code_v1_no_empty_lines": "private static int[] toMagArray(long mag) {\n    int highWord = (int) (mag >>> 32);\n    return highWord == 0\n            ? new int[] { (int) mag }\n            : new int[] { highWord, (int) mag };\n}\n\nfinal long result = unsignedLongPow(base.mag[0] & LONG_MASK, exponent);\n\nreturn bitsToShift + scaleFactor <= Long.SIZE  // Fits in long?\n        ? new BigInteger(result << bitsToShift, newSign)\n        : new BigInteger(result, newSign).shiftLeft(bitsToShift);", "target": "private static int[] toMagArray(long mag) {\n    int highWord = (int) (mag >>> 32);\n    return highWord == 0\n            ? new int[] { (int) mag }\n            : new int[] { highWord, (int) mag };\n}\n\nfinal long result = unsignedLongPow(base.mag[0] & LONG_MASK, exponent);\n\nreturn bitsToShift + scaleFactor <= Long.SIZE  // Fits in long?\n        ? new BigInteger(result << bitsToShift, newSign)\n        : new BigInteger(result, newSign).shiftLeft(bitsToShift);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：BigInteger.pow()方法在处理小指数时使用通用的大数乘法算法，内存分配和计算开销较大。优化后：1. 重构构造函数，提取toMagArray()方法减少重复代码；2. 优化pow()算法：添加快速路径处理指数为0/1或基数为0/1的情况；3. 对小指数场景使用unsignedLongPow()方法，避免创建中间BigInteger对象；4. 通过new BigInteger(long mag, int signum)构造函数直接创建结果，减少内存分配。思路：针对常见的小指数场景进行特殊优化，减少对象创建和内存消耗，同时保持大数计算的正确性。"}
{"id": 411, "source": "riscv-dataset-excel", "optimization_type": "内存优化+缓存优化", "optimization_description": "优化前：AOT缓存中遗漏了部分interned字符串，导致运行时需要重新解析字符串常量，增加了运行时开销。优化后：通过重构字符串解析逻辑，确保所有interned字符串都能正确存入AOT缓存。关键修改包括：1) 移除AOTConstantPoolResolver的初始化/清理逻辑；2) 将dumptime_resolve_constants()简化为preresolve_string_cp_entries()；3) 移除_dumped_interned_strings参数传递，直接使用全局字符串表。优化思路：简化字符串缓存机制，避免重复处理和遗漏，提高AOT缓存的完整性和运行时性能。", "original_code": "AOT缓存中遗漏了部分interned字符串，导致运行时需要重新解析字符串常量，增加了运行时开销。", "optimized_code": "-  void dumptime_resolve_constants(InstanceKlass* ik, TRAPS);\n+  static void preresolve_string_cp_entries(InstanceKlass* ik, TRAPS);\n-  oop shared_strings_array = StringTable::init_shared_strings_array(_dumped_interned_strings);\n+  oop shared_strings_array = StringTable::init_shared_strings_array();\n-  StringTable::write_shared_table(_dumped_interned_strings);\n+  StringTable::write_shared_table();", "source_url": "https://github.com/openjdk/riscv-port/commit/4379e2d26bd445d3f303a5937d1e335885be9216", "code_v0_no_empty_lines": "AOT缓存中遗漏了部分interned字符串，导致运行时需要重新解析字符串常量，增加了运行时开销。", "code_v1_no_empty_lines": "-  void dumptime_resolve_constants(InstanceKlass* ik, TRAPS);\n+  static void preresolve_string_cp_entries(InstanceKlass* ik, TRAPS);\n-  oop shared_strings_array = StringTable::init_shared_strings_array(_dumped_interned_strings);\n+  oop shared_strings_array = StringTable::init_shared_strings_array();\n-  StringTable::write_shared_table(_dumped_interned_strings);\n+  StringTable::write_shared_table();", "target": "-  void dumptime_resolve_constants(InstanceKlass* ik, TRAPS);\n+  static void preresolve_string_cp_entries(InstanceKlass* ik, TRAPS);\n-  oop shared_strings_array = StringTable::init_shared_strings_array(_dumped_interned_strings);\n+  oop shared_strings_array = StringTable::init_shared_strings_array();\n-  StringTable::write_shared_table(_dumped_interned_strings);\n+  StringTable::write_shared_table();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AOT缓存中遗漏了部分interned字符串，导致运行时需要重新解析字符串常量，增加了运行时开销。优化后：通过重构字符串解析逻辑，确保所有interned字符串都能正确存入AOT缓存。关键修改包括：1) 移除AOTConstantPoolResolver的初始化/清理逻辑；2) 将dumptime_resolve_constants()简化为preresolve_string_cp_entries()；3) 移除_dumped_interned_strings参数传递，直接使用全局字符串表。优化思路：简化字符串缓存机制，避免重复处理和遗漏，提高AOT缓存的完整性和运行时性能。"}
{"id": 412, "source": "riscv-dataset-excel", "optimization_type": "垃圾回收优化+JIT编译优化", "optimization_description": "优化前：ZGC在老年代分配时只对C2编译器生成的代码进行去优化处理，JVMCI编译器生成的代码可能缺少必要的屏障导致内存安全问题。优化后：扩展条件同时检查C2和JVMCI编译器生成的代码，确保当JIT编译器可能省略对象屏障时，通过去优化帧让解释器正确处理对象分配。优化思路：增强ZGC与JVMCI的兼容性，防止因编译器优化导致的屏障缺失问题。", "original_code": "ZGC在老年代分配时只对C2编译器生成的代码进行去优化处理，JVMCI编译器生成的代码可能缺少必要的屏障导致内存安全问题。", "optimized_code": "-  if (nm->is_compiled_by_c2() && !caller_frame.is_deoptimized_frame()) {\n+  if ((nm->is_compiled_by_c2() || nm->is_compiled_by_jvmci()) && !caller_frame.is_deoptimized_frame()) {", "source_url": "https://github.com/openjdk/riscv-port/commit/cc34135fff7650ad44c910dca0fd47e9cbd56b68", "code_v0_no_empty_lines": "ZGC在老年代分配时只对C2编译器生成的代码进行去优化处理，JVMCI编译器生成的代码可能缺少必要的屏障导致内存安全问题。", "code_v1_no_empty_lines": "-  if (nm->is_compiled_by_c2() && !caller_frame.is_deoptimized_frame()) {\n+  if ((nm->is_compiled_by_c2() || nm->is_compiled_by_jvmci()) && !caller_frame.is_deoptimized_frame()) {", "target": "-  if (nm->is_compiled_by_c2() && !caller_frame.is_deoptimized_frame()) {\n+  if ((nm->is_compiled_by_c2() || nm->is_compiled_by_jvmci()) && !caller_frame.is_deoptimized_frame()) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ZGC在老年代分配时只对C2编译器生成的代码进行去优化处理，JVMCI编译器生成的代码可能缺少必要的屏障导致内存安全问题。优化后：扩展条件同时检查C2和JVMCI编译器生成的代码，确保当JIT编译器可能省略对象屏障时，通过去优化帧让解释器正确处理对象分配。优化思路：增强ZGC与JVMCI的兼容性，防止因编译器优化导致的屏障缺失问题。"}
{"id": 413, "source": "riscv-dataset-excel", "optimization_type": "内存初始化优化", "optimization_description": "优化前：静态类成员（如MemBaseline和MemoryFileTracker）在程序启动时立即初始化，可能导致静态初始化顺序问题（Static Initialization Order Fiasco），增加启动开销和潜在错误。优化后：引入Deferred模板类，将静态成员的构造延迟到首次使用时（通过initialize()方法），避免早期初始化问题，减少启动时间，并确保内存安全（不释放内存）。优化思路：通过延迟初始化解决静态初始化依赖问题，提升Hotspot虚拟机启动性能和稳定性。", "original_code": "静态类成员（如MemBaseline和MemoryFileTracker）在程序启动时立即初始化，可能导致静态初始化顺序问题（Static Initialization Order Fiasco），增加启动开销和潜在错误。", "optimized_code": "- static MemBaseline _baseline;\n+ static Deferred<MemBaseline> _baseline;\n- static MemoryFileTracker* _tracker;\n+ static Deferred<MemoryFileTracker> _tracker;\n+ template<typename T>\n+ class Deferred {\n+   union { T _t; };\n+   template<typename... Ts>\n+   void initialize(Ts&... args) {\n+     ::new (const_cast<NCVP>(get())) T(args...);\n+   }\n+ };", "source_url": "https://github.com/openjdk/riscv-port/commit/604225fb0c5f6bf2128a305d09649d76c43dedc9", "code_v0_no_empty_lines": "静态类成员（如MemBaseline和MemoryFileTracker）在程序启动时立即初始化，可能导致静态初始化顺序问题（Static Initialization Order Fiasco），增加启动开销和潜在错误。", "code_v1_no_empty_lines": "- static MemBaseline _baseline;\n+ static Deferred<MemBaseline> _baseline;\n- static MemoryFileTracker* _tracker;\n+ static Deferred<MemoryFileTracker> _tracker;\n+ template<typename T>\n+ class Deferred {\n+   union { T _t; };\n+   template<typename... Ts>\n+   void initialize(Ts&... args) {\n+     ::new (const_cast<NCVP>(get())) T(args...);\n+   }\n+ };", "target": "- static MemBaseline _baseline;\n+ static Deferred<MemBaseline> _baseline;\n- static MemoryFileTracker* _tracker;\n+ static Deferred<MemoryFileTracker> _tracker;\n+ template<typename T>\n+ class Deferred {\n+   union { T _t; };\n+   template<typename... Ts>\n+   void initialize(Ts&... args) {\n+     ::new (const_cast<NCVP>(get())) T(args...);\n+   }\n+ };", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：静态类成员（如MemBaseline和MemoryFileTracker）在程序启动时立即初始化，可能导致静态初始化顺序问题（Static Initialization Order Fiasco），增加启动开销和潜在错误。优化后：引入Deferred模板类，将静态成员的构造延迟到首次使用时（通过initialize()方法），避免早期初始化问题，减少启动时间，并确保内存安全（不释放内存）。优化思路：通过延迟初始化解决静态初始化依赖问题，提升Hotspot虚拟机启动性能和稳定性。"}
{"id": 414, "source": "riscv-dataset-excel", "optimization_type": "数学函数性能优化", "optimization_description": "优化前：Math.tanh函数在处理大输入值（|x|>=2^32）时返回+/-1，但分支判断逻辑复杂，且对|x|>=22的情况没有早期快速路径。优化后：1) 将大值阈值从2^32降低到22（因为tanh(22)≈1），添加早期分支直接返回+/-1，避免不必要的计算；2) 调整中间范围判断条件，简化控制流；3) 重新组织指令顺序，减少寄存器依赖和指令数量。优化思路：基于数学特性（tanh函数在|x|>=22时已非常接近+/-1），通过提前判断和简化分支逻辑来减少计算开销，修复性能回归。", "original_code": "Math.tanh函数在处理大输入值（|x|>=2^32）时返回+/-1，但分支判断逻辑复杂，且对|x|>=22的情况没有早期快速路径。", "optimized_code": "@@ -324,6 +324,12 @@ address StubGenerator::generate_libmTanh() {\n   __ enter(); // required for proper stackwalking of RuntimeStub frame\n \n   __ bind(B1_2);\n+  __ pextrw(rcx, xmm0, 3);\n+  __ movl(rdx, 32768);\n+  __ andl(rdx, rcx);\n+  __ andl(rcx, 32767);\n+  __ cmpl(rcx, 16438);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_2_0_1); // Branch only if |x| >= 22\n   __ movsd(xmm3, ExternalAddress(HALFMASK), r11 /*rscratch*/);\n   __ xorpd(xmm4, xmm4);\n   __ movsd(xmm1, ExternalAddress(L2E), r11 /*rscratch*/);\n@@ -331,16 +337,12 @@ address StubGenerator::generate_libmTanh() {\n   __ movl(rax, 32768);\n   __ pinsrw(xmm4, rax, 3);\n   __ movsd(xmm6,  ExternalAddress(Shifter), r11 /*rscratch*/);\n-  __ pextrw(rcx, xmm0, 3);\n   __ andpd(xmm3, xmm0);\n   __ andnpd(xmm4, xmm0);\n   __ pshufd(xmm5, xmm4, 68);\n-  __ movl(rdx, 32768);\n-  __ andl(rdx, rcx);\n-  __ andl(rcx, 32767);\n   __ subl(rcx, 16304);\n-  __ cmpl(rcx, 144);\n-  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_1);\n+  __ cmpl(rcx, 134);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_1); // Branch only if |x| is not in [2^{-4},22)", "source_url": "https://github.com/openjdk/riscv-port/commit/c8bbcaf5de6982f673504a8dc766fb80bb6f0d07", "code_v0_no_empty_lines": "Math.tanh函数在处理大输入值（|x|>=2^32）时返回+/-1，但分支判断逻辑复杂，且对|x|>=22的情况没有早期快速路径。", "code_v1_no_empty_lines": "@@ -324,6 +324,12 @@ address StubGenerator::generate_libmTanh() {\n   __ enter(); // required for proper stackwalking of RuntimeStub frame\n \n   __ bind(B1_2);\n+  __ pextrw(rcx, xmm0, 3);\n+  __ movl(rdx, 32768);\n+  __ andl(rdx, rcx);\n+  __ andl(rcx, 32767);\n+  __ cmpl(rcx, 16438);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_2_0_1); // Branch only if |x| >= 22\n   __ movsd(xmm3, ExternalAddress(HALFMASK), r11 /*rscratch*/);\n   __ xorpd(xmm4, xmm4);\n   __ movsd(xmm1, ExternalAddress(L2E), r11 /*rscratch*/);\n@@ -331,16 +337,12 @@ address StubGenerator::generate_libmTanh() {\n   __ movl(rax, 32768);\n   __ pinsrw(xmm4, rax, 3);\n   __ movsd(xmm6,  ExternalAddress(Shifter), r11 /*rscratch*/);\n-  __ pextrw(rcx, xmm0, 3);\n   __ andpd(xmm3, xmm0);\n   __ andnpd(xmm4, xmm0);\n   __ pshufd(xmm5, xmm4, 68);\n-  __ movl(rdx, 32768);\n-  __ andl(rdx, rcx);\n-  __ andl(rcx, 32767);\n   __ subl(rcx, 16304);\n-  __ cmpl(rcx, 144);\n-  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_1);\n+  __ cmpl(rcx, 134);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_1); // Branch only if |x| is not in [2^{-4},22)", "target": "@@ -324,6 +324,12 @@ address StubGenerator::generate_libmTanh() {\n   __ enter(); // required for proper stackwalking of RuntimeStub frame\n \n   __ bind(B1_2);\n+  __ pextrw(rcx, xmm0, 3);\n+  __ movl(rdx, 32768);\n+  __ andl(rdx, rcx);\n+  __ andl(rcx, 32767);\n+  __ cmpl(rcx, 16438);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_2_0_1); // Branch only if |x| >= 22\n   __ movsd(xmm3, ExternalAddress(HALFMASK), r11 /*rscratch*/);\n   __ xorpd(xmm4, xmm4);\n   __ movsd(xmm1, ExternalAddress(L2E), r11 /*rscratch*/);\n@@ -331,16 +337,12 @@ address StubGenerator::generate_libmTanh() {\n   __ movl(rax, 32768);\n   __ pinsrw(xmm4, rax, 3);\n   __ movsd(xmm6,  ExternalAddress(Shifter), r11 /*rscratch*/);\n-  __ pextrw(rcx, xmm0, 3);\n   __ andpd(xmm3, xmm0);\n   __ andnpd(xmm4, xmm0);\n   __ pshufd(xmm5, xmm4, 68);\n-  __ movl(rdx, 32768);\n-  __ andl(rdx, rcx);\n-  __ andl(rcx, 32767);\n   __ subl(rcx, 16304);\n-  __ cmpl(rcx, 144);\n-  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_1);\n+  __ cmpl(rcx, 134);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_1); // Branch only if |x| is not in [2^{-4},22)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Math.tanh函数在处理大输入值（|x|>=2^32）时返回+/-1，但分支判断逻辑复杂，且对|x|>=22的情况没有早期快速路径。优化后：1) 将大值阈值从2^32降低到22（因为tanh(22)≈1），添加早期分支直接返回+/-1，避免不必要的计算；2) 调整中间范围判断条件，简化控制流；3) 重新组织指令顺序，减少寄存器依赖和指令数量。优化思路：基于数学特性（tanh函数在|x|>=22时已非常接近+/-1），通过提前判断和简化分支逻辑来减少计算开销，修复性能回归。"}
{"id": 415, "source": "riscv-dataset-excel", "optimization_type": "内存布局优化", "optimization_description": "优化前：数据结构的默认填充大小为单个缓存行大小（64字节），在aarch64架构上可能因缓存行预取或相邻缓存行效应导致伪共享。优化后：将默认填充大小增加到两个缓存行大小（128字节），通过增加数据结构的间距来减少不同CPU核心间的缓存行竞争，提升多线程并发性能。优化思路：针对aarch64架构特性调整内存对齐策略，避免伪共享问题。", "original_code": "数据结构的默认填充大小为单个缓存行大小（64字节），在aarch64架构上可能因缓存行预取或相邻缓存行效应导致伪共享。", "optimized_code": "-#define DEFAULT_PADDING_SIZE DEFAULT_CACHE_LINE_SIZE\n+#define DEFAULT_PADDING_SIZE (2*DEFAULT_CACHE_LINE_SIZE)", "source_url": "https://github.com/openjdk/riscv-port/commit/60ba81d77f0e299b8131cf23b1253689fa898e85", "code_v0_no_empty_lines": "数据结构的默认填充大小为单个缓存行大小（64字节），在aarch64架构上可能因缓存行预取或相邻缓存行效应导致伪共享。", "code_v1_no_empty_lines": "-#define DEFAULT_PADDING_SIZE DEFAULT_CACHE_LINE_SIZE\n+#define DEFAULT_PADDING_SIZE (2*DEFAULT_CACHE_LINE_SIZE)", "target": "-#define DEFAULT_PADDING_SIZE DEFAULT_CACHE_LINE_SIZE\n+#define DEFAULT_PADDING_SIZE (2*DEFAULT_CACHE_LINE_SIZE)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：数据结构的默认填充大小为单个缓存行大小（64字节），在aarch64架构上可能因缓存行预取或相邻缓存行效应导致伪共享。优化后：将默认填充大小增加到两个缓存行大小（128字节），通过增加数据结构的间距来减少不同CPU核心间的缓存行竞争，提升多线程并发性能。优化思路：针对aarch64架构特性调整内存对齐策略，避免伪共享问题。"}
{"id": 416, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+算法优化", "optimization_description": "优化前：GHASH算法在PPC64架构上使用通用指令实现，性能较低。优化后：为PPC64架构添加GHASH算法的硬件加速内联函数，利用PowerPC的vpmsumd（向量多项式乘法）指令实现Galois/Counter Mode的快速多项式乘法，结合Karatsuba算法优化128位乘法，通过向量寄存器操作减少内存访问和指令数量。优化思路：利用PPC64架构的特定向量指令集实现算法硬件加速，显著提升加密性能。", "original_code": "GHASH算法在PPC64架构上使用通用指令实现，性能较低。", "optimized_code": "新增 computeGCMProduct 函数和 generate_ghash_processBlocks 函数，包含 __ vpmsumd(vLowProduct, vLowerH, vH); 等向量指令", "source_url": "https://github.com/openjdk/riscv-port/commit/cdad6d788de4785c8dbf2710a86fdacb8d070565", "code_v0_no_empty_lines": "GHASH算法在PPC64架构上使用通用指令实现，性能较低。", "code_v1_no_empty_lines": "新增 computeGCMProduct 函数和 generate_ghash_processBlocks 函数，包含 __ vpmsumd(vLowProduct, vLowerH, vH); 等向量指令", "target": "新增 computeGCMProduct 函数和 generate_ghash_processBlocks 函数，包含 __ vpmsumd(vLowProduct, vLowerH, vH); 等向量指令", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：GHASH算法在PPC64架构上使用通用指令实现，性能较低。优化后：为PPC64架构添加GHASH算法的硬件加速内联函数，利用PowerPC的vpmsumd（向量多项式乘法）指令实现Galois/Counter Mode的快速多项式乘法，结合Karatsuba算法优化128位乘法，通过向量寄存器操作减少内存访问和指令数量。优化思路：利用PPC64架构的特定向量指令集实现算法硬件加速，显著提升加密性能。"}
{"id": 417, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+数据结构优化", "optimization_description": "优化前：每次添加nmethod依赖时都需要遍历整个依赖链表来检查重复项，当依赖链表很大时会产生显著的性能开销。优化后：利用依赖添加操作的并发特性（持有CodeCache_lock且新nmethod未安装），只需检查链表头部即可确定是否重复，避免了全链表遍历。同时优化了CAS循环中的head加载位置，减少不必要的原子操作。优化思路：基于操作约束（新nmethod不在链表中或已在头部）将O(n)的链表遍历优化为O(1)的头部检查，显著提升依赖记录性能。", "original_code": "每次添加nmethod依赖时都需要遍历整个依赖链表来检查重复项，当依赖链表很大时会产生显著的性能开销。", "optimized_code": "void DependencyContext::add_dependent_nmethod(nmethod* nm) {\n  assert_lock_strong(CodeCache_lock);\n-  for (nmethodBucket* b = dependencies_not_unloading(); b != nullptr; b = b->next_not_unloading()) {\n-    if (nm == b->get_nmethod()) {\n-      return;\n-    }\n+  assert(nm->is_not_installed(), \"Precondition: new nmethod\");\n+\n+  // ... 优化说明注释 ...\n+\n+  nmethodBucket* head = Atomic::load(_dependency_context_addr);\n+  if (head != nullptr && nm == head->get_nmethod()) {\n+    return;\n+  }\n+\n+#ifdef ASSERT\n+  for (nmethodBucket* b = head; b != nullptr; b = b->next()) {\n+    assert(nm != b->get_nmethod(), \"Invariant: should not be in the list yet\");\n   }\n+#endif\n+\n   nmethodBucket* new_head = new nmethodBucket(nm, nullptr);\n   for (;;) {\n-    nmethodBucket* head = Atomic::load(_dependency_context_addr);\n     new_head->set_next(head);\n     if (Atomic::cmpxchg(_dependency_context_addr, head, new_head) == head) {\n       break;\n     }\n+    head = Atomic::load(_dependency_context_addr);\n   }", "source_url": "https://github.com/openjdk/riscv-port/commit/8ef7e256a09115b475601b621c9b6842185289d0", "code_v0_no_empty_lines": "每次添加nmethod依赖时都需要遍历整个依赖链表来检查重复项，当依赖链表很大时会产生显著的性能开销。", "code_v1_no_empty_lines": "void DependencyContext::add_dependent_nmethod(nmethod* nm) {\n  assert_lock_strong(CodeCache_lock);\n-  for (nmethodBucket* b = dependencies_not_unloading(); b != nullptr; b = b->next_not_unloading()) {\n-    if (nm == b->get_nmethod()) {\n-      return;\n-    }\n+  assert(nm->is_not_installed(), \"Precondition: new nmethod\");\n+\n+  // ... 优化说明注释 ...\n+\n+  nmethodBucket* head = Atomic::load(_dependency_context_addr);\n+  if (head != nullptr && nm == head->get_nmethod()) {\n+    return;\n+  }\n+\n+#ifdef ASSERT\n+  for (nmethodBucket* b = head; b != nullptr; b = b->next()) {\n+    assert(nm != b->get_nmethod(), \"Invariant: should not be in the list yet\");\n   }\n+#endif\n+\n   nmethodBucket* new_head = new nmethodBucket(nm, nullptr);\n   for (;;) {\n-    nmethodBucket* head = Atomic::load(_dependency_context_addr);\n     new_head->set_next(head);\n     if (Atomic::cmpxchg(_dependency_context_addr, head, new_head) == head) {\n       break;\n     }\n+    head = Atomic::load(_dependency_context_addr);\n   }", "target": "void DependencyContext::add_dependent_nmethod(nmethod* nm) {\n  assert_lock_strong(CodeCache_lock);\n-  for (nmethodBucket* b = dependencies_not_unloading(); b != nullptr; b = b->next_not_unloading()) {\n-    if (nm == b->get_nmethod()) {\n-      return;\n-    }\n+  assert(nm->is_not_installed(), \"Precondition: new nmethod\");\n+\n+  // ... 优化说明注释 ...\n+\n+  nmethodBucket* head = Atomic::load(_dependency_context_addr);\n+  if (head != nullptr && nm == head->get_nmethod()) {\n+    return;\n+  }\n+\n+#ifdef ASSERT\n+  for (nmethodBucket* b = head; b != nullptr; b = b->next()) {\n+    assert(nm != b->get_nmethod(), \"Invariant: should not be in the list yet\");\n   }\n+#endif\n+\n   nmethodBucket* new_head = new nmethodBucket(nm, nullptr);\n   for (;;) {\n-    nmethodBucket* head = Atomic::load(_dependency_context_addr);\n     new_head->set_next(head);\n     if (Atomic::cmpxchg(_dependency_context_addr, head, new_head) == head) {\n       break;\n     }\n+    head = Atomic::load(_dependency_context_addr);\n   }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次添加nmethod依赖时都需要遍历整个依赖链表来检查重复项，当依赖链表很大时会产生显著的性能开销。优化后：利用依赖添加操作的并发特性（持有CodeCache_lock且新nmethod未安装），只需检查链表头部即可确定是否重复，避免了全链表遍历。同时优化了CAS循环中的head加载位置，减少不必要的原子操作。优化思路：基于操作约束（新nmethod不在链表中或已在头部）将O(n)的链表遍历优化为O(1)的头部检查，显著提升依赖记录性能。"}
{"id": 418, "source": "riscv-dataset-excel", "optimization_type": "AOT缓存优化+内存管理优化", "optimization_description": "优化前：AOT缓存不支持Soft/Weak Reference对象，导致相关类（如MethodType.internTable使用的ReferencedKeyMap）无法有效利用AOT缓存加速。优化后：新增Reference对象AOT缓存支持，通过aotReferenceObjSupport模块处理Reference对象的缓存资格检查、字段重置和运行时恢复，使包含弱引用的核心类（如java.lang.ref.Reference）能够被AOT缓存，提升启动性能和内存效率。思路：扩展AOT缓存机制以安全处理Reference对象，确保缓存一致性并避免无关对象被意外缓存。", "original_code": "AOT缓存不支持Soft/Weak Reference对象，导致相关类（如MethodType.internTable使用的ReferencedKeyMap）无法有效利用AOT缓存加速。", "optimized_code": "+  AOTReferenceObjSupport::init_keep_alive_objs_table();\n+  ik == vmClasses::Reference_klass()\n+  // 新增aotReferenceObjSupport.cpp文件，包含Reference对象AOT缓存支持", "source_url": "https://github.com/openjdk/riscv-port/commit/1ff7e813e39d16376baccdbd9e7075035248319d", "code_v0_no_empty_lines": "AOT缓存不支持Soft/Weak Reference对象，导致相关类（如MethodType.internTable使用的ReferencedKeyMap）无法有效利用AOT缓存加速。", "code_v1_no_empty_lines": "+  AOTReferenceObjSupport::init_keep_alive_objs_table();\n+  ik == vmClasses::Reference_klass()\n+  // 新增aotReferenceObjSupport.cpp文件，包含Reference对象AOT缓存支持", "target": "+  AOTReferenceObjSupport::init_keep_alive_objs_table();\n+  ik == vmClasses::Reference_klass()\n+  // 新增aotReferenceObjSupport.cpp文件，包含Reference对象AOT缓存支持", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AOT缓存不支持Soft/Weak Reference对象，导致相关类（如MethodType.internTable使用的ReferencedKeyMap）无法有效利用AOT缓存加速。优化后：新增Reference对象AOT缓存支持，通过aotReferenceObjSupport模块处理Reference对象的缓存资格检查、字段重置和运行时恢复，使包含弱引用的核心类（如java.lang.ref.Reference）能够被AOT缓存，提升启动性能和内存效率。思路：扩展AOT缓存机制以安全处理Reference对象，确保缓存一致性并避免无关对象被意外缓存。"}
{"id": 419, "source": "riscv-dataset-excel", "optimization_type": "缓存优化+代码生成优化", "optimization_description": "优化前：每次调用downcall都会重新生成代码，导致性能开销。优化后：1. 为LinkRequest记录类添加equals和hashCode方法，使其可作为缓存键；2. 使用SoftReferenceCache缓存已生成的MethodHandle；3. 将CapturableState集合改为位掩码表示，提高比较效率。思路：通过缓存机制避免重复的代码生成，特别针对频繁调用的相同函数签名场景，减少动态代码生成开销。", "original_code": "每次调用downcall都会重新生成代码，导致性能开销。", "optimized_code": "private record LinkRequest(FunctionDescriptor descriptor, LinkerOptions options) {\n    // Overrides for boot performance\n    @Override\n    public boolean equals(Object obj) {\n        return obj instanceof LinkRequest other &&\n                other.descriptor.equals(descriptor) &&\n                other.options.equals(options);\n    }\n\n    @Override\n    public int hashCode() {\n        return descriptor.hashCode() * 1237 + options.hashCode();\n    }\n}\nprivate final SoftReferenceCache<LinkRequest, MethodHandle> DOWNCALL_CACHE = new SoftReferenceCache<>();", "source_url": "https://github.com/openjdk/riscv-port/commit/5d2d1ab5740259bc30d0184e4d691a05fdf63e19", "code_v0_no_empty_lines": "每次调用downcall都会重新生成代码，导致性能开销。", "code_v1_no_empty_lines": "private record LinkRequest(FunctionDescriptor descriptor, LinkerOptions options) {\n    // Overrides for boot performance\n    @Override\n    public boolean equals(Object obj) {\n        return obj instanceof LinkRequest other &&\n                other.descriptor.equals(descriptor) &&\n                other.options.equals(options);\n    }\n\n    @Override\n    public int hashCode() {\n        return descriptor.hashCode() * 1237 + options.hashCode();\n    }\n}\nprivate final SoftReferenceCache<LinkRequest, MethodHandle> DOWNCALL_CACHE = new SoftReferenceCache<>();", "target": "private record LinkRequest(FunctionDescriptor descriptor, LinkerOptions options) {\n    // Overrides for boot performance\n    @Override\n    public boolean equals(Object obj) {\n        return obj instanceof LinkRequest other &&\n                other.descriptor.equals(descriptor) &&\n                other.options.equals(options);\n    }\n\n    @Override\n    public int hashCode() {\n        return descriptor.hashCode() * 1237 + options.hashCode();\n    }\n}\nprivate final SoftReferenceCache<LinkRequest, MethodHandle> DOWNCALL_CACHE = new SoftReferenceCache<>();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次调用downcall都会重新生成代码，导致性能开销。优化后：1. 为LinkRequest记录类添加equals和hashCode方法，使其可作为缓存键；2. 使用SoftReferenceCache缓存已生成的MethodHandle；3. 将CapturableState集合改为位掩码表示，提高比较效率。思路：通过缓存机制避免重复的代码生成，特别针对频繁调用的相同函数签名场景，减少动态代码生成开销。"}
{"id": 420, "source": "riscv-dataset-excel", "optimization_type": "代码清理+API简化", "optimization_description": "优化前：Thread::SpinAcquire()函数接受一个未使用的lock name参数，导致所有调用点都需要传递冗余参数。优化后：移除未使用的lock name参数，简化函数签名和所有调用点。优化思路：清理无用参数，减少代码复杂度和维护成本，同时保持原有功能不变。", "original_code": "Thread::SpinAcquire()函数接受一个未使用的lock name参数，导致所有调用点都需要传递冗余参数。", "optimized_code": "- void Thread::SpinAcquire(volatile int * adr, const char * LockName) {\n+ void Thread::SpinAcquire(volatile int * adr) {\n- Thread::SpinAcquire(&_wait_set_lock, \"wait_set - add\");\n+ Thread::SpinAcquire(&_wait_set_lock);", "source_url": "https://github.com/openjdk/riscv-port/commit/62ef706dd1b21a347c2cca717a2277b75dd25097", "code_v0_no_empty_lines": "Thread::SpinAcquire()函数接受一个未使用的lock name参数，导致所有调用点都需要传递冗余参数。", "code_v1_no_empty_lines": "- void Thread::SpinAcquire(volatile int * adr, const char * LockName) {\n+ void Thread::SpinAcquire(volatile int * adr) {\n- Thread::SpinAcquire(&_wait_set_lock, \"wait_set - add\");\n+ Thread::SpinAcquire(&_wait_set_lock);", "target": "- void Thread::SpinAcquire(volatile int * adr, const char * LockName) {\n+ void Thread::SpinAcquire(volatile int * adr) {\n- Thread::SpinAcquire(&_wait_set_lock, \"wait_set - add\");\n+ Thread::SpinAcquire(&_wait_set_lock);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Thread::SpinAcquire()函数接受一个未使用的lock name参数，导致所有调用点都需要传递冗余参数。优化后：移除未使用的lock name参数，简化函数签名和所有调用点。优化思路：清理无用参数，减少代码复杂度和维护成本，同时保持原有功能不变。"}
{"id": 421, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（IGVN工作列表逻辑）", "optimization_description": "优化前：当LShiftNode更新时，IGVN只将直接用户（如ConvI2L）加入工作列表，但ConvI2L可能没有更新，导致后续的AndNode无法重新估值。优化后：检测到ConvI2L或ConstraintCast节点时，直接遍历其用户，将AndI/AndL节点加入工作列表，跳过中间转换节点。优化思路：确保AndNode的特殊优化（当RHS位数小于移位量时结果为0）在存在中间转换节点时仍能触发，避免错过优化机会。", "original_code": "当LShiftNode更新时，IGVN只将直接用户（如ConvI2L）加入工作列表，但ConvI2L可能没有更新，导致后续的AndNode无法重新估值。", "optimized_code": "if (use->is_ConstraintCast() || use_op == Op_ConvI2L) {\n  auto is_boundary = [](Node* n){ return !n->is_ConstraintCast() && n->Opcode() != Op_ConvI2L; };\n  auto push_and_to_worklist = [&worklist](Node* n){\n    if (n->Opcode() == Op_AndL || n->Opcode() == Op_AndI) {\n      worklist.push(n);\n    }\n  };\n  use->visit_uses(push_and_to_worklist, is_boundary);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/6254046f508049a4e568f0f2eae51dc10da392c1", "code_v0_no_empty_lines": "当LShiftNode更新时，IGVN只将直接用户（如ConvI2L）加入工作列表，但ConvI2L可能没有更新，导致后续的AndNode无法重新估值。", "code_v1_no_empty_lines": "if (use->is_ConstraintCast() || use_op == Op_ConvI2L) {\n  auto is_boundary = [](Node* n){ return !n->is_ConstraintCast() && n->Opcode() != Op_ConvI2L; };\n  auto push_and_to_worklist = [&worklist](Node* n){\n    if (n->Opcode() == Op_AndL || n->Opcode() == Op_AndI) {\n      worklist.push(n);\n    }\n  };\n  use->visit_uses(push_and_to_worklist, is_boundary);\n}", "target": "if (use->is_ConstraintCast() || use_op == Op_ConvI2L) {\n  auto is_boundary = [](Node* n){ return !n->is_ConstraintCast() && n->Opcode() != Op_ConvI2L; };\n  auto push_and_to_worklist = [&worklist](Node* n){\n    if (n->Opcode() == Op_AndL || n->Opcode() == Op_AndI) {\n      worklist.push(n);\n    }\n  };\n  use->visit_uses(push_and_to_worklist, is_boundary);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当LShiftNode更新时，IGVN只将直接用户（如ConvI2L）加入工作列表，但ConvI2L可能没有更新，导致后续的AndNode无法重新估值。优化后：检测到ConvI2L或ConstraintCast节点时，直接遍历其用户，将AndI/AndL节点加入工作列表，跳过中间转换节点。优化思路：确保AndNode的特殊优化（当RHS位数小于移位量时结果为0）在存在中间转换节点时仍能触发，避免错过优化机会。"}
{"id": 422, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+缓存同步优化", "optimization_description": "优化前：x86平台ICache同步仅使用CLFLUSH指令配合MFENCE，无法利用现代CPU的新指令集特性。优化后：1) 引入X86ICacheSync配置选项(-1到5)，支持自动选择或手动指定ICache同步机制；2) 新增serialize()汇编指令支持；3) 重构ICache刷新逻辑，根据配置选择不同指令：CLFLUSH(传统)、CLFLUSHOPT(优化版)、CLWB(回写)、CPUID或SERIALIZE指令；4) 使用条件分支优化(jccb)减少代码大小。优化思路：利用现代x86 CPU的新指令集特性(CLFLUSHOPT/CLWB/SERIALIZE)提供更高效的指令缓存同步机制，减少同步开销，提升JIT编译后代码加载性能。", "original_code": "x86平台ICache同步仅使用CLFLUSH指令配合MFENCE，无法利用现代CPU的新指令集特性。", "optimized_code": "void ICacheStubGenerator::generate_icache_flush(ICache::flush_icache_stub_t* flush_icache_stub) {\n-  StubCodeMark mark(this, \"ICache\", \"flush_icache_stub\");\n+  StubCodeMark mark(this, \"ICache\", _stub_name);\n\n  address start = __ pc();\n-#ifdef AMD64\n\n  const Register addr  = c_rarg0;\n  const Register lines = c_rarg1;\n\n  __ testl(lines, lines);\n-  __ jcc(Assembler::zero, done);\n+  __ jccb(Assembler::zero, done);\n\n-  // Force ordering wrt cflush.\n-  // Other fence and sync instructions won't do the job.\n-  __ mfence();\n+  x86_generate_icache_fence(_masm);\n\n-  __ bind(flush_line);\n-  __ clflush(Address(addr, 0));\n+  if (1 <= X86ICacheSync && X86ICacheSync <= 3) {\n+    __ bind(flush_line);\n+    x86_generate_icache_flush_insn(_masm, addr);\n     __ addptr(addr, ICache::line_size);\n     __ decrementl(lines);\n-    __ jcc(Assembler::notZero, flush_line);\n+    __ jccb(Assembler::notZero, flush_line);\n\n-  __ mfence();\n+    x86_generate_icache_fence(_masm);\n+  }\n\n   __ bind(done);\n\n-#else\n-  const Address magic(rsp, 3*wordSize);\n-  __ lock(); __ addl(Address(rsp, 0), 0);\n-#endif // AMD64\n   __ movptr(rax, magic); // Handshake with caller to make sure it happened!\n   __ ret(0);\n\n   *flush_icache_stub = (ICache::flush_icache_stub_t)start;\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/188c236071fd573a9ef35c34126443c6982a4f53", "code_v0_no_empty_lines": "x86平台ICache同步仅使用CLFLUSH指令配合MFENCE，无法利用现代CPU的新指令集特性。", "code_v1_no_empty_lines": "void ICacheStubGenerator::generate_icache_flush(ICache::flush_icache_stub_t* flush_icache_stub) {\n-  StubCodeMark mark(this, \"ICache\", \"flush_icache_stub\");\n+  StubCodeMark mark(this, \"ICache\", _stub_name);\n\n  address start = __ pc();\n-#ifdef AMD64\n\n  const Register addr  = c_rarg0;\n  const Register lines = c_rarg1;\n\n  __ testl(lines, lines);\n-  __ jcc(Assembler::zero, done);\n+  __ jccb(Assembler::zero, done);\n\n-  // Force ordering wrt cflush.\n-  // Other fence and sync instructions won't do the job.\n-  __ mfence();\n+  x86_generate_icache_fence(_masm);\n\n-  __ bind(flush_line);\n-  __ clflush(Address(addr, 0));\n+  if (1 <= X86ICacheSync && X86ICacheSync <= 3) {\n+    __ bind(flush_line);\n+    x86_generate_icache_flush_insn(_masm, addr);\n     __ addptr(addr, ICache::line_size);\n     __ decrementl(lines);\n-    __ jcc(Assembler::notZero, flush_line);\n+    __ jccb(Assembler::notZero, flush_line);\n\n-  __ mfence();\n+    x86_generate_icache_fence(_masm);\n+  }\n\n   __ bind(done);\n\n-#else\n-  const Address magic(rsp, 3*wordSize);\n-  __ lock(); __ addl(Address(rsp, 0), 0);\n-#endif // AMD64\n   __ movptr(rax, magic); // Handshake with caller to make sure it happened!\n   __ ret(0);\n\n   *flush_icache_stub = (ICache::flush_icache_stub_t)start;\n }", "target": "void ICacheStubGenerator::generate_icache_flush(ICache::flush_icache_stub_t* flush_icache_stub) {\n-  StubCodeMark mark(this, \"ICache\", \"flush_icache_stub\");\n+  StubCodeMark mark(this, \"ICache\", _stub_name);\n\n  address start = __ pc();\n-#ifdef AMD64\n\n  const Register addr  = c_rarg0;\n  const Register lines = c_rarg1;\n\n  __ testl(lines, lines);\n-  __ jcc(Assembler::zero, done);\n+  __ jccb(Assembler::zero, done);\n\n-  // Force ordering wrt cflush.\n-  // Other fence and sync instructions won't do the job.\n-  __ mfence();\n+  x86_generate_icache_fence(_masm);\n\n-  __ bind(flush_line);\n-  __ clflush(Address(addr, 0));\n+  if (1 <= X86ICacheSync && X86ICacheSync <= 3) {\n+    __ bind(flush_line);\n+    x86_generate_icache_flush_insn(_masm, addr);\n     __ addptr(addr, ICache::line_size);\n     __ decrementl(lines);\n-    __ jcc(Assembler::notZero, flush_line);\n+    __ jccb(Assembler::notZero, flush_line);\n\n-  __ mfence();\n+    x86_generate_icache_fence(_masm);\n+  }\n\n   __ bind(done);\n\n-#else\n-  const Address magic(rsp, 3*wordSize);\n-  __ lock(); __ addl(Address(rsp, 0), 0);\n-#endif // AMD64\n   __ movptr(rax, magic); // Handshake with caller to make sure it happened!\n   __ ret(0);\n\n   *flush_icache_stub = (ICache::flush_icache_stub_t)start;\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：x86平台ICache同步仅使用CLFLUSH指令配合MFENCE，无法利用现代CPU的新指令集特性。优化后：1) 引入X86ICacheSync配置选项(-1到5)，支持自动选择或手动指定ICache同步机制；2) 新增serialize()汇编指令支持；3) 重构ICache刷新逻辑，根据配置选择不同指令：CLFLUSH(传统)、CLFLUSHOPT(优化版)、CLWB(回写)、CPUID或SERIALIZE指令；4) 使用条件分支优化(jccb)减少代码大小。优化思路：利用现代x86 CPU的新指令集特性(CLFLUSHOPT/CLWB/SERIALIZE)提供更高效的指令缓存同步机制，减少同步开销，提升JIT编译后代码加载性能。"}
{"id": 423, "source": "riscv-dataset-excel", "optimization_type": "内存优化+GC性能优化", "optimization_description": "优化前：在标记阶段（mark phase）对所有字符串对象尝试去重，包括短寿命字符串，增加了标记阶段的额外开销。优化后：将字符串去重延迟到重定位阶段（relocate phase），仅对晋升对象（promoted objects）进行去重，让短寿命字符串自然消亡。优化思路：避免为即将死亡的短寿命字符串支付去重开销，减少GC暂停时间，同时通过新增的ZStringDedup模块集中管理去重逻辑，提升内存利用效率。", "original_code": "在标记阶段（mark phase）对所有字符串对象尝试去重，包括短寿命字符串，增加了标记阶段的额外开销。", "optimized_code": "diff --git a/src/hotspot/share/gc/z/zMark.cpp b/src/hotspot/share/gc/z/zMark.cpp\nindex e0c68213ca3..9846f1244ec 100644\n--- a/src/hotspot/share/gc/z/zMark.cpp\n+++ b/src/hotspot/share/gc/z/zMark.cpp\n@@ -27,7 +27,6 @@\n #include \"code/nmethod.hpp\"\n #include \"gc/shared/continuationGCSupport.inline.hpp\"\n #include \"gc/shared/gc_globals.hpp\"\n-#include \"gc/shared/stringdedup/stringDedup.hpp\"\n #include \"gc/shared/suspendibleThreadSet.hpp\"\n #include \"gc/shared/workerThread.hpp\"\n #include \"gc/z/zAbort.inline.hpp\"\n@@ -389,25 +388,6 @@ void ZMark::follow_object(oop obj, bool finalizable) {\n   }\n }\n \n-static void try_deduplicate(ZMarkContext* context, oop obj) {\n-  if (!StringDedup::is_enabled()) {\n-    // Not enabled\n-    return;\n-  }\n-\n-  if (!java_lang_String::is_instance(obj)) {\n-    // Not a String object\n-    return;\n-  }\n-\n-  if (java_lang_String::test_and_set_deduplication_requested(obj)) {\n-    // Already requested deduplication\n-    return;\n-  }\n-\n-  // Request deduplication\n-  context->string_dedup_requests()->add(obj);\n-}\n-\n void ZMark::mark_and_follow(ZMarkContext* context, ZMarkStackEntry entry) {\n   // Decode flags\n   const bool finalizable = entry.finalizable();\n@@ -449,13 +429,7 @@ void ZMark::mark_and_follow(ZMarkContext* context, ZMarkStackEntry entry) {\n     if (is_array(addr)) {\n       follow_array_object(objArrayOop(to_oop(addr)), finalizable);\n     } else {\n-      const oop obj = to_oop(addr);\n-      follow_object(obj, finalizable);\n-\n-      if (!finalizable) {\n-        // Try deduplicate\n-        try_deduplicate(context, obj);\n-      }\n+      follow_object(to_oop(addr), finalizable);\n     }\n   }\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/953eef4f113408ab4ae432308f9848f7d226c619", "code_v0_no_empty_lines": "在标记阶段（mark phase）对所有字符串对象尝试去重，包括短寿命字符串，增加了标记阶段的额外开销。", "code_v1_no_empty_lines": "diff --git a/src/hotspot/share/gc/z/zMark.cpp b/src/hotspot/share/gc/z/zMark.cpp\nindex e0c68213ca3..9846f1244ec 100644\n--- a/src/hotspot/share/gc/z/zMark.cpp\n+++ b/src/hotspot/share/gc/z/zMark.cpp\n@@ -27,7 +27,6 @@\n #include \"code/nmethod.hpp\"\n #include \"gc/shared/continuationGCSupport.inline.hpp\"\n #include \"gc/shared/gc_globals.hpp\"\n-#include \"gc/shared/stringdedup/stringDedup.hpp\"\n #include \"gc/shared/suspendibleThreadSet.hpp\"\n #include \"gc/shared/workerThread.hpp\"\n #include \"gc/z/zAbort.inline.hpp\"\n@@ -389,25 +388,6 @@ void ZMark::follow_object(oop obj, bool finalizable) {\n   }\n }\n \n-static void try_deduplicate(ZMarkContext* context, oop obj) {\n-  if (!StringDedup::is_enabled()) {\n-    // Not enabled\n-    return;\n-  }\n-\n-  if (!java_lang_String::is_instance(obj)) {\n-    // Not a String object\n-    return;\n-  }\n-\n-  if (java_lang_String::test_and_set_deduplication_requested(obj)) {\n-    // Already requested deduplication\n-    return;\n-  }\n-\n-  // Request deduplication\n-  context->string_dedup_requests()->add(obj);\n-}\n-\n void ZMark::mark_and_follow(ZMarkContext* context, ZMarkStackEntry entry) {\n   // Decode flags\n   const bool finalizable = entry.finalizable();\n@@ -449,13 +429,7 @@ void ZMark::mark_and_follow(ZMarkContext* context, ZMarkStackEntry entry) {\n     if (is_array(addr)) {\n       follow_array_object(objArrayOop(to_oop(addr)), finalizable);\n     } else {\n-      const oop obj = to_oop(addr);\n-      follow_object(obj, finalizable);\n-\n-      if (!finalizable) {\n-        // Try deduplicate\n-        try_deduplicate(context, obj);\n-      }\n+      follow_object(to_oop(addr), finalizable);\n     }\n   }\n }", "target": "diff --git a/src/hotspot/share/gc/z/zMark.cpp b/src/hotspot/share/gc/z/zMark.cpp\nindex e0c68213ca3..9846f1244ec 100644\n--- a/src/hotspot/share/gc/z/zMark.cpp\n+++ b/src/hotspot/share/gc/z/zMark.cpp\n@@ -27,7 +27,6 @@\n #include \"code/nmethod.hpp\"\n #include \"gc/shared/continuationGCSupport.inline.hpp\"\n #include \"gc/shared/gc_globals.hpp\"\n-#include \"gc/shared/stringdedup/stringDedup.hpp\"\n #include \"gc/shared/suspendibleThreadSet.hpp\"\n #include \"gc/shared/workerThread.hpp\"\n #include \"gc/z/zAbort.inline.hpp\"\n@@ -389,25 +388,6 @@ void ZMark::follow_object(oop obj, bool finalizable) {\n   }\n }\n \n-static void try_deduplicate(ZMarkContext* context, oop obj) {\n-  if (!StringDedup::is_enabled()) {\n-    // Not enabled\n-    return;\n-  }\n-\n-  if (!java_lang_String::is_instance(obj)) {\n-    // Not a String object\n-    return;\n-  }\n-\n-  if (java_lang_String::test_and_set_deduplication_requested(obj)) {\n-    // Already requested deduplication\n-    return;\n-  }\n-\n-  // Request deduplication\n-  context->string_dedup_requests()->add(obj);\n-}\n-\n void ZMark::mark_and_follow(ZMarkContext* context, ZMarkStackEntry entry) {\n   // Decode flags\n   const bool finalizable = entry.finalizable();\n@@ -449,13 +429,7 @@ void ZMark::mark_and_follow(ZMarkContext* context, ZMarkStackEntry entry) {\n     if (is_array(addr)) {\n       follow_array_object(objArrayOop(to_oop(addr)), finalizable);\n     } else {\n-      const oop obj = to_oop(addr);\n-      follow_object(obj, finalizable);\n-\n-      if (!finalizable) {\n-        // Try deduplicate\n-        try_deduplicate(context, obj);\n-      }\n+      follow_object(to_oop(addr), finalizable);\n     }\n   }\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在标记阶段（mark phase）对所有字符串对象尝试去重，包括短寿命字符串，增加了标记阶段的额外开销。优化后：将字符串去重延迟到重定位阶段（relocate phase），仅对晋升对象（promoted objects）进行去重，让短寿命字符串自然消亡。优化思路：避免为即将死亡的短寿命字符串支付去重开销，减少GC暂停时间，同时通过新增的ZStringDedup模块集中管理去重逻辑，提升内存利用效率。"}
{"id": 424, "source": "riscv-dataset-excel", "optimization_type": "循环优化+依赖关系优化", "optimization_description": "优化前：在计数循环中，当循环phi类型被缩小（例如确定除数不为零）时，除法节点会丢失与零行程保护条件的控制依赖关系，导致除法可能浮到循环保护条件之上，即使循环未执行也会执行除法。优化后：在创建主循环和后循环时，通过添加CastII节点显式建立循环phi输入与零行程保护之间的依赖关系，确保除法节点保持正确的控制依赖。优化思路：通过强制依赖关系防止除法节点在循环保护条件之前执行，避免潜在除零异常。", "original_code": "在计数循环中，当循环phi类型被缩小（例如确定除数不为零）时，除法节点会丢失与零行程保护条件的控制依赖关系，导致除法可能浮到循环保护条件之上，即使循环未执行也会执行除法。", "optimized_code": "void PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, CountedLoopNode* loop) {\n  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n  register_new_node(castii, ctrl);\n  Node* phi = loop->phi();\n  assert(phi->in(LoopNode::EntryControl) == incr, \"replacing wrong input?\");\n  _igvn.replace_input_of(phi, LoopNode::EntryControl, castii);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/be6e4406d8c9024bb368ed9dc22d4a6df2a0846a", "code_v0_no_empty_lines": "在计数循环中，当循环phi类型被缩小（例如确定除数不为零）时，除法节点会丢失与零行程保护条件的控制依赖关系，导致除法可能浮到循环保护条件之上，即使循环未执行也会执行除法。", "code_v1_no_empty_lines": "void PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, CountedLoopNode* loop) {\n  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n  register_new_node(castii, ctrl);\n  Node* phi = loop->phi();\n  assert(phi->in(LoopNode::EntryControl) == incr, \"replacing wrong input?\");\n  _igvn.replace_input_of(phi, LoopNode::EntryControl, castii);\n}", "target": "void PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, CountedLoopNode* loop) {\n  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n  register_new_node(castii, ctrl);\n  Node* phi = loop->phi();\n  assert(phi->in(LoopNode::EntryControl) == incr, \"replacing wrong input?\");\n  _igvn.replace_input_of(phi, LoopNode::EntryControl, castii);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在计数循环中，当循环phi类型被缩小（例如确定除数不为零）时，除法节点会丢失与零行程保护条件的控制依赖关系，导致除法可能浮到循环保护条件之上，即使循环未执行也会执行除法。优化后：在创建主循环和后循环时，通过添加CastII节点显式建立循环phi输入与零行程保护之间的依赖关系，确保除法节点保持正确的控制依赖。优化思路：通过强制依赖关系防止除法节点在循环保护条件之前执行，避免潜在除零异常。"}
{"id": 425, "source": "riscv-dataset-excel", "optimization_type": "字节码生成优化", "optimization_description": "优化前：类型开关（type switch）的字节码生成过程中，栈映射表（StackMapTable）信息是动态计算和添加的，每次生成都需要重新计算验证类型信息，增加了运行时开销。优化后：预定义了两个静态常量列表（TYPE_SWITCH_LOCALS和TYPE_SWITCH_EXTRA_LOCALS），根据条件选择使用，并在生成字节码时复用这些预定义的验证类型信息，同时集中管理栈映射帧的构建。优化思路：通过预计算和复用验证类型信息，减少动态计算开销，提高类型开关操作的性能，特别是在频繁调用的场景下。", "original_code": "类型开关（type switch）的字节码生成过程中，栈映射表（StackMapTable）信息是动态计算和添加的，每次生成都需要重新计算验证类型信息，增加了运行时开销。", "optimized_code": "private static final List<StackMapFrameInfo.VerificationTypeInfo> TYPE_SWITCH_LOCALS = List.of(\n            StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_Object), StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER\n    );\nprivate static final List<StackMapFrameInfo.VerificationTypeInfo> TYPE_SWITCH_EXTRA_LOCALS = List.of(\n            StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_Object), StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER,\n            StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_BiPredicate), StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_List)\n    );\nvar locals = enumDescs == null && extraClassLabels == null ? TYPE_SWITCH_LOCALS : TYPE_SWITCH_EXTRA_LOCALS;\nvar stackMapFrames = new ArrayList<StackMapFrameInfo>(labelConstants.length * 2);\nstackMapFrames.add(StackMapFrameInfo.of(nonNullLabel, locals, List.of()));\n.with(StackMapTableAttribute.of(stackMapFrames));\nDirectCodeBuilder.withMaxs(cb, 2, locals.size());", "source_url": "https://github.com/openjdk/riscv-port/commit/bd1c53e96038994788ca5c11602aa2ce4fa4c840", "code_v0_no_empty_lines": "类型开关（type switch）的字节码生成过程中，栈映射表（StackMapTable）信息是动态计算和添加的，每次生成都需要重新计算验证类型信息，增加了运行时开销。", "code_v1_no_empty_lines": "private static final List<StackMapFrameInfo.VerificationTypeInfo> TYPE_SWITCH_LOCALS = List.of(\n            StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_Object), StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER\n    );\nprivate static final List<StackMapFrameInfo.VerificationTypeInfo> TYPE_SWITCH_EXTRA_LOCALS = List.of(\n            StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_Object), StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER,\n            StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_BiPredicate), StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_List)\n    );\nvar locals = enumDescs == null && extraClassLabels == null ? TYPE_SWITCH_LOCALS : TYPE_SWITCH_EXTRA_LOCALS;\nvar stackMapFrames = new ArrayList<StackMapFrameInfo>(labelConstants.length * 2);\nstackMapFrames.add(StackMapFrameInfo.of(nonNullLabel, locals, List.of()));\n.with(StackMapTableAttribute.of(stackMapFrames));\nDirectCodeBuilder.withMaxs(cb, 2, locals.size());", "target": "private static final List<StackMapFrameInfo.VerificationTypeInfo> TYPE_SWITCH_LOCALS = List.of(\n            StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_Object), StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER\n    );\nprivate static final List<StackMapFrameInfo.VerificationTypeInfo> TYPE_SWITCH_EXTRA_LOCALS = List.of(\n            StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_Object), StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER,\n            StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_BiPredicate), StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_List)\n    );\nvar locals = enumDescs == null && extraClassLabels == null ? TYPE_SWITCH_LOCALS : TYPE_SWITCH_EXTRA_LOCALS;\nvar stackMapFrames = new ArrayList<StackMapFrameInfo>(labelConstants.length * 2);\nstackMapFrames.add(StackMapFrameInfo.of(nonNullLabel, locals, List.of()));\n.with(StackMapTableAttribute.of(stackMapFrames));\nDirectCodeBuilder.withMaxs(cb, 2, locals.size());", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：类型开关（type switch）的字节码生成过程中，栈映射表（StackMapTable）信息是动态计算和添加的，每次生成都需要重新计算验证类型信息，增加了运行时开销。优化后：预定义了两个静态常量列表（TYPE_SWITCH_LOCALS和TYPE_SWITCH_EXTRA_LOCALS），根据条件选择使用，并在生成字节码时复用这些预定义的验证类型信息，同时集中管理栈映射帧的构建。优化思路：通过预计算和复用验证类型信息，减少动态计算开销，提高类型开关操作的性能，特别是在频繁调用的场景下。"}
{"id": 426, "source": "riscv-dataset-excel", "optimization_type": "测试兼容性优化", "optimization_description": "优化前：测试用例在启用-XX:+UseCompactObjectHeaders选项的JDK构建中会失败，因为缺少必要的实验性选项解锁。优化后：添加-XX:+UnlockExperimentalVMOptions以解锁实验性选项，并显式禁用-XX:-UseCompactObjectHeaders确保测试兼容性。思路：通过添加必要的VM选项解锁和显式禁用特定功能，确保测试用例在不同JDK构建配置下都能正常运行。", "original_code": "测试用例在启用-XX:+UseCompactObjectHeaders选项的JDK构建中会失败，因为缺少必要的实验性选项解锁。", "optimized_code": "+                \"-XX:+UnlockExperimentalVMOptions\",\n+                \"-XX:-UseCompactObjectHeaders\",", "source_url": "https://github.com/openjdk/riscv-port/commit/1a72febc97de3d0ade8813951797dfda1984650f", "code_v0_no_empty_lines": "测试用例在启用-XX:+UseCompactObjectHeaders选项的JDK构建中会失败，因为缺少必要的实验性选项解锁。", "code_v1_no_empty_lines": "+                \"-XX:+UnlockExperimentalVMOptions\",\n+                \"-XX:-UseCompactObjectHeaders\",", "target": "+                \"-XX:+UnlockExperimentalVMOptions\",\n+                \"-XX:-UseCompactObjectHeaders\",", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：测试用例在启用-XX:+UseCompactObjectHeaders选项的JDK构建中会失败，因为缺少必要的实验性选项解锁。优化后：添加-XX:+UnlockExperimentalVMOptions以解锁实验性选项，并显式禁用-XX:-UseCompactObjectHeaders确保测试兼容性。思路：通过添加必要的VM选项解锁和显式禁用特定功能，确保测试用例在不同JDK构建配置下都能正常运行。"}
{"id": 427, "source": "riscv-dataset-excel", "optimization_type": "配置优化+内存管理优化", "optimization_description": "优化前：当ZFakeNUMA启用时，UseNUMA可能仍被设置为true，导致NUMA相关优化与ZFakeNUMA模拟的NUMA环境冲突，可能产生性能开销或错误行为。优化后：当ZFakeNUMA启用时，强制禁用UseNUMA，避免两者同时启用带来的冲突。优化思路：确保NUMA相关配置的一致性，当使用模拟NUMA环境时，禁用实际的NUMA优化，防止资源浪费和潜在的性能问题。", "original_code": "当ZFakeNUMA启用时，UseNUMA可能仍被设置为true，导致NUMA相关优化与ZFakeNUMA模拟的NUMA环境冲突，可能产生性能开销或错误行为。", "optimized_code": "-  // Enable NUMA by default\n-  if (FLAG_IS_DEFAULT(UseNUMA) && FLAG_IS_DEFAULT(ZFakeNUMA)) {\n-    FLAG_SET_DEFAULT(UseNUMA, true);\n+  // NUMA settings\n+  if (FLAG_IS_DEFAULT(ZFakeNUMA)) {\n+    // Enable NUMA by default\n+    if (FLAG_IS_DEFAULT(UseNUMA)) {\n+      FLAG_SET_DEFAULT(UseNUMA, true);\n+    }\n+  } else {\n+    if (UseNUMA) {\n+      if (!FLAG_IS_DEFAULT(UseNUMA)) {\n+        warning(\"ZFakeNUMA is enabled; turning off UseNUMA\");\n+      }\n+      FLAG_SET_ERGO(UseNUMA, false);\n+    }\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/f2587d9bd2e86c46c49ad972790c60ec394848da", "code_v0_no_empty_lines": "当ZFakeNUMA启用时，UseNUMA可能仍被设置为true，导致NUMA相关优化与ZFakeNUMA模拟的NUMA环境冲突，可能产生性能开销或错误行为。", "code_v1_no_empty_lines": "-  // Enable NUMA by default\n-  if (FLAG_IS_DEFAULT(UseNUMA) && FLAG_IS_DEFAULT(ZFakeNUMA)) {\n-    FLAG_SET_DEFAULT(UseNUMA, true);\n+  // NUMA settings\n+  if (FLAG_IS_DEFAULT(ZFakeNUMA)) {\n+    // Enable NUMA by default\n+    if (FLAG_IS_DEFAULT(UseNUMA)) {\n+      FLAG_SET_DEFAULT(UseNUMA, true);\n+    }\n+  } else {\n+    if (UseNUMA) {\n+      if (!FLAG_IS_DEFAULT(UseNUMA)) {\n+        warning(\"ZFakeNUMA is enabled; turning off UseNUMA\");\n+      }\n+      FLAG_SET_ERGO(UseNUMA, false);\n+    }\n+  }", "target": "-  // Enable NUMA by default\n-  if (FLAG_IS_DEFAULT(UseNUMA) && FLAG_IS_DEFAULT(ZFakeNUMA)) {\n-    FLAG_SET_DEFAULT(UseNUMA, true);\n+  // NUMA settings\n+  if (FLAG_IS_DEFAULT(ZFakeNUMA)) {\n+    // Enable NUMA by default\n+    if (FLAG_IS_DEFAULT(UseNUMA)) {\n+      FLAG_SET_DEFAULT(UseNUMA, true);\n+    }\n+  } else {\n+    if (UseNUMA) {\n+      if (!FLAG_IS_DEFAULT(UseNUMA)) {\n+        warning(\"ZFakeNUMA is enabled; turning off UseNUMA\");\n+      }\n+      FLAG_SET_ERGO(UseNUMA, false);\n+    }\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当ZFakeNUMA启用时，UseNUMA可能仍被设置为true，导致NUMA相关优化与ZFakeNUMA模拟的NUMA环境冲突，可能产生性能开销或错误行为。优化后：当ZFakeNUMA启用时，强制禁用UseNUMA，避免两者同时启用带来的冲突。优化思路：确保NUMA相关配置的一致性，当使用模拟NUMA环境时，禁用实际的NUMA优化，防止资源浪费和潜在的性能问题。"}
{"id": 428, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：使用mmap时未指定MAP_FIXED_NOREPLACE标志，可能导致内存映射冲突和意外覆盖已存在的映射。优化后：在Linux系统上添加MAP_FIXED_NOREPLACE标志，确保在指定地址映射内存时，如果该地址已被占用则失败而不是覆盖。优化思路：提高内存预留的可靠性和安全性，避免因地址冲突导致的不可预测行为，同时保持向后兼容性（通过条件编译仅Linux生效）。", "original_code": "使用mmap时未指定MAP_FIXED_NOREPLACE标志，可能导致内存映射冲突和意外覆盖已存在的映射。", "optimized_code": "--- a/src/hotspot/os/posix/gc/z/zVirtualMemoryManager_posix.cpp\n+++ b/src/hotspot/os/posix/gc/z/zVirtualMemoryManager_posix.cpp\n@@ -32,7 +35,9 @@ void ZVirtualMemoryReserver::pd_register_callbacks(ZVirtualMemoryRegistry* regis\n }\n \n bool ZVirtualMemoryReserver::pd_reserve(zaddress_unsafe addr, size_t size) {\n-  void* const res = mmap((void*)untype(addr), size, PROT_NONE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_NORESERVE, -1, 0);\n+  const int flags = MAP_ANONYMOUS|MAP_PRIVATE|MAP_NORESERVE LINUX_ONLY(|MAP_FIXED_NOREPLACE);\n+\n+  void* const res = mmap((void*)untype(addr), size, PROT_NONE, flags, -1, 0);", "source_url": "https://github.com/openjdk/riscv-port/commit/0f1c448ca15485cd7270cf0607acfceacdcefaff", "code_v0_no_empty_lines": "使用mmap时未指定MAP_FIXED_NOREPLACE标志，可能导致内存映射冲突和意外覆盖已存在的映射。", "code_v1_no_empty_lines": "--- a/src/hotspot/os/posix/gc/z/zVirtualMemoryManager_posix.cpp\n+++ b/src/hotspot/os/posix/gc/z/zVirtualMemoryManager_posix.cpp\n@@ -32,7 +35,9 @@ void ZVirtualMemoryReserver::pd_register_callbacks(ZVirtualMemoryRegistry* regis\n }\n \n bool ZVirtualMemoryReserver::pd_reserve(zaddress_unsafe addr, size_t size) {\n-  void* const res = mmap((void*)untype(addr), size, PROT_NONE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_NORESERVE, -1, 0);\n+  const int flags = MAP_ANONYMOUS|MAP_PRIVATE|MAP_NORESERVE LINUX_ONLY(|MAP_FIXED_NOREPLACE);\n+\n+  void* const res = mmap((void*)untype(addr), size, PROT_NONE, flags, -1, 0);", "target": "--- a/src/hotspot/os/posix/gc/z/zVirtualMemoryManager_posix.cpp\n+++ b/src/hotspot/os/posix/gc/z/zVirtualMemoryManager_posix.cpp\n@@ -32,7 +35,9 @@ void ZVirtualMemoryReserver::pd_register_callbacks(ZVirtualMemoryRegistry* regis\n }\n \n bool ZVirtualMemoryReserver::pd_reserve(zaddress_unsafe addr, size_t size) {\n-  void* const res = mmap((void*)untype(addr), size, PROT_NONE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_NORESERVE, -1, 0);\n+  const int flags = MAP_ANONYMOUS|MAP_PRIVATE|MAP_NORESERVE LINUX_ONLY(|MAP_FIXED_NOREPLACE);\n+\n+  void* const res = mmap((void*)untype(addr), size, PROT_NONE, flags, -1, 0);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用mmap时未指定MAP_FIXED_NOREPLACE标志，可能导致内存映射冲突和意外覆盖已存在的映射。优化后：在Linux系统上添加MAP_FIXED_NOREPLACE标志，确保在指定地址映射内存时，如果该地址已被占用则失败而不是覆盖。优化思路：提高内存预留的可靠性和安全性，避免因地址冲突导致的不可预测行为，同时保持向后兼容性（通过条件编译仅Linux生效）。"}
{"id": 429, "source": "riscv-dataset-excel", "optimization_type": "编译器向量化优化", "optimization_description": "优化前：内存依赖处理与普通依赖混合，使用通用依赖集合vtn_dependencies，可能导致依赖关系不明确，影响向量化优化效果。优化后：将内存依赖与普通依赖分离，引入专门的内存依赖集合vtn_memory_dependencies，并调用专门的add_memory_dependencies_of_node_to_vtnode函数处理内存依赖。优化思路：通过显式区分内存依赖和普通依赖，使向量化构建过程更清晰，减少依赖处理错误，提升C2编译器SuperWord向量化优化的准确性和性能。", "original_code": "内存依赖处理与普通依赖混合，使用通用依赖集合vtn_dependencies，可能导致依赖关系不明确，影响向量化优化效果。", "optimized_code": "- void SuperWordVTransformBuilder::build_inputs_for_vector_vtnodes(VectorSet& vtn_dependencies) {\n+ void SuperWordVTransformBuilder::build_inputs_for_vector_vtnodes(VectorSet& vtn_memory_dependencies) {\n-     vtn_dependencies.clear(); // Add every dependency only once per vtn.\n+     vtn_memory_dependencies.clear(); // Add every memory dependency only once per vtn.\n-     add_dependencies_of_node_to_vtnode(pack->at(k), vtn, vtn_dependencies);\n+     add_memory_dependencies_of_node_to_vtnode(pack->at(k), vtn, vtn_memory_dependencies);", "source_url": "https://github.com/openjdk/riscv-port/commit/4dd64b49716144cc697fb461ff88860e2cbcaaea", "code_v0_no_empty_lines": "内存依赖处理与普通依赖混合，使用通用依赖集合vtn_dependencies，可能导致依赖关系不明确，影响向量化优化效果。", "code_v1_no_empty_lines": "- void SuperWordVTransformBuilder::build_inputs_for_vector_vtnodes(VectorSet& vtn_dependencies) {\n+ void SuperWordVTransformBuilder::build_inputs_for_vector_vtnodes(VectorSet& vtn_memory_dependencies) {\n-     vtn_dependencies.clear(); // Add every dependency only once per vtn.\n+     vtn_memory_dependencies.clear(); // Add every memory dependency only once per vtn.\n-     add_dependencies_of_node_to_vtnode(pack->at(k), vtn, vtn_dependencies);\n+     add_memory_dependencies_of_node_to_vtnode(pack->at(k), vtn, vtn_memory_dependencies);", "target": "- void SuperWordVTransformBuilder::build_inputs_for_vector_vtnodes(VectorSet& vtn_dependencies) {\n+ void SuperWordVTransformBuilder::build_inputs_for_vector_vtnodes(VectorSet& vtn_memory_dependencies) {\n-     vtn_dependencies.clear(); // Add every dependency only once per vtn.\n+     vtn_memory_dependencies.clear(); // Add every memory dependency only once per vtn.\n-     add_dependencies_of_node_to_vtnode(pack->at(k), vtn, vtn_dependencies);\n+     add_memory_dependencies_of_node_to_vtnode(pack->at(k), vtn, vtn_memory_dependencies);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：内存依赖处理与普通依赖混合，使用通用依赖集合vtn_dependencies，可能导致依赖关系不明确，影响向量化优化效果。优化后：将内存依赖与普通依赖分离，引入专门的内存依赖集合vtn_memory_dependencies，并调用专门的add_memory_dependencies_of_node_to_vtnode函数处理内存依赖。优化思路：通过显式区分内存依赖和普通依赖，使向量化构建过程更清晰，减少依赖处理错误，提升C2编译器SuperWord向量化优化的准确性和性能。"}
{"id": 430, "source": "riscv-dataset-excel", "optimization_type": "死代码消除", "optimization_description": "优化前：Blackhole节点即使其控制输入（control input）已死（即该分支不可达），仍会保留在IR中，导致不必要的节点存在和潜在的性能开销。优化后：为BlackholeNode实现了Ideal方法，调用remove_dead_region来检查并移除控制输入已死的Blackhole节点。优化思路：在C2编译器的优化阶段（PhaseGVN），通过Ideal变换识别并消除死代码（dead control input的Blackhole），减少IR节点数量，提升编译效率和生成的代码质量。", "original_code": "Blackhole节点即使其控制输入（control input）已死（即该分支不可达），仍会保留在IR中，导致不必要的节点存在和潜在的性能开销。", "optimized_code": "+Node* BlackholeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/1138a186eb670e2c0662bda69c35680b41f4d66c", "code_v0_no_empty_lines": "Blackhole节点即使其控制输入（control input）已死（即该分支不可达），仍会保留在IR中，导致不必要的节点存在和潜在的性能开销。", "code_v1_no_empty_lines": "+Node* BlackholeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n+}", "target": "+Node* BlackholeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Blackhole节点即使其控制输入（control input）已死（即该分支不可达），仍会保留在IR中，导致不必要的节点存在和潜在的性能开销。优化后：为BlackholeNode实现了Ideal方法，调用remove_dead_region来检查并移除控制输入已死的Blackhole节点。优化思路：在C2编译器的优化阶段（PhaseGVN），通过Ideal变换识别并消除死代码（dead control input的Blackhole），减少IR节点数量，提升编译效率和生成的代码质量。"}
{"id": 431, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+性能优化", "optimization_description": "优化前：VSeq类限制向量寄存器序列长度为2的幂且不超过8，缺乏灵活的序列操作功能，寄存器范围检查不完善。优化后：1. 移除长度限制，支持任意偶数长度的序列；2. 增强寄存器范围检查，防止下溢和上溢；3. 添加VS_MASK_BIT宏简化掩码计算；4. 新增is_constant()方法检测常量序列；5. 添加vs_write_before_read()方法检查寄存器读写顺序；6. 模板化vs_front/vs_back/vs_even/vs_odd方法，支持任意偶数长度序列的分割；7. 新增vs_reverse()方法支持反向索引序列。优化思路：为ML-KEM算法提供更灵活的向量寄存器操作支持，充分利用AArch64架构的SIMD指令并行性，提升加密算法的执行效率。", "original_code": "VSeq类限制向量寄存器序列长度为2的幂且不超过8，缺乏灵活的序列操作功能，寄存器范围检查不完善。", "optimized_code": "template<int N> class VSeq {\n  static_assert(N >= 2, \"vector sequence length must be greater than 1\");\n-  static_assert(N <= 8, \"vector sequence length must not exceed 8\");\n-  static_assert((N & (N - 1)) == 0, \"vector sequence length must be power of two\");\nprivate:\n  int _base;  // index of first register in sequence\n  int _delta; // increment to derive successive indices\npublic:\n  VSeq(FloatRegister base_reg, int delta = 1) : VSeq(base_reg->encoding(), delta) { }\n  VSeq(int base, int delta = 1) : _base(base), _delta(delta) {\n-    assert (_base >= 0, \"invalid base register\");\n-    assert (_delta >= 0, \"invalid register delta\");\n-    assert ((_base + (N - 1) * _delta) < 32, \"range exceeded\");\n+    assert (_base >= 0 && _base <= 31, \"invalid base register\");\n+    assert ((_base + (N - 1) * _delta) >= 0, \"register range underflow\");\n+    assert ((_base + (N - 1) * _delta) < 32, \"register range overflow\");\n  }\n  // indexed access to sequence\n  FloatRegister operator [](int i) const {\n    assert(i >= 0 && i < N, \"index out of bounds\");\n    return as_FloatRegister(_base + i * _delta);\n  }\n  int mask() const {\n    int m = 0;\n-    int bit = 1 << _base;\n    for (int i = 0; i < N; i++) {\n-      m |= bit << (i * _delta);\n+      m |= VS_MASK_BIT(_base, _delta, i);\n    }\n    return m;\n  }\n  int base() const { return _base; }\n  int delta() const { return _delta; }\n+  bool is_constant() const { return _delta == 0; }\n};", "source_url": "https://github.com/openjdk/riscv-port/commit/465c8e658356f658ee04397936f555f6bdffc3c2", "code_v0_no_empty_lines": "VSeq类限制向量寄存器序列长度为2的幂且不超过8，缺乏灵活的序列操作功能，寄存器范围检查不完善。", "code_v1_no_empty_lines": "template<int N> class VSeq {\n  static_assert(N >= 2, \"vector sequence length must be greater than 1\");\n-  static_assert(N <= 8, \"vector sequence length must not exceed 8\");\n-  static_assert((N & (N - 1)) == 0, \"vector sequence length must be power of two\");\nprivate:\n  int _base;  // index of first register in sequence\n  int _delta; // increment to derive successive indices\npublic:\n  VSeq(FloatRegister base_reg, int delta = 1) : VSeq(base_reg->encoding(), delta) { }\n  VSeq(int base, int delta = 1) : _base(base), _delta(delta) {\n-    assert (_base >= 0, \"invalid base register\");\n-    assert (_delta >= 0, \"invalid register delta\");\n-    assert ((_base + (N - 1) * _delta) < 32, \"range exceeded\");\n+    assert (_base >= 0 && _base <= 31, \"invalid base register\");\n+    assert ((_base + (N - 1) * _delta) >= 0, \"register range underflow\");\n+    assert ((_base + (N - 1) * _delta) < 32, \"register range overflow\");\n  }\n  // indexed access to sequence\n  FloatRegister operator [](int i) const {\n    assert(i >= 0 && i < N, \"index out of bounds\");\n    return as_FloatRegister(_base + i * _delta);\n  }\n  int mask() const {\n    int m = 0;\n-    int bit = 1 << _base;\n    for (int i = 0; i < N; i++) {\n-      m |= bit << (i * _delta);\n+      m |= VS_MASK_BIT(_base, _delta, i);\n    }\n    return m;\n  }\n  int base() const { return _base; }\n  int delta() const { return _delta; }\n+  bool is_constant() const { return _delta == 0; }\n};", "target": "template<int N> class VSeq {\n  static_assert(N >= 2, \"vector sequence length must be greater than 1\");\n-  static_assert(N <= 8, \"vector sequence length must not exceed 8\");\n-  static_assert((N & (N - 1)) == 0, \"vector sequence length must be power of two\");\nprivate:\n  int _base;  // index of first register in sequence\n  int _delta; // increment to derive successive indices\npublic:\n  VSeq(FloatRegister base_reg, int delta = 1) : VSeq(base_reg->encoding(), delta) { }\n  VSeq(int base, int delta = 1) : _base(base), _delta(delta) {\n-    assert (_base >= 0, \"invalid base register\");\n-    assert (_delta >= 0, \"invalid register delta\");\n-    assert ((_base + (N - 1) * _delta) < 32, \"range exceeded\");\n+    assert (_base >= 0 && _base <= 31, \"invalid base register\");\n+    assert ((_base + (N - 1) * _delta) >= 0, \"register range underflow\");\n+    assert ((_base + (N - 1) * _delta) < 32, \"register range overflow\");\n  }\n  // indexed access to sequence\n  FloatRegister operator [](int i) const {\n    assert(i >= 0 && i < N, \"index out of bounds\");\n    return as_FloatRegister(_base + i * _delta);\n  }\n  int mask() const {\n    int m = 0;\n-    int bit = 1 << _base;\n    for (int i = 0; i < N; i++) {\n-      m |= bit << (i * _delta);\n+      m |= VS_MASK_BIT(_base, _delta, i);\n    }\n    return m;\n  }\n  int base() const { return _base; }\n  int delta() const { return _delta; }\n+  bool is_constant() const { return _delta == 0; }\n};", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：VSeq类限制向量寄存器序列长度为2的幂且不超过8，缺乏灵活的序列操作功能，寄存器范围检查不完善。优化后：1. 移除长度限制，支持任意偶数长度的序列；2. 增强寄存器范围检查，防止下溢和上溢；3. 添加VS_MASK_BIT宏简化掩码计算；4. 新增is_constant()方法检测常量序列；5. 添加vs_write_before_read()方法检查寄存器读写顺序；6. 模板化vs_front/vs_back/vs_even/vs_odd方法，支持任意偶数长度序列的分割；7. 新增vs_reverse()方法支持反向索引序列。优化思路：为ML-KEM算法提供更灵活的向量寄存器操作支持，充分利用AArch64架构的SIMD指令并行性，提升加密算法的执行效率。"}
{"id": 432, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+算术优化", "optimization_description": "优化前：在fold_subI_no_underflow_pattern函数中折叠MaxL/MinL模式时，缺少对long类型加法溢出的检查，可能导致优化后的代码产生不正确结果。优化后：1. 新增can_overflow(const TypeLong*, jlong)函数，专门检测long类型加法是否可能溢出；2. 在模式折叠前添加溢出检查，如果检测到可能溢出则放弃优化。优化思路：通过添加精确的溢出检测，确保编译器优化仅在安全情况下进行，避免因算术溢出导致程序行为错误，同时保持优化带来的性能收益。", "original_code": "在fold_subI_no_underflow_pattern函数中折叠MaxL/MinL模式时，缺少对long类型加法溢出的检查，可能导致优化后的代码产生不正确结果。", "optimized_code": "+// Check if addition of a long with type 't' and a constant 'c' can overflow.\n+static bool can_overflow(const TypeLong* t, jlong c) {\n+  jlong t_lo = t->_lo;\n+  jlong t_hi = t->_hi;\n+  return ((c < 0 && (java_add(t_lo, c) > t_lo)) ||\n+          (c > 0 && (java_add(t_hi, c) < t_hi)));\n+}\n+\n+          // Collapsed graph not equivalent if potential over/underflow -> bailing out (*)\n+          if (can_overflow(phase->type(x)->is_long(), con1->get_long() + con2->get_long())) {\n+            return nullptr;\n+          }", "source_url": "https://github.com/openjdk/riscv-port/commit/38afa4d42ff27f9c9ef18ee1691885ed4cf8dde5", "code_v0_no_empty_lines": "在fold_subI_no_underflow_pattern函数中折叠MaxL/MinL模式时，缺少对long类型加法溢出的检查，可能导致优化后的代码产生不正确结果。", "code_v1_no_empty_lines": "+// Check if addition of a long with type 't' and a constant 'c' can overflow.\n+static bool can_overflow(const TypeLong* t, jlong c) {\n+  jlong t_lo = t->_lo;\n+  jlong t_hi = t->_hi;\n+  return ((c < 0 && (java_add(t_lo, c) > t_lo)) ||\n+          (c > 0 && (java_add(t_hi, c) < t_hi)));\n+}\n+\n+          // Collapsed graph not equivalent if potential over/underflow -> bailing out (*)\n+          if (can_overflow(phase->type(x)->is_long(), con1->get_long() + con2->get_long())) {\n+            return nullptr;\n+          }", "target": "+// Check if addition of a long with type 't' and a constant 'c' can overflow.\n+static bool can_overflow(const TypeLong* t, jlong c) {\n+  jlong t_lo = t->_lo;\n+  jlong t_hi = t->_hi;\n+  return ((c < 0 && (java_add(t_lo, c) > t_lo)) ||\n+          (c > 0 && (java_add(t_hi, c) < t_hi)));\n+}\n+\n+          // Collapsed graph not equivalent if potential over/underflow -> bailing out (*)\n+          if (can_overflow(phase->type(x)->is_long(), con1->get_long() + con2->get_long())) {\n+            return nullptr;\n+          }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在fold_subI_no_underflow_pattern函数中折叠MaxL/MinL模式时，缺少对long类型加法溢出的检查，可能导致优化后的代码产生不正确结果。优化后：1. 新增can_overflow(const TypeLong*, jlong)函数，专门检测long类型加法是否可能溢出；2. 在模式折叠前添加溢出检查，如果检测到可能溢出则放弃优化。优化思路：通过添加精确的溢出检测，确保编译器优化仅在安全情况下进行，避免因算术溢出导致程序行为错误，同时保持优化带来的性能收益。"}
{"id": 433, "source": "riscv-dataset-excel", "optimization_type": "内存优化+性能优化", "optimization_description": "优化前：使用原始缓冲区进行SYNC_FLUSH操作，当缓冲区小于7字节时，zlib库可能重复输出5字节的flush标记，导致性能下降和内存浪费。优化后：引入SYNC_FLUSH_MIN_BUF_SIZE常量，在flush()方法中检查缓冲区大小，若小于7字节则使用默认512字节缓冲区，确保满足zlib库要求。优化思路：遵循zlib库文档要求，避免重复flush标记输出，提高压缩效率和内存使用效率。", "original_code": "使用原始缓冲区进行SYNC_FLUSH操作，当缓冲区小于7字节时，zlib库可能重复输出5字节的flush标记，导致性能下降和内存浪费。", "optimized_code": "private static final int SYNC_FLUSH_MIN_BUF_SIZE = 7;\nfinal byte[] flushBuf = buf.length < SYNC_FLUSH_MIN_BUF_SIZE\n        ? new byte[DEFAULT_BUF_SIZE]\n        : buf;\nwhile ((len = def.deflate(flushBuf, 0, flushBuf.length, Deflater.SYNC_FLUSH)) > 0) {\n    out.write(flushBuf, 0, len);\n    if (len < flushBuf.length)\n        break;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/cf871db447660e657a3db82bffae8fce1b7e57a5", "code_v0_no_empty_lines": "使用原始缓冲区进行SYNC_FLUSH操作，当缓冲区小于7字节时，zlib库可能重复输出5字节的flush标记，导致性能下降和内存浪费。", "code_v1_no_empty_lines": "private static final int SYNC_FLUSH_MIN_BUF_SIZE = 7;\nfinal byte[] flushBuf = buf.length < SYNC_FLUSH_MIN_BUF_SIZE\n        ? new byte[DEFAULT_BUF_SIZE]\n        : buf;\nwhile ((len = def.deflate(flushBuf, 0, flushBuf.length, Deflater.SYNC_FLUSH)) > 0) {\n    out.write(flushBuf, 0, len);\n    if (len < flushBuf.length)\n        break;\n}", "target": "private static final int SYNC_FLUSH_MIN_BUF_SIZE = 7;\nfinal byte[] flushBuf = buf.length < SYNC_FLUSH_MIN_BUF_SIZE\n        ? new byte[DEFAULT_BUF_SIZE]\n        : buf;\nwhile ((len = def.deflate(flushBuf, 0, flushBuf.length, Deflater.SYNC_FLUSH)) > 0) {\n    out.write(flushBuf, 0, len);\n    if (len < flushBuf.length)\n        break;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用原始缓冲区进行SYNC_FLUSH操作，当缓冲区小于7字节时，zlib库可能重复输出5字节的flush标记，导致性能下降和内存浪费。优化后：引入SYNC_FLUSH_MIN_BUF_SIZE常量，在flush()方法中检查缓冲区大小，若小于7字节则使用默认512字节缓冲区，确保满足zlib库要求。优化思路：遵循zlib库文档要求，避免重复flush标记输出，提高压缩效率和内存使用效率。"}
{"id": 434, "source": "riscv-dataset-excel", "optimization_type": "边界检查优化+错误处理优化", "optimization_description": "优化前：Blit函数缺少对输入参数的边界检查，可能导致整数溢出或无效内存访问。优化后：1. 添加width/height非正数检查，避免无效操作；2. 添加UNSAFE_TO_ADD检查，防止srcx+width等加法溢出；3. 添加UNSAFE_TO_SUB检查，防止srcx-dstx等减法溢出。优化思路：通过前置边界检查，提前返回无效参数，避免后续计算错误和潜在的安全问题，同时减少不必要的内存操作开销。", "original_code": "Blit函数缺少对输入参数的边界检查，可能导致整数溢出或无效内存访问。", "optimized_code": "if (width <= 0 || height <= 0) {\n        return;\n    }\n\n    srcInfo.bounds.x1 = srcx;\n    srcInfo.bounds.y1 = srcy;\n    if (UNSAFE_TO_ADD(srcx, width) ||\n        UNSAFE_TO_ADD(srcy, height) ||\n        UNSAFE_TO_ADD(dstx, width) ||\n        UNSAFE_TO_ADD(dsty, height)) {\n        return;\n    }\n\n    srcInfo.bounds.x2 = srcx + width;\n    srcInfo.bounds.y2 = srcy + height;\n    dstInfo.bounds.x1 = dstx;\n    dstInfo.bounds.y1 = dsty;\n    dstInfo.bounds.x2 = dstx + width;\n    dstInfo.bounds.y2 = dsty + height;\n    if (UNSAFE_TO_SUB(srcx, dstx) ||\n        UNSAFE_TO_SUB(srcy, dsty)) {\n        return;\n    }", "source_url": "https://github.com/openjdk/riscv-port/commit/43b2b0bd1e5e6fad4581957a3072836921ef6683", "code_v0_no_empty_lines": "Blit函数缺少对输入参数的边界检查，可能导致整数溢出或无效内存访问。", "code_v1_no_empty_lines": "if (width <= 0 || height <= 0) {\n        return;\n    }\n\n    srcInfo.bounds.x1 = srcx;\n    srcInfo.bounds.y1 = srcy;\n    if (UNSAFE_TO_ADD(srcx, width) ||\n        UNSAFE_TO_ADD(srcy, height) ||\n        UNSAFE_TO_ADD(dstx, width) ||\n        UNSAFE_TO_ADD(dsty, height)) {\n        return;\n    }\n\n    srcInfo.bounds.x2 = srcx + width;\n    srcInfo.bounds.y2 = srcy + height;\n    dstInfo.bounds.x1 = dstx;\n    dstInfo.bounds.y1 = dsty;\n    dstInfo.bounds.x2 = dstx + width;\n    dstInfo.bounds.y2 = dsty + height;\n    if (UNSAFE_TO_SUB(srcx, dstx) ||\n        UNSAFE_TO_SUB(srcy, dsty)) {\n        return;\n    }", "target": "if (width <= 0 || height <= 0) {\n        return;\n    }\n\n    srcInfo.bounds.x1 = srcx;\n    srcInfo.bounds.y1 = srcy;\n    if (UNSAFE_TO_ADD(srcx, width) ||\n        UNSAFE_TO_ADD(srcy, height) ||\n        UNSAFE_TO_ADD(dstx, width) ||\n        UNSAFE_TO_ADD(dsty, height)) {\n        return;\n    }\n\n    srcInfo.bounds.x2 = srcx + width;\n    srcInfo.bounds.y2 = srcy + height;\n    dstInfo.bounds.x1 = dstx;\n    dstInfo.bounds.y1 = dsty;\n    dstInfo.bounds.x2 = dstx + width;\n    dstInfo.bounds.y2 = dsty + height;\n    if (UNSAFE_TO_SUB(srcx, dstx) ||\n        UNSAFE_TO_SUB(srcy, dsty)) {\n        return;\n    }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Blit函数缺少对输入参数的边界检查，可能导致整数溢出或无效内存访问。优化后：1. 添加width/height非正数检查，避免无效操作；2. 添加UNSAFE_TO_ADD检查，防止srcx+width等加法溢出；3. 添加UNSAFE_TO_SUB检查，防止srcx-dstx等减法溢出。优化思路：通过前置边界检查，提前返回无效参数，避免后续计算错误和潜在的安全问题，同时减少不必要的内存操作开销。"}
{"id": 435, "source": "riscv-dataset-excel", "optimization_type": "CPU特性检测优化", "optimization_description": "优化前：CPU特性检测逻辑分散在AMD/Intel/ZX平台特定代码块中，导致代码重复和维护困难，且AMD平台缺少CLWB特性检测。优化后：将LZCNT、PREFETCHW、CLWB等通用特性检测移到公共代码区域，简化平台特定代码，确保AMD平台能正确检测CLWB特性。优化思路：重构特性检测逻辑，消除代码重复，统一处理跨平台通用特性。", "original_code": "CPU特性检测逻辑分散在AMD/Intel/ZX平台特定代码块中，导致代码重复和维护困难，且AMD平台缺少CLWB特性检测。", "optimized_code": "if (ext_cpuid1_ecx.bits.lzcnt != 0)\n    result |= CPU_LZCNT;\n  if (ext_cpuid1_ecx.bits.prefetchw != 0)\n    result |= CPU_3DNOW_PREFETCH;\n  if (sef_cpuid7_ebx.bits.clwb != 0)\n    result |= CPU_CLWB;", "source_url": "https://github.com/openjdk/riscv-port/commit/3090e2187c2cbbbc08f27305d152664a83736dfa", "code_v0_no_empty_lines": "CPU特性检测逻辑分散在AMD/Intel/ZX平台特定代码块中，导致代码重复和维护困难，且AMD平台缺少CLWB特性检测。", "code_v1_no_empty_lines": "if (ext_cpuid1_ecx.bits.lzcnt != 0)\n    result |= CPU_LZCNT;\n  if (ext_cpuid1_ecx.bits.prefetchw != 0)\n    result |= CPU_3DNOW_PREFETCH;\n  if (sef_cpuid7_ebx.bits.clwb != 0)\n    result |= CPU_CLWB;", "target": "if (ext_cpuid1_ecx.bits.lzcnt != 0)\n    result |= CPU_LZCNT;\n  if (ext_cpuid1_ecx.bits.prefetchw != 0)\n    result |= CPU_3DNOW_PREFETCH;\n  if (sef_cpuid7_ebx.bits.clwb != 0)\n    result |= CPU_CLWB;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CPU特性检测逻辑分散在AMD/Intel/ZX平台特定代码块中，导致代码重复和维护困难，且AMD平台缺少CLWB特性检测。优化后：将LZCNT、PREFETCHW、CLWB等通用特性检测移到公共代码区域，简化平台特定代码，确保AMD平台能正确检测CLWB特性。优化思路：重构特性检测逻辑，消除代码重复，统一处理跨平台通用特性。"}
{"id": 436, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+内存优化", "optimization_description": "优化前：使用synchronized方法和HashMap跟踪XMLReader使用状态，导致多线程并发访问时的锁竞争和额外内存开销。优化后：移除synchronized关键字和m_inUse数据结构，改为基于ThreadLocal的线程私有缓存，消除了锁竞争，减少了内存占用。优化思路：通过线程局部存储避免共享状态，提升specjvm2008::xml.transform工作负载的可扩展性。", "original_code": "使用synchronized方法和HashMap跟踪XMLReader使用状态，导致多线程并发访问时的锁竞争和额外内存开销。", "optimized_code": "- public synchronized XMLReader getXMLReader() throws SAXException {\n+ public XMLReader getXMLReader() throws SAXException {\n- public synchronized void releaseXMLReader(XMLReader reader) {\n+ public void releaseXMLReader(XMLReader reader) {\n- private HashMap<XMLReader, Boolean> m_inUse;\n- m_inUse.put(reader, Boolean.TRUE);\n- m_inUse.remove(reader);", "source_url": "https://github.com/openjdk/riscv-port/commit/d684867066edb886bc444c864ef9db3eff318c34", "code_v0_no_empty_lines": "使用synchronized方法和HashMap跟踪XMLReader使用状态，导致多线程并发访问时的锁竞争和额外内存开销。", "code_v1_no_empty_lines": "- public synchronized XMLReader getXMLReader() throws SAXException {\n+ public XMLReader getXMLReader() throws SAXException {\n- public synchronized void releaseXMLReader(XMLReader reader) {\n+ public void releaseXMLReader(XMLReader reader) {\n- private HashMap<XMLReader, Boolean> m_inUse;\n- m_inUse.put(reader, Boolean.TRUE);\n- m_inUse.remove(reader);", "target": "- public synchronized XMLReader getXMLReader() throws SAXException {\n+ public XMLReader getXMLReader() throws SAXException {\n- public synchronized void releaseXMLReader(XMLReader reader) {\n+ public void releaseXMLReader(XMLReader reader) {\n- private HashMap<XMLReader, Boolean> m_inUse;\n- m_inUse.put(reader, Boolean.TRUE);\n- m_inUse.remove(reader);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用synchronized方法和HashMap跟踪XMLReader使用状态，导致多线程并发访问时的锁竞争和额外内存开销。优化后：移除synchronized关键字和m_inUse数据结构，改为基于ThreadLocal的线程私有缓存，消除了锁竞争，减少了内存占用。优化思路：通过线程局部存储避免共享状态，提升specjvm2008::xml.transform工作负载的可扩展性。"}
{"id": 437, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码简化", "optimization_description": "优化前：fieldDescriptor::reinitialize() 接收 InstanceKlass 和字段索引，需要调用 ik->field(index) 获取 FieldInfo，导致在遍历字段时产生双重迭代（先遍历获取索引，再通过索引查找 FieldInfo）。优化后：reinitialize() 直接接收 FieldInfo 引用，调用方通过 FieldStream 的 to_FieldInfo() 方法获取 FieldInfo 并传递，消除了双重迭代开销。优化思路：将 FieldInfo 查找从 reinitialize 内部移到调用方，利用 FieldStream 已缓存的 FieldInfo 避免重复查找，减少内存访问和函数调用开销，同时简化了代码（如移除 Pair<int,int> 结构，直接使用 FieldInfo 数组排序）。", "original_code": "fieldDescriptor::reinitialize() 接收 InstanceKlass 和字段索引，需要调用 ik->field(index) 获取 FieldInfo，导致在遍历字段时产生双重迭代（先遍历获取索引，再通过索引查找 FieldInfo）。", "optimized_code": "void fieldDescriptor::reinitialize(InstanceKlass* ik, const FieldInfo& fieldinfo) {\n  if (_cp.is_null() || field_holder() != ik) {\n    _cp = constantPoolHandle(Thread::current(), ik->constants());\n    assert(field_holder() == ik || ik->is_scratch_class(), \"must be already initialized to this class\");\n  }\n  _fieldinfo = fieldinfo;\n  guarantee(_fieldinfo.name_index() != 0 && _fieldinfo.signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/f169fc5a99ee2b485e156c043134ab76b7e5ebd9", "code_v0_no_empty_lines": "fieldDescriptor::reinitialize() 接收 InstanceKlass 和字段索引，需要调用 ik->field(index) 获取 FieldInfo，导致在遍历字段时产生双重迭代（先遍历获取索引，再通过索引查找 FieldInfo）。", "code_v1_no_empty_lines": "void fieldDescriptor::reinitialize(InstanceKlass* ik, const FieldInfo& fieldinfo) {\n  if (_cp.is_null() || field_holder() != ik) {\n    _cp = constantPoolHandle(Thread::current(), ik->constants());\n    assert(field_holder() == ik || ik->is_scratch_class(), \"must be already initialized to this class\");\n  }\n  _fieldinfo = fieldinfo;\n  guarantee(_fieldinfo.name_index() != 0 && _fieldinfo.signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n}", "target": "void fieldDescriptor::reinitialize(InstanceKlass* ik, const FieldInfo& fieldinfo) {\n  if (_cp.is_null() || field_holder() != ik) {\n    _cp = constantPoolHandle(Thread::current(), ik->constants());\n    assert(field_holder() == ik || ik->is_scratch_class(), \"must be already initialized to this class\");\n  }\n  _fieldinfo = fieldinfo;\n  guarantee(_fieldinfo.name_index() != 0 && _fieldinfo.signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：fieldDescriptor::reinitialize() 接收 InstanceKlass 和字段索引，需要调用 ik->field(index) 获取 FieldInfo，导致在遍历字段时产生双重迭代（先遍历获取索引，再通过索引查找 FieldInfo）。优化后：reinitialize() 直接接收 FieldInfo 引用，调用方通过 FieldStream 的 to_FieldInfo() 方法获取 FieldInfo 并传递，消除了双重迭代开销。优化思路：将 FieldInfo 查找从 reinitialize 内部移到调用方，利用 FieldStream 已缓存的 FieldInfo 避免重复查找，减少内存访问和函数调用开销，同时简化了代码（如移除 Pair<int,int> 结构，直接使用 FieldInfo 数组排序）。"}
{"id": 438, "source": "riscv-dataset-excel", "optimization_type": "性能优化", "optimization_description": "优化前：使用Long::valueOf方法将字符串转换为Long对象，然后自动拆箱为long，存在不必要的装箱开销。优化后：直接使用Long::parseLong方法将字符串解析为long基本类型，避免了装箱操作。思路：消除自动装箱带来的性能开销，提高HttpHeaders.firstValueAsLong方法的执行效率。", "original_code": "使用Long::valueOf方法将字符串转换为Long对象，然后自动拆箱为long，存在不必要的装箱开销。", "optimized_code": "-        return allValues(name).stream().mapToLong(Long::valueOf).findFirst();\n+        return allValues(name).stream().mapToLong(Long::parseLong).findFirst();", "source_url": "https://github.com/openjdk/riscv-port/commit/e1b677091e0f7860762695ae2e3cff2b63ff9d39", "code_v0_no_empty_lines": "使用Long::valueOf方法将字符串转换为Long对象，然后自动拆箱为long，存在不必要的装箱开销。", "code_v1_no_empty_lines": "-        return allValues(name).stream().mapToLong(Long::valueOf).findFirst();\n+        return allValues(name).stream().mapToLong(Long::parseLong).findFirst();", "target": "-        return allValues(name).stream().mapToLong(Long::valueOf).findFirst();\n+        return allValues(name).stream().mapToLong(Long::parseLong).findFirst();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用Long::valueOf方法将字符串转换为Long对象，然后自动拆箱为long，存在不必要的装箱开销。优化后：直接使用Long::parseLong方法将字符串解析为long基本类型，避免了装箱操作。思路：消除自动装箱带来的性能开销，提高HttpHeaders.firstValueAsLong方法的执行效率。"}
{"id": 439, "source": "riscv-dataset-excel", "optimization_type": "代码清理与初始化优化", "optimization_description": "优化前：编码属性初始化逻辑复杂，通过条件判断从多个来源获取nativeEncoding，file.encoding处理逻辑包含冗余的getOrDefault和putIfAbsent调用。优化后：引入_native_encoding_NDX统一获取nativeEncoding，简化file.encoding处理逻辑，直接检查null值并设置默认值UTF-8，COMPAT情况直接替换为nativeEncoding。优化思路：清理冗余代码，统一编码属性获取路径，简化初始化逻辑，提高代码可读性和维护性。", "original_code": "编码属性初始化逻辑复杂，通过条件判断从多个来源获取nativeEncoding，file.encoding处理逻辑包含冗余的getOrDefault和putIfAbsent调用。", "optimized_code": "-        var nativeEncoding = ((raw.propDefault(Raw._file_encoding_NDX) == null)\n-                ? raw.propDefault(Raw._sun_jnu_encoding_NDX)\n-                : raw.propDefault(Raw._file_encoding_NDX));\n+        String nativeEncoding = raw.propDefault(Raw._native_encoding_NDX);\n\n-        var fileEncoding = props.getOrDefault(\"file.encoding\", \"UTF-8\");\n-        if (\"COMPAT\".equals(fileEncoding)) {\n+        String fileEncoding = props.get(\"file.encoding\");\n+        if (fileEncoding == null) {\n+            put(props, \"file.encoding\", \"UTF-8\");\n+        } else if (\"COMPAT\".equals(fileEncoding)) {\n             put(props, \"file.encoding\", nativeEncoding);\n-        } else {\n-            putIfAbsent(props, \"file.encoding\", fileEncoding);\n         }", "source_url": "https://github.com/openjdk/riscv-port/commit/83c7d3bbe860656ee403fa29df6a9e0aae962839", "code_v0_no_empty_lines": "编码属性初始化逻辑复杂，通过条件判断从多个来源获取nativeEncoding，file.encoding处理逻辑包含冗余的getOrDefault和putIfAbsent调用。", "code_v1_no_empty_lines": "-        var nativeEncoding = ((raw.propDefault(Raw._file_encoding_NDX) == null)\n-                ? raw.propDefault(Raw._sun_jnu_encoding_NDX)\n-                : raw.propDefault(Raw._file_encoding_NDX));\n+        String nativeEncoding = raw.propDefault(Raw._native_encoding_NDX);\n\n-        var fileEncoding = props.getOrDefault(\"file.encoding\", \"UTF-8\");\n-        if (\"COMPAT\".equals(fileEncoding)) {\n+        String fileEncoding = props.get(\"file.encoding\");\n+        if (fileEncoding == null) {\n+            put(props, \"file.encoding\", \"UTF-8\");\n+        } else if (\"COMPAT\".equals(fileEncoding)) {\n             put(props, \"file.encoding\", nativeEncoding);\n-        } else {\n-            putIfAbsent(props, \"file.encoding\", fileEncoding);\n         }", "target": "-        var nativeEncoding = ((raw.propDefault(Raw._file_encoding_NDX) == null)\n-                ? raw.propDefault(Raw._sun_jnu_encoding_NDX)\n-                : raw.propDefault(Raw._file_encoding_NDX));\n+        String nativeEncoding = raw.propDefault(Raw._native_encoding_NDX);\n\n-        var fileEncoding = props.getOrDefault(\"file.encoding\", \"UTF-8\");\n-        if (\"COMPAT\".equals(fileEncoding)) {\n+        String fileEncoding = props.get(\"file.encoding\");\n+        if (fileEncoding == null) {\n+            put(props, \"file.encoding\", \"UTF-8\");\n+        } else if (\"COMPAT\".equals(fileEncoding)) {\n             put(props, \"file.encoding\", nativeEncoding);\n-        } else {\n-            putIfAbsent(props, \"file.encoding\", fileEncoding);\n         }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：编码属性初始化逻辑复杂，通过条件判断从多个来源获取nativeEncoding，file.encoding处理逻辑包含冗余的getOrDefault和putIfAbsent调用。优化后：引入_native_encoding_NDX统一获取nativeEncoding，简化file.encoding处理逻辑，直接检查null值并设置默认值UTF-8，COMPAT情况直接替换为nativeEncoding。优化思路：清理冗余代码，统一编码属性获取路径，简化初始化逻辑，提高代码可读性和维护性。"}
{"id": 440, "source": "riscv-dataset-excel", "optimization_type": "缓存优化+内存优化", "optimization_description": "优化前：MethodTypeForm.LF_INTERPRET缓存整个LambdaForm对象，包含不必要的元数据开销，且需要创建虚拟的空白LambdaForm作为模板。优化后：改为直接缓存MemberName（方法入口点），移除了LF_INTERPRET枚举和createBlankForType方法，新增interpretEntry软引用字段和对应的缓存方法。优化思路：减少内存占用和对象创建开销，通过缓存更轻量的MemberName而非完整的LambdaForm来提升Lambda解释器入口点的访问性能。", "original_code": "MethodTypeForm.LF_INTERPRET缓存整个LambdaForm对象，包含不必要的元数据开销，且需要创建虚拟的空白LambdaForm作为模板。", "optimized_code": "- private static LambdaForm createBlankForType(MethodType mt) {\n-     // Make a dummy blank lambda form.\n-     // It is used as a template for managing the invocation of similar forms that are non-empty.\n-     // Called only from getPreparedForm.\n-     LambdaForm form = new LambdaForm(0, 0, DEFAULT_FORCE_INLINE, DEFAULT_CUSTOMIZED, new Name[0], Kind.GENERIC);\n-     return form;\n- }\n\n- LambdaForm prep = mtype.form().cachedLambdaForm(MethodTypeForm.LF_INTERPRET);\n- if (prep == null) {\n+ MethodTypeForm form = mtype.form();\n+ MemberName entry = form.cachedInterpretEntry();\n+ if (entry == null) {\n      assert (isValidSignature(basicTypeSignature()));\n-     prep = LambdaForm.createBlankForType(mtype);\n-     prep.vmentry = InvokerBytecodeGenerator.generateLambdaFormInterpreterEntryPoint(mtype);\n-     prep = mtype.form().setCachedLambdaForm(MethodTypeForm.LF_INTERPRET, prep);\n+     entry = InvokerBytecodeGenerator.generateLambdaFormInterpreterEntryPoint(mtype);\n+     entry = form.setCachedInterpretEntry(entry);\n  }\n- this.vmentry = prep.vmentry;\n+ this.vmentry = entry;\n\n+ private SoftReference<MemberName> interpretEntry;\n- LF_INTERPRET               =  6,  // LF interpreter\n\n+ public MemberName cachedInterpretEntry() {\n+     return (interpretEntry == null) ? null : interpretEntry.get();\n+ }\n+ public synchronized MemberName setCachedInterpretEntry(MemberName mn) {\n+     MemberName prev = cachedInterpretEntry();\n+     if (prev != null) {\n+         return prev;\n+     }\n+     this.interpretEntry = new SoftReference<>(mn);\n+     return mn;\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/dc249be2474d8711ca6e92ec139b4b6f0aa92e6e", "code_v0_no_empty_lines": "MethodTypeForm.LF_INTERPRET缓存整个LambdaForm对象，包含不必要的元数据开销，且需要创建虚拟的空白LambdaForm作为模板。", "code_v1_no_empty_lines": "- private static LambdaForm createBlankForType(MethodType mt) {\n-     // Make a dummy blank lambda form.\n-     // It is used as a template for managing the invocation of similar forms that are non-empty.\n-     // Called only from getPreparedForm.\n-     LambdaForm form = new LambdaForm(0, 0, DEFAULT_FORCE_INLINE, DEFAULT_CUSTOMIZED, new Name[0], Kind.GENERIC);\n-     return form;\n- }\n\n- LambdaForm prep = mtype.form().cachedLambdaForm(MethodTypeForm.LF_INTERPRET);\n- if (prep == null) {\n+ MethodTypeForm form = mtype.form();\n+ MemberName entry = form.cachedInterpretEntry();\n+ if (entry == null) {\n      assert (isValidSignature(basicTypeSignature()));\n-     prep = LambdaForm.createBlankForType(mtype);\n-     prep.vmentry = InvokerBytecodeGenerator.generateLambdaFormInterpreterEntryPoint(mtype);\n-     prep = mtype.form().setCachedLambdaForm(MethodTypeForm.LF_INTERPRET, prep);\n+     entry = InvokerBytecodeGenerator.generateLambdaFormInterpreterEntryPoint(mtype);\n+     entry = form.setCachedInterpretEntry(entry);\n  }\n- this.vmentry = prep.vmentry;\n+ this.vmentry = entry;\n\n+ private SoftReference<MemberName> interpretEntry;\n- LF_INTERPRET               =  6,  // LF interpreter\n\n+ public MemberName cachedInterpretEntry() {\n+     return (interpretEntry == null) ? null : interpretEntry.get();\n+ }\n+ public synchronized MemberName setCachedInterpretEntry(MemberName mn) {\n+     MemberName prev = cachedInterpretEntry();\n+     if (prev != null) {\n+         return prev;\n+     }\n+     this.interpretEntry = new SoftReference<>(mn);\n+     return mn;\n+ }", "target": "- private static LambdaForm createBlankForType(MethodType mt) {\n-     // Make a dummy blank lambda form.\n-     // It is used as a template for managing the invocation of similar forms that are non-empty.\n-     // Called only from getPreparedForm.\n-     LambdaForm form = new LambdaForm(0, 0, DEFAULT_FORCE_INLINE, DEFAULT_CUSTOMIZED, new Name[0], Kind.GENERIC);\n-     return form;\n- }\n\n- LambdaForm prep = mtype.form().cachedLambdaForm(MethodTypeForm.LF_INTERPRET);\n- if (prep == null) {\n+ MethodTypeForm form = mtype.form();\n+ MemberName entry = form.cachedInterpretEntry();\n+ if (entry == null) {\n      assert (isValidSignature(basicTypeSignature()));\n-     prep = LambdaForm.createBlankForType(mtype);\n-     prep.vmentry = InvokerBytecodeGenerator.generateLambdaFormInterpreterEntryPoint(mtype);\n-     prep = mtype.form().setCachedLambdaForm(MethodTypeForm.LF_INTERPRET, prep);\n+     entry = InvokerBytecodeGenerator.generateLambdaFormInterpreterEntryPoint(mtype);\n+     entry = form.setCachedInterpretEntry(entry);\n  }\n- this.vmentry = prep.vmentry;\n+ this.vmentry = entry;\n\n+ private SoftReference<MemberName> interpretEntry;\n- LF_INTERPRET               =  6,  // LF interpreter\n\n+ public MemberName cachedInterpretEntry() {\n+     return (interpretEntry == null) ? null : interpretEntry.get();\n+ }\n+ public synchronized MemberName setCachedInterpretEntry(MemberName mn) {\n+     MemberName prev = cachedInterpretEntry();\n+     if (prev != null) {\n+         return prev;\n+     }\n+     this.interpretEntry = new SoftReference<>(mn);\n+     return mn;\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：MethodTypeForm.LF_INTERPRET缓存整个LambdaForm对象，包含不必要的元数据开销，且需要创建虚拟的空白LambdaForm作为模板。优化后：改为直接缓存MemberName（方法入口点），移除了LF_INTERPRET枚举和createBlankForType方法，新增interpretEntry软引用字段和对应的缓存方法。优化思路：减少内存占用和对象创建开销，通过缓存更轻量的MemberName而非完整的LambdaForm来提升Lambda解释器入口点的访问性能。"}
{"id": 441, "source": "riscv-dataset-excel", "optimization_type": "算法优化+性能优化", "optimization_description": "优化前：使用牛顿迭代法计算BigDecimal平方根，涉及BigDecimal到double的转换和多次迭代，计算开销较大。优化后：直接调用BigInteger.sqrt()方法计算平方根，利用底层优化的整数平方根算法，避免了类型转换和迭代开销。优化思路：利用Java 9+中BigInteger.sqrt()的高效实现，简化算法流程，提高计算性能。", "original_code": "使用牛顿迭代法计算BigDecimal平方根，涉及BigDecimal到double的转换和多次迭代，计算开销较大。", "optimized_code": "- // 使用牛顿迭代法计算平方根\n+ // 使用BigInteger.sqrt()计算平方根\n- BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);\n- // 使用Math.sqrt获取初始猜测值进行牛顿迭代\n+ BigInteger[] sqrtRem = stripped.unscaledValue().sqrtAndRemainder();\n+ result = new BigDecimal(sqrtRem[0], strippedScale >> 1);", "source_url": "https://github.com/openjdk/riscv-port/commit/c4c3edfa964ef504f12971c5deef7c7355bdf325", "code_v0_no_empty_lines": "使用牛顿迭代法计算BigDecimal平方根，涉及BigDecimal到double的转换和多次迭代，计算开销较大。", "code_v1_no_empty_lines": "- // 使用牛顿迭代法计算平方根\n+ // 使用BigInteger.sqrt()计算平方根\n- BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);\n- // 使用Math.sqrt获取初始猜测值进行牛顿迭代\n+ BigInteger[] sqrtRem = stripped.unscaledValue().sqrtAndRemainder();\n+ result = new BigDecimal(sqrtRem[0], strippedScale >> 1);", "target": "- // 使用牛顿迭代法计算平方根\n+ // 使用BigInteger.sqrt()计算平方根\n- BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);\n- // 使用Math.sqrt获取初始猜测值进行牛顿迭代\n+ BigInteger[] sqrtRem = stripped.unscaledValue().sqrtAndRemainder();\n+ result = new BigDecimal(sqrtRem[0], strippedScale >> 1);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用牛顿迭代法计算BigDecimal平方根，涉及BigDecimal到double的转换和多次迭代，计算开销较大。优化后：直接调用BigInteger.sqrt()方法计算平方根，利用底层优化的整数平方根算法，避免了类型转换和迭代开销。优化思路：利用Java 9+中BigInteger.sqrt()的高效实现，简化算法流程，提高计算性能。"}
{"id": 442, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：缺少对Float16（半精度浮点数）操作的向量化支持，相关计算只能使用标量指令执行。优化后：为Float16操作添加了AVX-512 FP16指令支持，包括evcmpph等向量比较指令，并更新了多个宏汇编函数以支持Float16向量操作。优化思路：利用现代CPU的AVX-512 FP16扩展，通过SIMD指令并行处理多个Float16数据，显著提升半精度浮点运算的性能，特别是在机器学习、图形处理等需要大量半精度计算的场景中。", "original_code": "缺少对Float16（半精度浮点数）操作的向量化支持，相关计算只能使用标量指令执行。", "optimized_code": "+void Assembler::evcmpph(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src,\n+                        ComparisonPredicateFP comparison, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0xC2, (0xC0 | encode), comparison);\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/9a3f9997b68a1f64e53b9711b878fb073c3c9b90", "code_v0_no_empty_lines": "缺少对Float16（半精度浮点数）操作的向量化支持，相关计算只能使用标量指令执行。", "code_v1_no_empty_lines": "+void Assembler::evcmpph(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src,\n+                        ComparisonPredicateFP comparison, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0xC2, (0xC0 | encode), comparison);\n+}", "target": "+void Assembler::evcmpph(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src,\n+                        ComparisonPredicateFP comparison, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(VM_Version::supports_avx512vl() || vector_len == Assembler::AVX_512bit, \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0xC2, (0xC0 | encode), comparison);\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：缺少对Float16（半精度浮点数）操作的向量化支持，相关计算只能使用标量指令执行。优化后：为Float16操作添加了AVX-512 FP16指令支持，包括evcmpph等向量比较指令，并更新了多个宏汇编函数以支持Float16向量操作。优化思路：利用现代CPU的AVX-512 FP16扩展，通过SIMD指令并行处理多个Float16数据，显著提升半精度浮点运算的性能，特别是在机器学习、图形处理等需要大量半精度计算的场景中。"}
{"id": 443, "source": "riscv-dataset-excel", "optimization_type": "SIMD指令集优化", "optimization_description": "优化前：ML-DSA（Dilithium）算法在Java中通过纯软件实现，性能受限于标量指令执行效率。优化后：新增AVX-512指令集硬件加速实现，通过新增stubGenerator_x86_64_dilithium.cpp文件实现Dilithium算法的向量化计算，包括Montgomery乘法、NTT变换等核心操作。优化思路：利用AVX-512的512位向量寄存器（如xmm28-xmm31）和SIMD指令并行处理16个32位整数，通过预计算常量表（dilithiumAvx512Consts）和置换表（dilithiumAvx512Perms）减少运行时计算开销，显著提升ML-DSA算法的签名/验证性能。", "original_code": "ML-DSA（Dilithium）算法在Java中通过纯软件实现，性能受限于标量指令执行效率。", "optimized_code": "diff --git a/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp b/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp\nindex 9fcb044b09a..b480c78f79d 100644\n--- a/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp\n+++ b/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp\n@@ -4204,6 +4204,8 @@ void StubGenerator::generate_compiler_stubs() {\n \n   generate_chacha_stubs();\n \n+  generate_dilithium_stubs();\n+\n   generate_sha3_stubs();\n \n   // data cache line writeback\n--- /dev/null\n+++ b/src/hotspot/cpu/x86/stubGenerator_x86_64_dilithium.cpp\n@@ -0,0 +1,1034 @@\n+/*\n+ * Copyright (c) 2025, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#include \"asm/assembler.hpp\"\n+#include \"asm/assembler.inline.hpp\"\n+#include \"runtime/stubRoutines.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+#define __ _masm->", "source_url": "https://github.com/openjdk/riscv-port/commit/e87ff328d5cc66454213dee44cf2faeb0e76262f", "code_v0_no_empty_lines": "ML-DSA（Dilithium）算法在Java中通过纯软件实现，性能受限于标量指令执行效率。", "code_v1_no_empty_lines": "diff --git a/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp b/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp\nindex 9fcb044b09a..b480c78f79d 100644\n--- a/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp\n+++ b/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp\n@@ -4204,6 +4204,8 @@ void StubGenerator::generate_compiler_stubs() {\n \n   generate_chacha_stubs();\n \n+  generate_dilithium_stubs();\n+\n   generate_sha3_stubs();\n \n   // data cache line writeback\n--- /dev/null\n+++ b/src/hotspot/cpu/x86/stubGenerator_x86_64_dilithium.cpp\n@@ -0,0 +1,1034 @@\n+/*\n+ * Copyright (c) 2025, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#include \"asm/assembler.hpp\"\n+#include \"asm/assembler.inline.hpp\"\n+#include \"runtime/stubRoutines.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+#define __ _masm->", "target": "diff --git a/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp b/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp\nindex 9fcb044b09a..b480c78f79d 100644\n--- a/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp\n+++ b/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp\n@@ -4204,6 +4204,8 @@ void StubGenerator::generate_compiler_stubs() {\n \n   generate_chacha_stubs();\n \n+  generate_dilithium_stubs();\n+\n   generate_sha3_stubs();\n \n   // data cache line writeback\n--- /dev/null\n+++ b/src/hotspot/cpu/x86/stubGenerator_x86_64_dilithium.cpp\n@@ -0,0 +1,1034 @@\n+/*\n+ * Copyright (c) 2025, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#include \"asm/assembler.hpp\"\n+#include \"asm/assembler.inline.hpp\"\n+#include \"runtime/stubRoutines.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+#define __ _masm->", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ML-DSA（Dilithium）算法在Java中通过纯软件实现，性能受限于标量指令执行效率。优化后：新增AVX-512指令集硬件加速实现，通过新增stubGenerator_x86_64_dilithium.cpp文件实现Dilithium算法的向量化计算，包括Montgomery乘法、NTT变换等核心操作。优化思路：利用AVX-512的512位向量寄存器（如xmm28-xmm31）和SIMD指令并行处理16个32位整数，通过预计算常量表（dilithiumAvx512Consts）和置换表（dilithiumAvx512Perms）减少运行时计算开销，显著提升ML-DSA算法的签名/验证性能。"}
{"id": 444, "source": "riscv-dataset-excel", "optimization_type": "线程调度优化+延迟任务处理优化", "optimization_description": "优化前：虚拟线程使用独立的ScheduledThreadPoolExecutor数组处理延迟任务，通过线程ID哈希选择执行器，存在额外开销和资源竞争。优化后：当使用默认ForkJoinPool调度器时，直接复用FJP的延迟任务处理能力；使用自定义调度器时，通过新的DelayedTaskSchedulers类处理。优化思路：减少中间层，利用FJP原生延迟任务支持，降低延迟任务调度开销，提高虚拟线程park/sleep等定时操作的性能。", "original_code": "虚拟线程使用独立的ScheduledThreadPoolExecutor数组处理延迟任务，通过线程ID哈希选择执行器，存在额外开销和资源竞争。", "optimized_code": "- private static final ScheduledExecutorService[] DELAYED_TASK_SCHEDULERS = createDelayedTaskSchedulers();\n- private static Future<?> schedule(Runnable command, long delay, TimeUnit unit) {\n    long tid = Thread.currentThread().threadId();\n    int index = (int) tid & (DELAYED_TASK_SCHEDULERS.length - 1);\n    return DELAYED_TASK_SCHEDULERS[index].schedule(command, delay, unit);\n  }\n+ private Future<?> schedule(Runnable command, long delay, TimeUnit unit) {\n    if (scheduler instanceof ForkJoinPool pool) {\n        return pool.schedule(command, delay, unit);\n    } else {\n        return DelayedTaskSchedulers.schedule(command, delay, unit);\n    }\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/6c93ad42f38b49ea96155340c4b6bbedfcef2a90", "code_v0_no_empty_lines": "虚拟线程使用独立的ScheduledThreadPoolExecutor数组处理延迟任务，通过线程ID哈希选择执行器，存在额外开销和资源竞争。", "code_v1_no_empty_lines": "- private static final ScheduledExecutorService[] DELAYED_TASK_SCHEDULERS = createDelayedTaskSchedulers();\n- private static Future<?> schedule(Runnable command, long delay, TimeUnit unit) {\n    long tid = Thread.currentThread().threadId();\n    int index = (int) tid & (DELAYED_TASK_SCHEDULERS.length - 1);\n    return DELAYED_TASK_SCHEDULERS[index].schedule(command, delay, unit);\n  }\n+ private Future<?> schedule(Runnable command, long delay, TimeUnit unit) {\n    if (scheduler instanceof ForkJoinPool pool) {\n        return pool.schedule(command, delay, unit);\n    } else {\n        return DelayedTaskSchedulers.schedule(command, delay, unit);\n    }\n  }", "target": "- private static final ScheduledExecutorService[] DELAYED_TASK_SCHEDULERS = createDelayedTaskSchedulers();\n- private static Future<?> schedule(Runnable command, long delay, TimeUnit unit) {\n    long tid = Thread.currentThread().threadId();\n    int index = (int) tid & (DELAYED_TASK_SCHEDULERS.length - 1);\n    return DELAYED_TASK_SCHEDULERS[index].schedule(command, delay, unit);\n  }\n+ private Future<?> schedule(Runnable command, long delay, TimeUnit unit) {\n    if (scheduler instanceof ForkJoinPool pool) {\n        return pool.schedule(command, delay, unit);\n    } else {\n        return DelayedTaskSchedulers.schedule(command, delay, unit);\n    }\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：虚拟线程使用独立的ScheduledThreadPoolExecutor数组处理延迟任务，通过线程ID哈希选择执行器，存在额外开销和资源竞争。优化后：当使用默认ForkJoinPool调度器时，直接复用FJP的延迟任务处理能力；使用自定义调度器时，通过新的DelayedTaskSchedulers类处理。优化思路：减少中间层，利用FJP原生延迟任务支持，降低延迟任务调度开销，提高虚拟线程park/sleep等定时操作的性能。"}
{"id": 445, "source": "riscv-dataset-excel", "optimization_type": "内存模型优化", "optimization_description": "优化前：使用默认的原子操作内存顺序（通常是memory_order_seq_cst），在inc/dec操作和读取_items_count时产生不必要的内存屏障开销。优化后：1. inc_items_count()和dec_items_count()使用memory_order_relaxed，仅保证原子性，不保证内存顺序，减少同步开销。2. get_load_factor()通过Atomic::load显式读取_items_count，避免直接访问共享变量可能的内存可见性问题。优化思路：针对ObjectMonitorTable的items计数操作，这些计数更新不需要严格的全局内存顺序保证，使用relaxed内存顺序可提升并发性能，同时通过原子加载确保读取的一致性。", "original_code": "使用默认的原子操作内存顺序（通常是memory_order_seq_cst），在inc/dec操作和读取_items_count时产生不必要的内存屏障开销。", "optimized_code": "-    Atomic::inc(&_items_count);\n+    Atomic::inc(&_items_count, memory_order_relaxed);\n-    Atomic::dec(&_items_count);\n+    Atomic::dec(&_items_count, memory_order_relaxed);\n-    return (double)_items_count / (double)_table_size;\n+    size_t count = Atomic::load(&_items_count);\n+    return (double)count / (double)_table_size;", "source_url": "https://github.com/openjdk/riscv-port/commit/da462cf2255f55c1059f9d9bf479231408a72b55", "code_v0_no_empty_lines": "使用默认的原子操作内存顺序（通常是memory_order_seq_cst），在inc/dec操作和读取_items_count时产生不必要的内存屏障开销。", "code_v1_no_empty_lines": "-    Atomic::inc(&_items_count);\n+    Atomic::inc(&_items_count, memory_order_relaxed);\n-    Atomic::dec(&_items_count);\n+    Atomic::dec(&_items_count, memory_order_relaxed);\n-    return (double)_items_count / (double)_table_size;\n+    size_t count = Atomic::load(&_items_count);\n+    return (double)count / (double)_table_size;", "target": "-    Atomic::inc(&_items_count);\n+    Atomic::inc(&_items_count, memory_order_relaxed);\n-    Atomic::dec(&_items_count);\n+    Atomic::dec(&_items_count, memory_order_relaxed);\n-    return (double)_items_count / (double)_table_size;\n+    size_t count = Atomic::load(&_items_count);\n+    return (double)count / (double)_table_size;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用默认的原子操作内存顺序（通常是memory_order_seq_cst），在inc/dec操作和读取_items_count时产生不必要的内存屏障开销。优化后：1. inc_items_count()和dec_items_count()使用memory_order_relaxed，仅保证原子性，不保证内存顺序，减少同步开销。2. get_load_factor()通过Atomic::load显式读取_items_count，避免直接访问共享变量可能的内存可见性问题。优化思路：针对ObjectMonitorTable的items计数操作，这些计数更新不需要严格的全局内存顺序保证，使用relaxed内存顺序可提升并发性能，同时通过原子加载确保读取的一致性。"}
{"id": 446, "source": "riscv-dataset-excel", "optimization_type": "内存布局优化", "optimization_description": "优化前：类实例字段布局固定为原始类型字段在前、对象引用字段在后，导致每个类都生成独立的oop map条目，增加了内存占用。优化后：通过检测父类是否以对象引用字段结尾，动态调整字段布局顺序。如果父类以对象引用结尾，则子类将对象引用字段放在前面，这样父类和子类的对象引用字段可以合并到同一个oop map条目中。优化思路是减少oop map条目的数量，从而降低内存占用，特别是对于继承层次较深的类效果更明显。", "original_code": "类实例字段布局固定为原始类型字段在前、对象引用字段在后，导致每个类都生成独立的oop map条目，增加了内存占用。", "optimized_code": "if (_super_ends_with_oop) {\n    _layout->add(_root_group->oop_fields());\n    _layout->add(_root_group->primitive_fields());\n  } else {\n    _layout->add(_root_group->primitive_fields());\n    _layout->add(_root_group->oop_fields());\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/743d1c64c29118b15897b3c676919353ced467f5", "code_v0_no_empty_lines": "类实例字段布局固定为原始类型字段在前、对象引用字段在后，导致每个类都生成独立的oop map条目，增加了内存占用。", "code_v1_no_empty_lines": "if (_super_ends_with_oop) {\n    _layout->add(_root_group->oop_fields());\n    _layout->add(_root_group->primitive_fields());\n  } else {\n    _layout->add(_root_group->primitive_fields());\n    _layout->add(_root_group->oop_fields());\n  }", "target": "if (_super_ends_with_oop) {\n    _layout->add(_root_group->oop_fields());\n    _layout->add(_root_group->primitive_fields());\n  } else {\n    _layout->add(_root_group->primitive_fields());\n    _layout->add(_root_group->oop_fields());\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：类实例字段布局固定为原始类型字段在前、对象引用字段在后，导致每个类都生成独立的oop map条目，增加了内存占用。优化后：通过检测父类是否以对象引用字段结尾，动态调整字段布局顺序。如果父类以对象引用结尾，则子类将对象引用字段放在前面，这样父类和子类的对象引用字段可以合并到同一个oop map条目中。优化思路是减少oop map条目的数量，从而降低内存占用，特别是对于继承层次较深的类效果更明显。"}
{"id": 447, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化+查找性能优化", "optimization_description": "优化前使用GrowableArray进行二分查找（O(log n)），优化后使用基于哈希表的JfrSet实现（O(1)平均查找）。关键修改包括：1) 将GrowableArray替换为JfrCHeapTraceIdSet/JfrResourceAreaTraceIdSet；2) 将JfrPredicate/JfrMutablePredicate调用替换为直接的contains()/add()方法调用；3) 移除排序操作（JfrKlassUnloading::sort()）。优化思路是通过哈希表替代二分查找，显著提升集合操作的性能，特别是在频繁插入和查找的场景中。", "original_code": "// No original code extracted from description\n", "optimized_code": "- static GrowableArray<traceid>* unloaded_thread_id_set = nullptr;\n+ static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n- return JfrPredicate<traceid, compare_traceid>::test(unloaded_thread_id_set, tid);\n+ return unloaded_thread_id_set->contains(tid);\n- JfrMutablePredicate<traceid, compare_traceid>::test(unloaded_thread_id_set, tid);\n+ unloaded_thread_id_set->add(tid);", "source_url": "https://github.com/openjdk/riscv-port/commit/257f817c7fca1e8cdb0fec0e18ab9c07b19b1d13", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- static GrowableArray<traceid>* unloaded_thread_id_set = nullptr;\n+ static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n- return JfrPredicate<traceid, compare_traceid>::test(unloaded_thread_id_set, tid);\n+ return unloaded_thread_id_set->contains(tid);\n- JfrMutablePredicate<traceid, compare_traceid>::test(unloaded_thread_id_set, tid);\n+ unloaded_thread_id_set->add(tid);", "target": "- static GrowableArray<traceid>* unloaded_thread_id_set = nullptr;\n+ static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n- return JfrPredicate<traceid, compare_traceid>::test(unloaded_thread_id_set, tid);\n+ return unloaded_thread_id_set->contains(tid);\n- JfrMutablePredicate<traceid, compare_traceid>::test(unloaded_thread_id_set, tid);\n+ unloaded_thread_id_set->add(tid);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用GrowableArray进行二分查找（O(log n)），优化后使用基于哈希表的JfrSet实现（O(1)平均查找）。关键修改包括：1) 将GrowableArray替换为JfrCHeapTraceIdSet/JfrResourceAreaTraceIdSet；2) 将JfrPredicate/JfrMutablePredicate调用替换为直接的contains()/add()方法调用；3) 移除排序操作（JfrKlassUnloading::sort()）。优化思路是通过哈希表替代二分查找，显著提升集合操作的性能，特别是在频繁插入和查找的场景中。"}
{"id": 448, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+内存操作优化", "optimization_description": "优化前：Unsafe::setMemory操作在PPC64架构上使用通用Java实现，性能较低。优化后：为PPC64架构实现Unsafe::setMemory的汇编级intrinsic，通过检查内存对齐情况，分别使用8字节、4字节、2字节和1字节的原子循环填充，利用rldimi指令扩展字节值，使用store_sized_value指令高效存储。优化思路：针对特定架构实现底层硬件指令优化，减少函数调用开销，利用对齐访问提升内存操作性能。", "original_code": "Unsafe::setMemory操作在PPC64架构上使用通用Java实现，性能较低。", "optimized_code": "address generate_unsafe_setmemory(address unsafe_byte_fill) {\n    __ align(CodeEntryAlignment);\n    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n    address start = __ function_entry();\n\n    // bump this on entry, not on exit:\n    // inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n\n    {\n      Label L_fill8Bytes, L_fill4Bytes, L_fillBytes;\n\n      const Register dest = R3_ARG1;\n      const Register size = R4_ARG2;\n      const Register byteVal = R5_ARG3;\n      const Register rScratch1 = R6;\n\n      // fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n\n      // Check for pointer & size alignment\n      __ orr(rScratch1, dest, size);\n\n      __ andi_(R0, rScratch1, 7);\n      __ beq(CR0, L_fill8Bytes);\n\n      __ andi_(R0, rScratch1, 3);\n      __ beq(CR0, L_fill4Bytes);\n\n      __ andi_(R0, rScratch1, 1);\n      __ bne(CR0, L_fillBytes);\n\n      // Mark remaining code as such which performs Unsafe accesses.\n      UnsafeMemoryAccessMark umam(this, true, false);\n\n      // At this point, we know the lower bit of size is zero and a\n      // multiple of 2\n      do_setmemory_atomic_loop(2, dest, size, byteVal, _masm);\n\n      __ align(32);\n      __ bind(L_fill8Bytes);\n      // At this point, we know the lower 3 bits of size are zero and a\n      // multiple of 8\n      do_setmemory_atomic_loop(8, dest, size, byteVal, _masm);\n\n      __ align(32);\n      __ bind(L_fill4Bytes);\n      // At this point, we know the lower 2 bits of size are zero and a\n      // multiple of 4\n      do_setmemory_atomic_loop(4, dest, size, byteVal, _masm);\n\n      __ align(32);\n      __ bind(L_fillBytes);\n      do_setmemory_atomic_loop(1, dest, size, byteVal, _masm);\n    }\n\n    return start;\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/e266eba40131bb97c392c8c87551d28e74c4764a", "code_v0_no_empty_lines": "Unsafe::setMemory操作在PPC64架构上使用通用Java实现，性能较低。", "code_v1_no_empty_lines": "address generate_unsafe_setmemory(address unsafe_byte_fill) {\n    __ align(CodeEntryAlignment);\n    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n    address start = __ function_entry();\n\n    // bump this on entry, not on exit:\n    // inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n\n    {\n      Label L_fill8Bytes, L_fill4Bytes, L_fillBytes;\n\n      const Register dest = R3_ARG1;\n      const Register size = R4_ARG2;\n      const Register byteVal = R5_ARG3;\n      const Register rScratch1 = R6;\n\n      // fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n\n      // Check for pointer & size alignment\n      __ orr(rScratch1, dest, size);\n\n      __ andi_(R0, rScratch1, 7);\n      __ beq(CR0, L_fill8Bytes);\n\n      __ andi_(R0, rScratch1, 3);\n      __ beq(CR0, L_fill4Bytes);\n\n      __ andi_(R0, rScratch1, 1);\n      __ bne(CR0, L_fillBytes);\n\n      // Mark remaining code as such which performs Unsafe accesses.\n      UnsafeMemoryAccessMark umam(this, true, false);\n\n      // At this point, we know the lower bit of size is zero and a\n      // multiple of 2\n      do_setmemory_atomic_loop(2, dest, size, byteVal, _masm);\n\n      __ align(32);\n      __ bind(L_fill8Bytes);\n      // At this point, we know the lower 3 bits of size are zero and a\n      // multiple of 8\n      do_setmemory_atomic_loop(8, dest, size, byteVal, _masm);\n\n      __ align(32);\n      __ bind(L_fill4Bytes);\n      // At this point, we know the lower 2 bits of size are zero and a\n      // multiple of 4\n      do_setmemory_atomic_loop(4, dest, size, byteVal, _masm);\n\n      __ align(32);\n      __ bind(L_fillBytes);\n      do_setmemory_atomic_loop(1, dest, size, byteVal, _masm);\n    }\n\n    return start;\n  }", "target": "address generate_unsafe_setmemory(address unsafe_byte_fill) {\n    __ align(CodeEntryAlignment);\n    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n    address start = __ function_entry();\n\n    // bump this on entry, not on exit:\n    // inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n\n    {\n      Label L_fill8Bytes, L_fill4Bytes, L_fillBytes;\n\n      const Register dest = R3_ARG1;\n      const Register size = R4_ARG2;\n      const Register byteVal = R5_ARG3;\n      const Register rScratch1 = R6;\n\n      // fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n\n      // Check for pointer & size alignment\n      __ orr(rScratch1, dest, size);\n\n      __ andi_(R0, rScratch1, 7);\n      __ beq(CR0, L_fill8Bytes);\n\n      __ andi_(R0, rScratch1, 3);\n      __ beq(CR0, L_fill4Bytes);\n\n      __ andi_(R0, rScratch1, 1);\n      __ bne(CR0, L_fillBytes);\n\n      // Mark remaining code as such which performs Unsafe accesses.\n      UnsafeMemoryAccessMark umam(this, true, false);\n\n      // At this point, we know the lower bit of size is zero and a\n      // multiple of 2\n      do_setmemory_atomic_loop(2, dest, size, byteVal, _masm);\n\n      __ align(32);\n      __ bind(L_fill8Bytes);\n      // At this point, we know the lower 3 bits of size are zero and a\n      // multiple of 8\n      do_setmemory_atomic_loop(8, dest, size, byteVal, _masm);\n\n      __ align(32);\n      __ bind(L_fill4Bytes);\n      // At this point, we know the lower 2 bits of size are zero and a\n      // multiple of 4\n      do_setmemory_atomic_loop(4, dest, size, byteVal, _masm);\n\n      __ align(32);\n      __ bind(L_fillBytes);\n      do_setmemory_atomic_loop(1, dest, size, byteVal, _masm);\n    }\n\n    return start;\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Unsafe::setMemory操作在PPC64架构上使用通用Java实现，性能较低。优化后：为PPC64架构实现Unsafe::setMemory的汇编级intrinsic，通过检查内存对齐情况，分别使用8字节、4字节、2字节和1字节的原子循环填充，利用rldimi指令扩展字节值，使用store_sized_value指令高效存储。优化思路：针对特定架构实现底层硬件指令优化，减少函数调用开销，利用对齐访问提升内存操作性能。"}
{"id": 449, "source": "riscv-dataset-excel", "optimization_type": "字符串处理性能优化", "optimization_description": "优化前：使用StringBuilder进行路径规范化，每次操作都需要创建StringBuilder对象并追加root，然后通过charAt()逐个字符处理路径字符串，最后调用toString()生成结果字符串。\n优化后：改为使用char数组直接操作，预先分配包含root和path的字符数组，通过System.arraycopy()批量复制字符，避免StringBuilder的额外开销和charAt()的边界检查。\n优化思路：减少内存分配和字符访问开销，通过数组操作替代StringBuilder，提高字符串到路径转换的性能，特别是在Windows文件系统路径处理场景下。", "original_code": "使用StringBuilder进行路径规范化，每次操作都需要创建StringBuilder对象并追加root，然后通过charAt()逐个字符处理路径字符串，最后调用toString()生成结果字符串。", "optimized_code": "-    private static String normalize(StringBuilder sb, String path, int off) {\n+    private static String normalize(String root, String path, int pathOff) {\n-        StringBuilder sb = new StringBuilder(input.length());\n-        sb.append(root);\n-        return new Result(type, root, normalize(sb, input, off));\n+        return new Result(type, root, normalize(root, input, off));\n-        return sb.toString();\n+        return new String(result, 0, dstPos);", "source_url": "https://github.com/openjdk/riscv-port/commit/5481021ee64fd457279ea7083be0f977c7ce3e3c", "code_v0_no_empty_lines": "使用StringBuilder进行路径规范化，每次操作都需要创建StringBuilder对象并追加root，然后通过charAt()逐个字符处理路径字符串，最后调用toString()生成结果字符串。", "code_v1_no_empty_lines": "-    private static String normalize(StringBuilder sb, String path, int off) {\n+    private static String normalize(String root, String path, int pathOff) {\n-        StringBuilder sb = new StringBuilder(input.length());\n-        sb.append(root);\n-        return new Result(type, root, normalize(sb, input, off));\n+        return new Result(type, root, normalize(root, input, off));\n-        return sb.toString();\n+        return new String(result, 0, dstPos);", "target": "-    private static String normalize(StringBuilder sb, String path, int off) {\n+    private static String normalize(String root, String path, int pathOff) {\n-        StringBuilder sb = new StringBuilder(input.length());\n-        sb.append(root);\n-        return new Result(type, root, normalize(sb, input, off));\n+        return new Result(type, root, normalize(root, input, off));\n-        return sb.toString();\n+        return new String(result, 0, dstPos);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用StringBuilder进行路径规范化，每次操作都需要创建StringBuilder对象并追加root，然后通过charAt()逐个字符处理路径字符串，最后调用toString()生成结果字符串。\n优化后：改为使用char数组直接操作，预先分配包含root和path的字符数组，通过System.arraycopy()批量复制字符，避免StringBuilder的额外开销和charAt()的边界检查。\n优化思路：减少内存分配和字符访问开销，通过数组操作替代StringBuilder，提高字符串到路径转换的性能，特别是在Windows文件系统路径处理场景下。"}
{"id": 450, "source": "riscv-dataset-excel", "optimization_type": "指令优化+内存屏障优化", "optimization_description": "优化前：在RISC-V架构下，所有内存屏障指令（membar）都会生成对应的fence指令，包括在TSO（Total Store Order）内存模型下不必要的屏障。优化后：1. 在membar函数中增加TSO检查，当UseZtso启用且order_constraint不包含StoreLoad时，直接返回而不生成fence指令（因为TSO已保证这些顺序）。2. 重构membar函数逻辑，将合并检查提前，简化控制流。3. 在riscv.ad中新增unnecessary_membar_rvtso等指令模式，当检测到不必要的屏障时生成空指令（ins_cost(0), size(0)）。优化思路：利用TSO内存模型的特性，消除冗余的内存屏障指令，减少指令数量和执行开销，同时保持程序正确性。", "original_code": "在RISC-V架构下，所有内存屏障指令（membar）都会生成对应的fence指令，包括在TSO（Total Store Order）内存模型下不必要的屏障。", "optimized_code": "void MacroAssembler::membar(uint32_t order_constraint) {\n+  if (UseZtso && ((order_constraint & StoreLoad) != StoreLoad)) {\n+    // TSO allows for stores to be reordered after loads. When the compiler\n+    // generates a fence to disallow that, we are required to generate the\n+    // fence for correctness.\n+    BLOCK_COMMENT(\"elided tso membar\");\n+    return;\n+  }\n\n   address prev = pc() - MacroAssembler::instruction_size;\n   address last = code()->last_insn();\n\n   if (prev == last && (get_membar_kind(prev) & order_constraint) == 0) {\n     // can do this simply by ORing them together.\n     set_membar_kind(prev, get_membar_kind(prev) | order_constraint);\n     BLOCK_COMMENT(\"merged membar\");\n-  } else {\n-    code()->set_last_insn(pc());\n-\n-    uint32_t predecessor = 0;\n-    uint32_t successor = 0;\n-\n-    membar_mask_to_pred_succ(order_constraint, predecessor, successor);\n-    fence(predecessor, successor);\n+    return;\n   }\n+\n+  code()->set_last_insn(pc());\n+  uint32_t predecessor = 0;\n+  uint32_t successor = 0;\n+  membar_mask_to_pred_succ(order_constraint, predecessor, successor);\n+  fence(predecessor, successor);\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/6d9ece73a96dd32fccf4a740205407a76dcd907a", "code_v0_no_empty_lines": "在RISC-V架构下，所有内存屏障指令（membar）都会生成对应的fence指令，包括在TSO（Total Store Order）内存模型下不必要的屏障。", "code_v1_no_empty_lines": "void MacroAssembler::membar(uint32_t order_constraint) {\n+  if (UseZtso && ((order_constraint & StoreLoad) != StoreLoad)) {\n+    // TSO allows for stores to be reordered after loads. When the compiler\n+    // generates a fence to disallow that, we are required to generate the\n+    // fence for correctness.\n+    BLOCK_COMMENT(\"elided tso membar\");\n+    return;\n+  }\n\n   address prev = pc() - MacroAssembler::instruction_size;\n   address last = code()->last_insn();\n\n   if (prev == last && (get_membar_kind(prev) & order_constraint) == 0) {\n     // can do this simply by ORing them together.\n     set_membar_kind(prev, get_membar_kind(prev) | order_constraint);\n     BLOCK_COMMENT(\"merged membar\");\n-  } else {\n-    code()->set_last_insn(pc());\n-\n-    uint32_t predecessor = 0;\n-    uint32_t successor = 0;\n-\n-    membar_mask_to_pred_succ(order_constraint, predecessor, successor);\n-    fence(predecessor, successor);\n+    return;\n   }\n+\n+  code()->set_last_insn(pc());\n+  uint32_t predecessor = 0;\n+  uint32_t successor = 0;\n+  membar_mask_to_pred_succ(order_constraint, predecessor, successor);\n+  fence(predecessor, successor);\n }", "target": "void MacroAssembler::membar(uint32_t order_constraint) {\n+  if (UseZtso && ((order_constraint & StoreLoad) != StoreLoad)) {\n+    // TSO allows for stores to be reordered after loads. When the compiler\n+    // generates a fence to disallow that, we are required to generate the\n+    // fence for correctness.\n+    BLOCK_COMMENT(\"elided tso membar\");\n+    return;\n+  }\n\n   address prev = pc() - MacroAssembler::instruction_size;\n   address last = code()->last_insn();\n\n   if (prev == last && (get_membar_kind(prev) & order_constraint) == 0) {\n     // can do this simply by ORing them together.\n     set_membar_kind(prev, get_membar_kind(prev) | order_constraint);\n     BLOCK_COMMENT(\"merged membar\");\n-  } else {\n-    code()->set_last_insn(pc());\n-\n-    uint32_t predecessor = 0;\n-    uint32_t successor = 0;\n-\n-    membar_mask_to_pred_succ(order_constraint, predecessor, successor);\n-    fence(predecessor, successor);\n+    return;\n   }\n+\n+  code()->set_last_insn(pc());\n+  uint32_t predecessor = 0;\n+  uint32_t successor = 0;\n+  membar_mask_to_pred_succ(order_constraint, predecessor, successor);\n+  fence(predecessor, successor);\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在RISC-V架构下，所有内存屏障指令（membar）都会生成对应的fence指令，包括在TSO（Total Store Order）内存模型下不必要的屏障。优化后：1. 在membar函数中增加TSO检查，当UseZtso启用且order_constraint不包含StoreLoad时，直接返回而不生成fence指令（因为TSO已保证这些顺序）。2. 重构membar函数逻辑，将合并检查提前，简化控制流。3. 在riscv.ad中新增unnecessary_membar_rvtso等指令模式，当检测到不必要的屏障时生成空指令（ins_cost(0), size(0)）。优化思路：利用TSO内存模型的特性，消除冗余的内存屏障指令，减少指令数量和执行开销，同时保持程序正确性。"}
{"id": 451, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+异常处理优化", "optimization_description": "优化前：builtin_throw函数处理异常时，逻辑复杂且内联，包含大量条件判断和重复代码，特别是对于Math.*Exact等频繁溢出的情况，容易导致deoptimization和re-execution循环。优化后：重构builtin_throw函数，提取热异常判断逻辑到独立的is_builtin_throw_hot函数，增加新重载版本处理预构建异常对象，并添加allow_too_many_traps参数控制陷阱处理。优化思路：通过代码重构和逻辑分离，减少重复代码，提高异常处理路径的清晰度和性能，避免在频繁溢出场景下陷入deoptimization循环，提升C2编译器对Math.*Exact等精确运算的优化效果。", "original_code": "builtin_throw函数处理异常时，逻辑复杂且内联，包含大量条件判断和重复代码，特别是对于Math.*Exact等频繁溢出的情况，容易导致deoptimization和re-execution循环。", "optimized_code": "- bool must_throw = true;\n- bool treat_throw_as_hot = false;\n- ciMethodData* md = method()->method_data();\n- if (ProfileTraps) {\n-   if (too_many_traps(reason)) {\n-     treat_throw_as_hot = true;\n-   }\n-   if (C->trap_count(reason) != 0\n-       && method()->method_data()->trap_count(reason) != 0\n-       && has_exception_handler()) {\n-       treat_throw_as_hot = true;\n-   }\n- }\n+ void GraphKit::builtin_throw(Deoptimization::DeoptReason reason,\n+                              ciInstance* ex_obj,\n+                              bool allow_too_many_traps) {\n+ bool GraphKit::is_builtin_throw_hot(Deoptimization::DeoptReason reason) {\n+   if (ProfileTraps) {\n+     if (too_many_traps(reason)) {\n+       return true;\n+     }\n+     if (C->trap_count(reason) != 0\n+         && method()->method_data()->trap_count(reason) != 0\n+         && has_exception_handler()) {\n+         return true;\n+     }\n+   }\n+   return false;\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/97ed536125645304aed03a4afbc3ded627de0bb0", "code_v0_no_empty_lines": "builtin_throw函数处理异常时，逻辑复杂且内联，包含大量条件判断和重复代码，特别是对于Math.*Exact等频繁溢出的情况，容易导致deoptimization和re-execution循环。", "code_v1_no_empty_lines": "- bool must_throw = true;\n- bool treat_throw_as_hot = false;\n- ciMethodData* md = method()->method_data();\n- if (ProfileTraps) {\n-   if (too_many_traps(reason)) {\n-     treat_throw_as_hot = true;\n-   }\n-   if (C->trap_count(reason) != 0\n-       && method()->method_data()->trap_count(reason) != 0\n-       && has_exception_handler()) {\n-       treat_throw_as_hot = true;\n-   }\n- }\n+ void GraphKit::builtin_throw(Deoptimization::DeoptReason reason,\n+                              ciInstance* ex_obj,\n+                              bool allow_too_many_traps) {\n+ bool GraphKit::is_builtin_throw_hot(Deoptimization::DeoptReason reason) {\n+   if (ProfileTraps) {\n+     if (too_many_traps(reason)) {\n+       return true;\n+     }\n+     if (C->trap_count(reason) != 0\n+         && method()->method_data()->trap_count(reason) != 0\n+         && has_exception_handler()) {\n+         return true;\n+     }\n+   }\n+   return false;\n+ }", "target": "- bool must_throw = true;\n- bool treat_throw_as_hot = false;\n- ciMethodData* md = method()->method_data();\n- if (ProfileTraps) {\n-   if (too_many_traps(reason)) {\n-     treat_throw_as_hot = true;\n-   }\n-   if (C->trap_count(reason) != 0\n-       && method()->method_data()->trap_count(reason) != 0\n-       && has_exception_handler()) {\n-       treat_throw_as_hot = true;\n-   }\n- }\n+ void GraphKit::builtin_throw(Deoptimization::DeoptReason reason,\n+                              ciInstance* ex_obj,\n+                              bool allow_too_many_traps) {\n+ bool GraphKit::is_builtin_throw_hot(Deoptimization::DeoptReason reason) {\n+   if (ProfileTraps) {\n+     if (too_many_traps(reason)) {\n+       return true;\n+     }\n+     if (C->trap_count(reason) != 0\n+         && method()->method_data()->trap_count(reason) != 0\n+         && has_exception_handler()) {\n+         return true;\n+     }\n+   }\n+   return false;\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：builtin_throw函数处理异常时，逻辑复杂且内联，包含大量条件判断和重复代码，特别是对于Math.*Exact等频繁溢出的情况，容易导致deoptimization和re-execution循环。优化后：重构builtin_throw函数，提取热异常判断逻辑到独立的is_builtin_throw_hot函数，增加新重载版本处理预构建异常对象，并添加allow_too_many_traps参数控制陷阱处理。优化思路：通过代码重构和逻辑分离，减少重复代码，提高异常处理路径的清晰度和性能，避免在频繁溢出场景下陷入deoptimization循环，提升C2编译器对Math.*Exact等精确运算的优化效果。"}
{"id": 452, "source": "riscv-dataset-excel", "optimization_type": "常量折叠优化+范围分析优化", "optimization_description": "优化前：XorINode::add_ring和XorLNode::add_ring方法在处理非负整数范围时，常量折叠逻辑不完善，当两个操作数都是常量时能正确计算XOR结果，但当至少一个操作数是非负范围时，无法精确计算XOR结果的范围上界，导致常量折叠被阻塞。\n\n优化后：1. 引入xor_upper_bound_for_ranges函数，通过计算两个非负范围hi值的按位或，加1后取下一个2的幂次再减1，精确计算XOR结果的上界。2. 修改add_ring方法，优先处理两个常量操作数的情况，然后处理两个非负范围的情况，使用新函数计算精确上界。3. 移除Value方法中冗余的范围计算逻辑。\n\n优化思路：通过精确计算非负整数范围XOR操作的上界，消除常量折叠的阻塞，使编译器能更早地识别和折叠常量表达式，减少运行时计算开销，提高代码生成质量。", "original_code": "XorINode::add_ring和XorLNode::add_ring方法在处理非负整数范围时，常量折叠逻辑不完善，当两个操作数都是常量时能正确计算XOR结果，但当至少一个操作数是非负范围时，无法精确计算XOR结果的范围上界，导致常量折叠被阻塞。", "optimized_code": "--- a/src/hotspot/share/opto/addnode.cpp\n+++ b/src/hotspot/share/opto/addnode.cpp\n@@ -1033,16 +1020,20 @@ const Type *XorINode::add_ring( const Type *t0, const Type *t1 ) const {\n   const TypeInt *r0 = t0->is_int(); // Handy access\n   const TypeInt *r1 = t1->is_int();\n \n-  // Complementing a boolean?\n-  if( r0 == TypeInt::BOOL && ( r1 == TypeInt::ONE\n-                               || r1 == TypeInt::BOOL))\n-    return TypeInt::BOOL;\n+  if (r0->is_con() && r1->is_con()) {\n+    // compute constant result\n+    return TypeInt::make(r0->get_con() ^ r1->get_con());\n+  }\n \n-  if( !r0->is_con() || !r1->is_con() ) // Not constants\n-    return TypeInt::INT;        // Any integer, but still no symbols.\n+  // At least one of the arguments is not constant\n \n-  // Otherwise just XOR them bits.\n-  return TypeInt::make( r0->get_con() ^ r1->get_con() );\n+  if (r0->_lo >= 0 && r1->_lo >= 0) {\n+      // Combine [r0->_lo, r0->_hi] ^ [r0->_lo, r1->_hi] -> [0, upper_bound]\n+      jint upper_bound = xor_upper_bound_for_ranges<jint, juint>(r0->_hi, r1->_hi);\n+      return TypeInt::make(0, upper_bound, MAX2(r0->_widen, r1->_widen));\n+  }\n+\n+  return TypeInt::INT;\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/37f8e419f9661ba30b3c34bd9fecef71ab1eddb1", "code_v0_no_empty_lines": "XorINode::add_ring和XorLNode::add_ring方法在处理非负整数范围时，常量折叠逻辑不完善，当两个操作数都是常量时能正确计算XOR结果，但当至少一个操作数是非负范围时，无法精确计算XOR结果的范围上界，导致常量折叠被阻塞。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/opto/addnode.cpp\n+++ b/src/hotspot/share/opto/addnode.cpp\n@@ -1033,16 +1020,20 @@ const Type *XorINode::add_ring( const Type *t0, const Type *t1 ) const {\n   const TypeInt *r0 = t0->is_int(); // Handy access\n   const TypeInt *r1 = t1->is_int();\n \n-  // Complementing a boolean?\n-  if( r0 == TypeInt::BOOL && ( r1 == TypeInt::ONE\n-                               || r1 == TypeInt::BOOL))\n-    return TypeInt::BOOL;\n+  if (r0->is_con() && r1->is_con()) {\n+    // compute constant result\n+    return TypeInt::make(r0->get_con() ^ r1->get_con());\n+  }\n \n-  if( !r0->is_con() || !r1->is_con() ) // Not constants\n-    return TypeInt::INT;        // Any integer, but still no symbols.\n+  // At least one of the arguments is not constant\n \n-  // Otherwise just XOR them bits.\n-  return TypeInt::make( r0->get_con() ^ r1->get_con() );\n+  if (r0->_lo >= 0 && r1->_lo >= 0) {\n+      // Combine [r0->_lo, r0->_hi] ^ [r0->_lo, r1->_hi] -> [0, upper_bound]\n+      jint upper_bound = xor_upper_bound_for_ranges<jint, juint>(r0->_hi, r1->_hi);\n+      return TypeInt::make(0, upper_bound, MAX2(r0->_widen, r1->_widen));\n+  }\n+\n+  return TypeInt::INT;\n }", "target": "--- a/src/hotspot/share/opto/addnode.cpp\n+++ b/src/hotspot/share/opto/addnode.cpp\n@@ -1033,16 +1020,20 @@ const Type *XorINode::add_ring( const Type *t0, const Type *t1 ) const {\n   const TypeInt *r0 = t0->is_int(); // Handy access\n   const TypeInt *r1 = t1->is_int();\n \n-  // Complementing a boolean?\n-  if( r0 == TypeInt::BOOL && ( r1 == TypeInt::ONE\n-                               || r1 == TypeInt::BOOL))\n-    return TypeInt::BOOL;\n+  if (r0->is_con() && r1->is_con()) {\n+    // compute constant result\n+    return TypeInt::make(r0->get_con() ^ r1->get_con());\n+  }\n \n-  if( !r0->is_con() || !r1->is_con() ) // Not constants\n-    return TypeInt::INT;        // Any integer, but still no symbols.\n+  // At least one of the arguments is not constant\n \n-  // Otherwise just XOR them bits.\n-  return TypeInt::make( r0->get_con() ^ r1->get_con() );\n+  if (r0->_lo >= 0 && r1->_lo >= 0) {\n+      // Combine [r0->_lo, r0->_hi] ^ [r0->_lo, r1->_hi] -> [0, upper_bound]\n+      jint upper_bound = xor_upper_bound_for_ranges<jint, juint>(r0->_hi, r1->_hi);\n+      return TypeInt::make(0, upper_bound, MAX2(r0->_widen, r1->_widen));\n+  }\n+\n+  return TypeInt::INT;\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：XorINode::add_ring和XorLNode::add_ring方法在处理非负整数范围时，常量折叠逻辑不完善，当两个操作数都是常量时能正确计算XOR结果，但当至少一个操作数是非负范围时，无法精确计算XOR结果的范围上界，导致常量折叠被阻塞。\n\n优化后：1. 引入xor_upper_bound_for_ranges函数，通过计算两个非负范围hi值的按位或，加1后取下一个2的幂次再减1，精确计算XOR结果的上界。2. 修改add_ring方法，优先处理两个常量操作数的情况，然后处理两个非负范围的情况，使用新函数计算精确上界。3. 移除Value方法中冗余的范围计算逻辑。\n\n优化思路：通过精确计算非负整数范围XOR操作的上界，消除常量折叠的阻塞，使编译器能更早地识别和折叠常量表达式，减少运行时计算开销，提高代码生成质量。"}
{"id": 453, "source": "riscv-dataset-excel", "optimization_type": "锁优化+性能优化", "optimization_description": "优化前：在DaCapo xalan基准测试中，使用-XX:+UseObjectMonitorTable时，BasicLock::object_monitor_cache()方法直接返回缓存的ObjectMonitor指针，未检查监控器是否正在异步放气（deflation），可能导致性能问题。优化后：在object_monitor_cache()方法中添加检查，如果监控器正在异步放气，则清除缓存并返回nullptr，避免使用无效监控器。这修复了性能回归，确保在轻量级锁模式下正确管理监控器缓存，提升并发性能。", "original_code": "在DaCapo xalan基准测试中，使用-XX:+UseObjectMonitorTable时，BasicLock::object_monitor_cache()方法直接返回缓存的ObjectMonitor指针，未检查监控器是否正在异步放气（deflation），可能导致性能问题。", "optimized_code": "inline ObjectMonitor* BasicLock::object_monitor_cache() {\n  assert(UseObjectMonitorTable, \"must be\");\n#if !defined(ZERO) && (defined(X86) || defined(AARCH64) || defined(RISCV64) || defined(PPC64) || defined(S390))\n  ObjectMonitor* monitor = reinterpret_cast<ObjectMonitor*>(get_metadata());\n  if (monitor != nullptr && monitor->is_being_async_deflated()) {\n    clear_object_monitor_cache();\n    return nullptr;\n  }\n  return monitor;\n#else\n  // Other platforms do not make use of the cache yet,\n  // and are not as careful with maintaining the invariant\n#endif\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/d894b781b8f245ce8a5d28401c0abb5abb420bc8", "code_v0_no_empty_lines": "在DaCapo xalan基准测试中，使用-XX:+UseObjectMonitorTable时，BasicLock::object_monitor_cache()方法直接返回缓存的ObjectMonitor指针，未检查监控器是否正在异步放气（deflation），可能导致性能问题。", "code_v1_no_empty_lines": "inline ObjectMonitor* BasicLock::object_monitor_cache() {\n  assert(UseObjectMonitorTable, \"must be\");\n#if !defined(ZERO) && (defined(X86) || defined(AARCH64) || defined(RISCV64) || defined(PPC64) || defined(S390))\n  ObjectMonitor* monitor = reinterpret_cast<ObjectMonitor*>(get_metadata());\n  if (monitor != nullptr && monitor->is_being_async_deflated()) {\n    clear_object_monitor_cache();\n    return nullptr;\n  }\n  return monitor;\n#else\n  // Other platforms do not make use of the cache yet,\n  // and are not as careful with maintaining the invariant\n#endif\n}", "target": "inline ObjectMonitor* BasicLock::object_monitor_cache() {\n  assert(UseObjectMonitorTable, \"must be\");\n#if !defined(ZERO) && (defined(X86) || defined(AARCH64) || defined(RISCV64) || defined(PPC64) || defined(S390))\n  ObjectMonitor* monitor = reinterpret_cast<ObjectMonitor*>(get_metadata());\n  if (monitor != nullptr && monitor->is_being_async_deflated()) {\n    clear_object_monitor_cache();\n    return nullptr;\n  }\n  return monitor;\n#else\n  // Other platforms do not make use of the cache yet,\n  // and are not as careful with maintaining the invariant\n#endif\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在DaCapo xalan基准测试中，使用-XX:+UseObjectMonitorTable时，BasicLock::object_monitor_cache()方法直接返回缓存的ObjectMonitor指针，未检查监控器是否正在异步放气（deflation），可能导致性能问题。优化后：在object_monitor_cache()方法中添加检查，如果监控器正在异步放气，则清除缓存并返回nullptr，避免使用无效监控器。这修复了性能回归，确保在轻量级锁模式下正确管理监控器缓存，提升并发性能。"}
{"id": 454, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+特殊值处理优化", "optimization_description": "优化前：Float16.max/min操作直接使用vmaxsh/vminsh指令，但未正确处理特殊值（如带符号零、NaN）的IEEE 754语义。优化后：新增scalar_max_min_fp16函数，通过evpmovw2m检测符号位，evpblendmw交换操作数确保第二个操作数为正值（max）或负值（min），然后执行vmaxsh/vminsh，最后用evcmpsh检测NaN并处理NaN返回规则。思路：利用AVX-512指令集特性，在硬件指令基础上添加软件逻辑来保证特殊值的正确行为，同时保持高性能。", "original_code": "Float16.max/min操作直接使用vmaxsh/vminsh指令，但未正确处理特殊值（如带符号零、NaN）的IEEE 754语义。", "optimized_code": "void C2_MacroAssembler::scalar_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n                                          KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n  if (opcode == Op_MaxHF) {\n    // Move sign bits of src2 to mask register.\n    evpmovw2m(ktmp, src2, vlen_enc);\n    // xtmp1 = src2 < 0 ? src2 : src1\n    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n    // xtmp2 = src2 < 0 ? ? src1 : src2\n    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n    // Idea behind above swapping is to make seconds source operand a +ve value.\n    // As per instruction semantic, if the values being compared are both 0.0s (of either sign), the value in\n    // the second source operand is returned. If only one value is a NaN (SNaN or QNaN) for this instruction,\n    // the second source operand, either a NaN or a valid floating-point value, is returned\n    // dst = max(xtmp1, xtmp2)\n    vmaxsh(dst, xtmp1, xtmp2);\n    // isNaN = is_unordered_quiet(xtmp1)\n    evcmpsh(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q);\n    // Final result is same as first source if its a NaN value,\n    // in case second operand holds a NaN value then as per above semantics\n    // result is same as second operand.\n    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n  } else {\n    assert(opcode == Op_MinHF, \"\");\n    // Move sign bits of src1 to mask register.\n    evpmovw2m(ktmp, src1, vlen_enc);\n    // xtmp1 = src1 < 0 ? src2 : src1\n    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n    // xtmp2 = src1 < 0 ? src1 : src2\n    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n    // Idea behind above swapping is to make seconds source operand a -ve value.\n    // As per instruction semantics, if the values being compared are both 0.0s (of either sign), the value in\n    // the second source operand is returned.\n    // If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN\n    // or a valid floating-point value, is written to the result.\n    // dst = min(xtmp1, xtmp2)\n    vminsh(dst, xtmp1, xtmp2);\n    // isNaN = is_unordered_quiet(xtmp1)\n    evcmpsh(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q);\n    // Final result is same as first source if its a NaN value,\n    // in case second operand holds a NaN value then as per above semantics\n    // result is same as second operand.\n    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n  }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/f7a94feedd63775a09d0bcb9ef3313972e2a5d69", "code_v0_no_empty_lines": "Float16.max/min操作直接使用vmaxsh/vminsh指令，但未正确处理特殊值（如带符号零、NaN）的IEEE 754语义。", "code_v1_no_empty_lines": "void C2_MacroAssembler::scalar_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n                                          KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n  if (opcode == Op_MaxHF) {\n    // Move sign bits of src2 to mask register.\n    evpmovw2m(ktmp, src2, vlen_enc);\n    // xtmp1 = src2 < 0 ? src2 : src1\n    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n    // xtmp2 = src2 < 0 ? ? src1 : src2\n    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n    // Idea behind above swapping is to make seconds source operand a +ve value.\n    // As per instruction semantic, if the values being compared are both 0.0s (of either sign), the value in\n    // the second source operand is returned. If only one value is a NaN (SNaN or QNaN) for this instruction,\n    // the second source operand, either a NaN or a valid floating-point value, is returned\n    // dst = max(xtmp1, xtmp2)\n    vmaxsh(dst, xtmp1, xtmp2);\n    // isNaN = is_unordered_quiet(xtmp1)\n    evcmpsh(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q);\n    // Final result is same as first source if its a NaN value,\n    // in case second operand holds a NaN value then as per above semantics\n    // result is same as second operand.\n    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n  } else {\n    assert(opcode == Op_MinHF, \"\");\n    // Move sign bits of src1 to mask register.\n    evpmovw2m(ktmp, src1, vlen_enc);\n    // xtmp1 = src1 < 0 ? src2 : src1\n    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n    // xtmp2 = src1 < 0 ? src1 : src2\n    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n    // Idea behind above swapping is to make seconds source operand a -ve value.\n    // As per instruction semantics, if the values being compared are both 0.0s (of either sign), the value in\n    // the second source operand is returned.\n    // If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN\n    // or a valid floating-point value, is written to the result.\n    // dst = min(xtmp1, xtmp2)\n    vminsh(dst, xtmp1, xtmp2);\n    // isNaN = is_unordered_quiet(xtmp1)\n    evcmpsh(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q);\n    // Final result is same as first source if its a NaN value,\n    // in case second operand holds a NaN value then as per above semantics\n    // result is same as second operand.\n    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n  }\n}", "target": "void C2_MacroAssembler::scalar_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n                                          KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n  if (opcode == Op_MaxHF) {\n    // Move sign bits of src2 to mask register.\n    evpmovw2m(ktmp, src2, vlen_enc);\n    // xtmp1 = src2 < 0 ? src2 : src1\n    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n    // xtmp2 = src2 < 0 ? ? src1 : src2\n    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n    // Idea behind above swapping is to make seconds source operand a +ve value.\n    // As per instruction semantic, if the values being compared are both 0.0s (of either sign), the value in\n    // the second source operand is returned. If only one value is a NaN (SNaN or QNaN) for this instruction,\n    // the second source operand, either a NaN or a valid floating-point value, is returned\n    // dst = max(xtmp1, xtmp2)\n    vmaxsh(dst, xtmp1, xtmp2);\n    // isNaN = is_unordered_quiet(xtmp1)\n    evcmpsh(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q);\n    // Final result is same as first source if its a NaN value,\n    // in case second operand holds a NaN value then as per above semantics\n    // result is same as second operand.\n    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n  } else {\n    assert(opcode == Op_MinHF, \"\");\n    // Move sign bits of src1 to mask register.\n    evpmovw2m(ktmp, src1, vlen_enc);\n    // xtmp1 = src1 < 0 ? src2 : src1\n    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n    // xtmp2 = src1 < 0 ? src1 : src2\n    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n    // Idea behind above swapping is to make seconds source operand a -ve value.\n    // As per instruction semantics, if the values being compared are both 0.0s (of either sign), the value in\n    // the second source operand is returned.\n    // If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN\n    // or a valid floating-point value, is written to the result.\n    // dst = min(xtmp1, xtmp2)\n    vminsh(dst, xtmp1, xtmp2);\n    // isNaN = is_unordered_quiet(xtmp1)\n    evcmpsh(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q);\n    // Final result is same as first source if its a NaN value,\n    // in case second operand holds a NaN value then as per above semantics\n    // result is same as second operand.\n    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Float16.max/min操作直接使用vmaxsh/vminsh指令，但未正确处理特殊值（如带符号零、NaN）的IEEE 754语义。优化后：新增scalar_max_min_fp16函数，通过evpmovw2m检测符号位，evpblendmw交换操作数确保第二个操作数为正值（max）或负值（min），然后执行vmaxsh/vminsh，最后用evcmpsh检测NaN并处理NaN返回规则。思路：利用AVX-512指令集特性，在硬件指令基础上添加软件逻辑来保证特殊值的正确行为，同时保持高性能。"}
{"id": 455, "source": "riscv-dataset-excel", "optimization_type": "内存泄漏修复", "optimization_description": "优化前：GrowableArrayCHeap::allocate()函数在max==0时返回nullptr，但GrowableArrayCHeapAllocator::allocate()函数没有处理max==0的情况，导致分配了不必要的小内存块，造成内存泄漏。优化后：将max==0的检查逻辑从GrowableArrayCHeap::allocate()移动到GrowableArrayCHeapAllocator::allocate()中，确保在分配器层面正确处理零大小分配，避免内存泄漏。思路：统一内存分配逻辑，确保所有分配路径都能正确处理零大小分配请求。", "original_code": "GrowableArrayCHeap::allocate()函数在max==0时返回nullptr，但GrowableArrayCHeapAllocator::allocate()函数没有处理max==0的情况，导致分配了不必要的小内存块，造成内存泄漏。", "optimized_code": "--- a/src/hotspot/share/utilities/growableArray.cpp\n+++ b/src/hotspot/share/utilities/growableArray.cpp\n@@ -43,6 +43,11 @@ void* GrowableArrayArenaAllocator::allocate(int max, int element_size, Arena* ar\n \n void* GrowableArrayCHeapAllocator::allocate(int max, int element_size, MemTag mem_tag) {\n   assert(max >= 0, \"integer overflow\");\n+\n+  if (max == 0) {\n+    return nullptr;\n+  }\n+\n   size_t byte_size = element_size * (size_t) max;\n \n   // memory tag has to be specified for C heap allocation\n--- a/src/hotspot/share/utilities/growableArray.hpp\n+++ b/src/hotspot/share/utilities/growableArray.hpp\n@@ -811,10 +811,6 @@ class GrowableArrayCHeap : public GrowableArrayWithAllocator<E, GrowableArrayCHe\n   STATIC_ASSERT(MT != mtNone);\n \n   static E* allocate(int max, MemTag mem_tag) {\n-    if (max == 0) {\n-      return nullptr;\n-    }\n-\n     return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), mem_tag);\n   }", "source_url": "https://github.com/openjdk/riscv-port/commit/b80b04d77afdb2a808e2c7f9268d8092eb16714e", "code_v0_no_empty_lines": "GrowableArrayCHeap::allocate()函数在max==0时返回nullptr，但GrowableArrayCHeapAllocator::allocate()函数没有处理max==0的情况，导致分配了不必要的小内存块，造成内存泄漏。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/utilities/growableArray.cpp\n+++ b/src/hotspot/share/utilities/growableArray.cpp\n@@ -43,6 +43,11 @@ void* GrowableArrayArenaAllocator::allocate(int max, int element_size, Arena* ar\n \n void* GrowableArrayCHeapAllocator::allocate(int max, int element_size, MemTag mem_tag) {\n   assert(max >= 0, \"integer overflow\");\n+\n+  if (max == 0) {\n+    return nullptr;\n+  }\n+\n   size_t byte_size = element_size * (size_t) max;\n \n   // memory tag has to be specified for C heap allocation\n--- a/src/hotspot/share/utilities/growableArray.hpp\n+++ b/src/hotspot/share/utilities/growableArray.hpp\n@@ -811,10 +811,6 @@ class GrowableArrayCHeap : public GrowableArrayWithAllocator<E, GrowableArrayCHe\n   STATIC_ASSERT(MT != mtNone);\n \n   static E* allocate(int max, MemTag mem_tag) {\n-    if (max == 0) {\n-      return nullptr;\n-    }\n-\n     return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), mem_tag);\n   }", "target": "--- a/src/hotspot/share/utilities/growableArray.cpp\n+++ b/src/hotspot/share/utilities/growableArray.cpp\n@@ -43,6 +43,11 @@ void* GrowableArrayArenaAllocator::allocate(int max, int element_size, Arena* ar\n \n void* GrowableArrayCHeapAllocator::allocate(int max, int element_size, MemTag mem_tag) {\n   assert(max >= 0, \"integer overflow\");\n+\n+  if (max == 0) {\n+    return nullptr;\n+  }\n+\n   size_t byte_size = element_size * (size_t) max;\n \n   // memory tag has to be specified for C heap allocation\n--- a/src/hotspot/share/utilities/growableArray.hpp\n+++ b/src/hotspot/share/utilities/growableArray.hpp\n@@ -811,10 +811,6 @@ class GrowableArrayCHeap : public GrowableArrayWithAllocator<E, GrowableArrayCHe\n   STATIC_ASSERT(MT != mtNone);\n \n   static E* allocate(int max, MemTag mem_tag) {\n-    if (max == 0) {\n-      return nullptr;\n-    }\n-\n     return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), mem_tag);\n   }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：GrowableArrayCHeap::allocate()函数在max==0时返回nullptr，但GrowableArrayCHeapAllocator::allocate()函数没有处理max==0的情况，导致分配了不必要的小内存块，造成内存泄漏。优化后：将max==0的检查逻辑从GrowableArrayCHeap::allocate()移动到GrowableArrayCHeapAllocator::allocate()中，确保在分配器层面正确处理零大小分配，避免内存泄漏。思路：统一内存分配逻辑，确保所有分配路径都能正确处理零大小分配请求。"}
{"id": 456, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（常量折叠）", "optimization_description": "优化前：在C2编译器（HotSpot JVM的即时编译器）中，OrINode和OrLNode的add_ring方法未处理(x | -1)的特殊情况，导致无法进行常量折叠。优化后：在add_ring方法中添加了检查，如果任一操作数为-1（即所有位均为1），则直接返回-1，因为任何数与-1进行按位或操作结果都是-1。优化思路：利用按位或操作的数学性质（x | -1 == -1），在编译时进行常量折叠，消除冗余的运行时计算，提升性能。", "original_code": "在C2编译器（HotSpot JVM的即时编译器）中，OrINode和OrLNode的add_ring方法未处理(x | -1)的特殊情况，导致无法进行常量折叠。", "optimized_code": "// If either input is all ones, the output is all ones.\n// x | ~0 == ~0 <==> x | -1 == -1\nif (r0 == TypeInt::MINUS_1 || r1 == TypeInt::MINUS_1) {\n    return TypeInt::MINUS_1;\n}\n\n// If either input is all ones, the output is all ones.\n// x | ~0 == ~0 <==> x | -1 == -1\nif (r0 == TypeLong::MINUS_1 || r1 == TypeLong::MINUS_1) {\n    return TypeLong::MINUS_1;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/f301663b346bf2388ecfa429be1cf64c6e93ee8e", "code_v0_no_empty_lines": "在C2编译器（HotSpot JVM的即时编译器）中，OrINode和OrLNode的add_ring方法未处理(x | -1)的特殊情况，导致无法进行常量折叠。", "code_v1_no_empty_lines": "// If either input is all ones, the output is all ones.\n// x | ~0 == ~0 <==> x | -1 == -1\nif (r0 == TypeInt::MINUS_1 || r1 == TypeInt::MINUS_1) {\n    return TypeInt::MINUS_1;\n}\n\n// If either input is all ones, the output is all ones.\n// x | ~0 == ~0 <==> x | -1 == -1\nif (r0 == TypeLong::MINUS_1 || r1 == TypeLong::MINUS_1) {\n    return TypeLong::MINUS_1;\n}", "target": "// If either input is all ones, the output is all ones.\n// x | ~0 == ~0 <==> x | -1 == -1\nif (r0 == TypeInt::MINUS_1 || r1 == TypeInt::MINUS_1) {\n    return TypeInt::MINUS_1;\n}\n\n// If either input is all ones, the output is all ones.\n// x | ~0 == ~0 <==> x | -1 == -1\nif (r0 == TypeLong::MINUS_1 || r1 == TypeLong::MINUS_1) {\n    return TypeLong::MINUS_1;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在C2编译器（HotSpot JVM的即时编译器）中，OrINode和OrLNode的add_ring方法未处理(x | -1)的特殊情况，导致无法进行常量折叠。优化后：在add_ring方法中添加了检查，如果任一操作数为-1（即所有位均为1），则直接返回-1，因为任何数与-1进行按位或操作结果都是-1。优化思路：利用按位或操作的数学性质（x | -1 == -1），在编译时进行常量折叠，消除冗余的运行时计算，提升性能。"}
{"id": 457, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+延迟任务调度优化", "optimization_description": "优化前：1. CompletableFuture使用静态检查决定是否使用ForkJoinPool.commonPool()，否则回退到ThreadPerTaskExecutor（为每个任务创建新线程），这在高并发场景下效率低下。2. 参数空值检查使用if-throw方式，代码冗余。优化后：1. 引入DelayScheduler类专门处理延迟任务，统一使用ForkJoinPool.asyncCommonPool()确保最小并行度，避免线程创建开销。2. 将if-throw替换为Objects.requireNonNull()，减少代码量并保持相同语义。思路：通过专用延迟调度器和优化空值检查，提升高并发下延迟任务处理性能，简化代码结构。", "original_code": "1. CompletableFuture使用静态检查决定是否使用ForkJoinPool.commonPool()，否则回退到ThreadPerTaskExecutor（为每个任务创建新线程），这在高并发场景下效率低下。2. 参数空值检查使用if-throw方式，代码冗余。", "optimized_code": "- private static final Executor ASYNC_POOL = USE_COMMON_POOL ? ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();\n+ private static final ForkJoinPool ASYNC_POOL = ForkJoinPool.asyncCommonPool(); // ensures minimal parallelism\n\n- if (f == null) throw new NullPointerException();\n+ Objects.requireNonNull(f);", "source_url": "https://github.com/openjdk/riscv-port/commit/8b0602dbed2f7ced190ec81753defab8a4bc316d", "code_v0_no_empty_lines": "1. CompletableFuture使用静态检查决定是否使用ForkJoinPool.commonPool()，否则回退到ThreadPerTaskExecutor（为每个任务创建新线程），这在高并发场景下效率低下。2. 参数空值检查使用if-throw方式，代码冗余。", "code_v1_no_empty_lines": "- private static final Executor ASYNC_POOL = USE_COMMON_POOL ? ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();\n+ private static final ForkJoinPool ASYNC_POOL = ForkJoinPool.asyncCommonPool(); // ensures minimal parallelism\n\n- if (f == null) throw new NullPointerException();\n+ Objects.requireNonNull(f);", "target": "- private static final Executor ASYNC_POOL = USE_COMMON_POOL ? ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();\n+ private static final ForkJoinPool ASYNC_POOL = ForkJoinPool.asyncCommonPool(); // ensures minimal parallelism\n\n- if (f == null) throw new NullPointerException();\n+ Objects.requireNonNull(f);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. CompletableFuture使用静态检查决定是否使用ForkJoinPool.commonPool()，否则回退到ThreadPerTaskExecutor（为每个任务创建新线程），这在高并发场景下效率低下。2. 参数空值检查使用if-throw方式，代码冗余。优化后：1. 引入DelayScheduler类专门处理延迟任务，统一使用ForkJoinPool.asyncCommonPool()确保最小并行度，避免线程创建开销。2. 将if-throw替换为Objects.requireNonNull()，减少代码量并保持相同语义。思路：通过专用延迟调度器和优化空值检查，提升高并发下延迟任务处理性能，简化代码结构。"}
{"id": 458, "source": "riscv-dataset-excel", "optimization_type": "SIMD指令集优化+平台适配优化", "optimization_description": "优化前：所有支持AVX512DQ指令集的CPU都启用AVX512版本的SIMD排序。优化后：为AMD Zen4处理器（CPU_FAMILY_AMD_19H）禁用AVX512版本的SIMD排序，改用AVX2版本。优化思路：针对AMD Zen4处理器在AVX512指令集上的性能特性，通过平台检测禁用AVX512排序实现，避免性能下降，同时保持其他平台（如Intel）的AVX512优化。", "original_code": "所有支持AVX512DQ指令集的CPU都启用AVX512版本的SIMD排序。", "optimized_code": "static bool supports_avx512_simd_sort() {\n  if (supports_avx512dq()) {\n    // Disable AVX512 version of SIMD Sort on AMD Zen4 Processors.\n    if (is_amd() && cpu_family() == CPU_FAMILY_AMD_19H) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/8cbadf78d04d0e3d1136a5582f281de099fc5e49", "code_v0_no_empty_lines": "所有支持AVX512DQ指令集的CPU都启用AVX512版本的SIMD排序。", "code_v1_no_empty_lines": "static bool supports_avx512_simd_sort() {\n  if (supports_avx512dq()) {\n    // Disable AVX512 version of SIMD Sort on AMD Zen4 Processors.\n    if (is_amd() && cpu_family() == CPU_FAMILY_AMD_19H) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}", "target": "static bool supports_avx512_simd_sort() {\n  if (supports_avx512dq()) {\n    // Disable AVX512 version of SIMD Sort on AMD Zen4 Processors.\n    if (is_amd() && cpu_family() == CPU_FAMILY_AMD_19H) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：所有支持AVX512DQ指令集的CPU都启用AVX512版本的SIMD排序。优化后：为AMD Zen4处理器（CPU_FAMILY_AMD_19H）禁用AVX512版本的SIMD排序，改用AVX2版本。优化思路：针对AMD Zen4处理器在AVX512指令集上的性能特性，通过平台检测禁用AVX512排序实现，避免性能下降，同时保持其他平台（如Intel）的AVX512优化。"}
{"id": 459, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+寄存器分配优化", "optimization_description": "优化前：1) 在generate_fixed_frame中，ConstMethod*加载到rbcp后立即用于计算codebase，然后重新加载ConstMethod*来获取ConstantPool*，存在冗余加载。2) 使用load_mirror宏调用，可能产生额外开销。3) 使用jcc指令而非jccb（短跳转），可能导致跳转距离较长时生成更大代码。4) 使用0而非NULL_WORD常量。优化后：1) 重新组织寄存器使用：将ConstMethod*加载到rax，计算codebase到rbcp，然后从同一rax获取ConstantPool*并保留在rax中供后续使用，消除冗余加载。2) 内联镜像加载逻辑，直接通过ConstantPool*->InstanceKlass*->Java mirror路径，避免宏调用开销。3) 将jcc改为jccb短跳转指令，减少代码大小。4) 统一使用NULL_WORD常量。优化思路：通过寄存器重用减少内存访问，内联关键操作减少调用开销，使用短跳转优化代码大小，统一常量使用提高可读性和潜在性能。", "original_code": "1) 在generate_fixed_frame中，ConstMethod*加载到rbcp后立即用于计算codebase，然后重新加载ConstMethod*来获取ConstantPool*，存在冗余加载。2) 使用load_mirror宏调用，可能产生额外开销。3) 使用jcc指令而非jccb（短跳转），可能导致跳转距离较长时生成更大代码。4) 使用0而非NULL_WORD常量。", "optimized_code": "@@ -561,32 +561,42 @@ void TemplateInterpreterGenerator::generate_fixed_frame(bool native_call) {\n   // initialize fixed part of activation frame\n-  __ push(rax);        // save return address\n-  __ enter();          // save old & set new rbp\n+  __ push(rax);         // save return address\n+  __ enter();           // save old & set new rbp\n   __ push(rbcp);        // set sender sp\n-  __ push(NULL_WORD); // leave last_sp as null\n-  __ movptr(rbcp, Address(rbx, Method::const_offset()));      // get ConstMethod*\n-  __ lea(rbcp, Address(rbcp, ConstMethod::codes_offset())); // get codebase\n+\n+  // Resolve ConstMethod* -> ConstantPool*.\n+  // Get codebase, while we still have ConstMethod*.\n+  // Save ConstantPool* in rax for later use.\n+  __ movptr(rax, Address(rbx, Method::const_offset()));\n+  __ lea(rbcp, Address(rax, ConstMethod::codes_offset()));\n+  __ movptr(rax, Address(rax, ConstMethod::constants_offset()));\n+\n+  __ push(NULL_WORD);  // leave last_sp as null\n   __ push(rbx);        // save Method*\n-  // Get mirror and store it in the frame as GC root for this Method*\n-  __ load_mirror(rdx, rbx, rscratch2);\n+\n+  // Get mirror and store it in the frame as GC root for this Method*.\n+  // rax is still ConstantPool*, resolve ConstantPool* -> InstanceKlass* -> Java mirror.\n+  __ movptr(rdx, Address(rax, ConstantPool::pool_holder_offset()));\n+  __ movptr(rdx, Address(rdx, in_bytes(Klass::java_mirror_offset())));\n+  __ resolve_oop_handle(rdx, rscratch2);\n   __ push(rdx);\n+\n   if (ProfileInterpreter) {\n     Label method_data_continue;\n     __ movptr(rdx, Address(rbx, in_bytes(Method::method_data_offset())));\n     __ testptr(rdx, rdx);\n-    __ jcc(Assembler::zero, method_data_continue);\n+    __ jccb(Assembler::zero, method_data_continue);\n     __ addptr(rdx, in_bytes(MethodData::data_offset()));\n     __ bind(method_data_continue);\n     __ push(rdx);      // set the mdp (method data pointer)\n   } else {\n-    __ push(0);\n+    __ push(NULL_WORD);\n   }\n \n-  __ movptr(rdx, Address(rbx, Method::const_offset()));\n-  __ movptr(rdx, Address(rdx, ConstMethod::constants_offset()));\n-  __ movptr(rdx, Address(rdx, ConstantPool::cache_offset()));\n-  __ push(rdx); // set constant pool cache\n+  // rax is still ConstantPool*, set the constant pool cache\n+  __ movptr(rdx, Address(rax, ConstantPool::cache_offset()));\n+  __ push(rdx);\n \n   __ movptr(rax, rlocals);\n   __ subptr(rax, rbp);\n@@ -594,7 +604,7 @@ void TemplateInterpreterGenerator::generate_fixed_frame(bool native_call) {\n   __ push(rax); // set relativized rlocals, see frame::interpreter_frame_locals()\n \n   if (native_call) {\n-    __ push(0); // no bcp\n+    __ push(NULL_WORD); // no bcp\n   } else {\n     __ push(rbcp); // set bcp\n   }\n@@ -1242,11 +1252,11 @@ address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n   {\n     Label exit, loop;\n     __ testl(rdx, rdx);\n-    __ jcc(Assembler::lessEqual, exit); // do nothing if rdx <= 0\n+    __ jccb(Assembler::lessEqual, exit); // do nothing if rdx <= 0\n     __ bind(loop);\n     __ push(NULL_WORD); // initialize local variables\n     __ decrementl(rdx); // until everything initialized\n-    __ jcc(Assembler::greater, loop);\n+    __ jccb(Assembler::greater, loop);\n     __ bind(exit);\n   }", "source_url": "https://github.com/openjdk/riscv-port/commit/22f630cb20b4e846f63cf5799cd2c50437d4dcad", "code_v0_no_empty_lines": "1) 在generate_fixed_frame中，ConstMethod*加载到rbcp后立即用于计算codebase，然后重新加载ConstMethod*来获取ConstantPool*，存在冗余加载。2) 使用load_mirror宏调用，可能产生额外开销。3) 使用jcc指令而非jccb（短跳转），可能导致跳转距离较长时生成更大代码。4) 使用0而非NULL_WORD常量。", "code_v1_no_empty_lines": "@@ -561,32 +561,42 @@ void TemplateInterpreterGenerator::generate_fixed_frame(bool native_call) {\n   // initialize fixed part of activation frame\n-  __ push(rax);        // save return address\n-  __ enter();          // save old & set new rbp\n+  __ push(rax);         // save return address\n+  __ enter();           // save old & set new rbp\n   __ push(rbcp);        // set sender sp\n-  __ push(NULL_WORD); // leave last_sp as null\n-  __ movptr(rbcp, Address(rbx, Method::const_offset()));      // get ConstMethod*\n-  __ lea(rbcp, Address(rbcp, ConstMethod::codes_offset())); // get codebase\n+\n+  // Resolve ConstMethod* -> ConstantPool*.\n+  // Get codebase, while we still have ConstMethod*.\n+  // Save ConstantPool* in rax for later use.\n+  __ movptr(rax, Address(rbx, Method::const_offset()));\n+  __ lea(rbcp, Address(rax, ConstMethod::codes_offset()));\n+  __ movptr(rax, Address(rax, ConstMethod::constants_offset()));\n+\n+  __ push(NULL_WORD);  // leave last_sp as null\n   __ push(rbx);        // save Method*\n-  // Get mirror and store it in the frame as GC root for this Method*\n-  __ load_mirror(rdx, rbx, rscratch2);\n+\n+  // Get mirror and store it in the frame as GC root for this Method*.\n+  // rax is still ConstantPool*, resolve ConstantPool* -> InstanceKlass* -> Java mirror.\n+  __ movptr(rdx, Address(rax, ConstantPool::pool_holder_offset()));\n+  __ movptr(rdx, Address(rdx, in_bytes(Klass::java_mirror_offset())));\n+  __ resolve_oop_handle(rdx, rscratch2);\n   __ push(rdx);\n+\n   if (ProfileInterpreter) {\n     Label method_data_continue;\n     __ movptr(rdx, Address(rbx, in_bytes(Method::method_data_offset())));\n     __ testptr(rdx, rdx);\n-    __ jcc(Assembler::zero, method_data_continue);\n+    __ jccb(Assembler::zero, method_data_continue);\n     __ addptr(rdx, in_bytes(MethodData::data_offset()));\n     __ bind(method_data_continue);\n     __ push(rdx);      // set the mdp (method data pointer)\n   } else {\n-    __ push(0);\n+    __ push(NULL_WORD);\n   }\n \n-  __ movptr(rdx, Address(rbx, Method::const_offset()));\n-  __ movptr(rdx, Address(rdx, ConstMethod::constants_offset()));\n-  __ movptr(rdx, Address(rdx, ConstantPool::cache_offset()));\n-  __ push(rdx); // set constant pool cache\n+  // rax is still ConstantPool*, set the constant pool cache\n+  __ movptr(rdx, Address(rax, ConstantPool::cache_offset()));\n+  __ push(rdx);\n \n   __ movptr(rax, rlocals);\n   __ subptr(rax, rbp);\n@@ -594,7 +604,7 @@ void TemplateInterpreterGenerator::generate_fixed_frame(bool native_call) {\n   __ push(rax); // set relativized rlocals, see frame::interpreter_frame_locals()\n \n   if (native_call) {\n-    __ push(0); // no bcp\n+    __ push(NULL_WORD); // no bcp\n   } else {\n     __ push(rbcp); // set bcp\n   }\n@@ -1242,11 +1252,11 @@ address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n   {\n     Label exit, loop;\n     __ testl(rdx, rdx);\n-    __ jcc(Assembler::lessEqual, exit); // do nothing if rdx <= 0\n+    __ jccb(Assembler::lessEqual, exit); // do nothing if rdx <= 0\n     __ bind(loop);\n     __ push(NULL_WORD); // initialize local variables\n     __ decrementl(rdx); // until everything initialized\n-    __ jcc(Assembler::greater, loop);\n+    __ jccb(Assembler::greater, loop);\n     __ bind(exit);\n   }", "target": "@@ -561,32 +561,42 @@ void TemplateInterpreterGenerator::generate_fixed_frame(bool native_call) {\n   // initialize fixed part of activation frame\n-  __ push(rax);        // save return address\n-  __ enter();          // save old & set new rbp\n+  __ push(rax);         // save return address\n+  __ enter();           // save old & set new rbp\n   __ push(rbcp);        // set sender sp\n-  __ push(NULL_WORD); // leave last_sp as null\n-  __ movptr(rbcp, Address(rbx, Method::const_offset()));      // get ConstMethod*\n-  __ lea(rbcp, Address(rbcp, ConstMethod::codes_offset())); // get codebase\n+\n+  // Resolve ConstMethod* -> ConstantPool*.\n+  // Get codebase, while we still have ConstMethod*.\n+  // Save ConstantPool* in rax for later use.\n+  __ movptr(rax, Address(rbx, Method::const_offset()));\n+  __ lea(rbcp, Address(rax, ConstMethod::codes_offset()));\n+  __ movptr(rax, Address(rax, ConstMethod::constants_offset()));\n+\n+  __ push(NULL_WORD);  // leave last_sp as null\n   __ push(rbx);        // save Method*\n-  // Get mirror and store it in the frame as GC root for this Method*\n-  __ load_mirror(rdx, rbx, rscratch2);\n+\n+  // Get mirror and store it in the frame as GC root for this Method*.\n+  // rax is still ConstantPool*, resolve ConstantPool* -> InstanceKlass* -> Java mirror.\n+  __ movptr(rdx, Address(rax, ConstantPool::pool_holder_offset()));\n+  __ movptr(rdx, Address(rdx, in_bytes(Klass::java_mirror_offset())));\n+  __ resolve_oop_handle(rdx, rscratch2);\n   __ push(rdx);\n+\n   if (ProfileInterpreter) {\n     Label method_data_continue;\n     __ movptr(rdx, Address(rbx, in_bytes(Method::method_data_offset())));\n     __ testptr(rdx, rdx);\n-    __ jcc(Assembler::zero, method_data_continue);\n+    __ jccb(Assembler::zero, method_data_continue);\n     __ addptr(rdx, in_bytes(MethodData::data_offset()));\n     __ bind(method_data_continue);\n     __ push(rdx);      // set the mdp (method data pointer)\n   } else {\n-    __ push(0);\n+    __ push(NULL_WORD);\n   }\n \n-  __ movptr(rdx, Address(rbx, Method::const_offset()));\n-  __ movptr(rdx, Address(rdx, ConstMethod::constants_offset()));\n-  __ movptr(rdx, Address(rdx, ConstantPool::cache_offset()));\n-  __ push(rdx); // set constant pool cache\n+  // rax is still ConstantPool*, set the constant pool cache\n+  __ movptr(rdx, Address(rax, ConstantPool::cache_offset()));\n+  __ push(rdx);\n \n   __ movptr(rax, rlocals);\n   __ subptr(rax, rbp);\n@@ -594,7 +604,7 @@ void TemplateInterpreterGenerator::generate_fixed_frame(bool native_call) {\n   __ push(rax); // set relativized rlocals, see frame::interpreter_frame_locals()\n \n   if (native_call) {\n-    __ push(0); // no bcp\n+    __ push(NULL_WORD); // no bcp\n   } else {\n     __ push(rbcp); // set bcp\n   }\n@@ -1242,11 +1252,11 @@ address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n   {\n     Label exit, loop;\n     __ testl(rdx, rdx);\n-    __ jcc(Assembler::lessEqual, exit); // do nothing if rdx <= 0\n+    __ jccb(Assembler::lessEqual, exit); // do nothing if rdx <= 0\n     __ bind(loop);\n     __ push(NULL_WORD); // initialize local variables\n     __ decrementl(rdx); // until everything initialized\n-    __ jcc(Assembler::greater, loop);\n+    __ jccb(Assembler::greater, loop);\n     __ bind(exit);\n   }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1) 在generate_fixed_frame中，ConstMethod*加载到rbcp后立即用于计算codebase，然后重新加载ConstMethod*来获取ConstantPool*，存在冗余加载。2) 使用load_mirror宏调用，可能产生额外开销。3) 使用jcc指令而非jccb（短跳转），可能导致跳转距离较长时生成更大代码。4) 使用0而非NULL_WORD常量。优化后：1) 重新组织寄存器使用：将ConstMethod*加载到rax，计算codebase到rbcp，然后从同一rax获取ConstantPool*并保留在rax中供后续使用，消除冗余加载。2) 内联镜像加载逻辑，直接通过ConstantPool*->InstanceKlass*->Java mirror路径，避免宏调用开销。3) 将jcc改为jccb短跳转指令，减少代码大小。4) 统一使用NULL_WORD常量。优化思路：通过寄存器重用减少内存访问，内联关键操作减少调用开销，使用短跳转优化代码大小，统一常量使用提高可读性和潜在性能。"}
{"id": 460, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化+锁性能优化", "optimization_description": "优化前：entry_list_tail()函数每次调用时都会遍历整个_entry_list来构建双向链表并设置尾指针，即使链表已经部分或完全构建完成。在unlink_after_acquire()中多次调用entry_list_tail()时存在重复遍历开销。\n\n优化后：将双向链表构建逻辑分离到新的entry_list_build_dll()函数中，该函数能智能检测已构建的部分并只构建缺失的prev指针。entry_list_tail()简化为直接返回尾指针或调用一次构建函数。unlink_after_acquire()中不再需要重置_entry_list_tail并重复遍历。\n\n优化思路：通过分离关注点和避免重复遍历，减少锁竞争时的链表操作开销，提高ObjectMonitor::unlink_after_acquire()的性能。", "original_code": "entry_list_tail()函数每次调用时都会遍历整个_entry_list来构建双向链表并设置尾指针，即使链表已经部分或完全构建完成。在unlink_after_acquire()中多次调用entry_list_tail()时存在重复遍历开销。", "optimized_code": "- ObjectWaiter* ObjectMonitor::entry_list_tail(JavaThread* current) {\n  assert(has_owner(current), \"invariant\");\n  ObjectWaiter* w = _entry_list_tail;\n  if (w != nullptr) {\n    return w;\n  }\n  // Need acquire here to match the implicit release of the cmpxchg\n  // that updated _entry_list, so we can access w->_next.\n  w = Atomic::load_acquire(&_entry_list);\n  assert(w != nullptr, \"invariant\");\n  if (w->next() == nullptr) {\n    _entry_list_tail = w;\n    return w;\n  }\n  ObjectWaiter* prev = nullptr;\n  while (w != nullptr) {\n    assert(w->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n    w->_prev = prev;\n    prev = w;\n    w = w->next();\n  }\n  _entry_list_tail = prev;\n  return prev;\n}\n\n+ void ObjectMonitor::entry_list_build_dll(JavaThread* current) {\n+   assert(has_owner(current), \"invariant\");\n+   ObjectWaiter* prev = nullptr;\n+   // Need acquire here to match the implicit release of the cmpxchg\n+   // that updated entry_list, so we can access w->prev().\n+   ObjectWaiter* w = Atomic::load_acquire(&_entry_list);\n+   assert(w != nullptr, \"should only be called when entry list is not empty\");\n+   while (w != nullptr) {\n+     assert(w->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n+     assert(w->prev() == nullptr || w->prev() == prev, \"invariant\");\n+     if (w->prev() != nullptr) {\n+       break;\n+     }\n+     w->_prev = prev;\n+     prev = w;\n+     w = w->next();\n+   }\n+   if (w == nullptr) {\n+     // We converted the entire entry_list from a singly linked list\n+     // into a doubly linked list. Now we just need to set the tail\n+     // pointer.\n+     assert(prev != nullptr && prev->next() == nullptr, \"invariant\");\n+     assert(_entry_list_tail == nullptr || _entry_list_tail == prev, \"invariant\");\n+     _entry_list_tail = prev;\n+   } else {\n+ #ifdef ASSERT\n+     // We stopped iterating through the _entry_list when we found a\n+     // node that had its prev pointer set. I.e. we converted the first\n+     // part of the entry_list from a singly linked list into a doubly\n+     // linked list. Now we just want to make sure the rest of the list\n+     // is doubly linked. But first we check that we have a tail\n+     // pointer, because if the end of the entry_list is doubly linked\n+     // and we don't have the tail pointer, something is broken.\n+     assert(_entry_list_tail != nullptr, \"invariant\");\n+     while (w != nullptr) {\n+       assert(w->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n+       assert(w->prev() == prev, \"invariant\");\n+       prev = w;\n+       w = w->next();\n+     }\n+     assert(_entry_list_tail == prev, \"invariant\");\n+ #endif\n+   }\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/45a9750b2c9364a05e00cdb935ef986c0a2c3e19", "code_v0_no_empty_lines": "entry_list_tail()函数每次调用时都会遍历整个_entry_list来构建双向链表并设置尾指针，即使链表已经部分或完全构建完成。在unlink_after_acquire()中多次调用entry_list_tail()时存在重复遍历开销。", "code_v1_no_empty_lines": "- ObjectWaiter* ObjectMonitor::entry_list_tail(JavaThread* current) {\n  assert(has_owner(current), \"invariant\");\n  ObjectWaiter* w = _entry_list_tail;\n  if (w != nullptr) {\n    return w;\n  }\n  // Need acquire here to match the implicit release of the cmpxchg\n  // that updated _entry_list, so we can access w->_next.\n  w = Atomic::load_acquire(&_entry_list);\n  assert(w != nullptr, \"invariant\");\n  if (w->next() == nullptr) {\n    _entry_list_tail = w;\n    return w;\n  }\n  ObjectWaiter* prev = nullptr;\n  while (w != nullptr) {\n    assert(w->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n    w->_prev = prev;\n    prev = w;\n    w = w->next();\n  }\n  _entry_list_tail = prev;\n  return prev;\n}\n\n+ void ObjectMonitor::entry_list_build_dll(JavaThread* current) {\n+   assert(has_owner(current), \"invariant\");\n+   ObjectWaiter* prev = nullptr;\n+   // Need acquire here to match the implicit release of the cmpxchg\n+   // that updated entry_list, so we can access w->prev().\n+   ObjectWaiter* w = Atomic::load_acquire(&_entry_list);\n+   assert(w != nullptr, \"should only be called when entry list is not empty\");\n+   while (w != nullptr) {\n+     assert(w->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n+     assert(w->prev() == nullptr || w->prev() == prev, \"invariant\");\n+     if (w->prev() != nullptr) {\n+       break;\n+     }\n+     w->_prev = prev;\n+     prev = w;\n+     w = w->next();\n+   }\n+   if (w == nullptr) {\n+     // We converted the entire entry_list from a singly linked list\n+     // into a doubly linked list. Now we just need to set the tail\n+     // pointer.\n+     assert(prev != nullptr && prev->next() == nullptr, \"invariant\");\n+     assert(_entry_list_tail == nullptr || _entry_list_tail == prev, \"invariant\");\n+     _entry_list_tail = prev;\n+   } else {\n+ #ifdef ASSERT\n+     // We stopped iterating through the _entry_list when we found a\n+     // node that had its prev pointer set. I.e. we converted the first\n+     // part of the entry_list from a singly linked list into a doubly\n+     // linked list. Now we just want to make sure the rest of the list\n+     // is doubly linked. But first we check that we have a tail\n+     // pointer, because if the end of the entry_list is doubly linked\n+     // and we don't have the tail pointer, something is broken.\n+     assert(_entry_list_tail != nullptr, \"invariant\");\n+     while (w != nullptr) {\n+       assert(w->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n+       assert(w->prev() == prev, \"invariant\");\n+       prev = w;\n+       w = w->next();\n+     }\n+     assert(_entry_list_tail == prev, \"invariant\");\n+ #endif\n+   }\n+ }", "target": "- ObjectWaiter* ObjectMonitor::entry_list_tail(JavaThread* current) {\n  assert(has_owner(current), \"invariant\");\n  ObjectWaiter* w = _entry_list_tail;\n  if (w != nullptr) {\n    return w;\n  }\n  // Need acquire here to match the implicit release of the cmpxchg\n  // that updated _entry_list, so we can access w->_next.\n  w = Atomic::load_acquire(&_entry_list);\n  assert(w != nullptr, \"invariant\");\n  if (w->next() == nullptr) {\n    _entry_list_tail = w;\n    return w;\n  }\n  ObjectWaiter* prev = nullptr;\n  while (w != nullptr) {\n    assert(w->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n    w->_prev = prev;\n    prev = w;\n    w = w->next();\n  }\n  _entry_list_tail = prev;\n  return prev;\n}\n\n+ void ObjectMonitor::entry_list_build_dll(JavaThread* current) {\n+   assert(has_owner(current), \"invariant\");\n+   ObjectWaiter* prev = nullptr;\n+   // Need acquire here to match the implicit release of the cmpxchg\n+   // that updated entry_list, so we can access w->prev().\n+   ObjectWaiter* w = Atomic::load_acquire(&_entry_list);\n+   assert(w != nullptr, \"should only be called when entry list is not empty\");\n+   while (w != nullptr) {\n+     assert(w->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n+     assert(w->prev() == nullptr || w->prev() == prev, \"invariant\");\n+     if (w->prev() != nullptr) {\n+       break;\n+     }\n+     w->_prev = prev;\n+     prev = w;\n+     w = w->next();\n+   }\n+   if (w == nullptr) {\n+     // We converted the entire entry_list from a singly linked list\n+     // into a doubly linked list. Now we just need to set the tail\n+     // pointer.\n+     assert(prev != nullptr && prev->next() == nullptr, \"invariant\");\n+     assert(_entry_list_tail == nullptr || _entry_list_tail == prev, \"invariant\");\n+     _entry_list_tail = prev;\n+   } else {\n+ #ifdef ASSERT\n+     // We stopped iterating through the _entry_list when we found a\n+     // node that had its prev pointer set. I.e. we converted the first\n+     // part of the entry_list from a singly linked list into a doubly\n+     // linked list. Now we just want to make sure the rest of the list\n+     // is doubly linked. But first we check that we have a tail\n+     // pointer, because if the end of the entry_list is doubly linked\n+     // and we don't have the tail pointer, something is broken.\n+     assert(_entry_list_tail != nullptr, \"invariant\");\n+     while (w != nullptr) {\n+       assert(w->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n+       assert(w->prev() == prev, \"invariant\");\n+       prev = w;\n+       w = w->next();\n+     }\n+     assert(_entry_list_tail == prev, \"invariant\");\n+ #endif\n+   }\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：entry_list_tail()函数每次调用时都会遍历整个_entry_list来构建双向链表并设置尾指针，即使链表已经部分或完全构建完成。在unlink_after_acquire()中多次调用entry_list_tail()时存在重复遍历开销。\n\n优化后：将双向链表构建逻辑分离到新的entry_list_build_dll()函数中，该函数能智能检测已构建的部分并只构建缺失的prev指针。entry_list_tail()简化为直接返回尾指针或调用一次构建函数。unlink_after_acquire()中不再需要重置_entry_list_tail并重复遍历。\n\n优化思路：通过分离关注点和避免重复遍历，减少锁竞争时的链表操作开销，提高ObjectMonitor::unlink_after_acquire()的性能。"}
{"id": 461, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（C2中间表示优化）", "optimization_description": "优化前：C2编译器在处理部分字存储（如StoreB）前的符号扩展操作时，只能识别并优化左移和右移常量相等的情况（conIL == conIR）。优化后：扩展了优化规则，支持处理左移常量大于右移常量（conIL > conIR）的情况，通过数学证明确保在特定条件下（conIL >= conIR且conIR <= num_rejected_bits）可以将(RShiftI (LShiftI v conIL) conIR)简化为(LShiftI v (conIL-conIR))。优化思路：识别并消除冗余的移位操作链，减少中间表示节点数量，提升编译后代码执行效率，特别是在处理数组存储和类型转换场景中。", "original_code": "C2编译器在处理部分字存储（如StoreB）前的符号扩展操作时，只能识别并优化左移和右移常量相等的情况（conIL == conIR）。", "optimized_code": "Node *StoreNode::Ideal_sign_extended_input(PhaseGVN *phase, int num_bits) {\n  Node *val = in(MemNode::ValueIn);\n  if( val->Opcode() == Op_RShiftI ) {\n    const TypeInt *t = phase->type( val->in(2) )->isa_int();\n    if( t && t->is_con() && (t->get_con() <= num_bits) ) {\n      Node *shl = val->in(1);\n      if( shl->Opcode() == Op_LShiftI ) {\n        const TypeInt *t2 = phase->type( shl->in(2) )->isa_int();\n        if( t2 && t2->is_con() && (t2->get_con() == t->get_con()) ) {\n          set_req_X(MemNode::ValueIn, shl->in(1), phase);\n          return this;\n        }\n      }\n    }\n  }\n  return NULL;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/bdcac98673a2250f608bdf244e17578eecb30fbe", "code_v0_no_empty_lines": "C2编译器在处理部分字存储（如StoreB）前的符号扩展操作时，只能识别并优化左移和右移常量相等的情况（conIL == conIR）。", "code_v1_no_empty_lines": "Node *StoreNode::Ideal_sign_extended_input(PhaseGVN *phase, int num_bits) {\n  Node *val = in(MemNode::ValueIn);\n  if( val->Opcode() == Op_RShiftI ) {\n    const TypeInt *t = phase->type( val->in(2) )->isa_int();\n    if( t && t->is_con() && (t->get_con() <= num_bits) ) {\n      Node *shl = val->in(1);\n      if( shl->Opcode() == Op_LShiftI ) {\n        const TypeInt *t2 = phase->type( shl->in(2) )->isa_int();\n        if( t2 && t2->is_con() && (t2->get_con() == t->get_con()) ) {\n          set_req_X(MemNode::ValueIn, shl->in(1), phase);\n          return this;\n        }\n      }\n    }\n  }\n  return NULL;\n}", "target": "Node *StoreNode::Ideal_sign_extended_input(PhaseGVN *phase, int num_bits) {\n  Node *val = in(MemNode::ValueIn);\n  if( val->Opcode() == Op_RShiftI ) {\n    const TypeInt *t = phase->type( val->in(2) )->isa_int();\n    if( t && t->is_con() && (t->get_con() <= num_bits) ) {\n      Node *shl = val->in(1);\n      if( shl->Opcode() == Op_LShiftI ) {\n        const TypeInt *t2 = phase->type( shl->in(2) )->isa_int();\n        if( t2 && t2->is_con() && (t2->get_con() == t->get_con()) ) {\n          set_req_X(MemNode::ValueIn, shl->in(1), phase);\n          return this;\n        }\n      }\n    }\n  }\n  return NULL;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器在处理部分字存储（如StoreB）前的符号扩展操作时，只能识别并优化左移和右移常量相等的情况（conIL == conIR）。优化后：扩展了优化规则，支持处理左移常量大于右移常量（conIL > conIR）的情况，通过数学证明确保在特定条件下（conIL >= conIR且conIR <= num_rejected_bits）可以将(RShiftI (LShiftI v conIL) conIR)简化为(LShiftI v (conIL-conIR))。优化思路：识别并消除冗余的移位操作链，减少中间表示节点数量，提升编译后代码执行效率，特别是在处理数组存储和类型转换场景中。"}
{"id": 462, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+分支消除", "optimization_description": "优化前：min/max操作使用条件分支指令（ble/bge）和跳转标签实现，存在分支预测开销和流水线停顿风险。优化后：当支持Zicond扩展时，使用条件移动指令（cmov_gt/cmov_lt）直接实现min/max操作，消除了分支跳转。优化思路：利用RISC-V Zicond扩展的条件移动指令替代传统分支实现，减少分支预测失败惩罚，提高指令级并行性，特别适用于数据依赖较少的场景。", "original_code": "min/max操作使用条件分支指令（ble/bge）和跳转标签实现，存在分支预测开销和流水线停顿风险。", "optimized_code": "-    \"ble $dst, $src, skip\\t#@minI_reg_reg\\n\\t\"\n-    \"mv  $dst, $src\\n\\t\"\n-    \"skip:\"\n+    \"minI_reg_reg $dst, $dst, $src\\t#@minI_reg_reg\\n\\t\"\n-    Label Lskip;\n-    __ ble(as_Register($dst$$reg), as_Register($src$$reg), Lskip);\n-    __ mv(as_Register($dst$$reg), as_Register($src$$reg));\n-    __ bind(Lskip);\n+    __ cmov_gt(as_Register($dst$$reg), as_Register($src$$reg),\n+               as_Register($dst$$reg), as_Register($src$$reg));", "source_url": "https://github.com/openjdk/riscv-port/commit/3d3b7820371058b40f2e694536c98aa3900abb5f", "code_v0_no_empty_lines": "min/max操作使用条件分支指令（ble/bge）和跳转标签实现，存在分支预测开销和流水线停顿风险。", "code_v1_no_empty_lines": "-    \"ble $dst, $src, skip\\t#@minI_reg_reg\\n\\t\"\n-    \"mv  $dst, $src\\n\\t\"\n-    \"skip:\"\n+    \"minI_reg_reg $dst, $dst, $src\\t#@minI_reg_reg\\n\\t\"\n-    Label Lskip;\n-    __ ble(as_Register($dst$$reg), as_Register($src$$reg), Lskip);\n-    __ mv(as_Register($dst$$reg), as_Register($src$$reg));\n-    __ bind(Lskip);\n+    __ cmov_gt(as_Register($dst$$reg), as_Register($src$$reg),\n+               as_Register($dst$$reg), as_Register($src$$reg));", "target": "-    \"ble $dst, $src, skip\\t#@minI_reg_reg\\n\\t\"\n-    \"mv  $dst, $src\\n\\t\"\n-    \"skip:\"\n+    \"minI_reg_reg $dst, $dst, $src\\t#@minI_reg_reg\\n\\t\"\n-    Label Lskip;\n-    __ ble(as_Register($dst$$reg), as_Register($src$$reg), Lskip);\n-    __ mv(as_Register($dst$$reg), as_Register($src$$reg));\n-    __ bind(Lskip);\n+    __ cmov_gt(as_Register($dst$$reg), as_Register($src$$reg),\n+               as_Register($dst$$reg), as_Register($src$$reg));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：min/max操作使用条件分支指令（ble/bge）和跳转标签实现，存在分支预测开销和流水线停顿风险。优化后：当支持Zicond扩展时，使用条件移动指令（cmov_gt/cmov_lt）直接实现min/max操作，消除了分支跳转。优化思路：利用RISC-V Zicond扩展的条件移动指令替代传统分支实现，减少分支预测失败惩罚，提高指令级并行性，特别适用于数据依赖较少的场景。"}
{"id": 463, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+指令集优化", "optimization_description": "优化前：AArch64架构的NEON向量重排指令仅支持4个或更多通道的向量（vlen >= 4），对于短向量（如2个元素的double向量）无法生成重排指令，导致性能下降。优化后：1. 移除了vlen < 4的限制，允许小通道数向量使用重排操作；2. 将原有的rearrange_HS_neon指令重构为rearrange_HSD_neon，支持更广泛的向量类型（包括half-word、single-word和double-word）；3. 通过新的neon_rearrange_hsd宏实现更简洁高效的向量重排逻辑。优化思路：扩展向量重排指令的支持范围，特别是针对小向量场景，通过重构指令实现和移除不必要的限制，提升向量化代码的性能和兼容性。", "original_code": "AArch64架构的NEON向量重排指令仅支持4个或更多通道的向量（vlen >= 4），对于短向量（如2个元素的double向量）无法生成重排指令，导致性能下降。", "optimized_code": "- instruct rearrange_HS_neon(vReg dst, vReg src, vReg shuffle, vReg tmp1, vReg tmp2) %{\n  predicate(UseSVE == 0 &&\n            (Matcher::vector_element_basic_type(n) == T_SHORT ||\n             (type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 &&\n              Matcher::vector_length_in_bytes(n) == 16)));\n  match(Set dst (VectorRearrange src shuffle));\n  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n  format %{ \"rearrange_HS_neon $dst, $src, $shuffle\\t# vector (4S/8S/4I/4F). KILL $tmp1, $tmp2\" %}\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    if (bt == T_SHORT) {\n      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n      assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n      Assembler::SIMD_Arrangement size1 = length_in_bytes == 16 ? __ T16B : __ T8B;\n      Assembler::SIMD_Arrangement size2 = length_in_bytes == 16 ? __ T8H : __ T4H;\n      __ mov($tmp1$$FloatRegister, size1, 0x02);\n      __ mov($tmp2$$FloatRegister, size2, 0x0100);\n      __ mulv($dst$$FloatRegister, size2, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n      __ addv($dst$$FloatRegister, size1, $dst$$FloatRegister, $tmp2$$FloatRegister);\n      __ tbl($dst$$FloatRegister, size1, $src$$FloatRegister, 1, $dst$$FloatRegister);\n    } else {\n      assert(bt == T_INT || bt == T_FLOAT, \"unsupported type\");\n      __ mov($tmp1$$FloatRegister, __ T16B, 0x04);\n      __ mov($tmp2$$FloatRegister, __ T4S, 0x03020100);\n      __ mulv($dst$$FloatRegister, __ T4S, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n      __ addv($dst$$FloatRegister, __ T16B, $dst$$FloatRegister, $tmp2$$FloatRegister);\n      __ tbl($dst$$FloatRegister, __ T16B, $src$$FloatRegister, 1, $dst$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}\n\n+ instruct rearrange_HSD_neon(vReg dst, vReg src, vReg shuffle, vReg tmp) %{\n+   predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) != T_BYTE);\n+   match(Set dst (VectorRearrange src shuffle));\n+   effect(TEMP_DEF dst, TEMP tmp);\n+   format %{ \"rearrange_HSD_neon $dst, $src, $shuffle\\t# vector (4H/8H/2S/4S/2D). KILL $tmp\" %}\n+   ins_encode %{\n+     BasicType bt = Matcher::vector_element_basic_type(this);\n+     uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+     assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+     __ neon_rearrange_hsd($dst$$FloatRegister, $src$$FloatRegister,\n+                           $shuffle$$FloatRegister, $tmp$$FloatRegister,\n+                           bt, length_in_bytes == 16);\n+   %}\n+   ins_pipe(pipe_slow);\n+%}\n\n-      case Op_VectorLoadShuffle:\n-      case Op_VectorRearrange:\n-        if (vlen < 4) {\n-          return false;\n-        }\n-        break;", "source_url": "https://github.com/openjdk/riscv-port/commit/99c8a6e47ac9b0659349a849940c27c626beb905", "code_v0_no_empty_lines": "AArch64架构的NEON向量重排指令仅支持4个或更多通道的向量（vlen >= 4），对于短向量（如2个元素的double向量）无法生成重排指令，导致性能下降。", "code_v1_no_empty_lines": "- instruct rearrange_HS_neon(vReg dst, vReg src, vReg shuffle, vReg tmp1, vReg tmp2) %{\n  predicate(UseSVE == 0 &&\n            (Matcher::vector_element_basic_type(n) == T_SHORT ||\n             (type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 &&\n              Matcher::vector_length_in_bytes(n) == 16)));\n  match(Set dst (VectorRearrange src shuffle));\n  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n  format %{ \"rearrange_HS_neon $dst, $src, $shuffle\\t# vector (4S/8S/4I/4F). KILL $tmp1, $tmp2\" %}\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    if (bt == T_SHORT) {\n      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n      assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n      Assembler::SIMD_Arrangement size1 = length_in_bytes == 16 ? __ T16B : __ T8B;\n      Assembler::SIMD_Arrangement size2 = length_in_bytes == 16 ? __ T8H : __ T4H;\n      __ mov($tmp1$$FloatRegister, size1, 0x02);\n      __ mov($tmp2$$FloatRegister, size2, 0x0100);\n      __ mulv($dst$$FloatRegister, size2, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n      __ addv($dst$$FloatRegister, size1, $dst$$FloatRegister, $tmp2$$FloatRegister);\n      __ tbl($dst$$FloatRegister, size1, $src$$FloatRegister, 1, $dst$$FloatRegister);\n    } else {\n      assert(bt == T_INT || bt == T_FLOAT, \"unsupported type\");\n      __ mov($tmp1$$FloatRegister, __ T16B, 0x04);\n      __ mov($tmp2$$FloatRegister, __ T4S, 0x03020100);\n      __ mulv($dst$$FloatRegister, __ T4S, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n      __ addv($dst$$FloatRegister, __ T16B, $dst$$FloatRegister, $tmp2$$FloatRegister);\n      __ tbl($dst$$FloatRegister, __ T16B, $src$$FloatRegister, 1, $dst$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}\n\n+ instruct rearrange_HSD_neon(vReg dst, vReg src, vReg shuffle, vReg tmp) %{\n+   predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) != T_BYTE);\n+   match(Set dst (VectorRearrange src shuffle));\n+   effect(TEMP_DEF dst, TEMP tmp);\n+   format %{ \"rearrange_HSD_neon $dst, $src, $shuffle\\t# vector (4H/8H/2S/4S/2D). KILL $tmp\" %}\n+   ins_encode %{\n+     BasicType bt = Matcher::vector_element_basic_type(this);\n+     uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+     assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+     __ neon_rearrange_hsd($dst$$FloatRegister, $src$$FloatRegister,\n+                           $shuffle$$FloatRegister, $tmp$$FloatRegister,\n+                           bt, length_in_bytes == 16);\n+   %}\n+   ins_pipe(pipe_slow);\n+%}\n\n-      case Op_VectorLoadShuffle:\n-      case Op_VectorRearrange:\n-        if (vlen < 4) {\n-          return false;\n-        }\n-        break;", "target": "- instruct rearrange_HS_neon(vReg dst, vReg src, vReg shuffle, vReg tmp1, vReg tmp2) %{\n  predicate(UseSVE == 0 &&\n            (Matcher::vector_element_basic_type(n) == T_SHORT ||\n             (type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 &&\n              Matcher::vector_length_in_bytes(n) == 16)));\n  match(Set dst (VectorRearrange src shuffle));\n  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n  format %{ \"rearrange_HS_neon $dst, $src, $shuffle\\t# vector (4S/8S/4I/4F). KILL $tmp1, $tmp2\" %}\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    if (bt == T_SHORT) {\n      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n      assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n      Assembler::SIMD_Arrangement size1 = length_in_bytes == 16 ? __ T16B : __ T8B;\n      Assembler::SIMD_Arrangement size2 = length_in_bytes == 16 ? __ T8H : __ T4H;\n      __ mov($tmp1$$FloatRegister, size1, 0x02);\n      __ mov($tmp2$$FloatRegister, size2, 0x0100);\n      __ mulv($dst$$FloatRegister, size2, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n      __ addv($dst$$FloatRegister, size1, $dst$$FloatRegister, $tmp2$$FloatRegister);\n      __ tbl($dst$$FloatRegister, size1, $src$$FloatRegister, 1, $dst$$FloatRegister);\n    } else {\n      assert(bt == T_INT || bt == T_FLOAT, \"unsupported type\");\n      __ mov($tmp1$$FloatRegister, __ T16B, 0x04);\n      __ mov($tmp2$$FloatRegister, __ T4S, 0x03020100);\n      __ mulv($dst$$FloatRegister, __ T4S, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n      __ addv($dst$$FloatRegister, __ T16B, $dst$$FloatRegister, $tmp2$$FloatRegister);\n      __ tbl($dst$$FloatRegister, __ T16B, $src$$FloatRegister, 1, $dst$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}\n\n+ instruct rearrange_HSD_neon(vReg dst, vReg src, vReg shuffle, vReg tmp) %{\n+   predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) != T_BYTE);\n+   match(Set dst (VectorRearrange src shuffle));\n+   effect(TEMP_DEF dst, TEMP tmp);\n+   format %{ \"rearrange_HSD_neon $dst, $src, $shuffle\\t# vector (4H/8H/2S/4S/2D). KILL $tmp\" %}\n+   ins_encode %{\n+     BasicType bt = Matcher::vector_element_basic_type(this);\n+     uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+     assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+     __ neon_rearrange_hsd($dst$$FloatRegister, $src$$FloatRegister,\n+                           $shuffle$$FloatRegister, $tmp$$FloatRegister,\n+                           bt, length_in_bytes == 16);\n+   %}\n+   ins_pipe(pipe_slow);\n+%}\n\n-      case Op_VectorLoadShuffle:\n-      case Op_VectorRearrange:\n-        if (vlen < 4) {\n-          return false;\n-        }\n-        break;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AArch64架构的NEON向量重排指令仅支持4个或更多通道的向量（vlen >= 4），对于短向量（如2个元素的double向量）无法生成重排指令，导致性能下降。优化后：1. 移除了vlen < 4的限制，允许小通道数向量使用重排操作；2. 将原有的rearrange_HS_neon指令重构为rearrange_HSD_neon，支持更广泛的向量类型（包括half-word、single-word和double-word）；3. 通过新的neon_rearrange_hsd宏实现更简洁高效的向量重排逻辑。优化思路：扩展向量重排指令的支持范围，特别是针对小向量场景，通过重构指令实现和移除不必要的限制，提升向量化代码的性能和兼容性。"}
{"id": 464, "source": "riscv-dataset-excel", "optimization_type": "向量化指令优化", "optimization_description": "优化前：AArch64后端缺少对无符号和饱和向量操作（SaturatingAddV/SaturatingSubV）的硬件指令支持，这些操作需要通过软件模拟实现，性能较低。优化后：为AArch64架构添加了后端实现，包括有符号/无符号的饱和加法和饱和减法指令（vsqadd/vuqadd/vsqsub/vuqsub），支持NEON和SVE指令集，能够直接映射到硬件指令。优化思路：利用AArch64的向量指令集特性，为新的向量操作添加后端匹配规则，当编译器遇到SaturatingAddV/SaturatingSubV节点时，可以直接生成对应的硬件指令，避免了软件模拟的开销，显著提升了向量饱和运算的性能。", "original_code": "AArch64后端缺少对无符号和饱和向量操作（SaturatingAddV/SaturatingSubV）的硬件指令支持，这些操作需要通过软件模拟实现，性能较低。", "optimized_code": "instruct vsqadd(vReg dst, vReg src1, vReg src2) %{\n  predicate(!n->as_SaturatingVector()->is_unsigned());\n  match(Set dst (SaturatingAddV src1 src2));\n  format %{ \"vsqadd $dst, $src1, $src2\" %}\n  ins_encode %{\n    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n      __ sqaddv($dst$$FloatRegister, get_arrangement(this),\n                $src1$$FloatRegister, $src2$$FloatRegister);\n    } else {\n      assert(UseSVE > 0, \"must be sve\");\n      BasicType bt = Matcher::vector_element_basic_type(this);\n      __ sve_sqadd($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n                   $src1$$FloatRegister, $src2$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}\n\ninstruct vuqadd(vReg dst, vReg src1, vReg src2) %{\n  predicate(n->as_SaturatingVector()->is_unsigned());\n  match(Set dst (SaturatingAddV src1 src2));\n  format %{ \"vuqadd $dst, $src1, $src2\" %}\n  ins_encode %{\n    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n      __ uqaddv($dst$$FloatRegister, get_arrangement(this),\n                $src1$$FloatRegister, $src2$$FloatRegister);\n    } else {\n      assert(UseSVE > 0, \"must be sve\");\n      BasicType bt = Matcher::vector_element_basic_type(this);\n      __ sve_uqadd($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n                   $src1$$FloatRegister, $src2$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}\n\ninstruct vsqsub(vReg dst, vReg src1, vReg src2) %{\n  predicate(!n->as_SaturatingVector()->is_unsigned());\n  match(Set dst (SaturatingSubV src1 src2));\n  format %{ \"vsqsub $dst, $src1, $src2\" %}\n  ins_encode %{\n    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n      __ sqsubv($dst$$FloatRegister, get_arrangement(this),\n                $src1$$FloatRegister, $src2$$FloatRegister);\n    } else {\n      assert(UseSVE > 0, \"must be sve\");\n      BasicType bt = Matcher::vector_element_basic_type(this);\n      __ sve_sqsub($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n                   $src1$$FloatRegister, $src2$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}\n\ninstruct vuqsub(vReg dst, vReg src1, vReg src2) %{\n  predicate(n->as_SaturatingVector()->is_unsigned());\n  match(Set dst (SaturatingSubV src1 src2));\n  format %{ \"vuqsub $dst, $src1, $src2\" %}\n  ins_encode %{\n    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n      __ uqsubv($dst$$FloatRegister, get_arrangement(this),\n                $src1$$FloatRegister, $src2$$FloatRegister);\n    } else {\n      assert(UseSVE > 0, \"must be sve\");\n      BasicType bt = Matcher::vector_element_basic_type(this);\n      __ sve_uqsub($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n                   $src1$$FloatRegister, $src2$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}", "source_url": "https://github.com/openjdk/riscv-port/commit/ba658a71ba4372b42a496edee55400f5014815d4", "code_v0_no_empty_lines": "AArch64后端缺少对无符号和饱和向量操作（SaturatingAddV/SaturatingSubV）的硬件指令支持，这些操作需要通过软件模拟实现，性能较低。", "code_v1_no_empty_lines": "instruct vsqadd(vReg dst, vReg src1, vReg src2) %{\n  predicate(!n->as_SaturatingVector()->is_unsigned());\n  match(Set dst (SaturatingAddV src1 src2));\n  format %{ \"vsqadd $dst, $src1, $src2\" %}\n  ins_encode %{\n    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n      __ sqaddv($dst$$FloatRegister, get_arrangement(this),\n                $src1$$FloatRegister, $src2$$FloatRegister);\n    } else {\n      assert(UseSVE > 0, \"must be sve\");\n      BasicType bt = Matcher::vector_element_basic_type(this);\n      __ sve_sqadd($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n                   $src1$$FloatRegister, $src2$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}\n\ninstruct vuqadd(vReg dst, vReg src1, vReg src2) %{\n  predicate(n->as_SaturatingVector()->is_unsigned());\n  match(Set dst (SaturatingAddV src1 src2));\n  format %{ \"vuqadd $dst, $src1, $src2\" %}\n  ins_encode %{\n    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n      __ uqaddv($dst$$FloatRegister, get_arrangement(this),\n                $src1$$FloatRegister, $src2$$FloatRegister);\n    } else {\n      assert(UseSVE > 0, \"must be sve\");\n      BasicType bt = Matcher::vector_element_basic_type(this);\n      __ sve_uqadd($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n                   $src1$$FloatRegister, $src2$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}\n\ninstruct vsqsub(vReg dst, vReg src1, vReg src2) %{\n  predicate(!n->as_SaturatingVector()->is_unsigned());\n  match(Set dst (SaturatingSubV src1 src2));\n  format %{ \"vsqsub $dst, $src1, $src2\" %}\n  ins_encode %{\n    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n      __ sqsubv($dst$$FloatRegister, get_arrangement(this),\n                $src1$$FloatRegister, $src2$$FloatRegister);\n    } else {\n      assert(UseSVE > 0, \"must be sve\");\n      BasicType bt = Matcher::vector_element_basic_type(this);\n      __ sve_sqsub($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n                   $src1$$FloatRegister, $src2$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}\n\ninstruct vuqsub(vReg dst, vReg src1, vReg src2) %{\n  predicate(n->as_SaturatingVector()->is_unsigned());\n  match(Set dst (SaturatingSubV src1 src2));\n  format %{ \"vuqsub $dst, $src1, $src2\" %}\n  ins_encode %{\n    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n      __ uqsubv($dst$$FloatRegister, get_arrangement(this),\n                $src1$$FloatRegister, $src2$$FloatRegister);\n    } else {\n      assert(UseSVE > 0, \"must be sve\");\n      BasicType bt = Matcher::vector_element_basic_type(this);\n      __ sve_uqsub($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n                   $src1$$FloatRegister, $src2$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}", "target": "instruct vsqadd(vReg dst, vReg src1, vReg src2) %{\n  predicate(!n->as_SaturatingVector()->is_unsigned());\n  match(Set dst (SaturatingAddV src1 src2));\n  format %{ \"vsqadd $dst, $src1, $src2\" %}\n  ins_encode %{\n    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n      __ sqaddv($dst$$FloatRegister, get_arrangement(this),\n                $src1$$FloatRegister, $src2$$FloatRegister);\n    } else {\n      assert(UseSVE > 0, \"must be sve\");\n      BasicType bt = Matcher::vector_element_basic_type(this);\n      __ sve_sqadd($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n                   $src1$$FloatRegister, $src2$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}\n\ninstruct vuqadd(vReg dst, vReg src1, vReg src2) %{\n  predicate(n->as_SaturatingVector()->is_unsigned());\n  match(Set dst (SaturatingAddV src1 src2));\n  format %{ \"vuqadd $dst, $src1, $src2\" %}\n  ins_encode %{\n    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n      __ uqaddv($dst$$FloatRegister, get_arrangement(this),\n                $src1$$FloatRegister, $src2$$FloatRegister);\n    } else {\n      assert(UseSVE > 0, \"must be sve\");\n      BasicType bt = Matcher::vector_element_basic_type(this);\n      __ sve_uqadd($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n                   $src1$$FloatRegister, $src2$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}\n\ninstruct vsqsub(vReg dst, vReg src1, vReg src2) %{\n  predicate(!n->as_SaturatingVector()->is_unsigned());\n  match(Set dst (SaturatingSubV src1 src2));\n  format %{ \"vsqsub $dst, $src1, $src2\" %}\n  ins_encode %{\n    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n      __ sqsubv($dst$$FloatRegister, get_arrangement(this),\n                $src1$$FloatRegister, $src2$$FloatRegister);\n    } else {\n      assert(UseSVE > 0, \"must be sve\");\n      BasicType bt = Matcher::vector_element_basic_type(this);\n      __ sve_sqsub($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n                   $src1$$FloatRegister, $src2$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}\n\ninstruct vuqsub(vReg dst, vReg src1, vReg src2) %{\n  predicate(n->as_SaturatingVector()->is_unsigned());\n  match(Set dst (SaturatingSubV src1 src2));\n  format %{ \"vuqsub $dst, $src1, $src2\" %}\n  ins_encode %{\n    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n      __ uqsubv($dst$$FloatRegister, get_arrangement(this),\n                $src1$$FloatRegister, $src2$$FloatRegister);\n    } else {\n      assert(UseSVE > 0, \"must be sve\");\n      BasicType bt = Matcher::vector_element_basic_type(this);\n      __ sve_uqsub($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n                   $src1$$FloatRegister, $src2$$FloatRegister);\n    }\n  %}\n  ins_pipe(pipe_slow);\n%}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AArch64后端缺少对无符号和饱和向量操作（SaturatingAddV/SaturatingSubV）的硬件指令支持，这些操作需要通过软件模拟实现，性能较低。优化后：为AArch64架构添加了后端实现，包括有符号/无符号的饱和加法和饱和减法指令（vsqadd/vuqadd/vsqsub/vuqsub），支持NEON和SVE指令集，能够直接映射到硬件指令。优化思路：利用AArch64的向量指令集特性，为新的向量操作添加后端匹配规则，当编译器遇到SaturatingAddV/SaturatingSubV节点时，可以直接生成对应的硬件指令，避免了软件模拟的开销，显著提升了向量饱和运算的性能。"}
{"id": 465, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+代码大小优化", "optimization_description": "优化前：使用通用emit_arith函数处理APX NDD指令的立即数编码，导致EVEX编码开销较大。优化后：新增emit_arith_ndd专用函数，针对8位立即数使用紧凑的3字节编码（通过设置符号位），相比标准编码节省3字节；针对32位立即数保持原有编码。优化思路：通过专用编码函数减少指令大小，提高代码缓存友好性，抵消EVEX编码带来的额外开销，提升APX NDD指令生成效率。", "original_code": "使用通用emit_arith函数处理APX NDD指令的立即数编码，导致EVEX编码开销较大。", "optimized_code": "+void Assembler::emit_arith_ndd(int op1, int op2, Register dst, int32_t imm32) {\n+  assert(isByte(op1) && isByte(op2), \"wrong opcode\");\n+  assert(op1 == 0x81, \"Unexpected opcode\");\n+  // This code cache friendly optimization saves 3 bytes per encoding, which offsets the EVEX encoding penalty.\n+  if (is8bit(imm32)) {\n+    emit_int24(op1 | 0x02,        // set sign bit\n+               op2 | encode(dst),\n+               imm32 & 0xFF);\n+  }\n+  else {\n+    emit_int16(op1, (op2 | encode(dst)));\n+    emit_int32(imm32);\n+  }\n+}\n\n-  emit_arith(0x81, 0xC0, src, imm32);\n+  emit_arith_ndd(0x81, 0xC0, src, imm32);", "source_url": "https://github.com/openjdk/riscv-port/commit/c87e1be0526fdd656bf0601542db6b92ccea567f", "code_v0_no_empty_lines": "使用通用emit_arith函数处理APX NDD指令的立即数编码，导致EVEX编码开销较大。", "code_v1_no_empty_lines": "+void Assembler::emit_arith_ndd(int op1, int op2, Register dst, int32_t imm32) {\n+  assert(isByte(op1) && isByte(op2), \"wrong opcode\");\n+  assert(op1 == 0x81, \"Unexpected opcode\");\n+  // This code cache friendly optimization saves 3 bytes per encoding, which offsets the EVEX encoding penalty.\n+  if (is8bit(imm32)) {\n+    emit_int24(op1 | 0x02,        // set sign bit\n+               op2 | encode(dst),\n+               imm32 & 0xFF);\n+  }\n+  else {\n+    emit_int16(op1, (op2 | encode(dst)));\n+    emit_int32(imm32);\n+  }\n+}\n\n-  emit_arith(0x81, 0xC0, src, imm32);\n+  emit_arith_ndd(0x81, 0xC0, src, imm32);", "target": "+void Assembler::emit_arith_ndd(int op1, int op2, Register dst, int32_t imm32) {\n+  assert(isByte(op1) && isByte(op2), \"wrong opcode\");\n+  assert(op1 == 0x81, \"Unexpected opcode\");\n+  // This code cache friendly optimization saves 3 bytes per encoding, which offsets the EVEX encoding penalty.\n+  if (is8bit(imm32)) {\n+    emit_int24(op1 | 0x02,        // set sign bit\n+               op2 | encode(dst),\n+               imm32 & 0xFF);\n+  }\n+  else {\n+    emit_int16(op1, (op2 | encode(dst)));\n+    emit_int32(imm32);\n+  }\n+}\n\n-  emit_arith(0x81, 0xC0, src, imm32);\n+  emit_arith_ndd(0x81, 0xC0, src, imm32);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用通用emit_arith函数处理APX NDD指令的立即数编码，导致EVEX编码开销较大。优化后：新增emit_arith_ndd专用函数，针对8位立即数使用紧凑的3字节编码（通过设置符号位），相比标准编码节省3字节；针对32位立即数保持原有编码。优化思路：通过专用编码函数减少指令大小，提高代码缓存友好性，抵消EVEX编码带来的额外开销，提升APX NDD指令生成效率。"}
{"id": 466, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+类型系统修复", "optimization_description": "优化前：在数组填充优化中，使用store->as_Mem()->memory_type()获取内存类型，这可能导致类型不匹配，特别是在处理内存段初始化等场景时，会错误地为内部调用分配类型。优化后：改为使用store->adr_type()->isa_aryptr()->elem()->array_element_basic_type()获取数组元素的基本类型，确保类型正确性。思路：修复了数组填充优化中的类型推导逻辑，避免因类型不匹配导致的错误内部调用，同时添加了对不匹配存储的检查，提高了优化的正确性和可靠性。", "original_code": "在数组填充优化中，使用store->as_Mem()->memory_type()获取内存类型，这可能导致类型不匹配，特别是在处理内存段初始化等场景时，会错误地为内部调用分配类型。", "optimized_code": "- BasicType t = store->as_Mem()->memory_type();\n+ BasicType t = msg == nullptr ?\n    store->adr_type()->isa_aryptr()->elem()->array_element_basic_type() : T_VOID;", "source_url": "https://github.com/openjdk/riscv-port/commit/de580090cd9ada313a878975b9f183045d293684", "code_v0_no_empty_lines": "在数组填充优化中，使用store->as_Mem()->memory_type()获取内存类型，这可能导致类型不匹配，特别是在处理内存段初始化等场景时，会错误地为内部调用分配类型。", "code_v1_no_empty_lines": "- BasicType t = store->as_Mem()->memory_type();\n+ BasicType t = msg == nullptr ?\n    store->adr_type()->isa_aryptr()->elem()->array_element_basic_type() : T_VOID;", "target": "- BasicType t = store->as_Mem()->memory_type();\n+ BasicType t = msg == nullptr ?\n    store->adr_type()->isa_aryptr()->elem()->array_element_basic_type() : T_VOID;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在数组填充优化中，使用store->as_Mem()->memory_type()获取内存类型，这可能导致类型不匹配，特别是在处理内存段初始化等场景时，会错误地为内部调用分配类型。优化后：改为使用store->adr_type()->isa_aryptr()->elem()->array_element_basic_type()获取数组元素的基本类型，确保类型正确性。思路：修复了数组填充优化中的类型推导逻辑，避免因类型不匹配导致的错误内部调用，同时添加了对不匹配存储的检查，提高了优化的正确性和可靠性。"}
{"id": 467, "source": "riscv-dataset-excel", "optimization_type": "测试框架功能增强", "optimization_description": "优化前：CompileFramework的编译方法不支持传递额外的javac编译参数，限制了测试框架的功能性，特别是对于需要特殊编译选项（如VectorAPI）的测试场景。优化后：1. 在compileJavaSources和compileJavaFiles方法中添加javacFlags参数，允许传递额外的javac编译标志；2. 修改编译错误检测逻辑，仅根据退出码判断编译失败，忽略警告输出；3. 在CompileFramework.compile方法中添加可变参数支持，使测试代码可以传递编译选项。优化思路：通过参数化编译过程，增强测试框架的灵活性，使其能够支持需要特殊编译选项的测试用例（如VectorAPI测试），同时改进错误处理逻辑以避免误报。", "original_code": "CompileFramework的编译方法不支持传递额外的javac编译参数，限制了测试框架的功能性，特别是对于需要特殊编译选项（如VectorAPI）的测试场景。", "optimized_code": "-    public static void compileJavaSources(List<SourceCode> javaSources, Path sourceDir, Path classesDir) {\n+    public static void compileJavaSources(List<SourceCode> javaSources, Path sourceDir, Path classesDir, String[] javacFlags) {\n-        compileJavaFiles(javaFilePaths, classesDir);\n+        compileJavaFiles(javaFilePaths, classesDir, javacFlags);\n-    private static void compileJavaFiles(List<Path> paths, Path classesDir) {\n+    private static void compileJavaFiles(List<Path> paths, Path classesDir, String[] javacFlags) {\n+        if (javacFlags != null) {\n+            command.addAll(Arrays.asList(javacFlags));\n+        }\n-        if (exitCode != 0 || !output.isEmpty()) {\n+        // Note: the output can be non-empty even if the compilation succeeds, e.g. for warnings.\n+        if (exitCode != 0) {\n-    public void compile() {\n+    public void compile(String... javacFlags) {\n-        Compile.compileJavaSources(javaSources, sourceDir, classesDir);\n+        Compile.compileJavaSources(javaSources, sourceDir, classesDir, javacFlags);", "source_url": "https://github.com/openjdk/riscv-port/commit/3ed010ab7cf5b8c9bf8fa000e88ea95285351982", "code_v0_no_empty_lines": "CompileFramework的编译方法不支持传递额外的javac编译参数，限制了测试框架的功能性，特别是对于需要特殊编译选项（如VectorAPI）的测试场景。", "code_v1_no_empty_lines": "-    public static void compileJavaSources(List<SourceCode> javaSources, Path sourceDir, Path classesDir) {\n+    public static void compileJavaSources(List<SourceCode> javaSources, Path sourceDir, Path classesDir, String[] javacFlags) {\n-        compileJavaFiles(javaFilePaths, classesDir);\n+        compileJavaFiles(javaFilePaths, classesDir, javacFlags);\n-    private static void compileJavaFiles(List<Path> paths, Path classesDir) {\n+    private static void compileJavaFiles(List<Path> paths, Path classesDir, String[] javacFlags) {\n+        if (javacFlags != null) {\n+            command.addAll(Arrays.asList(javacFlags));\n+        }\n-        if (exitCode != 0 || !output.isEmpty()) {\n+        // Note: the output can be non-empty even if the compilation succeeds, e.g. for warnings.\n+        if (exitCode != 0) {\n-    public void compile() {\n+    public void compile(String... javacFlags) {\n-        Compile.compileJavaSources(javaSources, sourceDir, classesDir);\n+        Compile.compileJavaSources(javaSources, sourceDir, classesDir, javacFlags);", "target": "-    public static void compileJavaSources(List<SourceCode> javaSources, Path sourceDir, Path classesDir) {\n+    public static void compileJavaSources(List<SourceCode> javaSources, Path sourceDir, Path classesDir, String[] javacFlags) {\n-        compileJavaFiles(javaFilePaths, classesDir);\n+        compileJavaFiles(javaFilePaths, classesDir, javacFlags);\n-    private static void compileJavaFiles(List<Path> paths, Path classesDir) {\n+    private static void compileJavaFiles(List<Path> paths, Path classesDir, String[] javacFlags) {\n+        if (javacFlags != null) {\n+            command.addAll(Arrays.asList(javacFlags));\n+        }\n-        if (exitCode != 0 || !output.isEmpty()) {\n+        // Note: the output can be non-empty even if the compilation succeeds, e.g. for warnings.\n+        if (exitCode != 0) {\n-    public void compile() {\n+    public void compile(String... javacFlags) {\n-        Compile.compileJavaSources(javaSources, sourceDir, classesDir);\n+        Compile.compileJavaSources(javaSources, sourceDir, classesDir, javacFlags);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CompileFramework的编译方法不支持传递额外的javac编译参数，限制了测试框架的功能性，特别是对于需要特殊编译选项（如VectorAPI）的测试场景。优化后：1. 在compileJavaSources和compileJavaFiles方法中添加javacFlags参数，允许传递额外的javac编译标志；2. 修改编译错误检测逻辑，仅根据退出码判断编译失败，忽略警告输出；3. 在CompileFramework.compile方法中添加可变参数支持，使测试代码可以传递编译选项。优化思路：通过参数化编译过程，增强测试框架的灵活性，使其能够支持需要特殊编译选项的测试用例（如VectorAPI测试），同时改进错误处理逻辑以避免误报。"}
{"id": 468, "source": "riscv-dataset-excel", "optimization_type": "GC性能优化+并发优化", "optimization_description": "优化前：在Shenandoah GC的并发收集周期中，final roots阶段需要全局安全点（safepoint），这会暂停所有应用线程，导致停顿。优化后：通过引入ShenandoahFlushSATBHandshakeClosure和重构并发逻辑，将final roots阶段改为并发执行，无需全局安全点。优化思路：利用handshake机制在线程间协调，在并发更新引用阶段处理SATB队列刷新，消除安全点停顿，提升GC并发性和应用响应性。", "original_code": "在Shenandoah GC的并发收集周期中，final roots阶段需要全局安全点（safepoint），这会暂停所有应用线程，导致停顿。", "optimized_code": "-    vmop_entry_final_roots();\n+    if (!entry_final_roots()) {\n+      assert(_degen_point != _degenerated_unset, \"Need to know where to start degenerated cycle\");\n+      return false;\n+    }\n+\n+    if (VerifyAfterGC) {\n+      vmop_entry_verify_final_roots();\n+    }", "source_url": "https://github.com/openjdk/riscv-port/commit/8a1c85eaa902500d49ca82c67b6838d39cb5b24f", "code_v0_no_empty_lines": "在Shenandoah GC的并发收集周期中，final roots阶段需要全局安全点（safepoint），这会暂停所有应用线程，导致停顿。", "code_v1_no_empty_lines": "-    vmop_entry_final_roots();\n+    if (!entry_final_roots()) {\n+      assert(_degen_point != _degenerated_unset, \"Need to know where to start degenerated cycle\");\n+      return false;\n+    }\n+\n+    if (VerifyAfterGC) {\n+      vmop_entry_verify_final_roots();\n+    }", "target": "-    vmop_entry_final_roots();\n+    if (!entry_final_roots()) {\n+      assert(_degen_point != _degenerated_unset, \"Need to know where to start degenerated cycle\");\n+      return false;\n+    }\n+\n+    if (VerifyAfterGC) {\n+      vmop_entry_verify_final_roots();\n+    }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在Shenandoah GC的并发收集周期中，final roots阶段需要全局安全点（safepoint），这会暂停所有应用线程，导致停顿。优化后：通过引入ShenandoahFlushSATBHandshakeClosure和重构并发逻辑，将final roots阶段改为并发执行，无需全局安全点。优化思路：利用handshake机制在线程间协调，在并发更新引用阶段处理SATB队列刷新，消除安全点停顿，提升GC并发性和应用响应性。"}
{"id": 469, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "优化前：仅在CPU型号为ARM时默认启用UseSignumIntrinsic。优化后：根据CPU是否支持浮点(FP)或SIMD(ASIMD)指令集来启用该优化，并移除了对特定CPU型号的限制。思路：扩大优化适用范围，使更多支持必要指令集的AArch64处理器能利用signum函数的内联优化，提升数学运算性能。", "original_code": "仅在CPU型号为ARM时默认启用UseSignumIntrinsic。", "optimized_code": "-  if (_cpu == CPU_ARM) {\n+  if (_features & (CPU_FP | CPU_ASIMD)) {\n     if (FLAG_IS_DEFAULT(UseSignumIntrinsic)) {\n       FLAG_SET_DEFAULT(UseSignumIntrinsic, true);\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/b025d8c2e062210b6148da43f11517666b0b4932", "code_v0_no_empty_lines": "仅在CPU型号为ARM时默认启用UseSignumIntrinsic。", "code_v1_no_empty_lines": "-  if (_cpu == CPU_ARM) {\n+  if (_features & (CPU_FP | CPU_ASIMD)) {\n     if (FLAG_IS_DEFAULT(UseSignumIntrinsic)) {\n       FLAG_SET_DEFAULT(UseSignumIntrinsic, true);\n     }", "target": "-  if (_cpu == CPU_ARM) {\n+  if (_features & (CPU_FP | CPU_ASIMD)) {\n     if (FLAG_IS_DEFAULT(UseSignumIntrinsic)) {\n       FLAG_SET_DEFAULT(UseSignumIntrinsic, true);\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：仅在CPU型号为ARM时默认启用UseSignumIntrinsic。优化后：根据CPU是否支持浮点(FP)或SIMD(ASIMD)指令集来启用该优化，并移除了对特定CPU型号的限制。思路：扩大优化适用范围，使更多支持必要指令集的AArch64处理器能利用signum函数的内联优化，提升数学运算性能。"}
{"id": 470, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（C2成本估算优化）", "optimization_description": "优化前：G1预屏障的成本估算使用固定值50个节点，这个值是从早期屏障扩展的理想图中提取的，但包含了不必要的开销估算。优化后：仅考虑实际内联到主代码流中的快速路径成本（6个节点），慢速路径单独布局不影响性能。优化思路：更精确地估算屏障成本，避免过度惩罚预屏障操作，从而提高C2编译器对G1垃圾收集器屏障的性能评估准确性。", "original_code": "G1预屏障的成本估算使用固定值50个节点，这个值是从早期屏障扩展的理想图中提取的，但包含了不必要的开销估算。", "optimized_code": "-    nodes += 50;\n+    // Only consider the fast path for the barrier that is\n+    // actually inlined into the main code stream.\n+    // The slow path is laid out separately and does not\n+    // directly affect performance.\n+    // It has a cost of 6 (AddP, LoadB, Cmp, Bool, If, IfProj).\n+    nodes += 6;", "source_url": "https://github.com/openjdk/riscv-port/commit/9f8d833f8654cb4280d002ef86ce3ae9d709eddc", "code_v0_no_empty_lines": "G1预屏障的成本估算使用固定值50个节点，这个值是从早期屏障扩展的理想图中提取的，但包含了不必要的开销估算。", "code_v1_no_empty_lines": "-    nodes += 50;\n+    // Only consider the fast path for the barrier that is\n+    // actually inlined into the main code stream.\n+    // The slow path is laid out separately and does not\n+    // directly affect performance.\n+    // It has a cost of 6 (AddP, LoadB, Cmp, Bool, If, IfProj).\n+    nodes += 6;", "target": "-    nodes += 50;\n+    // Only consider the fast path for the barrier that is\n+    // actually inlined into the main code stream.\n+    // The slow path is laid out separately and does not\n+    // directly affect performance.\n+    // It has a cost of 6 (AddP, LoadB, Cmp, Bool, If, IfProj).\n+    nodes += 6;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：G1预屏障的成本估算使用固定值50个节点，这个值是从早期屏障扩展的理想图中提取的，但包含了不必要的开销估算。优化后：仅考虑实际内联到主代码流中的快速路径成本（6个节点），慢速路径单独布局不影响性能。优化思路：更精确地估算屏障成本，避免过度惩罚预屏障操作，从而提高C2编译器对G1垃圾收集器屏障的性能评估准确性。"}
{"id": 471, "source": "riscv-dataset-excel", "optimization_type": "内存优化+延迟初始化", "optimization_description": "优化前：ZLiveMap在构造函数中立即初始化_bitmap，即使页面可能从未被标记（即从未有存活对象）。这导致不必要的内存分配和初始化开销。优化后：引入_bitmap_size字段存储位图大小，将_bitmap初始化为空，并添加allocate_bitmap()方法。位图仅在首次需要设置位时（即页面首次被标记时）才延迟初始化。这减少了内存占用和初始化开销，特别是对于可能从未使用的页面，提升了ZGC垃圾收集器的性能。", "original_code": "ZLiveMap在构造函数中立即初始化_bitmap，即使页面可能从未被标记（即从未有存活对象）。这导致不必要的内存分配和初始化开销。", "optimized_code": "-    _bitmap(bitmap_size(size, NumSegments)),\n+    _bitmap_size(bitmap_size(size, NumSegments)),\n+    _bitmap(0),\n+void ZLiveMap::allocate_bitmap() {\n+  if (_bitmap.size() != _bitmap_size) {\n+    _bitmap.initialize(_bitmap_size, false /* clear */);\n+  }\n+}\n+      // We lazily initialize the bitmap the first time the page is\n+      // marked, i.e. a bit is about to be set for the first time.\n+      allocate_bitmap();", "source_url": "https://github.com/openjdk/riscv-port/commit/2672c40bf10a6597ae861e2183e7558ffed43dba", "code_v0_no_empty_lines": "ZLiveMap在构造函数中立即初始化_bitmap，即使页面可能从未被标记（即从未有存活对象）。这导致不必要的内存分配和初始化开销。", "code_v1_no_empty_lines": "-    _bitmap(bitmap_size(size, NumSegments)),\n+    _bitmap_size(bitmap_size(size, NumSegments)),\n+    _bitmap(0),\n+void ZLiveMap::allocate_bitmap() {\n+  if (_bitmap.size() != _bitmap_size) {\n+    _bitmap.initialize(_bitmap_size, false /* clear */);\n+  }\n+}\n+      // We lazily initialize the bitmap the first time the page is\n+      // marked, i.e. a bit is about to be set for the first time.\n+      allocate_bitmap();", "target": "-    _bitmap(bitmap_size(size, NumSegments)),\n+    _bitmap_size(bitmap_size(size, NumSegments)),\n+    _bitmap(0),\n+void ZLiveMap::allocate_bitmap() {\n+  if (_bitmap.size() != _bitmap_size) {\n+    _bitmap.initialize(_bitmap_size, false /* clear */);\n+  }\n+}\n+      // We lazily initialize the bitmap the first time the page is\n+      // marked, i.e. a bit is about to be set for the first time.\n+      allocate_bitmap();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ZLiveMap在构造函数中立即初始化_bitmap，即使页面可能从未被标记（即从未有存活对象）。这导致不必要的内存分配和初始化开销。优化后：引入_bitmap_size字段存储位图大小，将_bitmap初始化为空，并添加allocate_bitmap()方法。位图仅在首次需要设置位时（即页面首次被标记时）才延迟初始化。这减少了内存占用和初始化开销，特别是对于可能从未使用的页面，提升了ZGC垃圾收集器的性能。"}
{"id": 472, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+性能优化", "optimization_description": "优化前：浮点数最大值/最小值操作（MaxF/MinF/MaxD/MinD）使用通用指令序列实现，需要多个指令和标志寄存器操作。优化后：当检测到RISC-V Zfa扩展可用时，使用专门的fminm/fmaxm指令（单精度fminm_s/fmaxm_s和双精度fminm_d/fmaxm_d）直接完成浮点数最大值/最小值计算。优化思路：利用RISC-V Zfa扩展的新指令，将原本需要多个指令的浮点数比较操作简化为单条指令，减少指令数量，避免标志寄存器操作，提高浮点运算性能。", "original_code": "浮点数最大值/最小值操作（MaxF/MinF/MaxD/MinD）使用通用指令序列实现，需要多个指令和标志寄存器操作。", "optimized_code": "void fminm_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n    assert_cond(UseZfa);\n    fp_base<S_32_sp, 0b00101>(Rd, Rs1, Rs2, 0b010);\n  }\n\n  void fmaxm_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n    assert_cond(UseZfa);\n    fp_base<S_32_sp, 0b00101>(Rd, Rs1, Rs2, 0b011);\n  }\n\n  void fminm_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n    assert_cond(UseZfa);\n    fp_base<D_64_dp, 0b00101>(Rd, Rs1, Rs2, 0b010);\n  }\n\n  void fmaxm_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n    assert_cond(UseZfa);\n    fp_base<D_64_dp, 0b00101>(Rd, Rs1, Rs2, 0b011);\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/a7a09f69abc6c4730599d3de9067c2fde75c5172", "code_v0_no_empty_lines": "浮点数最大值/最小值操作（MaxF/MinF/MaxD/MinD）使用通用指令序列实现，需要多个指令和标志寄存器操作。", "code_v1_no_empty_lines": "void fminm_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n    assert_cond(UseZfa);\n    fp_base<S_32_sp, 0b00101>(Rd, Rs1, Rs2, 0b010);\n  }\n\n  void fmaxm_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n    assert_cond(UseZfa);\n    fp_base<S_32_sp, 0b00101>(Rd, Rs1, Rs2, 0b011);\n  }\n\n  void fminm_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n    assert_cond(UseZfa);\n    fp_base<D_64_dp, 0b00101>(Rd, Rs1, Rs2, 0b010);\n  }\n\n  void fmaxm_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n    assert_cond(UseZfa);\n    fp_base<D_64_dp, 0b00101>(Rd, Rs1, Rs2, 0b011);\n  }", "target": "void fminm_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n    assert_cond(UseZfa);\n    fp_base<S_32_sp, 0b00101>(Rd, Rs1, Rs2, 0b010);\n  }\n\n  void fmaxm_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n    assert_cond(UseZfa);\n    fp_base<S_32_sp, 0b00101>(Rd, Rs1, Rs2, 0b011);\n  }\n\n  void fminm_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n    assert_cond(UseZfa);\n    fp_base<D_64_dp, 0b00101>(Rd, Rs1, Rs2, 0b010);\n  }\n\n  void fmaxm_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n    assert_cond(UseZfa);\n    fp_base<D_64_dp, 0b00101>(Rd, Rs1, Rs2, 0b011);\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：浮点数最大值/最小值操作（MaxF/MinF/MaxD/MinD）使用通用指令序列实现，需要多个指令和标志寄存器操作。优化后：当检测到RISC-V Zfa扩展可用时，使用专门的fminm/fmaxm指令（单精度fminm_s/fmaxm_s和双精度fminm_d/fmaxm_d）直接完成浮点数最大值/最小值计算。优化思路：利用RISC-V Zfa扩展的新指令，将原本需要多个指令的浮点数比较操作简化为单条指令，减少指令数量，避免标志寄存器操作，提高浮点运算性能。"}
{"id": 473, "source": "riscv-dataset-excel", "optimization_type": "内联优化+指令优化", "optimization_description": "优化前：Math.max(long,long)和Math.min(long,long)方法调用需要经过完整的Java方法调用开销，包括参数传递、栈帧管理等。优化后：通过新增_minL和_maxL内联函数，在C2编译器中将long类型的min/max调用直接转换为对应的MinLNode和MaxLNode中间表示节点，编译器可以进一步优化为底层硬件指令。优化思路：扩展现有的min/max内联框架，为long类型添加专门的内联处理路径，消除方法调用开销，利用编译器优化生成高效代码。", "original_code": "Math.max(long,long)和Math.min(long,long)方法调用需要经过完整的Java方法调用开销，包括参数传递、栈帧管理等。", "optimized_code": "case vmIntrinsics::_minL:\ncase vmIntrinsics::_maxL:\n  assert(callee()->signature()->size() == 4, \"minL/maxL has 2 parameters of size 2 each.\");\n  a = argument(0);\n  b = argument(2);\n  break;\n...\ncase vmIntrinsics::_minL:\n  n = new MinLNode(_gvn.C, a, b);\n  break;\ncase vmIntrinsics::_maxL:\n  n = new MaxLNode(_gvn.C, a, b);\n  break;", "source_url": "https://github.com/openjdk/riscv-port/commit/4e51a8c9ad4e5345d05cf32ce1e82b7158f80e93", "code_v0_no_empty_lines": "Math.max(long,long)和Math.min(long,long)方法调用需要经过完整的Java方法调用开销，包括参数传递、栈帧管理等。", "code_v1_no_empty_lines": "case vmIntrinsics::_minL:\ncase vmIntrinsics::_maxL:\n  assert(callee()->signature()->size() == 4, \"minL/maxL has 2 parameters of size 2 each.\");\n  a = argument(0);\n  b = argument(2);\n  break;\n...\ncase vmIntrinsics::_minL:\n  n = new MinLNode(_gvn.C, a, b);\n  break;\ncase vmIntrinsics::_maxL:\n  n = new MaxLNode(_gvn.C, a, b);\n  break;", "target": "case vmIntrinsics::_minL:\ncase vmIntrinsics::_maxL:\n  assert(callee()->signature()->size() == 4, \"minL/maxL has 2 parameters of size 2 each.\");\n  a = argument(0);\n  b = argument(2);\n  break;\n...\ncase vmIntrinsics::_minL:\n  n = new MinLNode(_gvn.C, a, b);\n  break;\ncase vmIntrinsics::_maxL:\n  n = new MaxLNode(_gvn.C, a, b);\n  break;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Math.max(long,long)和Math.min(long,long)方法调用需要经过完整的Java方法调用开销，包括参数传递、栈帧管理等。优化后：通过新增_minL和_maxL内联函数，在C2编译器中将long类型的min/max调用直接转换为对应的MinLNode和MaxLNode中间表示节点，编译器可以进一步优化为底层硬件指令。优化思路：扩展现有的min/max内联框架，为long类型添加专门的内联处理路径，消除方法调用开销，利用编译器优化生成高效代码。"}
{"id": 474, "source": "riscv-dataset-excel", "optimization_type": "内存分配优化+NUMA感知优化", "optimization_description": "优化前：函数参数顺序为(dest, word_size, node_index)，在NUMA迁移场景下可能导致node_index参数传递错误，引发内存分配崩溃。优化后：将node_index参数提前到word_size之前，统一所有相关函数的参数顺序为(dest, node_index, ...)，确保NUMA节点信息在调用链中正确传递。优化思路：通过调整参数顺序消除NUMA感知分配中的参数传递不一致问题，修复因NUMA迁移导致的内存分配崩溃。", "original_code": "函数参数顺序为(dest, word_size, node_index)，在NUMA迁移场景下可能导致node_index参数传递错误，引发内存分配崩溃。", "optimized_code": "-HeapWord* par_allocate_during_gc(G1HeapRegionAttr dest,\n-                                              size_t word_size,\n-                                              uint node_index) {\n+HeapWord* par_allocate_during_gc(G1HeapRegionAttr dest,\n+                                              uint node_index,\n+                                              size_t word_size) {\n\n-HeapWord* survivor_attempt_allocation(size_t min_word_size,\n+HeapWord* survivor_attempt_allocation(uint node_index,\n+                                                   size_t min_word_size,\n                                                    size_t desired_word_size,\n-                                                   size_t* actual_word_size,\n-                                                   uint node_index) {\n+                                                   size_t* actual_word_size) {", "source_url": "https://github.com/openjdk/riscv-port/commit/37ec796255ae857588a5c7e0d572407dd81cbec9", "code_v0_no_empty_lines": "函数参数顺序为(dest, word_size, node_index)，在NUMA迁移场景下可能导致node_index参数传递错误，引发内存分配崩溃。", "code_v1_no_empty_lines": "-HeapWord* par_allocate_during_gc(G1HeapRegionAttr dest,\n-                                              size_t word_size,\n-                                              uint node_index) {\n+HeapWord* par_allocate_during_gc(G1HeapRegionAttr dest,\n+                                              uint node_index,\n+                                              size_t word_size) {\n\n-HeapWord* survivor_attempt_allocation(size_t min_word_size,\n+HeapWord* survivor_attempt_allocation(uint node_index,\n+                                                   size_t min_word_size,\n                                                    size_t desired_word_size,\n-                                                   size_t* actual_word_size,\n-                                                   uint node_index) {\n+                                                   size_t* actual_word_size) {", "target": "-HeapWord* par_allocate_during_gc(G1HeapRegionAttr dest,\n-                                              size_t word_size,\n-                                              uint node_index) {\n+HeapWord* par_allocate_during_gc(G1HeapRegionAttr dest,\n+                                              uint node_index,\n+                                              size_t word_size) {\n\n-HeapWord* survivor_attempt_allocation(size_t min_word_size,\n+HeapWord* survivor_attempt_allocation(uint node_index,\n+                                                   size_t min_word_size,\n                                                    size_t desired_word_size,\n-                                                   size_t* actual_word_size,\n-                                                   uint node_index) {\n+                                                   size_t* actual_word_size) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：函数参数顺序为(dest, word_size, node_index)，在NUMA迁移场景下可能导致node_index参数传递错误，引发内存分配崩溃。优化后：将node_index参数提前到word_size之前，统一所有相关函数的参数顺序为(dest, node_index, ...)，确保NUMA节点信息在调用链中正确传递。优化思路：通过调整参数顺序消除NUMA感知分配中的参数传递不一致问题，修复因NUMA迁移导致的内存分配崩溃。"}
{"id": 475, "source": "riscv-dataset-excel", "optimization_type": "基准测试优化", "optimization_description": "优化前：WriteBarrier JMH基准测试仅包含老年代对象间的写屏障测试场景，缺少跨代引用场景的测试覆盖。优化后：新增了老年代到年轻代、年轻代到老年代、年轻代到年轻代等跨代引用场景的写屏障基准测试方法，并添加了相应的年轻代对象数组和引用字段。优化思路：通过扩展测试场景覆盖跨代引用情况，能够更全面地评估垃圾收集器中写屏障的性能特性，特别是针对不同代际间对象引用场景的优化效果。", "original_code": "WriteBarrier JMH基准测试仅包含老年代对象间的写屏障测试场景，缺少跨代引用场景的测试覆盖。", "optimized_code": "+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void testArrayWriteBarrierFastPathOldToYoungSmall() {\n+        for (int i = 0; i < NUM_REFERENCES_SMALL; i++) {\n+            youngArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = realRef;\n+        }\n+    }\n\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void testArrayWriteBarrierFastPathYoungToOldSmall() {\n+        for (int i = 0; i < NUM_REFERENCES_SMALL; i++) {\n+            theArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = youngRef;\n+        }\n+    }\n\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void testArrayWriteBarrierFastPathYoungToYoungSmall() {\n+        for (int i = 0; i < NUM_REFERENCES_SMALL; i++) {\n+            youngArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = youngRef;\n+        }\n+    }", "source_url": "https://github.com/openjdk/riscv-port/commit/03ef79cf05bdcfc3bb126d004f8f039fb2f4ba9f", "code_v0_no_empty_lines": "WriteBarrier JMH基准测试仅包含老年代对象间的写屏障测试场景，缺少跨代引用场景的测试覆盖。", "code_v1_no_empty_lines": "+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void testArrayWriteBarrierFastPathOldToYoungSmall() {\n+        for (int i = 0; i < NUM_REFERENCES_SMALL; i++) {\n+            youngArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = realRef;\n+        }\n+    }\n\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void testArrayWriteBarrierFastPathYoungToOldSmall() {\n+        for (int i = 0; i < NUM_REFERENCES_SMALL; i++) {\n+            theArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = youngRef;\n+        }\n+    }\n\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void testArrayWriteBarrierFastPathYoungToYoungSmall() {\n+        for (int i = 0; i < NUM_REFERENCES_SMALL; i++) {\n+            youngArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = youngRef;\n+        }\n+    }", "target": "+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void testArrayWriteBarrierFastPathOldToYoungSmall() {\n+        for (int i = 0; i < NUM_REFERENCES_SMALL; i++) {\n+            youngArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = realRef;\n+        }\n+    }\n\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void testArrayWriteBarrierFastPathYoungToOldSmall() {\n+        for (int i = 0; i < NUM_REFERENCES_SMALL; i++) {\n+            theArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = youngRef;\n+        }\n+    }\n\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void testArrayWriteBarrierFastPathYoungToYoungSmall() {\n+        for (int i = 0; i < NUM_REFERENCES_SMALL; i++) {\n+            youngArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = youngRef;\n+        }\n+    }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：WriteBarrier JMH基准测试仅包含老年代对象间的写屏障测试场景，缺少跨代引用场景的测试覆盖。优化后：新增了老年代到年轻代、年轻代到老年代、年轻代到年轻代等跨代引用场景的写屏障基准测试方法，并添加了相应的年轻代对象数组和引用字段。优化思路：通过扩展测试场景覆盖跨代引用情况，能够更全面地评估垃圾收集器中写屏障的性能特性，特别是针对不同代际间对象引用场景的优化效果。"}
{"id": 476, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+编译器优化", "optimization_description": "优化前：x86平台的C1编译器（客户端编译器）缺少CRC32-C指令集的内在函数实现，相关功能调用会回退到较慢的软件实现。优化后：为x86平台添加了CRC32-C指令集的内在函数支持，包括updateBytesCRC32C和updateDirectByteBufferCRC32C两个方法，通过调用StubRoutines::updateBytesCRC32C()利用硬件指令加速CRC32-C计算。优化思路：利用x86平台的CRC32-C硬件指令（需要AVX和CLMUL指令集支持）替代软件算法，显著提升数据校验性能，同时修正了多处注释中的拼写错误（LCMUL→CLMUL）。", "original_code": "x86平台的C1编译器（客户端编译器）缺少CRC32-C指令集的内在函数实现，相关功能调用会回退到较慢的软件实现。", "optimized_code": "void LIRGenerator::do_update_CRC32C(Intrinsic* x) {\n-  Unimplemented();\n+  assert(UseCRC32CIntrinsics, \"need AVX and CLMUL instructions support\");\n+  LIR_Opr result = rlock_result(x);\n+  \n+  switch (x->id()) {\n+    case vmIntrinsics::_updateBytesCRC32C:\n+    case vmIntrinsics::_updateDirectByteBufferCRC32C: {\n+      bool is_updateBytes = (x->id() == vmIntrinsics::_updateBytesCRC32C);\n+      \n+      LIRItem crc(x->argument_at(0), this);\n+      LIRItem buf(x->argument_at(1), this);\n+      LIRItem off(x->argument_at(2), this);\n+      LIRItem end(x->argument_at(3), this);\n+      buf.load_item();\n+      off.load_nonconstant();\n+      end.load_nonconstant();\n+      \n+      // len = end - off\n+      LIR_Opr len  = end.result();\n+      LIR_Opr tmpA = new_register(T_INT);\n+      LIR_Opr tmpB = new_register(T_INT);\n+      __ move(end.result(), tmpA);\n+      __ move(off.result(), tmpB);\n+      __ sub(tmpA, tmpB, tmpA);\n+      len = tmpA;\n+      \n+      LIR_Opr index = off.result();\n+      int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;\n+      if (off.result()->is_constant()) {\n+        index = LIR_OprFact::illegalOpr;\n+        offset += off.result()->as_jint();\n+      }\n+      LIR_Opr base_op = buf.result();\n+      LIR_Address* a = nullptr;\n+      \n+      if (index->is_valid()) {\n+        LIR_Opr tmp = new_register(T_LONG);\n+        __ convert(Bytecodes::_i2l, index, tmp);\n+        index = tmp;\n+        a = new LIR_Address(base_op, index, offset, T_BYTE);\n+      } else {\n+        a = new LIR_Address(base_op, offset, T_BYTE);\n+      }\n+      \n+      BasicTypeList signature(3);\n+      signature.append(T_INT);\n+      signature.append(T_ADDRESS);\n+      signature.append(T_INT);\n+      CallingConvention* cc = frame_map()->c_calling_convention(&signature);\n+      const LIR_Opr result_reg = result_register_for(x->type());\n+      \n+      LIR_Opr arg1 = cc->at(0),\n+              arg2 = cc->at(1),\n+              arg3 = cc->at(2);\n+      \n+      crc.load_item_force(arg1);\n+      __ leal(LIR_OprFact::address(a), arg2);\n+      __ move(len, arg3);\n+      \n+      __ call_runtime_leaf(StubRoutines::updateBytesCRC32C(), getThreadTemp(), result_reg, cc->args());\n+      __ move(result_reg, result);\n+      break;\n+    }\n+    default: {\n+      ShouldNotReachHere();\n+    }\n+  }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/4c5956d7481e043c35f5dc78f095516288a00a2e", "code_v0_no_empty_lines": "x86平台的C1编译器（客户端编译器）缺少CRC32-C指令集的内在函数实现，相关功能调用会回退到较慢的软件实现。", "code_v1_no_empty_lines": "void LIRGenerator::do_update_CRC32C(Intrinsic* x) {\n-  Unimplemented();\n+  assert(UseCRC32CIntrinsics, \"need AVX and CLMUL instructions support\");\n+  LIR_Opr result = rlock_result(x);\n+  \n+  switch (x->id()) {\n+    case vmIntrinsics::_updateBytesCRC32C:\n+    case vmIntrinsics::_updateDirectByteBufferCRC32C: {\n+      bool is_updateBytes = (x->id() == vmIntrinsics::_updateBytesCRC32C);\n+      \n+      LIRItem crc(x->argument_at(0), this);\n+      LIRItem buf(x->argument_at(1), this);\n+      LIRItem off(x->argument_at(2), this);\n+      LIRItem end(x->argument_at(3), this);\n+      buf.load_item();\n+      off.load_nonconstant();\n+      end.load_nonconstant();\n+      \n+      // len = end - off\n+      LIR_Opr len  = end.result();\n+      LIR_Opr tmpA = new_register(T_INT);\n+      LIR_Opr tmpB = new_register(T_INT);\n+      __ move(end.result(), tmpA);\n+      __ move(off.result(), tmpB);\n+      __ sub(tmpA, tmpB, tmpA);\n+      len = tmpA;\n+      \n+      LIR_Opr index = off.result();\n+      int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;\n+      if (off.result()->is_constant()) {\n+        index = LIR_OprFact::illegalOpr;\n+        offset += off.result()->as_jint();\n+      }\n+      LIR_Opr base_op = buf.result();\n+      LIR_Address* a = nullptr;\n+      \n+      if (index->is_valid()) {\n+        LIR_Opr tmp = new_register(T_LONG);\n+        __ convert(Bytecodes::_i2l, index, tmp);\n+        index = tmp;\n+        a = new LIR_Address(base_op, index, offset, T_BYTE);\n+      } else {\n+        a = new LIR_Address(base_op, offset, T_BYTE);\n+      }\n+      \n+      BasicTypeList signature(3);\n+      signature.append(T_INT);\n+      signature.append(T_ADDRESS);\n+      signature.append(T_INT);\n+      CallingConvention* cc = frame_map()->c_calling_convention(&signature);\n+      const LIR_Opr result_reg = result_register_for(x->type());\n+      \n+      LIR_Opr arg1 = cc->at(0),\n+              arg2 = cc->at(1),\n+              arg3 = cc->at(2);\n+      \n+      crc.load_item_force(arg1);\n+      __ leal(LIR_OprFact::address(a), arg2);\n+      __ move(len, arg3);\n+      \n+      __ call_runtime_leaf(StubRoutines::updateBytesCRC32C(), getThreadTemp(), result_reg, cc->args());\n+      __ move(result_reg, result);\n+      break;\n+    }\n+    default: {\n+      ShouldNotReachHere();\n+    }\n+  }\n}", "target": "void LIRGenerator::do_update_CRC32C(Intrinsic* x) {\n-  Unimplemented();\n+  assert(UseCRC32CIntrinsics, \"need AVX and CLMUL instructions support\");\n+  LIR_Opr result = rlock_result(x);\n+  \n+  switch (x->id()) {\n+    case vmIntrinsics::_updateBytesCRC32C:\n+    case vmIntrinsics::_updateDirectByteBufferCRC32C: {\n+      bool is_updateBytes = (x->id() == vmIntrinsics::_updateBytesCRC32C);\n+      \n+      LIRItem crc(x->argument_at(0), this);\n+      LIRItem buf(x->argument_at(1), this);\n+      LIRItem off(x->argument_at(2), this);\n+      LIRItem end(x->argument_at(3), this);\n+      buf.load_item();\n+      off.load_nonconstant();\n+      end.load_nonconstant();\n+      \n+      // len = end - off\n+      LIR_Opr len  = end.result();\n+      LIR_Opr tmpA = new_register(T_INT);\n+      LIR_Opr tmpB = new_register(T_INT);\n+      __ move(end.result(), tmpA);\n+      __ move(off.result(), tmpB);\n+      __ sub(tmpA, tmpB, tmpA);\n+      len = tmpA;\n+      \n+      LIR_Opr index = off.result();\n+      int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;\n+      if (off.result()->is_constant()) {\n+        index = LIR_OprFact::illegalOpr;\n+        offset += off.result()->as_jint();\n+      }\n+      LIR_Opr base_op = buf.result();\n+      LIR_Address* a = nullptr;\n+      \n+      if (index->is_valid()) {\n+        LIR_Opr tmp = new_register(T_LONG);\n+        __ convert(Bytecodes::_i2l, index, tmp);\n+        index = tmp;\n+        a = new LIR_Address(base_op, index, offset, T_BYTE);\n+      } else {\n+        a = new LIR_Address(base_op, offset, T_BYTE);\n+      }\n+      \n+      BasicTypeList signature(3);\n+      signature.append(T_INT);\n+      signature.append(T_ADDRESS);\n+      signature.append(T_INT);\n+      CallingConvention* cc = frame_map()->c_calling_convention(&signature);\n+      const LIR_Opr result_reg = result_register_for(x->type());\n+      \n+      LIR_Opr arg1 = cc->at(0),\n+              arg2 = cc->at(1),\n+              arg3 = cc->at(2);\n+      \n+      crc.load_item_force(arg1);\n+      __ leal(LIR_OprFact::address(a), arg2);\n+      __ move(len, arg3);\n+      \n+      __ call_runtime_leaf(StubRoutines::updateBytesCRC32C(), getThreadTemp(), result_reg, cc->args());\n+      __ move(result_reg, result);\n+      break;\n+    }\n+    default: {\n+      ShouldNotReachHere();\n+    }\n+  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：x86平台的C1编译器（客户端编译器）缺少CRC32-C指令集的内在函数实现，相关功能调用会回退到较慢的软件实现。优化后：为x86平台添加了CRC32-C指令集的内在函数支持，包括updateBytesCRC32C和updateDirectByteBufferCRC32C两个方法，通过调用StubRoutines::updateBytesCRC32C()利用硬件指令加速CRC32-C计算。优化思路：利用x86平台的CRC32-C硬件指令（需要AVX和CLMUL指令集支持）替代软件算法，显著提升数据校验性能，同时修正了多处注释中的拼写错误（LCMUL→CLMUL）。"}
{"id": 477, "source": "riscv-dataset-excel", "optimization_type": "监控与诊断增强", "optimization_description": "优化前：JFR缺少对Java监视器收缩（deflation）的监控和统计信息，无法追踪监视器生命周期完整数据。优化后：新增JavaMonitorDeflate事件记录监视器收缩操作，新增JavaMonitorStatistics周期性事件统计使用中的监视器数量，并统一了JFR事件排除逻辑。优化思路：通过扩展JFR事件系统，提供更完整的Java监视器运行时行为监控，帮助诊断性能问题和内存使用情况，同时保持向后兼容性。", "original_code": "JFR缺少对Java监视器收缩（deflation）的监控和统计信息，无法追踪监视器生命周期完整数据。", "optimized_code": "1. metadata.xml中添加JavaMonitorDeflate和JavaMonitorStatistics事件定义\n2. objectMonitor.cpp中添加post_monitor_deflate_event函数和事件触发逻辑\n3. objectMonitor.inline.hpp中添加is_jfr_excluded静态方法\n4. jfrPeriodic.cpp中添加JavaMonitorStatistics周期性事件收集", "source_url": "https://github.com/openjdk/riscv-port/commit/895f64a18d7c752332ef9255c0b118bf25bdbb90", "code_v0_no_empty_lines": "JFR缺少对Java监视器收缩（deflation）的监控和统计信息，无法追踪监视器生命周期完整数据。", "code_v1_no_empty_lines": "1. metadata.xml中添加JavaMonitorDeflate和JavaMonitorStatistics事件定义\n2. objectMonitor.cpp中添加post_monitor_deflate_event函数和事件触发逻辑\n3. objectMonitor.inline.hpp中添加is_jfr_excluded静态方法\n4. jfrPeriodic.cpp中添加JavaMonitorStatistics周期性事件收集", "target": "1. metadata.xml中添加JavaMonitorDeflate和JavaMonitorStatistics事件定义\n2. objectMonitor.cpp中添加post_monitor_deflate_event函数和事件触发逻辑\n3. objectMonitor.inline.hpp中添加is_jfr_excluded静态方法\n4. jfrPeriodic.cpp中添加JavaMonitorStatistics周期性事件收集", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：JFR缺少对Java监视器收缩（deflation）的监控和统计信息，无法追踪监视器生命周期完整数据。优化后：新增JavaMonitorDeflate事件记录监视器收缩操作，新增JavaMonitorStatistics周期性事件统计使用中的监视器数量，并统一了JFR事件排除逻辑。优化思路：通过扩展JFR事件系统，提供更完整的Java监视器运行时行为监控，帮助诊断性能问题和内存使用情况，同时保持向后兼容性。"}
{"id": 478, "source": "riscv-dataset-excel", "optimization_type": "数据类型优化+平台适配优化", "optimization_description": "优化前：BytecodeCounter::_counter_value在64位平台上仍使用32位整数存储，当字节码执行次数超过2^31-1时会发生溢出。优化后：将计数器升级为64位整数，支持更大的计数范围（2^63-1）。优化思路：在64位平台上使用64位原子操作和比较指令（如atomic_add、cmp、ld/std代替atomic_addw、cmpw、lwz/stw），移除32位限制检查（TraceBytecodesAt < max_intx），确保长期运行的JVM实例不会因计数器溢出而影响性能监控和调试功能。", "original_code": "BytecodeCounter::_counter_value在64位平台上仍使用32位整数存储，当字节码执行次数超过2^31-1时会发生溢出。", "optimized_code": "- __ atomic_addw(noreg, 1, r10);\n+ __ atomic_add(noreg, 1, r10);\n- __ cmpw(rscratch1, rscratch2);\n+ __ cmp(rscratch1, rscratch2);\n- __ lwa(R12_scratch2, offs2, R12_scratch2);\n+ __ ld(R12_scratch2, offs2, R12_scratch2);\n- __ lwz(R12_scratch2, offs, R11_scratch1);\n+ __ ld(R12_scratch2, offs, R11_scratch1);\n- __ stw(R12_scratch2, offs, R11_scratch1);\n+ __ std(R12_scratch2, offs, R11_scratch1);\n- __ load_sized_value(Z_tmp_1, Address(Z_tmp_1), 4, false /*signed*/);\n+ __ load_sized_value(Z_tmp_1, Address(Z_tmp_1), 8, false /*signed*/);\n- __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);\n+ __ add2mem_64(Address(Z_R1_scratch), 1, Z_R0_scratch);\n- __ incrementl(ExternalAddress((address) &BytecodeCounter::_counter_value), rscratch1);\n+ #ifndef _LP64\n+   __ incrementl(ExternalAddress((address) &BytecodeCounter::_counter_value), rscratch1);\n+ #else\n+   __ incrementq(ExternalAddress((address) &BytecodeCounter::_counter_value), rscratch1);\n+ #endif", "source_url": "https://github.com/openjdk/riscv-port/commit/4be502ea38b37d5fb532b64e5b82363805bfe657", "code_v0_no_empty_lines": "BytecodeCounter::_counter_value在64位平台上仍使用32位整数存储，当字节码执行次数超过2^31-1时会发生溢出。", "code_v1_no_empty_lines": "- __ atomic_addw(noreg, 1, r10);\n+ __ atomic_add(noreg, 1, r10);\n- __ cmpw(rscratch1, rscratch2);\n+ __ cmp(rscratch1, rscratch2);\n- __ lwa(R12_scratch2, offs2, R12_scratch2);\n+ __ ld(R12_scratch2, offs2, R12_scratch2);\n- __ lwz(R12_scratch2, offs, R11_scratch1);\n+ __ ld(R12_scratch2, offs, R11_scratch1);\n- __ stw(R12_scratch2, offs, R11_scratch1);\n+ __ std(R12_scratch2, offs, R11_scratch1);\n- __ load_sized_value(Z_tmp_1, Address(Z_tmp_1), 4, false /*signed*/);\n+ __ load_sized_value(Z_tmp_1, Address(Z_tmp_1), 8, false /*signed*/);\n- __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);\n+ __ add2mem_64(Address(Z_R1_scratch), 1, Z_R0_scratch);\n- __ incrementl(ExternalAddress((address) &BytecodeCounter::_counter_value), rscratch1);\n+ #ifndef _LP64\n+   __ incrementl(ExternalAddress((address) &BytecodeCounter::_counter_value), rscratch1);\n+ #else\n+   __ incrementq(ExternalAddress((address) &BytecodeCounter::_counter_value), rscratch1);\n+ #endif", "target": "- __ atomic_addw(noreg, 1, r10);\n+ __ atomic_add(noreg, 1, r10);\n- __ cmpw(rscratch1, rscratch2);\n+ __ cmp(rscratch1, rscratch2);\n- __ lwa(R12_scratch2, offs2, R12_scratch2);\n+ __ ld(R12_scratch2, offs2, R12_scratch2);\n- __ lwz(R12_scratch2, offs, R11_scratch1);\n+ __ ld(R12_scratch2, offs, R11_scratch1);\n- __ stw(R12_scratch2, offs, R11_scratch1);\n+ __ std(R12_scratch2, offs, R11_scratch1);\n- __ load_sized_value(Z_tmp_1, Address(Z_tmp_1), 4, false /*signed*/);\n+ __ load_sized_value(Z_tmp_1, Address(Z_tmp_1), 8, false /*signed*/);\n- __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);\n+ __ add2mem_64(Address(Z_R1_scratch), 1, Z_R0_scratch);\n- __ incrementl(ExternalAddress((address) &BytecodeCounter::_counter_value), rscratch1);\n+ #ifndef _LP64\n+   __ incrementl(ExternalAddress((address) &BytecodeCounter::_counter_value), rscratch1);\n+ #else\n+   __ incrementq(ExternalAddress((address) &BytecodeCounter::_counter_value), rscratch1);\n+ #endif", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：BytecodeCounter::_counter_value在64位平台上仍使用32位整数存储，当字节码执行次数超过2^31-1时会发生溢出。优化后：将计数器升级为64位整数，支持更大的计数范围（2^63-1）。优化思路：在64位平台上使用64位原子操作和比较指令（如atomic_add、cmp、ld/std代替atomic_addw、cmpw、lwz/stw），移除32位限制检查（TraceBytecodesAt < max_intx），确保长期运行的JVM实例不会因计数器溢出而影响性能监控和调试功能。"}
{"id": 479, "source": "riscv-dataset-excel", "optimization_type": "JFR配置优化", "optimization_description": "优化前：JavaMonitorInflate事件在default.jfc中启用但设置了20ms阈值，在profile.jfc中启用且设置了10ms阈值，导致监控膨胀事件记录有延迟且可能产生额外开销。优化后：将两个配置文件中的JavaMonitorInflate事件默认禁用（enabled=false），并将阈值设置为0ms（无延迟记录）。优化思路：减少JFR监控开销，避免不必要的监控膨胀事件记录，提高运行时性能，同时保持事件在需要时可手动启用。", "original_code": "JavaMonitorInflate事件在default.jfc中启用但设置了20ms阈值，在profile.jfc中启用且设置了10ms阈值，导致监控膨胀事件记录有延迟且可能产生额外开销。", "optimized_code": "- <setting name=\"threshold\" control=\"locking-threshold\">20 ms</setting>\n+ <setting name=\"threshold\">0 ms</setting>\n- <setting name=\"enabled\">true</setting>\n+ <setting name=\"enabled\">false</setting>\n- <setting name=\"threshold\" control=\"locking-threshold\">10 ms</setting>\n+ <setting name=\"threshold\">0 ms</setting>", "source_url": "https://github.com/openjdk/riscv-port/commit/0ad9a104e2fed2dd80494cec22e9d9332d37821b", "code_v0_no_empty_lines": "JavaMonitorInflate事件在default.jfc中启用但设置了20ms阈值，在profile.jfc中启用且设置了10ms阈值，导致监控膨胀事件记录有延迟且可能产生额外开销。", "code_v1_no_empty_lines": "- <setting name=\"threshold\" control=\"locking-threshold\">20 ms</setting>\n+ <setting name=\"threshold\">0 ms</setting>\n- <setting name=\"enabled\">true</setting>\n+ <setting name=\"enabled\">false</setting>\n- <setting name=\"threshold\" control=\"locking-threshold\">10 ms</setting>\n+ <setting name=\"threshold\">0 ms</setting>", "target": "- <setting name=\"threshold\" control=\"locking-threshold\">20 ms</setting>\n+ <setting name=\"threshold\">0 ms</setting>\n- <setting name=\"enabled\">true</setting>\n+ <setting name=\"enabled\">false</setting>\n- <setting name=\"threshold\" control=\"locking-threshold\">10 ms</setting>\n+ <setting name=\"threshold\">0 ms</setting>", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：JavaMonitorInflate事件在default.jfc中启用但设置了20ms阈值，在profile.jfc中启用且设置了10ms阈值，导致监控膨胀事件记录有延迟且可能产生额外开销。优化后：将两个配置文件中的JavaMonitorInflate事件默认禁用（enabled=false），并将阈值设置为0ms（无延迟记录）。优化思路：减少JFR监控开销，避免不必要的监控膨胀事件记录，提高运行时性能，同时保持事件在需要时可手动启用。"}
{"id": 480, "source": "riscv-dataset-excel", "optimization_type": "编译器优化顺序调整", "optimization_description": "优化前：MergeStores（合并存储操作）在RangeCheck smearing（范围检查扩散）之前执行，可能导致合并错误的存储序列。例如，当RangeCheck节点位于存储节点之间时，过早合并会生成次优的存储模式。优化后：在Optimize()函数中，将process_for_merge_stores_igvn()调用移至process_for_post_loop_opts_igvn()之后，确保MergeStores在RangeCheck smearing完成后再执行。优化思路：通过调整优化阶段顺序，避免RangeCheck节点干扰存储合并，从而生成更高效的存储序列（如合并为更大的StoreL操作），提升内存访问性能。", "original_code": "MergeStores（合并存储操作）在RangeCheck smearing（范围检查扩散）之前执行，可能导致合并错误的存储序列。例如，当RangeCheck节点位于存储节点之间时，过早合并会生成次优的存储模式。", "optimized_code": "+  process_for_merge_stores_igvn(igvn);\n+void Compile::process_for_merge_stores_igvn(PhaseIterGVN& igvn) {\n+  C->set_merge_stores_phase();\n+  if (_for_merge_stores_igvn.length() > 0) {\n+    while (_for_merge_stores_igvn.length() > 0) {\n+      Node* n = _for_merge_stores_igvn.pop();\n+      n->remove_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n+      igvn._worklist.push(n);\n+    }\n+    igvn.optimize();\n+    if (failing()) return;\n+    assert(_for_merge_stores_igvn.length() == 0, \"no more delayed nodes allowed\");\n+    print_method(PHASE_AFTER_MERGE_STORES, 3);\n+  }\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/4cf63160ad575d49dbe70f128cd36aba22b8f2ff", "code_v0_no_empty_lines": "MergeStores（合并存储操作）在RangeCheck smearing（范围检查扩散）之前执行，可能导致合并错误的存储序列。例如，当RangeCheck节点位于存储节点之间时，过早合并会生成次优的存储模式。", "code_v1_no_empty_lines": "+  process_for_merge_stores_igvn(igvn);\n+void Compile::process_for_merge_stores_igvn(PhaseIterGVN& igvn) {\n+  C->set_merge_stores_phase();\n+  if (_for_merge_stores_igvn.length() > 0) {\n+    while (_for_merge_stores_igvn.length() > 0) {\n+      Node* n = _for_merge_stores_igvn.pop();\n+      n->remove_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n+      igvn._worklist.push(n);\n+    }\n+    igvn.optimize();\n+    if (failing()) return;\n+    assert(_for_merge_stores_igvn.length() == 0, \"no more delayed nodes allowed\");\n+    print_method(PHASE_AFTER_MERGE_STORES, 3);\n+  }\n+}", "target": "+  process_for_merge_stores_igvn(igvn);\n+void Compile::process_for_merge_stores_igvn(PhaseIterGVN& igvn) {\n+  C->set_merge_stores_phase();\n+  if (_for_merge_stores_igvn.length() > 0) {\n+    while (_for_merge_stores_igvn.length() > 0) {\n+      Node* n = _for_merge_stores_igvn.pop();\n+      n->remove_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n+      igvn._worklist.push(n);\n+    }\n+    igvn.optimize();\n+    if (failing()) return;\n+    assert(_for_merge_stores_igvn.length() == 0, \"no more delayed nodes allowed\");\n+    print_method(PHASE_AFTER_MERGE_STORES, 3);\n+  }\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：MergeStores（合并存储操作）在RangeCheck smearing（范围检查扩散）之前执行，可能导致合并错误的存储序列。例如，当RangeCheck节点位于存储节点之间时，过早合并会生成次优的存储模式。优化后：在Optimize()函数中，将process_for_merge_stores_igvn()调用移至process_for_post_loop_opts_igvn()之后，确保MergeStores在RangeCheck smearing完成后再执行。优化思路：通过调整优化阶段顺序，避免RangeCheck节点干扰存储合并，从而生成更高效的存储序列（如合并为更大的StoreL操作），提升内存访问性能。"}
{"id": 481, "source": "riscv-dataset-excel", "optimization_type": "内存布局优化+性能优化", "optimization_description": "优化前：nmethod的可变数据（如重定位信息）存储在CodeCache内部，占用CodeCache空间并增加内存碎片。优化后：将可变数据移出CodeCache，通过_mutable_data指针在堆上单独分配。优化思路：减少CodeCache内存占用，提高缓存局部性，降低GC压力，提升JVM性能。", "original_code": "nmethod的可变数据（如重定位信息）存储在CodeCache内部，占用CodeCache空间并增加内存碎片。", "optimized_code": "- unsigned int size = header_size;\n+ unsigned int size = align_code_offset(header_size);\n- size += align_up(cb->total_relocation_size(), oopSize);\n- size = align_code_offset(size);\n- size += align_up(cb->total_metadata_size(), oopSize);\n+ _mutable_data_size(mutable_data_size),\n+ if (_mutable_data_size > 0) {\n+   _mutable_data = (address)os::malloc(_mutable_data_size, mtCode);\n+ }\n+ if (_mutable_data != nullptr) {\n+   os::free(_mutable_data);\n+   _mutable_data = nullptr;\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/83de34041eacdf987988364487712c79bbb4c235", "code_v0_no_empty_lines": "nmethod的可变数据（如重定位信息）存储在CodeCache内部，占用CodeCache空间并增加内存碎片。", "code_v1_no_empty_lines": "- unsigned int size = header_size;\n+ unsigned int size = align_code_offset(header_size);\n- size += align_up(cb->total_relocation_size(), oopSize);\n- size = align_code_offset(size);\n- size += align_up(cb->total_metadata_size(), oopSize);\n+ _mutable_data_size(mutable_data_size),\n+ if (_mutable_data_size > 0) {\n+   _mutable_data = (address)os::malloc(_mutable_data_size, mtCode);\n+ }\n+ if (_mutable_data != nullptr) {\n+   os::free(_mutable_data);\n+   _mutable_data = nullptr;\n+ }", "target": "- unsigned int size = header_size;\n+ unsigned int size = align_code_offset(header_size);\n- size += align_up(cb->total_relocation_size(), oopSize);\n- size = align_code_offset(size);\n- size += align_up(cb->total_metadata_size(), oopSize);\n+ _mutable_data_size(mutable_data_size),\n+ if (_mutable_data_size > 0) {\n+   _mutable_data = (address)os::malloc(_mutable_data_size, mtCode);\n+ }\n+ if (_mutable_data != nullptr) {\n+   os::free(_mutable_data);\n+   _mutable_data = nullptr;\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：nmethod的可变数据（如重定位信息）存储在CodeCache内部，占用CodeCache空间并增加内存碎片。优化后：将可变数据移出CodeCache，通过_mutable_data指针在堆上单独分配。优化思路：减少CodeCache内存占用，提高缓存局部性，降低GC压力，提升JVM性能。"}
{"id": 482, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+存储合并优化", "optimization_description": "优化前：MergePrimitiveStores只能合并平台字节序（大端或小端）的相邻存储操作，无法处理字节序反转的情况。优化后：引入ValueOrder状态机（Unknown/Const/Platform/Reverse/NotAdjacent），通过find_adjacent_input_value_order函数检测输入值的顺序关系，支持检测和合并字节序反转的存储模式。优化思路：扩展存储合并算法，使其能够识别并合并字节序反转的相邻存储操作，当检测到Reverse模式且平台支持ReverseBytes指令时，允许合并这些存储，从而生成更高效的代码。", "original_code": "MergePrimitiveStores只能合并平台字节序（大端或小端）的相邻存储操作，无法处理字节序反转的情况。", "optimized_code": "enum ValueOrder : uint8_t {\n    Unknown,     // Initial state\n    Const,       // Input values are const\n    Platform,    // Platform order\n    Reverse,     // Reverse platform order\n    NotAdjacent  // Not adjacent\n};\nValueOrder find_adjacent_input_value_order(const Node* n1, const Node* n2, const int memory_size) const;\nbool is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const {\n  ValueOrder input_value_order = find_adjacent_input_value_order(n1, n2, memory_size);\n  \n  switch (input_value_order) {\n    case ValueOrder::NotAdjacent:\n      return false;\n    case ValueOrder::Reverse:\n      if (memory_size != 1 ||\n          !Matcher::match_rule_supported(Op_ReverseBytesS) ||\n          !Matcher::match_rule_supported(Op_ReverseBytesI) ||\n          !Matcher::match_rule_supported(Op_ReverseBytesL)) {\n        // ReverseBytes are not supported by platform\n        return false;\n      }\n      // fall-through.\n    case ValueOrder::Const:\n    case ValueOrder::Platform:\n      if (_value_order == ValueOrder::Unknown) {\n        // Initial state is Unknown, and we find a valid input value order\n        return true;\n      }\n      // The value order can not be changed\n      return _value_order == input_value_order;\n    case ValueOrder::Unknown:\n    default:\n      ShouldNotReachHere();\n  }\n  return false;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/5928209280e7a655a22f11bc03eae32a4e99756c", "code_v0_no_empty_lines": "MergePrimitiveStores只能合并平台字节序（大端或小端）的相邻存储操作，无法处理字节序反转的情况。", "code_v1_no_empty_lines": "enum ValueOrder : uint8_t {\n    Unknown,     // Initial state\n    Const,       // Input values are const\n    Platform,    // Platform order\n    Reverse,     // Reverse platform order\n    NotAdjacent  // Not adjacent\n};\nValueOrder find_adjacent_input_value_order(const Node* n1, const Node* n2, const int memory_size) const;\nbool is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const {\n  ValueOrder input_value_order = find_adjacent_input_value_order(n1, n2, memory_size);\n  \n  switch (input_value_order) {\n    case ValueOrder::NotAdjacent:\n      return false;\n    case ValueOrder::Reverse:\n      if (memory_size != 1 ||\n          !Matcher::match_rule_supported(Op_ReverseBytesS) ||\n          !Matcher::match_rule_supported(Op_ReverseBytesI) ||\n          !Matcher::match_rule_supported(Op_ReverseBytesL)) {\n        // ReverseBytes are not supported by platform\n        return false;\n      }\n      // fall-through.\n    case ValueOrder::Const:\n    case ValueOrder::Platform:\n      if (_value_order == ValueOrder::Unknown) {\n        // Initial state is Unknown, and we find a valid input value order\n        return true;\n      }\n      // The value order can not be changed\n      return _value_order == input_value_order;\n    case ValueOrder::Unknown:\n    default:\n      ShouldNotReachHere();\n  }\n  return false;\n}", "target": "enum ValueOrder : uint8_t {\n    Unknown,     // Initial state\n    Const,       // Input values are const\n    Platform,    // Platform order\n    Reverse,     // Reverse platform order\n    NotAdjacent  // Not adjacent\n};\nValueOrder find_adjacent_input_value_order(const Node* n1, const Node* n2, const int memory_size) const;\nbool is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const {\n  ValueOrder input_value_order = find_adjacent_input_value_order(n1, n2, memory_size);\n  \n  switch (input_value_order) {\n    case ValueOrder::NotAdjacent:\n      return false;\n    case ValueOrder::Reverse:\n      if (memory_size != 1 ||\n          !Matcher::match_rule_supported(Op_ReverseBytesS) ||\n          !Matcher::match_rule_supported(Op_ReverseBytesI) ||\n          !Matcher::match_rule_supported(Op_ReverseBytesL)) {\n        // ReverseBytes are not supported by platform\n        return false;\n      }\n      // fall-through.\n    case ValueOrder::Const:\n    case ValueOrder::Platform:\n      if (_value_order == ValueOrder::Unknown) {\n        // Initial state is Unknown, and we find a valid input value order\n        return true;\n      }\n      // The value order can not be changed\n      return _value_order == input_value_order;\n    case ValueOrder::Unknown:\n    default:\n      ShouldNotReachHere();\n  }\n  return false;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：MergePrimitiveStores只能合并平台字节序（大端或小端）的相邻存储操作，无法处理字节序反转的情况。优化后：引入ValueOrder状态机（Unknown/Const/Platform/Reverse/NotAdjacent），通过find_adjacent_input_value_order函数检测输入值的顺序关系，支持检测和合并字节序反转的存储模式。优化思路：扩展存储合并算法，使其能够识别并合并字节序反转的相邻存储操作，当检测到Reverse模式且平台支持ReverseBytes指令时，允许合并这些存储，从而生成更高效的代码。"}
{"id": 483, "source": "riscv-dataset-excel", "optimization_type": "条件优化+性能优化", "optimization_description": "优化前：Poly1305、MD5和SHA1加密内在函数在RISC-V平台上默认启用，不考虑内存对齐访问的性能影响。优化后：只有当AvoidUnalignedAccesses标志为false（即系统支持快速非对齐内存访问）时，才默认启用这些加密内在函数。优化思路：避免在支持非对齐访问较慢的RISC-V系统上使用这些内在函数，防止因内存对齐问题导致的性能下降，确保内在函数只在能发挥性能优势的硬件配置下启用。", "original_code": "Poly1305、MD5和SHA1加密内在函数在RISC-V平台上默认启用，不考虑内存对齐访问的性能影响。", "optimized_code": "-  if (FLAG_IS_DEFAULT(UsePoly1305Intrinsics)) {\n-    FLAG_SET_DEFAULT(UsePoly1305Intrinsics, true);\n-  }\n+  if (FLAG_IS_DEFAULT(UsePoly1305Intrinsics) && !AvoidUnalignedAccesses) {\n+    FLAG_SET_DEFAULT(UsePoly1305Intrinsics, true);\n+  }\n-  if (FLAG_IS_DEFAULT(UseMD5Intrinsics)) {\n+  if (FLAG_IS_DEFAULT(UseMD5Intrinsics) && !AvoidUnalignedAccesses) {\n-  if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {\n+  if (FLAG_IS_DEFAULT(UseSHA1Intrinsics) && !AvoidUnalignedAccesses) {", "source_url": "https://github.com/openjdk/riscv-port/commit/af9af7e90f7dab5adc7b89b76eb978d269e863de", "code_v0_no_empty_lines": "Poly1305、MD5和SHA1加密内在函数在RISC-V平台上默认启用，不考虑内存对齐访问的性能影响。", "code_v1_no_empty_lines": "-  if (FLAG_IS_DEFAULT(UsePoly1305Intrinsics)) {\n-    FLAG_SET_DEFAULT(UsePoly1305Intrinsics, true);\n-  }\n+  if (FLAG_IS_DEFAULT(UsePoly1305Intrinsics) && !AvoidUnalignedAccesses) {\n+    FLAG_SET_DEFAULT(UsePoly1305Intrinsics, true);\n+  }\n-  if (FLAG_IS_DEFAULT(UseMD5Intrinsics)) {\n+  if (FLAG_IS_DEFAULT(UseMD5Intrinsics) && !AvoidUnalignedAccesses) {\n-  if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {\n+  if (FLAG_IS_DEFAULT(UseSHA1Intrinsics) && !AvoidUnalignedAccesses) {", "target": "-  if (FLAG_IS_DEFAULT(UsePoly1305Intrinsics)) {\n-    FLAG_SET_DEFAULT(UsePoly1305Intrinsics, true);\n-  }\n+  if (FLAG_IS_DEFAULT(UsePoly1305Intrinsics) && !AvoidUnalignedAccesses) {\n+    FLAG_SET_DEFAULT(UsePoly1305Intrinsics, true);\n+  }\n-  if (FLAG_IS_DEFAULT(UseMD5Intrinsics)) {\n+  if (FLAG_IS_DEFAULT(UseMD5Intrinsics) && !AvoidUnalignedAccesses) {\n-  if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {\n+  if (FLAG_IS_DEFAULT(UseSHA1Intrinsics) && !AvoidUnalignedAccesses) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Poly1305、MD5和SHA1加密内在函数在RISC-V平台上默认启用，不考虑内存对齐访问的性能影响。优化后：只有当AvoidUnalignedAccesses标志为false（即系统支持快速非对齐内存访问）时，才默认启用这些加密内在函数。优化思路：避免在支持非对齐访问较慢的RISC-V系统上使用这些内在函数，防止因内存对齐问题导致的性能下降，确保内在函数只在能发挥性能优势的硬件配置下启用。"}
{"id": 484, "source": "riscv-dataset-excel", "optimization_type": "循环优化+死代码消除", "optimization_description": "优化前：在C2 SuperWord多版本化优化中，当快速循环（fast loop）消失后，对应的慢速循环（slow loop）及其关联的多版本化条件判断（multiversion_if）可能变得无用，但仍保留在IR中，导致冗余代码执行。优化后：新增eliminate_useless_multiversion_if()函数，在循环优化阶段检测并标记无用的OpaqueMultiversioning节点，使其在后续IGVN阶段被常量折叠消除。优化思路：通过遍历循环树，识别与快速主循环关联的多版本化条件判断，收集仍有效的OpaqueMultiversioning节点；对于未关联到任何快速循环的节点（即无用节点），若其慢速循环仍处于延迟模式（未添加运行时检查），则标记为无用，触发常量折叠，从而移除冗余的慢速循环路径，减少不必要的控制流和潜在的性能开销。", "original_code": "在C2 SuperWord多版本化优化中，当快速循环（fast loop）消失后，对应的慢速循环（slow loop）及其关联的多版本化条件判断（multiversion_if）可能变得无用，但仍保留在IR中，导致冗余代码执行。", "optimized_code": "+void PhaseIdealLoop::eliminate_useless_multiversion_if() {\n+  if (_multiversion_opaque_nodes.size() == 0) {\n+    return;\n+  }\n+\n+  ResourceMark rm;\n+  Unique_Node_List useful_multiversioning_opaque_nodes;\n+\n+  // The OpaqueMultiversioning is only used from the fast main loop in AutoVectorization, to add\n+  // speculative runtime-checks to the multiversion_if. Thus, a OpaqueMultiversioning is only\n+  // useful if it can be found from a fast main loop. If it can not be found from a fast main loop,\n+  // then we cannot ever use that multiversion_if to add more speculative runtime-checks, and hence\n+  // it is useless. If it is still in delayed mode, i.e. has not yet had any runtime-checks added,\n+  // then we can let it constant fold towards the fast loop.\n+  for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n+    IdealLoopTree* lpt = iter.current();\n+    if (lpt->_child == nullptr && lpt->is_counted()) {\n+      CountedLoopNode* head = lpt->_head->as_CountedLoop();\n+      if (head->is_main_loop() && head->is_multiversion_fast_loop()) {\n+        // There are fast_loop pre/main/post loops, but the finding traversal starts at the main\n+        // loop, and traverses via the fast pre loop to the multiversion_if.\n+        IfNode* multiversion_if = head->find_multiversion_if_from_multiversion_fast_main_loop();\n+        if (multiversion_if != nullptr) {\n+            useful_multiversioning_opaque_nodes.push(multiversion_if->in(1)->as_OpaqueMultiversioning());\n+        }\n+      }\n+    }\n+  }\n+\n+  for (uint i = 0; i < _multiversion_opaque_nodes.size(); i++) {\n+    OpaqueMultiversioningNode* opaque = _multiversion_opaque_nodes.at(i)->as_OpaqueMultiversioning();\n+    if (!useful_multiversioning_opaque_nodes.member(opaque)) {\n+      if (opaque->is_delayed_slow_loop()) {\n+        // We cannot hack the node directly, otherwise the slow_loop will complain that it cannot\n+        // find the multiversioning opaque node. Instead, we mark the opaque node as useless, and\n+        // it can be constant folded during IGVN.\n+        opaque->mark_useless();\n+        _igvn._worklist.push(opaque);\n+      }\n+    }\n+  }\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/e82031ec1a8ae2478f83d009594d512a13fdb77e", "code_v0_no_empty_lines": "在C2 SuperWord多版本化优化中，当快速循环（fast loop）消失后，对应的慢速循环（slow loop）及其关联的多版本化条件判断（multiversion_if）可能变得无用，但仍保留在IR中，导致冗余代码执行。", "code_v1_no_empty_lines": "+void PhaseIdealLoop::eliminate_useless_multiversion_if() {\n+  if (_multiversion_opaque_nodes.size() == 0) {\n+    return;\n+  }\n+\n+  ResourceMark rm;\n+  Unique_Node_List useful_multiversioning_opaque_nodes;\n+\n+  // The OpaqueMultiversioning is only used from the fast main loop in AutoVectorization, to add\n+  // speculative runtime-checks to the multiversion_if. Thus, a OpaqueMultiversioning is only\n+  // useful if it can be found from a fast main loop. If it can not be found from a fast main loop,\n+  // then we cannot ever use that multiversion_if to add more speculative runtime-checks, and hence\n+  // it is useless. If it is still in delayed mode, i.e. has not yet had any runtime-checks added,\n+  // then we can let it constant fold towards the fast loop.\n+  for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n+    IdealLoopTree* lpt = iter.current();\n+    if (lpt->_child == nullptr && lpt->is_counted()) {\n+      CountedLoopNode* head = lpt->_head->as_CountedLoop();\n+      if (head->is_main_loop() && head->is_multiversion_fast_loop()) {\n+        // There are fast_loop pre/main/post loops, but the finding traversal starts at the main\n+        // loop, and traverses via the fast pre loop to the multiversion_if.\n+        IfNode* multiversion_if = head->find_multiversion_if_from_multiversion_fast_main_loop();\n+        if (multiversion_if != nullptr) {\n+            useful_multiversioning_opaque_nodes.push(multiversion_if->in(1)->as_OpaqueMultiversioning());\n+        }\n+      }\n+    }\n+  }\n+\n+  for (uint i = 0; i < _multiversion_opaque_nodes.size(); i++) {\n+    OpaqueMultiversioningNode* opaque = _multiversion_opaque_nodes.at(i)->as_OpaqueMultiversioning();\n+    if (!useful_multiversioning_opaque_nodes.member(opaque)) {\n+      if (opaque->is_delayed_slow_loop()) {\n+        // We cannot hack the node directly, otherwise the slow_loop will complain that it cannot\n+        // find the multiversioning opaque node. Instead, we mark the opaque node as useless, and\n+        // it can be constant folded during IGVN.\n+        opaque->mark_useless();\n+        _igvn._worklist.push(opaque);\n+      }\n+    }\n+  }\n+}", "target": "+void PhaseIdealLoop::eliminate_useless_multiversion_if() {\n+  if (_multiversion_opaque_nodes.size() == 0) {\n+    return;\n+  }\n+\n+  ResourceMark rm;\n+  Unique_Node_List useful_multiversioning_opaque_nodes;\n+\n+  // The OpaqueMultiversioning is only used from the fast main loop in AutoVectorization, to add\n+  // speculative runtime-checks to the multiversion_if. Thus, a OpaqueMultiversioning is only\n+  // useful if it can be found from a fast main loop. If it can not be found from a fast main loop,\n+  // then we cannot ever use that multiversion_if to add more speculative runtime-checks, and hence\n+  // it is useless. If it is still in delayed mode, i.e. has not yet had any runtime-checks added,\n+  // then we can let it constant fold towards the fast loop.\n+  for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n+    IdealLoopTree* lpt = iter.current();\n+    if (lpt->_child == nullptr && lpt->is_counted()) {\n+      CountedLoopNode* head = lpt->_head->as_CountedLoop();\n+      if (head->is_main_loop() && head->is_multiversion_fast_loop()) {\n+        // There are fast_loop pre/main/post loops, but the finding traversal starts at the main\n+        // loop, and traverses via the fast pre loop to the multiversion_if.\n+        IfNode* multiversion_if = head->find_multiversion_if_from_multiversion_fast_main_loop();\n+        if (multiversion_if != nullptr) {\n+            useful_multiversioning_opaque_nodes.push(multiversion_if->in(1)->as_OpaqueMultiversioning());\n+        }\n+      }\n+    }\n+  }\n+\n+  for (uint i = 0; i < _multiversion_opaque_nodes.size(); i++) {\n+    OpaqueMultiversioningNode* opaque = _multiversion_opaque_nodes.at(i)->as_OpaqueMultiversioning();\n+    if (!useful_multiversioning_opaque_nodes.member(opaque)) {\n+      if (opaque->is_delayed_slow_loop()) {\n+        // We cannot hack the node directly, otherwise the slow_loop will complain that it cannot\n+        // find the multiversioning opaque node. Instead, we mark the opaque node as useless, and\n+        // it can be constant folded during IGVN.\n+        opaque->mark_useless();\n+        _igvn._worklist.push(opaque);\n+      }\n+    }\n+  }\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在C2 SuperWord多版本化优化中，当快速循环（fast loop）消失后，对应的慢速循环（slow loop）及其关联的多版本化条件判断（multiversion_if）可能变得无用，但仍保留在IR中，导致冗余代码执行。优化后：新增eliminate_useless_multiversion_if()函数，在循环优化阶段检测并标记无用的OpaqueMultiversioning节点，使其在后续IGVN阶段被常量折叠消除。优化思路：通过遍历循环树，识别与快速主循环关联的多版本化条件判断，收集仍有效的OpaqueMultiversioning节点；对于未关联到任何快速循环的节点（即无用节点），若其慢速循环仍处于延迟模式（未添加运行时检查），则标记为无用，触发常量折叠，从而移除冗余的慢速循环路径，减少不必要的控制流和潜在的性能开销。"}
{"id": 485, "source": "riscv-dataset-excel", "optimization_type": "指令优化", "optimization_description": "优化前：在revb函数中，执行srli指令后使用zext指令将Rd寄存器零扩展到8位。优化后：移除zext指令，因为srli指令已经将高56位清零，Rd寄存器低8位已包含正确值，无需额外零扩展操作。思路：消除冗余指令，减少指令数量，提高代码执行效率。", "original_code": "在revb函数中，执行srli指令后使用zext指令将Rd寄存器零扩展到8位。", "optimized_code": "-  zext(Rd, Rd, 8);", "source_url": "https://github.com/openjdk/riscv-port/commit/b1a21b563e3ae13fa5c409a4f0c04686c3f5b34a", "code_v0_no_empty_lines": "在revb函数中，执行srli指令后使用zext指令将Rd寄存器零扩展到8位。", "code_v1_no_empty_lines": "-  zext(Rd, Rd, 8);", "target": "-  zext(Rd, Rd, 8);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在revb函数中，执行srli指令后使用zext指令将Rd寄存器零扩展到8位。优化后：移除zext指令，因为srli指令已经将高56位清零，Rd寄存器低8位已包含正确值，无需额外零扩展操作。思路：消除冗余指令，减少指令数量，提高代码执行效率。"}
{"id": 486, "source": "riscv-dataset-excel", "optimization_type": "内存优化+数据结构优化", "optimization_description": "优化前：ZPageTable直接使用ZAddressOffsetMax作为映射大小，导致内存浪费。优化后：通过ZIndexDistributor::get_count()计算实际所需大小，根据不同的分配策略（Striped或ClaimTree）对齐到合适边界。思路：减少ZGC页表数据结构的内存占用，通过动态计算对齐后的实际大小来替代固定最大值，提高内存利用率。", "original_code": "ZPageTable直接使用ZAddressOffsetMax作为映射大小，导致内存浪费。", "optimized_code": "static size_t get_max_offset_for_map() {\n  // The page table has (ZAddressOffsetMax >> ZGranuleSizeShift) slots\n  const size_t max_count = ZAddressOffsetMax >> ZGranuleSizeShift;\n  const size_t required_count = ZIndexDistributor::get_count(max_count);\n\n  return required_count << ZGranuleSizeShift;\n}\n\nZPageTable::ZPageTable()\n  : _map(get_max_offset_for_map()) {}", "source_url": "https://github.com/openjdk/riscv-port/commit/1f10ffba88119caab169b1fc43ccfd143e3b85a6", "code_v0_no_empty_lines": "ZPageTable直接使用ZAddressOffsetMax作为映射大小，导致内存浪费。", "code_v1_no_empty_lines": "static size_t get_max_offset_for_map() {\n  // The page table has (ZAddressOffsetMax >> ZGranuleSizeShift) slots\n  const size_t max_count = ZAddressOffsetMax >> ZGranuleSizeShift;\n  const size_t required_count = ZIndexDistributor::get_count(max_count);\n\n  return required_count << ZGranuleSizeShift;\n}\n\nZPageTable::ZPageTable()\n  : _map(get_max_offset_for_map()) {}", "target": "static size_t get_max_offset_for_map() {\n  // The page table has (ZAddressOffsetMax >> ZGranuleSizeShift) slots\n  const size_t max_count = ZAddressOffsetMax >> ZGranuleSizeShift;\n  const size_t required_count = ZIndexDistributor::get_count(max_count);\n\n  return required_count << ZGranuleSizeShift;\n}\n\nZPageTable::ZPageTable()\n  : _map(get_max_offset_for_map()) {}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ZPageTable直接使用ZAddressOffsetMax作为映射大小，导致内存浪费。优化后：通过ZIndexDistributor::get_count()计算实际所需大小，根据不同的分配策略（Striped或ClaimTree）对齐到合适边界。思路：减少ZGC页表数据结构的内存占用，通过动态计算对齐后的实际大小来替代固定最大值，提高内存利用率。"}
{"id": 487, "source": "riscv-dataset-excel", "optimization_type": "内联优化+指令集优化", "optimization_description": "优化前：Thread.currentThread()方法在s390架构上未实现内联，调用返回nullptr，导致性能开销。优化后：为s390架构实现Thread.currentThread()的内联生成器，直接通过寄存器加载当前线程对象并解析句柄，减少函数调用开销，提升性能。优化思路：针对特定硬件架构实现关键Java方法的内联，避免通用路径的性能损失。", "original_code": "Thread.currentThread()方法在s390架构上未实现内联，调用返回nullptr，导致性能开销。", "optimized_code": "address TemplateInterpreterGenerator::generate_currentThread() {\n  uint64_t entry_off = __ offset();\n\n  __ z_lg(Z_RET, Address(Z_thread, JavaThread::threadObj_offset()));\n  __ resolve_oop_handle(Z_RET);\n\n  // Restore caller sp for c2i case.\n  __ resize_frame_absolute(Z_R10, Z_R0, true); // Cut the stack back to where the caller started.\n  __ z_br(Z_R14);\n\n  return __ addr_at(entry_off);\n}\n\n// Not supported\n-address TemplateInterpreterGenerator::generate_currentThread() { return nullptr; }", "source_url": "https://github.com/openjdk/riscv-port/commit/93c878455bfffc07f115f9e20ee11b20186eb2be", "code_v0_no_empty_lines": "Thread.currentThread()方法在s390架构上未实现内联，调用返回nullptr，导致性能开销。", "code_v1_no_empty_lines": "address TemplateInterpreterGenerator::generate_currentThread() {\n  uint64_t entry_off = __ offset();\n\n  __ z_lg(Z_RET, Address(Z_thread, JavaThread::threadObj_offset()));\n  __ resolve_oop_handle(Z_RET);\n\n  // Restore caller sp for c2i case.\n  __ resize_frame_absolute(Z_R10, Z_R0, true); // Cut the stack back to where the caller started.\n  __ z_br(Z_R14);\n\n  return __ addr_at(entry_off);\n}\n\n// Not supported\n-address TemplateInterpreterGenerator::generate_currentThread() { return nullptr; }", "target": "address TemplateInterpreterGenerator::generate_currentThread() {\n  uint64_t entry_off = __ offset();\n\n  __ z_lg(Z_RET, Address(Z_thread, JavaThread::threadObj_offset()));\n  __ resolve_oop_handle(Z_RET);\n\n  // Restore caller sp for c2i case.\n  __ resize_frame_absolute(Z_R10, Z_R0, true); // Cut the stack back to where the caller started.\n  __ z_br(Z_R14);\n\n  return __ addr_at(entry_off);\n}\n\n// Not supported\n-address TemplateInterpreterGenerator::generate_currentThread() { return nullptr; }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Thread.currentThread()方法在s390架构上未实现内联，调用返回nullptr，导致性能开销。优化后：为s390架构实现Thread.currentThread()的内联生成器，直接通过寄存器加载当前线程对象并解析句柄，减少函数调用开销，提升性能。优化思路：针对特定硬件架构实现关键Java方法的内联，避免通用路径的性能损失。"}
{"id": 488, "source": "riscv-dataset-excel", "optimization_type": "内联优化", "optimization_description": "优化前：多个Vector类中的checkMaskFromIndexSize方法被调用，该方法未被强制内联，导致方法调用开销。优化后：直接内联调用AbstractMask.checkIndexByLane方法，通过@ForceInline注解确保内联，消除方法调用开销，提升VectorAPI性能。", "original_code": "多个Vector类中的checkMaskFromIndexSize方法被调用，该方法未被强制内联，导致方法调用开销。", "optimized_code": "-        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        ((AbstractMask<Byte>)m)\n+            .checkIndexByLane(offset, a.length, vsp.iota(), 1);", "source_url": "https://github.com/openjdk/riscv-port/commit/d48ddfe49a4e0b07949912d3c91d6f4737658b3e", "code_v0_no_empty_lines": "多个Vector类中的checkMaskFromIndexSize方法被调用，该方法未被强制内联，导致方法调用开销。", "code_v1_no_empty_lines": "-        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        ((AbstractMask<Byte>)m)\n+            .checkIndexByLane(offset, a.length, vsp.iota(), 1);", "target": "-        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        ((AbstractMask<Byte>)m)\n+            .checkIndexByLane(offset, a.length, vsp.iota(), 1);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多个Vector类中的checkMaskFromIndexSize方法被调用，该方法未被强制内联，导致方法调用开销。优化后：直接内联调用AbstractMask.checkIndexByLane方法，通过@ForceInline注解确保内联，消除方法调用开销，提升VectorAPI性能。"}
{"id": 489, "source": "riscv-dataset-excel", "optimization_type": "GC暂停时间优化+并发性能优化", "optimization_description": "优化前：StringTable和SymbolTable的统计收集操作（statistics_get）在安全点（safepoint）期间执行，会阻塞所有Java线程，导致安全点延迟增加，影响GC暂停时间。优化后：引入StatisticsTask机制，将统计收集分解为可中断的小任务，在任务执行间隙插入ThreadBlockInVM允许安全点检查，避免长时间阻塞。同时重构了concurrentHashTable的统计接口，移除了同步的statistics_to方法，改为使用异步的统计任务。优化思路：通过任务分解和允许安全点中断，减少统计操作对GC暂停时间的影响，提升系统响应性。", "original_code": "StringTable和SymbolTable的统计收集操作（statistics_get）在安全点（safepoint）期间执行，会阻塞所有Java线程，导致安全点延迟增加，影响GC暂停时间。", "optimized_code": "TableStatistics StringTable::get_table_statistics() {\n  static TableStatistics ts;\n  SizeFunc sz;\n- ts = _local_table->statistics_get(Thread::current(), sz, ts);\n+ Thread* jt = Thread::current();\n+ StringTableHash::StatisticsTask sts(_local_table);\n+ if (!sts.prepare(jt)) {\n+   return ts;  // return old table statistics\n+ }\n+ {\n+   TraceTime timer(\"GetStatistics\", TRACETIME_LOG(Debug, stringtable, perf));\n+   while (sts.do_task(jt, sz)) {\n+     sts.pause(jt);\n+     if (jt->is_Java_thread()) {\n+       ThreadBlockInVM tbivm(JavaThread::cast(jt));\n+     }\n+     sts.cont(jt);\n+   }\n+ }\n+ ts = sts.done(jt);\n  return ts;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/1e18fffee456382c4eeb017b3fad0dc99ccaad35", "code_v0_no_empty_lines": "StringTable和SymbolTable的统计收集操作（statistics_get）在安全点（safepoint）期间执行，会阻塞所有Java线程，导致安全点延迟增加，影响GC暂停时间。", "code_v1_no_empty_lines": "TableStatistics StringTable::get_table_statistics() {\n  static TableStatistics ts;\n  SizeFunc sz;\n- ts = _local_table->statistics_get(Thread::current(), sz, ts);\n+ Thread* jt = Thread::current();\n+ StringTableHash::StatisticsTask sts(_local_table);\n+ if (!sts.prepare(jt)) {\n+   return ts;  // return old table statistics\n+ }\n+ {\n+   TraceTime timer(\"GetStatistics\", TRACETIME_LOG(Debug, stringtable, perf));\n+   while (sts.do_task(jt, sz)) {\n+     sts.pause(jt);\n+     if (jt->is_Java_thread()) {\n+       ThreadBlockInVM tbivm(JavaThread::cast(jt));\n+     }\n+     sts.cont(jt);\n+   }\n+ }\n+ ts = sts.done(jt);\n  return ts;\n}", "target": "TableStatistics StringTable::get_table_statistics() {\n  static TableStatistics ts;\n  SizeFunc sz;\n- ts = _local_table->statistics_get(Thread::current(), sz, ts);\n+ Thread* jt = Thread::current();\n+ StringTableHash::StatisticsTask sts(_local_table);\n+ if (!sts.prepare(jt)) {\n+   return ts;  // return old table statistics\n+ }\n+ {\n+   TraceTime timer(\"GetStatistics\", TRACETIME_LOG(Debug, stringtable, perf));\n+   while (sts.do_task(jt, sz)) {\n+     sts.pause(jt);\n+     if (jt->is_Java_thread()) {\n+       ThreadBlockInVM tbivm(JavaThread::cast(jt));\n+     }\n+     sts.cont(jt);\n+   }\n+ }\n+ ts = sts.done(jt);\n  return ts;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：StringTable和SymbolTable的统计收集操作（statistics_get）在安全点（safepoint）期间执行，会阻塞所有Java线程，导致安全点延迟增加，影响GC暂停时间。优化后：引入StatisticsTask机制，将统计收集分解为可中断的小任务，在任务执行间隙插入ThreadBlockInVM允许安全点检查，避免长时间阻塞。同时重构了concurrentHashTable的统计接口，移除了同步的statistics_to方法，改为使用异步的统计任务。优化思路：通过任务分解和允许安全点中断，减少统计操作对GC暂停时间的影响，提升系统响应性。"}
{"id": 490, "source": "riscv-dataset-excel", "optimization_type": "指令集优化/CPU特性启用", "optimization_description": "优化前：在Ampere AArch64 CPU上，UseSignumIntrinsic标志使用默认值（可能为false），未启用signum函数的内置优化。优化后：检测到Ampere CPU型号时，如果UseSignumIntrinsic标志未显式设置，则默认启用该优化。思路：利用Ampere CPU的特定硬件特性，通过启用signum函数的内置实现（intrinsic）来提升数学运算性能，减少函数调用开销。", "original_code": "在Ampere AArch64 CPU上，UseSignumIntrinsic标志使用默认值（可能为false），未启用signum函数的内置优化。", "optimized_code": "+    if (FLAG_IS_DEFAULT(UseSignumIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseSignumIntrinsic, true);\n+    }", "source_url": "https://github.com/openjdk/riscv-port/commit/f529bf712d8946584999dfc98abea60c22c97167", "code_v0_no_empty_lines": "在Ampere AArch64 CPU上，UseSignumIntrinsic标志使用默认值（可能为false），未启用signum函数的内置优化。", "code_v1_no_empty_lines": "+    if (FLAG_IS_DEFAULT(UseSignumIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseSignumIntrinsic, true);\n+    }", "target": "+    if (FLAG_IS_DEFAULT(UseSignumIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseSignumIntrinsic, true);\n+    }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在Ampere AArch64 CPU上，UseSignumIntrinsic标志使用默认值（可能为false），未启用signum函数的内置优化。优化后：检测到Ampere CPU型号时，如果UseSignumIntrinsic标志未显式设置，则默认启用该优化。思路：利用Ampere CPU的特定硬件特性，通过启用signum函数的内置实现（intrinsic）来提升数学运算性能，减少函数调用开销。"}
{"id": 491, "source": "riscv-dataset-excel", "optimization_type": "垃圾收集算法优化", "optimization_description": "优化前：新添加的年轻区域使用固定的InitialSurvivorRate作为初始幸存率预测，这可能导致预测不准确，影响垃圾收集效率。优化后：为新区域计算更合理的初始预测值new_pred，基于现有数组末尾的预测趋势（当数组长度>1时，使用最后两个预测值的差值；否则使用InitialSurvivorRate）。对于非首个新区域，使用前一个区域的最后预测值初始化预测器，并使用new_pred更新累积预测。优化思路：提供更贴近实际应用行为的初始幸存率预测，减少预测调整时间，提高G1垃圾收集器的效率。", "original_code": "新添加的年轻区域使用固定的InitialSurvivorRate作为初始幸存率预测，这可能导致预测不准确，影响垃圾收集效率。", "optimized_code": "for (size_t i = _stats_arrays_length; i < _num_added_regions; ++i) {\n      // Initialize predictors and accumulated survivor rate predictions.\n      _surv_rate_predictors[i] = new TruncatedSeq(10);\n-      _surv_rate_predictors[i]->add(InitialSurvivorRate);\n-      _accum_surv_rate_pred[i] = ((i == 0) ? 0.0 : _accum_surv_rate_pred[i-1]) + InitialSurvivorRate;\n+      if (i == 0) {\n+        _surv_rate_predictors[i]->add(InitialSurvivorRate);\n+        _accum_surv_rate_pred[i] = 0.0;\n+      } else {\n+        _surv_rate_predictors[i]->add(_surv_rate_predictors[i-1]->last());\n+        _accum_surv_rate_pred[i] = _accum_surv_rate_pred[i-1] + new_pred;\n+      }\n     }\n-    _last_pred = InitialSurvivorRate;\n+    _last_pred = new_pred;", "source_url": "https://github.com/openjdk/riscv-port/commit/aac9cb4537b13a4af123ae76f29359e851dc4c82", "code_v0_no_empty_lines": "新添加的年轻区域使用固定的InitialSurvivorRate作为初始幸存率预测，这可能导致预测不准确，影响垃圾收集效率。", "code_v1_no_empty_lines": "for (size_t i = _stats_arrays_length; i < _num_added_regions; ++i) {\n      // Initialize predictors and accumulated survivor rate predictions.\n      _surv_rate_predictors[i] = new TruncatedSeq(10);\n-      _surv_rate_predictors[i]->add(InitialSurvivorRate);\n-      _accum_surv_rate_pred[i] = ((i == 0) ? 0.0 : _accum_surv_rate_pred[i-1]) + InitialSurvivorRate;\n+      if (i == 0) {\n+        _surv_rate_predictors[i]->add(InitialSurvivorRate);\n+        _accum_surv_rate_pred[i] = 0.0;\n+      } else {\n+        _surv_rate_predictors[i]->add(_surv_rate_predictors[i-1]->last());\n+        _accum_surv_rate_pred[i] = _accum_surv_rate_pred[i-1] + new_pred;\n+      }\n     }\n-    _last_pred = InitialSurvivorRate;\n+    _last_pred = new_pred;", "target": "for (size_t i = _stats_arrays_length; i < _num_added_regions; ++i) {\n      // Initialize predictors and accumulated survivor rate predictions.\n      _surv_rate_predictors[i] = new TruncatedSeq(10);\n-      _surv_rate_predictors[i]->add(InitialSurvivorRate);\n-      _accum_surv_rate_pred[i] = ((i == 0) ? 0.0 : _accum_surv_rate_pred[i-1]) + InitialSurvivorRate;\n+      if (i == 0) {\n+        _surv_rate_predictors[i]->add(InitialSurvivorRate);\n+        _accum_surv_rate_pred[i] = 0.0;\n+      } else {\n+        _surv_rate_predictors[i]->add(_surv_rate_predictors[i-1]->last());\n+        _accum_surv_rate_pred[i] = _accum_surv_rate_pred[i-1] + new_pred;\n+      }\n     }\n-    _last_pred = InitialSurvivorRate;\n+    _last_pred = new_pred;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：新添加的年轻区域使用固定的InitialSurvivorRate作为初始幸存率预测，这可能导致预测不准确，影响垃圾收集效率。优化后：为新区域计算更合理的初始预测值new_pred，基于现有数组末尾的预测趋势（当数组长度>1时，使用最后两个预测值的差值；否则使用InitialSurvivorRate）。对于非首个新区域，使用前一个区域的最后预测值初始化预测器，并使用new_pred更新累积预测。优化思路：提供更贴近实际应用行为的初始幸存率预测，减少预测调整时间，提高G1垃圾收集器的效率。"}
{"id": 492, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（值编号优化）", "optimization_description": "优化前：向量交换操作（如加法、乘法等）的输入顺序可能不同（如vec1+vec2与vec2+vec1），导致全局值编号（GVN）无法识别它们是相同的计算，从而生成冗余的IR节点。优化后：在VectorNode::Ideal阶段，对于非谓词化的交换向量操作，通过should_swap_inputs_to_help_global_value_numbering()方法检查并统一交换输入顺序（按节点索引升序排列），确保相同计算具有一致的输入顺序。优化思路：通过规范化交换操作的输入顺序，帮助GVN更有效地识别和共享相同的IR节点，减少冗余计算，提升编译器优化效果和潜在运行时性能。", "original_code": "向量交换操作（如加法、乘法等）的输入顺序可能不同（如vec1+vec2与vec2+vec1），导致全局值编号（GVN）无法识别它们是相同的计算，从而生成冗余的IR节点。", "optimized_code": "bool VectorNode::should_swap_inputs_to_help_global_value_numbering() {\n  // ...\n  // For non-predicated commutative operations, sort the inputs in\n  // increasing order of node indices.\n  if (in(1)->_idx > in(2)->_idx) {\n    return true;\n  }\n  // fallthrough\n  default:\n    return false;\n}\n\nNode* VectorNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n  // ...\n  // Sort inputs of commutative non-predicated vector operations to help value numbering.\n  if (should_swap_inputs_to_help_global_value_numbering()) {\n    swap_edges(1, 2);\n  }\n  return nullptr;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/e410af00e69587b86536b298b869ddc898fd9862", "code_v0_no_empty_lines": "向量交换操作（如加法、乘法等）的输入顺序可能不同（如vec1+vec2与vec2+vec1），导致全局值编号（GVN）无法识别它们是相同的计算，从而生成冗余的IR节点。", "code_v1_no_empty_lines": "bool VectorNode::should_swap_inputs_to_help_global_value_numbering() {\n  // ...\n  // For non-predicated commutative operations, sort the inputs in\n  // increasing order of node indices.\n  if (in(1)->_idx > in(2)->_idx) {\n    return true;\n  }\n  // fallthrough\n  default:\n    return false;\n}\n\nNode* VectorNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n  // ...\n  // Sort inputs of commutative non-predicated vector operations to help value numbering.\n  if (should_swap_inputs_to_help_global_value_numbering()) {\n    swap_edges(1, 2);\n  }\n  return nullptr;\n}", "target": "bool VectorNode::should_swap_inputs_to_help_global_value_numbering() {\n  // ...\n  // For non-predicated commutative operations, sort the inputs in\n  // increasing order of node indices.\n  if (in(1)->_idx > in(2)->_idx) {\n    return true;\n  }\n  // fallthrough\n  default:\n    return false;\n}\n\nNode* VectorNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n  // ...\n  // Sort inputs of commutative non-predicated vector operations to help value numbering.\n  if (should_swap_inputs_to_help_global_value_numbering()) {\n    swap_edges(1, 2);\n  }\n  return nullptr;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：向量交换操作（如加法、乘法等）的输入顺序可能不同（如vec1+vec2与vec2+vec1），导致全局值编号（GVN）无法识别它们是相同的计算，从而生成冗余的IR节点。优化后：在VectorNode::Ideal阶段，对于非谓词化的交换向量操作，通过should_swap_inputs_to_help_global_value_numbering()方法检查并统一交换输入顺序（按节点索引升序排列），确保相同计算具有一致的输入顺序。优化思路：通过规范化交换操作的输入顺序，帮助GVN更有效地识别和共享相同的IR节点，减少冗余计算，提升编译器优化效果和潜在运行时性能。"}
{"id": 493, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+性能优化", "optimization_description": "优化前：ZGC的标记栈内存有严格限制（最多占用10%地址空间），需要复杂的分配器管理（zMarkStackAllocator），线程退出时需要释放标记栈（mark_flush_and_free）。优化后：移除了标记栈内存限制，使用无限制的标记栈内存，简化了内存管理架构，移除了zMarkStackAllocator模块，线程退出时只需刷新标记栈（mark_flush）。优化思路：通过消除标记栈的内存限制，简化了内存管理逻辑，减少了内存分配和释放的开销，提高了标记阶段的性能和可扩展性。", "original_code": "ZGC的标记栈内存有严格限制（最多占用10%地址空间），需要复杂的分配器管理（zMarkStackAllocator），线程退出时需要释放标记栈（mark_flush_and_free）。", "optimized_code": "- size_t ZAddressSpaceLimit::mark_stack() {\n-   // Allow mark stacks to occupy 10% of the address space\n-   const size_t limit = address_space_limit() / 10;\n-   return align_up(limit, ZMarkStackSpaceExpandSize);\n- }\n+ // 移除了mark_stack()函数及相关限制检查", "source_url": "https://github.com/openjdk/riscv-port/commit/65f79c145b7b1b32ed064a37ad4d2b6aca935a4c", "code_v0_no_empty_lines": "ZGC的标记栈内存有严格限制（最多占用10%地址空间），需要复杂的分配器管理（zMarkStackAllocator），线程退出时需要释放标记栈（mark_flush_and_free）。", "code_v1_no_empty_lines": "- size_t ZAddressSpaceLimit::mark_stack() {\n-   // Allow mark stacks to occupy 10% of the address space\n-   const size_t limit = address_space_limit() / 10;\n-   return align_up(limit, ZMarkStackSpaceExpandSize);\n- }\n+ // 移除了mark_stack()函数及相关限制检查", "target": "- size_t ZAddressSpaceLimit::mark_stack() {\n-   // Allow mark stacks to occupy 10% of the address space\n-   const size_t limit = address_space_limit() / 10;\n-   return align_up(limit, ZMarkStackSpaceExpandSize);\n- }\n+ // 移除了mark_stack()函数及相关限制检查", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ZGC的标记栈内存有严格限制（最多占用10%地址空间），需要复杂的分配器管理（zMarkStackAllocator），线程退出时需要释放标记栈（mark_flush_and_free）。优化后：移除了标记栈内存限制，使用无限制的标记栈内存，简化了内存管理架构，移除了zMarkStackAllocator模块，线程退出时只需刷新标记栈（mark_flush）。优化思路：通过消除标记栈的内存限制，简化了内存管理逻辑，减少了内存分配和释放的开销，提高了标记阶段的性能和可扩展性。"}
{"id": 494, "source": "riscv-dataset-excel", "optimization_type": "内联优化+指令优化", "optimization_description": "优化前：Class.isInstance 内联调用通过通用运行时调用机制，存在函数调用开销和间接跳转。优化后：1. 为 is_instance_of_id 创建专用 C1 stub，通过 rt_call 直接内联汇编实现，避免函数调用开销；2. 在 rt_call 中添加对 is_instance_of_id 的特殊处理，使用更高效的调用序列；3. 优化 repne_scan 函数，实现 2x 循环展开，减少分支预测失败和循环开销；4. 针对 Power10 处理器使用 setbc 指令替代分支，进一步减少分支开销。优化思路：通过专用内联汇编实现关键路径，减少间接调用和分支，利用现代 CPU 特性提升性能。", "original_code": "Class.isInstance 内联调用通过通用运行时调用机制，存在函数调用开销和间接跳转。", "optimized_code": "case C1StubId::is_instance_of_id:\n      {\n        // Called like a C function, but without FunctionDescriptor (see LIR_Assembler::rt_call).\n\n        // Arguments and return value.\n        Register mirror = R3_ARG1;\n        Register obj    = R4_ARG2;\n        Register result = R3_RET;\n\n        // Other argument registers can be used as temp registers.\n        Register klass  = R5;\n        Register offset = R6;\n        Register sub_klass = R7;\n\n        Label is_secondary, success;\n\n        // Get the Klass*.\n        __ ld(klass, java_lang_Class::klass_offset(), mirror);\n\n        // Return false if obj or klass is null.\n        mirror = noreg; // killed by next instruction\n        __ li(result, 0); // assume result is false\n        __ cmpdi(CR0, obj, 0);\n        __ cmpdi(CR1, klass, 0);\n        __ cror(CR0, Assembler::equal, CR1, Assembler::equal);\n        __ bclr(Assembler::bcondCRbiIs1, Assembler::bi0(CR0, Assembler::equal), Assembler::bhintbhBCLRisReturn);\n\n        __ lwz(offset, in_bytes(Klass::super_check_offset_offset()), klass);\n        __ load_klass(sub_klass, obj);\n        __ cmpwi(CR0, offset, in_bytes(Klass::secondary_super_cache_offset()));\n        __ beq(CR0, is_secondary); // Klass is a secondary superclass\n\n        // Klass is a concrete class\n        __ ldx(R0, sub_klass, offset);\n        __ cmpd(CR0, klass, R0);\n        if (VM_Version::has_brw()) {\n          // Power10 can set the result by one instruction. No need for a branch.\n          __ setbc(result, CR0, Assembler::equal);\n        } else {\n          __ beq(CR0, success);\n        }\n        __ blr();\n\n        __ bind(is_secondary);\n\n        // This is necessary because I am never in my own secondary_super list.\n        __ cmpd(CR0, sub_klass, klass);\n        __ beq(CR0, success);\n\n        __ lookup_secondary_supers_table_var(sub_klass, klass,\n                                             /*temps*/R9, R10, R11, R12,\n                                             /*result*/R8);\n        __ cmpdi(CR0, R8, 0); // 0 means is subclass\n        if (VM_Version::has_brw()) {\n          // Power10 can set the result by one instruction. No need for a branch.\n          __ setbc(result, CR0, Assembler::equal);\n        } else {\n          __ beq(CR0, success);\n        }\n        __ blr();\n\n        __ bind(success);\n        __ li(result, 1);\n        __ blr();\n      }", "source_url": "https://github.com/openjdk/riscv-port/commit/735805d9259037ae594eb4f75e96860d43feea5d", "code_v0_no_empty_lines": "Class.isInstance 内联调用通过通用运行时调用机制，存在函数调用开销和间接跳转。", "code_v1_no_empty_lines": "case C1StubId::is_instance_of_id:\n      {\n        // Called like a C function, but without FunctionDescriptor (see LIR_Assembler::rt_call).\n\n        // Arguments and return value.\n        Register mirror = R3_ARG1;\n        Register obj    = R4_ARG2;\n        Register result = R3_RET;\n\n        // Other argument registers can be used as temp registers.\n        Register klass  = R5;\n        Register offset = R6;\n        Register sub_klass = R7;\n\n        Label is_secondary, success;\n\n        // Get the Klass*.\n        __ ld(klass, java_lang_Class::klass_offset(), mirror);\n\n        // Return false if obj or klass is null.\n        mirror = noreg; // killed by next instruction\n        __ li(result, 0); // assume result is false\n        __ cmpdi(CR0, obj, 0);\n        __ cmpdi(CR1, klass, 0);\n        __ cror(CR0, Assembler::equal, CR1, Assembler::equal);\n        __ bclr(Assembler::bcondCRbiIs1, Assembler::bi0(CR0, Assembler::equal), Assembler::bhintbhBCLRisReturn);\n\n        __ lwz(offset, in_bytes(Klass::super_check_offset_offset()), klass);\n        __ load_klass(sub_klass, obj);\n        __ cmpwi(CR0, offset, in_bytes(Klass::secondary_super_cache_offset()));\n        __ beq(CR0, is_secondary); // Klass is a secondary superclass\n\n        // Klass is a concrete class\n        __ ldx(R0, sub_klass, offset);\n        __ cmpd(CR0, klass, R0);\n        if (VM_Version::has_brw()) {\n          // Power10 can set the result by one instruction. No need for a branch.\n          __ setbc(result, CR0, Assembler::equal);\n        } else {\n          __ beq(CR0, success);\n        }\n        __ blr();\n\n        __ bind(is_secondary);\n\n        // This is necessary because I am never in my own secondary_super list.\n        __ cmpd(CR0, sub_klass, klass);\n        __ beq(CR0, success);\n\n        __ lookup_secondary_supers_table_var(sub_klass, klass,\n                                             /*temps*/R9, R10, R11, R12,\n                                             /*result*/R8);\n        __ cmpdi(CR0, R8, 0); // 0 means is subclass\n        if (VM_Version::has_brw()) {\n          // Power10 can set the result by one instruction. No need for a branch.\n          __ setbc(result, CR0, Assembler::equal);\n        } else {\n          __ beq(CR0, success);\n        }\n        __ blr();\n\n        __ bind(success);\n        __ li(result, 1);\n        __ blr();\n      }", "target": "case C1StubId::is_instance_of_id:\n      {\n        // Called like a C function, but without FunctionDescriptor (see LIR_Assembler::rt_call).\n\n        // Arguments and return value.\n        Register mirror = R3_ARG1;\n        Register obj    = R4_ARG2;\n        Register result = R3_RET;\n\n        // Other argument registers can be used as temp registers.\n        Register klass  = R5;\n        Register offset = R6;\n        Register sub_klass = R7;\n\n        Label is_secondary, success;\n\n        // Get the Klass*.\n        __ ld(klass, java_lang_Class::klass_offset(), mirror);\n\n        // Return false if obj or klass is null.\n        mirror = noreg; // killed by next instruction\n        __ li(result, 0); // assume result is false\n        __ cmpdi(CR0, obj, 0);\n        __ cmpdi(CR1, klass, 0);\n        __ cror(CR0, Assembler::equal, CR1, Assembler::equal);\n        __ bclr(Assembler::bcondCRbiIs1, Assembler::bi0(CR0, Assembler::equal), Assembler::bhintbhBCLRisReturn);\n\n        __ lwz(offset, in_bytes(Klass::super_check_offset_offset()), klass);\n        __ load_klass(sub_klass, obj);\n        __ cmpwi(CR0, offset, in_bytes(Klass::secondary_super_cache_offset()));\n        __ beq(CR0, is_secondary); // Klass is a secondary superclass\n\n        // Klass is a concrete class\n        __ ldx(R0, sub_klass, offset);\n        __ cmpd(CR0, klass, R0);\n        if (VM_Version::has_brw()) {\n          // Power10 can set the result by one instruction. No need for a branch.\n          __ setbc(result, CR0, Assembler::equal);\n        } else {\n          __ beq(CR0, success);\n        }\n        __ blr();\n\n        __ bind(is_secondary);\n\n        // This is necessary because I am never in my own secondary_super list.\n        __ cmpd(CR0, sub_klass, klass);\n        __ beq(CR0, success);\n\n        __ lookup_secondary_supers_table_var(sub_klass, klass,\n                                             /*temps*/R9, R10, R11, R12,\n                                             /*result*/R8);\n        __ cmpdi(CR0, R8, 0); // 0 means is subclass\n        if (VM_Version::has_brw()) {\n          // Power10 can set the result by one instruction. No need for a branch.\n          __ setbc(result, CR0, Assembler::equal);\n        } else {\n          __ beq(CR0, success);\n        }\n        __ blr();\n\n        __ bind(success);\n        __ li(result, 1);\n        __ blr();\n      }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Class.isInstance 内联调用通过通用运行时调用机制，存在函数调用开销和间接跳转。优化后：1. 为 is_instance_of_id 创建专用 C1 stub，通过 rt_call 直接内联汇编实现，避免函数调用开销；2. 在 rt_call 中添加对 is_instance_of_id 的特殊处理，使用更高效的调用序列；3. 优化 repne_scan 函数，实现 2x 循环展开，减少分支预测失败和循环开销；4. 针对 Power10 处理器使用 setbc 指令替代分支，进一步减少分支开销。优化思路：通过专用内联汇编实现关键路径，减少间接调用和分支，利用现代 CPU 特性提升性能。"}
{"id": 495, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+目标平台优化", "optimization_description": "优化前：为PowerPC 64位小端架构（ppc64le）配置的JVM编译标志使用-mtune=power8，这意味着代码生成会针对Power8 CPU进行优化，可能无法充分利用Power10 CPU的新特性和性能改进。优化后：将-mtune参数从power8改为power10，使编译器生成的代码针对Power10 CPU进行优化，利用Power10的指令集扩展、流水线改进和其他微架构特性，从而提高在Power10 CPU上的运行性能。优化思路：针对特定CPU架构调整编译器优化目标，使生成的机器代码更好地匹配目标硬件的特性。", "original_code": "为PowerPC 64位小端架构（ppc64le）配置的JVM编译标志使用-mtune=power8，这意味着代码生成会针对Power8 CPU进行优化，可能无法充分利用Power10 CPU的新特性和性能改进。", "optimized_code": "-        $1_CFLAGS_CPU_JVM=\"${$1_CFLAGS_CPU_JVM} -DABI_ELFv2 -mcpu=power8 -mtune=power8\"\n+        $1_CFLAGS_CPU_JVM=\"${$1_CFLAGS_CPU_JVM} -DABI_ELFv2 -mcpu=power8 -mtune=power10\"", "source_url": "https://github.com/openjdk/riscv-port/commit/e1d0a9c832ef3e92faaed7f290ff56c0ed8a9d94", "code_v0_no_empty_lines": "为PowerPC 64位小端架构（ppc64le）配置的JVM编译标志使用-mtune=power8，这意味着代码生成会针对Power8 CPU进行优化，可能无法充分利用Power10 CPU的新特性和性能改进。", "code_v1_no_empty_lines": "-        $1_CFLAGS_CPU_JVM=\"${$1_CFLAGS_CPU_JVM} -DABI_ELFv2 -mcpu=power8 -mtune=power8\"\n+        $1_CFLAGS_CPU_JVM=\"${$1_CFLAGS_CPU_JVM} -DABI_ELFv2 -mcpu=power8 -mtune=power10\"", "target": "-        $1_CFLAGS_CPU_JVM=\"${$1_CFLAGS_CPU_JVM} -DABI_ELFv2 -mcpu=power8 -mtune=power8\"\n+        $1_CFLAGS_CPU_JVM=\"${$1_CFLAGS_CPU_JVM} -DABI_ELFv2 -mcpu=power8 -mtune=power10\"", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：为PowerPC 64位小端架构（ppc64le）配置的JVM编译标志使用-mtune=power8，这意味着代码生成会针对Power8 CPU进行优化，可能无法充分利用Power10 CPU的新特性和性能改进。优化后：将-mtune参数从power8改为power10，使编译器生成的代码针对Power10 CPU进行优化，利用Power10的指令集扩展、流水线改进和其他微架构特性，从而提高在Power10 CPU上的运行性能。优化思路：针对特定CPU架构调整编译器优化目标，使生成的机器代码更好地匹配目标硬件的特性。"}
{"id": 496, "source": "riscv-dataset-excel", "optimization_type": "虚函数优化+内存布局优化", "optimization_description": "优化前：CodeBlob及其子类（如nmethod）使用虚函数表（vtable）实现多态，导致内存开销和间接调用开销。优化后：通过静态断言确保所有CodeBlob子类都不是多态类型，移除虚函数表，改为使用基于kind枚举的静态vptr数组查找。优化思路：消除虚函数调用开销，简化内存布局，提高缓存局部性，特别有利于JIT编译代码的缓存和访问性能。", "original_code": "CodeBlob及其子类（如nmethod）使用虚函数表（vtable）实现多态，导致内存开销和间接调用开销。", "optimized_code": "static_assert(!std::is_polymorphic<nmethod>::value, \"no virtual methods are allowed in nmethod\");\nconst CodeBlob::Vptr* CodeBlob::vptr() const {\n  constexpr const CodeBlob::Vptr* array[(size_t)CodeBlobKind::Number_Of_Kinds] = {\n      nullptr/* None */,\n      &nmethod::_vptr,\n      &BufferBlob::_vptr,\n      &AdapterBlob::_vptr,\n      &VtableBlob::_vptr,\n      &MethodHandlesAdapterBlob::_vptr,\n      &RuntimeStub::_vptr,\n      &DeoptimizationBlob::_vptr,\n      &SafepointBlob::_vptr,\n#ifdef COMPILER2\n      &ExceptionBlob::_vptr,\n      &UncommonTrapBlob::_vptr,\n#endif\n      &UpcallStub::_vptr\n  };\n  return array[(size_t)_kind];\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/46d4a601e04f90b11d4ccc97a49f4e7010b4fd83", "code_v0_no_empty_lines": "CodeBlob及其子类（如nmethod）使用虚函数表（vtable）实现多态，导致内存开销和间接调用开销。", "code_v1_no_empty_lines": "static_assert(!std::is_polymorphic<nmethod>::value, \"no virtual methods are allowed in nmethod\");\nconst CodeBlob::Vptr* CodeBlob::vptr() const {\n  constexpr const CodeBlob::Vptr* array[(size_t)CodeBlobKind::Number_Of_Kinds] = {\n      nullptr/* None */,\n      &nmethod::_vptr,\n      &BufferBlob::_vptr,\n      &AdapterBlob::_vptr,\n      &VtableBlob::_vptr,\n      &MethodHandlesAdapterBlob::_vptr,\n      &RuntimeStub::_vptr,\n      &DeoptimizationBlob::_vptr,\n      &SafepointBlob::_vptr,\n#ifdef COMPILER2\n      &ExceptionBlob::_vptr,\n      &UncommonTrapBlob::_vptr,\n#endif\n      &UpcallStub::_vptr\n  };\n  return array[(size_t)_kind];\n}", "target": "static_assert(!std::is_polymorphic<nmethod>::value, \"no virtual methods are allowed in nmethod\");\nconst CodeBlob::Vptr* CodeBlob::vptr() const {\n  constexpr const CodeBlob::Vptr* array[(size_t)CodeBlobKind::Number_Of_Kinds] = {\n      nullptr/* None */,\n      &nmethod::_vptr,\n      &BufferBlob::_vptr,\n      &AdapterBlob::_vptr,\n      &VtableBlob::_vptr,\n      &MethodHandlesAdapterBlob::_vptr,\n      &RuntimeStub::_vptr,\n      &DeoptimizationBlob::_vptr,\n      &SafepointBlob::_vptr,\n#ifdef COMPILER2\n      &ExceptionBlob::_vptr,\n      &UncommonTrapBlob::_vptr,\n#endif\n      &UpcallStub::_vptr\n  };\n  return array[(size_t)_kind];\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CodeBlob及其子类（如nmethod）使用虚函数表（vtable）实现多态，导致内存开销和间接调用开销。优化后：通过静态断言确保所有CodeBlob子类都不是多态类型，移除虚函数表，改为使用基于kind枚举的静态vptr数组查找。优化思路：消除虚函数调用开销，简化内存布局，提高缓存局部性，特别有利于JIT编译代码的缓存和访问性能。"}
{"id": 497, "source": "riscv-dataset-excel", "optimization_type": "向量化指令优化", "optimization_description": "优化前：RISC-V后端缺少SelectFromTwoVector操作的向量化实现，导致该操作无法利用RVV向量指令集。优化后：新增select_from_two_vectors指令模式，通过vrgather_vv指令实现从两个向量中根据索引选择元素的功能，并添加了边界检查逻辑（当索引超出第一个向量长度时从第二个向量选择）。优化思路：为RISC-V架构实现C2编译器的SelectFromTwoVector向量化支持，提升向量操作的性能。", "original_code": "RISC-V后端缺少SelectFromTwoVector操作的向量化实现，导致该操作无法利用RVV向量指令集。", "optimized_code": "instruct select_from_two_vectors(vReg dst, vReg src1, vReg src2, vReg index, vRegMask_V0 v0, vReg tmp) %{\n  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n  effect(TEMP_DEF dst, TEMP v0, TEMP tmp);\n  format %{ \"select_from_two_vectors $dst, $src1, $src2, $index\" %}", "source_url": "https://github.com/openjdk/riscv-port/commit/885be2efa6b1359a7c7ab36882e19a7eaba77fb3", "code_v0_no_empty_lines": "RISC-V后端缺少SelectFromTwoVector操作的向量化实现，导致该操作无法利用RVV向量指令集。", "code_v1_no_empty_lines": "instruct select_from_two_vectors(vReg dst, vReg src1, vReg src2, vReg index, vRegMask_V0 v0, vReg tmp) %{\n  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n  effect(TEMP_DEF dst, TEMP v0, TEMP tmp);\n  format %{ \"select_from_two_vectors $dst, $src1, $src2, $index\" %}", "target": "instruct select_from_two_vectors(vReg dst, vReg src1, vReg src2, vReg index, vRegMask_V0 v0, vReg tmp) %{\n  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n  effect(TEMP_DEF dst, TEMP v0, TEMP tmp);\n  format %{ \"select_from_two_vectors $dst, $src1, $src2, $index\" %}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V后端缺少SelectFromTwoVector操作的向量化实现，导致该操作无法利用RVV向量指令集。优化后：新增select_from_two_vectors指令模式，通过vrgather_vv指令实现从两个向量中根据索引选择元素的功能，并添加了边界检查逻辑（当索引超出第一个向量长度时从第二个向量选择）。优化思路：为RISC-V架构实现C2编译器的SelectFromTwoVector向量化支持，提升向量操作的性能。"}
{"id": 498, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（C2 JIT编译器）", "optimization_description": "优化前：C2编译器对掩码检查的优化有限，主要处理(v << N) & M模式，当(-1 << N) & M == 0时折叠为零。优化后：引入更通用的AndIL_is_zero_element_under_mask函数，基于尾随零分析判断表达式在掩码下是否为零元素，支持(v1 + v2) & mask模式，当表达式的最低设置位高于掩码的最高设置位时，可简化为addend & mask。优化思路：从特定移位模式扩展到通用加法模式，利用尾随零分析和模运算性质，提升掩码检查优化的覆盖范围和效果。", "original_code": "C2编译器对掩码检查的优化有限，主要处理(v << N) & M模式，当(-1 << N) & M == 0时折叠为零。", "optimized_code": "- if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_INT, true)) {\n+ if (AndIL_is_zero_element_under_mask(phase, in(1), in(2), T_INT) ||\n+     AndIL_is_zero_element_under_mask(phase, in(2), in(1), T_INT)) {\n- Node* progress = AndIL_add_shift_and_mask(phase, T_INT);\n+ Node* progress = AndIL_sum_and_mask(phase, T_INT);", "source_url": "https://github.com/openjdk/riscv-port/commit/7f3ecb4d92fdb084ce632cab484cf4578487b090", "code_v0_no_empty_lines": "C2编译器对掩码检查的优化有限，主要处理(v << N) & M模式，当(-1 << N) & M == 0时折叠为零。", "code_v1_no_empty_lines": "- if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_INT, true)) {\n+ if (AndIL_is_zero_element_under_mask(phase, in(1), in(2), T_INT) ||\n+     AndIL_is_zero_element_under_mask(phase, in(2), in(1), T_INT)) {\n- Node* progress = AndIL_add_shift_and_mask(phase, T_INT);\n+ Node* progress = AndIL_sum_and_mask(phase, T_INT);", "target": "- if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_INT, true)) {\n+ if (AndIL_is_zero_element_under_mask(phase, in(1), in(2), T_INT) ||\n+     AndIL_is_zero_element_under_mask(phase, in(2), in(1), T_INT)) {\n- Node* progress = AndIL_add_shift_and_mask(phase, T_INT);\n+ Node* progress = AndIL_sum_and_mask(phase, T_INT);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器对掩码检查的优化有限，主要处理(v << N) & M模式，当(-1 << N) & M == 0时折叠为零。优化后：引入更通用的AndIL_is_zero_element_under_mask函数，基于尾随零分析判断表达式在掩码下是否为零元素，支持(v1 + v2) & mask模式，当表达式的最低设置位高于掩码的最高设置位时，可简化为addend & mask。优化思路：从特定移位模式扩展到通用加法模式，利用尾随零分析和模运算性质，提升掩码检查优化的覆盖范围和效果。"}
{"id": 499, "source": "riscv-dataset-excel", "optimization_type": "内联优化", "optimization_description": "优化前：Method类的invocation_count()、backedge_count()、highest_comp_level()等热方法访问器在.cpp文件中定义为普通成员函数，每次调用需要函数调用开销。优化后：将这些方法移至method.inline.hpp头文件并标记为inline，编译器可在调用点直接内联展开代码。优化思路：通过内联消除函数调用开销，提高任务选择等频繁调用的性能，同时更新相关文件包含关系以支持内联。", "original_code": "Method类的invocation_count()、backedge_count()、highest_comp_level()等热方法访问器在.cpp文件中定义为普通成员函数，每次调用需要函数调用开销。", "optimized_code": "- int Method::invocation_count() const;\n- int Method::backedge_count() const;\n- int Method::highest_comp_level() const;\n+ inline int Method::invocation_count() const;\n+ inline int Method::backedge_count() const;\n+ inline int Method::highest_comp_level() const;\n+ inline int Method::interpreter_invocation_count() const;", "source_url": "https://github.com/openjdk/riscv-port/commit/b1b48286a6cbee8a9f96d739ab437915c573022c", "code_v0_no_empty_lines": "Method类的invocation_count()、backedge_count()、highest_comp_level()等热方法访问器在.cpp文件中定义为普通成员函数，每次调用需要函数调用开销。", "code_v1_no_empty_lines": "- int Method::invocation_count() const;\n- int Method::backedge_count() const;\n- int Method::highest_comp_level() const;\n+ inline int Method::invocation_count() const;\n+ inline int Method::backedge_count() const;\n+ inline int Method::highest_comp_level() const;\n+ inline int Method::interpreter_invocation_count() const;", "target": "- int Method::invocation_count() const;\n- int Method::backedge_count() const;\n- int Method::highest_comp_level() const;\n+ inline int Method::invocation_count() const;\n+ inline int Method::backedge_count() const;\n+ inline int Method::highest_comp_level() const;\n+ inline int Method::interpreter_invocation_count() const;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Method类的invocation_count()、backedge_count()、highest_comp_level()等热方法访问器在.cpp文件中定义为普通成员函数，每次调用需要函数调用开销。优化后：将这些方法移至method.inline.hpp头文件并标记为inline，编译器可在调用点直接内联展开代码。优化思路：通过内联消除函数调用开销，提高任务选择等频繁调用的性能，同时更新相关文件包含关系以支持内联。"}
{"id": 501, "source": "riscv-dataset-excel", "optimization_type": "寄存器分配优化", "optimization_description": "优化前：C1编译器在AArch64架构下仅使用部分通用寄存器（GPR），未充分利用所有32个寄存器，特别是高编号寄存器（r19-r31）未被有效分配。优化后：通过引入pd_nof_available_regs=32常量，修改寄存器映射逻辑，使C1编译器能够使用更多高编号GPR寄存器（如r19-r26等），增加寄存器分配池。优化思路：扩展寄存器分配范围，减少栈溢出，提高代码生成质量，特别是在寄存器压力大的场景下能减少内存访问，提升性能。", "original_code": "C1编译器在AArch64架构下仅使用部分通用寄存器（GPR），未充分利用所有32个寄存器，特别是高编号寄存器（r19-r31）未被有效分配。", "optimized_code": "enum {\n+  pd_nof_available_regs = 32,\n   pd_nof_cpu_regs_frame_map = Register::number_of_registers,\n   pd_nof_fpu_regs_frame_map = FloatRegister::number_of_registers,\n-  pd_nof_caller_save_cpu_regs_frame_map = 19 - 2 /* rscratch1 and rscratch2 */ R18_RESERVED_ONLY(- 1),\n+  pd_nof_caller_save_cpu_regs_frame_map = pd_nof_available_regs,\n   pd_nof_caller_save_fpu_regs_frame_map = 32,\n-  pd_first_callee_saved_reg = 19 - 2 /* rscratch1 and rscratch2 */ R18_RESERVED_ONLY(- 1),\n-  pd_last_callee_saved_reg = 26 - 2 /* rscratch1 and rscratch2 */ R18_RESERVED_ONLY(- 1),\n+  pd_first_callee_saved_reg = pd_nof_available_regs - 1,\n+  pd_last_callee_saved_reg = pd_first_callee_saved_reg - 1,\n-  pd_last_allocatable_cpu_reg = 16 R18_RESERVED_ONLY(- 1),\n+  pd_last_allocatable_cpu_reg = pd_nof_available_regs - 1,\n   pd_nof_cpu_regs_reg_alloc = pd_last_allocatable_cpu_reg + 1,\n   pd_nof_cpu_regs_linearscan = pd_nof_cpu_regs_reg_alloc,\n   pd_nof_fpu_regs_linearscan = pd_nof_fpu_regs_frame_map,\n   pd_nof_xmm_regs_linearscan = 0,\n   pd_first_cpu_reg = 0,\n-  pd_last_cpu_reg = 16 R18_RESERVED_ONLY(- 1),\n+  pd_last_cpu_reg = pd_nof_available_regs - 1,\n   pd_first_byte_reg = 0,\n-  pd_last_byte_reg = 16 R18_RESERVED_ONLY(- 1),\n+  pd_last_byte_reg = pd_last_cpu_reg,\n   pd_first_fpu_reg = pd_nof_cpu_regs_frame_map,\n   pd_last_fpu_reg =  pd_first_fpu_reg + 31", "source_url": "https://github.com/openjdk/riscv-port/commit/57f4c30fb6be1da57c8fcc742b5c36d842eef397", "code_v0_no_empty_lines": "C1编译器在AArch64架构下仅使用部分通用寄存器（GPR），未充分利用所有32个寄存器，特别是高编号寄存器（r19-r31）未被有效分配。", "code_v1_no_empty_lines": "enum {\n+  pd_nof_available_regs = 32,\n   pd_nof_cpu_regs_frame_map = Register::number_of_registers,\n   pd_nof_fpu_regs_frame_map = FloatRegister::number_of_registers,\n-  pd_nof_caller_save_cpu_regs_frame_map = 19 - 2 /* rscratch1 and rscratch2 */ R18_RESERVED_ONLY(- 1),\n+  pd_nof_caller_save_cpu_regs_frame_map = pd_nof_available_regs,\n   pd_nof_caller_save_fpu_regs_frame_map = 32,\n-  pd_first_callee_saved_reg = 19 - 2 /* rscratch1 and rscratch2 */ R18_RESERVED_ONLY(- 1),\n-  pd_last_callee_saved_reg = 26 - 2 /* rscratch1 and rscratch2 */ R18_RESERVED_ONLY(- 1),\n+  pd_first_callee_saved_reg = pd_nof_available_regs - 1,\n+  pd_last_callee_saved_reg = pd_first_callee_saved_reg - 1,\n-  pd_last_allocatable_cpu_reg = 16 R18_RESERVED_ONLY(- 1),\n+  pd_last_allocatable_cpu_reg = pd_nof_available_regs - 1,\n   pd_nof_cpu_regs_reg_alloc = pd_last_allocatable_cpu_reg + 1,\n   pd_nof_cpu_regs_linearscan = pd_nof_cpu_regs_reg_alloc,\n   pd_nof_fpu_regs_linearscan = pd_nof_fpu_regs_frame_map,\n   pd_nof_xmm_regs_linearscan = 0,\n   pd_first_cpu_reg = 0,\n-  pd_last_cpu_reg = 16 R18_RESERVED_ONLY(- 1),\n+  pd_last_cpu_reg = pd_nof_available_regs - 1,\n   pd_first_byte_reg = 0,\n-  pd_last_byte_reg = 16 R18_RESERVED_ONLY(- 1),\n+  pd_last_byte_reg = pd_last_cpu_reg,\n   pd_first_fpu_reg = pd_nof_cpu_regs_frame_map,\n   pd_last_fpu_reg =  pd_first_fpu_reg + 31", "target": "enum {\n+  pd_nof_available_regs = 32,\n   pd_nof_cpu_regs_frame_map = Register::number_of_registers,\n   pd_nof_fpu_regs_frame_map = FloatRegister::number_of_registers,\n-  pd_nof_caller_save_cpu_regs_frame_map = 19 - 2 /* rscratch1 and rscratch2 */ R18_RESERVED_ONLY(- 1),\n+  pd_nof_caller_save_cpu_regs_frame_map = pd_nof_available_regs,\n   pd_nof_caller_save_fpu_regs_frame_map = 32,\n-  pd_first_callee_saved_reg = 19 - 2 /* rscratch1 and rscratch2 */ R18_RESERVED_ONLY(- 1),\n-  pd_last_callee_saved_reg = 26 - 2 /* rscratch1 and rscratch2 */ R18_RESERVED_ONLY(- 1),\n+  pd_first_callee_saved_reg = pd_nof_available_regs - 1,\n+  pd_last_callee_saved_reg = pd_first_callee_saved_reg - 1,\n-  pd_last_allocatable_cpu_reg = 16 R18_RESERVED_ONLY(- 1),\n+  pd_last_allocatable_cpu_reg = pd_nof_available_regs - 1,\n   pd_nof_cpu_regs_reg_alloc = pd_last_allocatable_cpu_reg + 1,\n   pd_nof_cpu_regs_linearscan = pd_nof_cpu_regs_reg_alloc,\n   pd_nof_fpu_regs_linearscan = pd_nof_fpu_regs_frame_map,\n   pd_nof_xmm_regs_linearscan = 0,\n   pd_first_cpu_reg = 0,\n-  pd_last_cpu_reg = 16 R18_RESERVED_ONLY(- 1),\n+  pd_last_cpu_reg = pd_nof_available_regs - 1,\n   pd_first_byte_reg = 0,\n-  pd_last_byte_reg = 16 R18_RESERVED_ONLY(- 1),\n+  pd_last_byte_reg = pd_last_cpu_reg,\n   pd_first_fpu_reg = pd_nof_cpu_regs_frame_map,\n   pd_last_fpu_reg =  pd_first_fpu_reg + 31", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C1编译器在AArch64架构下仅使用部分通用寄存器（GPR），未充分利用所有32个寄存器，特别是高编号寄存器（r19-r31）未被有效分配。优化后：通过引入pd_nof_available_regs=32常量，修改寄存器映射逻辑，使C1编译器能够使用更多高编号GPR寄存器（如r19-r26等），增加寄存器分配池。优化思路：扩展寄存器分配范围，减少栈溢出，提高代码生成质量，特别是在寄存器压力大的场景下能减少内存访问，提升性能。"}
{"id": 502, "source": "riscv-dataset-excel", "optimization_type": "编译优化", "optimization_description": "优化前：构建splashscreen库时使用LOW优化级别，可能导致生成的二进制文件体积较大或性能未达最佳。优化后：将优化级别从LOW改为SIZE，编译器会优先优化生成的二进制文件体积，减少内存占用和磁盘空间使用。思路：针对启动画面库这种对启动速度敏感但体积需控制的场景，SIZE优化能在保证必要性能的同时最小化库文件大小。", "original_code": "构建splashscreen库时使用LOW优化级别，可能导致生成的二进制文件体积较大或性能未达最佳。", "optimized_code": "-      OPTIMIZATION := LOW, \\\n+      OPTIMIZATION := SIZE, \\", "source_url": "https://github.com/openjdk/riscv-port/commit/c2fc94782669ae1645014ee3bfeba957dbff4669", "code_v0_no_empty_lines": "构建splashscreen库时使用LOW优化级别，可能导致生成的二进制文件体积较大或性能未达最佳。", "code_v1_no_empty_lines": "-      OPTIMIZATION := LOW, \\\n+      OPTIMIZATION := SIZE, \\", "target": "-      OPTIMIZATION := LOW, \\\n+      OPTIMIZATION := SIZE, \\", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：构建splashscreen库时使用LOW优化级别，可能导致生成的二进制文件体积较大或性能未达最佳。优化后：将优化级别从LOW改为SIZE，编译器会优先优化生成的二进制文件体积，减少内存占用和磁盘空间使用。思路：针对启动画面库这种对启动速度敏感但体积需控制的场景，SIZE优化能在保证必要性能的同时最小化库文件大小。"}
{"id": 503, "source": "riscv-dataset-excel", "optimization_type": "指令调度优化+内存访问优化", "optimization_description": "优化前：1. LU/UL字符串比较时先加载数据再检查阈值，可能导致不必要的内存访问；2. 对齐检查条件错误，当base_offset1不是8字节对齐时未进行额外加载。优化后：1. 将阈值检查提前到内存加载之前，避免短字符串时的冗余内存访问；2. 修正对齐条件，确保在非8字节对齐时加载额外4字节数据以保证主循环8字节对齐。优化思路：通过指令重排减少内存访问开销，修正对齐逻辑避免非对齐访问惩罚，提升RISC-V平台在特定标志下的字符串比较性能。", "original_code": "1. LU/UL字符串比较时先加载数据再检查阈值，可能导致不必要的内存访问；2. 对齐检查条件错误，当base_offset1不是8字节对齐时未进行额外加载。", "optimized_code": "1. c2_MacroAssembler_riscv.cpp中LU和UL情况的指令重排：\n- lwu(tmp1, Address(str1));\n- load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n+ mv(t0, STUB_THRESHOLD);\n+ bge(cnt2, t0, STUB);\n+ lwu(tmp1, Address(str1));\n+ load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n\n2. stubGenerator_riscv.cpp中条件判断修正：\n- if (AvoidUnalignedAccesses && (base_offset1 % 8) == 0) {\n+ if (AvoidUnalignedAccesses && (base_offset1 % 8) != 0) {", "source_url": "https://github.com/openjdk/riscv-port/commit/d104debe51d8feb35b7c672a9d05404208bc5526", "code_v0_no_empty_lines": "1. LU/UL字符串比较时先加载数据再检查阈值，可能导致不必要的内存访问；2. 对齐检查条件错误，当base_offset1不是8字节对齐时未进行额外加载。", "code_v1_no_empty_lines": "1. c2_MacroAssembler_riscv.cpp中LU和UL情况的指令重排：\n- lwu(tmp1, Address(str1));\n- load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n+ mv(t0, STUB_THRESHOLD);\n+ bge(cnt2, t0, STUB);\n+ lwu(tmp1, Address(str1));\n+ load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n\n2. stubGenerator_riscv.cpp中条件判断修正：\n- if (AvoidUnalignedAccesses && (base_offset1 % 8) == 0) {\n+ if (AvoidUnalignedAccesses && (base_offset1 % 8) != 0) {", "target": "1. c2_MacroAssembler_riscv.cpp中LU和UL情况的指令重排：\n- lwu(tmp1, Address(str1));\n- load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n+ mv(t0, STUB_THRESHOLD);\n+ bge(cnt2, t0, STUB);\n+ lwu(tmp1, Address(str1));\n+ load_long_misaligned(tmp2, Address(str2), tmp3, (base_offset2 % 8) != 0 ? 4 : 8);\n\n2. stubGenerator_riscv.cpp中条件判断修正：\n- if (AvoidUnalignedAccesses && (base_offset1 % 8) == 0) {\n+ if (AvoidUnalignedAccesses && (base_offset1 % 8) != 0) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. LU/UL字符串比较时先加载数据再检查阈值，可能导致不必要的内存访问；2. 对齐检查条件错误，当base_offset1不是8字节对齐时未进行额外加载。优化后：1. 将阈值检查提前到内存加载之前，避免短字符串时的冗余内存访问；2. 修正对齐条件，确保在非8字节对齐时加载额外4字节数据以保证主循环8字节对齐。优化思路：通过指令重排减少内存访问开销，修正对齐逻辑避免非对齐访问惩罚，提升RISC-V平台在特定标志下的字符串比较性能。"}
{"id": 504, "source": "riscv-dataset-excel", "optimization_type": "内联优化+性能优化", "optimization_description": "优化前：Class.getModifiers() 是 native 方法，需要通过 JNI 调用，存在额外开销。优化后：将 getModifiers() 实现为 Java 方法，通过内联访问 Klass::modifier_flags 字段，避免了 JNI 调用开销，提高了反射性能。", "original_code": "Class.getModifiers() 是 native 方法，需要通过 JNI 调用，存在额外开销。", "optimized_code": "- case vmIntrinsics::_getModifiers: {\n    assert(x->number_of_arguments() == 1, \"wrong type\");\n\n    // Optimize for Foo.class.getModifier()\n    InstanceConstant* c = x->argument_at(0)->type()->as_InstanceConstant();\n    if (c != nullptr && !c->value()->is_null_object()) {\n      ciType* t = c->value()->java_mirror_type();\n      if (t->is_klass()) {\n        set_constant(t->as_klass()->modifier_flags());\n      } else {\n        assert(t->is_primitive_type(), \"should be a primitive type\");\n        set_constant(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n      }\n    }\n    break;\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/c9cadbd23fb13933b8968f283d27842cd35f8d6f", "code_v0_no_empty_lines": "Class.getModifiers() 是 native 方法，需要通过 JNI 调用，存在额外开销。", "code_v1_no_empty_lines": "- case vmIntrinsics::_getModifiers: {\n    assert(x->number_of_arguments() == 1, \"wrong type\");\n\n    // Optimize for Foo.class.getModifier()\n    InstanceConstant* c = x->argument_at(0)->type()->as_InstanceConstant();\n    if (c != nullptr && !c->value()->is_null_object()) {\n      ciType* t = c->value()->java_mirror_type();\n      if (t->is_klass()) {\n        set_constant(t->as_klass()->modifier_flags());\n      } else {\n        assert(t->is_primitive_type(), \"should be a primitive type\");\n        set_constant(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n      }\n    }\n    break;\n  }", "target": "- case vmIntrinsics::_getModifiers: {\n    assert(x->number_of_arguments() == 1, \"wrong type\");\n\n    // Optimize for Foo.class.getModifier()\n    InstanceConstant* c = x->argument_at(0)->type()->as_InstanceConstant();\n    if (c != nullptr && !c->value()->is_null_object()) {\n      ciType* t = c->value()->java_mirror_type();\n      if (t->is_klass()) {\n        set_constant(t->as_klass()->modifier_flags());\n      } else {\n        assert(t->is_primitive_type(), \"should be a primitive type\");\n        set_constant(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n      }\n    }\n    break;\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Class.getModifiers() 是 native 方法，需要通过 JNI 调用，存在额外开销。优化后：将 getModifiers() 实现为 Java 方法，通过内联访问 Klass::modifier_flags 字段，避免了 JNI 调用开销，提高了反射性能。"}
{"id": 505, "source": "riscv-dataset-excel", "optimization_type": "内联优化+指令集优化", "optimization_description": "优化前：Class.isInstance() 方法调用需要经过完整的 Java 方法调用开销，包括参数传递、栈帧设置和返回处理。优化后：为 C1 编译器添加了 Class.isInstance 内联函数，在多个架构（aarch64、x86、arm、ppc、riscv、s390）上实现了专用的汇编代码路径。优化思路：通过内联优化将高频使用的 Class.isInstance 方法转换为直接的类型检查汇编代码，避免了方法调用开销，并针对具体架构优化寄存器分配和分支预测，显著提升了类型检查性能。", "original_code": "Class.isInstance() 方法调用需要经过完整的 Java 方法调用开销，包括参数传递、栈帧设置和返回处理。", "optimized_code": "case C1StubId::is_instance_of_id:\n      {\n        // Mirror: c_rarg0\n        // Object: c_rarg1\n        // Temps: r3, r4, r5, r6\n        // Result: r0\n\n        // Get the Klass* into c_rarg6\n        Register klass = c_rarg6, obj = c_rarg1, result = r0;\n        __ ldr(klass, Address(c_rarg0, java_lang_Class::klass_offset()));\n\n        Label fail, is_secondary, success;\n\n        __ cbz(klass, fail); // Klass is null\n        __ cbz(obj, fail); // obj is null\n\n        __ ldrw(r3, Address(klass, in_bytes(Klass::super_check_offset_offset())));\n        __ cmpw(r3, in_bytes(Klass::secondary_super_cache_offset()));\n        __ br(Assembler::EQ, is_secondary); // Klass is a secondary superclass\n\n        // Klass is a concrete class\n        __ load_klass(r5, obj);\n        __ ldr(rscratch1, Address(r5, r3));\n        __ cmp(klass, rscratch1);\n        __ cset(result, Assembler::EQ);\n        __ ret(lr);\n\n        __ bind(is_secondary);\n\n        __ load_klass(obj, obj);\n\n        // This is necessary because I am never in my own secondary_super list.\n        __ cmp(obj, klass);\n        __ br(Assembler::EQ, success);\n\n        __ lookup_secondary_supers_table_var(obj, klass,\n                                             /*temps*/r3, r4, r5, v0,\n                                             result,\n                                             &success);\n        __ bind(fail);\n        __ mov(result, 0);\n        __ ret(lr);\n\n        __ bind(success);\n        __ mov(result, 1);\n        __ ret(lr);\n      }", "source_url": "https://github.com/openjdk/riscv-port/commit/b40f8eef98dac066816d4d548b2304276a76d5e0", "code_v0_no_empty_lines": "Class.isInstance() 方法调用需要经过完整的 Java 方法调用开销，包括参数传递、栈帧设置和返回处理。", "code_v1_no_empty_lines": "case C1StubId::is_instance_of_id:\n      {\n        // Mirror: c_rarg0\n        // Object: c_rarg1\n        // Temps: r3, r4, r5, r6\n        // Result: r0\n\n        // Get the Klass* into c_rarg6\n        Register klass = c_rarg6, obj = c_rarg1, result = r0;\n        __ ldr(klass, Address(c_rarg0, java_lang_Class::klass_offset()));\n\n        Label fail, is_secondary, success;\n\n        __ cbz(klass, fail); // Klass is null\n        __ cbz(obj, fail); // obj is null\n\n        __ ldrw(r3, Address(klass, in_bytes(Klass::super_check_offset_offset())));\n        __ cmpw(r3, in_bytes(Klass::secondary_super_cache_offset()));\n        __ br(Assembler::EQ, is_secondary); // Klass is a secondary superclass\n\n        // Klass is a concrete class\n        __ load_klass(r5, obj);\n        __ ldr(rscratch1, Address(r5, r3));\n        __ cmp(klass, rscratch1);\n        __ cset(result, Assembler::EQ);\n        __ ret(lr);\n\n        __ bind(is_secondary);\n\n        __ load_klass(obj, obj);\n\n        // This is necessary because I am never in my own secondary_super list.\n        __ cmp(obj, klass);\n        __ br(Assembler::EQ, success);\n\n        __ lookup_secondary_supers_table_var(obj, klass,\n                                             /*temps*/r3, r4, r5, v0,\n                                             result,\n                                             &success);\n        __ bind(fail);\n        __ mov(result, 0);\n        __ ret(lr);\n\n        __ bind(success);\n        __ mov(result, 1);\n        __ ret(lr);\n      }", "target": "case C1StubId::is_instance_of_id:\n      {\n        // Mirror: c_rarg0\n        // Object: c_rarg1\n        // Temps: r3, r4, r5, r6\n        // Result: r0\n\n        // Get the Klass* into c_rarg6\n        Register klass = c_rarg6, obj = c_rarg1, result = r0;\n        __ ldr(klass, Address(c_rarg0, java_lang_Class::klass_offset()));\n\n        Label fail, is_secondary, success;\n\n        __ cbz(klass, fail); // Klass is null\n        __ cbz(obj, fail); // obj is null\n\n        __ ldrw(r3, Address(klass, in_bytes(Klass::super_check_offset_offset())));\n        __ cmpw(r3, in_bytes(Klass::secondary_super_cache_offset()));\n        __ br(Assembler::EQ, is_secondary); // Klass is a secondary superclass\n\n        // Klass is a concrete class\n        __ load_klass(r5, obj);\n        __ ldr(rscratch1, Address(r5, r3));\n        __ cmp(klass, rscratch1);\n        __ cset(result, Assembler::EQ);\n        __ ret(lr);\n\n        __ bind(is_secondary);\n\n        __ load_klass(obj, obj);\n\n        // This is necessary because I am never in my own secondary_super list.\n        __ cmp(obj, klass);\n        __ br(Assembler::EQ, success);\n\n        __ lookup_secondary_supers_table_var(obj, klass,\n                                             /*temps*/r3, r4, r5, v0,\n                                             result,\n                                             &success);\n        __ bind(fail);\n        __ mov(result, 0);\n        __ ret(lr);\n\n        __ bind(success);\n        __ mov(result, 1);\n        __ ret(lr);\n      }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Class.isInstance() 方法调用需要经过完整的 Java 方法调用开销，包括参数传递、栈帧设置和返回处理。优化后：为 C1 编译器添加了 Class.isInstance 内联函数，在多个架构（aarch64、x86、arm、ppc、riscv、s390）上实现了专用的汇编代码路径。优化思路：通过内联优化将高频使用的 Class.isInstance 方法转换为直接的类型检查汇编代码，避免了方法调用开销，并针对具体架构优化寄存器分配和分支预测，显著提升了类型检查性能。"}
{"id": 506, "source": "riscv-dataset-excel", "optimization_type": "内存优化+数据结构优化", "optimization_description": "优化前：每个老年代区域使用独立的G1CardSet实例，导致内存碎片和重复开销。优化后：引入G1CSetCandidateGroup，允许多个老年代区域共享同一个G1CardSet实例，减少内存分配和碎片。思路：通过分组机制合并卡片集管理，降低GC元数据开销，提升内存局部性和扫描效率。", "original_code": "每个老年代区域使用独立的G1CardSet实例，导致内存碎片和重复开销。", "optimized_code": "- G1CardSet _young_regions_cardset;\n+ G1CSetCandidateGroup _young_regions_cset_group;\n- hr->install_group_cardset(young_regions_cardset());\n+ young_regions_cset_group()->add(hr);", "source_url": "https://github.com/openjdk/riscv-port/commit/86cec4ea2c2c56f03b23be44caade49b922cd3c6", "code_v0_no_empty_lines": "每个老年代区域使用独立的G1CardSet实例，导致内存碎片和重复开销。", "code_v1_no_empty_lines": "- G1CardSet _young_regions_cardset;\n+ G1CSetCandidateGroup _young_regions_cset_group;\n- hr->install_group_cardset(young_regions_cardset());\n+ young_regions_cset_group()->add(hr);", "target": "- G1CardSet _young_regions_cardset;\n+ G1CSetCandidateGroup _young_regions_cset_group;\n- hr->install_group_cardset(young_regions_cardset());\n+ young_regions_cset_group()->add(hr);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每个老年代区域使用独立的G1CardSet实例，导致内存碎片和重复开销。优化后：引入G1CSetCandidateGroup，允许多个老年代区域共享同一个G1CardSet实例，减少内存分配和碎片。思路：通过分组机制合并卡片集管理，降低GC元数据开销，提升内存局部性和扫描效率。"}
{"id": 507, "source": "riscv-dataset-excel", "optimization_type": "日期时间处理优化", "optimization_description": "优化前使用SimpleDateFormat进行日期解析，每次调用都创建新对象，且需要处理ParseException异常。优化后使用java.time API（LocalDateTime.parse + DateTimeFormatter.ISO_LOCAL_DATE_TIME），避免了对象创建开销，简化了异常处理（DateTimeParseException替代ParseException），提高了日期比较的性能。", "original_code": "// No original code extracted from description\n", "optimized_code": "-        private static boolean isPastCutoverDate(String s)\n-                throws ParseException {\n-            SimpleDateFormat format = new SimpleDateFormat(\n-                    \"yyyy-MM-dd'T'HH:mm:ss\", Locale.ROOT);\n-            format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-            format.setLenient(false);\n-            long time = format.parse(s.trim()).getTime();\n-            return System.currentTimeMillis() > time;\n-\n+        // cutOver adheres to ISO8601 Local Date Time format (excluding nano secs)\n+        private static boolean isPastCutoverDate(String cutOver) {\n+            return System.currentTimeMillis() >\n+                    LocalDateTime.parse(cutOver, DateTimeFormatter.ISO_LOCAL_DATE_TIME)\n+                            .toInstant(ZoneOffset.UTC)\n+                            .toEpochMilli();", "source_url": "https://github.com/openjdk/riscv-port/commit/250ff86dc86f73dbf7c944d9b5a792c4bdfeef0d", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "-        private static boolean isPastCutoverDate(String s)\n-                throws ParseException {\n-            SimpleDateFormat format = new SimpleDateFormat(\n-                    \"yyyy-MM-dd'T'HH:mm:ss\", Locale.ROOT);\n-            format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-            format.setLenient(false);\n-            long time = format.parse(s.trim()).getTime();\n-            return System.currentTimeMillis() > time;\n-\n+        // cutOver adheres to ISO8601 Local Date Time format (excluding nano secs)\n+        private static boolean isPastCutoverDate(String cutOver) {\n+            return System.currentTimeMillis() >\n+                    LocalDateTime.parse(cutOver, DateTimeFormatter.ISO_LOCAL_DATE_TIME)\n+                            .toInstant(ZoneOffset.UTC)\n+                            .toEpochMilli();", "target": "-        private static boolean isPastCutoverDate(String s)\n-                throws ParseException {\n-            SimpleDateFormat format = new SimpleDateFormat(\n-                    \"yyyy-MM-dd'T'HH:mm:ss\", Locale.ROOT);\n-            format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-            format.setLenient(false);\n-            long time = format.parse(s.trim()).getTime();\n-            return System.currentTimeMillis() > time;\n-\n+        // cutOver adheres to ISO8601 Local Date Time format (excluding nano secs)\n+        private static boolean isPastCutoverDate(String cutOver) {\n+            return System.currentTimeMillis() >\n+                    LocalDateTime.parse(cutOver, DateTimeFormatter.ISO_LOCAL_DATE_TIME)\n+                            .toInstant(ZoneOffset.UTC)\n+                            .toEpochMilli();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用SimpleDateFormat进行日期解析，每次调用都创建新对象，且需要处理ParseException异常。优化后使用java.time API（LocalDateTime.parse + DateTimeFormatter.ISO_LOCAL_DATE_TIME），避免了对象创建开销，简化了异常处理（DateTimeParseException替代ParseException），提高了日期比较的性能。"}
{"id": 508, "source": "riscv-dataset-excel", "optimization_type": "SIMD并行化优化", "optimization_description": "优化前：ChaCha20 intrinsic 使用块并行化方法，通过将4个块的相同状态元素加载到向量寄存器中（例如所有4个块的state[0]在一个寄存器中），然后使用循环结构处理。这种方法需要复杂的寄存器数组管理和内存交错加载。\n\n优化后：改为使用四分之一轮并行化方法，基于Goll和Gueron的向量化方案。核心思路是：1）将初始状态加载到4个128位向量寄存器中；2）创建4组4向量副本，每组对应一个块，通过向计数器（state[12]）添加+0/+1/+2/+3来区分；3）在SIMD寄存器中对齐数据，使得每个向量的对应通道包含四分之一轮操作所需的值；4）在每轮之间进行通道旋转操作实现对角线排列。\n\n优化思路：从块级并行改为四分之一轮并行，更好地利用SIMD指令的并行性，减少内存访问和寄存器管理开销，提高ChaCha20加密算法的吞吐量。", "original_code": "ChaCha20 intrinsic 使用块并行化方法，通过将4个块的相同状态元素加载到向量寄存器中（例如所有4个块的state[0]在一个寄存器中），然后使用循环结构处理。这种方法需要复杂的寄存器数组管理和内存交错加载。", "optimized_code": "- address generate_chacha20Block_blockpar() {\n+ address generate_chacha20Block_qrpar() {\n- // ChaCha20 block function.  This version parallelizes by loading\n- // individual 32-bit state elements into vectors for four blocks\n- // (e.g. all four blocks' worth of state[0] in one register, etc.)\n+ // ChaCha20 block function.  This version parallelizes 4 quarter\n+ // round operations at a time.  It uses 16 SIMD registers to\n+ // produce 4 blocks of key stream.\n- __ BIND(L_cc20_const);\n- __ emit_int64(0x0000000100000000UL);\n- __ emit_int64(0x0000000300000002UL);\n+ __ BIND(L_Q_cc20_const);\n+ __ emit_int64(0x0000000000000001UL);\n+ __ emit_int64(0x0000000000000000UL);\n- // Organize SIMD registers in an array that facilitates\n- // putting repetitive opcodes into loop structures.\n- const FloatRegister workSt[16] = {\n-      v4,  v5,  v6,  v7, v16, v17, v18, v19,\n-     v20, v21, v22, v23, v24, v25, v26, v27\n- };\n- // Load from memory and interlace across 16 SIMD registers,\n- // With each word from memory being broadcast to all lanes of\n- // each successive SIMD register.\n- __ mov(tmpAddr, state);\n- for (i = 0; i < 16; i += 4) {\n-   __ ld4r(workSt[i], workSt[i + 1], workSt[i + 2], workSt[i + 3], __ T4S,\n-       __ post(tmpAddr, 16));\n- }\n- // Pull in constant data.  The first 16 bytes are the add overlay\n- // which is applied to the vector holding the counter (state[12]).\n- __ adr(tmpAddr, L_cc20_const);\n- __ ldpq(origCtrState, lrot8Tbl, Address(tmpAddr));\n- __ addv(workSt[12], __ T4S, workSt[12], origCtrState);\n+ // Load the initial state in the first 4 quadword registers,\n+ // then copy the initial state into the next 4 quadword registers\n+ // that will be used for the working state.\n+ __ ld1(aState, bState, cState, dState, __ T16B, Address(state));\n+ // Load the index register for 2 constant 128-bit data fields.\n+ // The first represents the +1/+0/+0/+0 add mask.  The second is\n+ // the 8-bit left rotation.\n+ __ adr(tmpAddr, L_Q_cc20_const);\n+ __ ldpq(addMask, lrot8Tbl, Address(tmpAddr));\n+ __ mov(a1Vec, __ T16B, aState);\n+ __ mov(b1Vec, __ T16B, bState);\n+ __ mov(c1Vec, __ T16B, cState);\n+ __ mov(d1Vec, __ T16B, dState);\n+ __ mov(a2Vec, __ T16B, aState);\n+ __ mov(b2Vec, __ T16B, bState);\n+ __ mov(c2Vec, __ T16B, cState);\n+ __ addv(d2Vec, __ T4S, d1Vec, addMask);\n+ __ mov(a3Vec, __ T16B, aState);\n+ __ mov(b3Vec, __ T16B, bState);\n+ __ mov(c3Vec, __ T16B, cState);\n+ __ addv(d3Vec, __ T4S, d2Vec, addMask);\n+ __ mov(a4Vec, __ T16B, aState);\n+ __ mov(b4Vec, __ T16B, bState);\n+ __ mov(c4Vec, __ T16B, cState);\n+ __ addv(d4Vec, __ T4S, d3Vec, addMask);", "source_url": "https://github.com/openjdk/riscv-port/commit/ee4caa4180e76911ee75148583c2923f847f8605", "code_v0_no_empty_lines": "ChaCha20 intrinsic 使用块并行化方法，通过将4个块的相同状态元素加载到向量寄存器中（例如所有4个块的state[0]在一个寄存器中），然后使用循环结构处理。这种方法需要复杂的寄存器数组管理和内存交错加载。", "code_v1_no_empty_lines": "- address generate_chacha20Block_blockpar() {\n+ address generate_chacha20Block_qrpar() {\n- // ChaCha20 block function.  This version parallelizes by loading\n- // individual 32-bit state elements into vectors for four blocks\n- // (e.g. all four blocks' worth of state[0] in one register, etc.)\n+ // ChaCha20 block function.  This version parallelizes 4 quarter\n+ // round operations at a time.  It uses 16 SIMD registers to\n+ // produce 4 blocks of key stream.\n- __ BIND(L_cc20_const);\n- __ emit_int64(0x0000000100000000UL);\n- __ emit_int64(0x0000000300000002UL);\n+ __ BIND(L_Q_cc20_const);\n+ __ emit_int64(0x0000000000000001UL);\n+ __ emit_int64(0x0000000000000000UL);\n- // Organize SIMD registers in an array that facilitates\n- // putting repetitive opcodes into loop structures.\n- const FloatRegister workSt[16] = {\n-      v4,  v5,  v6,  v7, v16, v17, v18, v19,\n-     v20, v21, v22, v23, v24, v25, v26, v27\n- };\n- // Load from memory and interlace across 16 SIMD registers,\n- // With each word from memory being broadcast to all lanes of\n- // each successive SIMD register.\n- __ mov(tmpAddr, state);\n- for (i = 0; i < 16; i += 4) {\n-   __ ld4r(workSt[i], workSt[i + 1], workSt[i + 2], workSt[i + 3], __ T4S,\n-       __ post(tmpAddr, 16));\n- }\n- // Pull in constant data.  The first 16 bytes are the add overlay\n- // which is applied to the vector holding the counter (state[12]).\n- __ adr(tmpAddr, L_cc20_const);\n- __ ldpq(origCtrState, lrot8Tbl, Address(tmpAddr));\n- __ addv(workSt[12], __ T4S, workSt[12], origCtrState);\n+ // Load the initial state in the first 4 quadword registers,\n+ // then copy the initial state into the next 4 quadword registers\n+ // that will be used for the working state.\n+ __ ld1(aState, bState, cState, dState, __ T16B, Address(state));\n+ // Load the index register for 2 constant 128-bit data fields.\n+ // The first represents the +1/+0/+0/+0 add mask.  The second is\n+ // the 8-bit left rotation.\n+ __ adr(tmpAddr, L_Q_cc20_const);\n+ __ ldpq(addMask, lrot8Tbl, Address(tmpAddr));\n+ __ mov(a1Vec, __ T16B, aState);\n+ __ mov(b1Vec, __ T16B, bState);\n+ __ mov(c1Vec, __ T16B, cState);\n+ __ mov(d1Vec, __ T16B, dState);\n+ __ mov(a2Vec, __ T16B, aState);\n+ __ mov(b2Vec, __ T16B, bState);\n+ __ mov(c2Vec, __ T16B, cState);\n+ __ addv(d2Vec, __ T4S, d1Vec, addMask);\n+ __ mov(a3Vec, __ T16B, aState);\n+ __ mov(b3Vec, __ T16B, bState);\n+ __ mov(c3Vec, __ T16B, cState);\n+ __ addv(d3Vec, __ T4S, d2Vec, addMask);\n+ __ mov(a4Vec, __ T16B, aState);\n+ __ mov(b4Vec, __ T16B, bState);\n+ __ mov(c4Vec, __ T16B, cState);\n+ __ addv(d4Vec, __ T4S, d3Vec, addMask);", "target": "- address generate_chacha20Block_blockpar() {\n+ address generate_chacha20Block_qrpar() {\n- // ChaCha20 block function.  This version parallelizes by loading\n- // individual 32-bit state elements into vectors for four blocks\n- // (e.g. all four blocks' worth of state[0] in one register, etc.)\n+ // ChaCha20 block function.  This version parallelizes 4 quarter\n+ // round operations at a time.  It uses 16 SIMD registers to\n+ // produce 4 blocks of key stream.\n- __ BIND(L_cc20_const);\n- __ emit_int64(0x0000000100000000UL);\n- __ emit_int64(0x0000000300000002UL);\n+ __ BIND(L_Q_cc20_const);\n+ __ emit_int64(0x0000000000000001UL);\n+ __ emit_int64(0x0000000000000000UL);\n- // Organize SIMD registers in an array that facilitates\n- // putting repetitive opcodes into loop structures.\n- const FloatRegister workSt[16] = {\n-      v4,  v5,  v6,  v7, v16, v17, v18, v19,\n-     v20, v21, v22, v23, v24, v25, v26, v27\n- };\n- // Load from memory and interlace across 16 SIMD registers,\n- // With each word from memory being broadcast to all lanes of\n- // each successive SIMD register.\n- __ mov(tmpAddr, state);\n- for (i = 0; i < 16; i += 4) {\n-   __ ld4r(workSt[i], workSt[i + 1], workSt[i + 2], workSt[i + 3], __ T4S,\n-       __ post(tmpAddr, 16));\n- }\n- // Pull in constant data.  The first 16 bytes are the add overlay\n- // which is applied to the vector holding the counter (state[12]).\n- __ adr(tmpAddr, L_cc20_const);\n- __ ldpq(origCtrState, lrot8Tbl, Address(tmpAddr));\n- __ addv(workSt[12], __ T4S, workSt[12], origCtrState);\n+ // Load the initial state in the first 4 quadword registers,\n+ // then copy the initial state into the next 4 quadword registers\n+ // that will be used for the working state.\n+ __ ld1(aState, bState, cState, dState, __ T16B, Address(state));\n+ // Load the index register for 2 constant 128-bit data fields.\n+ // The first represents the +1/+0/+0/+0 add mask.  The second is\n+ // the 8-bit left rotation.\n+ __ adr(tmpAddr, L_Q_cc20_const);\n+ __ ldpq(addMask, lrot8Tbl, Address(tmpAddr));\n+ __ mov(a1Vec, __ T16B, aState);\n+ __ mov(b1Vec, __ T16B, bState);\n+ __ mov(c1Vec, __ T16B, cState);\n+ __ mov(d1Vec, __ T16B, dState);\n+ __ mov(a2Vec, __ T16B, aState);\n+ __ mov(b2Vec, __ T16B, bState);\n+ __ mov(c2Vec, __ T16B, cState);\n+ __ addv(d2Vec, __ T4S, d1Vec, addMask);\n+ __ mov(a3Vec, __ T16B, aState);\n+ __ mov(b3Vec, __ T16B, bState);\n+ __ mov(c3Vec, __ T16B, cState);\n+ __ addv(d3Vec, __ T4S, d2Vec, addMask);\n+ __ mov(a4Vec, __ T16B, aState);\n+ __ mov(b4Vec, __ T16B, bState);\n+ __ mov(c4Vec, __ T16B, cState);\n+ __ addv(d4Vec, __ T4S, d3Vec, addMask);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ChaCha20 intrinsic 使用块并行化方法，通过将4个块的相同状态元素加载到向量寄存器中（例如所有4个块的state[0]在一个寄存器中），然后使用循环结构处理。这种方法需要复杂的寄存器数组管理和内存交错加载。\n\n优化后：改为使用四分之一轮并行化方法，基于Goll和Gueron的向量化方案。核心思路是：1）将初始状态加载到4个128位向量寄存器中；2）创建4组4向量副本，每组对应一个块，通过向计数器（state[12]）添加+0/+1/+2/+3来区分；3）在SIMD寄存器中对齐数据，使得每个向量的对应通道包含四分之一轮操作所需的值；4）在每轮之间进行通道旋转操作实现对角线排列。\n\n优化思路：从块级并行改为四分之一轮并行，更好地利用SIMD指令的并行性，减少内存访问和寄存器管理开销，提高ChaCha20加密算法的吞吐量。"}
{"id": 509, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+内存安全优化", "optimization_description": "优化前：PerfDataManager销毁计数器时，使用1ms睡眠等待其他线程完成操作，导致VM关闭时产生1ms延迟。优化后：引入GlobalCounter同步机制，确保计数器访问与销毁的安全同步。思路：用原子操作和全局计数器替代睡眠等待，消除关闭延迟，同时保证并发访问的安全性。", "original_code": "PerfDataManager销毁计数器时，使用1ms睡眠等待其他线程完成操作，导致VM关闭时产生1ms延迟。", "optimized_code": "1. objectMonitor.cpp: OM_PERFDATA_OP(FutileWakeups, inc()) -> OM_PERFDATA_SAFE_OP(FutileWakeups, inc())\n2. objectMonitor.hpp: 新增OM_PERFDATA_SAFE_OP宏，使用GlobalCounter::CriticalSection保护\n3. perfData.cpp: _has_PerfData = false -> Atomic::store(&_has_PerfData, false); os::naked_short_sleep(1) -> GlobalCounter::write_synchronize()", "source_url": "https://github.com/openjdk/riscv-port/commit/305bbdae7fe40e33cf2baa100c134bd85ecaa553", "code_v0_no_empty_lines": "PerfDataManager销毁计数器时，使用1ms睡眠等待其他线程完成操作，导致VM关闭时产生1ms延迟。", "code_v1_no_empty_lines": "1. objectMonitor.cpp: OM_PERFDATA_OP(FutileWakeups, inc()) -> OM_PERFDATA_SAFE_OP(FutileWakeups, inc())\n2. objectMonitor.hpp: 新增OM_PERFDATA_SAFE_OP宏，使用GlobalCounter::CriticalSection保护\n3. perfData.cpp: _has_PerfData = false -> Atomic::store(&_has_PerfData, false); os::naked_short_sleep(1) -> GlobalCounter::write_synchronize()", "target": "1. objectMonitor.cpp: OM_PERFDATA_OP(FutileWakeups, inc()) -> OM_PERFDATA_SAFE_OP(FutileWakeups, inc())\n2. objectMonitor.hpp: 新增OM_PERFDATA_SAFE_OP宏，使用GlobalCounter::CriticalSection保护\n3. perfData.cpp: _has_PerfData = false -> Atomic::store(&_has_PerfData, false); os::naked_short_sleep(1) -> GlobalCounter::write_synchronize()", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PerfDataManager销毁计数器时，使用1ms睡眠等待其他线程完成操作，导致VM关闭时产生1ms延迟。优化后：引入GlobalCounter同步机制，确保计数器访问与销毁的安全同步。思路：用原子操作和全局计数器替代睡眠等待，消除关闭延迟，同时保证并发访问的安全性。"}
{"id": 510, "source": "riscv-dataset-excel", "optimization_type": "内联优化", "optimization_description": "优化前：MemorySegment::reinterpret方法没有强制内联，可能导致方法调用开销。优化后：为三个reinterpret方法添加@ForceInline注解，强制编译器内联这些方法。思路：通过强制内联消除方法调用开销，提高内存段重新解释操作的性能，特别是在频繁调用场景下。", "original_code": "MemorySegment::reinterpret方法没有强制内联，可能导致方法调用开销。", "optimized_code": "@Override\n@CallerSensitive\n+@ForceInline\npublic final MemorySegment reinterpret(long newSize, Arena arena, Consumer<MemorySegment> cleanup) {\n@Override\n@CallerSensitive\n+@ForceInline\npublic final MemorySegment reinterpret(long newSize) {\n@Override\n@CallerSensitive\n+@ForceInline\npublic final MemorySegment reinterpret(Arena arena, Consumer<MemorySegment> cleanup) {", "source_url": "https://github.com/openjdk/riscv-port/commit/137ad5d03c598d5e2888d08e6fbc638936650f30", "code_v0_no_empty_lines": "MemorySegment::reinterpret方法没有强制内联，可能导致方法调用开销。", "code_v1_no_empty_lines": "@Override\n@CallerSensitive\n+@ForceInline\npublic final MemorySegment reinterpret(long newSize, Arena arena, Consumer<MemorySegment> cleanup) {\n@Override\n@CallerSensitive\n+@ForceInline\npublic final MemorySegment reinterpret(long newSize) {\n@Override\n@CallerSensitive\n+@ForceInline\npublic final MemorySegment reinterpret(Arena arena, Consumer<MemorySegment> cleanup) {", "target": "@Override\n@CallerSensitive\n+@ForceInline\npublic final MemorySegment reinterpret(long newSize, Arena arena, Consumer<MemorySegment> cleanup) {\n@Override\n@CallerSensitive\n+@ForceInline\npublic final MemorySegment reinterpret(long newSize) {\n@Override\n@CallerSensitive\n+@ForceInline\npublic final MemorySegment reinterpret(Arena arena, Consumer<MemorySegment> cleanup) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：MemorySegment::reinterpret方法没有强制内联，可能导致方法调用开销。优化后：为三个reinterpret方法添加@ForceInline注解，强制编译器内联这些方法。思路：通过强制内联消除方法调用开销，提高内存段重新解释操作的性能，特别是在频繁调用场景下。"}
{"id": 511, "source": "riscv-dataset-excel", "optimization_type": "内存优化+并发性能优化", "optimization_description": "优化前使用ConcurrentHashMap缓存ZoneOffset对象，存在哈希计算、锁竞争等开销。优化后使用AtomicReferenceArray固定大小数组，通过计算quarter索引直接访问，消除了哈希计算和锁竞争。优化思路：利用ZoneOffset的有效范围（-18:00到+18:00）和15分钟间隔特性，将256个可能的quarter值映射到数组索引，使用原子操作保证线程安全，显著提升并发访问性能并减少内存开销。", "original_code": "// No original code extracted from description\n", "optimized_code": "- private static final ConcurrentMap<Integer, ZoneOffset> SECONDS_CACHE = new ConcurrentHashMap<>(16, 0.75f, 4);\n+ private static final int SECONDS_PER_QUARTER = 15 * SECONDS_PER_MINUTE;\n+ private static final AtomicReferenceArray<ZoneOffset> QUARTER_CACHE = new AtomicReferenceArray<>(256);\n- Integer totalSecs = totalSeconds;\n- ZoneOffset result = SECONDS_CACHE.get(totalSecs);\n+ int quarters = totalSeconds / SECONDS_PER_QUARTER;\n+ int key = quarters & 0xff;\n+ ZoneOffset result = QUARTER_CACHE.getOpaque(key);\n- var existing = SECONDS_CACHE.putIfAbsent(totalSecs, result);\n+ var existing = QUARTER_CACHE.compareAndExchange(key, null, result);", "source_url": "https://github.com/openjdk/riscv-port/commit/3f8a875497c0e8356f9104e32aa801b879c7b941", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- private static final ConcurrentMap<Integer, ZoneOffset> SECONDS_CACHE = new ConcurrentHashMap<>(16, 0.75f, 4);\n+ private static final int SECONDS_PER_QUARTER = 15 * SECONDS_PER_MINUTE;\n+ private static final AtomicReferenceArray<ZoneOffset> QUARTER_CACHE = new AtomicReferenceArray<>(256);\n- Integer totalSecs = totalSeconds;\n- ZoneOffset result = SECONDS_CACHE.get(totalSecs);\n+ int quarters = totalSeconds / SECONDS_PER_QUARTER;\n+ int key = quarters & 0xff;\n+ ZoneOffset result = QUARTER_CACHE.getOpaque(key);\n- var existing = SECONDS_CACHE.putIfAbsent(totalSecs, result);\n+ var existing = QUARTER_CACHE.compareAndExchange(key, null, result);", "target": "- private static final ConcurrentMap<Integer, ZoneOffset> SECONDS_CACHE = new ConcurrentHashMap<>(16, 0.75f, 4);\n+ private static final int SECONDS_PER_QUARTER = 15 * SECONDS_PER_MINUTE;\n+ private static final AtomicReferenceArray<ZoneOffset> QUARTER_CACHE = new AtomicReferenceArray<>(256);\n- Integer totalSecs = totalSeconds;\n- ZoneOffset result = SECONDS_CACHE.get(totalSecs);\n+ int quarters = totalSeconds / SECONDS_PER_QUARTER;\n+ int key = quarters & 0xff;\n+ ZoneOffset result = QUARTER_CACHE.getOpaque(key);\n- var existing = SECONDS_CACHE.putIfAbsent(totalSecs, result);\n+ var existing = QUARTER_CACHE.compareAndExchange(key, null, result);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用ConcurrentHashMap缓存ZoneOffset对象，存在哈希计算、锁竞争等开销。优化后使用AtomicReferenceArray固定大小数组，通过计算quarter索引直接访问，消除了哈希计算和锁竞争。优化思路：利用ZoneOffset的有效范围（-18:00到+18:00）和15分钟间隔特性，将256个可能的quarter值映射到数组索引，使用原子操作保证线程安全，显著提升并发访问性能并减少内存开销。"}
{"id": 512, "source": "riscv-dataset-excel", "optimization_type": "编译器标志优化", "optimization_description": "优化前：当用户指定-XX:AOTMode时，需要手动启用-XX:+AOTClassLinking才能获得AOT类链接优化。优化后：自动检测AOTMode标志设置，默认启用AOTClassLinking，简化用户配置。优化思路：通过自动关联相关优化标志，减少用户配置复杂度，确保AOT模式能充分利用性能优化特性。", "original_code": "当用户指定-XX:AOTMode时，需要手动启用-XX:+AOTClassLinking才能获得AOT类链接优化。", "optimized_code": "if (!FLAG_IS_DEFAULT(AOTMode)) {\n    // Using any form of the new AOTMode switch enables enhanced optimizations.\n    FLAG_SET_ERGO_IF_DEFAULT(AOTClassLinking, true);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/d266ca965d214f54c1ab16c1863f87728542b3e0", "code_v0_no_empty_lines": "当用户指定-XX:AOTMode时，需要手动启用-XX:+AOTClassLinking才能获得AOT类链接优化。", "code_v1_no_empty_lines": "if (!FLAG_IS_DEFAULT(AOTMode)) {\n    // Using any form of the new AOTMode switch enables enhanced optimizations.\n    FLAG_SET_ERGO_IF_DEFAULT(AOTClassLinking, true);\n}", "target": "if (!FLAG_IS_DEFAULT(AOTMode)) {\n    // Using any form of the new AOTMode switch enables enhanced optimizations.\n    FLAG_SET_ERGO_IF_DEFAULT(AOTClassLinking, true);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当用户指定-XX:AOTMode时，需要手动启用-XX:+AOTClassLinking才能获得AOT类链接优化。优化后：自动检测AOTMode标志设置，默认启用AOTClassLinking，简化用户配置。优化思路：通过自动关联相关优化标志，减少用户配置复杂度，确保AOT模式能充分利用性能优化特性。"}
{"id": 513, "source": "riscv-dataset-excel", "optimization_type": "构建系统优化", "optimization_description": "优化前：构建系统通过变量LIBFONTMANAGER_OPTIMIZATION来设置LIBFONTMANAGER的优化级别，该变量在多个条件分支中被重复设置为HIGHEST，增加了维护复杂性和潜在错误。优化后：直接在所有构建配置中将OPTIMIZATION设置为HIGHEST，移除了冗余的变量定义和赋值。优化思路：简化构建配置逻辑，消除重复代码，提高构建系统的可维护性和一致性。", "original_code": "构建系统通过变量LIBFONTMANAGER_OPTIMIZATION来设置LIBFONTMANAGER的优化级别，该变量在多个条件分支中被重复设置为HIGHEST，增加了维护复杂性和潜在错误。", "optimized_code": "-LIBFONTMANAGER_OPTIMIZATION := HIGHEST\n-  LIBFONTMANAGER_OPTIMIZATION := HIGHEST\n-    OPTIMIZATION := $(LIBFONTMANAGER_OPTIMIZATION), \n+    OPTIMIZATION := HIGHEST,", "source_url": "https://github.com/openjdk/riscv-port/commit/168a471fd0b6cc7c6a9e2ada19edbc489d62849c", "code_v0_no_empty_lines": "构建系统通过变量LIBFONTMANAGER_OPTIMIZATION来设置LIBFONTMANAGER的优化级别，该变量在多个条件分支中被重复设置为HIGHEST，增加了维护复杂性和潜在错误。", "code_v1_no_empty_lines": "-LIBFONTMANAGER_OPTIMIZATION := HIGHEST\n-  LIBFONTMANAGER_OPTIMIZATION := HIGHEST\n-    OPTIMIZATION := $(LIBFONTMANAGER_OPTIMIZATION), \n+    OPTIMIZATION := HIGHEST,", "target": "-LIBFONTMANAGER_OPTIMIZATION := HIGHEST\n-  LIBFONTMANAGER_OPTIMIZATION := HIGHEST\n-    OPTIMIZATION := $(LIBFONTMANAGER_OPTIMIZATION), \n+    OPTIMIZATION := HIGHEST,", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：构建系统通过变量LIBFONTMANAGER_OPTIMIZATION来设置LIBFONTMANAGER的优化级别，该变量在多个条件分支中被重复设置为HIGHEST，增加了维护复杂性和潜在错误。优化后：直接在所有构建配置中将OPTIMIZATION设置为HIGHEST，移除了冗余的变量定义和赋值。优化思路：简化构建配置逻辑，消除重复代码，提高构建系统的可维护性和一致性。"}
{"id": 514, "source": "riscv-dataset-excel", "optimization_type": "内存分配优化+性能优化", "optimization_description": "优化前：downcalls（向下调用）的内存分配可能频繁创建和销毁内存段，导致性能开销。优化后：引入BufferStack类，为每个线程维护一个可重用的内存栈，通过pushFrame/close机制实现栈式内存分配，减少内存分配次数和垃圾回收压力。优化思路：1) 使用线程本地存储（ThreadLocal）为每个线程分配独立的内存栈；2) 通过SlicingAllocator实现高效的内存切片分配；3) 添加虚拟线程并发控制（ReentrantLock），确保线程安全；4) 支持内存重用，通过resetTo方法重置栈指针，避免重复分配。", "original_code": "downcalls（向下调用）的内存分配可能频繁创建和销毁内存段，导致性能开销。", "optimized_code": "new file mode 100644\n+++ b/src/java.base/share/classes/jdk/internal/foreign/abi/BufferStack.java\n@@ -0,0 +1,122 @@\n+public class BufferStack {\n+    private final long size;\n+\n+    public BufferStack(long size) {\n+        this.size = size;\n+    }\n+\n+    private final ThreadLocal<PerThread> tl = new CarrierThreadLocal<>() {\n+        @Override\n+        protected PerThread initialValue() {\n+            return new PerThread(size);\n+        }\n+    };\n+\n+    @ForceInline\n+    public Arena pushFrame(long size, long byteAlignment) {\n+        return tl.get().pushFrame(size, byteAlignment);\n+    }\n+\n+    private static final class PerThread {\n+        private final ReentrantLock lock = new ReentrantLock();\n+        private final SlicingAllocator stack;\n+\n+        public PerThread(long size) {\n+            this.stack = new SlicingAllocator(Arena.ofAuto().allocate(size));\n+        }\n+\n+        @ForceInline\n+        public Arena pushFrame(long size, long byteAlignment) {\n+            boolean needsLock = Thread.currentThread().isVirtual() && !lock.isHeldByCurrentThread();\n+            if (needsLock && !lock.tryLock()) {\n+                // Rare: another virtual thread on the same carrier competed for acquisition.\n+                return Arena.ofConfined();\n+            }\n+            if (!stack.canAllocate(size, byteAlignment)) {\n+                if (needsLock) lock.unlock();\n+                return Arena.ofConfined();\n+            }\n+\n+            return new Frame(needsLock, size, byteAlignment);\n+        }\n+\n+        private class Frame implements Arena {\n+            private final boolean locked;\n+            private final long parentOffset;\n+            private final long topOfStack;\n+            private final Arena scope = Arena.ofConfined();\n+            private final SegmentAllocator frame;\n+\n+            @SuppressWarnings(\"restricted\")\n+            public Frame(boolean locked, long byteSize, long byteAlignment) {\n+                this.locked = locked;\n+\n+                parentOffset = stack.currentOffset();\n+                MemorySegment frameSegment = stack.allocate(byteSize, byteAlignment);\n+                topOfStack = stack.currentOffset();\n+                frame = new SlicingAllocator(frameSegment.reinterpret(scope, null));\n+            }\n+\n+            private void assertOrder() {\n+                if (topOfStack != stack.currentOffset())\n+                    throw new IllegalStateException(\"Out of order access: frame not top-of-stack\");\n+            }\n+\n+            @Override\n+            @SuppressWarnings(\"restricted\")\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return frame.allocate(byteSize, byteAlignment);\n+            }\n+\n+            @Override\n+            public MemorySegment.Scope scope() {\n+                return scope.scope();\n+            }\n+\n+            @Override\n+            public void close() {\n+                assertOrder();\n+                scope.close();\n+                stack.resetTo(parentOffset);\n+                if (locked) {\n+                    lock.unlock();\n+                }\n+            }\n+        }\n+    }\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/8cc13045428eebb8933df865f9a87f0f91909ba5", "code_v0_no_empty_lines": "downcalls（向下调用）的内存分配可能频繁创建和销毁内存段，导致性能开销。", "code_v1_no_empty_lines": "new file mode 100644\n+++ b/src/java.base/share/classes/jdk/internal/foreign/abi/BufferStack.java\n@@ -0,0 +1,122 @@\n+public class BufferStack {\n+    private final long size;\n+\n+    public BufferStack(long size) {\n+        this.size = size;\n+    }\n+\n+    private final ThreadLocal<PerThread> tl = new CarrierThreadLocal<>() {\n+        @Override\n+        protected PerThread initialValue() {\n+            return new PerThread(size);\n+        }\n+    };\n+\n+    @ForceInline\n+    public Arena pushFrame(long size, long byteAlignment) {\n+        return tl.get().pushFrame(size, byteAlignment);\n+    }\n+\n+    private static final class PerThread {\n+        private final ReentrantLock lock = new ReentrantLock();\n+        private final SlicingAllocator stack;\n+\n+        public PerThread(long size) {\n+            this.stack = new SlicingAllocator(Arena.ofAuto().allocate(size));\n+        }\n+\n+        @ForceInline\n+        public Arena pushFrame(long size, long byteAlignment) {\n+            boolean needsLock = Thread.currentThread().isVirtual() && !lock.isHeldByCurrentThread();\n+            if (needsLock && !lock.tryLock()) {\n+                // Rare: another virtual thread on the same carrier competed for acquisition.\n+                return Arena.ofConfined();\n+            }\n+            if (!stack.canAllocate(size, byteAlignment)) {\n+                if (needsLock) lock.unlock();\n+                return Arena.ofConfined();\n+            }\n+\n+            return new Frame(needsLock, size, byteAlignment);\n+        }\n+\n+        private class Frame implements Arena {\n+            private final boolean locked;\n+            private final long parentOffset;\n+            private final long topOfStack;\n+            private final Arena scope = Arena.ofConfined();\n+            private final SegmentAllocator frame;\n+\n+            @SuppressWarnings(\"restricted\")\n+            public Frame(boolean locked, long byteSize, long byteAlignment) {\n+                this.locked = locked;\n+\n+                parentOffset = stack.currentOffset();\n+                MemorySegment frameSegment = stack.allocate(byteSize, byteAlignment);\n+                topOfStack = stack.currentOffset();\n+                frame = new SlicingAllocator(frameSegment.reinterpret(scope, null));\n+            }\n+\n+            private void assertOrder() {\n+                if (topOfStack != stack.currentOffset())\n+                    throw new IllegalStateException(\"Out of order access: frame not top-of-stack\");\n+            }\n+\n+            @Override\n+            @SuppressWarnings(\"restricted\")\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return frame.allocate(byteSize, byteAlignment);\n+            }\n+\n+            @Override\n+            public MemorySegment.Scope scope() {\n+                return scope.scope();\n+            }\n+\n+            @Override\n+            public void close() {\n+                assertOrder();\n+                scope.close();\n+                stack.resetTo(parentOffset);\n+                if (locked) {\n+                    lock.unlock();\n+                }\n+            }\n+        }\n+    }\n+}", "target": "new file mode 100644\n+++ b/src/java.base/share/classes/jdk/internal/foreign/abi/BufferStack.java\n@@ -0,0 +1,122 @@\n+public class BufferStack {\n+    private final long size;\n+\n+    public BufferStack(long size) {\n+        this.size = size;\n+    }\n+\n+    private final ThreadLocal<PerThread> tl = new CarrierThreadLocal<>() {\n+        @Override\n+        protected PerThread initialValue() {\n+            return new PerThread(size);\n+        }\n+    };\n+\n+    @ForceInline\n+    public Arena pushFrame(long size, long byteAlignment) {\n+        return tl.get().pushFrame(size, byteAlignment);\n+    }\n+\n+    private static final class PerThread {\n+        private final ReentrantLock lock = new ReentrantLock();\n+        private final SlicingAllocator stack;\n+\n+        public PerThread(long size) {\n+            this.stack = new SlicingAllocator(Arena.ofAuto().allocate(size));\n+        }\n+\n+        @ForceInline\n+        public Arena pushFrame(long size, long byteAlignment) {\n+            boolean needsLock = Thread.currentThread().isVirtual() && !lock.isHeldByCurrentThread();\n+            if (needsLock && !lock.tryLock()) {\n+                // Rare: another virtual thread on the same carrier competed for acquisition.\n+                return Arena.ofConfined();\n+            }\n+            if (!stack.canAllocate(size, byteAlignment)) {\n+                if (needsLock) lock.unlock();\n+                return Arena.ofConfined();\n+            }\n+\n+            return new Frame(needsLock, size, byteAlignment);\n+        }\n+\n+        private class Frame implements Arena {\n+            private final boolean locked;\n+            private final long parentOffset;\n+            private final long topOfStack;\n+            private final Arena scope = Arena.ofConfined();\n+            private final SegmentAllocator frame;\n+\n+            @SuppressWarnings(\"restricted\")\n+            public Frame(boolean locked, long byteSize, long byteAlignment) {\n+                this.locked = locked;\n+\n+                parentOffset = stack.currentOffset();\n+                MemorySegment frameSegment = stack.allocate(byteSize, byteAlignment);\n+                topOfStack = stack.currentOffset();\n+                frame = new SlicingAllocator(frameSegment.reinterpret(scope, null));\n+            }\n+\n+            private void assertOrder() {\n+                if (topOfStack != stack.currentOffset())\n+                    throw new IllegalStateException(\"Out of order access: frame not top-of-stack\");\n+            }\n+\n+            @Override\n+            @SuppressWarnings(\"restricted\")\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return frame.allocate(byteSize, byteAlignment);\n+            }\n+\n+            @Override\n+            public MemorySegment.Scope scope() {\n+                return scope.scope();\n+            }\n+\n+            @Override\n+            public void close() {\n+                assertOrder();\n+                scope.close();\n+                stack.resetTo(parentOffset);\n+                if (locked) {\n+                    lock.unlock();\n+                }\n+            }\n+        }\n+    }\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：downcalls（向下调用）的内存分配可能频繁创建和销毁内存段，导致性能开销。优化后：引入BufferStack类，为每个线程维护一个可重用的内存栈，通过pushFrame/close机制实现栈式内存分配，减少内存分配次数和垃圾回收压力。优化思路：1) 使用线程本地存储（ThreadLocal）为每个线程分配独立的内存栈；2) 通过SlicingAllocator实现高效的内存切片分配；3) 添加虚拟线程并发控制（ReentrantLock），确保线程安全；4) 支持内存重用，通过resetTo方法重置栈指针，避免重复分配。"}
{"id": 515, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化", "optimization_description": "优化前：三个静态方法（getTimeZone、getAvailableIDs(int)、getAvailableIDs()）都标记为synchronized，导致不必要的同步开销。优化后：移除了这些方法的synchronized关键字，因为这些方法内部调用的底层实现（getTimeZone(ID, true)和ZoneInfo.getAvailableIDs()）已经是线程安全的，或者不需要同步。优化思路：消除不必要的同步锁，减少多线程环境下的竞争和阻塞，提高并发性能。", "original_code": "三个静态方法（getTimeZone、getAvailableIDs(int)、getAvailableIDs()）都标记为synchronized，导致不必要的同步开销。", "optimized_code": "-    public static synchronized TimeZone getTimeZone(String ID) {\n+    public static TimeZone getTimeZone(String ID) {\n-    public static synchronized String[] getAvailableIDs(int rawOffset) {\n+    public static String[] getAvailableIDs(int rawOffset) {\n-    public static synchronized String[] getAvailableIDs() {\n+    public static String[] getAvailableIDs() {", "source_url": "https://github.com/openjdk/riscv-port/commit/bef5f56544ded9307e5f1095bd42ae46fdc2adda", "code_v0_no_empty_lines": "三个静态方法（getTimeZone、getAvailableIDs(int)、getAvailableIDs()）都标记为synchronized，导致不必要的同步开销。", "code_v1_no_empty_lines": "-    public static synchronized TimeZone getTimeZone(String ID) {\n+    public static TimeZone getTimeZone(String ID) {\n-    public static synchronized String[] getAvailableIDs(int rawOffset) {\n+    public static String[] getAvailableIDs(int rawOffset) {\n-    public static synchronized String[] getAvailableIDs() {\n+    public static String[] getAvailableIDs() {", "target": "-    public static synchronized TimeZone getTimeZone(String ID) {\n+    public static TimeZone getTimeZone(String ID) {\n-    public static synchronized String[] getAvailableIDs(int rawOffset) {\n+    public static String[] getAvailableIDs(int rawOffset) {\n-    public static synchronized String[] getAvailableIDs() {\n+    public static String[] getAvailableIDs() {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：三个静态方法（getTimeZone、getAvailableIDs(int)、getAvailableIDs()）都标记为synchronized，导致不必要的同步开销。优化后：移除了这些方法的synchronized关键字，因为这些方法内部调用的底层实现（getTimeZone(ID, true)和ZoneInfo.getAvailableIDs()）已经是线程安全的，或者不需要同步。优化思路：消除不必要的同步锁，减少多线程环境下的竞争和阻塞，提高并发性能。"}
{"id": 516, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化+内存优化", "optimization_description": "优化前：使用Hashtable存储静态映射，通过多次put()调用初始化，存在同步开销和内存分配开销。优化后：改为使用不可变的Map.ofEntries()创建静态映射，声明为final Map接口类型，一次性初始化。优化思路：消除Hashtable的同步开销，利用不可变集合的优化特性，减少内存分配和初始化代码量，提高性能和代码简洁性。", "original_code": "使用Hashtable存储静态映射，通过多次put()调用初始化，存在同步开销和内存分配开销。", "optimized_code": "-    private static final Hashtable<Object, Attribute> styleConstantToCssMap = new Hashtable<Object, Attribute>(17);\n+    private static final Map<Object, Attribute> styleConstantToCssMap;\n-        styleConstantToCssMap.put(StyleConstants.FontFamily,\n-                                  CSS.Attribute.FONT_FAMILY);\n+        styleConstantToCssMap = Map.ofEntries(\n+                Map.entry(StyleConstants.FontFamily,\n+                          CSS.Attribute.FONT_FAMILY),", "source_url": "https://github.com/openjdk/riscv-port/commit/56a187798991cb6dede62ac166cbdca7a654cf7f", "code_v0_no_empty_lines": "使用Hashtable存储静态映射，通过多次put()调用初始化，存在同步开销和内存分配开销。", "code_v1_no_empty_lines": "-    private static final Hashtable<Object, Attribute> styleConstantToCssMap = new Hashtable<Object, Attribute>(17);\n+    private static final Map<Object, Attribute> styleConstantToCssMap;\n-        styleConstantToCssMap.put(StyleConstants.FontFamily,\n-                                  CSS.Attribute.FONT_FAMILY);\n+        styleConstantToCssMap = Map.ofEntries(\n+                Map.entry(StyleConstants.FontFamily,\n+                          CSS.Attribute.FONT_FAMILY),", "target": "-    private static final Hashtable<Object, Attribute> styleConstantToCssMap = new Hashtable<Object, Attribute>(17);\n+    private static final Map<Object, Attribute> styleConstantToCssMap;\n-        styleConstantToCssMap.put(StyleConstants.FontFamily,\n-                                  CSS.Attribute.FONT_FAMILY);\n+        styleConstantToCssMap = Map.ofEntries(\n+                Map.entry(StyleConstants.FontFamily,\n+                          CSS.Attribute.FONT_FAMILY),", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用Hashtable存储静态映射，通过多次put()调用初始化，存在同步开销和内存分配开销。优化后：改为使用不可变的Map.ofEntries()创建静态映射，声明为final Map接口类型，一次性初始化。优化思路：消除Hashtable的同步开销，利用不可变集合的优化特性，减少内存分配和初始化代码量，提高性能和代码简洁性。"}
{"id": 517, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化", "optimization_description": "优化前：在type_profile_helper函数中，每次访问profile数据槽位时都重复计算地址（使用lea指令加载地址到寄存器），导致生成冗余的地址计算指令。优化后：引入slot_at lambda函数封装地址计算逻辑，通过复用form_address调用减少指令数量，消除重复的地址计算。优化思路：通过代码重构减少冗余指令生成，提高AArch64平台上类型profile计数器的代码质量，解决Bug 8346890中提到的suboptimal code问题。", "original_code": "在type_profile_helper函数中，每次访问profile数据槽位时都重复计算地址（使用lea指令加载地址到寄存器），导致生成冗余的地址计算指令。", "optimized_code": "auto slot_at = [=](ByteSize offset) -> Address {\n    return __ form_address(rscratch2, mdo,\n                           md->byte_offset_of_slot(data, offset),\n                           LogBytesPerWord);\n  };\n\n  for (uint i = 0; i < ReceiverTypeData::row_limit(); i++) {\n    Label next_test;\n    __ ldr(rscratch1, slot_at(ReceiverTypeData::receiver_offset(i)));\n    __ cmp(recv, rscratch1);\n    __ br(Assembler::NE, next_test);\n    __ addptr(slot_at(ReceiverTypeData::receiver_count_offset(i)),\n              DataLayout::counter_increment);\n    __ b(*update_done);\n    __ bind(next_test);\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/5a0bdd04e0d62bbdd01373510cb1d06c586e69b3", "code_v0_no_empty_lines": "在type_profile_helper函数中，每次访问profile数据槽位时都重复计算地址（使用lea指令加载地址到寄存器），导致生成冗余的地址计算指令。", "code_v1_no_empty_lines": "auto slot_at = [=](ByteSize offset) -> Address {\n    return __ form_address(rscratch2, mdo,\n                           md->byte_offset_of_slot(data, offset),\n                           LogBytesPerWord);\n  };\n\n  for (uint i = 0; i < ReceiverTypeData::row_limit(); i++) {\n    Label next_test;\n    __ ldr(rscratch1, slot_at(ReceiverTypeData::receiver_offset(i)));\n    __ cmp(recv, rscratch1);\n    __ br(Assembler::NE, next_test);\n    __ addptr(slot_at(ReceiverTypeData::receiver_count_offset(i)),\n              DataLayout::counter_increment);\n    __ b(*update_done);\n    __ bind(next_test);\n  }", "target": "auto slot_at = [=](ByteSize offset) -> Address {\n    return __ form_address(rscratch2, mdo,\n                           md->byte_offset_of_slot(data, offset),\n                           LogBytesPerWord);\n  };\n\n  for (uint i = 0; i < ReceiverTypeData::row_limit(); i++) {\n    Label next_test;\n    __ ldr(rscratch1, slot_at(ReceiverTypeData::receiver_offset(i)));\n    __ cmp(recv, rscratch1);\n    __ br(Assembler::NE, next_test);\n    __ addptr(slot_at(ReceiverTypeData::receiver_count_offset(i)),\n              DataLayout::counter_increment);\n    __ b(*update_done);\n    __ bind(next_test);\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在type_profile_helper函数中，每次访问profile数据槽位时都重复计算地址（使用lea指令加载地址到寄存器），导致生成冗余的地址计算指令。优化后：引入slot_at lambda函数封装地址计算逻辑，通过复用form_address调用减少指令数量，消除重复的地址计算。优化思路：通过代码重构减少冗余指令生成，提高AArch64平台上类型profile计数器的代码质量，解决Bug 8346890中提到的suboptimal code问题。"}
{"id": 518, "source": "riscv-dataset-excel", "optimization_type": "缓存优化+指令集优化", "optimization_description": "优化前：secondary_super_cache 在 PPC64 架构上扩展性差，C1 编译器和解释器在类型检查时使用线性搜索，性能不佳。优化后：1) 新增 RLWNM、RLDCL、RLDCR 等 PPC 旋转指令支持，提升位操作效率；2) 重构 check_klass_subtype_slow_path 函数，减少寄存器使用（如将 temp2_reg 设为 noreg），优化缓存命中路径；3) 改进条件码设置逻辑，移除冗余的 crandc 指令。思路：通过指令集优化和缓存访问模式改进，提升多线程环境下类型检查的并发性能。", "original_code": "secondary_super_cache 在 PPC64 架构上扩展性差，C1 编译器和解释器在类型检查时使用线性搜索，性能不佳。", "optimized_code": "- __ check_klass_subtype_slow_path(sub_klass, super_klass, temp1_reg, temp2_reg);\n+ __ check_klass_subtype_slow_path(sub_klass, super_klass, temp1_reg, noreg);", "source_url": "https://github.com/openjdk/riscv-port/commit/4a375e5b8899aa684b8a921e198203e76794f709", "code_v0_no_empty_lines": "secondary_super_cache 在 PPC64 架构上扩展性差，C1 编译器和解释器在类型检查时使用线性搜索，性能不佳。", "code_v1_no_empty_lines": "- __ check_klass_subtype_slow_path(sub_klass, super_klass, temp1_reg, temp2_reg);\n+ __ check_klass_subtype_slow_path(sub_klass, super_klass, temp1_reg, noreg);", "target": "- __ check_klass_subtype_slow_path(sub_klass, super_klass, temp1_reg, temp2_reg);\n+ __ check_klass_subtype_slow_path(sub_klass, super_klass, temp1_reg, noreg);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：secondary_super_cache 在 PPC64 架构上扩展性差，C1 编译器和解释器在类型检查时使用线性搜索，性能不佳。优化后：1) 新增 RLWNM、RLDCL、RLDCR 等 PPC 旋转指令支持，提升位操作效率；2) 重构 check_klass_subtype_slow_path 函数，减少寄存器使用（如将 temp2_reg 设为 noreg），优化缓存命中路径；3) 改进条件码设置逻辑，移除冗余的 crandc 指令。思路：通过指令集优化和缓存访问模式改进，提升多线程环境下类型检查的并发性能。"}
{"id": 519, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化", "optimization_description": "优化前：对于\"vr\"和\"vd\"内联汇编约束，当处理mask类型时，使用VR和VRNoV0寄存器类（其第一个类型为nxv8i8），导致生成额外的insert/extract_subvector和bitcast转换指令，并且对nxv16i4类型参数产生错误的扩展代码。优化后：将VM和VMNoV0寄存器类（其第一个类型为nxv64i1）放在检查列表的最前面，使得mask类型优先使用这些寄存器类，从而减少不必要的bitcast转换，只生成insert/extract_subvector指令，同时为后续修复nxv16i4参数问题提供基础。优化思路：通过调整寄存器类检查顺序，让mask类型匹配更合适的寄存器类，减少类型转换开销并修复代码生成错误。", "original_code": "对于\"vr\"和\"vd\"内联汇编约束，当处理mask类型时，使用VR和VRNoV0寄存器类（其第一个类型为nxv8i8），导致生成额外的insert/extract_subvector和bitcast转换指令，并且对nxv16i4类型参数产生错误的扩展代码。", "optimized_code": "for (const auto *RC :\n         {&RISCV::VMRegClass, &RISCV::VRRegClass, &RISCV::VRM2RegClass,\n          &RISCV::VRM4RegClass, &RISCV::VRM8RegClass, &RISCV::VRN2M1RegClass,\n          &RISCV::VRN3M1RegClass, &RISCV::VRN4M1RegClass,\n          &RISCV::VRN5M1RegClass, &RISCV::VRN6M1RegClass,\n          &RISCV::VRN7M1RegClass, &RISCV::VRN8M1RegClass,\n          &RISCV::VRN2M2RegClass, &RISCV::VRN3M2RegClass,\n          &RISCV::VRN4M2RegClass, &RISCV::VRN2M4RegClass}) {\n\nfor (const auto *RC :\n         {&RISCV::VMNoV0RegClass, &RISCV::VRNoV0RegClass,\n          &RISCV::VRM2NoV0RegClass, &RISCV::VRM4NoV0RegClass,\n          &RISCV::VRM8NoV0RegClass, &RISCV::VRN2M1NoV0RegClass,\n          &RISCV::VRN3M1NoV0RegClass, &RISCV::VRN4M1NoV0RegClass,\n          &RISCV::VRN5M1NoV0RegClass, &RISCV::VRN6M1NoV0RegClass,\n          &RISCV::VRN7M1NoV0RegClass, &RISCV::VRN8M1NoV0RegClass,\n          &RISCV::VRN2M2NoV0RegClass, &RISCV::VRN3M2NoV0RegClass,\n          &RISCV::VRN4M2NoV0RegClass, &RISCV::VRN2M4NoV0RegClass}) {", "source_url": "https://github.com/llvm/llvm-project/commit/632cbee244f31854c3d7320033471772a7a2f453", "code_v0_no_empty_lines": "对于\"vr\"和\"vd\"内联汇编约束，当处理mask类型时，使用VR和VRNoV0寄存器类（其第一个类型为nxv8i8），导致生成额外的insert/extract_subvector和bitcast转换指令，并且对nxv16i4类型参数产生错误的扩展代码。", "code_v1_no_empty_lines": "for (const auto *RC :\n         {&RISCV::VMRegClass, &RISCV::VRRegClass, &RISCV::VRM2RegClass,\n          &RISCV::VRM4RegClass, &RISCV::VRM8RegClass, &RISCV::VRN2M1RegClass,\n          &RISCV::VRN3M1RegClass, &RISCV::VRN4M1RegClass,\n          &RISCV::VRN5M1RegClass, &RISCV::VRN6M1RegClass,\n          &RISCV::VRN7M1RegClass, &RISCV::VRN8M1RegClass,\n          &RISCV::VRN2M2RegClass, &RISCV::VRN3M2RegClass,\n          &RISCV::VRN4M2RegClass, &RISCV::VRN2M4RegClass}) {\n\nfor (const auto *RC :\n         {&RISCV::VMNoV0RegClass, &RISCV::VRNoV0RegClass,\n          &RISCV::VRM2NoV0RegClass, &RISCV::VRM4NoV0RegClass,\n          &RISCV::VRM8NoV0RegClass, &RISCV::VRN2M1NoV0RegClass,\n          &RISCV::VRN3M1NoV0RegClass, &RISCV::VRN4M1NoV0RegClass,\n          &RISCV::VRN5M1NoV0RegClass, &RISCV::VRN6M1NoV0RegClass,\n          &RISCV::VRN7M1NoV0RegClass, &RISCV::VRN8M1NoV0RegClass,\n          &RISCV::VRN2M2NoV0RegClass, &RISCV::VRN3M2NoV0RegClass,\n          &RISCV::VRN4M2NoV0RegClass, &RISCV::VRN2M4NoV0RegClass}) {", "target": "for (const auto *RC :\n         {&RISCV::VMRegClass, &RISCV::VRRegClass, &RISCV::VRM2RegClass,\n          &RISCV::VRM4RegClass, &RISCV::VRM8RegClass, &RISCV::VRN2M1RegClass,\n          &RISCV::VRN3M1RegClass, &RISCV::VRN4M1RegClass,\n          &RISCV::VRN5M1RegClass, &RISCV::VRN6M1RegClass,\n          &RISCV::VRN7M1RegClass, &RISCV::VRN8M1RegClass,\n          &RISCV::VRN2M2RegClass, &RISCV::VRN3M2RegClass,\n          &RISCV::VRN4M2RegClass, &RISCV::VRN2M4RegClass}) {\n\nfor (const auto *RC :\n         {&RISCV::VMNoV0RegClass, &RISCV::VRNoV0RegClass,\n          &RISCV::VRM2NoV0RegClass, &RISCV::VRM4NoV0RegClass,\n          &RISCV::VRM8NoV0RegClass, &RISCV::VRN2M1NoV0RegClass,\n          &RISCV::VRN3M1NoV0RegClass, &RISCV::VRN4M1NoV0RegClass,\n          &RISCV::VRN5M1NoV0RegClass, &RISCV::VRN6M1NoV0RegClass,\n          &RISCV::VRN7M1NoV0RegClass, &RISCV::VRN8M1NoV0RegClass,\n          &RISCV::VRN2M2NoV0RegClass, &RISCV::VRN3M2NoV0RegClass,\n          &RISCV::VRN4M2NoV0RegClass, &RISCV::VRN2M4NoV0RegClass}) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于\"vr\"和\"vd\"内联汇编约束，当处理mask类型时，使用VR和VRNoV0寄存器类（其第一个类型为nxv8i8），导致生成额外的insert/extract_subvector和bitcast转换指令，并且对nxv16i4类型参数产生错误的扩展代码。优化后：将VM和VMNoV0寄存器类（其第一个类型为nxv64i1）放在检查列表的最前面，使得mask类型优先使用这些寄存器类，从而减少不必要的bitcast转换，只生成insert/extract_subvector指令，同时为后续修复nxv16i4参数问题提供基础。优化思路：通过调整寄存器类检查顺序，让mask类型匹配更合适的寄存器类，减少类型转换开销并修复代码生成错误。"}
{"id": 520, "source": "riscv-dataset-excel", "optimization_type": "寄存器分配优化", "optimization_description": "优化前：向量掩码类型的内联汇编约束只能使用包含V0寄存器的VM寄存器类，可能导致不必要的寄存器分配限制。优化后：新增VMNoV0寄存器类，专门用于向量掩码类型但不包含V0寄存器，为后续的内联汇编约束提供更精确的寄存器分配。思路：通过创建专门的寄存器类来区分包含和不包含V0的掩码寄存器，提高寄存器分配的灵活性和精确性。", "original_code": "向量掩码类型的内联汇编约束只能使用包含V0寄存器的VM寄存器类，可能导致不必要的寄存器分配限制。", "optimized_code": "def VMNoV0 : VReg<VMaskVTs, (sub VR, V0), 1>;", "source_url": "https://github.com/llvm/llvm-project/commit/2e16f24957eea220d09bdc869d369c80904eecaf", "code_v0_no_empty_lines": "向量掩码类型的内联汇编约束只能使用包含V0寄存器的VM寄存器类，可能导致不必要的寄存器分配限制。", "code_v1_no_empty_lines": "def VMNoV0 : VReg<VMaskVTs, (sub VR, V0), 1>;", "target": "def VMNoV0 : VReg<VMaskVTs, (sub VR, V0), 1>;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：向量掩码类型的内联汇编约束只能使用包含V0寄存器的VM寄存器类，可能导致不必要的寄存器分配限制。优化后：新增VMNoV0寄存器类，专门用于向量掩码类型但不包含V0寄存器，为后续的内联汇编约束提供更精确的寄存器分配。思路：通过创建专门的寄存器类来区分包含和不包含V0的掩码寄存器，提高寄存器分配的灵活性和精确性。"}
{"id": 521, "source": "riscv-dataset-excel", "optimization_type": "构建系统优化", "optimization_description": "优化前：构建配置中CFLAGS全局应用于所有源文件，导致为vector_math_neon.c错误地添加了SVE架构标志。优化后：将CFLAGS改为针对特定文件vector_math_sve.c的编译标志，避免错误传递。思路：通过精细化编译标志作用范围，确保每个源文件使用正确的架构指令集，解决构建错误并提升构建正确性。", "original_code": "构建配置中CFLAGS全局应用于所有源文件，导致为vector_math_neon.c错误地添加了SVE架构标志。", "optimized_code": "-      CFLAGS := $(SVE_CFLAGS), \\\n+      vector_math_sve.c_CFLAGS := $(SVE_CFLAGS), \\", "source_url": "https://github.com/openjdk/riscv-port/commit/3ebf88996f35f397f4396e3d139b9251048de751", "code_v0_no_empty_lines": "构建配置中CFLAGS全局应用于所有源文件，导致为vector_math_neon.c错误地添加了SVE架构标志。", "code_v1_no_empty_lines": "-      CFLAGS := $(SVE_CFLAGS), \\\n+      vector_math_sve.c_CFLAGS := $(SVE_CFLAGS), \\", "target": "-      CFLAGS := $(SVE_CFLAGS), \\\n+      vector_math_sve.c_CFLAGS := $(SVE_CFLAGS), \\", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：构建配置中CFLAGS全局应用于所有源文件，导致为vector_math_neon.c错误地添加了SVE架构标志。优化后：将CFLAGS改为针对特定文件vector_math_sve.c的编译标志，避免错误传递。思路：通过精细化编译标志作用范围，确保每个源文件使用正确的架构指令集，解决构建错误并提升构建正确性。"}
{"id": 522, "source": "riscv-dataset-excel", "optimization_type": "指令生成优化+中间表示优化", "optimization_description": "优化前：C2编译器在解析阶段遇到浮点取模运算（ModF/ModD）时，会生成函数调用指令，这些调用需要额外的栈操作、寄存器保存/恢复开销，并且使用FPU的fprem指令需要循环迭代计算，性能开销较大。\n\n优化后：在解析阶段直接生成宏节点（macro nodes）来表示ModF/ModD操作，而不是生成函数调用。这允许后续优化阶段（如指令选择、寄存器分配）更高效地处理这些操作，减少中间表示转换开销，并可能生成更优化的机器指令。\n\n优化思路：通过将浮点取模操作从函数调用转换为宏节点，减少解析阶段的间接开销，使编译器能够进行更积极的优化，提高生成代码的执行效率。", "original_code": "C2编译器在解析阶段遇到浮点取模运算（ModF/ModD）时，会生成函数调用指令，这些调用需要额外的栈操作、寄存器保存/恢复开销，并且使用FPU的fprem指令需要循环迭代计算，性能开销较大。", "optimized_code": "- instruct modDPR_reg(regDPR dst, regDPR src, eAXRegI rax, eFlagsReg cr) %{\n  predicate(UseSSE<=1);\n  match(Set dst (ModD dst src));\n  effect(KILL rax, KILL cr);\n  format %{ \"DMOD   $dst,$src\" %};\n  ins_cost(250);\n  ins_encode(Push_Reg_Mod_DPR(dst, src),\n              emitModDPR(),\n              Push_Result_Mod_DPR(src),\n              Pop_Reg_DPR(dst));\n  ins_pipe( pipe_slow );\n%}\n\n-instruct modD_reg(regD dst, regD src0, regD src1, eAXRegI rax, eFlagsReg cr) %{\n  predicate(UseSSE>=2);\n  match(Set dst (ModD src0 src1));\n  effect(KILL rax, KILL cr);\n  format %{ \"SUB    ESP,8\\t # DMOD\\n\"\n          \"\\tMOVSD  [ESP+0],$src1\\n\"\n          \"\\tFLD_D  [ESP+0]\\n\"\n          \"\\tMOVSD  [ESP+0],$src0\\n\"\n          \"\\tFLD_D  [ESP+0]\\n\"\n     \"loop:\\tFPREM\\n\"\n          \"\\tFWAIT\\n\"\n          \"\\tFNSTSW AX\\n\"\n          \"\\tSAHF\\n\"\n          \"\\tJP     loop\\n\"\n          \"\\tFSTP_D [ESP+0]\\n\"\n          \"\\tMOVSD  $dst,[ESP+0]\\n\"\n          \"\\tADD    ESP,8\\n\"\n          \"\\tFSTP   ST0\\t # Restore FPU Stack\"\n    %};\n  ins_cost(250);\n  ins_encode( Push_ModD_encoding(src0, src1), emitModDPR(), Push_ResultD(dst), PopFPU);\n  ins_pipe( pipe_slow );\n%}", "source_url": "https://github.com/openjdk/riscv-port/commit/f54e0bf267280c270b0e181289498b28aaf36ee6", "code_v0_no_empty_lines": "C2编译器在解析阶段遇到浮点取模运算（ModF/ModD）时，会生成函数调用指令，这些调用需要额外的栈操作、寄存器保存/恢复开销，并且使用FPU的fprem指令需要循环迭代计算，性能开销较大。", "code_v1_no_empty_lines": "- instruct modDPR_reg(regDPR dst, regDPR src, eAXRegI rax, eFlagsReg cr) %{\n  predicate(UseSSE<=1);\n  match(Set dst (ModD dst src));\n  effect(KILL rax, KILL cr);\n  format %{ \"DMOD   $dst,$src\" %};\n  ins_cost(250);\n  ins_encode(Push_Reg_Mod_DPR(dst, src),\n              emitModDPR(),\n              Push_Result_Mod_DPR(src),\n              Pop_Reg_DPR(dst));\n  ins_pipe( pipe_slow );\n%}\n\n-instruct modD_reg(regD dst, regD src0, regD src1, eAXRegI rax, eFlagsReg cr) %{\n  predicate(UseSSE>=2);\n  match(Set dst (ModD src0 src1));\n  effect(KILL rax, KILL cr);\n  format %{ \"SUB    ESP,8\\t # DMOD\\n\"\n          \"\\tMOVSD  [ESP+0],$src1\\n\"\n          \"\\tFLD_D  [ESP+0]\\n\"\n          \"\\tMOVSD  [ESP+0],$src0\\n\"\n          \"\\tFLD_D  [ESP+0]\\n\"\n     \"loop:\\tFPREM\\n\"\n          \"\\tFWAIT\\n\"\n          \"\\tFNSTSW AX\\n\"\n          \"\\tSAHF\\n\"\n          \"\\tJP     loop\\n\"\n          \"\\tFSTP_D [ESP+0]\\n\"\n          \"\\tMOVSD  $dst,[ESP+0]\\n\"\n          \"\\tADD    ESP,8\\n\"\n          \"\\tFSTP   ST0\\t # Restore FPU Stack\"\n    %};\n  ins_cost(250);\n  ins_encode( Push_ModD_encoding(src0, src1), emitModDPR(), Push_ResultD(dst), PopFPU);\n  ins_pipe( pipe_slow );\n%}", "target": "- instruct modDPR_reg(regDPR dst, regDPR src, eAXRegI rax, eFlagsReg cr) %{\n  predicate(UseSSE<=1);\n  match(Set dst (ModD dst src));\n  effect(KILL rax, KILL cr);\n  format %{ \"DMOD   $dst,$src\" %};\n  ins_cost(250);\n  ins_encode(Push_Reg_Mod_DPR(dst, src),\n              emitModDPR(),\n              Push_Result_Mod_DPR(src),\n              Pop_Reg_DPR(dst));\n  ins_pipe( pipe_slow );\n%}\n\n-instruct modD_reg(regD dst, regD src0, regD src1, eAXRegI rax, eFlagsReg cr) %{\n  predicate(UseSSE>=2);\n  match(Set dst (ModD src0 src1));\n  effect(KILL rax, KILL cr);\n  format %{ \"SUB    ESP,8\\t # DMOD\\n\"\n          \"\\tMOVSD  [ESP+0],$src1\\n\"\n          \"\\tFLD_D  [ESP+0]\\n\"\n          \"\\tMOVSD  [ESP+0],$src0\\n\"\n          \"\\tFLD_D  [ESP+0]\\n\"\n     \"loop:\\tFPREM\\n\"\n          \"\\tFWAIT\\n\"\n          \"\\tFNSTSW AX\\n\"\n          \"\\tSAHF\\n\"\n          \"\\tJP     loop\\n\"\n          \"\\tFSTP_D [ESP+0]\\n\"\n          \"\\tMOVSD  $dst,[ESP+0]\\n\"\n          \"\\tADD    ESP,8\\n\"\n          \"\\tFSTP   ST0\\t # Restore FPU Stack\"\n    %};\n  ins_cost(250);\n  ins_encode( Push_ModD_encoding(src0, src1), emitModDPR(), Push_ResultD(dst), PopFPU);\n  ins_pipe( pipe_slow );\n%}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器在解析阶段遇到浮点取模运算（ModF/ModD）时，会生成函数调用指令，这些调用需要额外的栈操作、寄存器保存/恢复开销，并且使用FPU的fprem指令需要循环迭代计算，性能开销较大。\n\n优化后：在解析阶段直接生成宏节点（macro nodes）来表示ModF/ModD操作，而不是生成函数调用。这允许后续优化阶段（如指令选择、寄存器分配）更高效地处理这些操作，减少中间表示转换开销，并可能生成更优化的机器指令。\n\n优化思路：通过将浮点取模操作从函数调用转换为宏节点，减少解析阶段的间接开销，使编译器能够进行更积极的优化，提高生成代码的执行效率。"}
{"id": 523, "source": "riscv-dataset-excel", "optimization_type": "代码简化+逻辑优化", "optimization_description": "优化前：代码结构冗余，对AlwaysTenure/NeverTenure条件重复检查两次，分别处理减阈值和增阈值逻辑。优化后：合并条件检查，将AlwaysTenure/NeverTenure的判断提取到外层，内部嵌套处理增减阈值逻辑，减少重复代码和条件判断次数。思路：通过重构条件逻辑简化代码结构，提高可读性并减少不必要的条件判断开销。", "original_code": "代码结构冗余，对AlwaysTenure/NeverTenure条件重复检查两次，分别处理减阈值和增阈值逻辑。", "optimized_code": "-  if (decr_tenuring_threshold && !(AlwaysTenure || NeverTenure)) {\n-    if (tenuring_threshold > 1) {\n+  if (!(AlwaysTenure || NeverTenure)) {\n+    if (decr_tenuring_threshold && tenuring_threshold > 1) {\n       tenuring_threshold--;\n-    }\n-  } else if (incr_tenuring_threshold && !(AlwaysTenure || NeverTenure)) {\n-    if (tenuring_threshold < MaxTenuringThreshold) {\n+    } else if (incr_tenuring_threshold && tenuring_threshold < MaxTenuringThreshold) {\n       tenuring_threshold++;\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/c207cc7e705d3f449f2387324d86cfb31ce40c44", "code_v0_no_empty_lines": "代码结构冗余，对AlwaysTenure/NeverTenure条件重复检查两次，分别处理减阈值和增阈值逻辑。", "code_v1_no_empty_lines": "-  if (decr_tenuring_threshold && !(AlwaysTenure || NeverTenure)) {\n-    if (tenuring_threshold > 1) {\n+  if (!(AlwaysTenure || NeverTenure)) {\n+    if (decr_tenuring_threshold && tenuring_threshold > 1) {\n       tenuring_threshold--;\n-    }\n-  } else if (incr_tenuring_threshold && !(AlwaysTenure || NeverTenure)) {\n-    if (tenuring_threshold < MaxTenuringThreshold) {\n+    } else if (incr_tenuring_threshold && tenuring_threshold < MaxTenuringThreshold) {\n       tenuring_threshold++;\n     }", "target": "-  if (decr_tenuring_threshold && !(AlwaysTenure || NeverTenure)) {\n-    if (tenuring_threshold > 1) {\n+  if (!(AlwaysTenure || NeverTenure)) {\n+    if (decr_tenuring_threshold && tenuring_threshold > 1) {\n       tenuring_threshold--;\n-    }\n-  } else if (incr_tenuring_threshold && !(AlwaysTenure || NeverTenure)) {\n-    if (tenuring_threshold < MaxTenuringThreshold) {\n+    } else if (incr_tenuring_threshold && tenuring_threshold < MaxTenuringThreshold) {\n       tenuring_threshold++;\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：代码结构冗余，对AlwaysTenure/NeverTenure条件重复检查两次，分别处理减阈值和增阈值逻辑。优化后：合并条件检查，将AlwaysTenure/NeverTenure的判断提取到外层，内部嵌套处理增减阈值逻辑，减少重复代码和条件判断次数。思路：通过重构条件逻辑简化代码结构，提高可读性并减少不必要的条件判断开销。"}
{"id": 524, "source": "riscv-dataset-excel", "optimization_type": "内存优化+编译时性能优化", "optimization_description": "优化前：每次调用arraycopy_type()等函数时都会动态创建TypeFunc对象，导致重复计算和内存分配开销。优化后：将TypeFunc对象缓存为静态成员变量，通过initialize_xxx_Type()函数一次性初始化，后续调用直接返回缓存对象。优化思路：将运行时重复创建的类型对象改为编译时一次性创建并缓存，减少内存分配和计算开销，提高编译效率。", "original_code": "每次调用arraycopy_type()等函数时都会动态创建TypeFunc对象，导致重复计算和内存分配开销。", "optimized_code": "static const TypeFunc* _arraycopy_type_Type;\n\nstatic const TypeFunc* arraycopy_type() {\n  assert(_arraycopy_type_Type != nullptr, \"should be initialized\");\n  return _arraycopy_type_Type;\n}\n\nstatic void initialize_arraycopy_Type() {\n  assert(_arraycopy_type_Type == nullptr, \"should be\");\n  // ... TypeFunc creation logic ...\n  _arraycopy_type_Type = TypeFunc::make(domain, range);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/f5573f5cbdcae5d1303c8b58d2946c168b977326", "code_v0_no_empty_lines": "每次调用arraycopy_type()等函数时都会动态创建TypeFunc对象，导致重复计算和内存分配开销。", "code_v1_no_empty_lines": "static const TypeFunc* _arraycopy_type_Type;\n\nstatic const TypeFunc* arraycopy_type() {\n  assert(_arraycopy_type_Type != nullptr, \"should be initialized\");\n  return _arraycopy_type_Type;\n}\n\nstatic void initialize_arraycopy_Type() {\n  assert(_arraycopy_type_Type == nullptr, \"should be\");\n  // ... TypeFunc creation logic ...\n  _arraycopy_type_Type = TypeFunc::make(domain, range);\n}", "target": "static const TypeFunc* _arraycopy_type_Type;\n\nstatic const TypeFunc* arraycopy_type() {\n  assert(_arraycopy_type_Type != nullptr, \"should be initialized\");\n  return _arraycopy_type_Type;\n}\n\nstatic void initialize_arraycopy_Type() {\n  assert(_arraycopy_type_Type == nullptr, \"should be\");\n  // ... TypeFunc creation logic ...\n  _arraycopy_type_Type = TypeFunc::make(domain, range);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次调用arraycopy_type()等函数时都会动态创建TypeFunc对象，导致重复计算和内存分配开销。优化后：将TypeFunc对象缓存为静态成员变量，通过initialize_xxx_Type()函数一次性初始化，后续调用直接返回缓存对象。优化思路：将运行时重复创建的类型对象改为编译时一次性创建并缓存，减少内存分配和计算开销，提高编译效率。"}
{"id": 525, "source": "riscv-dataset-excel", "optimization_type": "编译器中间表示优化", "optimization_description": "优化前：CMoveNode、FmaDNode、FmaFNode、ReverseBytes*Node、Reverse*Node等节点构造函数需要传入control()或nullptr作为控制输入参数。优化后：移除了这些节点的控制输入参数，简化了节点构造。优化思路：在C2编译器优化阶段，某些节点（如条件移动、融合乘加、字节反转等）的控制输入是冗余的，移除这些不必要的控制输入可以简化中间表示、减少内存占用，并可能提高后续优化阶段的效率。", "original_code": "CMoveNode、FmaDNode、FmaFNode、ReverseBytes*Node、Reverse*Node等节点构造函数需要传入control()或nullptr作为控制输入参数。", "optimized_code": "-    res = gvn.transform(CMoveNode::make(nullptr, bol, a, b, t));\n+    res = gvn.transform(CMoveNode::make(bol, a, b, t));\n-    result = _gvn.transform(new FmaDNode(control(), a, b, c));\n+    result = _gvn.transform(new FmaDNode(a, b, c));\n-    Node *cmov = CMoveNode::make(cmov_ctrl, iff->in(1), phi->in(1+flip), phi->in(2-flip), _igvn.type(phi));\n+    Node* cmov = CMoveNode::make(iff->in(1), phi->in(1+flip), phi->in(2-flip), _igvn.type(phi));", "source_url": "https://github.com/openjdk/riscv-port/commit/aa21de566d387ab71adebdf798f7710a005c27b1", "code_v0_no_empty_lines": "CMoveNode、FmaDNode、FmaFNode、ReverseBytes*Node、Reverse*Node等节点构造函数需要传入control()或nullptr作为控制输入参数。", "code_v1_no_empty_lines": "-    res = gvn.transform(CMoveNode::make(nullptr, bol, a, b, t));\n+    res = gvn.transform(CMoveNode::make(bol, a, b, t));\n-    result = _gvn.transform(new FmaDNode(control(), a, b, c));\n+    result = _gvn.transform(new FmaDNode(a, b, c));\n-    Node *cmov = CMoveNode::make(cmov_ctrl, iff->in(1), phi->in(1+flip), phi->in(2-flip), _igvn.type(phi));\n+    Node* cmov = CMoveNode::make(iff->in(1), phi->in(1+flip), phi->in(2-flip), _igvn.type(phi));", "target": "-    res = gvn.transform(CMoveNode::make(nullptr, bol, a, b, t));\n+    res = gvn.transform(CMoveNode::make(bol, a, b, t));\n-    result = _gvn.transform(new FmaDNode(control(), a, b, c));\n+    result = _gvn.transform(new FmaDNode(a, b, c));\n-    Node *cmov = CMoveNode::make(cmov_ctrl, iff->in(1), phi->in(1+flip), phi->in(2-flip), _igvn.type(phi));\n+    Node* cmov = CMoveNode::make(iff->in(1), phi->in(1+flip), phi->in(2-flip), _igvn.type(phi));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CMoveNode、FmaDNode、FmaFNode、ReverseBytes*Node、Reverse*Node等节点构造函数需要传入control()或nullptr作为控制输入参数。优化后：移除了这些节点的控制输入参数，简化了节点构造。优化思路：在C2编译器优化阶段，某些节点（如条件移动、融合乘加、字节反转等）的控制输入是冗余的，移除这些不必要的控制输入可以简化中间表示、减少内存占用，并可能提高后续优化阶段的效率。"}
{"id": 526, "source": "riscv-dataset-excel", "optimization_type": "缓存优化+指令集优化", "optimization_description": "优化前：secondary_super_cache 在 RISC-V 架构上扩展性差，C1 编译器和解释器使用线性搜索查找次级超类，导致性能瓶颈。优化后：1. 引入哈希表查找机制（check_klass_subtype_slow_path_table），通过寄存器动态分配和哈希表加速次级超类查找；2. 优化寄存器使用逻辑，避免不必要的寄存器冲突；3. 新增 ror 指令实现以利用 RISC-V Zbb 扩展提升位操作效率。优化思路：将线性搜索替换为哈希表查找，减少缓存未命中，提升多线程环境下的类继承检查性能。", "original_code": "secondary_super_cache 在 RISC-V 架构上扩展性差，C1 编译器和解释器使用线性搜索查找次级超类，导致性能瓶颈。", "optimized_code": "void MacroAssembler::check_klass_subtype_slow_path_table(Register sub_klass,\n                                                         Register super_klass,\n                                                         Register tmp1_reg,\n                                                         Register tmp2_reg,\n                                                         Label* L_success,\n                                                         Label* L_failure,\n                                                         bool set_cond_codes) {\n  RegSet tmps = RegSet::of(tmp1_reg, tmp2_reg);\n\n  assert_different_registers(sub_klass, super_klass, tmp1_reg, tmp2_reg);\n\n  Label L_fallthrough;\n  int label_nulls = 0;\n  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n  assert(label_nulls <= 1, \"at most one null in the batch\");\n\n  BLOCK_COMMENT(\"check_klass_subtype_slow_path\");\n\n  RegSet caller_save_regs = RegSet::of(x7) + RegSet::range(x10, x17) + RegSet::range(x28, x31);\n  RegSetIterator<Register> available_regs = (caller_save_regs - tmps - sub_klass - super_klass).begin();\n\n  RegSet pushed_regs;\n\n  tmp1_reg = allocate_if_noreg(tmp1_reg, available_regs, pushed_regs);", "source_url": "https://github.com/openjdk/riscv-port/commit/8460072f9ddcec5d1f86e3c4de3d1457771b805c", "code_v0_no_empty_lines": "secondary_super_cache 在 RISC-V 架构上扩展性差，C1 编译器和解释器使用线性搜索查找次级超类，导致性能瓶颈。", "code_v1_no_empty_lines": "void MacroAssembler::check_klass_subtype_slow_path_table(Register sub_klass,\n                                                         Register super_klass,\n                                                         Register tmp1_reg,\n                                                         Register tmp2_reg,\n                                                         Label* L_success,\n                                                         Label* L_failure,\n                                                         bool set_cond_codes) {\n  RegSet tmps = RegSet::of(tmp1_reg, tmp2_reg);\n\n  assert_different_registers(sub_klass, super_klass, tmp1_reg, tmp2_reg);\n\n  Label L_fallthrough;\n  int label_nulls = 0;\n  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n  assert(label_nulls <= 1, \"at most one null in the batch\");\n\n  BLOCK_COMMENT(\"check_klass_subtype_slow_path\");\n\n  RegSet caller_save_regs = RegSet::of(x7) + RegSet::range(x10, x17) + RegSet::range(x28, x31);\n  RegSetIterator<Register> available_regs = (caller_save_regs - tmps - sub_klass - super_klass).begin();\n\n  RegSet pushed_regs;\n\n  tmp1_reg = allocate_if_noreg(tmp1_reg, available_regs, pushed_regs);", "target": "void MacroAssembler::check_klass_subtype_slow_path_table(Register sub_klass,\n                                                         Register super_klass,\n                                                         Register tmp1_reg,\n                                                         Register tmp2_reg,\n                                                         Label* L_success,\n                                                         Label* L_failure,\n                                                         bool set_cond_codes) {\n  RegSet tmps = RegSet::of(tmp1_reg, tmp2_reg);\n\n  assert_different_registers(sub_klass, super_klass, tmp1_reg, tmp2_reg);\n\n  Label L_fallthrough;\n  int label_nulls = 0;\n  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n  assert(label_nulls <= 1, \"at most one null in the batch\");\n\n  BLOCK_COMMENT(\"check_klass_subtype_slow_path\");\n\n  RegSet caller_save_regs = RegSet::of(x7) + RegSet::range(x10, x17) + RegSet::range(x28, x31);\n  RegSetIterator<Register> available_regs = (caller_save_regs - tmps - sub_klass - super_klass).begin();\n\n  RegSet pushed_regs;\n\n  tmp1_reg = allocate_if_noreg(tmp1_reg, available_regs, pushed_regs);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：secondary_super_cache 在 RISC-V 架构上扩展性差，C1 编译器和解释器使用线性搜索查找次级超类，导致性能瓶颈。优化后：1. 引入哈希表查找机制（check_klass_subtype_slow_path_table），通过寄存器动态分配和哈希表加速次级超类查找；2. 优化寄存器使用逻辑，避免不必要的寄存器冲突；3. 新增 ror 指令实现以利用 RISC-V Zbb 扩展提升位操作效率。优化思路：将线性搜索替换为哈希表查找，减少缓存未命中，提升多线程环境下的类继承检查性能。"}
{"id": 527, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+内存优化", "optimization_description": "优化前：1) GC状态通过堆全局变量访问，存在线程竞争；2) init-update-refs阶段需要安全点，暂停所有线程；3) GC LABs（本地分配缓冲区）在安全点中回收。优化后：1) 使用线程本地数据存储GC状态，消除全局访问竞争；2) 移除init-update-refs安全点，使更新引用阶段完全并发；3) 并发回收GC LABs，减少暂停时间。优化思路：通过线程本地化和并发化减少GC暂停，提升应用响应性。", "original_code": "1) GC状态通过堆全局变量访问，存在线程竞争；2) init-update-refs阶段需要安全点，暂停所有线程；3) GC LABs（本地分配缓冲区）在安全点中回收。", "optimized_code": "-  int gc_state = _heap->gc_state();\n+  char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n-  heap->set_evacuation_in_progress(false);\n-  heap->set_concurrent_weak_root_in_progress(false);\n-  heap->prepare_update_heap_references(true /*concurrent*/);\n-  heap->set_update_refs_in_progress(true);\n+  // Evacuation is complete, retire gc labs\n+  heap->concurrent_prepare_for_update_refs();\n+  // Perform update-refs phase.\n+  if (ShenandoahVerify || ShenandoahPacing) {\n+    vmop_entry_init_updaterefs();\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/764d70b7df18e288582e616c62b0d7078f1ff3aa", "code_v0_no_empty_lines": "1) GC状态通过堆全局变量访问，存在线程竞争；2) init-update-refs阶段需要安全点，暂停所有线程；3) GC LABs（本地分配缓冲区）在安全点中回收。", "code_v1_no_empty_lines": "-  int gc_state = _heap->gc_state();\n+  char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n-  heap->set_evacuation_in_progress(false);\n-  heap->set_concurrent_weak_root_in_progress(false);\n-  heap->prepare_update_heap_references(true /*concurrent*/);\n-  heap->set_update_refs_in_progress(true);\n+  // Evacuation is complete, retire gc labs\n+  heap->concurrent_prepare_for_update_refs();\n+  // Perform update-refs phase.\n+  if (ShenandoahVerify || ShenandoahPacing) {\n+    vmop_entry_init_updaterefs();\n+  }", "target": "-  int gc_state = _heap->gc_state();\n+  char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n-  heap->set_evacuation_in_progress(false);\n-  heap->set_concurrent_weak_root_in_progress(false);\n-  heap->prepare_update_heap_references(true /*concurrent*/);\n-  heap->set_update_refs_in_progress(true);\n+  // Evacuation is complete, retire gc labs\n+  heap->concurrent_prepare_for_update_refs();\n+  // Perform update-refs phase.\n+  if (ShenandoahVerify || ShenandoahPacing) {\n+    vmop_entry_init_updaterefs();\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1) GC状态通过堆全局变量访问，存在线程竞争；2) init-update-refs阶段需要安全点，暂停所有线程；3) GC LABs（本地分配缓冲区）在安全点中回收。优化后：1) 使用线程本地数据存储GC状态，消除全局访问竞争；2) 移除init-update-refs安全点，使更新引用阶段完全并发；3) 并发回收GC LABs，减少暂停时间。优化思路：通过线程本地化和并发化减少GC暂停，提升应用响应性。"}
{"id": 528, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+内存可见性优化", "optimization_description": "优化前：每次调用matches方法时都会进入同步块，即使operations和context已初始化，导致不必要的同步开销。优化后：1. 使用双重检查锁定模式，仅在operations或context为null时才进入同步块，减少锁竞争；2. 为operations和context字段添加volatile修饰符，确保多线程环境下的内存可见性。优化思路：通过延迟同步和保证内存可见性，提高specjvm2008::xml.validation工作负载的可扩展性。", "original_code": "每次调用matches方法时都会进入同步块，即使operations和context已初始化，导致不必要的同步开销。", "optimized_code": "- synchronized (this) {\n-     if (this.operations == null)\n-         this.prepare();\n-     if (this.context == null)\n-         this.context = new Context();\n+ if (this.operations == null || this.context == null) {\n+     synchronized (this) {\n+         if (this.operations == null)\n+             this.prepare();\n+         if (this.context == null)\n+             this.context = new Context();\n+     }\n }\n \n- transient Op operations = null;\n- transient Context context = null;\n+ transient volatile Op operations = null;\n+ transient volatile Context context = null;", "source_url": "https://github.com/openjdk/riscv-port/commit/10d08dbc81aa14499410f0a7a64d0b3243b660f1", "code_v0_no_empty_lines": "每次调用matches方法时都会进入同步块，即使operations和context已初始化，导致不必要的同步开销。", "code_v1_no_empty_lines": "- synchronized (this) {\n-     if (this.operations == null)\n-         this.prepare();\n-     if (this.context == null)\n-         this.context = new Context();\n+ if (this.operations == null || this.context == null) {\n+     synchronized (this) {\n+         if (this.operations == null)\n+             this.prepare();\n+         if (this.context == null)\n+             this.context = new Context();\n+     }\n }\n \n- transient Op operations = null;\n- transient Context context = null;\n+ transient volatile Op operations = null;\n+ transient volatile Context context = null;", "target": "- synchronized (this) {\n-     if (this.operations == null)\n-         this.prepare();\n-     if (this.context == null)\n-         this.context = new Context();\n+ if (this.operations == null || this.context == null) {\n+     synchronized (this) {\n+         if (this.operations == null)\n+             this.prepare();\n+         if (this.context == null)\n+             this.context = new Context();\n+     }\n }\n \n- transient Op operations = null;\n- transient Context context = null;\n+ transient volatile Op operations = null;\n+ transient volatile Context context = null;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次调用matches方法时都会进入同步块，即使operations和context已初始化，导致不必要的同步开销。优化后：1. 使用双重检查锁定模式，仅在operations或context为null时才进入同步块，减少锁竞争；2. 为operations和context字段添加volatile修饰符，确保多线程环境下的内存可见性。优化思路：通过延迟同步和保证内存可见性，提高specjvm2008::xml.validation工作负载的可扩展性。"}
{"id": 529, "source": "riscv-dataset-excel", "optimization_type": "编译器调度优化", "optimization_description": "优化前：调度器在比较基本块频率时使用精确比较（LCA->_freq < least_freq），由于浮点数计算存在微小误差，可能导致不必要的指令提升（hoisting），增加寄存器压力和指令开销。优化后：引入delta因子（1 + PROB_UNLIKELY_MAG(4)）作为容差阈值，只有当LCA块频率明显更低（LCA->_freq * delta < least_freq）时才认为其更优。优化思路：避免因浮点数精度误差导致的过度优化，减少不必要的指令移动，提高调度质量并降低寄存器压力。", "original_code": "调度器在比较基本块频率时使用精确比较（LCA->_freq < least_freq），由于浮点数计算存在微小误差，可能导致不必要的指令提升（hoisting），增加寄存器压力和指令开销。", "optimized_code": "-  if (LCA->_freq < least_freq) {\n+  const double delta = 1 + PROB_UNLIKELY_MAG(4);\n+\n+  // Better Frequency. Add a small delta to the comparison to not needlessly\n+  // hoist because of, e.g., small numerical inaccuracies.\n+  if (LCA->_freq * delta < least_freq) {\n   return true;\n }\n \n // Otherwise, choose with latency\n-  const double delta = 1 + PROB_UNLIKELY_MAG(4);", "source_url": "https://github.com/openjdk/riscv-port/commit/cbb2b847e48c970297c2142a0675918b364e7987", "code_v0_no_empty_lines": "调度器在比较基本块频率时使用精确比较（LCA->_freq < least_freq），由于浮点数计算存在微小误差，可能导致不必要的指令提升（hoisting），增加寄存器压力和指令开销。", "code_v1_no_empty_lines": "-  if (LCA->_freq < least_freq) {\n+  const double delta = 1 + PROB_UNLIKELY_MAG(4);\n+\n+  // Better Frequency. Add a small delta to the comparison to not needlessly\n+  // hoist because of, e.g., small numerical inaccuracies.\n+  if (LCA->_freq * delta < least_freq) {\n   return true;\n }\n \n // Otherwise, choose with latency\n-  const double delta = 1 + PROB_UNLIKELY_MAG(4);", "target": "-  if (LCA->_freq < least_freq) {\n+  const double delta = 1 + PROB_UNLIKELY_MAG(4);\n+\n+  // Better Frequency. Add a small delta to the comparison to not needlessly\n+  // hoist because of, e.g., small numerical inaccuracies.\n+  if (LCA->_freq * delta < least_freq) {\n   return true;\n }\n \n // Otherwise, choose with latency\n-  const double delta = 1 + PROB_UNLIKELY_MAG(4);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：调度器在比较基本块频率时使用精确比较（LCA->_freq < least_freq），由于浮点数计算存在微小误差，可能导致不必要的指令提升（hoisting），增加寄存器压力和指令开销。优化后：引入delta因子（1 + PROB_UNLIKELY_MAG(4)）作为容差阈值，只有当LCA块频率明显更低（LCA->_freq * delta < least_freq）时才认为其更优。优化思路：避免因浮点数精度误差导致的过度优化，减少不必要的指令移动，提高调度质量并降低寄存器压力。"}
{"id": 530, "source": "riscv-dataset-excel", "optimization_type": "并发数据一致性优化", "optimization_description": "优化前：在canBufferUnprocessedBytes方法中，先调用unprocessed.addAndGet(len)增加未处理字节数，然后将结果传递给checkWindowSizeExceeded方法，该方法内部再调用received.get()获取已接收字节数。这种顺序可能导致在并发环境下，未处理字节被异步释放时被重复计数，造成HTTP/2流控窗口计算错误。优化后：修改了方法调用顺序，先获取已接收字节数(processed = received.get())，再增加未处理字节数(buffered = unprocessed.addAndGet(len))，然后将这两个值一起传递给checkWindowSizeExceeded方法。这样确保了在检查窗口是否超出时，使用的是获取已接收字节数时的未处理字节状态，避免了因并发操作导致的重复计数问题。优化思路：通过调整原子操作的顺序和参数传递方式，确保流控检查的原子性和一致性，修复了HTTP/2流控可能重复计数未处理数据的bug。", "original_code": "在canBufferUnprocessedBytes方法中，先调用unprocessed.addAndGet(len)增加未处理字节数，然后将结果传递给checkWindowSizeExceeded方法，该方法内部再调用received.get()获取已接收字节数。这种顺序可能导致在并发环境下，未处理字节被异步释放时被重复计数，造成HTTP/2流控窗口计算错误。", "optimized_code": "-    boolean canBufferUnprocessedBytes(int len) {\n-        return !checkWindowSizeExceeded(unprocessed.addAndGet(len));\n+    boolean canBufferUnprocessedBytes(int len) {\n+        long buffered, processed;\n+        // get received before unprocessed in order to avoid counting\n+        // unprocessed bytes that might get unbuffered asynchronously\n+        // twice.\n+        processed = received.get();\n+        buffered = unprocessed.addAndGet(len);\n+        return !checkWindowSizeExceeded(processed, buffered);\n     }\n \n     // adds the provided amount to the amount of already\n-    // received and processed bytes and checks whether the\n+    // processed and processed bytes and checks whether the\n     // flow control window is exceeded. If so, take\n     // corrective actions and return true.\n-    private boolean checkWindowSizeExceeded(long len) {\n+    private boolean checkWindowSizeExceeded(long processed, long len) {\n         // because windowSize is bound by Integer.MAX_VALUE\n         // we will never reach the point where received.get() + len\n         // could overflow\n-        long rcv = received.get() + len;\n+        long rcv = processed + len;\n         return rcv > windowSize && windowSizeExceeded(rcv);\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/06126361db1edb1d4c181a82952c1ac133a839f9", "code_v0_no_empty_lines": "在canBufferUnprocessedBytes方法中，先调用unprocessed.addAndGet(len)增加未处理字节数，然后将结果传递给checkWindowSizeExceeded方法，该方法内部再调用received.get()获取已接收字节数。这种顺序可能导致在并发环境下，未处理字节被异步释放时被重复计数，造成HTTP/2流控窗口计算错误。", "code_v1_no_empty_lines": "-    boolean canBufferUnprocessedBytes(int len) {\n-        return !checkWindowSizeExceeded(unprocessed.addAndGet(len));\n+    boolean canBufferUnprocessedBytes(int len) {\n+        long buffered, processed;\n+        // get received before unprocessed in order to avoid counting\n+        // unprocessed bytes that might get unbuffered asynchronously\n+        // twice.\n+        processed = received.get();\n+        buffered = unprocessed.addAndGet(len);\n+        return !checkWindowSizeExceeded(processed, buffered);\n     }\n \n     // adds the provided amount to the amount of already\n-    // received and processed bytes and checks whether the\n+    // processed and processed bytes and checks whether the\n     // flow control window is exceeded. If so, take\n     // corrective actions and return true.\n-    private boolean checkWindowSizeExceeded(long len) {\n+    private boolean checkWindowSizeExceeded(long processed, long len) {\n         // because windowSize is bound by Integer.MAX_VALUE\n         // we will never reach the point where received.get() + len\n         // could overflow\n-        long rcv = received.get() + len;\n+        long rcv = processed + len;\n         return rcv > windowSize && windowSizeExceeded(rcv);\n     }", "target": "-    boolean canBufferUnprocessedBytes(int len) {\n-        return !checkWindowSizeExceeded(unprocessed.addAndGet(len));\n+    boolean canBufferUnprocessedBytes(int len) {\n+        long buffered, processed;\n+        // get received before unprocessed in order to avoid counting\n+        // unprocessed bytes that might get unbuffered asynchronously\n+        // twice.\n+        processed = received.get();\n+        buffered = unprocessed.addAndGet(len);\n+        return !checkWindowSizeExceeded(processed, buffered);\n     }\n \n     // adds the provided amount to the amount of already\n-    // received and processed bytes and checks whether the\n+    // processed and processed bytes and checks whether the\n     // flow control window is exceeded. If so, take\n     // corrective actions and return true.\n-    private boolean checkWindowSizeExceeded(long len) {\n+    private boolean checkWindowSizeExceeded(long processed, long len) {\n         // because windowSize is bound by Integer.MAX_VALUE\n         // we will never reach the point where received.get() + len\n         // could overflow\n-        long rcv = received.get() + len;\n+        long rcv = processed + len;\n         return rcv > windowSize && windowSizeExceeded(rcv);\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在canBufferUnprocessedBytes方法中，先调用unprocessed.addAndGet(len)增加未处理字节数，然后将结果传递给checkWindowSizeExceeded方法，该方法内部再调用received.get()获取已接收字节数。这种顺序可能导致在并发环境下，未处理字节被异步释放时被重复计数，造成HTTP/2流控窗口计算错误。优化后：修改了方法调用顺序，先获取已接收字节数(processed = received.get())，再增加未处理字节数(buffered = unprocessed.addAndGet(len))，然后将这两个值一起传递给checkWindowSizeExceeded方法。这样确保了在检查窗口是否超出时，使用的是获取已接收字节数时的未处理字节状态，避免了因并发操作导致的重复计数问题。优化思路：通过调整原子操作的顺序和参数传递方式，确保流控检查的原子性和一致性，修复了HTTP/2流控可能重复计数未处理数据的bug。"}
{"id": 531, "source": "riscv-dataset-excel", "optimization_type": "编译器标志优化", "optimization_description": "优化前：Windows构建使用Microsoft编译器时，未启用/Zc:throwingNew标志，导致operator new在内存不足时返回0而非抛出std::bad_alloc，需要手动添加安全分配函数。优化后：添加/Zc:throwingNew编译器标志，使operator new符合C++标准，在内存不足时抛出std::bad_alloc，从而可以删除awt_new.cpp中手动实现的安全分配函数。优化思路：通过编译器标志标准化内存分配行为，简化代码并提高标准符合性。", "original_code": "Windows构建使用Microsoft编译器时，未启用/Zc:throwingNew标志，导致operator new在内存不足时返回0而非抛出std::bad_alloc，需要手动添加安全分配函数。", "optimized_code": "TOOLCHAIN_CFLAGS_JVM=\"-nologo -MD -Zc:preprocessor -Zc:inline -Zc:throwingNew -permissive- -utf-8 -MP\"\nTOOLCHAIN_CFLAGS_JDK=\"-nologo -MD -Zc:preprocessor -Zc:inline -Zc:throwingNew -permissive- -utf-8 -Zc:wchar_t-\"", "source_url": "https://github.com/openjdk/riscv-port/commit/a289bcfe7e2786d05c338712b818fc4ef12cb4ac", "code_v0_no_empty_lines": "Windows构建使用Microsoft编译器时，未启用/Zc:throwingNew标志，导致operator new在内存不足时返回0而非抛出std::bad_alloc，需要手动添加安全分配函数。", "code_v1_no_empty_lines": "TOOLCHAIN_CFLAGS_JVM=\"-nologo -MD -Zc:preprocessor -Zc:inline -Zc:throwingNew -permissive- -utf-8 -MP\"\nTOOLCHAIN_CFLAGS_JDK=\"-nologo -MD -Zc:preprocessor -Zc:inline -Zc:throwingNew -permissive- -utf-8 -Zc:wchar_t-\"", "target": "TOOLCHAIN_CFLAGS_JVM=\"-nologo -MD -Zc:preprocessor -Zc:inline -Zc:throwingNew -permissive- -utf-8 -MP\"\nTOOLCHAIN_CFLAGS_JDK=\"-nologo -MD -Zc:preprocessor -Zc:inline -Zc:throwingNew -permissive- -utf-8 -Zc:wchar_t-\"", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Windows构建使用Microsoft编译器时，未启用/Zc:throwingNew标志，导致operator new在内存不足时返回0而非抛出std::bad_alloc，需要手动添加安全分配函数。优化后：添加/Zc:throwingNew编译器标志，使operator new符合C++标准，在内存不足时抛出std::bad_alloc，从而可以删除awt_new.cpp中手动实现的安全分配函数。优化思路：通过编译器标志标准化内存分配行为，简化代码并提高标准符合性。"}
{"id": 532, "source": "riscv-dataset-excel", "optimization_type": "编译器安全优化", "optimization_description": "优化前：循环预测（Loop Predication）在判断除法操作是否可外提时，仅检查操作是否仅依赖于循环测试（depends_only_on_test），未考虑除法需要零检查（zero check）以防止除零异常。这导致可能将需要零检查的除法操作错误地外提到循环外，引发SIGFPE崩溃。优化后：在判断操作是否可外提时，增加对零检查依赖性的检查（no_dependent_zero_check(n)），确保需要零检查的除法操作不被错误外提。优化思路：通过完善循环预测的条件判断，避免将可能抛出异常的操作外提，确保编译器优化的安全性。", "original_code": "循环预测（Loop Predication）在判断除法操作是否可外提时，仅检查操作是否仅依赖于循环测试（depends_only_on_test），未考虑除法需要零检查（zero check）以防止除零异常。这导致可能将需要零检查的除法操作错误地外提到循环外，引发SIGFPE崩溃。", "optimized_code": "-          if (n->is_CFG() || n->depends_only_on_test() || n->in(0) == nullptr || !_phase->is_member(_lpt, n->in(0))) {\n+          if (n->is_CFG() || (n->depends_only_on_test() && _phase->igvn().no_dependent_zero_check(n)) || n->in(0) == nullptr || !_phase->is_member(_lpt, n->in(0))) {", "source_url": "https://github.com/openjdk/riscv-port/commit/55c6904e8f3d02530749bf28f2cc966e8983a984", "code_v0_no_empty_lines": "循环预测（Loop Predication）在判断除法操作是否可外提时，仅检查操作是否仅依赖于循环测试（depends_only_on_test），未考虑除法需要零检查（zero check）以防止除零异常。这导致可能将需要零检查的除法操作错误地外提到循环外，引发SIGFPE崩溃。", "code_v1_no_empty_lines": "-          if (n->is_CFG() || n->depends_only_on_test() || n->in(0) == nullptr || !_phase->is_member(_lpt, n->in(0))) {\n+          if (n->is_CFG() || (n->depends_only_on_test() && _phase->igvn().no_dependent_zero_check(n)) || n->in(0) == nullptr || !_phase->is_member(_lpt, n->in(0))) {", "target": "-          if (n->is_CFG() || n->depends_only_on_test() || n->in(0) == nullptr || !_phase->is_member(_lpt, n->in(0))) {\n+          if (n->is_CFG() || (n->depends_only_on_test() && _phase->igvn().no_dependent_zero_check(n)) || n->in(0) == nullptr || !_phase->is_member(_lpt, n->in(0))) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：循环预测（Loop Predication）在判断除法操作是否可外提时，仅检查操作是否仅依赖于循环测试（depends_only_on_test），未考虑除法需要零检查（zero check）以防止除零异常。这导致可能将需要零检查的除法操作错误地外提到循环外，引发SIGFPE崩溃。优化后：在判断操作是否可外提时，增加对零检查依赖性的检查（no_dependent_zero_check(n)），确保需要零检查的除法操作不被错误外提。优化思路：通过完善循环预测的条件判断，避免将可能抛出异常的操作外提，确保编译器优化的安全性。"}
{"id": 533, "source": "riscv-dataset-excel", "optimization_type": "代码对齐优化", "optimization_description": "优化前：Ampere-1A和1B处理器使用默认的CodeEntryAlignment值，可能导致代码入口对齐不足，影响指令缓存效率和分支预测性能。优化后：为Ampere-1A和1B处理器设置CodeEntryAlignment为32字节，确保代码入口按32字节边界对齐。优化思路：针对特定CPU架构（Ampere-1A/1B）调整代码对齐参数，利用处理器微架构特性（如缓存行大小、分支预测器对齐要求）减少缓存未命中和分支预测失败，提升指令执行效率。", "original_code": "Ampere-1A和1B处理器使用默认的CodeEntryAlignment值，可能导致代码入口对齐不足，影响指令缓存效率和分支预测性能。", "optimized_code": "+    if (FLAG_IS_DEFAULT(CodeEntryAlignment) &&\n+        (_model == CPU_MODEL_AMPERE_1A || _model == CPU_MODEL_AMPERE_1B)) {\n+      FLAG_SET_DEFAULT(CodeEntryAlignment, 32);\n+    }", "source_url": "https://github.com/openjdk/riscv-port/commit/89ee1a5517ea1e3915f4362ada3d2086b63c107e", "code_v0_no_empty_lines": "Ampere-1A和1B处理器使用默认的CodeEntryAlignment值，可能导致代码入口对齐不足，影响指令缓存效率和分支预测性能。", "code_v1_no_empty_lines": "+    if (FLAG_IS_DEFAULT(CodeEntryAlignment) &&\n+        (_model == CPU_MODEL_AMPERE_1A || _model == CPU_MODEL_AMPERE_1B)) {\n+      FLAG_SET_DEFAULT(CodeEntryAlignment, 32);\n+    }", "target": "+    if (FLAG_IS_DEFAULT(CodeEntryAlignment) &&\n+        (_model == CPU_MODEL_AMPERE_1A || _model == CPU_MODEL_AMPERE_1B)) {\n+      FLAG_SET_DEFAULT(CodeEntryAlignment, 32);\n+    }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Ampere-1A和1B处理器使用默认的CodeEntryAlignment值，可能导致代码入口对齐不足，影响指令缓存效率和分支预测性能。优化后：为Ampere-1A和1B处理器设置CodeEntryAlignment为32字节，确保代码入口按32字节边界对齐。优化思路：针对特定CPU架构（Ampere-1A/1B）调整代码对齐参数，利用处理器微架构特性（如缓存行大小、分支预测器对齐要求）减少缓存未命中和分支预测失败，提升指令执行效率。"}
{"id": 534, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+代码重构", "optimization_description": "优化前：RISC-V汇编指令命名与标准RISC-V规范不一致（如rol/ror），且部分算术操作使用通用add/sub指令。优化后：1) 将rol/ror重命名为rolr/rorr以符合RISC-V规范；2) 将add/sub替换为更高效的addi/subi立即数指令；3) 统一栈操作模式（subi替代addi负值）。优化思路：通过标准化指令命名和选择更高效的立即数指令，提高代码可读性、维护性和执行效率，同时确保与RISC-V ISA规范对齐。", "original_code": "RISC-V汇编指令命名与标准RISC-V规范不一致（如rol/ror），且部分算术操作使用通用add/sub指令。", "optimized_code": "- INSN(rol,       0b0110011, 0b001, 0b0110000);\n- INSN(rolw,      0b0111011, 0b001, 0b0110000);\n- INSN(ror,       0b0110011, 0b101, 0b0110000);\n- INSN(rorw,      0b0111011, 0b101, 0b0110000);\n+ INSN(rolr,      0b0110011, 0b001, 0b0110000);\n+ INSN(rolrw,     0b0111011, 0b001, 0b0110000);\n+ INSN(rorr,      0b0110011, 0b101, 0b0110000);\n+ INSN(rorrw,     0b0111011, 0b101, 0b0110000);", "source_url": "https://github.com/openjdk/riscv-port/commit/8c87ea2bdf6e1aea5fdca4624d7b7fe590d33a37", "code_v0_no_empty_lines": "RISC-V汇编指令命名与标准RISC-V规范不一致（如rol/ror），且部分算术操作使用通用add/sub指令。", "code_v1_no_empty_lines": "- INSN(rol,       0b0110011, 0b001, 0b0110000);\n- INSN(rolw,      0b0111011, 0b001, 0b0110000);\n- INSN(ror,       0b0110011, 0b101, 0b0110000);\n- INSN(rorw,      0b0111011, 0b101, 0b0110000);\n+ INSN(rolr,      0b0110011, 0b001, 0b0110000);\n+ INSN(rolrw,     0b0111011, 0b001, 0b0110000);\n+ INSN(rorr,      0b0110011, 0b101, 0b0110000);\n+ INSN(rorrw,     0b0111011, 0b101, 0b0110000);", "target": "- INSN(rol,       0b0110011, 0b001, 0b0110000);\n- INSN(rolw,      0b0111011, 0b001, 0b0110000);\n- INSN(ror,       0b0110011, 0b101, 0b0110000);\n- INSN(rorw,      0b0111011, 0b101, 0b0110000);\n+ INSN(rolr,      0b0110011, 0b001, 0b0110000);\n+ INSN(rolrw,     0b0111011, 0b001, 0b0110000);\n+ INSN(rorr,      0b0110011, 0b101, 0b0110000);\n+ INSN(rorrw,     0b0111011, 0b101, 0b0110000);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V汇编指令命名与标准RISC-V规范不一致（如rol/ror），且部分算术操作使用通用add/sub指令。优化后：1) 将rol/ror重命名为rolr/rorr以符合RISC-V规范；2) 将add/sub替换为更高效的addi/subi立即数指令；3) 统一栈操作模式（subi替代addi负值）。优化思路：通过标准化指令命名和选择更高效的立即数指令，提高代码可读性、维护性和执行效率，同时确保与RISC-V ISA规范对齐。"}
{"id": 535, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：使用getResourceBytes()一次性读取整个资源到字节数组，然后通过Arrays.equals()比较，对于大资源会消耗大量内存。优化后：新增getResource()方法返回InputStream，实现compareStreams()方法进行流式比较，使用固定大小的缓冲区（1024字节）逐块读取比较。优化思路：避免一次性加载整个资源到内存，改为流式处理，显著降低内存峰值使用，提高内存效率。", "original_code": "使用getResourceBytes()一次性读取整个资源到字节数组，然后通过Arrays.equals()比较，对于大资源会消耗大量内存。", "optimized_code": "- boolean contentEquals = Arrays.equals(baseBytes, image.getResourceBytes(item));\n+ if (!compareStreams(base.getResource(item), image.getResource(item))) {\n+ private boolean compareStreams(InputStream is1, InputStream is2) {\n+     byte[] buf1 = new byte[1024];\n+     byte[] buf2 = new byte[1024];\n+     // 流式比较逻辑", "source_url": "https://github.com/openjdk/riscv-port/commit/f696d9c521fa13969cb81381dc8586bcdccf67d9", "code_v0_no_empty_lines": "使用getResourceBytes()一次性读取整个资源到字节数组，然后通过Arrays.equals()比较，对于大资源会消耗大量内存。", "code_v1_no_empty_lines": "- boolean contentEquals = Arrays.equals(baseBytes, image.getResourceBytes(item));\n+ if (!compareStreams(base.getResource(item), image.getResource(item))) {\n+ private boolean compareStreams(InputStream is1, InputStream is2) {\n+     byte[] buf1 = new byte[1024];\n+     byte[] buf2 = new byte[1024];\n+     // 流式比较逻辑", "target": "- boolean contentEquals = Arrays.equals(baseBytes, image.getResourceBytes(item));\n+ if (!compareStreams(base.getResource(item), image.getResource(item))) {\n+ private boolean compareStreams(InputStream is1, InputStream is2) {\n+     byte[] buf1 = new byte[1024];\n+     byte[] buf2 = new byte[1024];\n+     // 流式比较逻辑", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用getResourceBytes()一次性读取整个资源到字节数组，然后通过Arrays.equals()比较，对于大资源会消耗大量内存。优化后：新增getResource()方法返回InputStream，实现compareStreams()方法进行流式比较，使用固定大小的缓冲区（1024字节）逐块读取比较。优化思路：避免一次性加载整个资源到内存，改为流式处理，显著降低内存峰值使用，提高内存效率。"}
{"id": 536, "source": "riscv-dataset-excel", "optimization_type": "内联优化", "optimization_description": "优化前：increment_total_full_collections() 是一个独立的成员函数，每次调用都会产生函数调用开销。优化后：将函数体直接内联到调用处，避免了函数调用的开销。思路：通过内联小函数来减少函数调用开销，提高性能，特别是在频繁调用的代码路径中。", "original_code": "increment_total_full_collections() 是一个独立的成员函数，每次调用都会产生函数调用开销。", "optimized_code": "-      increment_total_full_collections();\n+      _total_full_collections++;\n-\n-  void increment_total_full_collections() { _total_full_collections++; }", "source_url": "https://github.com/openjdk/riscv-port/commit/98724219a87c1cdb1e7942ade1a4d49b201a0a94", "code_v0_no_empty_lines": "increment_total_full_collections() 是一个独立的成员函数，每次调用都会产生函数调用开销。", "code_v1_no_empty_lines": "-      increment_total_full_collections();\n+      _total_full_collections++;\n-\n-  void increment_total_full_collections() { _total_full_collections++; }", "target": "-      increment_total_full_collections();\n+      _total_full_collections++;\n-\n-  void increment_total_full_collections() { _total_full_collections++; }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：increment_total_full_collections() 是一个独立的成员函数，每次调用都会产生函数调用开销。优化后：将函数体直接内联到调用处，避免了函数调用的开销。思路：通过内联小函数来减少函数调用开销，提高性能，特别是在频繁调用的代码路径中。"}
{"id": 537, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化", "optimization_description": "性能提升：优化前使用computeIfAbsent方法在并发场景下存在锁竞争和额外函数调用开销。优化后采用get+putIfAbsent模式，先尝试无锁读取缓存，仅在缓存未命中时执行原子操作，减少了锁争用和函数调用开销，提高了ZoneOffset.ofTotalSeconds方法的并发性能。同样的优化模式也应用于DateTimeTextProvider和DecimalStyle类中的缓存访问。", "original_code": "// No original code extracted from description\n", "optimized_code": "- return SECONDS_CACHE.computeIfAbsent(totalSeconds, totalSecs -> {\n-     ZoneOffset result = new ZoneOffset(totalSecs);\n-     ID_CACHE.putIfAbsent(result.getId(), result);\n-     return result;\n- });\n+ Integer totalSecs = totalSeconds;\n+ ZoneOffset result = SECONDS_CACHE.get(totalSecs);\n+ if (result == null) {\n+     result = new ZoneOffset(totalSeconds);\n+     var existing = SECONDS_CACHE.putIfAbsent(totalSecs, result);\n+     if (existing != null) {\n+         result = existing;\n+     }\n+     ID_CACHE.putIfAbsent(result.getId(), result);\n+ }\n+ return result;", "source_url": "https://github.com/openjdk/riscv-port/commit/9a60f4457bb56d0f5039a97e6b943e62a8a2c3ee", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- return SECONDS_CACHE.computeIfAbsent(totalSeconds, totalSecs -> {\n-     ZoneOffset result = new ZoneOffset(totalSecs);\n-     ID_CACHE.putIfAbsent(result.getId(), result);\n-     return result;\n- });\n+ Integer totalSecs = totalSeconds;\n+ ZoneOffset result = SECONDS_CACHE.get(totalSecs);\n+ if (result == null) {\n+     result = new ZoneOffset(totalSeconds);\n+     var existing = SECONDS_CACHE.putIfAbsent(totalSecs, result);\n+     if (existing != null) {\n+         result = existing;\n+     }\n+     ID_CACHE.putIfAbsent(result.getId(), result);\n+ }\n+ return result;", "target": "- return SECONDS_CACHE.computeIfAbsent(totalSeconds, totalSecs -> {\n-     ZoneOffset result = new ZoneOffset(totalSecs);\n-     ID_CACHE.putIfAbsent(result.getId(), result);\n-     return result;\n- });\n+ Integer totalSecs = totalSeconds;\n+ ZoneOffset result = SECONDS_CACHE.get(totalSecs);\n+ if (result == null) {\n+     result = new ZoneOffset(totalSeconds);\n+     var existing = SECONDS_CACHE.putIfAbsent(totalSecs, result);\n+     if (existing != null) {\n+         result = existing;\n+     }\n+     ID_CACHE.putIfAbsent(result.getId(), result);\n+ }\n+ return result;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升：优化前使用computeIfAbsent方法在并发场景下存在锁竞争和额外函数调用开销。优化后采用get+putIfAbsent模式，先尝试无锁读取缓存，仅在缓存未命中时执行原子操作，减少了锁争用和函数调用开销，提高了ZoneOffset.ofTotalSeconds方法的并发性能。同样的优化模式也应用于DateTimeTextProvider和DecimalStyle类中的缓存访问。"}
{"id": 538, "source": "riscv-dataset-excel", "optimization_type": "NUMA性能优化", "optimization_description": "优化前：当CPU和内存节点不对齐时，NUMA策略可能导致性能下降，因为进程可能在不匹配的节点上运行。优化后：新增了mem_and_cpu_node_mismatch()检查，如果CPU和内存节点配置不匹配，则禁用NUMA支持，避免性能损失。思路：通过检测CPU和内存节点的对齐情况，在不对齐时禁用NUMA，防止因跨节点访问导致的性能问题。", "original_code": "当CPU和内存节点不对齐时，NUMA策略可能导致性能下降，因为进程可能在不匹配的节点上运行。", "optimized_code": "if (Linux::mem_and_cpu_node_mismatch()) {\n  disable_numa(\"The process memory and cpu node configuration does not match\");\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/62a4544bb76aa339a8129f81d2527405a1b1e7e3", "code_v0_no_empty_lines": "当CPU和内存节点不对齐时，NUMA策略可能导致性能下降，因为进程可能在不匹配的节点上运行。", "code_v1_no_empty_lines": "if (Linux::mem_and_cpu_node_mismatch()) {\n  disable_numa(\"The process memory and cpu node configuration does not match\");\n}", "target": "if (Linux::mem_and_cpu_node_mismatch()) {\n  disable_numa(\"The process memory and cpu node configuration does not match\");\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当CPU和内存节点不对齐时，NUMA策略可能导致性能下降，因为进程可能在不匹配的节点上运行。优化后：新增了mem_and_cpu_node_mismatch()检查，如果CPU和内存节点配置不匹配，则禁用NUMA支持，避免性能损失。思路：通过检测CPU和内存节点的对齐情况，在不对齐时禁用NUMA，防止因跨节点访问导致的性能问题。"}
{"id": 539, "source": "riscv-dataset-excel", "optimization_type": "构造函数优化+内存优化", "optimization_description": "优化前：vframeStreamCommon构造函数接受RegisterMap对象作为参数，调用者需要先构造RegisterMap临时对象，导致额外的对象构造和复制开销。优化后：构造函数改为直接接受RegisterMap的构造参数（JavaThread*和枚举值），在构造函数内部直接初始化_reg_map成员，避免了临时RegisterMap对象的构造和复制。优化思路：通过参数传递优化，将对象构造延迟到目标构造函数内部，减少中间临时对象的创建和复制操作，提升性能。", "original_code": "vframeStreamCommon构造函数接受RegisterMap对象作为参数，调用者需要先构造RegisterMap临时对象，导致额外的对象构造和复制开销。", "optimized_code": "inline vframeStreamCommon::vframeStreamCommon(JavaThread* thread,\n                                              RegisterMap::UpdateMap update_map,\n                                              RegisterMap::ProcessFrames process_frames,\n                                              RegisterMap::WalkContinuation walk_cont)\n        : _reg_map(thread, update_map, process_frames, walk_cont), _cont_entry(nullptr) {\n  _thread = _reg_map.thread();\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/4f44cf6bf2423a57a841be817f348e3b1e88f0eb", "code_v0_no_empty_lines": "vframeStreamCommon构造函数接受RegisterMap对象作为参数，调用者需要先构造RegisterMap临时对象，导致额外的对象构造和复制开销。", "code_v1_no_empty_lines": "inline vframeStreamCommon::vframeStreamCommon(JavaThread* thread,\n                                              RegisterMap::UpdateMap update_map,\n                                              RegisterMap::ProcessFrames process_frames,\n                                              RegisterMap::WalkContinuation walk_cont)\n        : _reg_map(thread, update_map, process_frames, walk_cont), _cont_entry(nullptr) {\n  _thread = _reg_map.thread();\n}", "target": "inline vframeStreamCommon::vframeStreamCommon(JavaThread* thread,\n                                              RegisterMap::UpdateMap update_map,\n                                              RegisterMap::ProcessFrames process_frames,\n                                              RegisterMap::WalkContinuation walk_cont)\n        : _reg_map(thread, update_map, process_frames, walk_cont), _cont_entry(nullptr) {\n  _thread = _reg_map.thread();\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：vframeStreamCommon构造函数接受RegisterMap对象作为参数，调用者需要先构造RegisterMap临时对象，导致额外的对象构造和复制开销。优化后：构造函数改为直接接受RegisterMap的构造参数（JavaThread*和枚举值），在构造函数内部直接初始化_reg_map成员，避免了临时RegisterMap对象的构造和复制。优化思路：通过参数传递优化，将对象构造延迟到目标构造函数内部，减少中间临时对象的创建和复制操作，提升性能。"}
{"id": 540, "source": "riscv-dataset-excel", "optimization_type": "指令优化+位运算优化", "optimization_description": "优化前：使用zero_extend/sign_extend宏和andi指令进行位掩码操作，可能产生多条指令序列。优化后：统一使用zext/sext宏（可能对应更高效的RISC-V指令如zext.w/sext.w），减少指令数量，提高位运算和类型转换性能。思路：针对RISC-V架构优化位掩码操作，利用架构特性简化代码并提升执行效率。", "original_code": "使用zero_extend/sign_extend宏和andi指令进行位掩码操作，可能产生多条指令序列。", "optimized_code": "- __ zero_extend(t1, t1, shift);\n+ __ zext(t1, t1, shift);\n- __ sign_extend(dest->as_register(), src->as_register(), 16);\n+ __ sext(dest->as_register(), src->as_register(), 16);\n- __ andi(tmp1, tmp1, 0xFF);\n+ __ zext(tmp1, tmp1, 8);", "source_url": "https://github.com/openjdk/riscv-port/commit/a7631ccf18e468d6ecba121865f7fed29cbf2186", "code_v0_no_empty_lines": "使用zero_extend/sign_extend宏和andi指令进行位掩码操作，可能产生多条指令序列。", "code_v1_no_empty_lines": "- __ zero_extend(t1, t1, shift);\n+ __ zext(t1, t1, shift);\n- __ sign_extend(dest->as_register(), src->as_register(), 16);\n+ __ sext(dest->as_register(), src->as_register(), 16);\n- __ andi(tmp1, tmp1, 0xFF);\n+ __ zext(tmp1, tmp1, 8);", "target": "- __ zero_extend(t1, t1, shift);\n+ __ zext(t1, t1, shift);\n- __ sign_extend(dest->as_register(), src->as_register(), 16);\n+ __ sext(dest->as_register(), src->as_register(), 16);\n- __ andi(tmp1, tmp1, 0xFF);\n+ __ zext(tmp1, tmp1, 8);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用zero_extend/sign_extend宏和andi指令进行位掩码操作，可能产生多条指令序列。优化后：统一使用zext/sext宏（可能对应更高效的RISC-V指令如zext.w/sext.w），减少指令数量，提高位运算和类型转换性能。思路：针对RISC-V架构优化位掩码操作，利用架构特性简化代码并提升执行效率。"}
{"id": 541, "source": "riscv-dataset-excel", "optimization_type": "向量寄存器优化", "optimization_description": "优化前：string_compress和string_inflate函数中的向量指令被#if 0预处理器指令完全禁用，导致无法利用s390x平台的向量处理能力。优化后：1. 移除#if 0/#endif预处理器指令，启用向量化代码路径；2. 修改函数签名，将向量寄存器作为参数传入（Vtmp1、Vtmp2、Vmask等），而不是在函数内部硬编码分配（如Z_V16-Z_V23）；3. 更新向量指令操作数，使用传入的寄存器参数。优化思路：通过参数化向量寄存器，允许调用者根据寄存器分配策略传递可用寄存器，避免寄存器冲突，同时启用向量化实现以提升字符串压缩/扩展操作的性能。", "original_code": "string_compress和string_inflate函数中的向量指令被#if 0预处理器指令完全禁用，导致无法利用s390x平台的向量处理能力。", "optimized_code": "-#if 0\n   if (VM_Version::has_VectorFacility()) {\n     const int  min_vcnt     = 32;\n     const int  log_min_vcnt = exact_log2(min_vcnt);\n     Label      VectorLoop, VectorDone, VectorBreak;\n-\n-    VectorRegister Vtmp1      = Z_V16;\n-    VectorRegister Vtmp2      = Z_V17;\n-    VectorRegister Vmask      = Z_V18;\n-    VectorRegister Vzero      = Z_V19;\n-    VectorRegister Vsrc_first = Z_V20;\n-    VectorRegister Vsrc_last  = Z_V23;\n+\n     assert((Vsrc_last->encoding() - Vsrc_first->encoding() + 1) == min_vcnt/8, \"logic error\");\n     assert(VM_Version::has_DistinctOpnds(), \"Assumption when has_VectorFacility()\");\n     z_srak(Rix, Rcnt, log_min_vcnt);\n@@ -199,8 +190,8 @@ unsigned int C2_MacroAssembler::string_compress(Register result, Register src, R\n       add2reg(Rsrc, min_vcnt*2);\n \n       //---<  check for incompatible character  >---\n-      z_vo(Vtmp1, Z_V20, Z_V21);\n-      z_vo(Vtmp2, Z_V22, Z_V23);\n+      z_vo(Vtmp1, Vsrc_first, v21);\n+      z_vo(Vtmp2, v22, Vsrc_last);\n       z_vo(Vtmp1, Vtmp1, Vtmp2);\n       z_vn(Vtmp1, Vtmp1, Vmask);\n       z_vceqhs(Vtmp1, Vtmp1, Vzero);\n@@ -208,8 +199,8 @@ unsigned int C2_MacroAssembler::string_compress(Register result, Register src, R\n                                            // re-process data from current iteration in break handler.\n \n       //---<  pack & store characters  >---\n-      z_vpkh(Vtmp1, Z_V20, Z_V21);\n-      z_vpkh(Vtmp2, Z_V22, Z_V23);\n+      z_vpkh(Vtmp1, Vsrc_first, v21);\n+      z_vpkh(Vtmp2, v22, Vsrc_last);\n       z_vstm(Vtmp1, Vtmp2, 0, Rdst);\n       add2reg(Rdst, min_vcnt);\n \n@@ -224,7 +215,6 @@ unsigned int C2_MacroAssembler::string_compress(Register result, Register src, R\n \n     bind(VectorDone);\n   }\n-#endif", "source_url": "https://github.com/openjdk/riscv-port/commit/cb92595599a8a22a807a29bf56f1e02e792386a9", "code_v0_no_empty_lines": "string_compress和string_inflate函数中的向量指令被#if 0预处理器指令完全禁用，导致无法利用s390x平台的向量处理能力。", "code_v1_no_empty_lines": "-#if 0\n   if (VM_Version::has_VectorFacility()) {\n     const int  min_vcnt     = 32;\n     const int  log_min_vcnt = exact_log2(min_vcnt);\n     Label      VectorLoop, VectorDone, VectorBreak;\n-\n-    VectorRegister Vtmp1      = Z_V16;\n-    VectorRegister Vtmp2      = Z_V17;\n-    VectorRegister Vmask      = Z_V18;\n-    VectorRegister Vzero      = Z_V19;\n-    VectorRegister Vsrc_first = Z_V20;\n-    VectorRegister Vsrc_last  = Z_V23;\n+\n     assert((Vsrc_last->encoding() - Vsrc_first->encoding() + 1) == min_vcnt/8, \"logic error\");\n     assert(VM_Version::has_DistinctOpnds(), \"Assumption when has_VectorFacility()\");\n     z_srak(Rix, Rcnt, log_min_vcnt);\n@@ -199,8 +190,8 @@ unsigned int C2_MacroAssembler::string_compress(Register result, Register src, R\n       add2reg(Rsrc, min_vcnt*2);\n \n       //---<  check for incompatible character  >---\n-      z_vo(Vtmp1, Z_V20, Z_V21);\n-      z_vo(Vtmp2, Z_V22, Z_V23);\n+      z_vo(Vtmp1, Vsrc_first, v21);\n+      z_vo(Vtmp2, v22, Vsrc_last);\n       z_vo(Vtmp1, Vtmp1, Vtmp2);\n       z_vn(Vtmp1, Vtmp1, Vmask);\n       z_vceqhs(Vtmp1, Vtmp1, Vzero);\n@@ -208,8 +199,8 @@ unsigned int C2_MacroAssembler::string_compress(Register result, Register src, R\n                                            // re-process data from current iteration in break handler.\n \n       //---<  pack & store characters  >---\n-      z_vpkh(Vtmp1, Z_V20, Z_V21);\n-      z_vpkh(Vtmp2, Z_V22, Z_V23);\n+      z_vpkh(Vtmp1, Vsrc_first, v21);\n+      z_vpkh(Vtmp2, v22, Vsrc_last);\n       z_vstm(Vtmp1, Vtmp2, 0, Rdst);\n       add2reg(Rdst, min_vcnt);\n \n@@ -224,7 +215,6 @@ unsigned int C2_MacroAssembler::string_compress(Register result, Register src, R\n \n     bind(VectorDone);\n   }\n-#endif", "target": "-#if 0\n   if (VM_Version::has_VectorFacility()) {\n     const int  min_vcnt     = 32;\n     const int  log_min_vcnt = exact_log2(min_vcnt);\n     Label      VectorLoop, VectorDone, VectorBreak;\n-\n-    VectorRegister Vtmp1      = Z_V16;\n-    VectorRegister Vtmp2      = Z_V17;\n-    VectorRegister Vmask      = Z_V18;\n-    VectorRegister Vzero      = Z_V19;\n-    VectorRegister Vsrc_first = Z_V20;\n-    VectorRegister Vsrc_last  = Z_V23;\n+\n     assert((Vsrc_last->encoding() - Vsrc_first->encoding() + 1) == min_vcnt/8, \"logic error\");\n     assert(VM_Version::has_DistinctOpnds(), \"Assumption when has_VectorFacility()\");\n     z_srak(Rix, Rcnt, log_min_vcnt);\n@@ -199,8 +190,8 @@ unsigned int C2_MacroAssembler::string_compress(Register result, Register src, R\n       add2reg(Rsrc, min_vcnt*2);\n \n       //---<  check for incompatible character  >---\n-      z_vo(Vtmp1, Z_V20, Z_V21);\n-      z_vo(Vtmp2, Z_V22, Z_V23);\n+      z_vo(Vtmp1, Vsrc_first, v21);\n+      z_vo(Vtmp2, v22, Vsrc_last);\n       z_vo(Vtmp1, Vtmp1, Vtmp2);\n       z_vn(Vtmp1, Vtmp1, Vmask);\n       z_vceqhs(Vtmp1, Vtmp1, Vzero);\n@@ -208,8 +199,8 @@ unsigned int C2_MacroAssembler::string_compress(Register result, Register src, R\n                                            // re-process data from current iteration in break handler.\n \n       //---<  pack & store characters  >---\n-      z_vpkh(Vtmp1, Z_V20, Z_V21);\n-      z_vpkh(Vtmp2, Z_V22, Z_V23);\n+      z_vpkh(Vtmp1, Vsrc_first, v21);\n+      z_vpkh(Vtmp2, v22, Vsrc_last);\n       z_vstm(Vtmp1, Vtmp2, 0, Rdst);\n       add2reg(Rdst, min_vcnt);\n \n@@ -224,7 +215,6 @@ unsigned int C2_MacroAssembler::string_compress(Register result, Register src, R\n \n     bind(VectorDone);\n   }\n-#endif", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：string_compress和string_inflate函数中的向量指令被#if 0预处理器指令完全禁用，导致无法利用s390x平台的向量处理能力。优化后：1. 移除#if 0/#endif预处理器指令，启用向量化代码路径；2. 修改函数签名，将向量寄存器作为参数传入（Vtmp1、Vtmp2、Vmask等），而不是在函数内部硬编码分配（如Z_V16-Z_V23）；3. 更新向量指令操作数，使用传入的寄存器参数。优化思路：通过参数化向量寄存器，允许调用者根据寄存器分配策略传递可用寄存器，避免寄存器冲突，同时启用向量化实现以提升字符串压缩/扩展操作的性能。"}
{"id": 542, "source": "riscv-dataset-excel", "optimization_type": "内存配置优化", "optimization_description": "优化前：OldSize初始化为0，当未设置InitialHeapSize或MinHeapSize时，可能导致内存配置计算异常或不稳定。优化后：将OldSize默认值设为4MB（经过ScaleForWordSize调整），为并行GC提供更合理的默认内存配置，确保与UseLargePages和UseNUMA选项兼容。优化思路：提供合理的默认值以避免配置缺失时的潜在问题，提升GC内存管理的稳定性和兼容性。", "original_code": "OldSize初始化为0，当未设置InitialHeapSize或MinHeapSize时，可能导致内存配置计算异常或不稳定。", "optimized_code": "-size_t OldSize = 0;\n+// If InitialHeapSize or MinHeapSize is not set on cmdline, this variable,\n+// together with NewSize, is used to derive them.\n+// Using the same value when it was a configurable flag to avoid breakage.\n+// See more in JDK-8346005\n+size_t OldSize = ScaleForWordSize(4*M);", "source_url": "https://github.com/openjdk/riscv-port/commit/a9a5f7cb0a75b82d613ecd9018e13e5337e90363", "code_v0_no_empty_lines": "OldSize初始化为0，当未设置InitialHeapSize或MinHeapSize时，可能导致内存配置计算异常或不稳定。", "code_v1_no_empty_lines": "-size_t OldSize = 0;\n+// If InitialHeapSize or MinHeapSize is not set on cmdline, this variable,\n+// together with NewSize, is used to derive them.\n+// Using the same value when it was a configurable flag to avoid breakage.\n+// See more in JDK-8346005\n+size_t OldSize = ScaleForWordSize(4*M);", "target": "-size_t OldSize = 0;\n+// If InitialHeapSize or MinHeapSize is not set on cmdline, this variable,\n+// together with NewSize, is used to derive them.\n+// Using the same value when it was a configurable flag to avoid breakage.\n+// See more in JDK-8346005\n+size_t OldSize = ScaleForWordSize(4*M);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：OldSize初始化为0，当未设置InitialHeapSize或MinHeapSize时，可能导致内存配置计算异常或不稳定。优化后：将OldSize默认值设为4MB（经过ScaleForWordSize调整），为并行GC提供更合理的默认内存配置，确保与UseLargePages和UseNUMA选项兼容。优化思路：提供合理的默认值以避免配置缺失时的潜在问题，提升GC内存管理的稳定性和兼容性。"}
{"id": 543, "source": "riscv-dataset-excel", "optimization_type": "并行化优化", "optimization_description": "优化前：并发清理阶段（op_cleanup_early和op_cleanup_complete）的垃圾回收操作是单线程执行的，通过free_set()->recycle_trash()串行处理所有垃圾区域，存在性能瓶颈。优化后：引入并行化机制，通过ShenandoahWorkerScope创建多线程工作域，使用parallel_heap_region_iterate并行遍历和回收垃圾区域，显著提升了并发清理阶段的执行效率。优化思路：将原本串行的垃圾区域回收操作改为并行执行，充分利用多核CPU资源，减少GC暂停时间。", "original_code": "并发清理阶段（op_cleanup_early和op_cleanup_complete）的垃圾回收操作是单线程执行的，通过free_set()->recycle_trash()串行处理所有垃圾区域，存在性能瓶颈。", "optimized_code": "-  ShenandoahHeap::heap()->free_set()->recycle_trash();\n+  ShenandoahWorkerScope scope(ShenandoahHeap::heap()->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_cleanup(),\n+                              \"cleanup early.\");\n+  ShenandoahHeap::heap()->recycle_trash();", "source_url": "https://github.com/openjdk/riscv-port/commit/4da6fd4283a13be1711e7ad948f1d05a0a9148a5", "code_v0_no_empty_lines": "并发清理阶段（op_cleanup_early和op_cleanup_complete）的垃圾回收操作是单线程执行的，通过free_set()->recycle_trash()串行处理所有垃圾区域，存在性能瓶颈。", "code_v1_no_empty_lines": "-  ShenandoahHeap::heap()->free_set()->recycle_trash();\n+  ShenandoahWorkerScope scope(ShenandoahHeap::heap()->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_cleanup(),\n+                              \"cleanup early.\");\n+  ShenandoahHeap::heap()->recycle_trash();", "target": "-  ShenandoahHeap::heap()->free_set()->recycle_trash();\n+  ShenandoahWorkerScope scope(ShenandoahHeap::heap()->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_cleanup(),\n+                              \"cleanup early.\");\n+  ShenandoahHeap::heap()->recycle_trash();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：并发清理阶段（op_cleanup_early和op_cleanup_complete）的垃圾回收操作是单线程执行的，通过free_set()->recycle_trash()串行处理所有垃圾区域，存在性能瓶颈。优化后：引入并行化机制，通过ShenandoahWorkerScope创建多线程工作域，使用parallel_heap_region_iterate并行遍历和回收垃圾区域，显著提升了并发清理阶段的执行效率。优化思路：将原本串行的垃圾区域回收操作改为并行执行，充分利用多核CPU资源，减少GC暂停时间。"}
{"id": 544, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化+内存优化", "optimization_description": "优化前：使用线程安全的Hashtable存储静态映射，通过静态初始化块填充，name2type方法需要手动处理null值。优化后：改用不可变的Map.of()创建静态final映射，使用getOrDefault简化null检查。优化思路：1) 用更现代的不可变Map替代过时的Hashtable，减少同步开销；2) 简化初始化代码；3) 使用getOrDefault避免显式null检查，提高代码简洁性和性能。", "original_code": "使用线程安全的Hashtable存储静态映射，通过静态初始化块填充，name2type方法需要手动处理null值。", "optimized_code": "- static Hashtable<String, Integer> contentTypes = new Hashtable<String, Integer>();\n- static {\n-     contentTypes.put(\"CDATA\", Integer.valueOf(CDATA));\n-     contentTypes.put(\"RCDATA\", Integer.valueOf(RCDATA));\n-     contentTypes.put(\"EMPTY\", Integer.valueOf(EMPTY));\n-     contentTypes.put(\"ANY\", Integer.valueOf(ANY));\n- }\n+ private static final Map<String, Integer> contentTypes = Map.of(\n+         \"CDATA\", CDATA,\n+         \"RCDATA\", RCDATA,\n+         \"EMPTY\", EMPTY,\n+         \"ANY\", ANY\n+ );", "source_url": "https://github.com/openjdk/riscv-port/commit/e4a34e96cd7eb227bd43e55d370d0b18d365ae1b", "code_v0_no_empty_lines": "使用线程安全的Hashtable存储静态映射，通过静态初始化块填充，name2type方法需要手动处理null值。", "code_v1_no_empty_lines": "- static Hashtable<String, Integer> contentTypes = new Hashtable<String, Integer>();\n- static {\n-     contentTypes.put(\"CDATA\", Integer.valueOf(CDATA));\n-     contentTypes.put(\"RCDATA\", Integer.valueOf(RCDATA));\n-     contentTypes.put(\"EMPTY\", Integer.valueOf(EMPTY));\n-     contentTypes.put(\"ANY\", Integer.valueOf(ANY));\n- }\n+ private static final Map<String, Integer> contentTypes = Map.of(\n+         \"CDATA\", CDATA,\n+         \"RCDATA\", RCDATA,\n+         \"EMPTY\", EMPTY,\n+         \"ANY\", ANY\n+ );", "target": "- static Hashtable<String, Integer> contentTypes = new Hashtable<String, Integer>();\n- static {\n-     contentTypes.put(\"CDATA\", Integer.valueOf(CDATA));\n-     contentTypes.put(\"RCDATA\", Integer.valueOf(RCDATA));\n-     contentTypes.put(\"EMPTY\", Integer.valueOf(EMPTY));\n-     contentTypes.put(\"ANY\", Integer.valueOf(ANY));\n- }\n+ private static final Map<String, Integer> contentTypes = Map.of(\n+         \"CDATA\", CDATA,\n+         \"RCDATA\", RCDATA,\n+         \"EMPTY\", EMPTY,\n+         \"ANY\", ANY\n+ );", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用线程安全的Hashtable存储静态映射，通过静态初始化块填充，name2type方法需要手动处理null值。优化后：改用不可变的Map.of()创建静态final映射，使用getOrDefault简化null检查。优化思路：1) 用更现代的不可变Map替代过时的Hashtable，减少同步开销；2) 简化初始化代码；3) 使用getOrDefault避免显式null检查，提高代码简洁性和性能。"}
{"id": 545, "source": "riscv-dataset-excel", "optimization_type": "算术优化+代码优化", "optimization_description": "优化前：无符号除法和取模运算（UDivI/L, UModI/L）缺少针对除数为2的幂次方的优化，且与有符号运算的逻辑不统一。优化后：1. 添加了模板函数 unsigned_div_ideal 和 unsigned_mod_ideal，当除数为2的幂次方时，将除法转换为右移运算，将取模转换为与运算，减少计算开销。2. 统一了无符号与有符号运算的共享逻辑，减少代码重复。思路：通过常量折叠和位运算优化，提升算术运算性能，同时重构代码以提高可维护性。", "original_code": "无符号除法和取模运算（UDivI/L, UModI/L）缺少针对除数为2的幂次方的优化，且与有符号运算的逻辑不统一。", "optimized_code": "template <typename TypeClass, typename Unsigned>\nNode* unsigned_div_ideal(PhaseGVN* phase, bool can_reshape, Node* div) {\n  // ...\n  if (is_power_of_2(divisor)) {\n    return make_urshift<TypeClass>(div->in(1), phase->intcon(log2i_graceful(divisor)));\n  }\n  // ...\n}\n\nNode *UDivINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n  return unsigned_div_ideal<TypeInt, juint>(phase, can_reshape, this);\n}\n\nNode *UDivLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n  return unsigned_div_ideal<TypeLong, julong>(phase, can_reshape, this);\n}\n\n// 类似地添加了 unsigned_mod_ideal 和 unsigned_mod_value 模板函数", "source_url": "https://github.com/openjdk/riscv-port/commit/d381d581bfc5bbe1db966088ed4cad01b65c5123", "code_v0_no_empty_lines": "无符号除法和取模运算（UDivI/L, UModI/L）缺少针对除数为2的幂次方的优化，且与有符号运算的逻辑不统一。", "code_v1_no_empty_lines": "template <typename TypeClass, typename Unsigned>\nNode* unsigned_div_ideal(PhaseGVN* phase, bool can_reshape, Node* div) {\n  // ...\n  if (is_power_of_2(divisor)) {\n    return make_urshift<TypeClass>(div->in(1), phase->intcon(log2i_graceful(divisor)));\n  }\n  // ...\n}\n\nNode *UDivINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n  return unsigned_div_ideal<TypeInt, juint>(phase, can_reshape, this);\n}\n\nNode *UDivLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n  return unsigned_div_ideal<TypeLong, julong>(phase, can_reshape, this);\n}\n\n// 类似地添加了 unsigned_mod_ideal 和 unsigned_mod_value 模板函数", "target": "template <typename TypeClass, typename Unsigned>\nNode* unsigned_div_ideal(PhaseGVN* phase, bool can_reshape, Node* div) {\n  // ...\n  if (is_power_of_2(divisor)) {\n    return make_urshift<TypeClass>(div->in(1), phase->intcon(log2i_graceful(divisor)));\n  }\n  // ...\n}\n\nNode *UDivINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n  return unsigned_div_ideal<TypeInt, juint>(phase, can_reshape, this);\n}\n\nNode *UDivLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n  return unsigned_div_ideal<TypeLong, julong>(phase, can_reshape, this);\n}\n\n// 类似地添加了 unsigned_mod_ideal 和 unsigned_mod_value 模板函数", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：无符号除法和取模运算（UDivI/L, UModI/L）缺少针对除数为2的幂次方的优化，且与有符号运算的逻辑不统一。优化后：1. 添加了模板函数 unsigned_div_ideal 和 unsigned_mod_ideal，当除数为2的幂次方时，将除法转换为右移运算，将取模转换为与运算，减少计算开销。2. 统一了无符号与有符号运算的共享逻辑，减少代码重复。思路：通过常量折叠和位运算优化，提升算术运算性能，同时重构代码以提高可维护性。"}
{"id": 546, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（常量折叠+代数化简）", "optimization_description": "优化前：Max/Min节点在编译期间无法识别某些常量边界情况，导致生成冗余的运行时比较操作。优化后：为MaxINode/MinINode添加Identity方法，通过静态类型分析（t1->_lo >= t2->_hi等）在编译时确定最大值/最小值，直接返回对应输入节点；同时扩展MaxNode::Identity以处理嵌套的Max/Min表达式（如Max(A, Max(A, B))）。优化思路：利用编译时的类型范围信息进行常量折叠和代数化简，消除不必要的运行时计算，减少生成的机器指令数量。", "original_code": "Max/Min节点在编译期间无法识别某些常量边界情况，导致生成冗余的运行时比较操作。", "optimized_code": "Node* MaxINode::Identity(PhaseGVN* phase) {\n  const TypeInt* t1 = phase->type(in(1))->is_int();\n  const TypeInt* t2 = phase->type(in(2))->is_int();\n\n  // Can we determine the maximum statically?\n  if (t1->_lo >= t2->_hi) {\n    return in(1);\n  } else if (t2->_lo >= t1->_hi) {\n    return in(2);\n  }\n\n  return MaxNode::Identity(phase);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/29d648c642a68699340a9ab43252f832efdb5cbf", "code_v0_no_empty_lines": "Max/Min节点在编译期间无法识别某些常量边界情况，导致生成冗余的运行时比较操作。", "code_v1_no_empty_lines": "Node* MaxINode::Identity(PhaseGVN* phase) {\n  const TypeInt* t1 = phase->type(in(1))->is_int();\n  const TypeInt* t2 = phase->type(in(2))->is_int();\n\n  // Can we determine the maximum statically?\n  if (t1->_lo >= t2->_hi) {\n    return in(1);\n  } else if (t2->_lo >= t1->_hi) {\n    return in(2);\n  }\n\n  return MaxNode::Identity(phase);\n}", "target": "Node* MaxINode::Identity(PhaseGVN* phase) {\n  const TypeInt* t1 = phase->type(in(1))->is_int();\n  const TypeInt* t2 = phase->type(in(2))->is_int();\n\n  // Can we determine the maximum statically?\n  if (t1->_lo >= t2->_hi) {\n    return in(1);\n  } else if (t2->_lo >= t1->_hi) {\n    return in(2);\n  }\n\n  return MaxNode::Identity(phase);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Max/Min节点在编译期间无法识别某些常量边界情况，导致生成冗余的运行时比较操作。优化后：为MaxINode/MinINode添加Identity方法，通过静态类型分析（t1->_lo >= t2->_hi等）在编译时确定最大值/最小值，直接返回对应输入节点；同时扩展MaxNode::Identity以处理嵌套的Max/Min表达式（如Max(A, Max(A, B))）。优化思路：利用编译时的类型范围信息进行常量折叠和代数化简，消除不必要的运行时计算，减少生成的机器指令数量。"}
{"id": 547, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+性能优化", "optimization_description": "优化前：RISC-V平台缺少CRC32计算的硬件加速支持，依赖软件实现效率较低。优化后：新增对Zvbc扩展指令集的支持，实现CRC32计算的硬件加速。通过使用vclmul（无进位乘法）等向量指令，在向量寄存器中批量处理数据，显著提升CRC32计算性能。优化思路：利用RISC-V向量扩展指令实现CRC32计算的硬件加速，通过向量化处理和专用指令减少计算周期。", "original_code": "RISC-V平台缺少CRC32计算的硬件加速支持，依赖软件实现效率较低。", "optimized_code": "+  product(bool, UseZvbc, false, EXPERIMENTAL, \"Use Zvbc instructions\")           \\\n+void MacroAssembler::crc32_vclmul_fold_16_bytes_vectorsize_16(VectorRegister vx, VectorRegister vt,\n+                      VectorRegister vtmp1, VectorRegister vtmp2, VectorRegister vtmp3, VectorRegister vtmp4,\n+                      Register buf, Register tmp, const int STEP) {\n+  assert_different_registers(vx, vt, vtmp1, vtmp2, vtmp3, vtmp4);\n+  vclmul_vv(vtmp1, vx, vt);\n+  vclmulh_vv(vtmp2, vx, vt);\n+  vle64_v(vtmp4, buf); addi(buf, buf, STEP);\n+  // low parts\n+  vredxor_vs(vtmp3, vtmp1, vtmp4);\n+  // high parts\n+  vslidedown_vi(vx, vtmp4, 1);\n+  vredxor_vs(vtmp1, vtmp2, vx);\n+  // merge low and high back\n+  vslideup_vi(vx, vtmp1, 1);\n+  vmv_x_s(tmp, vtmp3);\n+  vmv_s_x(vx, tmp);\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/c517ffba7d9388e75b5d7bba77e565e71c0a7d76", "code_v0_no_empty_lines": "RISC-V平台缺少CRC32计算的硬件加速支持，依赖软件实现效率较低。", "code_v1_no_empty_lines": "+  product(bool, UseZvbc, false, EXPERIMENTAL, \"Use Zvbc instructions\")           \\\n+void MacroAssembler::crc32_vclmul_fold_16_bytes_vectorsize_16(VectorRegister vx, VectorRegister vt,\n+                      VectorRegister vtmp1, VectorRegister vtmp2, VectorRegister vtmp3, VectorRegister vtmp4,\n+                      Register buf, Register tmp, const int STEP) {\n+  assert_different_registers(vx, vt, vtmp1, vtmp2, vtmp3, vtmp4);\n+  vclmul_vv(vtmp1, vx, vt);\n+  vclmulh_vv(vtmp2, vx, vt);\n+  vle64_v(vtmp4, buf); addi(buf, buf, STEP);\n+  // low parts\n+  vredxor_vs(vtmp3, vtmp1, vtmp4);\n+  // high parts\n+  vslidedown_vi(vx, vtmp4, 1);\n+  vredxor_vs(vtmp1, vtmp2, vx);\n+  // merge low and high back\n+  vslideup_vi(vx, vtmp1, 1);\n+  vmv_x_s(tmp, vtmp3);\n+  vmv_s_x(vx, tmp);\n+}", "target": "+  product(bool, UseZvbc, false, EXPERIMENTAL, \"Use Zvbc instructions\")           \\\n+void MacroAssembler::crc32_vclmul_fold_16_bytes_vectorsize_16(VectorRegister vx, VectorRegister vt,\n+                      VectorRegister vtmp1, VectorRegister vtmp2, VectorRegister vtmp3, VectorRegister vtmp4,\n+                      Register buf, Register tmp, const int STEP) {\n+  assert_different_registers(vx, vt, vtmp1, vtmp2, vtmp3, vtmp4);\n+  vclmul_vv(vtmp1, vx, vt);\n+  vclmulh_vv(vtmp2, vx, vt);\n+  vle64_v(vtmp4, buf); addi(buf, buf, STEP);\n+  // low parts\n+  vredxor_vs(vtmp3, vtmp1, vtmp4);\n+  // high parts\n+  vslidedown_vi(vx, vtmp4, 1);\n+  vredxor_vs(vtmp1, vtmp2, vx);\n+  // merge low and high back\n+  vslideup_vi(vx, vtmp1, 1);\n+  vmv_x_s(tmp, vtmp3);\n+  vmv_s_x(vx, tmp);\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V平台缺少CRC32计算的硬件加速支持，依赖软件实现效率较低。优化后：新增对Zvbc扩展指令集的支持，实现CRC32计算的硬件加速。通过使用vclmul（无进位乘法）等向量指令，在向量寄存器中批量处理数据，显著提升CRC32计算性能。优化思路：利用RISC-V向量扩展指令实现CRC32计算的硬件加速，通过向量化处理和专用指令减少计算周期。"}
{"id": 548, "source": "riscv-dataset-excel", "optimization_type": "内存泄漏修复", "optimization_description": "优化前：当st.as_string()返回空字符串时，代码会先分配内存给result，然后检查result是否为空字符串，若非空则返回result指针，否则返回nullptr。这导致在空字符串情况下，分配的result内存未被释放，造成内存泄漏。优化后：先检查st.size()是否大于0，仅在非空时调用os::strdup分配内存并返回指针，否则直接返回nullptr。优化思路：避免不必要的内存分配，直接根据条件决定是否分配内存，从而修复ASAN检测到的内存泄漏问题。", "original_code": "当st.as_string()返回空字符串时，代码会先分配内存给result，然后检查result是否为空字符串，若非空则返回result指针，否则返回nullptr。这导致在空字符串情况下，分配的result内存未被释放，造成内存泄漏。", "optimized_code": "-  const char* result = (const char*)os::strdup(st.as_string()); // Example: \"java.base,java.compiler\"\n-  return strcmp(result, \"\") != 0 ? result : nullptr;\n+  return (st.size() > 0) ? os::strdup(st.as_string()) : nullptr;  // Example: \"java.base,java.compiler\"", "source_url": "https://github.com/openjdk/riscv-port/commit/69e664de14d1f9d66447937d494da8bf971ac5fe", "code_v0_no_empty_lines": "当st.as_string()返回空字符串时，代码会先分配内存给result，然后检查result是否为空字符串，若非空则返回result指针，否则返回nullptr。这导致在空字符串情况下，分配的result内存未被释放，造成内存泄漏。", "code_v1_no_empty_lines": "-  const char* result = (const char*)os::strdup(st.as_string()); // Example: \"java.base,java.compiler\"\n-  return strcmp(result, \"\") != 0 ? result : nullptr;\n+  return (st.size() > 0) ? os::strdup(st.as_string()) : nullptr;  // Example: \"java.base,java.compiler\"", "target": "-  const char* result = (const char*)os::strdup(st.as_string()); // Example: \"java.base,java.compiler\"\n-  return strcmp(result, \"\") != 0 ? result : nullptr;\n+  return (st.size() > 0) ? os::strdup(st.as_string()) : nullptr;  // Example: \"java.base,java.compiler\"", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当st.as_string()返回空字符串时，代码会先分配内存给result，然后检查result是否为空字符串，若非空则返回result指针，否则返回nullptr。这导致在空字符串情况下，分配的result内存未被释放，造成内存泄漏。优化后：先检查st.size()是否大于0，仅在非空时调用os::strdup分配内存并返回指针，否则直接返回nullptr。优化思路：避免不必要的内存分配，直接根据条件决定是否分配内存，从而修复ASAN检测到的内存泄漏问题。"}
{"id": 549, "source": "riscv-dataset-excel", "optimization_type": "内存分配优化", "optimization_description": "优化前：Windows x86-64平台下final stubs的代码缓冲区大小分配不足（WINDOWS_ONLY(+2000)），导致生成最终存根时出现CodeBuffer空间不足错误。优化后：将Windows平台的final stubs代码缓冲区大小从2000增加到22000（WINDOWS_ONLY(+22000)），确保有足够空间容纳所有生成的代码。优化思路：根据实际代码生成需求调整预分配的内存空间，避免运行时因缓冲区不足导致的分配失败和性能问题。", "original_code": "Windows x86-64平台下final stubs的代码缓冲区大小分配不足（WINDOWS_ONLY(+2000)），导致生成最终存根时出现CodeBuffer空间不足错误。", "optimized_code": "-  _final_stubs_code_size        = 10000 LP64_ONLY(+20000) WINDOWS_ONLY(+2000) ZGC_ONLY(+20000)\n+  _final_stubs_code_size        = 10000 LP64_ONLY(+20000) WINDOWS_ONLY(+22000) ZGC_ONLY(+20000)", "source_url": "https://github.com/openjdk/riscv-port/commit/830173fcb08b004ea3932d47cb522c589feec0b5", "code_v0_no_empty_lines": "Windows x86-64平台下final stubs的代码缓冲区大小分配不足（WINDOWS_ONLY(+2000)），导致生成最终存根时出现CodeBuffer空间不足错误。", "code_v1_no_empty_lines": "-  _final_stubs_code_size        = 10000 LP64_ONLY(+20000) WINDOWS_ONLY(+2000) ZGC_ONLY(+20000)\n+  _final_stubs_code_size        = 10000 LP64_ONLY(+20000) WINDOWS_ONLY(+22000) ZGC_ONLY(+20000)", "target": "-  _final_stubs_code_size        = 10000 LP64_ONLY(+20000) WINDOWS_ONLY(+2000) ZGC_ONLY(+20000)\n+  _final_stubs_code_size        = 10000 LP64_ONLY(+20000) WINDOWS_ONLY(+22000) ZGC_ONLY(+20000)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Windows x86-64平台下final stubs的代码缓冲区大小分配不足（WINDOWS_ONLY(+2000)），导致生成最终存根时出现CodeBuffer空间不足错误。优化后：将Windows平台的final stubs代码缓冲区大小从2000增加到22000（WINDOWS_ONLY(+22000)），确保有足够空间容纳所有生成的代码。优化思路：根据实际代码生成需求调整预分配的内存空间，避免运行时因缓冲区不足导致的分配失败和性能问题。"}
{"id": 550, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：使用>=比较，当numComponents等于数组长度时触发数组扩容，导致不必要的数组分配和复制。优化后：使用>比较，仅在numComponents严格大于数组长度时才扩容，避免了不必要的数组分配和复制操作。思路：通过修改边界条件判断，减少内存分配和复制开销，提升性能。", "original_code": "使用>=比较，当numComponents等于数组长度时触发数组扩容，导致不必要的数组分配和复制。", "optimized_code": "-                if (numComponents >= components.length) {\n+                if (numComponents > components.length) {\n-                    if (numComponents >= tempComponents.length) {\n+                    if (numComponents > tempComponents.length) {", "source_url": "https://github.com/openjdk/riscv-port/commit/f6021a9c34da877bf954f5b90b4233949ec0ffc7", "code_v0_no_empty_lines": "使用>=比较，当numComponents等于数组长度时触发数组扩容，导致不必要的数组分配和复制。", "code_v1_no_empty_lines": "-                if (numComponents >= components.length) {\n+                if (numComponents > components.length) {\n-                    if (numComponents >= tempComponents.length) {\n+                    if (numComponents > tempComponents.length) {", "target": "-                if (numComponents >= components.length) {\n+                if (numComponents > components.length) {\n-                    if (numComponents >= tempComponents.length) {\n+                    if (numComponents > tempComponents.length) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用>=比较，当numComponents等于数组长度时触发数组扩容，导致不必要的数组分配和复制。优化后：使用>比较，仅在numComponents严格大于数组长度时才扩容，避免了不必要的数组分配和复制操作。思路：通过修改边界条件判断，减少内存分配和复制开销，提升性能。"}
{"id": 551, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+代码重构", "optimization_description": "优化前：每个GC线程独立分配和释放PartialArrayState对象，存在重复分配开销和内存碎片问题。优化后：引入PartialArrayStateManager集中管理PartialArrayState对象池，实现对象重用。关键修改包括：1) 在G1CollectedHeap中创建PartialArrayStateManager实例；2) 修改G1ParScanThreadState使用管理器接口；3) 移除worker_id参数简化调用。优化思路：通过对象池化减少内存分配次数，降低GC暂停时间，提高内存使用效率。", "original_code": "每个GC线程独立分配和释放PartialArrayState对象，存在重复分配开销和内存碎片问题。", "optimized_code": "- _partial_array_state_allocator->release(_worker_id, state);\n+ _partial_array_state_allocator.release(state);\n- _partial_array_state_allocator->allocate(_worker_id, fro\n+ _partial_array_state_allocator.allocate(fro", "source_url": "https://github.com/openjdk/riscv-port/commit/dbf48a53eca74380b279ce6be3bab2a6a248f7f2", "code_v0_no_empty_lines": "每个GC线程独立分配和释放PartialArrayState对象，存在重复分配开销和内存碎片问题。", "code_v1_no_empty_lines": "- _partial_array_state_allocator->release(_worker_id, state);\n+ _partial_array_state_allocator.release(state);\n- _partial_array_state_allocator->allocate(_worker_id, fro\n+ _partial_array_state_allocator.allocate(fro", "target": "- _partial_array_state_allocator->release(_worker_id, state);\n+ _partial_array_state_allocator.release(state);\n- _partial_array_state_allocator->allocate(_worker_id, fro\n+ _partial_array_state_allocator.allocate(fro", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每个GC线程独立分配和释放PartialArrayState对象，存在重复分配开销和内存碎片问题。优化后：引入PartialArrayStateManager集中管理PartialArrayState对象池，实现对象重用。关键修改包括：1) 在G1CollectedHeap中创建PartialArrayStateManager实例；2) 修改G1ParScanThreadState使用管理器接口；3) 移除worker_id参数简化调用。优化思路：通过对象池化减少内存分配次数，降低GC暂停时间，提高内存使用效率。"}
{"id": 552, "source": "riscv-dataset-excel", "optimization_type": "编译器控制流优化", "optimization_description": "优化前：do_range_check函数在范围检查消除后，某些节点（如Bool/Cmp节点）可能被错误地设置为new_limit_ctrl控制，导致控制流不正确，特别是当这些节点是循环变量时。优化后：1) 移除未使用的old_new参数；2) 在计算new_limit_ctrl时考虑主循环限制的早期控制；3) 将pre_end的cmp_node和in(1)的控制设置为pre_end->in(0)（最晚可能的控制），避免将循环变量节点设置为循环外控制；4) 移除对主循环零行程保护的Bool/Cmp节点的控制设置，添加断言验证其控制已在适当位置。优化思路：确保循环变量节点的控制不被错误提升到循环外，修复范围检查消除后可能出现的控制流不一致问题。", "original_code": "do_range_check函数在范围检查消除后，某些节点（如Bool/Cmp节点）可能被错误地设置为new_limit_ctrl控制，导致控制流不正确，特别是当这些节点是循环变量时。", "optimized_code": "-void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n+void PhaseIdealLoop::do_range_check(IdealLoopTree* loop) {\n-  Node* new_limit_ctrl = dominated_node(pre_ctrl, pre_limit_ctrl);\n+  Node* new_limit_ctrl = dominated_node(pre_ctrl, pre_limit_ctrl, compute_early_ctrl(main_limit, main_limit_ctrl));\n-  set_ctrl(pre_end->cmp_node(), new_limit_ctrl);\n-  set_ctrl(pre_end->in(1), new_limit_ctrl);\n+  set_ctrl(pre_end->cmp_node(), pre_end->in(0));\n+  set_ctrl(pre_end->in(1), pre_end->in(0));\n-  set_ctrl(iffm->in(1)->in(1), new_limit_ctrl);\n-  set_ctrl(iffm->in(1), new_limit_ctrl);\n+  assert(is_dominator(new_limit_ctrl, get_ctrl(iffm->in(1)->in(1))), \"control of cmp should be below control of updated input\");", "source_url": "https://github.com/openjdk/riscv-port/commit/d9a22139fb14c67e2b1dac2c93c1e46bc3b14c72", "code_v0_no_empty_lines": "do_range_check函数在范围检查消除后，某些节点（如Bool/Cmp节点）可能被错误地设置为new_limit_ctrl控制，导致控制流不正确，特别是当这些节点是循环变量时。", "code_v1_no_empty_lines": "-void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n+void PhaseIdealLoop::do_range_check(IdealLoopTree* loop) {\n-  Node* new_limit_ctrl = dominated_node(pre_ctrl, pre_limit_ctrl);\n+  Node* new_limit_ctrl = dominated_node(pre_ctrl, pre_limit_ctrl, compute_early_ctrl(main_limit, main_limit_ctrl));\n-  set_ctrl(pre_end->cmp_node(), new_limit_ctrl);\n-  set_ctrl(pre_end->in(1), new_limit_ctrl);\n+  set_ctrl(pre_end->cmp_node(), pre_end->in(0));\n+  set_ctrl(pre_end->in(1), pre_end->in(0));\n-  set_ctrl(iffm->in(1)->in(1), new_limit_ctrl);\n-  set_ctrl(iffm->in(1), new_limit_ctrl);\n+  assert(is_dominator(new_limit_ctrl, get_ctrl(iffm->in(1)->in(1))), \"control of cmp should be below control of updated input\");", "target": "-void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n+void PhaseIdealLoop::do_range_check(IdealLoopTree* loop) {\n-  Node* new_limit_ctrl = dominated_node(pre_ctrl, pre_limit_ctrl);\n+  Node* new_limit_ctrl = dominated_node(pre_ctrl, pre_limit_ctrl, compute_early_ctrl(main_limit, main_limit_ctrl));\n-  set_ctrl(pre_end->cmp_node(), new_limit_ctrl);\n-  set_ctrl(pre_end->in(1), new_limit_ctrl);\n+  set_ctrl(pre_end->cmp_node(), pre_end->in(0));\n+  set_ctrl(pre_end->in(1), pre_end->in(0));\n-  set_ctrl(iffm->in(1)->in(1), new_limit_ctrl);\n-  set_ctrl(iffm->in(1), new_limit_ctrl);\n+  assert(is_dominator(new_limit_ctrl, get_ctrl(iffm->in(1)->in(1))), \"control of cmp should be below control of updated input\");", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：do_range_check函数在范围检查消除后，某些节点（如Bool/Cmp节点）可能被错误地设置为new_limit_ctrl控制，导致控制流不正确，特别是当这些节点是循环变量时。优化后：1) 移除未使用的old_new参数；2) 在计算new_limit_ctrl时考虑主循环限制的早期控制；3) 将pre_end的cmp_node和in(1)的控制设置为pre_end->in(0)（最晚可能的控制），避免将循环变量节点设置为循环外控制；4) 移除对主循环零行程保护的Bool/Cmp节点的控制设置，添加断言验证其控制已在适当位置。优化思路：确保循环变量节点的控制不被错误提升到循环外，修复范围检查消除后可能出现的控制流不一致问题。"}
{"id": 553, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化+代码生成优化", "optimization_description": "优化前：在ReduceInitialCardMarks启用时，对新分配对象跳过卡标记的逻辑缺乏详细说明和运行时验证。优化后：1) 在编译器层添加详细注释，说明在Generational Shenandoah中为何可以安全跳过新生代对象的初始卡标记；2) 在运行时层添加on_slowpath_allocation_exit()方法，在慢路径分配退出时验证对象确实在新生代，确保卡标记消除的安全性。优化思路：通过添加运行时验证和详细文档，确保卡标记消除优化的安全性，同时保持性能优势。", "original_code": "在ReduceInitialCardMarks启用时，对新分配对象跳过卡标记的逻辑缺乏详细说明和运行时验证。", "optimized_code": "1. shenandoahBarrierSetC2.cpp中优化条件判断逻辑，添加详细注释说明\n2. shenandoahBarrierSet.cpp中添加on_slowpath_allocation_exit()方法实现\n3. shenandoahBarrierSet.hpp中声明on_slowpath_allocation_exit()方法并添加override修饰符", "source_url": "https://github.com/openjdk/riscv-port/commit/a97dca52c9257121fc96613a4b591920c1c3e31a", "code_v0_no_empty_lines": "在ReduceInitialCardMarks启用时，对新分配对象跳过卡标记的逻辑缺乏详细说明和运行时验证。", "code_v1_no_empty_lines": "1. shenandoahBarrierSetC2.cpp中优化条件判断逻辑，添加详细注释说明\n2. shenandoahBarrierSet.cpp中添加on_slowpath_allocation_exit()方法实现\n3. shenandoahBarrierSet.hpp中声明on_slowpath_allocation_exit()方法并添加override修饰符", "target": "1. shenandoahBarrierSetC2.cpp中优化条件判断逻辑，添加详细注释说明\n2. shenandoahBarrierSet.cpp中添加on_slowpath_allocation_exit()方法实现\n3. shenandoahBarrierSet.hpp中声明on_slowpath_allocation_exit()方法并添加override修饰符", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在ReduceInitialCardMarks启用时，对新分配对象跳过卡标记的逻辑缺乏详细说明和运行时验证。优化后：1) 在编译器层添加详细注释，说明在Generational Shenandoah中为何可以安全跳过新生代对象的初始卡标记；2) 在运行时层添加on_slowpath_allocation_exit()方法，在慢路径分配退出时验证对象确实在新生代，确保卡标记消除的安全性。优化思路：通过添加运行时验证和详细文档，确保卡标记消除优化的安全性，同时保持性能优势。"}
{"id": 554, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+内存管理优化", "optimization_description": "优化前：uncommit操作在控制线程中同步执行，使用周期性检查（shrink_period）触发，可能阻塞控制线程并增加GC暂停时间。优化后：将uncommit操作分离到独立的STS（Serviceability Agent Thread State）感知线程中异步执行，通过通知机制触发。优化思路：减少控制线程阻塞，提高并发性能，避免uncommit操作干扰GC关键路径，同时通过专门的线程管理内存回收，提升系统响应性。", "original_code": "uncommit操作在控制线程中同步执行，使用周期性检查（shrink_period）触发，可能阻塞控制线程并增加GC暂停时间。", "optimized_code": "1. 移除控制线程中的uncommit逻辑，改为通知机制\n   - 删除last_shrink_time和shrink_period变量\n   - 将直接调用heap->maybe_uncommit()改为heap->notify_soft_max_changed()和heap->notify_explicit_gc_requested()\n2. 新增独立的uncommit线程\n   - 创建shenandoahUncommitThread.cpp/hpp文件\n   - 实现ShenandoahUncommitThread类，继承自NamedThread\n   - 添加ShenandoahNoUncommitMark防止并发冲突", "source_url": "https://github.com/openjdk/riscv-port/commit/bedb68aba126c6400ce9f2182105b5294ff42021", "code_v0_no_empty_lines": "uncommit操作在控制线程中同步执行，使用周期性检查（shrink_period）触发，可能阻塞控制线程并增加GC暂停时间。", "code_v1_no_empty_lines": "1. 移除控制线程中的uncommit逻辑，改为通知机制\n   - 删除last_shrink_time和shrink_period变量\n   - 将直接调用heap->maybe_uncommit()改为heap->notify_soft_max_changed()和heap->notify_explicit_gc_requested()\n2. 新增独立的uncommit线程\n   - 创建shenandoahUncommitThread.cpp/hpp文件\n   - 实现ShenandoahUncommitThread类，继承自NamedThread\n   - 添加ShenandoahNoUncommitMark防止并发冲突", "target": "1. 移除控制线程中的uncommit逻辑，改为通知机制\n   - 删除last_shrink_time和shrink_period变量\n   - 将直接调用heap->maybe_uncommit()改为heap->notify_soft_max_changed()和heap->notify_explicit_gc_requested()\n2. 新增独立的uncommit线程\n   - 创建shenandoahUncommitThread.cpp/hpp文件\n   - 实现ShenandoahUncommitThread类，继承自NamedThread\n   - 添加ShenandoahNoUncommitMark防止并发冲突", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：uncommit操作在控制线程中同步执行，使用周期性检查（shrink_period）触发，可能阻塞控制线程并增加GC暂停时间。优化后：将uncommit操作分离到独立的STS（Serviceability Agent Thread State）感知线程中异步执行，通过通知机制触发。优化思路：减少控制线程阻塞，提高并发性能，避免uncommit操作干扰GC关键路径，同时通过专门的线程管理内存回收，提升系统响应性。"}
{"id": 555, "source": "riscv-dataset-excel", "optimization_type": "编译优化支持", "optimization_description": "优化前：OpenJDK的Link Time Optimization（LTO）仅支持GCC和Microsoft编译器，缺少对Clang编译器的支持，且汇编代码中的全局标签在LTO时可能引发链接问题。优化后：1. 在构建系统中为Clang编译器添加LTO支持（-flto标志），针对AIX平台添加-ffat-lto-objects选项；2. 将SpinPause函数中的全局标签'SpinPause_return'改为局部标签'1:'，避免LTO时的符号冲突。优化思路：扩展编译器支持范围以利用LTO的跨模块优化能力，同时修复汇编代码的标签作用域问题，确保在不同编译器下都能正确进行链接时优化。", "original_code": "OpenJDK的Link Time Optimization（LTO）仅支持GCC和Microsoft编译器，缺少对Clang编译器的支持，且汇编代码中的全局标签在LTO时可能引发链接问题。", "optimized_code": "diff --git a/make/hotspot/lib/JvmFeatures.gmk b/make/hotspot/lib/JvmFeatures.gmk\nindex b94031515f7..09a48508eff 100644\n--- a/make/hotspot/lib/JvmFeatures.gmk\n+++ b/make/hotspot/lib/JvmFeatures.gmk\n@@ -174,6 +174,12 @@ ifeq ($(call check-jvm-feature, link-time-opt), true)\n         -fno-fat-lto-objects\n     JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto \\\n         -fuse-linker-plugin -fno-strict-aliasing\n+  else ifeq ($(call isCompiler, clang), true)\n+    JVM_CFLAGS_FEATURES += -flto -fno-strict-aliasing\n+    ifeq ($(call isBuildOs, aix), true)\n+      JVM_CFLAGS_FEATURES += -ffat-lto-objects\n+    endif\n+    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto -fno-strict-aliasing\n   else ifeq ($(call isCompiler, microsoft), true)\n     JVM_CFLAGS_FEATURES += -GL\n     JVM_LDFLAGS_FEATURES += -LTCG:INCREMENTAL\n\ndiff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp\nindex 7702dbd17ad..1e3602d08f4 100644\n--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp\n+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp\n@@ -501,6 +501,7 @@ static inline void atomic_copy64(const volatile void *src, volatile void *dst) {\n }\n \n extern \"C\" {\n+  // needs local assembler label '1:' to avoid trouble when using linktime optimization\n   int SpinPause() {\n     // We don't use StubRoutines::aarch64::spin_wait stub in order to\n     // avoid a costly call to os::current_thread_enable_wx() on MacOS.\n@@ -523,14 +524,14 @@ extern \"C\" {\n                                       // to entry for case SpinWait::NOP\n         \"  add  %[d], %[d], %[o]  \\n\"\n         \"  br   %[d]              \\n\"\n-        \"  b    SpinPause_return  \\n\" // case SpinWait::NONE  (-1)\n+        \"  b    1f                \\n\" // case SpinWait::NONE  (-1)\n         \"  nop                    \\n\" // padding\n         \"  nop                    \\n\" // case SpinWait::NOP   ( 0)\n-        \"  b    SpinPause_return  \\n\"\n+        \"  b    1f                \\n\"\n         \"  isb                    \\n\" // case SpinWait::ISB   ( 1)\n-        \"  b    SpinPause_return  \\n\"\n+        \"  b    1f                \\n\"\n         \"  yield                  \\n\" // case SpinWait::YIELD ( 2)\n-        \"SpinPause_return:        \\n\"\n+        \"1:        \\n\"\n         : [d]\"=&r\"(br_dst)\n         : [o]\"r\"(off)\n         : \"memory\")", "source_url": "https://github.com/openjdk/riscv-port/commit/85fedbf668023fd00d70ec649504c2f80e4c84bb", "code_v0_no_empty_lines": "OpenJDK的Link Time Optimization（LTO）仅支持GCC和Microsoft编译器，缺少对Clang编译器的支持，且汇编代码中的全局标签在LTO时可能引发链接问题。", "code_v1_no_empty_lines": "diff --git a/make/hotspot/lib/JvmFeatures.gmk b/make/hotspot/lib/JvmFeatures.gmk\nindex b94031515f7..09a48508eff 100644\n--- a/make/hotspot/lib/JvmFeatures.gmk\n+++ b/make/hotspot/lib/JvmFeatures.gmk\n@@ -174,6 +174,12 @@ ifeq ($(call check-jvm-feature, link-time-opt), true)\n         -fno-fat-lto-objects\n     JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto \\\n         -fuse-linker-plugin -fno-strict-aliasing\n+  else ifeq ($(call isCompiler, clang), true)\n+    JVM_CFLAGS_FEATURES += -flto -fno-strict-aliasing\n+    ifeq ($(call isBuildOs, aix), true)\n+      JVM_CFLAGS_FEATURES += -ffat-lto-objects\n+    endif\n+    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto -fno-strict-aliasing\n   else ifeq ($(call isCompiler, microsoft), true)\n     JVM_CFLAGS_FEATURES += -GL\n     JVM_LDFLAGS_FEATURES += -LTCG:INCREMENTAL\n\ndiff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp\nindex 7702dbd17ad..1e3602d08f4 100644\n--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp\n+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp\n@@ -501,6 +501,7 @@ static inline void atomic_copy64(const volatile void *src, volatile void *dst) {\n }\n \n extern \"C\" {\n+  // needs local assembler label '1:' to avoid trouble when using linktime optimization\n   int SpinPause() {\n     // We don't use StubRoutines::aarch64::spin_wait stub in order to\n     // avoid a costly call to os::current_thread_enable_wx() on MacOS.\n@@ -523,14 +524,14 @@ extern \"C\" {\n                                       // to entry for case SpinWait::NOP\n         \"  add  %[d], %[d], %[o]  \\n\"\n         \"  br   %[d]              \\n\"\n-        \"  b    SpinPause_return  \\n\" // case SpinWait::NONE  (-1)\n+        \"  b    1f                \\n\" // case SpinWait::NONE  (-1)\n         \"  nop                    \\n\" // padding\n         \"  nop                    \\n\" // case SpinWait::NOP   ( 0)\n-        \"  b    SpinPause_return  \\n\"\n+        \"  b    1f                \\n\"\n         \"  isb                    \\n\" // case SpinWait::ISB   ( 1)\n-        \"  b    SpinPause_return  \\n\"\n+        \"  b    1f                \\n\"\n         \"  yield                  \\n\" // case SpinWait::YIELD ( 2)\n-        \"SpinPause_return:        \\n\"\n+        \"1:        \\n\"\n         : [d]\"=&r\"(br_dst)\n         : [o]\"r\"(off)\n         : \"memory\")", "target": "diff --git a/make/hotspot/lib/JvmFeatures.gmk b/make/hotspot/lib/JvmFeatures.gmk\nindex b94031515f7..09a48508eff 100644\n--- a/make/hotspot/lib/JvmFeatures.gmk\n+++ b/make/hotspot/lib/JvmFeatures.gmk\n@@ -174,6 +174,12 @@ ifeq ($(call check-jvm-feature, link-time-opt), true)\n         -fno-fat-lto-objects\n     JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto \\\n         -fuse-linker-plugin -fno-strict-aliasing\n+  else ifeq ($(call isCompiler, clang), true)\n+    JVM_CFLAGS_FEATURES += -flto -fno-strict-aliasing\n+    ifeq ($(call isBuildOs, aix), true)\n+      JVM_CFLAGS_FEATURES += -ffat-lto-objects\n+    endif\n+    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto -fno-strict-aliasing\n   else ifeq ($(call isCompiler, microsoft), true)\n     JVM_CFLAGS_FEATURES += -GL\n     JVM_LDFLAGS_FEATURES += -LTCG:INCREMENTAL\n\ndiff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp\nindex 7702dbd17ad..1e3602d08f4 100644\n--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp\n+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp\n@@ -501,6 +501,7 @@ static inline void atomic_copy64(const volatile void *src, volatile void *dst) {\n }\n \n extern \"C\" {\n+  // needs local assembler label '1:' to avoid trouble when using linktime optimization\n   int SpinPause() {\n     // We don't use StubRoutines::aarch64::spin_wait stub in order to\n     // avoid a costly call to os::current_thread_enable_wx() on MacOS.\n@@ -523,14 +524,14 @@ extern \"C\" {\n                                       // to entry for case SpinWait::NOP\n         \"  add  %[d], %[d], %[o]  \\n\"\n         \"  br   %[d]              \\n\"\n-        \"  b    SpinPause_return  \\n\" // case SpinWait::NONE  (-1)\n+        \"  b    1f                \\n\" // case SpinWait::NONE  (-1)\n         \"  nop                    \\n\" // padding\n         \"  nop                    \\n\" // case SpinWait::NOP   ( 0)\n-        \"  b    SpinPause_return  \\n\"\n+        \"  b    1f                \\n\"\n         \"  isb                    \\n\" // case SpinWait::ISB   ( 1)\n-        \"  b    SpinPause_return  \\n\"\n+        \"  b    1f                \\n\"\n         \"  yield                  \\n\" // case SpinWait::YIELD ( 2)\n-        \"SpinPause_return:        \\n\"\n+        \"1:        \\n\"\n         : [d]\"=&r\"(br_dst)\n         : [o]\"r\"(off)\n         : \"memory\")", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：OpenJDK的Link Time Optimization（LTO）仅支持GCC和Microsoft编译器，缺少对Clang编译器的支持，且汇编代码中的全局标签在LTO时可能引发链接问题。优化后：1. 在构建系统中为Clang编译器添加LTO支持（-flto标志），针对AIX平台添加-ffat-lto-objects选项；2. 将SpinPause函数中的全局标签'SpinPause_return'改为局部标签'1:'，避免LTO时的符号冲突。优化思路：扩展编译器支持范围以利用LTO的跨模块优化能力，同时修复汇编代码的标签作用域问题，确保在不同编译器下都能正确进行链接时优化。"}
{"id": 556, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+性能优化", "optimization_description": "优化前：PPC64架构缺乏半精度浮点数（float16）与单精度浮点数（float）之间位表示转换的硬件指令支持，需要通过软件模拟实现转换，效率较低。优化后：为PPC64架构添加了LFIWAX、LFIWZX、STFIWX等整数-浮点加载/存储指令，以及XVCVHPSP、XVCVSPHP、XSCVHPDP、XSCVDPHP等半精度-单精度转换指令的硬件支持，使编译器能够生成对应的机器码。优化思路：利用PPC64硬件指令实现半精度浮点数转换，将原本的软件模拟转换为硬件指令执行，显著提升转换性能，特别是在向量化操作中效果更明显。", "original_code": "PPC64架构缺乏半精度浮点数（float16）与单精度浮点数（float）之间位表示转换的硬件指令支持，需要通过软件模拟实现转换，效率较低。", "optimized_code": "+    LFIWAX_OPCODE  = (31u << OPCODE_SHIFT |  855u << 1),\n+    LFIWZX_OPCODE  = (31u << OPCODE_SHIFT |  887u << 1),\n+    STFIWX_OPCODE  = (31u << OPCODE_SHIFT |  983u << 1),\n+    XVCVHPSP_OPCODE= (60u << OPCODE_SHIFT |  475u << 2 | 24u << 16), // XX2-FORM\n+    XVCVSPHP_OPCODE= (60u << OPCODE_SHIFT |  475u << 2 | 25u << 16), // XX2-FORM\n+    XSCVHPDP_OPCODE= (60u << OPCODE_SHIFT |  347u << 2 | 16u << 16), // XX2-FORM\n+    XSCVDPHP_OPCODE= (60u << OPCODE_SHIFT |  347u << 2 | 17u << 16), // XX2-FORM", "source_url": "https://github.com/openjdk/riscv-port/commit/b42d79eb6a6d497dc63718c2854609bebca4498c", "code_v0_no_empty_lines": "PPC64架构缺乏半精度浮点数（float16）与单精度浮点数（float）之间位表示转换的硬件指令支持，需要通过软件模拟实现转换，效率较低。", "code_v1_no_empty_lines": "+    LFIWAX_OPCODE  = (31u << OPCODE_SHIFT |  855u << 1),\n+    LFIWZX_OPCODE  = (31u << OPCODE_SHIFT |  887u << 1),\n+    STFIWX_OPCODE  = (31u << OPCODE_SHIFT |  983u << 1),\n+    XVCVHPSP_OPCODE= (60u << OPCODE_SHIFT |  475u << 2 | 24u << 16), // XX2-FORM\n+    XVCVSPHP_OPCODE= (60u << OPCODE_SHIFT |  475u << 2 | 25u << 16), // XX2-FORM\n+    XSCVHPDP_OPCODE= (60u << OPCODE_SHIFT |  347u << 2 | 16u << 16), // XX2-FORM\n+    XSCVDPHP_OPCODE= (60u << OPCODE_SHIFT |  347u << 2 | 17u << 16), // XX2-FORM", "target": "+    LFIWAX_OPCODE  = (31u << OPCODE_SHIFT |  855u << 1),\n+    LFIWZX_OPCODE  = (31u << OPCODE_SHIFT |  887u << 1),\n+    STFIWX_OPCODE  = (31u << OPCODE_SHIFT |  983u << 1),\n+    XVCVHPSP_OPCODE= (60u << OPCODE_SHIFT |  475u << 2 | 24u << 16), // XX2-FORM\n+    XVCVSPHP_OPCODE= (60u << OPCODE_SHIFT |  475u << 2 | 25u << 16), // XX2-FORM\n+    XSCVHPDP_OPCODE= (60u << OPCODE_SHIFT |  347u << 2 | 16u << 16), // XX2-FORM\n+    XSCVDPHP_OPCODE= (60u << OPCODE_SHIFT |  347u << 2 | 17u << 16), // XX2-FORM", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PPC64架构缺乏半精度浮点数（float16）与单精度浮点数（float）之间位表示转换的硬件指令支持，需要通过软件模拟实现转换，效率较低。优化后：为PPC64架构添加了LFIWAX、LFIWZX、STFIWX等整数-浮点加载/存储指令，以及XVCVHPSP、XVCVSPHP、XSCVHPDP、XSCVDPHP等半精度-单精度转换指令的硬件支持，使编译器能够生成对应的机器码。优化思路：利用PPC64硬件指令实现半精度浮点数转换，将原本的软件模拟转换为硬件指令执行，显著提升转换性能，特别是在向量化操作中效果更明显。"}
{"id": 557, "source": "riscv-dataset-excel", "optimization_type": "性能优化", "optimization_description": "优化前：先调用Properties.containsKey()检查键是否存在，再调用getProperty()获取值，导致两次哈希查找。优化后：直接调用getProperty()获取值，通过检查返回值是否为null来判断键是否存在，减少一次哈希查找操作。思路：消除冗余的containsKey调用，将两次哈希查找合并为一次，提高方法执行效率。", "original_code": "先调用Properties.containsKey()检查键是否存在，再调用getProperty()获取值，导致两次哈希查找。", "optimized_code": "-            String key    = prefix + DOT_FILE_SUFFIX;\n-            if (!systemCustomCursorProperties.containsKey(key)) {\n+            String fileName =\n+                systemCustomCursorProperties.getProperty(prefix + DOT_FILE_SUFFIX);\n+            if (fileName == null) {", "source_url": "https://github.com/openjdk/riscv-port/commit/3b7571d37812472a2152f9c8cbfd2a4abdb35016", "code_v0_no_empty_lines": "先调用Properties.containsKey()检查键是否存在，再调用getProperty()获取值，导致两次哈希查找。", "code_v1_no_empty_lines": "-            String key    = prefix + DOT_FILE_SUFFIX;\n-            if (!systemCustomCursorProperties.containsKey(key)) {\n+            String fileName =\n+                systemCustomCursorProperties.getProperty(prefix + DOT_FILE_SUFFIX);\n+            if (fileName == null) {", "target": "-            String key    = prefix + DOT_FILE_SUFFIX;\n-            if (!systemCustomCursorProperties.containsKey(key)) {\n+            String fileName =\n+                systemCustomCursorProperties.getProperty(prefix + DOT_FILE_SUFFIX);\n+            if (fileName == null) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：先调用Properties.containsKey()检查键是否存在，再调用getProperty()获取值，导致两次哈希查找。优化后：直接调用getProperty()获取值，通过检查返回值是否为null来判断键是否存在，减少一次哈希查找操作。思路：消除冗余的containsKey调用，将两次哈希查找合并为一次，提高方法执行效率。"}
{"id": 559, "source": "riscv-dataset-excel", "optimization_type": "代码简化+性能优化", "optimization_description": "优化前：PQC算法中为向量NTT操作定义了大型静态数组MONT_ZETAS_FOR_VECTOR_NTT_ARR，并通过包装函数调用内部函数，增加了代码复杂性和内存占用。优化后：移除了该数组定义和相关的包装函数，直接使用内部函数，减少了代码量（427行删除 vs 48行新增）。优化思路：简化代码结构，减少不必要的包装层，可能通过内联或直接调用内部函数来提高性能并降低内存使用。", "original_code": "PQC算法中为向量NTT操作定义了大型静态数组MONT_ZETAS_FOR_VECTOR_NTT_ARR，并通过包装函数调用内部函数，增加了代码复杂性和内存占用。", "optimized_code": "-    private static final short[] MONT_ZETAS_FOR_VECTOR_NTT_ARR = new short[]{\n            // level 0\n            -758, -758, -758, -758, -758, -758, -758, -758,\n            -758, -758, -758, -758, -758, -758, -758, -758,\n            ... (大量数组元素)\n    };\n+    // 移除了MONT_ZETAS_FOR_VECTOR_NTT_ARR数组定义", "source_url": "https://github.com/openjdk/riscv-port/commit/f904480a49649e0e89e4afca11fcadecb8669331", "code_v0_no_empty_lines": "PQC算法中为向量NTT操作定义了大型静态数组MONT_ZETAS_FOR_VECTOR_NTT_ARR，并通过包装函数调用内部函数，增加了代码复杂性和内存占用。", "code_v1_no_empty_lines": "-    private static final short[] MONT_ZETAS_FOR_VECTOR_NTT_ARR = new short[]{\n            // level 0\n            -758, -758, -758, -758, -758, -758, -758, -758,\n            -758, -758, -758, -758, -758, -758, -758, -758,\n            ... (大量数组元素)\n    };\n+    // 移除了MONT_ZETAS_FOR_VECTOR_NTT_ARR数组定义", "target": "-    private static final short[] MONT_ZETAS_FOR_VECTOR_NTT_ARR = new short[]{\n            // level 0\n            -758, -758, -758, -758, -758, -758, -758, -758,\n            -758, -758, -758, -758, -758, -758, -758, -758,\n            ... (大量数组元素)\n    };\n+    // 移除了MONT_ZETAS_FOR_VECTOR_NTT_ARR数组定义", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PQC算法中为向量NTT操作定义了大型静态数组MONT_ZETAS_FOR_VECTOR_NTT_ARR，并通过包装函数调用内部函数，增加了代码复杂性和内存占用。优化后：移除了该数组定义和相关的包装函数，直接使用内部函数，减少了代码量（427行删除 vs 48行新增）。优化思路：简化代码结构，减少不必要的包装层，可能通过内联或直接调用内部函数来提高性能并降低内存使用。"}
{"id": 560, "source": "riscv-dataset-excel", "optimization_type": "浮点运算优化+指令选择优化", "optimization_description": "优化前：在x86_64平台上，处理浮点数NaN转换（如Double.doubleToRawLongBits等）时会调用解释器存根，导致额外开销。优化后：修改条件编译，仅对IA32（32位x86）平台保留解释器存根调用，x86_64平台直接生成机器指令（MOV_D2L、MOV_L2D等），避免解释器调用开销，提升浮点转换性能。", "original_code": "在x86_64平台上，处理浮点数NaN转换（如Double.doubleToRawLongBits等）时会调用解释器存根，导致额外开销。", "optimized_code": "-#if defined(X86) && !defined(ZERO)\n+#if defined(IA32) && !defined(ZERO)\n...\n-#endif // X86 && !ZERO\n+#endif // IA32 && !ZERO", "source_url": "https://github.com/openjdk/riscv-port/commit/f3b4350e0f14d3b0c551e0d24563788f379111d6", "code_v0_no_empty_lines": "在x86_64平台上，处理浮点数NaN转换（如Double.doubleToRawLongBits等）时会调用解释器存根，导致额外开销。", "code_v1_no_empty_lines": "-#if defined(X86) && !defined(ZERO)\n+#if defined(IA32) && !defined(ZERO)\n...\n-#endif // X86 && !ZERO\n+#endif // IA32 && !ZERO", "target": "-#if defined(X86) && !defined(ZERO)\n+#if defined(IA32) && !defined(ZERO)\n...\n-#endif // X86 && !ZERO\n+#endif // IA32 && !ZERO", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在x86_64平台上，处理浮点数NaN转换（如Double.doubleToRawLongBits等）时会调用解释器存根，导致额外开销。优化后：修改条件编译，仅对IA32（32位x86）平台保留解释器存根调用，x86_64平台直接生成机器指令（MOV_D2L、MOV_L2D等），避免解释器调用开销，提升浮点转换性能。"}
{"id": 561, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化/指令格式修复", "optimization_description": "优化前：浮点数max/min指令的format字符串存在错误，包括：1) 未正确引用临时寄存器变量名（如$tmp, $atmp等），2) 归约指令的format字符串与实际指令名不匹配（如maxD_reduction指令却显示为\"$dst = min(...)\"）。优化后：1) 在format字符串中正确添加了$前缀来引用寄存器变量，2) 统一了归约指令的format字符串格式，使其与实际指令名一致（如maxF_reduction、minD_reduction等）。优化思路：修复指令格式描述错误，确保汇编输出和调试信息准确反映实际生成的指令，提高代码可读性和调试便利性。", "original_code": "浮点数max/min指令的format字符串存在错误，包括：1) 未正确引用临时寄存器变量名（如$tmp, $atmp等），2) 归约指令的format字符串与实际指令名不匹配（如maxD_reduction指令却显示为\"$dst = min(...)\"）。", "optimized_code": "- format %{ \"$dst = max($a, $b)\\t# intrinsic (float)\" %}\n+ format %{ \"maxF_reduction $dst, $a, $b \\t!using $xtmp and $rtmp as TEMP\" %}\n\n- format %{ \"$dst = max($a, $b)\\t# intrinsic (double)\" %}\n+ format %{ \"maxD_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n\n- format %{ \"$dst = min($a, $b)\\t# intrinsic (float)\" %}\n+ format %{ \"minF_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n\n- format %{ \"$dst = min($a, $b)\\t# intrinsic (double)\" %}\n+ format %{ \"maxD_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}", "source_url": "https://github.com/openjdk/riscv-port/commit/e1695f6c40dbf27538c6c450eb1cf64a05e0ee9a", "code_v0_no_empty_lines": "浮点数max/min指令的format字符串存在错误，包括：1) 未正确引用临时寄存器变量名（如$tmp, $atmp等），2) 归约指令的format字符串与实际指令名不匹配（如maxD_reduction指令却显示为\"$dst = min(...)\"）。", "code_v1_no_empty_lines": "- format %{ \"$dst = max($a, $b)\\t# intrinsic (float)\" %}\n+ format %{ \"maxF_reduction $dst, $a, $b \\t!using $xtmp and $rtmp as TEMP\" %}\n\n- format %{ \"$dst = max($a, $b)\\t# intrinsic (double)\" %}\n+ format %{ \"maxD_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n\n- format %{ \"$dst = min($a, $b)\\t# intrinsic (float)\" %}\n+ format %{ \"minF_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n\n- format %{ \"$dst = min($a, $b)\\t# intrinsic (double)\" %}\n+ format %{ \"maxD_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}", "target": "- format %{ \"$dst = max($a, $b)\\t# intrinsic (float)\" %}\n+ format %{ \"maxF_reduction $dst, $a, $b \\t!using $xtmp and $rtmp as TEMP\" %}\n\n- format %{ \"$dst = max($a, $b)\\t# intrinsic (double)\" %}\n+ format %{ \"maxD_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n\n- format %{ \"$dst = min($a, $b)\\t# intrinsic (float)\" %}\n+ format %{ \"minF_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n\n- format %{ \"$dst = min($a, $b)\\t# intrinsic (double)\" %}\n+ format %{ \"maxD_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：浮点数max/min指令的format字符串存在错误，包括：1) 未正确引用临时寄存器变量名（如$tmp, $atmp等），2) 归约指令的format字符串与实际指令名不匹配（如maxD_reduction指令却显示为\"$dst = min(...)\"）。优化后：1) 在format字符串中正确添加了$前缀来引用寄存器变量，2) 统一了归约指令的format字符串格式，使其与实际指令名一致（如maxF_reduction、minD_reduction等）。优化思路：修复指令格式描述错误，确保汇编输出和调试信息准确反映实际生成的指令，提高代码可读性和调试便利性。"}
{"id": 562, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+GC并行性优化", "optimization_description": "优化前：Cleaner使用简单的链表结构管理PhantomCleanable对象，GC处理队列时存在串行化瓶颈，导致GC并行性差。优化后：引入分块链表结构CleanableList，将Cleanable对象组织成固定容量（4096）的节点数组，通过节点缓存减少内存分配开销，优化内存局部性。关键思路：1）将线性链表改为分块数组链表，减少GC遍历时的内存访问开销；2）维护节点缓存，避免在容量边界频繁分配/释放节点；3）通过数组索引快速定位和移除元素，保持非头节点始终满容量。这显著提升了GC并行处理Cleaner队列的效率，解决了Bug 8343704中描述的GC并行性问题。", "original_code": "Cleaner使用简单的链表结构管理PhantomCleanable对象，GC处理队列时存在串行化瓶颈，导致GC并行性差。", "optimized_code": "final PhantomCleanable<?> phantomCleanableList;\n+ final CleanableList activeList;\n\npublic CleanerImpl() {\n    queue = new ReferenceQueue<>();\n    phantomCleanableList = new PhantomCleanableRef();\n+    activeList = new CleanableList();\n}\n\nwhile (!phantomCleanableList.isListEmpty()) {\n+ while (!activeList.isEmpty()) {\n\nstatic final class CleanableList {\n    static final int NODE_CAPACITY = 4096;\n    private Node head;\n    private Node cache;\n    \n    public synchronized void insert(PhantomCleanable<?> phc) {\n        if (head.size == NODE_CAPACITY) {\n            Node newHead;\n            if (cache != null) {\n                newHead = cache;\n                cache = null;\n            } else {\n                newHead = new Node();\n            }\n            newHead.next = head;\n            head = newHead;\n        }\n        phc.node = head;\n        phc.index = head.size;\n        head.arr[head.size] = phc;\n        head.size++;\n    }\n    \n    public synchronized boolean remove(PhantomCleanable<?> phc) {\n        if (phc.node == null) return false;\n        \n        final int lastIndex = head.size - 1;\n        if (head != phc.node || (phc.index != lastIndex)) {\n            PhantomCleanable<?> mover = head.arr[lastIndex];\n            mover.node = phc.node;\n            mover.index = phc.index;\n            phc.node.arr[phc.index] = mover;\n        }\n        \n        phc.node = null;\n        head.arr[lastIndex] = null;\n        head.size--;\n        \n        if (head.size == 0 && head.next != null) {\n            Node newHead = head.next;\n            if (cache == null) {\n                cache = head;\n                cache.next = null;\n            }\n            head = newHead;\n        }\n        return true;\n    }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/4000e923e8b4472fe022f1fd78a1c42b2045683f", "code_v0_no_empty_lines": "Cleaner使用简单的链表结构管理PhantomCleanable对象，GC处理队列时存在串行化瓶颈，导致GC并行性差。", "code_v1_no_empty_lines": "final PhantomCleanable<?> phantomCleanableList;\n+ final CleanableList activeList;\n\npublic CleanerImpl() {\n    queue = new ReferenceQueue<>();\n    phantomCleanableList = new PhantomCleanableRef();\n+    activeList = new CleanableList();\n}\n\nwhile (!phantomCleanableList.isListEmpty()) {\n+ while (!activeList.isEmpty()) {\n\nstatic final class CleanableList {\n    static final int NODE_CAPACITY = 4096;\n    private Node head;\n    private Node cache;\n    \n    public synchronized void insert(PhantomCleanable<?> phc) {\n        if (head.size == NODE_CAPACITY) {\n            Node newHead;\n            if (cache != null) {\n                newHead = cache;\n                cache = null;\n            } else {\n                newHead = new Node();\n            }\n            newHead.next = head;\n            head = newHead;\n        }\n        phc.node = head;\n        phc.index = head.size;\n        head.arr[head.size] = phc;\n        head.size++;\n    }\n    \n    public synchronized boolean remove(PhantomCleanable<?> phc) {\n        if (phc.node == null) return false;\n        \n        final int lastIndex = head.size - 1;\n        if (head != phc.node || (phc.index != lastIndex)) {\n            PhantomCleanable<?> mover = head.arr[lastIndex];\n            mover.node = phc.node;\n            mover.index = phc.index;\n            phc.node.arr[phc.index] = mover;\n        }\n        \n        phc.node = null;\n        head.arr[lastIndex] = null;\n        head.size--;\n        \n        if (head.size == 0 && head.next != null) {\n            Node newHead = head.next;\n            if (cache == null) {\n                cache = head;\n                cache.next = null;\n            }\n            head = newHead;\n        }\n        return true;\n    }\n}", "target": "final PhantomCleanable<?> phantomCleanableList;\n+ final CleanableList activeList;\n\npublic CleanerImpl() {\n    queue = new ReferenceQueue<>();\n    phantomCleanableList = new PhantomCleanableRef();\n+    activeList = new CleanableList();\n}\n\nwhile (!phantomCleanableList.isListEmpty()) {\n+ while (!activeList.isEmpty()) {\n\nstatic final class CleanableList {\n    static final int NODE_CAPACITY = 4096;\n    private Node head;\n    private Node cache;\n    \n    public synchronized void insert(PhantomCleanable<?> phc) {\n        if (head.size == NODE_CAPACITY) {\n            Node newHead;\n            if (cache != null) {\n                newHead = cache;\n                cache = null;\n            } else {\n                newHead = new Node();\n            }\n            newHead.next = head;\n            head = newHead;\n        }\n        phc.node = head;\n        phc.index = head.size;\n        head.arr[head.size] = phc;\n        head.size++;\n    }\n    \n    public synchronized boolean remove(PhantomCleanable<?> phc) {\n        if (phc.node == null) return false;\n        \n        final int lastIndex = head.size - 1;\n        if (head != phc.node || (phc.index != lastIndex)) {\n            PhantomCleanable<?> mover = head.arr[lastIndex];\n            mover.node = phc.node;\n            mover.index = phc.index;\n            phc.node.arr[phc.index] = mover;\n        }\n        \n        phc.node = null;\n        head.arr[lastIndex] = null;\n        head.size--;\n        \n        if (head.size == 0 && head.next != null) {\n            Node newHead = head.next;\n            if (cache == null) {\n                cache = head;\n                cache.next = null;\n            }\n            head = newHead;\n        }\n        return true;\n    }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Cleaner使用简单的链表结构管理PhantomCleanable对象，GC处理队列时存在串行化瓶颈，导致GC并行性差。优化后：引入分块链表结构CleanableList，将Cleanable对象组织成固定容量（4096）的节点数组，通过节点缓存减少内存分配开销，优化内存局部性。关键思路：1）将线性链表改为分块数组链表，减少GC遍历时的内存访问开销；2）维护节点缓存，避免在容量边界频繁分配/释放节点；3）通过数组索引快速定位和移除元素，保持非头节点始终满容量。这显著提升了GC并行处理Cleaner队列的效率，解决了Bug 8343704中描述的GC并行性问题。"}
{"id": 563, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：当启用UseObjectMonitorTable时，get_object_age()函数可能错误处理对象年龄计算，导致generational Shenandoah GC与compact headers不兼容。优化后：添加条件检查，当使用对象监视器表时，直接返回mark word中的年龄字段，避免通过monitor路径的错误处理。优化思路：修复generational Shenandoah GC在使用compact headers时的对象年龄计算逻辑，确保与轻量级锁定的兼容性。", "original_code": "当启用UseObjectMonitorTable时，get_object_age()函数可能错误处理对象年龄计算，导致generational Shenandoah GC与compact headers不兼容。", "optimized_code": "+  if (UseObjectMonitorTable) {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"Must use LW locking, too\");\n+    assert(w.age() <= markWord::max_age, \"Impossible!\");\n+    return w.age();\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/e9f6ba05264ecb2f1ca3983ea503778f301bf280", "code_v0_no_empty_lines": "当启用UseObjectMonitorTable时，get_object_age()函数可能错误处理对象年龄计算，导致generational Shenandoah GC与compact headers不兼容。", "code_v1_no_empty_lines": "+  if (UseObjectMonitorTable) {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"Must use LW locking, too\");\n+    assert(w.age() <= markWord::max_age, \"Impossible!\");\n+    return w.age();\n+  }", "target": "+  if (UseObjectMonitorTable) {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"Must use LW locking, too\");\n+    assert(w.age() <= markWord::max_age, \"Impossible!\");\n+    return w.age();\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当启用UseObjectMonitorTable时，get_object_age()函数可能错误处理对象年龄计算，导致generational Shenandoah GC与compact headers不兼容。优化后：添加条件检查，当使用对象监视器表时，直接返回mark word中的年龄字段，避免通过monitor路径的错误处理。优化思路：修复generational Shenandoah GC在使用compact headers时的对象年龄计算逻辑，确保与轻量级锁定的兼容性。"}
{"id": 564, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码简化", "optimization_description": "优化前：secondary_super_cache检查在类型检查路径中导致额外分支和计算开销，影响C1编译器和解释器的性能扩展性。优化后：简化了check_klass_subtype_fast_path函数，移除了对secondary_super_cache的特殊处理，将super_check_offset参数从RegisterOrConstant改为Register，减少了条件分支和寄存器使用。优化思路：通过统一处理primary和secondary super类型检查，减少代码复杂性和分支预测失败，提高s390x架构上类型检查的性能和可扩展性。", "original_code": "secondary_super_cache检查在类型检查路径中导致额外分支和计算开销，影响C1编译器和解释器的性能扩展性。", "optimized_code": "- bool need_slow_path = !k->is_loaded() || ((int) k->super_check_offset() == in_bytes(Klass::secondary_super_cache_offset()));\n+ bool need_slow_path = !k->is_loaded();\n- __ check_klass_subtype_fast_path(..., RegisterOrConstant(super_check_offset));\n+ __ check_klass_subtype_fast_path(..., super_check_offset);", "source_url": "https://github.com/openjdk/riscv-port/commit/a3b58ee5cd1ec0ea78649d4128d272458b05eb13", "code_v0_no_empty_lines": "secondary_super_cache检查在类型检查路径中导致额外分支和计算开销，影响C1编译器和解释器的性能扩展性。", "code_v1_no_empty_lines": "- bool need_slow_path = !k->is_loaded() || ((int) k->super_check_offset() == in_bytes(Klass::secondary_super_cache_offset()));\n+ bool need_slow_path = !k->is_loaded();\n- __ check_klass_subtype_fast_path(..., RegisterOrConstant(super_check_offset));\n+ __ check_klass_subtype_fast_path(..., super_check_offset);", "target": "- bool need_slow_path = !k->is_loaded() || ((int) k->super_check_offset() == in_bytes(Klass::secondary_super_cache_offset()));\n+ bool need_slow_path = !k->is_loaded();\n- __ check_klass_subtype_fast_path(..., RegisterOrConstant(super_check_offset));\n+ __ check_klass_subtype_fast_path(..., super_check_offset);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：secondary_super_cache检查在类型检查路径中导致额外分支和计算开销，影响C1编译器和解释器的性能扩展性。优化后：简化了check_klass_subtype_fast_path函数，移除了对secondary_super_cache的特殊处理，将super_check_offset参数从RegisterOrConstant改为Register，减少了条件分支和寄存器使用。优化思路：通过统一处理primary和secondary super类型检查，减少代码复杂性和分支预测失败，提高s390x架构上类型检查的性能和可扩展性。"}
{"id": 565, "source": "riscv-dataset-excel", "optimization_type": "反射性能优化+方法调用优化", "optimization_description": "优化前：反射调用原生方法时，所有原生方法都使用原生访问器（native accessor），包括签名多态方法（如MethodHandle.invokeExact），导致性能下降。优化后：1. 区分真正的原生方法和签名多态方法，仅对签名多态方法使用原生访问器，其他原生方法使用更高效的MethodHandle调用。2. 使用reflectionFactory.getExecutableSharedParameterTypes()缓存参数类型，避免重复获取。优化思路：通过精确识别签名多态方法，减少不必要的原生访问器使用，提升反射调用性能。", "original_code": "反射调用原生方法时，所有原生方法都使用原生访问器（native accessor），包括签名多态方法（如MethodHandle.invokeExact），导致性能下降。", "optimized_code": "- if (Modifier.isNative(member.getModifiers()))\n+ if (member instanceof Method method && isSignaturePolymorphicMethod(method))\n- assert !Modifier.isNative(method.getModifiers());\n+ assert !MethodHandleAccessorFactory.isSignaturePolymorphicMethod(method);\n- var mtype = methodType(method.getReturnType(), method.getParameterTypes());\n+ var mtype = methodType(method.getReturnType(), reflectionFactory.getExecutableSharedParameterTypes(method));", "source_url": "https://github.com/openjdk/riscv-port/commit/5958463cadb04560ec85d9af972255bfe6dcc2f2", "code_v0_no_empty_lines": "反射调用原生方法时，所有原生方法都使用原生访问器（native accessor），包括签名多态方法（如MethodHandle.invokeExact），导致性能下降。", "code_v1_no_empty_lines": "- if (Modifier.isNative(member.getModifiers()))\n+ if (member instanceof Method method && isSignaturePolymorphicMethod(method))\n- assert !Modifier.isNative(method.getModifiers());\n+ assert !MethodHandleAccessorFactory.isSignaturePolymorphicMethod(method);\n- var mtype = methodType(method.getReturnType(), method.getParameterTypes());\n+ var mtype = methodType(method.getReturnType(), reflectionFactory.getExecutableSharedParameterTypes(method));", "target": "- if (Modifier.isNative(member.getModifiers()))\n+ if (member instanceof Method method && isSignaturePolymorphicMethod(method))\n- assert !Modifier.isNative(method.getModifiers());\n+ assert !MethodHandleAccessorFactory.isSignaturePolymorphicMethod(method);\n- var mtype = methodType(method.getReturnType(), method.getParameterTypes());\n+ var mtype = methodType(method.getReturnType(), reflectionFactory.getExecutableSharedParameterTypes(method));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：反射调用原生方法时，所有原生方法都使用原生访问器（native accessor），包括签名多态方法（如MethodHandle.invokeExact），导致性能下降。优化后：1. 区分真正的原生方法和签名多态方法，仅对签名多态方法使用原生访问器，其他原生方法使用更高效的MethodHandle调用。2. 使用reflectionFactory.getExecutableSharedParameterTypes()缓存参数类型，避免重复获取。优化思路：通过精确识别签名多态方法，减少不必要的原生访问器使用，提升反射调用性能。"}
{"id": 566, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：在计算缓冲区大小时，总是为lib_name预留一个额外的字节（+2中的+1用于下划线，+1用于空终止符，但lib_name为null时也预留了下划线的空间）。优化后：通过引入underscore_len变量，仅在lib_name非空时才计算下划线的长度，精确分配所需内存，避免浪费一个字节。思路：消除不必要的内存分配，提高内存使用效率。", "original_code": "在计算缓冲区大小时，总是为lib_name预留一个额外的字节（+2中的+1用于下划线，+1用于空终止符，但lib_name为null时也预留了下划线的空间）。", "optimized_code": "- len = (lib_name != nullptr ? name_len : 0) + strlen(sym_name) + 2;\n+ len = strlen(sym_name) + underscore_len + name_len + 1;", "source_url": "https://github.com/openjdk/riscv-port/commit/3d0d0e62900653c4e395166a9ac48578b3dbc1f8", "code_v0_no_empty_lines": "在计算缓冲区大小时，总是为lib_name预留一个额外的字节（+2中的+1用于下划线，+1用于空终止符，但lib_name为null时也预留了下划线的空间）。", "code_v1_no_empty_lines": "- len = (lib_name != nullptr ? name_len : 0) + strlen(sym_name) + 2;\n+ len = strlen(sym_name) + underscore_len + name_len + 1;", "target": "- len = (lib_name != nullptr ? name_len : 0) + strlen(sym_name) + 2;\n+ len = strlen(sym_name) + underscore_len + name_len + 1;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在计算缓冲区大小时，总是为lib_name预留一个额外的字节（+2中的+1用于下划线，+1用于空终止符，但lib_name为null时也预留了下划线的空间）。优化后：通过引入underscore_len变量，仅在lib_name非空时才计算下划线的长度，精确分配所需内存，避免浪费一个字节。思路：消除不必要的内存分配，提高内存使用效率。"}
{"id": 567, "source": "riscv-dataset-excel", "optimization_type": "CDS内存优化+字符串共享优化", "optimization_description": "优化前：CDS归档时，对于未链接的旧类（old classes），其静态final字符串字段的默认值无法被正确归档到共享字符串表中，导致这些字符串无法在运行时共享，增加了内存占用。优化后：修改了add_dumped_interned_strings()方法，对于未链接的类，通过遍历其静态字段，检查并添加字符串对象到CDS归档字符串表中；对于已链接的类，保持原有逻辑。优化思路：确保所有类的interned字符串（包括旧类的静态final字符串字段）都能被正确归档到CDS共享字符串表中，提高字符串共享率，减少运行时内存占用。", "original_code": "CDS归档时，对于未链接的旧类（old classes），其静态final字符串字段的默认值无法被正确归档到共享字符串表中，导致这些字符串无法在运行时共享，增加了内存占用。", "optimized_code": "--- a/src/hotspot/share/cds/metaspaceShared.cpp\n+++ b/src/hotspot/share/cds/metaspaceShared.cpp\n@@ -1014,9 +1014,7 @@ void VM_PopulateDumpSharedSpace::dump_java_heap_objects(GrowableArray<Klass*>* k\n     Klass* k = klasses->at(i);\n     if (k->is_instance_klass()) {\n       InstanceKlass* ik = InstanceKlass::cast(k);\n-      if (ik->is_linked()) {\n-        ik->constants()->add_dumped_interned_strings();\n-      }\n+      ik->constants()->add_dumped_interned_strings();\n     }\n   }\n   if (_extra_interned_strings != nullptr) {\n--- a/src/hotspot/share/oops/constantPool.cpp\n+++ b/src/hotspot/share/oops/constantPool.cpp\n@@ -403,18 +405,38 @@ void ConstantPool::find_required_hidden_classes() {\n }\n \n void ConstantPool::add_dumped_interned_strings() {\n-  objArrayOop rr = resolved_references();\n-  if (rr != nullptr) {\n-    int rr_len = rr->length();\n-    for (int i = 0; i < rr_len; i++) {\n-      oop p = rr->obj_at(i);\n-      if (java_lang_String::is_instance(p) &&\n-          !ArchiveHeapWriter::is_string_too_large_to_archive(p)) {\n-        HeapShared::add_to_dumped_interned_strings(p);\n+  InstanceKlass* ik = pool_holder();\n+  if (!ik->is_linked()) {\n+    // resolved_references() doesn't exist yet, so we have no resolved CONSTANT_String entries. However,\n+    // some static final fields may have default values that were initialized when the class was parsed.\n+    // We need to enter those into the CDS archive strings table.\n+    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        fieldDescriptor& fd = fs.field_descriptor();\n+        if (fd.field_type() == T_OBJECT) {\n+          int offset = fd.offset();\n+          check_and_add_dumped_interned_string(ik->java_mirror()->obj_field(offset));\n+        }\n+      }\n+    }\n+  } else {\n+    objArrayOop rr = resolved_references();\n+    if (rr != nullptr) {\n+      int rr_len = rr->length();\n+      for (int i = 0; i < rr_len; i++) {\n+        check_and_add_dumped_interned_string(rr->obj_at(i));\n       }\n     }\n   }\n }\n+\n+void ConstantPool::check_and_add_dumped_interned_string(oop obj) {\n+  if (obj != nullptr && java_lang_String::is_instance(obj) &&\n+      !ArchiveHeapWriter::is_string_too_large_to_archive(obj)) {\n+    HeapShared::add_to_dumped_interned_strings(obj);\n+  }\n+}\n+", "source_url": "https://github.com/openjdk/riscv-port/commit/68b1b94d1be686037e2aaef57c0d9adc594fac7a", "code_v0_no_empty_lines": "CDS归档时，对于未链接的旧类（old classes），其静态final字符串字段的默认值无法被正确归档到共享字符串表中，导致这些字符串无法在运行时共享，增加了内存占用。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/cds/metaspaceShared.cpp\n+++ b/src/hotspot/share/cds/metaspaceShared.cpp\n@@ -1014,9 +1014,7 @@ void VM_PopulateDumpSharedSpace::dump_java_heap_objects(GrowableArray<Klass*>* k\n     Klass* k = klasses->at(i);\n     if (k->is_instance_klass()) {\n       InstanceKlass* ik = InstanceKlass::cast(k);\n-      if (ik->is_linked()) {\n-        ik->constants()->add_dumped_interned_strings();\n-      }\n+      ik->constants()->add_dumped_interned_strings();\n     }\n   }\n   if (_extra_interned_strings != nullptr) {\n--- a/src/hotspot/share/oops/constantPool.cpp\n+++ b/src/hotspot/share/oops/constantPool.cpp\n@@ -403,18 +405,38 @@ void ConstantPool::find_required_hidden_classes() {\n }\n \n void ConstantPool::add_dumped_interned_strings() {\n-  objArrayOop rr = resolved_references();\n-  if (rr != nullptr) {\n-    int rr_len = rr->length();\n-    for (int i = 0; i < rr_len; i++) {\n-      oop p = rr->obj_at(i);\n-      if (java_lang_String::is_instance(p) &&\n-          !ArchiveHeapWriter::is_string_too_large_to_archive(p)) {\n-        HeapShared::add_to_dumped_interned_strings(p);\n+  InstanceKlass* ik = pool_holder();\n+  if (!ik->is_linked()) {\n+    // resolved_references() doesn't exist yet, so we have no resolved CONSTANT_String entries. However,\n+    // some static final fields may have default values that were initialized when the class was parsed.\n+    // We need to enter those into the CDS archive strings table.\n+    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        fieldDescriptor& fd = fs.field_descriptor();\n+        if (fd.field_type() == T_OBJECT) {\n+          int offset = fd.offset();\n+          check_and_add_dumped_interned_string(ik->java_mirror()->obj_field(offset));\n+        }\n+      }\n+    }\n+  } else {\n+    objArrayOop rr = resolved_references();\n+    if (rr != nullptr) {\n+      int rr_len = rr->length();\n+      for (int i = 0; i < rr_len; i++) {\n+        check_and_add_dumped_interned_string(rr->obj_at(i));\n       }\n     }\n   }\n }\n+\n+void ConstantPool::check_and_add_dumped_interned_string(oop obj) {\n+  if (obj != nullptr && java_lang_String::is_instance(obj) &&\n+      !ArchiveHeapWriter::is_string_too_large_to_archive(obj)) {\n+    HeapShared::add_to_dumped_interned_strings(obj);\n+  }\n+}\n+", "target": "--- a/src/hotspot/share/cds/metaspaceShared.cpp\n+++ b/src/hotspot/share/cds/metaspaceShared.cpp\n@@ -1014,9 +1014,7 @@ void VM_PopulateDumpSharedSpace::dump_java_heap_objects(GrowableArray<Klass*>* k\n     Klass* k = klasses->at(i);\n     if (k->is_instance_klass()) {\n       InstanceKlass* ik = InstanceKlass::cast(k);\n-      if (ik->is_linked()) {\n-        ik->constants()->add_dumped_interned_strings();\n-      }\n+      ik->constants()->add_dumped_interned_strings();\n     }\n   }\n   if (_extra_interned_strings != nullptr) {\n--- a/src/hotspot/share/oops/constantPool.cpp\n+++ b/src/hotspot/share/oops/constantPool.cpp\n@@ -403,18 +405,38 @@ void ConstantPool::find_required_hidden_classes() {\n }\n \n void ConstantPool::add_dumped_interned_strings() {\n-  objArrayOop rr = resolved_references();\n-  if (rr != nullptr) {\n-    int rr_len = rr->length();\n-    for (int i = 0; i < rr_len; i++) {\n-      oop p = rr->obj_at(i);\n-      if (java_lang_String::is_instance(p) &&\n-          !ArchiveHeapWriter::is_string_too_large_to_archive(p)) {\n-        HeapShared::add_to_dumped_interned_strings(p);\n+  InstanceKlass* ik = pool_holder();\n+  if (!ik->is_linked()) {\n+    // resolved_references() doesn't exist yet, so we have no resolved CONSTANT_String entries. However,\n+    // some static final fields may have default values that were initialized when the class was parsed.\n+    // We need to enter those into the CDS archive strings table.\n+    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        fieldDescriptor& fd = fs.field_descriptor();\n+        if (fd.field_type() == T_OBJECT) {\n+          int offset = fd.offset();\n+          check_and_add_dumped_interned_string(ik->java_mirror()->obj_field(offset));\n+        }\n+      }\n+    }\n+  } else {\n+    objArrayOop rr = resolved_references();\n+    if (rr != nullptr) {\n+      int rr_len = rr->length();\n+      for (int i = 0; i < rr_len; i++) {\n+        check_and_add_dumped_interned_string(rr->obj_at(i));\n       }\n     }\n   }\n }\n+\n+void ConstantPool::check_and_add_dumped_interned_string(oop obj) {\n+  if (obj != nullptr && java_lang_String::is_instance(obj) &&\n+      !ArchiveHeapWriter::is_string_too_large_to_archive(obj)) {\n+    HeapShared::add_to_dumped_interned_strings(obj);\n+  }\n+}\n+", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CDS归档时，对于未链接的旧类（old classes），其静态final字符串字段的默认值无法被正确归档到共享字符串表中，导致这些字符串无法在运行时共享，增加了内存占用。优化后：修改了add_dumped_interned_strings()方法，对于未链接的类，通过遍历其静态字段，检查并添加字符串对象到CDS归档字符串表中；对于已链接的类，保持原有逻辑。优化思路：确保所有类的interned字符串（包括旧类的静态final字符串字段）都能被正确归档到CDS共享字符串表中，提高字符串共享率，减少运行时内存占用。"}
{"id": 568, "source": "riscv-dataset-excel", "optimization_type": "内存泄漏修复", "optimization_description": "优化前：ALLOW_C_FUNCTION宏调用方式不正确，可能导致内存泄漏。优化后：修正ALLOW_C_FUNCTION宏的参数传递方式，确保_init_error_msg指针被正确释放。思路：修复JVMCIEnv析构函数中的内存泄漏问题，确保动态分配的错误消息内存能够被正确释放。", "original_code": "ALLOW_C_FUNCTION宏调用方式不正确，可能导致内存泄漏。", "optimized_code": "-    ALLOW_C_FUNCTION(::free((void*) _init_error_msg));\n+    ALLOW_C_FUNCTION(::free, ::free((void*) _init_error_msg);)", "source_url": "https://github.com/openjdk/riscv-port/commit/b8233989e7605268dda908e6b639ca373789792b", "code_v0_no_empty_lines": "ALLOW_C_FUNCTION宏调用方式不正确，可能导致内存泄漏。", "code_v1_no_empty_lines": "-    ALLOW_C_FUNCTION(::free((void*) _init_error_msg));\n+    ALLOW_C_FUNCTION(::free, ::free((void*) _init_error_msg);)", "target": "-    ALLOW_C_FUNCTION(::free((void*) _init_error_msg));\n+    ALLOW_C_FUNCTION(::free, ::free((void*) _init_error_msg);)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ALLOW_C_FUNCTION宏调用方式不正确，可能导致内存泄漏。优化后：修正ALLOW_C_FUNCTION宏的参数传递方式，确保_init_error_msg指针被正确释放。思路：修复JVMCIEnv析构函数中的内存泄漏问题，确保动态分配的错误消息内存能够被正确释放。"}
{"id": 569, "source": "riscv-dataset-excel", "optimization_type": "指令优化+代码清理", "optimization_description": "优化前：存在多个冗余的字节反转函数（revb_h_h、revb_w_w、revb_h_helper、revb_h），代码重复且复杂，特别是非ZBB扩展路径使用循环和多次操作。优化后：1. 删除冗余函数，只保留核心的revb_w函数；2. 简化非ZBB路径的实现，使用更直接的位操作替代循环；3. 在汇编指令中直接内联rev8和移位操作，减少函数调用开销。优化思路：通过代码清理消除冗余，简化实现逻辑，利用RISC-V ZBB扩展的rev8指令提高性能，同时保持向后兼容。", "original_code": "存在多个冗余的字节反转函数（revb_h_h、revb_w_w、revb_h_helper、revb_h），代码重复且复杂，特别是非ZBB扩展路径使用循环和多次操作。", "optimized_code": "- void MacroAssembler::revb_h_h(Register Rd, Register Rs, Register tmp) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 48);\n    return;\n  }\n  ...\n}\n- void MacroAssembler::revb_w_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 32);\n    return;\n  }\n  ...\n}\n+ void MacroAssembler::revb_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 32);\n    return;\n  }\n  ...\n  sign_extend(Rd, Rd, 32);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/08d563ba15047020fd5f5fea80547e18898bbab2", "code_v0_no_empty_lines": "存在多个冗余的字节反转函数（revb_h_h、revb_w_w、revb_h_helper、revb_h），代码重复且复杂，特别是非ZBB扩展路径使用循环和多次操作。", "code_v1_no_empty_lines": "- void MacroAssembler::revb_h_h(Register Rd, Register Rs, Register tmp) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 48);\n    return;\n  }\n  ...\n}\n- void MacroAssembler::revb_w_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 32);\n    return;\n  }\n  ...\n}\n+ void MacroAssembler::revb_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 32);\n    return;\n  }\n  ...\n  sign_extend(Rd, Rd, 32);\n}", "target": "- void MacroAssembler::revb_h_h(Register Rd, Register Rs, Register tmp) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 48);\n    return;\n  }\n  ...\n}\n- void MacroAssembler::revb_w_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 32);\n    return;\n  }\n  ...\n}\n+ void MacroAssembler::revb_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n  if (UseZbb) {\n    rev8(Rd, Rs);\n    srai(Rd, Rd, 32);\n    return;\n  }\n  ...\n  sign_extend(Rd, Rd, 32);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：存在多个冗余的字节反转函数（revb_h_h、revb_w_w、revb_h_helper、revb_h），代码重复且复杂，特别是非ZBB扩展路径使用循环和多次操作。优化后：1. 删除冗余函数，只保留核心的revb_w函数；2. 简化非ZBB路径的实现，使用更直接的位操作替代循环；3. 在汇编指令中直接内联rev8和移位操作，减少函数调用开销。优化思路：通过代码清理消除冗余，简化实现逻辑，利用RISC-V ZBB扩展的rev8指令提高性能，同时保持向后兼容。"}
{"id": 570, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+条件移动优化", "optimization_description": "优化前：条件移动操作使用传统的分支跳转模式（Label L; cmp_branch; mv; bind(L)），存在分支预测失败和流水线停顿的开销。优化后：为RISC-V架构添加Zicond扩展指令支持，实现无分支的条件移动操作。通过czero_eqz/czero_nez指令，根据条件寄存器直接选择源值或保持目标值，避免了分支跳转。优化思路：利用RISC-V Zicond扩展指令实现硬件级条件移动，消除分支预测开销，提高条件操作的执行效率，特别适用于频繁的条件赋值场景。", "original_code": "条件移动操作使用传统的分支跳转模式（Label L; cmp_branch; mv; bind(L)），存在分支预测失败和流水线停顿的开销。", "optimized_code": "void C2_MacroAssembler::enc_cmove(int cmpFlag, Register op1, Register op2, Register dst, Register src) {\n-  Label L;\n-  cmp_branch(cmpFlag ^ (1 << neg_cond_bits), op1, op2, L);\n-  mv(dst, src);\n-  bind(L);\n+  bool is_unsigned = (cmpFlag & unsigned_branch_mask) == unsigned_branch_mask;\n+  int op_select = cmpFlag & (~unsigned_branch_mask);\n+\n+  switch (op_select) {\n+    case BoolTest::eq:\n+      cmov_eq(op1, op2, dst, src);\n+      break;\n+    case BoolTest::ne:\n+      cmov_ne(op1, op2, dst, src);\n+      break;\n+    case BoolTest::le:\n+      if (is_unsigned) {\n+        cmov_leu(op1, op2, dst, src);\n+      } else {\n+        cmov_le(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::ge:\n+      if (is_unsigned) {\n+        cmov_geu(op1, op2, dst, src);\n+      } else {\n+        cmov_ge(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::lt:\n+      if (is_unsigned) {\n+        cmov_ltu(op1, op2, dst, src);\n+      } else {\n+        cmov_lt(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::gt:\n+      if (is_unsigned) {\n+        cmov_gtu(op1, op2, dst, src);\n+      } else {\n+        cmov_gt(op1, op2, dst, src);\n+      }\n+      break;\n+    default:\n+      assert(false, \"unsupported compare condition\");\n+      ShouldNotReachHere();\n+  }\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/edfe28541a6ed94357f873aa69778c7eba707cbb", "code_v0_no_empty_lines": "条件移动操作使用传统的分支跳转模式（Label L; cmp_branch; mv; bind(L)），存在分支预测失败和流水线停顿的开销。", "code_v1_no_empty_lines": "void C2_MacroAssembler::enc_cmove(int cmpFlag, Register op1, Register op2, Register dst, Register src) {\n-  Label L;\n-  cmp_branch(cmpFlag ^ (1 << neg_cond_bits), op1, op2, L);\n-  mv(dst, src);\n-  bind(L);\n+  bool is_unsigned = (cmpFlag & unsigned_branch_mask) == unsigned_branch_mask;\n+  int op_select = cmpFlag & (~unsigned_branch_mask);\n+\n+  switch (op_select) {\n+    case BoolTest::eq:\n+      cmov_eq(op1, op2, dst, src);\n+      break;\n+    case BoolTest::ne:\n+      cmov_ne(op1, op2, dst, src);\n+      break;\n+    case BoolTest::le:\n+      if (is_unsigned) {\n+        cmov_leu(op1, op2, dst, src);\n+      } else {\n+        cmov_le(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::ge:\n+      if (is_unsigned) {\n+        cmov_geu(op1, op2, dst, src);\n+      } else {\n+        cmov_ge(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::lt:\n+      if (is_unsigned) {\n+        cmov_ltu(op1, op2, dst, src);\n+      } else {\n+        cmov_lt(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::gt:\n+      if (is_unsigned) {\n+        cmov_gtu(op1, op2, dst, src);\n+      } else {\n+        cmov_gt(op1, op2, dst, src);\n+      }\n+      break;\n+    default:\n+      assert(false, \"unsupported compare condition\");\n+      ShouldNotReachHere();\n+  }\n }", "target": "void C2_MacroAssembler::enc_cmove(int cmpFlag, Register op1, Register op2, Register dst, Register src) {\n-  Label L;\n-  cmp_branch(cmpFlag ^ (1 << neg_cond_bits), op1, op2, L);\n-  mv(dst, src);\n-  bind(L);\n+  bool is_unsigned = (cmpFlag & unsigned_branch_mask) == unsigned_branch_mask;\n+  int op_select = cmpFlag & (~unsigned_branch_mask);\n+\n+  switch (op_select) {\n+    case BoolTest::eq:\n+      cmov_eq(op1, op2, dst, src);\n+      break;\n+    case BoolTest::ne:\n+      cmov_ne(op1, op2, dst, src);\n+      break;\n+    case BoolTest::le:\n+      if (is_unsigned) {\n+        cmov_leu(op1, op2, dst, src);\n+      } else {\n+        cmov_le(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::ge:\n+      if (is_unsigned) {\n+        cmov_geu(op1, op2, dst, src);\n+      } else {\n+        cmov_ge(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::lt:\n+      if (is_unsigned) {\n+        cmov_ltu(op1, op2, dst, src);\n+      } else {\n+        cmov_lt(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::gt:\n+      if (is_unsigned) {\n+        cmov_gtu(op1, op2, dst, src);\n+      } else {\n+        cmov_gt(op1, op2, dst, src);\n+      }\n+      break;\n+    default:\n+      assert(false, \"unsupported compare condition\");\n+      ShouldNotReachHere();\n+  }\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：条件移动操作使用传统的分支跳转模式（Label L; cmp_branch; mv; bind(L)），存在分支预测失败和流水线停顿的开销。优化后：为RISC-V架构添加Zicond扩展指令支持，实现无分支的条件移动操作。通过czero_eqz/czero_nez指令，根据条件寄存器直接选择源值或保持目标值，避免了分支跳转。优化思路：利用RISC-V Zicond扩展指令实现硬件级条件移动，消除分支预测开销，提高条件操作的执行效率，特别适用于频繁的条件赋值场景。"}
{"id": 571, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：临时直接缓冲区通过ByteBuffer.allocateDirect()分配，会占用直接内存上限配额，可能导致内存限制过早触发。优化后：通过unsafe.allocateMemory()直接分配内存，然后通过新增的JavaNioAccess.newDirectByteBuffer()接口创建DirectByteBuffer，这样创建的临时缓冲区不计入直接内存上限。优化思路：分离临时缓冲区的内存分配与配额管理，避免临时缓冲区影响应用程序的正常直接内存使用。", "original_code": "临时直接缓冲区通过ByteBuffer.allocateDirect()分配，会占用直接内存上限配额，可能导致内存限制过早触发。", "optimized_code": "1. 在Util.java中修改getTemporaryDirectBuffer方法：\n- return ByteBuffer.allocateDirect(size);\n+ long addr = unsafe.allocateMemory(size);\n+ return NIO_ACCESS.newDirectByteBuffer(addr, size);\n\n2. 在Util.java中修改free方法：\n- ((DirectBuffer)buf).cleaner().clean();\n+ unsafe.freeMemory(((DirectBuffer)buf).address());", "source_url": "https://github.com/openjdk/riscv-port/commit/0312694c46b4fb3455cde2e4d1f8746ad4df8548", "code_v0_no_empty_lines": "临时直接缓冲区通过ByteBuffer.allocateDirect()分配，会占用直接内存上限配额，可能导致内存限制过早触发。", "code_v1_no_empty_lines": "1. 在Util.java中修改getTemporaryDirectBuffer方法：\n- return ByteBuffer.allocateDirect(size);\n+ long addr = unsafe.allocateMemory(size);\n+ return NIO_ACCESS.newDirectByteBuffer(addr, size);\n\n2. 在Util.java中修改free方法：\n- ((DirectBuffer)buf).cleaner().clean();\n+ unsafe.freeMemory(((DirectBuffer)buf).address());", "target": "1. 在Util.java中修改getTemporaryDirectBuffer方法：\n- return ByteBuffer.allocateDirect(size);\n+ long addr = unsafe.allocateMemory(size);\n+ return NIO_ACCESS.newDirectByteBuffer(addr, size);\n\n2. 在Util.java中修改free方法：\n- ((DirectBuffer)buf).cleaner().clean();\n+ unsafe.freeMemory(((DirectBuffer)buf).address());", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：临时直接缓冲区通过ByteBuffer.allocateDirect()分配，会占用直接内存上限配额，可能导致内存限制过早触发。优化后：通过unsafe.allocateMemory()直接分配内存，然后通过新增的JavaNioAccess.newDirectByteBuffer()接口创建DirectByteBuffer，这样创建的临时缓冲区不计入直接内存上限。优化思路：分离临时缓冲区的内存分配与配额管理，避免临时缓冲区影响应用程序的正常直接内存使用。"}
{"id": 572, "source": "riscv-dataset-excel", "optimization_type": "算法优化+向量化优化", "optimization_description": "优化前：AES/CTR模式在处理大数据负载时，直接调用implCrypt方法，无法有效触发编译器向量化优化（如AES-NI指令集）。优化后：引入chunkSize（块大小*6400），将大数据分割成固定大小的块循环处理，确保每个块达到编译器触发向量化优化的阈值。优化思路：通过分块处理，让编译器能够识别并应用硬件加速指令，显著提升大负载下的AES/CTR加密性能。", "original_code": "AES/CTR模式在处理大数据负载时，直接调用implCrypt方法，无法有效触发编译器向量化优化（如AES-NI指令集）。", "optimized_code": "private final int chunkSize;\n...\nchunkSize = blockSize * 6400;\n...\nint processed = 0;\nfor (;  len > chunkSize; inOff += chunkSize, outOff += chunkSize,\n    len -= chunkSize) {\n    processed += implCrypt(in, inOff, chunkSize, out, outOff);\n}\nprocessed += implCrypt(in, inOff, len, out, outOff);\nreturn processed;", "source_url": "https://github.com/openjdk/riscv-port/commit/75f3ec77e46831725ef927f0dda16a4dfd24b9a7", "code_v0_no_empty_lines": "AES/CTR模式在处理大数据负载时，直接调用implCrypt方法，无法有效触发编译器向量化优化（如AES-NI指令集）。", "code_v1_no_empty_lines": "private final int chunkSize;\n...\nchunkSize = blockSize * 6400;\n...\nint processed = 0;\nfor (;  len > chunkSize; inOff += chunkSize, outOff += chunkSize,\n    len -= chunkSize) {\n    processed += implCrypt(in, inOff, chunkSize, out, outOff);\n}\nprocessed += implCrypt(in, inOff, len, out, outOff);\nreturn processed;", "target": "private final int chunkSize;\n...\nchunkSize = blockSize * 6400;\n...\nint processed = 0;\nfor (;  len > chunkSize; inOff += chunkSize, outOff += chunkSize,\n    len -= chunkSize) {\n    processed += implCrypt(in, inOff, chunkSize, out, outOff);\n}\nprocessed += implCrypt(in, inOff, len, out, outOff);\nreturn processed;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AES/CTR模式在处理大数据负载时，直接调用implCrypt方法，无法有效触发编译器向量化优化（如AES-NI指令集）。优化后：引入chunkSize（块大小*6400），将大数据分割成固定大小的块循环处理，确保每个块达到编译器触发向量化优化的阈值。优化思路：通过分块处理，让编译器能够识别并应用硬件加速指令，显著提升大负载下的AES/CTR加密性能。"}
{"id": 573, "source": "riscv-dataset-excel", "optimization_type": "反射性能优化", "optimization_description": "优化前：反射过滤器包含System.security字段，导致每次反射访问System类时都需要检查该字段过滤规则。优化后：移除System.security字段的反射过滤器，减少反射调用时的过滤检查开销，提升反射性能。思路：通过清理不必要的反射过滤器，简化反射访问路径，减少运行时检查。", "original_code": "反射过滤器包含System.security字段，导致每次反射访问System类时都需要检查该字段过滤规则。", "optimized_code": "-            System.class, Set.of(\"security\")", "source_url": "https://github.com/openjdk/riscv-port/commit/35bd2f354ea50ccda325ac0c0b7d2fe66692d940", "code_v0_no_empty_lines": "反射过滤器包含System.security字段，导致每次反射访问System类时都需要检查该字段过滤规则。", "code_v1_no_empty_lines": "-            System.class, Set.of(\"security\")", "target": "-            System.class, Set.of(\"security\")", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：反射过滤器包含System.security字段，导致每次反射访问System类时都需要检查该字段过滤规则。优化后：移除System.security字段的反射过滤器，减少反射调用时的过滤检查开销，提升反射性能。思路：通过清理不必要的反射过滤器，简化反射访问路径，减少运行时检查。"}
{"id": 574, "source": "riscv-dataset-excel", "optimization_type": "代码清理/性能回归测试", "optimization_description": "优化前：存在基于RISC-V向量扩展（RVV）实现的ExpandBits/CompressBits intrinsics，用于Java的Integer/Long.compress/expand方法，但性能未达预期。优化后：完全移除了这些intrinsics实现，包括C2_MacroAssembler中的compress_bits_v/expand_bits_v函数、相关头文件声明、AD文件中的寄存器定义和匹配规则。优化思路：根据提交信息'verify perf of ExpandBits/CompressBits'，这是性能回归测试后的清理操作，移除低效实现以避免性能损失，让相关操作回退到默认的非向量化实现。", "original_code": "存在基于RISC-V向量扩展（RVV）实现的ExpandBits/CompressBits intrinsics，用于Java的Integer/Long.compress/expand方法，但性能未达预期。", "optimized_code": "-void C2_MacroAssembler::compress_bits_v(Register dst, Register src, Register mask, bool is_long) {\n-  Assembler::SEW sew = is_long ? Assembler::e64 : Assembler::e32;\n-  // intrinsic is enabled when MaxVectorSize >= 16\n-  Assembler::LMUL lmul = is_long ? Assembler::m4 : Assembler::m2;\n-  long len = is_long ? 64 : 32;\n-\n-  // load the src data(in bits) to be compressed.\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_s_x(v0, src);\n-  // reset the src data(in bytes) to zero.\n-  mv(t0, len);\n-  vsetvli(x0, t0, Assembler::e8, lmul);\n-  vmv_v_i(v4, 0);\n-  // convert the src data from bits to bytes.\n-  vmerge_vim(v4, v4, 1); // v0 as the implicit mask register\n-  // reset the dst data(in bytes) to zero.\n-  vmv_v_i(v8, 0);\n-  // load the mask data(in bits).\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_s_x(v0, mask);\n-  // compress the src data(in bytes) to dst(in bytes).\n-  vsetvli(x0, t0, Assembler::e8, lmul);\n-  vcompress_vm(v8, v4, v0);\n-  // convert the dst data from bytes to bits.\n-  vmseq_vi(v0, v8, 1);\n-  // store result back.\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_x_s(dst, v0);\n-}\n-\n-void C2_MacroAssembler::compress_bits_i_v(Register dst, Register src, Register mask) {\n-  compress_bits_v(dst, src, mask, /* is_long */ false);\n-}\n-\n-void C2_MacroAssembler::compress_bits_l_v(Register dst, Register src, Register mask) {\n-  compress_bits_v(dst, src, mask, /* is_long */ true);\n-}\n-\n-void C2_MacroAssembler::expand_bits_v(Register dst, Register src, Register mask, bool is_long) {\n-  Assembler::SEW sew = is_long ? Assembler::e64 : Assembler::e32;\n-  // intrinsic is enabled when MaxVectorSize >= 16\n-  Assembler::LMUL lmul = is_long ? Assembler::m4 : Assembler::m2;\n-  long len = is_long ? 64 : 32;\n-\n-  // load the src data(in bits) to be expanded.\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_s_x(v0, src);\n-  // reset the src data(in bytes) to zero.\n-  mv(t0, len);\n-  vsetvli(x0, t0, Assembler::e8, lmul);\n-  vmv_v_i(v4, 0);\n-  // convert the src data from bits to bytes.\n-  vmerge_vim(v4, v4, 1); // v0 as implicit mask register\n-  // reset the dst data(in bytes) to zero.\n-  vmv_v_i(v12, 0);\n-  // load the mask data(in bits).\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_s_x(v0, mask);\n-  // expand the src data(in bytes) to dst(in bytes).\n-  vsetvli(x0, t0, Assembler::e8, lmul);\n-  viota_m(v8, v0);\n-  vrgather_vv(v12, v4, v8, VectorMask::v0_t); // v0 as implicit mask register\n-  // convert the dst data from bytes to bits.\n-  vmseq_vi(v0, v12, 1);\n-  // store result back.\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_x_s(dst, v0);\n-}\n-\n-void C2_MacroAssembler::expand_bits_i_v(Register dst, Register src, Register mask) {\n-  expand_bits_v(dst, src, mask, /* is_long */ false);\n-}\n-\n-void C2_MacroAssembler::expand_bits_l_v(Register dst, Register src, Register mask) {\n-  expand_bits_v(dst, src, mask, /* is_long */ true);\n-}", "source_url": "https://github.com/openjdk/riscv-port/commit/133419177d8ddcfafe0b2bd25ee918bdb3b16d3f", "code_v0_no_empty_lines": "存在基于RISC-V向量扩展（RVV）实现的ExpandBits/CompressBits intrinsics，用于Java的Integer/Long.compress/expand方法，但性能未达预期。", "code_v1_no_empty_lines": "-void C2_MacroAssembler::compress_bits_v(Register dst, Register src, Register mask, bool is_long) {\n-  Assembler::SEW sew = is_long ? Assembler::e64 : Assembler::e32;\n-  // intrinsic is enabled when MaxVectorSize >= 16\n-  Assembler::LMUL lmul = is_long ? Assembler::m4 : Assembler::m2;\n-  long len = is_long ? 64 : 32;\n-\n-  // load the src data(in bits) to be compressed.\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_s_x(v0, src);\n-  // reset the src data(in bytes) to zero.\n-  mv(t0, len);\n-  vsetvli(x0, t0, Assembler::e8, lmul);\n-  vmv_v_i(v4, 0);\n-  // convert the src data from bits to bytes.\n-  vmerge_vim(v4, v4, 1); // v0 as the implicit mask register\n-  // reset the dst data(in bytes) to zero.\n-  vmv_v_i(v8, 0);\n-  // load the mask data(in bits).\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_s_x(v0, mask);\n-  // compress the src data(in bytes) to dst(in bytes).\n-  vsetvli(x0, t0, Assembler::e8, lmul);\n-  vcompress_vm(v8, v4, v0);\n-  // convert the dst data from bytes to bits.\n-  vmseq_vi(v0, v8, 1);\n-  // store result back.\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_x_s(dst, v0);\n-}\n-\n-void C2_MacroAssembler::compress_bits_i_v(Register dst, Register src, Register mask) {\n-  compress_bits_v(dst, src, mask, /* is_long */ false);\n-}\n-\n-void C2_MacroAssembler::compress_bits_l_v(Register dst, Register src, Register mask) {\n-  compress_bits_v(dst, src, mask, /* is_long */ true);\n-}\n-\n-void C2_MacroAssembler::expand_bits_v(Register dst, Register src, Register mask, bool is_long) {\n-  Assembler::SEW sew = is_long ? Assembler::e64 : Assembler::e32;\n-  // intrinsic is enabled when MaxVectorSize >= 16\n-  Assembler::LMUL lmul = is_long ? Assembler::m4 : Assembler::m2;\n-  long len = is_long ? 64 : 32;\n-\n-  // load the src data(in bits) to be expanded.\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_s_x(v0, src);\n-  // reset the src data(in bytes) to zero.\n-  mv(t0, len);\n-  vsetvli(x0, t0, Assembler::e8, lmul);\n-  vmv_v_i(v4, 0);\n-  // convert the src data from bits to bytes.\n-  vmerge_vim(v4, v4, 1); // v0 as implicit mask register\n-  // reset the dst data(in bytes) to zero.\n-  vmv_v_i(v12, 0);\n-  // load the mask data(in bits).\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_s_x(v0, mask);\n-  // expand the src data(in bytes) to dst(in bytes).\n-  vsetvli(x0, t0, Assembler::e8, lmul);\n-  viota_m(v8, v0);\n-  vrgather_vv(v12, v4, v8, VectorMask::v0_t); // v0 as implicit mask register\n-  // convert the dst data from bytes to bits.\n-  vmseq_vi(v0, v12, 1);\n-  // store result back.\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_x_s(dst, v0);\n-}\n-\n-void C2_MacroAssembler::expand_bits_i_v(Register dst, Register src, Register mask) {\n-  expand_bits_v(dst, src, mask, /* is_long */ false);\n-}\n-\n-void C2_MacroAssembler::expand_bits_l_v(Register dst, Register src, Register mask) {\n-  expand_bits_v(dst, src, mask, /* is_long */ true);\n-}", "target": "-void C2_MacroAssembler::compress_bits_v(Register dst, Register src, Register mask, bool is_long) {\n-  Assembler::SEW sew = is_long ? Assembler::e64 : Assembler::e32;\n-  // intrinsic is enabled when MaxVectorSize >= 16\n-  Assembler::LMUL lmul = is_long ? Assembler::m4 : Assembler::m2;\n-  long len = is_long ? 64 : 32;\n-\n-  // load the src data(in bits) to be compressed.\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_s_x(v0, src);\n-  // reset the src data(in bytes) to zero.\n-  mv(t0, len);\n-  vsetvli(x0, t0, Assembler::e8, lmul);\n-  vmv_v_i(v4, 0);\n-  // convert the src data from bits to bytes.\n-  vmerge_vim(v4, v4, 1); // v0 as the implicit mask register\n-  // reset the dst data(in bytes) to zero.\n-  vmv_v_i(v8, 0);\n-  // load the mask data(in bits).\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_s_x(v0, mask);\n-  // compress the src data(in bytes) to dst(in bytes).\n-  vsetvli(x0, t0, Assembler::e8, lmul);\n-  vcompress_vm(v8, v4, v0);\n-  // convert the dst data from bytes to bits.\n-  vmseq_vi(v0, v8, 1);\n-  // store result back.\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_x_s(dst, v0);\n-}\n-\n-void C2_MacroAssembler::compress_bits_i_v(Register dst, Register src, Register mask) {\n-  compress_bits_v(dst, src, mask, /* is_long */ false);\n-}\n-\n-void C2_MacroAssembler::compress_bits_l_v(Register dst, Register src, Register mask) {\n-  compress_bits_v(dst, src, mask, /* is_long */ true);\n-}\n-\n-void C2_MacroAssembler::expand_bits_v(Register dst, Register src, Register mask, bool is_long) {\n-  Assembler::SEW sew = is_long ? Assembler::e64 : Assembler::e32;\n-  // intrinsic is enabled when MaxVectorSize >= 16\n-  Assembler::LMUL lmul = is_long ? Assembler::m4 : Assembler::m2;\n-  long len = is_long ? 64 : 32;\n-\n-  // load the src data(in bits) to be expanded.\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_s_x(v0, src);\n-  // reset the src data(in bytes) to zero.\n-  mv(t0, len);\n-  vsetvli(x0, t0, Assembler::e8, lmul);\n-  vmv_v_i(v4, 0);\n-  // convert the src data from bits to bytes.\n-  vmerge_vim(v4, v4, 1); // v0 as implicit mask register\n-  // reset the dst data(in bytes) to zero.\n-  vmv_v_i(v12, 0);\n-  // load the mask data(in bits).\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_s_x(v0, mask);\n-  // expand the src data(in bytes) to dst(in bytes).\n-  vsetvli(x0, t0, Assembler::e8, lmul);\n-  viota_m(v8, v0);\n-  vrgather_vv(v12, v4, v8, VectorMask::v0_t); // v0 as implicit mask register\n-  // convert the dst data from bytes to bits.\n-  vmseq_vi(v0, v12, 1);\n-  // store result back.\n-  vsetivli(x0, 1, sew, Assembler::m1);\n-  vmv_x_s(dst, v0);\n-}\n-\n-void C2_MacroAssembler::expand_bits_i_v(Register dst, Register src, Register mask) {\n-  expand_bits_v(dst, src, mask, /* is_long */ false);\n-}\n-\n-void C2_MacroAssembler::expand_bits_l_v(Register dst, Register src, Register mask) {\n-  expand_bits_v(dst, src, mask, /* is_long */ true);\n-}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：存在基于RISC-V向量扩展（RVV）实现的ExpandBits/CompressBits intrinsics，用于Java的Integer/Long.compress/expand方法，但性能未达预期。优化后：完全移除了这些intrinsics实现，包括C2_MacroAssembler中的compress_bits_v/expand_bits_v函数、相关头文件声明、AD文件中的寄存器定义和匹配规则。优化思路：根据提交信息'verify perf of ExpandBits/CompressBits'，这是性能回归测试后的清理操作，移除低效实现以避免性能损失，让相关操作回退到默认的非向量化实现。"}
{"id": 575, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+向量化优化", "optimization_description": "优化前：长整型向量乘法使用通用指令序列，开销较高（ins_cost=500）。优化后：当输入向量元素可表示为32位无符号整数（如通过AndV掩码或URShiftV右移）时，使用x86 VPMULUDQ指令；当输入可表示为32位有符号整数（如通过VectorCastI2X或RShiftV右移）时，使用VPMULDQ指令。优化思路：利用输入数据范围信息，选择更高效的专用SIMD指令，降低指令开销（ins_cost从500降至100），提升向量乘法性能。", "original_code": "长整型向量乘法使用通用指令序列，开销较高（ins_cost=500）。", "optimized_code": "instruct vmuludq_reg(vec dst, vec src1, vec src2) %{\n  predicate(UseAVX > 0 && n->as_MulVL()->has_uint_inputs());\n  match(Set dst (MulVL src1 src2));\n  ins_cost(100);\n  format %{ \"vpmuludq $dst,$src1,$src2\t! muludq packedL\" %}", "source_url": "https://github.com/openjdk/riscv-port/commit/dc9a6ef6100d73a431cd0cfa2c252acf7743f8a3", "code_v0_no_empty_lines": "长整型向量乘法使用通用指令序列，开销较高（ins_cost=500）。", "code_v1_no_empty_lines": "instruct vmuludq_reg(vec dst, vec src1, vec src2) %{\n  predicate(UseAVX > 0 && n->as_MulVL()->has_uint_inputs());\n  match(Set dst (MulVL src1 src2));\n  ins_cost(100);\n  format %{ \"vpmuludq $dst,$src1,$src2\t! muludq packedL\" %}", "target": "instruct vmuludq_reg(vec dst, vec src1, vec src2) %{\n  predicate(UseAVX > 0 && n->as_MulVL()->has_uint_inputs());\n  match(Set dst (MulVL src1 src2));\n  ins_cost(100);\n  format %{ \"vpmuludq $dst,$src1,$src2\t! muludq packedL\" %}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：长整型向量乘法使用通用指令序列，开销较高（ins_cost=500）。优化后：当输入向量元素可表示为32位无符号整数（如通过AndV掩码或URShiftV右移）时，使用x86 VPMULUDQ指令；当输入可表示为32位有符号整数（如通过VectorCastI2X或RShiftV右移）时，使用VPMULDQ指令。优化思路：利用输入数据范围信息，选择更高效的专用SIMD指令，降低指令开销（ins_cost从500降至100），提升向量乘法性能。"}
{"id": 576, "source": "riscv-dataset-excel", "optimization_type": "算法优化+向量化优化", "optimization_description": "优化前：AES/CBC加密解密时，无论数据大小都直接调用implEncrypt/implDecrypt方法，对于大数据量无法触发硬件向量化优化。优化后：引入chunkSize（块大小*6400），将大数据分成多个chunk处理，每个chunk大小足够触发硬件向量化优化（如AES-NI指令集）。优化思路：通过分块处理大数据，让每个chunk达到硬件向量化优化的阈值，提高大负载下的AES/CBC性能。", "original_code": "AES/CBC加密解密时，无论数据大小都直接调用implEncrypt/implDecrypt方法，对于大数据量无法触发硬件向量化优化。", "optimized_code": "int encrypt(byte[] plain, int plainOffset, int plainLen,\n        ArrayUtil.blockSizeCheck(plainLen, blockSize);\n        ArrayUtil.nullAndBoundsCheck(plain, plainOffset, plainLen);\n        ArrayUtil.nullAndBoundsCheck(cipher, cipherOffset, plainLen);\n-        return implEncrypt(plain, plainOffset, plainLen,\n-                           cipher, cipherOffset);\n+        int processed = 0;\n+        for (;  plainLen > chunkSize; cipherOffset += chunkSize,\n+            plainOffset += chunkSize, plainLen -= chunkSize) {\n+            processed +=\n+               implEncrypt(plain, plainOffset, chunkSize, cipher, cipherOffset);\n+        }\n+        // note: above loop always leaves some data to process (more than zero,\n+        // less than or equal to chunkSize) so this last call can be\n+        // unconditional\n+        processed +=\n+            implEncrypt(plain, plainOffset, plainLen, cipher, cipherOffset);\n+        return processed;", "source_url": "https://github.com/openjdk/riscv-port/commit/d6b40d3033b306e2cefc12833bb4e99ae6e36008", "code_v0_no_empty_lines": "AES/CBC加密解密时，无论数据大小都直接调用implEncrypt/implDecrypt方法，对于大数据量无法触发硬件向量化优化。", "code_v1_no_empty_lines": "int encrypt(byte[] plain, int plainOffset, int plainLen,\n        ArrayUtil.blockSizeCheck(plainLen, blockSize);\n        ArrayUtil.nullAndBoundsCheck(plain, plainOffset, plainLen);\n        ArrayUtil.nullAndBoundsCheck(cipher, cipherOffset, plainLen);\n-        return implEncrypt(plain, plainOffset, plainLen,\n-                           cipher, cipherOffset);\n+        int processed = 0;\n+        for (;  plainLen > chunkSize; cipherOffset += chunkSize,\n+            plainOffset += chunkSize, plainLen -= chunkSize) {\n+            processed +=\n+               implEncrypt(plain, plainOffset, chunkSize, cipher, cipherOffset);\n+        }\n+        // note: above loop always leaves some data to process (more than zero,\n+        // less than or equal to chunkSize) so this last call can be\n+        // unconditional\n+        processed +=\n+            implEncrypt(plain, plainOffset, plainLen, cipher, cipherOffset);\n+        return processed;", "target": "int encrypt(byte[] plain, int plainOffset, int plainLen,\n        ArrayUtil.blockSizeCheck(plainLen, blockSize);\n        ArrayUtil.nullAndBoundsCheck(plain, plainOffset, plainLen);\n        ArrayUtil.nullAndBoundsCheck(cipher, cipherOffset, plainLen);\n-        return implEncrypt(plain, plainOffset, plainLen,\n-                           cipher, cipherOffset);\n+        int processed = 0;\n+        for (;  plainLen > chunkSize; cipherOffset += chunkSize,\n+            plainOffset += chunkSize, plainLen -= chunkSize) {\n+            processed +=\n+               implEncrypt(plain, plainOffset, chunkSize, cipher, cipherOffset);\n+        }\n+        // note: above loop always leaves some data to process (more than zero,\n+        // less than or equal to chunkSize) so this last call can be\n+        // unconditional\n+        processed +=\n+            implEncrypt(plain, plainOffset, plainLen, cipher, cipherOffset);\n+        return processed;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AES/CBC加密解密时，无论数据大小都直接调用implEncrypt/implDecrypt方法，对于大数据量无法触发硬件向量化优化。优化后：引入chunkSize（块大小*6400），将大数据分成多个chunk处理，每个chunk大小足够触发硬件向量化优化（如AES-NI指令集）。优化思路：通过分块处理大数据，让每个chunk达到硬件向量化优化的阈值，提高大负载下的AES/CBC性能。"}
{"id": 577, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+锁优化", "optimization_description": "优化前：ForkJoinPool在工作窃取时存在竞争增长问题，主要由于：1) 内存排序使用显式加载栅栏带来额外开销；2) 信号传播机制可能导致过度信号和虚假唤醒；3) 去激活机制容易误判导致不必要的重新激活；4) 状态管理不够清晰。\n\n优化后：1) 简化内存排序，使用有序写入替代显式加载栅栏，减少内存屏障开销；2) 优化信号传播，限制每个激活阶段只传播一次信号（针对InterruptibleTask），减少不必要的信号；3) 改进去激活机制，通过多次扫描减少误报重新激活；4) 明确状态位定义，增强状态管理清晰度。\n\n优化思路：通过减少不必要的同步操作、优化信号传播策略、改进状态管理机制，降低工作窃取时的竞争，提高ForkJoinPool在高并发场景下的性能。", "original_code": "ForkJoinPool在工作窃取时存在竞争增长问题，主要由于：1) 内存排序使用显式加载栅栏带来额外开销；2) 信号传播机制可能导致过度信号和虚假唤醒；3) 去激活机制容易误判导致不必要的重新激活；4) 状态管理不够清晰。", "optimized_code": "主要修改集中在ForkJoinPool.java中，涉及工作窃取算法、状态管理和信号传播机制的优化。关键代码片段包括：\n- 简化内存排序描述：从使用显式加载栅栏改为使用有序写入\n- 优化信号传播逻辑：限制每个激活阶段只传播一次信号（针对InterruptibleTask）\n- 改进去激活机制：减少误报重新激活，通过多次扫描\n- 增强状态管理：明确SHUTDOWN、STOP、CLEANED、TERMINATED状态位", "source_url": "https://github.com/openjdk/riscv-port/commit/18df6fd5ba93c3c2d5965c072d482dcf7cbfc675", "code_v0_no_empty_lines": "ForkJoinPool在工作窃取时存在竞争增长问题，主要由于：1) 内存排序使用显式加载栅栏带来额外开销；2) 信号传播机制可能导致过度信号和虚假唤醒；3) 去激活机制容易误判导致不必要的重新激活；4) 状态管理不够清晰。", "code_v1_no_empty_lines": "主要修改集中在ForkJoinPool.java中，涉及工作窃取算法、状态管理和信号传播机制的优化。关键代码片段包括：\n- 简化内存排序描述：从使用显式加载栅栏改为使用有序写入\n- 优化信号传播逻辑：限制每个激活阶段只传播一次信号（针对InterruptibleTask）\n- 改进去激活机制：减少误报重新激活，通过多次扫描\n- 增强状态管理：明确SHUTDOWN、STOP、CLEANED、TERMINATED状态位", "target": "主要修改集中在ForkJoinPool.java中，涉及工作窃取算法、状态管理和信号传播机制的优化。关键代码片段包括：\n- 简化内存排序描述：从使用显式加载栅栏改为使用有序写入\n- 优化信号传播逻辑：限制每个激活阶段只传播一次信号（针对InterruptibleTask）\n- 改进去激活机制：减少误报重新激活，通过多次扫描\n- 增强状态管理：明确SHUTDOWN、STOP、CLEANED、TERMINATED状态位", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ForkJoinPool在工作窃取时存在竞争增长问题，主要由于：1) 内存排序使用显式加载栅栏带来额外开销；2) 信号传播机制可能导致过度信号和虚假唤醒；3) 去激活机制容易误判导致不必要的重新激活；4) 状态管理不够清晰。\n\n优化后：1) 简化内存排序，使用有序写入替代显式加载栅栏，减少内存屏障开销；2) 优化信号传播，限制每个激活阶段只传播一次信号（针对InterruptibleTask），减少不必要的信号；3) 改进去激活机制，通过多次扫描减少误报重新激活；4) 明确状态位定义，增强状态管理清晰度。\n\n优化思路：通过减少不必要的同步操作、优化信号传播策略、改进状态管理机制，降低工作窃取时的竞争，提高ForkJoinPool在高并发场景下的性能。"}
{"id": 578, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化", "optimization_description": "优化前：使用synchronized块保护共享Context对象，通过inuse标志控制并发访问，每次调用都需要获取锁，在高并发场景下成为性能瓶颈。优化后：引入Semaphore机制（通过claim()/release()方法），将粗粒度锁替换为细粒度的并发控制，减少锁竞争，提高多线程下的可扩展性。优化思路：针对高vCPU数量的可扩展性问题，将同步机制从基于锁的互斥改为基于信号量的并发控制，降低线程间争用。", "original_code": "使用synchronized块保护共享Context对象，通过inuse标志控制并发访问，每次调用都需要获取锁，在高并发场景下成为性能瓶颈。", "optimized_code": "- synchronized (this.context) {\n-     con = this.context.inuse ? new Context() : this.context;\n-     con.reset(target, start, end, this.numberOfClosures);\n- }\n+ Context con = this.context;\n+ if (!con.claim()) {\n+     con = new Context();\n+ }\n+ con.reset(target, start, end, this.numberOfClosures);", "source_url": "https://github.com/openjdk/riscv-port/commit/78e5008e91610847bc11103e667fbe602b03d86a", "code_v0_no_empty_lines": "使用synchronized块保护共享Context对象，通过inuse标志控制并发访问，每次调用都需要获取锁，在高并发场景下成为性能瓶颈。", "code_v1_no_empty_lines": "- synchronized (this.context) {\n-     con = this.context.inuse ? new Context() : this.context;\n-     con.reset(target, start, end, this.numberOfClosures);\n- }\n+ Context con = this.context;\n+ if (!con.claim()) {\n+     con = new Context();\n+ }\n+ con.reset(target, start, end, this.numberOfClosures);", "target": "- synchronized (this.context) {\n-     con = this.context.inuse ? new Context() : this.context;\n-     con.reset(target, start, end, this.numberOfClosures);\n- }\n+ Context con = this.context;\n+ if (!con.claim()) {\n+     con = new Context();\n+ }\n+ con.reset(target, start, end, this.numberOfClosures);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用synchronized块保护共享Context对象，通过inuse标志控制并发访问，每次调用都需要获取锁，在高并发场景下成为性能瓶颈。优化后：引入Semaphore机制（通过claim()/release()方法），将粗粒度锁替换为细粒度的并发控制，减少锁竞争，提高多线程下的可扩展性。优化思路：针对高vCPU数量的可扩展性问题，将同步机制从基于锁的互斥改为基于信号量的并发控制，降低线程间争用。"}
{"id": 579, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化", "optimization_description": "优化前：使用volatile静态变量previousKey作为缓存，在多线程高并发场景下会成为性能瓶颈，因为所有线程共享同一个变量，频繁的读写操作导致缓存一致性开销和锁竞争。优化后：将previousKey改为ThreadLocal变量，每个线程拥有独立的缓存副本，消除了线程间的竞争，提高了在高vCPU环境下的可扩展性。优化思路：将共享缓存改为线程本地缓存，减少同步开销，提升并发性能。", "original_code": "使用volatile静态变量previousKey作为缓存，在多线程高并发场景下会成为性能瓶颈，因为所有线程共享同一个变量，频繁的读写操作导致缓存一致性开销和锁竞争。", "optimized_code": "-    private static volatile ServiceKey previousKey =\n-                                            new ServiceKey(\"\", \"\", false);\n+    private static final ThreadLocal<ServiceKey> previousKey =\n+        ThreadLocal.withInitial(() -> new ServiceKey(\"\",\"\", false));\n\n-        ServiceKey key = previousKey;\n+        ServiceKey key = previousKey.get();\n\n-            previousKey = key;\n+            previousKey.set(key);", "source_url": "https://github.com/openjdk/riscv-port/commit/4956a766213c3d76e13b98ac5d5efe5d4f553895", "code_v0_no_empty_lines": "使用volatile静态变量previousKey作为缓存，在多线程高并发场景下会成为性能瓶颈，因为所有线程共享同一个变量，频繁的读写操作导致缓存一致性开销和锁竞争。", "code_v1_no_empty_lines": "-    private static volatile ServiceKey previousKey =\n-                                            new ServiceKey(\"\", \"\", false);\n+    private static final ThreadLocal<ServiceKey> previousKey =\n+        ThreadLocal.withInitial(() -> new ServiceKey(\"\",\"\", false));\n\n-        ServiceKey key = previousKey;\n+        ServiceKey key = previousKey.get();\n\n-            previousKey = key;\n+            previousKey.set(key);", "target": "-    private static volatile ServiceKey previousKey =\n-                                            new ServiceKey(\"\", \"\", false);\n+    private static final ThreadLocal<ServiceKey> previousKey =\n+        ThreadLocal.withInitial(() -> new ServiceKey(\"\",\"\", false));\n\n-        ServiceKey key = previousKey;\n+        ServiceKey key = previousKey.get();\n\n-            previousKey = key;\n+            previousKey.set(key);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用volatile静态变量previousKey作为缓存，在多线程高并发场景下会成为性能瓶颈，因为所有线程共享同一个变量，频繁的读写操作导致缓存一致性开销和锁竞争。优化后：将previousKey改为ThreadLocal变量，每个线程拥有独立的缓存副本，消除了线程间的竞争，提高了在高vCPU环境下的可扩展性。优化思路：将共享缓存改为线程本地缓存，减少同步开销，提升并发性能。"}
{"id": 580, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：在merge_multidefs函数中创建了ResourceMark对象，这会分配内存资源并在函数结束时自动释放。优化后：移除了ResourceMark对象创建，避免了不必要的内存分配和释放开销。思路：通过分析发现该函数中并没有实际需要ResourceMark保护的资源分配，移除它可以减少内存管理开销，提高编译器运行效率。", "original_code": "在merge_multidefs函数中创建了ResourceMark对象，这会分配内存资源并在函数结束时自动释放。", "optimized_code": "-  ResourceMark rm;", "source_url": "https://github.com/openjdk/riscv-port/commit/93aa7e2fcf87c4dc62de4ea71be543ee677b11be", "code_v0_no_empty_lines": "在merge_multidefs函数中创建了ResourceMark对象，这会分配内存资源并在函数结束时自动释放。", "code_v1_no_empty_lines": "-  ResourceMark rm;", "target": "-  ResourceMark rm;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在merge_multidefs函数中创建了ResourceMark对象，这会分配内存资源并在函数结束时自动释放。优化后：移除了ResourceMark对象创建，避免了不必要的内存分配和释放开销。思路：通过分析发现该函数中并没有实际需要ResourceMark保护的资源分配，移除它可以减少内存管理开销，提高编译器运行效率。"}
{"id": 581, "source": "riscv-dataset-excel", "optimization_type": "测试用例添加", "optimization_description": "优化前：缺少验证C2编译器在形态变化后执行双态内联的测试用例。优化后：新增测试文件InlineBimorphicVirtualCallAfterMorphismChanged.java，验证当调用点在第三层编译时为单态，但在后续变为双态时，C2编译器能否正确执行双态内联。思路：通过创建测试用例来验证编译器的内联优化行为，确保编译器在运行时类型信息变化时仍能正确优化虚拟调用。", "original_code": "缺少验证C2编译器在形态变化后执行双态内联的测试用例。", "optimized_code": "new file mode 100644\ntest/hotspot/jtreg/compiler/inlining/InlineBimorphicVirtualCallAfterMorphismChanged.java", "source_url": "https://github.com/openjdk/riscv-port/commit/5ccd5106e023dbb47473e8914035c811e0cc6ee1", "code_v0_no_empty_lines": "缺少验证C2编译器在形态变化后执行双态内联的测试用例。", "code_v1_no_empty_lines": "new file mode 100644\ntest/hotspot/jtreg/compiler/inlining/InlineBimorphicVirtualCallAfterMorphismChanged.java", "target": "new file mode 100644\ntest/hotspot/jtreg/compiler/inlining/InlineBimorphicVirtualCallAfterMorphismChanged.java", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：缺少验证C2编译器在形态变化后执行双态内联的测试用例。优化后：新增测试文件InlineBimorphicVirtualCallAfterMorphismChanged.java，验证当调用点在第三层编译时为单态，但在后续变为双态时，C2编译器能否正确执行双态内联。思路：通过创建测试用例来验证编译器的内联优化行为，确保编译器在运行时类型信息变化时仍能正确优化虚拟调用。"}
{"id": 582, "source": "riscv-dataset-excel", "optimization_type": "调试/验证优化", "optimization_description": "优化前：当启用-XX:+VerifyActivationFrameSize标志时，RISC-V平台的栈帧大小验证功能未实现（Unimplemented()），导致该调试/验证功能在RISC-V上不可用。优化后：实现了完整的栈帧大小验证逻辑，计算当前栈帧大小（fp-esp），减去最小帧大小要求，如果结果为负（栈帧太小），则触发stop(\"broken stack frame\")停止执行，否则继续正常执行。优化思路：为RISC-V平台补全调试功能，确保在启用验证标志时能够正确检测栈帧大小问题，提高调试和错误检测能力。", "original_code": "当启用-XX:+VerifyActivationFrameSize标志时，RISC-V平台的栈帧大小验证功能未实现（Unimplemented()），导致该调试/验证功能在RISC-V上不可用。", "optimized_code": "-    Unimplemented();\n+    Label L;\n+    sub(t1, fp, esp);\n+    int min_frame_size =\n+      (frame::link_offset - frame::interpreter_frame_initial_sp_offset + frame::metadata_words) * wordSize;\n+    sub(t1, t1, min_frame_size);\n+    bgez(t1, L);\n+    stop(\"broken stack frame\");\n+    bind(L);", "source_url": "https://github.com/openjdk/riscv-port/commit/4fbf272017d2f6933e66f8a67cb88e3ffc42339e", "code_v0_no_empty_lines": "当启用-XX:+VerifyActivationFrameSize标志时，RISC-V平台的栈帧大小验证功能未实现（Unimplemented()），导致该调试/验证功能在RISC-V上不可用。", "code_v1_no_empty_lines": "-    Unimplemented();\n+    Label L;\n+    sub(t1, fp, esp);\n+    int min_frame_size =\n+      (frame::link_offset - frame::interpreter_frame_initial_sp_offset + frame::metadata_words) * wordSize;\n+    sub(t1, t1, min_frame_size);\n+    bgez(t1, L);\n+    stop(\"broken stack frame\");\n+    bind(L);", "target": "-    Unimplemented();\n+    Label L;\n+    sub(t1, fp, esp);\n+    int min_frame_size =\n+      (frame::link_offset - frame::interpreter_frame_initial_sp_offset + frame::metadata_words) * wordSize;\n+    sub(t1, t1, min_frame_size);\n+    bgez(t1, L);\n+    stop(\"broken stack frame\");\n+    bind(L);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当启用-XX:+VerifyActivationFrameSize标志时，RISC-V平台的栈帧大小验证功能未实现（Unimplemented()），导致该调试/验证功能在RISC-V上不可用。优化后：实现了完整的栈帧大小验证逻辑，计算当前栈帧大小（fp-esp），减去最小帧大小要求，如果结果为负（栈帧太小），则触发stop(\"broken stack frame\")停止执行，否则继续正常执行。优化思路：为RISC-V平台补全调试功能，确保在启用验证标志时能够正确检测栈帧大小问题，提高调试和错误检测能力。"}
{"id": 583, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+冗余消除", "optimization_description": "优化前：在C2编译器的匹配阶段，地址计算节点（AddPNode）会被克隆以尝试合并到复杂寻址表达式中，但对于间接内存操作（如volatile加载/存储），这些操作不会使用复杂寻址表达式，导致不必要的克隆和冗余代码生成。优化后：在pd_clone_address_expressions函数中添加检查，如果地址计算节点是至少一个间接内存加载/存储的输入，则跳过克隆。通过needs_acquiring_load和needs_releasing_store函数作为间接内存输入的代理判断。优化思路：避免生成不会被使用的冗余地址计算代码，减少寄存器压力和指令数量，提高代码生成效率。", "original_code": "在C2编译器的匹配阶段，地址计算节点（AddPNode）会被克隆以尝试合并到复杂寻址表达式中，但对于间接内存操作（如volatile加载/存储），这些操作不会使用复杂寻址表达式，导致不必要的克隆和冗余代码生成。", "optimized_code": "// Loads and stores with indirect memory input (e.g., volatile loads and\n  // stores) do not subsume the input into complex addressing expressions. If\n  // the addressing expression is input to at least one such load or store, do\n  // not clone the addressing expression. Query needs_acquiring_load and\n  // needs_releasing_store as a proxy for indirect memory input, as it is not\n  // possible to directly query for indirect memory input at this stage.\n  for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n    Node* n = m->fast_out(i);\n    if (n->is_Load() && needs_acquiring_load(n)) {\n      return false;\n    }\n    if (n->is_Store() && needs_releasing_store(n)) {\n      return false;\n    }\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/7d4c3fd0915cfa8b279f42494625ec6afda338af", "code_v0_no_empty_lines": "在C2编译器的匹配阶段，地址计算节点（AddPNode）会被克隆以尝试合并到复杂寻址表达式中，但对于间接内存操作（如volatile加载/存储），这些操作不会使用复杂寻址表达式，导致不必要的克隆和冗余代码生成。", "code_v1_no_empty_lines": "// Loads and stores with indirect memory input (e.g., volatile loads and\n  // stores) do not subsume the input into complex addressing expressions. If\n  // the addressing expression is input to at least one such load or store, do\n  // not clone the addressing expression. Query needs_acquiring_load and\n  // needs_releasing_store as a proxy for indirect memory input, as it is not\n  // possible to directly query for indirect memory input at this stage.\n  for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n    Node* n = m->fast_out(i);\n    if (n->is_Load() && needs_acquiring_load(n)) {\n      return false;\n    }\n    if (n->is_Store() && needs_releasing_store(n)) {\n      return false;\n    }\n  }", "target": "// Loads and stores with indirect memory input (e.g., volatile loads and\n  // stores) do not subsume the input into complex addressing expressions. If\n  // the addressing expression is input to at least one such load or store, do\n  // not clone the addressing expression. Query needs_acquiring_load and\n  // needs_releasing_store as a proxy for indirect memory input, as it is not\n  // possible to directly query for indirect memory input at this stage.\n  for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n    Node* n = m->fast_out(i);\n    if (n->is_Load() && needs_acquiring_load(n)) {\n      return false;\n    }\n    if (n->is_Store() && needs_releasing_store(n)) {\n      return false;\n    }\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在C2编译器的匹配阶段，地址计算节点（AddPNode）会被克隆以尝试合并到复杂寻址表达式中，但对于间接内存操作（如volatile加载/存储），这些操作不会使用复杂寻址表达式，导致不必要的克隆和冗余代码生成。优化后：在pd_clone_address_expressions函数中添加检查，如果地址计算节点是至少一个间接内存加载/存储的输入，则跳过克隆。通过needs_acquiring_load和needs_releasing_store函数作为间接内存输入的代理判断。优化思路：避免生成不会被使用的冗余地址计算代码，减少寄存器压力和指令数量，提高代码生成效率。"}
{"id": 584, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+内存访问优化", "optimization_description": "优化前：C2 SuperWord自动向量化在某些情况下会产生store-to-load forwarding失败，导致性能回归。优化后：新增SuperWordStoreToLoadForwardingFailureDetection配置参数（默认值8-16），在向量化调度阶段检测可能的store-to-load forwarding失败，如果检测到则放弃向量化。思路：通过检测内存访问模式，避免因向量化导致的store-to-load forwarding失败，从而修复性能回归问题。", "original_code": "C2 SuperWord自动向量化在某些情况下会产生store-to-load forwarding失败，导致性能回归。", "optimized_code": "if (!vtransform.schedule()) { return false; }\n+ if (vtransform.has_store_to_load_forwarding_failure()) { return false; }\nvtransform.apply();", "source_url": "https://github.com/openjdk/riscv-port/commit/75420e9314c54adc5b45f9b274a87af54dd6b5a8", "code_v0_no_empty_lines": "C2 SuperWord自动向量化在某些情况下会产生store-to-load forwarding失败，导致性能回归。", "code_v1_no_empty_lines": "if (!vtransform.schedule()) { return false; }\n+ if (vtransform.has_store_to_load_forwarding_failure()) { return false; }\nvtransform.apply();", "target": "if (!vtransform.schedule()) { return false; }\n+ if (vtransform.has_store_to_load_forwarding_failure()) { return false; }\nvtransform.apply();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2 SuperWord自动向量化在某些情况下会产生store-to-load forwarding失败，导致性能回归。优化后：新增SuperWordStoreToLoadForwardingFailureDetection配置参数（默认值8-16），在向量化调度阶段检测可能的store-to-load forwarding失败，如果检测到则放弃向量化。思路：通过检测内存访问模式，避免因向量化导致的store-to-load forwarding失败，从而修复性能回归问题。"}
{"id": 585, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：AlignVector标志未根据硬件特性自动设置，可能影响SLP（Superword Level Parallelism）向量化优化。优化后：当AlignVector为默认值时，根据AvoidUnalignedAccesses（避免非对齐访问）标志自动设置AlignVector。思路：在RISC-V架构中，如果硬件支持快速非对齐访问（MISALIGNED_FAST），则设置AvoidUnalignedAccesses为false，进而设置AlignVector为false，允许编译器进行更激进的向量化优化，提升性能。", "original_code": "AlignVector标志未根据硬件特性自动设置，可能影响SLP（Superword Level Parallelism）向量化优化。", "optimized_code": "if (FLAG_IS_DEFAULT(AlignVector)) {\n    FLAG_SET_DEFAULT(AlignVector, AvoidUnalignedAccesses);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/587f2b4b4dd73733a6ee247200371f8a8d0299c1", "code_v0_no_empty_lines": "AlignVector标志未根据硬件特性自动设置，可能影响SLP（Superword Level Parallelism）向量化优化。", "code_v1_no_empty_lines": "if (FLAG_IS_DEFAULT(AlignVector)) {\n    FLAG_SET_DEFAULT(AlignVector, AvoidUnalignedAccesses);\n}", "target": "if (FLAG_IS_DEFAULT(AlignVector)) {\n    FLAG_SET_DEFAULT(AlignVector, AvoidUnalignedAccesses);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AlignVector标志未根据硬件特性自动设置，可能影响SLP（Superword Level Parallelism）向量化优化。优化后：当AlignVector为默认值时，根据AvoidUnalignedAccesses（避免非对齐访问）标志自动设置AlignVector。思路：在RISC-V架构中，如果硬件支持快速非对齐访问（MISALIGNED_FAST），则设置AvoidUnalignedAccesses为false，进而设置AlignVector为false，允许编译器进行更激进的向量化优化，提升性能。"}
{"id": 586, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前：当AlwaysAtomicAccesses标志启用时，所有内存访问都被标记为volatile，导致不必要的内存屏障开销。优化后：将volatile访问（需要顺序一致性）与atomic访问（仅需原子性）分离，只有当真正需要顺序一致性时才使用volatile语义，减少不必要的内存屏障指令。优化思路：区分内存访问的原子性要求和顺序一致性要求，避免过度使用内存屏障。", "original_code": "当AlwaysAtomicAccesses标志启用时，所有内存访问都被标记为volatile，导致不必要的内存屏障开销。", "optimized_code": "- bool is_volatile = (((decorators & MO_SEQ_CST) != 0) || AlwaysAtomicAccesses);\n+ bool is_volatile = (decorators & MO_SEQ_CST) != 0;\n+ bool is_atomic = is_volatile || AlwaysAtomicAccesses;\n- if (is_volatile && !needs_patching) {\n+ if (is_atomic && !needs_patching) {", "source_url": "https://github.com/openjdk/riscv-port/commit/afee7405bd13cbe1cb829dd150a9de7e6faf49ae", "code_v0_no_empty_lines": "当AlwaysAtomicAccesses标志启用时，所有内存访问都被标记为volatile，导致不必要的内存屏障开销。", "code_v1_no_empty_lines": "- bool is_volatile = (((decorators & MO_SEQ_CST) != 0) || AlwaysAtomicAccesses);\n+ bool is_volatile = (decorators & MO_SEQ_CST) != 0;\n+ bool is_atomic = is_volatile || AlwaysAtomicAccesses;\n- if (is_volatile && !needs_patching) {\n+ if (is_atomic && !needs_patching) {", "target": "- bool is_volatile = (((decorators & MO_SEQ_CST) != 0) || AlwaysAtomicAccesses);\n+ bool is_volatile = (decorators & MO_SEQ_CST) != 0;\n+ bool is_atomic = is_volatile || AlwaysAtomicAccesses;\n- if (is_volatile && !needs_patching) {\n+ if (is_atomic && !needs_patching) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当AlwaysAtomicAccesses标志启用时，所有内存访问都被标记为volatile，导致不必要的内存屏障开销。优化后：将volatile访问（需要顺序一致性）与atomic访问（仅需原子性）分离，只有当真正需要顺序一致性时才使用volatile语义，减少不必要的内存屏障指令。优化思路：区分内存访问的原子性要求和顺序一致性要求，避免过度使用内存屏障。"}
{"id": 587, "source": "riscv-dataset-excel", "optimization_type": "代码重构+指令优化", "optimization_description": "优化前：在RISC-V架构下使用Zacas指令时，cmpxchg函数中直接将expected寄存器赋值给result寄存器，然后调用atomic_cas，这可能导致寄存器冲突问题（当result与new_val或expected相同时）。同时，atomic_cas函数通过复杂的宏定义和switch-case结构实现，代码冗余且维护困难。\n\n优化后：1. 在cmpxchg函数中，先将expected值保存到临时寄存器t0，调用atomic_cas操作t0，最后将结果复制到result寄存器，避免了寄存器冲突。2. 完全重构atomic_cas函数，删除所有宏定义的辅助函数，直接根据操作数大小调用对应的amocas_d或amocas_w指令，简化了代码结构。\n\n优化思路：修复Zacas指令在LW锁定场景下的寄存器使用问题，通过使用临时寄存器避免冲突；同时简化原子比较交换操作的实现，减少代码复杂度和维护成本，提高代码可读性和执行效率。", "original_code": "在RISC-V架构下使用Zacas指令时，cmpxchg函数中直接将expected寄存器赋值给result寄存器，然后调用atomic_cas，这可能导致寄存器冲突问题（当result与new_val或expected相同时）。同时，atomic_cas函数通过复杂的宏定义和switch-case结构实现，代码冗余且维护困难。", "optimized_code": "-  mv(result, expected);\n+  mv(t0, expected);\n   atomic_cas(t0, new_val, addr, size, acquire, release);\n+  mv(result, t0);\n\n-  #define ATOMIC_CAS(OP, AOP, ACQUIRE, RELEASE)                                        \\\nvoid MacroAssembler::atomic_##OP(Register prev, Register newv, Register addr) {      \\\n  assert(UseZacas, \"invariant\");                                                     \\\n  prev = prev->is_valid() ? prev : zr;                                               \\\n  AOP(prev, addr, newv, (Assembler::Aqrl)(ACQUIRE | RELEASE));                       \\\n  return;                                                                            \\\n}\n\nATOMIC_CAS(cas, amocas_d, Assembler::relaxed, Assembler::relaxed)\nATOMIC_CAS(casw, amocas_w, Assembler::relaxed, Assembler::relaxed)\nATOMIC_CAS(casl, amocas_d, Assembler::relaxed, Assembler::rl)\nATOMIC_CAS(caslw, amocas_w, Assembler::relaxed, Assembler::rl)\nATOMIC_CAS(casal, amocas_d, Assembler::aq, Assembler::rl)\nATOMIC_CAS(casalw, amocas_w, Assembler::aq, Assembler::rl)\n\n#undef ATOMIC_CAS\n\n#define ATOMIC_CASU(OP1, OP2)                                                        \\\nvoid MacroAssembler::atomic_##OP1(Register prev, Register newv, Register addr) {     \\\n  atomic_##OP2(prev, newv, addr);                                                    \\\n  zero_extend(prev, prev, 32);                                                       \\\n  return;                                                                            \\\n}\n\nATOMIC_CASU(caswu, casw)\nATOMIC_CASU(caslwu, caslw)\nATOMIC_CASU(casalwu, casalw)\n\n#undef ATOMIC_CASU\n\nvoid MacroAssembler::atomic_cas(\n    Register prev, Register newv, Register addr, enum operand_size size, Assembler::Aqrl acquire, Assembler::Aqrl release) {\n  switch (size) {\n    case int64:\n      switch ((Assembler::Aqrl)(acquire | release)) {\n        case Assembler::relaxed:\n          atomic_cas(prev, newv, addr);\n          break;\n        case Assembler::rl:\n          atomic_casl(prev, newv, addr);\n          break;\n        case Assembler::aqrl:\n          atomic_casal(prev, newv, addr);\n          break;\n        default:\n          ShouldNotReachHere();\n      }\n      break;\n    case int32:\n      switch ((Assembler::Aqrl)(acquire | release)) {\n        case Assembler::relaxed:\n          atomic_casw(prev, newv, addr);\n          break;\n        case Assembler::rl:\n          atomic_caslw(prev, newv, addr);\n          break;\n        case Assembler::aqrl:\n          atomic_casalw(prev, newv, addr);\n          break;\n        default:\n          ShouldNotReachHere();\n      }\n      break;\n    case uint32:\n      switch ((Assembler::Aqrl)(acquire | release)) {\n        case Assembler::relaxed:\n          atomic_caswu(prev, newv, addr);\n          break;\n        case Assembler::rl:\n          atomic_caslwu(prev, newv, addr);\n          break;\n        case Assembler::aqrl:\n          atomic_casalwu(prev, newv, addr);\n          break;\n        default:\n          ShouldNotReachHere();\n      }\n      break;\n    default:\n      ShouldNotReachHere();\n  }\n}\n+void MacroAssembler::atomic_cas(Register prev, Register newv, Register addr,\n+                                enum operand_size size, Assembler::Aqrl acquire, Assembler::Aqrl release) {\n  switch (size) {\n    case int64:\n      amocas_d(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n      break;\n    case int32:\n      amocas_w(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n      break;\n    case uint32:\n      amocas_w(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n      zero_extend(prev, prev, 32);\n      break;\n    default:\n      ShouldNotReachHere();\n  }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/ea7e722ca04752f0b58bf98e0a1907c015644fb5", "code_v0_no_empty_lines": "在RISC-V架构下使用Zacas指令时，cmpxchg函数中直接将expected寄存器赋值给result寄存器，然后调用atomic_cas，这可能导致寄存器冲突问题（当result与new_val或expected相同时）。同时，atomic_cas函数通过复杂的宏定义和switch-case结构实现，代码冗余且维护困难。", "code_v1_no_empty_lines": "-  mv(result, expected);\n+  mv(t0, expected);\n   atomic_cas(t0, new_val, addr, size, acquire, release);\n+  mv(result, t0);\n\n-  #define ATOMIC_CAS(OP, AOP, ACQUIRE, RELEASE)                                        \\\nvoid MacroAssembler::atomic_##OP(Register prev, Register newv, Register addr) {      \\\n  assert(UseZacas, \"invariant\");                                                     \\\n  prev = prev->is_valid() ? prev : zr;                                               \\\n  AOP(prev, addr, newv, (Assembler::Aqrl)(ACQUIRE | RELEASE));                       \\\n  return;                                                                            \\\n}\n\nATOMIC_CAS(cas, amocas_d, Assembler::relaxed, Assembler::relaxed)\nATOMIC_CAS(casw, amocas_w, Assembler::relaxed, Assembler::relaxed)\nATOMIC_CAS(casl, amocas_d, Assembler::relaxed, Assembler::rl)\nATOMIC_CAS(caslw, amocas_w, Assembler::relaxed, Assembler::rl)\nATOMIC_CAS(casal, amocas_d, Assembler::aq, Assembler::rl)\nATOMIC_CAS(casalw, amocas_w, Assembler::aq, Assembler::rl)\n\n#undef ATOMIC_CAS\n\n#define ATOMIC_CASU(OP1, OP2)                                                        \\\nvoid MacroAssembler::atomic_##OP1(Register prev, Register newv, Register addr) {     \\\n  atomic_##OP2(prev, newv, addr);                                                    \\\n  zero_extend(prev, prev, 32);                                                       \\\n  return;                                                                            \\\n}\n\nATOMIC_CASU(caswu, casw)\nATOMIC_CASU(caslwu, caslw)\nATOMIC_CASU(casalwu, casalw)\n\n#undef ATOMIC_CASU\n\nvoid MacroAssembler::atomic_cas(\n    Register prev, Register newv, Register addr, enum operand_size size, Assembler::Aqrl acquire, Assembler::Aqrl release) {\n  switch (size) {\n    case int64:\n      switch ((Assembler::Aqrl)(acquire | release)) {\n        case Assembler::relaxed:\n          atomic_cas(prev, newv, addr);\n          break;\n        case Assembler::rl:\n          atomic_casl(prev, newv, addr);\n          break;\n        case Assembler::aqrl:\n          atomic_casal(prev, newv, addr);\n          break;\n        default:\n          ShouldNotReachHere();\n      }\n      break;\n    case int32:\n      switch ((Assembler::Aqrl)(acquire | release)) {\n        case Assembler::relaxed:\n          atomic_casw(prev, newv, addr);\n          break;\n        case Assembler::rl:\n          atomic_caslw(prev, newv, addr);\n          break;\n        case Assembler::aqrl:\n          atomic_casalw(prev, newv, addr);\n          break;\n        default:\n          ShouldNotReachHere();\n      }\n      break;\n    case uint32:\n      switch ((Assembler::Aqrl)(acquire | release)) {\n        case Assembler::relaxed:\n          atomic_caswu(prev, newv, addr);\n          break;\n        case Assembler::rl:\n          atomic_caslwu(prev, newv, addr);\n          break;\n        case Assembler::aqrl:\n          atomic_casalwu(prev, newv, addr);\n          break;\n        default:\n          ShouldNotReachHere();\n      }\n      break;\n    default:\n      ShouldNotReachHere();\n  }\n}\n+void MacroAssembler::atomic_cas(Register prev, Register newv, Register addr,\n+                                enum operand_size size, Assembler::Aqrl acquire, Assembler::Aqrl release) {\n  switch (size) {\n    case int64:\n      amocas_d(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n      break;\n    case int32:\n      amocas_w(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n      break;\n    case uint32:\n      amocas_w(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n      zero_extend(prev, prev, 32);\n      break;\n    default:\n      ShouldNotReachHere();\n  }\n}", "target": "-  mv(result, expected);\n+  mv(t0, expected);\n   atomic_cas(t0, new_val, addr, size, acquire, release);\n+  mv(result, t0);\n\n-  #define ATOMIC_CAS(OP, AOP, ACQUIRE, RELEASE)                                        \\\nvoid MacroAssembler::atomic_##OP(Register prev, Register newv, Register addr) {      \\\n  assert(UseZacas, \"invariant\");                                                     \\\n  prev = prev->is_valid() ? prev : zr;                                               \\\n  AOP(prev, addr, newv, (Assembler::Aqrl)(ACQUIRE | RELEASE));                       \\\n  return;                                                                            \\\n}\n\nATOMIC_CAS(cas, amocas_d, Assembler::relaxed, Assembler::relaxed)\nATOMIC_CAS(casw, amocas_w, Assembler::relaxed, Assembler::relaxed)\nATOMIC_CAS(casl, amocas_d, Assembler::relaxed, Assembler::rl)\nATOMIC_CAS(caslw, amocas_w, Assembler::relaxed, Assembler::rl)\nATOMIC_CAS(casal, amocas_d, Assembler::aq, Assembler::rl)\nATOMIC_CAS(casalw, amocas_w, Assembler::aq, Assembler::rl)\n\n#undef ATOMIC_CAS\n\n#define ATOMIC_CASU(OP1, OP2)                                                        \\\nvoid MacroAssembler::atomic_##OP1(Register prev, Register newv, Register addr) {     \\\n  atomic_##OP2(prev, newv, addr);                                                    \\\n  zero_extend(prev, prev, 32);                                                       \\\n  return;                                                                            \\\n}\n\nATOMIC_CASU(caswu, casw)\nATOMIC_CASU(caslwu, caslw)\nATOMIC_CASU(casalwu, casalw)\n\n#undef ATOMIC_CASU\n\nvoid MacroAssembler::atomic_cas(\n    Register prev, Register newv, Register addr, enum operand_size size, Assembler::Aqrl acquire, Assembler::Aqrl release) {\n  switch (size) {\n    case int64:\n      switch ((Assembler::Aqrl)(acquire | release)) {\n        case Assembler::relaxed:\n          atomic_cas(prev, newv, addr);\n          break;\n        case Assembler::rl:\n          atomic_casl(prev, newv, addr);\n          break;\n        case Assembler::aqrl:\n          atomic_casal(prev, newv, addr);\n          break;\n        default:\n          ShouldNotReachHere();\n      }\n      break;\n    case int32:\n      switch ((Assembler::Aqrl)(acquire | release)) {\n        case Assembler::relaxed:\n          atomic_casw(prev, newv, addr);\n          break;\n        case Assembler::rl:\n          atomic_caslw(prev, newv, addr);\n          break;\n        case Assembler::aqrl:\n          atomic_casalw(prev, newv, addr);\n          break;\n        default:\n          ShouldNotReachHere();\n      }\n      break;\n    case uint32:\n      switch ((Assembler::Aqrl)(acquire | release)) {\n        case Assembler::relaxed:\n          atomic_caswu(prev, newv, addr);\n          break;\n        case Assembler::rl:\n          atomic_caslwu(prev, newv, addr);\n          break;\n        case Assembler::aqrl:\n          atomic_casalwu(prev, newv, addr);\n          break;\n        default:\n          ShouldNotReachHere();\n      }\n      break;\n    default:\n      ShouldNotReachHere();\n  }\n}\n+void MacroAssembler::atomic_cas(Register prev, Register newv, Register addr,\n+                                enum operand_size size, Assembler::Aqrl acquire, Assembler::Aqrl release) {\n  switch (size) {\n    case int64:\n      amocas_d(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n      break;\n    case int32:\n      amocas_w(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n      break;\n    case uint32:\n      amocas_w(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n      zero_extend(prev, prev, 32);\n      break;\n    default:\n      ShouldNotReachHere();\n  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在RISC-V架构下使用Zacas指令时，cmpxchg函数中直接将expected寄存器赋值给result寄存器，然后调用atomic_cas，这可能导致寄存器冲突问题（当result与new_val或expected相同时）。同时，atomic_cas函数通过复杂的宏定义和switch-case结构实现，代码冗余且维护困难。\n\n优化后：1. 在cmpxchg函数中，先将expected值保存到临时寄存器t0，调用atomic_cas操作t0，最后将结果复制到result寄存器，避免了寄存器冲突。2. 完全重构atomic_cas函数，删除所有宏定义的辅助函数，直接根据操作数大小调用对应的amocas_d或amocas_w指令，简化了代码结构。\n\n优化思路：修复Zacas指令在LW锁定场景下的寄存器使用问题，通过使用临时寄存器避免冲突；同时简化原子比较交换操作的实现，减少代码复杂度和维护成本，提高代码可读性和执行效率。"}
{"id": 588, "source": "riscv-dataset-excel", "optimization_type": "内存布局优化", "optimization_description": "优化前：MethodCounters继承自Metadata类，包含虚函数表指针(vptr)和虚函数实现，增加了对象内存开销。优化后：改为继承自MetaspaceObj基类，移除了不必要的虚函数和虚函数表指针，简化了内存布局。优化思路：MethodCounters不需要多态特性，移除vptr可以减少每个MethodCounters对象的内存占用，提高内存使用效率。", "original_code": "MethodCounters继承自Metadata类，包含虚函数表指针(vptr)和虚函数实现，增加了对象内存开销。", "optimized_code": "-class MethodCounters : public Metadata\n+class MethodCounters : public MetaspaceObj\n-virtual bool is_methodCounters() const { return true; }\n-virtual int size() const {\n-  return method_counters_size();\n-}\n-virtual const char* internal_name() const { return \"{method counters}\"; }\n-virtual void print_value_on(outputStream* st) const;\n+static int size() {\n+  return align_up((int)sizeof(MethodCounters), wordSize) / wordSize;\n+}\n+const char* internal_name() const { return \"{method counters}\"; }\n+void print_value_on(outputStream* st) const;", "source_url": "https://github.com/openjdk/riscv-port/commit/d4cd27e875ba7d44b0c614d48888340990b94169", "code_v0_no_empty_lines": "MethodCounters继承自Metadata类，包含虚函数表指针(vptr)和虚函数实现，增加了对象内存开销。", "code_v1_no_empty_lines": "-class MethodCounters : public Metadata\n+class MethodCounters : public MetaspaceObj\n-virtual bool is_methodCounters() const { return true; }\n-virtual int size() const {\n-  return method_counters_size();\n-}\n-virtual const char* internal_name() const { return \"{method counters}\"; }\n-virtual void print_value_on(outputStream* st) const;\n+static int size() {\n+  return align_up((int)sizeof(MethodCounters), wordSize) / wordSize;\n+}\n+const char* internal_name() const { return \"{method counters}\"; }\n+void print_value_on(outputStream* st) const;", "target": "-class MethodCounters : public Metadata\n+class MethodCounters : public MetaspaceObj\n-virtual bool is_methodCounters() const { return true; }\n-virtual int size() const {\n-  return method_counters_size();\n-}\n-virtual const char* internal_name() const { return \"{method counters}\"; }\n-virtual void print_value_on(outputStream* st) const;\n+static int size() {\n+  return align_up((int)sizeof(MethodCounters), wordSize) / wordSize;\n+}\n+const char* internal_name() const { return \"{method counters}\"; }\n+void print_value_on(outputStream* st) const;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：MethodCounters继承自Metadata类，包含虚函数表指针(vptr)和虚函数实现，增加了对象内存开销。优化后：改为继承自MetaspaceObj基类，移除了不必要的虚函数和虚函数表指针，简化了内存布局。优化思路：MethodCounters不需要多态特性，移除vptr可以减少每个MethodCounters对象的内存占用，提高内存使用效率。"}
{"id": 589, "source": "riscv-dataset-excel", "optimization_type": "指令优化+代码精简", "optimization_description": "优化前：通过调用load_narrow_klass_compact_c2函数间接加载压缩类指针，该函数包含地址计算和位移操作，增加了函数调用开销和代码复杂度。优化后：直接在指令编码中使用lwu（加载无符号字）和srli（逻辑右移）两条指令完成相同功能，消除了函数调用开销，简化了代码路径。优化思路：内联关键操作，减少间接调用，提高指令执行效率，同时删除冗余的函数定义和声明，精简代码体积。", "original_code": "通过调用load_narrow_klass_compact_c2函数间接加载压缩类指针，该函数包含地址计算和位移操作，增加了函数调用开销和代码复杂度。", "optimized_code": "- __ load_narrow_klass_compact_c2(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n+ __ lwu(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n+ __ srli(as_Register($dst$$reg), as_Register($dst$$reg), (unsigned) markWord::klass_shift_at_offset);", "source_url": "https://github.com/openjdk/riscv-port/commit/dc940ec8afcd3cd12ed3785d547f4cd602f65c15", "code_v0_no_empty_lines": "通过调用load_narrow_klass_compact_c2函数间接加载压缩类指针，该函数包含地址计算和位移操作，增加了函数调用开销和代码复杂度。", "code_v1_no_empty_lines": "- __ load_narrow_klass_compact_c2(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n+ __ lwu(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n+ __ srli(as_Register($dst$$reg), as_Register($dst$$reg), (unsigned) markWord::klass_shift_at_offset);", "target": "- __ load_narrow_klass_compact_c2(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n+ __ lwu(as_Register($dst$$reg), Address(as_Register($mem$$base), $mem$$disp));\n+ __ srli(as_Register($dst$$reg), as_Register($dst$$reg), (unsigned) markWord::klass_shift_at_offset);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：通过调用load_narrow_klass_compact_c2函数间接加载压缩类指针，该函数包含地址计算和位移操作，增加了函数调用开销和代码复杂度。优化后：直接在指令编码中使用lwu（加载无符号字）和srli（逻辑右移）两条指令完成相同功能，消除了函数调用开销，简化了代码路径。优化思路：内联关键操作，减少间接调用，提高指令执行效率，同时删除冗余的函数定义和声明，精简代码体积。"}
{"id": 590, "source": "riscv-dataset-excel", "optimization_type": "代码重构+可维护性优化", "optimization_description": "优化前：G1CMTask::do_marking_step方法是一个大型复杂函数，包含标记步骤的所有逻辑，代码可读性和可维护性较差。优化后：将do_marking_step拆分为多个小型包装方法（process_current_region、claim_new_region、attempt_stealing、attempt_termination、handle_abort），每个方法负责特定的子功能。优化思路：通过函数分解提高代码模块化，增强可读性和可维护性，便于后续调试和功能扩展，同时保持原有算法逻辑不变。", "original_code": "G1CMTask::do_marking_step方法是一个大型复杂函数，包含标记步骤的所有逻辑，代码可读性和可维护性较差。", "optimized_code": "+void G1CMTask::process_current_region(G1CMBitMapClosure& bitmap_closure) {\n+void G1CMTask::claim_new_region() {\n+void G1CMTask::attempt_stealing() {\n+void G1CMTask::attempt_termination(bool is_serial) {\n+void G1CMTask::handle_abort(bool is_serial, double elapsed_time_ms) {", "source_url": "https://github.com/openjdk/riscv-port/commit/1717946c1b6494a4a44622027ac1dd175fcb9563", "code_v0_no_empty_lines": "G1CMTask::do_marking_step方法是一个大型复杂函数，包含标记步骤的所有逻辑，代码可读性和可维护性较差。", "code_v1_no_empty_lines": "+void G1CMTask::process_current_region(G1CMBitMapClosure& bitmap_closure) {\n+void G1CMTask::claim_new_region() {\n+void G1CMTask::attempt_stealing() {\n+void G1CMTask::attempt_termination(bool is_serial) {\n+void G1CMTask::handle_abort(bool is_serial, double elapsed_time_ms) {", "target": "+void G1CMTask::process_current_region(G1CMBitMapClosure& bitmap_closure) {\n+void G1CMTask::claim_new_region() {\n+void G1CMTask::attempt_stealing() {\n+void G1CMTask::attempt_termination(bool is_serial) {\n+void G1CMTask::handle_abort(bool is_serial, double elapsed_time_ms) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：G1CMTask::do_marking_step方法是一个大型复杂函数，包含标记步骤的所有逻辑，代码可读性和可维护性较差。优化后：将do_marking_step拆分为多个小型包装方法（process_current_region、claim_new_region、attempt_stealing、attempt_termination、handle_abort），每个方法负责特定的子功能。优化思路：通过函数分解提高代码模块化，增强可读性和可维护性，便于后续调试和功能扩展，同时保持原有算法逻辑不变。"}
{"id": 591, "source": "riscv-dataset-excel", "optimization_type": "代码简化+配置优化", "optimization_description": "优化前：存在独立的UseRVVForBigIntegerShiftIntrinsics选项来控制BigInteger移位操作是否使用RVV指令。优化后：移除了该选项，BigInteger移位操作现在直接由UseRVV选项控制。优化思路：简化配置选项，减少代码复杂度，使RVV使用逻辑更加统一。", "original_code": "存在独立的UseRVVForBigIntegerShiftIntrinsics选项来控制BigInteger移位操作是否使用RVV指令。", "optimized_code": "-  product(bool, UseRVVForBigIntegerShiftIntrinsics, true,                        \\\n          \"Use RVV instructions for left/right shift of BigInteger\")             \\\n-    if (config.useRVVForBigIntegerShiftIntrinsics) {\\\n            flags.add(RISCV64.Flag.UseRVVForBigIntegerShiftIntrinsics);\\\n        }\\\n-    final boolean useRVVForBigIntegerShiftIntrinsics = getFlag(\"UseRVVForBigIntegerShiftIntrinsics\", Boolean.class);\\\n-        UseRVVForBigIntegerShiftIntrinsics", "source_url": "https://github.com/openjdk/riscv-port/commit/0d66689177b880035e4047399e3e64f461713562", "code_v0_no_empty_lines": "存在独立的UseRVVForBigIntegerShiftIntrinsics选项来控制BigInteger移位操作是否使用RVV指令。", "code_v1_no_empty_lines": "-  product(bool, UseRVVForBigIntegerShiftIntrinsics, true,                        \\\n          \"Use RVV instructions for left/right shift of BigInteger\")             \\\n-    if (config.useRVVForBigIntegerShiftIntrinsics) {\\\n            flags.add(RISCV64.Flag.UseRVVForBigIntegerShiftIntrinsics);\\\n        }\\\n-    final boolean useRVVForBigIntegerShiftIntrinsics = getFlag(\"UseRVVForBigIntegerShiftIntrinsics\", Boolean.class);\\\n-        UseRVVForBigIntegerShiftIntrinsics", "target": "-  product(bool, UseRVVForBigIntegerShiftIntrinsics, true,                        \\\n          \"Use RVV instructions for left/right shift of BigInteger\")             \\\n-    if (config.useRVVForBigIntegerShiftIntrinsics) {\\\n            flags.add(RISCV64.Flag.UseRVVForBigIntegerShiftIntrinsics);\\\n        }\\\n-    final boolean useRVVForBigIntegerShiftIntrinsics = getFlag(\"UseRVVForBigIntegerShiftIntrinsics\", Boolean.class);\\\n-        UseRVVForBigIntegerShiftIntrinsics", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：存在独立的UseRVVForBigIntegerShiftIntrinsics选项来控制BigInteger移位操作是否使用RVV指令。优化后：移除了该选项，BigInteger移位操作现在直接由UseRVV选项控制。优化思路：简化配置选项，减少代码复杂度，使RVV使用逻辑更加统一。"}
{"id": 592, "source": "riscv-dataset-excel", "optimization_type": "平台特定优化+编译器标志优化", "optimization_description": "优化前：在s390x平台上启用OptoScheduling标志，但该平台的架构描述文件(s390.ad)未维护OptoScheduling所需的信息，可能导致编译器生成低效或错误的代码。优化后：在VM初始化时检测OptoScheduling标志，如果启用则显示警告并强制设置为false，避免使用不支持的优化功能。优化思路：针对特定CPU架构(s390x)禁用不支持的编译器优化选项，确保编译器生成的代码正确性和稳定性。", "original_code": "在s390x平台上启用OptoScheduling标志，但该平台的架构描述文件(s390.ad)未维护OptoScheduling所需的信息，可能导致编译器生成低效或错误的代码。", "optimized_code": "+  // The OptoScheduling information is not maintained in s390.ad.\n+  if (OptoScheduling) {\n+    warning(\"OptoScheduling is not supported on this CPU.\");\n+    FLAG_SET_DEFAULT(OptoScheduling, false);\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/7540fa2147ff8fc9c652ef13548f72f27e2809a8", "code_v0_no_empty_lines": "在s390x平台上启用OptoScheduling标志，但该平台的架构描述文件(s390.ad)未维护OptoScheduling所需的信息，可能导致编译器生成低效或错误的代码。", "code_v1_no_empty_lines": "+  // The OptoScheduling information is not maintained in s390.ad.\n+  if (OptoScheduling) {\n+    warning(\"OptoScheduling is not supported on this CPU.\");\n+    FLAG_SET_DEFAULT(OptoScheduling, false);\n+  }", "target": "+  // The OptoScheduling information is not maintained in s390.ad.\n+  if (OptoScheduling) {\n+    warning(\"OptoScheduling is not supported on this CPU.\");\n+    FLAG_SET_DEFAULT(OptoScheduling, false);\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在s390x平台上启用OptoScheduling标志，但该平台的架构描述文件(s390.ad)未维护OptoScheduling所需的信息，可能导致编译器生成低效或错误的代码。优化后：在VM初始化时检测OptoScheduling标志，如果启用则显示警告并强制设置为false，避免使用不支持的优化功能。优化思路：针对特定CPU架构(s390x)禁用不支持的编译器优化选项，确保编译器生成的代码正确性和稳定性。"}
{"id": 593, "source": "riscv-dataset-excel", "optimization_type": "并行化优化", "optimization_description": "优化前：CDS（Class Data Sharing）的重定位操作是单线程执行的，在处理大量类数据时可能存在性能瓶颈。优化后：引入了并行重定位机制，通过创建ArchiveWorkers线程池，将重定位任务分割成多个chunk，由多个工作线程并行处理。优化思路：利用多核CPU的并行计算能力，通过工作窃取（work-stealing）模式（使用原子操作管理chunk分配）和雪崩式唤醒机制（每个工作线程唤醒两个其他线程）来加速CDS重定位过程，从而减少应用程序启动时间。", "original_code": "CDS（Class Data Sharing）的重定位操作是单线程执行的，在处理大量类数据时可能存在性能瓶颈。", "optimized_code": "+ArchiveWorkers ArchiveWorkers::_workers;\n+ArchiveWorkers::ArchiveWorkers() :\n+        _start_semaphore(0),\n+        _end_semaphore(0),\n+        _num_workers(0),\n+        _started_workers(0),\n+        _waiting_workers(0),\n+        _running_workers(0),\n+        _state(NOT_READY),\n+        _task(nullptr) {\n+}\n+void ArchiveWorkers::run_task(ArchiveWorkerTask* task) {\n+  if (is_parallel()) {\n+    run_task_multi(task);\n+  } else {\n+    run_task_single(task);\n+  }\n+}\n+void ArchiveWorkers::run_task_multi(ArchiveWorkerTask* task) {\n+  task->configure_max_chunks(_num_workers * CHUNKS_PER_WORKER);\n+  Atomic::release_store(&_task, task);\n+  signal_worker_if_needed();\n+  task->run();\n+  _end_semaphore.wait();\n+}\n+void ArchiveWorkerTask::run() {\n+  while (true) {\n+    int chunk = Atomic::load(&_chunk);\n+    if (chunk >= _max_chunks) {\n+      return;\n+    }\n+    if (Atomic::cmpxchg(&_chunk, chunk, chunk + 1, memory_order_relaxed) == chunk) {\n+      work(chunk, _max_chunks);\n+    }\n+  }\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/76a55c3cb6e5177442f355ae1036db4fbf8e54af", "code_v0_no_empty_lines": "CDS（Class Data Sharing）的重定位操作是单线程执行的，在处理大量类数据时可能存在性能瓶颈。", "code_v1_no_empty_lines": "+ArchiveWorkers ArchiveWorkers::_workers;\n+ArchiveWorkers::ArchiveWorkers() :\n+        _start_semaphore(0),\n+        _end_semaphore(0),\n+        _num_workers(0),\n+        _started_workers(0),\n+        _waiting_workers(0),\n+        _running_workers(0),\n+        _state(NOT_READY),\n+        _task(nullptr) {\n+}\n+void ArchiveWorkers::run_task(ArchiveWorkerTask* task) {\n+  if (is_parallel()) {\n+    run_task_multi(task);\n+  } else {\n+    run_task_single(task);\n+  }\n+}\n+void ArchiveWorkers::run_task_multi(ArchiveWorkerTask* task) {\n+  task->configure_max_chunks(_num_workers * CHUNKS_PER_WORKER);\n+  Atomic::release_store(&_task, task);\n+  signal_worker_if_needed();\n+  task->run();\n+  _end_semaphore.wait();\n+}\n+void ArchiveWorkerTask::run() {\n+  while (true) {\n+    int chunk = Atomic::load(&_chunk);\n+    if (chunk >= _max_chunks) {\n+      return;\n+    }\n+    if (Atomic::cmpxchg(&_chunk, chunk, chunk + 1, memory_order_relaxed) == chunk) {\n+      work(chunk, _max_chunks);\n+    }\n+  }\n+}", "target": "+ArchiveWorkers ArchiveWorkers::_workers;\n+ArchiveWorkers::ArchiveWorkers() :\n+        _start_semaphore(0),\n+        _end_semaphore(0),\n+        _num_workers(0),\n+        _started_workers(0),\n+        _waiting_workers(0),\n+        _running_workers(0),\n+        _state(NOT_READY),\n+        _task(nullptr) {\n+}\n+void ArchiveWorkers::run_task(ArchiveWorkerTask* task) {\n+  if (is_parallel()) {\n+    run_task_multi(task);\n+  } else {\n+    run_task_single(task);\n+  }\n+}\n+void ArchiveWorkers::run_task_multi(ArchiveWorkerTask* task) {\n+  task->configure_max_chunks(_num_workers * CHUNKS_PER_WORKER);\n+  Atomic::release_store(&_task, task);\n+  signal_worker_if_needed();\n+  task->run();\n+  _end_semaphore.wait();\n+}\n+void ArchiveWorkerTask::run() {\n+  while (true) {\n+    int chunk = Atomic::load(&_chunk);\n+    if (chunk >= _max_chunks) {\n+      return;\n+    }\n+    if (Atomic::cmpxchg(&_chunk, chunk, chunk + 1, memory_order_relaxed) == chunk) {\n+      work(chunk, _max_chunks);\n+    }\n+  }\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CDS（Class Data Sharing）的重定位操作是单线程执行的，在处理大量类数据时可能存在性能瓶颈。优化后：引入了并行重定位机制，通过创建ArchiveWorkers线程池，将重定位任务分割成多个chunk，由多个工作线程并行处理。优化思路：利用多核CPU的并行计算能力，通过工作窃取（work-stealing）模式（使用原子操作管理chunk分配）和雪崩式唤醒机制（每个工作线程唤醒两个其他线程）来加速CDS重定位过程，从而减少应用程序启动时间。"}
{"id": 594, "source": "riscv-dataset-excel", "optimization_type": "内存访问优化+条件判断优化", "optimization_description": "性能提升：优化前每次调用oopDesc::klass()都需要检查多个运行时标志（UseCompactObjectHeaders、UseCompressedClassPointers），导致频繁的条件分支和内存访问。优化后引入ObjLayout类，在初始化阶段根据标志计算并缓存对象布局模式，后续访问只需读取缓存的静态变量，减少条件判断和标志加载开销，特别有利于GC迭代器和栈跟踪构建器等频繁访问Klass*的性能关键路径。", "original_code": "// No original code extracted from description\n", "optimized_code": "+class ObjLayout {\n+public:\n+  enum Mode {\n+    Compact,\n+    Compressed,\n+    Uncompressed,\n+    Undefined\n+  };\n+  static inline Mode klass_mode();\n+  static inline int oop_base_offset_in_bytes() {\n+    return _oop_base_offset_in_bytes;\n+  }\n+};\n+inline ObjLayout::Mode ObjLayout::klass_mode() {\n+#ifdef _LP64\n+  return _klass_mode;\n+#else\n+  return Uncompressed;\n+#endif\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/276251c44a1a5b9dc36b27ecbaed37de62fc7558", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "+class ObjLayout {\n+public:\n+  enum Mode {\n+    Compact,\n+    Compressed,\n+    Uncompressed,\n+    Undefined\n+  };\n+  static inline Mode klass_mode();\n+  static inline int oop_base_offset_in_bytes() {\n+    return _oop_base_offset_in_bytes;\n+  }\n+};\n+inline ObjLayout::Mode ObjLayout::klass_mode() {\n+#ifdef _LP64\n+  return _klass_mode;\n+#else\n+  return Uncompressed;\n+#endif\n+}", "target": "+class ObjLayout {\n+public:\n+  enum Mode {\n+    Compact,\n+    Compressed,\n+    Uncompressed,\n+    Undefined\n+  };\n+  static inline Mode klass_mode();\n+  static inline int oop_base_offset_in_bytes() {\n+    return _oop_base_offset_in_bytes;\n+  }\n+};\n+inline ObjLayout::Mode ObjLayout::klass_mode() {\n+#ifdef _LP64\n+  return _klass_mode;\n+#else\n+  return Uncompressed;\n+#endif\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升：优化前每次调用oopDesc::klass()都需要检查多个运行时标志（UseCompactObjectHeaders、UseCompressedClassPointers），导致频繁的条件分支和内存访问。优化后引入ObjLayout类，在初始化阶段根据标志计算并缓存对象布局模式，后续访问只需读取缓存的静态变量，减少条件判断和标志加载开销，特别有利于GC迭代器和栈跟踪构建器等频繁访问Klass*的性能关键路径。"}
{"id": 595, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：S390x架构缺乏对SIMD向量指令的支持，无法利用硬件向量单元进行并行计算。优化后：实现了SLP（Superword Level Parallelism）支持，新增了向量逻辑运算（如VNX）和向量浮点运算（如VFA、VFS、VFM、VFD、VFSQ、VFLR）等指令定义。优化思路：通过扩展汇编器指令集，为S390x架构添加向量化能力，使编译器能够生成SIMD指令，利用硬件并行性提升数值计算和数据处理性能。", "original_code": "S390x架构缺乏对SIMD向量指令的支持，无法利用硬件向量单元进行并行计算。", "optimized_code": "+#define VNX_ZOPC    (unsigned long)(0xe7L << 40 | 0x6cL << 0)   // V1 := !(V2 | V3),  element size = 2**m\n+#define VFA_ZOPC   (unsigned long)(0xe7L << 40 | 0xE3L << 0)    // V1 := V2 + V3, element size = 2**m\n+#define VFS_ZOPC   (unsigned long)(0xe7L << 40 | 0xE2L << 0)    // V1 := V2 - V3, element size = 2**m\n+#define VFM_ZOPC   (unsigned long)(0xe7L << 40 | 0xE7L << 0)    // V1 := V2 * V3, element size = 2**m\n+#define VFD_ZOPC   (unsigned long)(0xe7L << 40 | 0xE5L << 0)    // V1 := V2 / V3, element size = 2**m\n+#define VFSQ_ZOPC  (unsigned long)(0xe7L << 40 | 0xCEL << 0)    // V1 := sqrt of V2, element size = 2**m\n+#define VFLR_ZOPC  (unsigned long)(0xe7L << 40 | 0xC5L << 0)    // vector fp load rounded, element size = 2**m", "source_url": "https://github.com/openjdk/riscv-port/commit/92b26317d444fc63c8b229dfabd2cddd838b9fe4", "code_v0_no_empty_lines": "S390x架构缺乏对SIMD向量指令的支持，无法利用硬件向量单元进行并行计算。", "code_v1_no_empty_lines": "+#define VNX_ZOPC    (unsigned long)(0xe7L << 40 | 0x6cL << 0)   // V1 := !(V2 | V3),  element size = 2**m\n+#define VFA_ZOPC   (unsigned long)(0xe7L << 40 | 0xE3L << 0)    // V1 := V2 + V3, element size = 2**m\n+#define VFS_ZOPC   (unsigned long)(0xe7L << 40 | 0xE2L << 0)    // V1 := V2 - V3, element size = 2**m\n+#define VFM_ZOPC   (unsigned long)(0xe7L << 40 | 0xE7L << 0)    // V1 := V2 * V3, element size = 2**m\n+#define VFD_ZOPC   (unsigned long)(0xe7L << 40 | 0xE5L << 0)    // V1 := V2 / V3, element size = 2**m\n+#define VFSQ_ZOPC  (unsigned long)(0xe7L << 40 | 0xCEL << 0)    // V1 := sqrt of V2, element size = 2**m\n+#define VFLR_ZOPC  (unsigned long)(0xe7L << 40 | 0xC5L << 0)    // vector fp load rounded, element size = 2**m", "target": "+#define VNX_ZOPC    (unsigned long)(0xe7L << 40 | 0x6cL << 0)   // V1 := !(V2 | V3),  element size = 2**m\n+#define VFA_ZOPC   (unsigned long)(0xe7L << 40 | 0xE3L << 0)    // V1 := V2 + V3, element size = 2**m\n+#define VFS_ZOPC   (unsigned long)(0xe7L << 40 | 0xE2L << 0)    // V1 := V2 - V3, element size = 2**m\n+#define VFM_ZOPC   (unsigned long)(0xe7L << 40 | 0xE7L << 0)    // V1 := V2 * V3, element size = 2**m\n+#define VFD_ZOPC   (unsigned long)(0xe7L << 40 | 0xE5L << 0)    // V1 := V2 / V3, element size = 2**m\n+#define VFSQ_ZOPC  (unsigned long)(0xe7L << 40 | 0xCEL << 0)    // V1 := sqrt of V2, element size = 2**m\n+#define VFLR_ZOPC  (unsigned long)(0xe7L << 40 | 0xC5L << 0)    // vector fp load rounded, element size = 2**m", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：S390x架构缺乏对SIMD向量指令的支持，无法利用硬件向量单元进行并行计算。优化后：实现了SLP（Superword Level Parallelism）支持，新增了向量逻辑运算（如VNX）和向量浮点运算（如VFA、VFS、VFM、VFD、VFSQ、VFLR）等指令定义。优化思路：通过扩展汇编器指令集，为S390x架构添加向量化能力，使编译器能够生成SIMD指令，利用硬件并行性提升数值计算和数据处理性能。"}
{"id": 596, "source": "riscv-dataset-excel", "optimization_type": "指令优化+内存访问优化", "optimization_description": "优化前：使用专门的load_narrow_klass_compact_c2宏指令，通过计算对象起始地址偏移来加载压缩类指针，涉及额外的地址计算和专用宏调用。优化后：直接使用标准内存加载指令ldrw加载数据，然后通过右移操作lsrw提取类指针，移除了专用宏指令和复杂的地址计算。优化思路：简化LoadNKlass指令的编码，将专用宏指令内联为标准的加载-移位操作序列，减少指令复杂度和维护成本，同时保持相同的功能。", "original_code": "使用专门的load_narrow_klass_compact_c2宏指令，通过计算对象起始地址偏移来加载压缩类指针，涉及额外的地址计算和专用宏调用。", "optimized_code": "instruct loadNKlassCompactHeaders(iRegNNoSp dst, memory4 mem)\n%{\n  match(Set dst (LoadNKlass mem));\n  predicate(!needs_acquiring_load(n) && UseCompactObjectHeaders);\n\n  ins_cost(4 * INSN_COST);\n  format %{\n    \"ldrw  $dst, $mem\\t# compressed class ptr, shifted\\n\\t\"\n    \"lsrw  $dst, $dst, markWord::klass_shift_at_offset\"\n  %}", "source_url": "https://github.com/openjdk/riscv-port/commit/ff12ff534abb2e08d1bb44a83ef4f84b8476f94c", "code_v0_no_empty_lines": "使用专门的load_narrow_klass_compact_c2宏指令，通过计算对象起始地址偏移来加载压缩类指针，涉及额外的地址计算和专用宏调用。", "code_v1_no_empty_lines": "instruct loadNKlassCompactHeaders(iRegNNoSp dst, memory4 mem)\n%{\n  match(Set dst (LoadNKlass mem));\n  predicate(!needs_acquiring_load(n) && UseCompactObjectHeaders);\n\n  ins_cost(4 * INSN_COST);\n  format %{\n    \"ldrw  $dst, $mem\\t# compressed class ptr, shifted\\n\\t\"\n    \"lsrw  $dst, $dst, markWord::klass_shift_at_offset\"\n  %}", "target": "instruct loadNKlassCompactHeaders(iRegNNoSp dst, memory4 mem)\n%{\n  match(Set dst (LoadNKlass mem));\n  predicate(!needs_acquiring_load(n) && UseCompactObjectHeaders);\n\n  ins_cost(4 * INSN_COST);\n  format %{\n    \"ldrw  $dst, $mem\\t# compressed class ptr, shifted\\n\\t\"\n    \"lsrw  $dst, $dst, markWord::klass_shift_at_offset\"\n  %}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用专门的load_narrow_klass_compact_c2宏指令，通过计算对象起始地址偏移来加载压缩类指针，涉及额外的地址计算和专用宏调用。优化后：直接使用标准内存加载指令ldrw加载数据，然后通过右移操作lsrw提取类指针，移除了专用宏指令和复杂的地址计算。优化思路：简化LoadNKlass指令的编码，将专用宏指令内联为标准的加载-移位操作序列，减少指令复杂度和维护成本，同时保持相同的功能。"}
{"id": 597, "source": "riscv-dataset-excel", "optimization_type": "系统调用优化", "optimization_description": "优化前：使用lutimes系统调用设置文件时间，精度为微秒级，且需要单独处理符号链接。优化后：统一使用futimens/utimensat系统调用，精度提升至纳秒级，通过文件描述符优先避免路径访问竞争，简化了符号链接处理逻辑。优化思路：移除微秒级精度的系统调用，采用更现代、更高精度的纳秒级系统调用，同时改进文件描述符使用策略以提高性能和可靠性。", "original_code": "使用lutimes系统调用设置文件时间，精度为微秒级，且需要单独处理符号链接。", "optimized_code": "- import static sun.nio.fs.UnixNativeDispatcher.lutimes;\n+ import static sun.nio.fs.UnixNativeDispatcher.futimens;\n+ import static sun.nio.fs.UnixNativeDispatcher.utimensat;\n- boolean useLutimes = false;\n+ int fd = -1;\n- TimeUnit timeUnit = useLutimes ? TimeUnit.MICROSECONDS : TimeUnit.NANOSECONDS;\n+ long modValue = lastModifiedTime.to(TimeUnit.NANOSECONDS);\n+ long accessValue = lastAccessTime.to(TimeUnit.NANOSECONDS);\n- if (useLutimes)\n-     lutimes(path, accessValue, modValue);\n- else\n-     futimens(fd, accessValue, modValue);\n+ if (fd >= 0)\n+     futimens(fd, accessValue, modValue);\n+ else\n+     utimensat(UnixConstants.AT_FDCWD, path, accessValue, modValue, flags);", "source_url": "https://github.com/openjdk/riscv-port/commit/7e9dfa4ae4bbafadd2f31fa31df9f25250847200", "code_v0_no_empty_lines": "使用lutimes系统调用设置文件时间，精度为微秒级，且需要单独处理符号链接。", "code_v1_no_empty_lines": "- import static sun.nio.fs.UnixNativeDispatcher.lutimes;\n+ import static sun.nio.fs.UnixNativeDispatcher.futimens;\n+ import static sun.nio.fs.UnixNativeDispatcher.utimensat;\n- boolean useLutimes = false;\n+ int fd = -1;\n- TimeUnit timeUnit = useLutimes ? TimeUnit.MICROSECONDS : TimeUnit.NANOSECONDS;\n+ long modValue = lastModifiedTime.to(TimeUnit.NANOSECONDS);\n+ long accessValue = lastAccessTime.to(TimeUnit.NANOSECONDS);\n- if (useLutimes)\n-     lutimes(path, accessValue, modValue);\n- else\n-     futimens(fd, accessValue, modValue);\n+ if (fd >= 0)\n+     futimens(fd, accessValue, modValue);\n+ else\n+     utimensat(UnixConstants.AT_FDCWD, path, accessValue, modValue, flags);", "target": "- import static sun.nio.fs.UnixNativeDispatcher.lutimes;\n+ import static sun.nio.fs.UnixNativeDispatcher.futimens;\n+ import static sun.nio.fs.UnixNativeDispatcher.utimensat;\n- boolean useLutimes = false;\n+ int fd = -1;\n- TimeUnit timeUnit = useLutimes ? TimeUnit.MICROSECONDS : TimeUnit.NANOSECONDS;\n+ long modValue = lastModifiedTime.to(TimeUnit.NANOSECONDS);\n+ long accessValue = lastAccessTime.to(TimeUnit.NANOSECONDS);\n- if (useLutimes)\n-     lutimes(path, accessValue, modValue);\n- else\n-     futimens(fd, accessValue, modValue);\n+ if (fd >= 0)\n+     futimens(fd, accessValue, modValue);\n+ else\n+     utimensat(UnixConstants.AT_FDCWD, path, accessValue, modValue, flags);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用lutimes系统调用设置文件时间，精度为微秒级，且需要单独处理符号链接。优化后：统一使用futimens/utimensat系统调用，精度提升至纳秒级，通过文件描述符优先避免路径访问竞争，简化了符号链接处理逻辑。优化思路：移除微秒级精度的系统调用，采用更现代、更高精度的纳秒级系统调用，同时改进文件描述符使用策略以提高性能和可靠性。"}
{"id": 598, "source": "riscv-dataset-excel", "optimization_type": "性能优化+事件系统优化", "optimization_description": "优化前：G1ScanCollectionSetRegionClosure在处理每个GC区域时都会发送JFR事件（EventGCPhaseParallel），导致大量事件开销。优化后：将原闭包拆分为G1ScanCodeRootsClosure和G1ScanOptionalRemSetRootsClosure两个专用闭包，并在外层统一发送一次JFR事件，避免每个区域重复发送事件。思路：减少JFR事件发送频率，降低GC暂停时间开销，提升GC性能。", "original_code": "G1ScanCollectionSetRegionClosure在处理每个GC区域时都会发送JFR事件（EventGCPhaseParallel），导致大量事件开销。", "optimized_code": "-class G1ScanCollectionSetRegionClosure : public G1HeapRegionClosure {\n+class G1ScanCodeRootsClosure : public G1HeapRegionClosure {\n+class G1ScanOptionalRemSetRootsClosure : public G1HeapRegionClosure {\n-  EventGCPhaseParallel event;\n-  event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_code_roots_phase));", "source_url": "https://github.com/openjdk/riscv-port/commit/a73226b18e274c44171021760e9eb05bc4a8b711", "code_v0_no_empty_lines": "G1ScanCollectionSetRegionClosure在处理每个GC区域时都会发送JFR事件（EventGCPhaseParallel），导致大量事件开销。", "code_v1_no_empty_lines": "-class G1ScanCollectionSetRegionClosure : public G1HeapRegionClosure {\n+class G1ScanCodeRootsClosure : public G1HeapRegionClosure {\n+class G1ScanOptionalRemSetRootsClosure : public G1HeapRegionClosure {\n-  EventGCPhaseParallel event;\n-  event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_code_roots_phase));", "target": "-class G1ScanCollectionSetRegionClosure : public G1HeapRegionClosure {\n+class G1ScanCodeRootsClosure : public G1HeapRegionClosure {\n+class G1ScanOptionalRemSetRootsClosure : public G1HeapRegionClosure {\n-  EventGCPhaseParallel event;\n-  event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_code_roots_phase));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：G1ScanCollectionSetRegionClosure在处理每个GC区域时都会发送JFR事件（EventGCPhaseParallel），导致大量事件开销。优化后：将原闭包拆分为G1ScanCodeRootsClosure和G1ScanOptionalRemSetRootsClosure两个专用闭包，并在外层统一发送一次JFR事件，避免每个区域重复发送事件。思路：减少JFR事件发送频率，降低GC暂停时间开销，提升GC性能。"}
{"id": 599, "source": "riscv-dataset-excel", "optimization_type": "内存优化+类型优化", "optimization_description": "优化前使用char[]存储ASCII数字字符，每个字符占用2字节。优化后改为byte[]，每个数字仅需1字节，减少内存占用。同时简化了类型转换，因为ASCII数字字符范围0-9完全可以用byte表示。优化思路是通过更紧凑的数据类型减少内存分配和访问开销，提升数值转换性能。", "original_code": "// No original code extracted from description\n", "optimized_code": "- public FDBigInteger(long lValue, char[] digits, int kDigits, int nDigits) {\n+ public FDBigInteger(long lValue, byte[] digits, int kDigits, int nDigits) {\n- char        digits[];\n+ byte[]      digits;\n- char[] digits = new char[ len ];\n+ byte[] digits = new byte[ len ];\n- digits[nDigits++] = c;\n+ digits[nDigits++] = (byte) c;", "source_url": "https://github.com/openjdk/riscv-port/commit/8523880f065efc8e0e527ddf2f14743fc0185593", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- public FDBigInteger(long lValue, char[] digits, int kDigits, int nDigits) {\n+ public FDBigInteger(long lValue, byte[] digits, int kDigits, int nDigits) {\n- char        digits[];\n+ byte[]      digits;\n- char[] digits = new char[ len ];\n+ byte[] digits = new byte[ len ];\n- digits[nDigits++] = c;\n+ digits[nDigits++] = (byte) c;", "target": "- public FDBigInteger(long lValue, char[] digits, int kDigits, int nDigits) {\n+ public FDBigInteger(long lValue, byte[] digits, int kDigits, int nDigits) {\n- char        digits[];\n+ byte[]      digits;\n- char[] digits = new char[ len ];\n+ byte[] digits = new byte[ len ];\n- digits[nDigits++] = c;\n+ digits[nDigits++] = (byte) c;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用char[]存储ASCII数字字符，每个字符占用2字节。优化后改为byte[]，每个数字仅需1字节，减少内存占用。同时简化了类型转换，因为ASCII数字字符范围0-9完全可以用byte表示。优化思路是通过更紧凑的数据类型减少内存分配和访问开销，提升数值转换性能。"}
{"id": 600, "source": "riscv-dataset-excel", "optimization_type": "编译器优化/循环优化", "optimization_description": "优化前：在循环断言谓词（Assertion Predicates）中，当创建模板断言谓词（Template Assertion Predicates）时，会生成包含不常见陷阱（uncommon traps）的节点，这些陷阱在循环展开等优化中可能导致性能开销。优化后：修改为仅使用Halt节点来创建模板断言谓词，移除了不常见陷阱。优化思路：通过简化断言谓词的结构，减少运行时开销，特别是在循环展开和循环切换（loop unswitching）场景下，提高编译后代码的执行效率，同时保持相同的语义保证。", "original_code": "在循环断言谓词（Assertion Predicates）中，当创建模板断言谓词（Template Assertion Predicates）时，会生成包含不常见陷阱（uncommon traps）的节点，这些陷阱在循环展开等优化中可能导致性能开销。", "optimized_code": "- void PhaseIdealLoop::get_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, const bool get_opaque) {\n+ void PhaseIdealLoop::get_template_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, const bool get_opaque) {\n- get_assertion_predicates(old_parse_predicate_proj, list);\n+ get_template_assertion_predicates(old_parse_predicate_proj, list);", "source_url": "https://github.com/openjdk/riscv-port/commit/c977ef7b45c5ab7be37169d4b673134e49c40a41", "code_v0_no_empty_lines": "在循环断言谓词（Assertion Predicates）中，当创建模板断言谓词（Template Assertion Predicates）时，会生成包含不常见陷阱（uncommon traps）的节点，这些陷阱在循环展开等优化中可能导致性能开销。", "code_v1_no_empty_lines": "- void PhaseIdealLoop::get_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, const bool get_opaque) {\n+ void PhaseIdealLoop::get_template_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, const bool get_opaque) {\n- get_assertion_predicates(old_parse_predicate_proj, list);\n+ get_template_assertion_predicates(old_parse_predicate_proj, list);", "target": "- void PhaseIdealLoop::get_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, const bool get_opaque) {\n+ void PhaseIdealLoop::get_template_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, const bool get_opaque) {\n- get_assertion_predicates(old_parse_predicate_proj, list);\n+ get_template_assertion_predicates(old_parse_predicate_proj, list);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在循环断言谓词（Assertion Predicates）中，当创建模板断言谓词（Template Assertion Predicates）时，会生成包含不常见陷阱（uncommon traps）的节点，这些陷阱在循环展开等优化中可能导致性能开销。优化后：修改为仅使用Halt节点来创建模板断言谓词，移除了不常见陷阱。优化思路：通过简化断言谓词的结构，减少运行时开销，特别是在循环展开和循环切换（loop unswitching）场景下，提高编译后代码的执行效率，同时保持相同的语义保证。"}
{"id": 601, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化+内存优化", "optimization_description": "优化前使用Hashtable存储默认二进制属性，每个键值对包含冗余的Boolean.TRUE值，占用额外内存且初始化复杂。优化后改用不可变Set存储纯字符串集合，消除了值存储开销，简化初始化代码，并通过Set.contains()替代Hashtable.containsKey()提高查找效率。", "original_code": "// No original code extracted from description\n", "optimized_code": "- private static final Hashtable<String, Boolean> defaultBinaryAttrs = new Hashtable<>(23,0.75f);\n+ private static final Set<String> defaultBinaryAttrs = Set.of(\n            \"userpassword\",\n            \"javaserializeddata\",\n            \"javaserializedobject\",\n            \"jpegphoto\",\n            \"audio\",\n            \"thumbnailphoto\",\n            \"thumbnaillogo\",\n            \"usercertificate\",\n            \"cacertificate\",\n            \"certificaterevocationlist\",\n            \"authorityrevocationlist\",\n            \"crosscertificatepair\",\n            \"photo\",\n            \"personalsignature\",\n            \"x500uniqueidentifier\"\n    );", "source_url": "https://github.com/openjdk/riscv-port/commit/ffea9809a72777fd6bfac5d0052c7db676aa20d1", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- private static final Hashtable<String, Boolean> defaultBinaryAttrs = new Hashtable<>(23,0.75f);\n+ private static final Set<String> defaultBinaryAttrs = Set.of(\n            \"userpassword\",\n            \"javaserializeddata\",\n            \"javaserializedobject\",\n            \"jpegphoto\",\n            \"audio\",\n            \"thumbnailphoto\",\n            \"thumbnaillogo\",\n            \"usercertificate\",\n            \"cacertificate\",\n            \"certificaterevocationlist\",\n            \"authorityrevocationlist\",\n            \"crosscertificatepair\",\n            \"photo\",\n            \"personalsignature\",\n            \"x500uniqueidentifier\"\n    );", "target": "- private static final Hashtable<String, Boolean> defaultBinaryAttrs = new Hashtable<>(23,0.75f);\n+ private static final Set<String> defaultBinaryAttrs = Set.of(\n            \"userpassword\",\n            \"javaserializeddata\",\n            \"javaserializedobject\",\n            \"jpegphoto\",\n            \"audio\",\n            \"thumbnailphoto\",\n            \"thumbnaillogo\",\n            \"usercertificate\",\n            \"cacertificate\",\n            \"certificaterevocationlist\",\n            \"authorityrevocationlist\",\n            \"crosscertificatepair\",\n            \"photo\",\n            \"personalsignature\",\n            \"x500uniqueidentifier\"\n    );", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用Hashtable存储默认二进制属性，每个键值对包含冗余的Boolean.TRUE值，占用额外内存且初始化复杂。优化后改用不可变Set存储纯字符串集合，消除了值存储开销，简化初始化代码，并通过Set.contains()替代Hashtable.containsKey()提高查找效率。"}
{"id": 602, "source": "riscv-dataset-excel", "optimization_type": "API简化+代码清理", "optimization_description": "优化前：GraphKit::make_load()和store_to_memory()方法需要显式传递slice参数（adr_idx），调用者需要手动计算并验证地址的alias index。优化后：移除slice参数，在方法内部自动通过_gvn.type(adr)->isa_ptr()计算alias index，简化API并减少调用者负担。优化思路：通过内部计算替代外部传递，消除冗余参数，使接口更简洁，同时通过assert验证确保地址类型一致性。", "original_code": "GraphKit::make_load()和store_to_memory()方法需要显式传递slice参数（adr_idx），调用者需要手动计算并验证地址的alias index。", "optimized_code": "- Node* GraphKit::make_load(Node* ctl, Node* adr, const Type* t, BasicType bt,\n+                          int adr_idx,\n                           MemNode::MemOrd mo,\n                           LoadNode::ControlDependency control_dependency,\n                           bool require_atomic_access,\n                           bool unaligned,\n                           bool mismatched,\n                           bool unsafe,\n                           uint8_t barrier_data) {\n-  assert(adr_idx == C->get_alias_index(_gvn.type(adr)->isa_ptr()), \"slice of address and input slice don't match\");\n+  int adr_idx = C->get_alias_index(_gvn.type(adr)->isa_ptr());", "source_url": "https://github.com/openjdk/riscv-port/commit/8af304c60f2758b1a6c6fb53dee6bd66b3d4f6f0", "code_v0_no_empty_lines": "GraphKit::make_load()和store_to_memory()方法需要显式传递slice参数（adr_idx），调用者需要手动计算并验证地址的alias index。", "code_v1_no_empty_lines": "- Node* GraphKit::make_load(Node* ctl, Node* adr, const Type* t, BasicType bt,\n+                          int adr_idx,\n                           MemNode::MemOrd mo,\n                           LoadNode::ControlDependency control_dependency,\n                           bool require_atomic_access,\n                           bool unaligned,\n                           bool mismatched,\n                           bool unsafe,\n                           uint8_t barrier_data) {\n-  assert(adr_idx == C->get_alias_index(_gvn.type(adr)->isa_ptr()), \"slice of address and input slice don't match\");\n+  int adr_idx = C->get_alias_index(_gvn.type(adr)->isa_ptr());", "target": "- Node* GraphKit::make_load(Node* ctl, Node* adr, const Type* t, BasicType bt,\n+                          int adr_idx,\n                           MemNode::MemOrd mo,\n                           LoadNode::ControlDependency control_dependency,\n                           bool require_atomic_access,\n                           bool unaligned,\n                           bool mismatched,\n                           bool unsafe,\n                           uint8_t barrier_data) {\n-  assert(adr_idx == C->get_alias_index(_gvn.type(adr)->isa_ptr()), \"slice of address and input slice don't match\");\n+  int adr_idx = C->get_alias_index(_gvn.type(adr)->isa_ptr());", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：GraphKit::make_load()和store_to_memory()方法需要显式传递slice参数（adr_idx），调用者需要手动计算并验证地址的alias index。优化后：移除slice参数，在方法内部自动通过_gvn.type(adr)->isa_ptr()计算alias index，简化API并减少调用者负担。优化思路：通过内部计算替代外部传递，消除冗余参数，使接口更简洁，同时通过assert验证确保地址类型一致性。"}
{"id": 603, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+架构简化", "optimization_description": "优化前：RISC-V后端使用旧的trampoline调用机制，包含复杂的共享trampoline请求处理、内存分配和重定位逻辑，增加了代码复杂度和运行时开销。优化后：完全移除trampoline相关代码，简化调用路径，将错误消息从'trampoline stub overflow'更新为'reloc call address stub overflow'，并调整调用存根大小计算。优化思路：清理过时的trampoline实现，减少代码体积（删除623行），简化架构，提高编译效率和运行时性能。", "original_code": "RISC-V后端使用旧的trampoline调用机制，包含复杂的共享trampoline请求处理、内存分配和重定位逻辑，增加了代码复杂度和运行时开销。", "optimized_code": "- return emit_shared_stubs_to_interp<MacroAssembler>(this, _shared_stub_to_interp_requests)\n         && emit_shared_trampolines(this, _shared_trampoline_requests);\n+ return emit_shared_stubs_to_interp<MacroAssembler>(this, _shared_stub_to_interp_requests);", "source_url": "https://github.com/openjdk/riscv-port/commit/eb40a88f4076360708402454a494907e8c0c845d", "code_v0_no_empty_lines": "RISC-V后端使用旧的trampoline调用机制，包含复杂的共享trampoline请求处理、内存分配和重定位逻辑，增加了代码复杂度和运行时开销。", "code_v1_no_empty_lines": "- return emit_shared_stubs_to_interp<MacroAssembler>(this, _shared_stub_to_interp_requests)\n         && emit_shared_trampolines(this, _shared_trampoline_requests);\n+ return emit_shared_stubs_to_interp<MacroAssembler>(this, _shared_stub_to_interp_requests);", "target": "- return emit_shared_stubs_to_interp<MacroAssembler>(this, _shared_stub_to_interp_requests)\n         && emit_shared_trampolines(this, _shared_trampoline_requests);\n+ return emit_shared_stubs_to_interp<MacroAssembler>(this, _shared_stub_to_interp_requests);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V后端使用旧的trampoline调用机制，包含复杂的共享trampoline请求处理、内存分配和重定位逻辑，增加了代码复杂度和运行时开销。优化后：完全移除trampoline相关代码，简化调用路径，将错误消息从'trampoline stub overflow'更新为'reloc call address stub overflow'，并调整调用存根大小计算。优化思路：清理过时的trampoline实现，减少代码体积（删除623行），简化架构，提高编译效率和运行时性能。"}
{"id": 604, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+性能优化", "optimization_description": "优化前：CRC32 intrinsic仅在CPU支持Zba指令集时启用。优化后：CRC32 intrinsic在CPU支持Zba或RVV指令集时均可启用。优化思路：扩展CRC32 intrinsic的启用条件，使更多RISC-V处理器能够利用硬件加速的CRC32计算，提升相关操作的性能。", "original_code": "CRC32 intrinsic仅在CPU支持Zba指令集时启用。", "optimized_code": "-  if (UseZba) {\n-    if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n-      FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);\n-    }\n-  } else {\n-    if (!FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n-      warning(\"CRC32 intrinsic requires Zba instructions (not available on this CPU)\");\n-    }\n-    FLAG_SET_DEFAULT(UseCRC32Intrinsics, false);\n-  }\n+  if (UseZba || UseRVV) {\n+    if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);\n+    }\n+  } else {\n+    if (!FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n+      warning(\"CRC32 intrinsic requires Zba or RVV instructions (not available on this CPU)\");\n+    }\n+    FLAG_SET_DEFAULT(UseCRC32Intrinsics, false);\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/2c1e4c381615ce52276f4bf331a1e7a845af4b6e", "code_v0_no_empty_lines": "CRC32 intrinsic仅在CPU支持Zba指令集时启用。", "code_v1_no_empty_lines": "-  if (UseZba) {\n-    if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n-      FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);\n-    }\n-  } else {\n-    if (!FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n-      warning(\"CRC32 intrinsic requires Zba instructions (not available on this CPU)\");\n-    }\n-    FLAG_SET_DEFAULT(UseCRC32Intrinsics, false);\n-  }\n+  if (UseZba || UseRVV) {\n+    if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);\n+    }\n+  } else {\n+    if (!FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n+      warning(\"CRC32 intrinsic requires Zba or RVV instructions (not available on this CPU)\");\n+    }\n+    FLAG_SET_DEFAULT(UseCRC32Intrinsics, false);\n+  }", "target": "-  if (UseZba) {\n-    if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n-      FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);\n-    }\n-  } else {\n-    if (!FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n-      warning(\"CRC32 intrinsic requires Zba instructions (not available on this CPU)\");\n-    }\n-    FLAG_SET_DEFAULT(UseCRC32Intrinsics, false);\n-  }\n+  if (UseZba || UseRVV) {\n+    if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);\n+    }\n+  } else {\n+    if (!FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n+      warning(\"CRC32 intrinsic requires Zba or RVV instructions (not available on this CPU)\");\n+    }\n+    FLAG_SET_DEFAULT(UseCRC32Intrinsics, false);\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CRC32 intrinsic仅在CPU支持Zba指令集时启用。优化后：CRC32 intrinsic在CPU支持Zba或RVV指令集时均可启用。优化思路：扩展CRC32 intrinsic的启用条件，使更多RISC-V处理器能够利用硬件加速的CRC32计算，提升相关操作的性能。"}
{"id": 605, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（循环展开）", "optimization_description": "优化前：断言谓词类型（AssertionPredicateType）仅在非产品构建（NOT_PRODUCT）中可用，导致循环展开时无法正确更新最后值断言谓词（Last Value Assertion Predicates）。优化后：将断言谓词类型相关代码从NOT_PRODUCT宏中移除，使其在产品构建中也可用，确保循环展开时仅更新必要的最后值断言谓词，避免不必要的谓词更新开销。优化思路：通过使断言谓词类型信息在运行时可用，编译器能更精确地控制循环展开过程中的谓词更新，减少冗余操作，提升编译性能。", "original_code": "断言谓词类型（AssertionPredicateType）仅在非产品构建（NOT_PRODUCT）中可用，导致循环展开时无法正确更新最后值断言谓词（Last Value Assertion Predicates）。", "optimized_code": "- NOT_PRODUCT(AssertionPredicateType _assertion_predicate_type;)\n+ AssertionPredicateType _assertion_predicate_type;\n- NOT_PRODUCT(IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);)\n+ IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);\n- NOT_PRODUCT(COMMA _assertion_predicate_type(AssertionPredicateType::None)) {\n+ _fcnt(fcnt),\n+ _assertion_predicate_type(AssertionPredicateType::None) {\n- NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n+ const bool rewire_uncommon_proj_phi_inputs,\n+ AssertionPredicateType assertion_predicate_type) {", "source_url": "https://github.com/openjdk/riscv-port/commit/3727f4046188bb623f9efec6fa149f767a9ffa30", "code_v0_no_empty_lines": "断言谓词类型（AssertionPredicateType）仅在非产品构建（NOT_PRODUCT）中可用，导致循环展开时无法正确更新最后值断言谓词（Last Value Assertion Predicates）。", "code_v1_no_empty_lines": "- NOT_PRODUCT(AssertionPredicateType _assertion_predicate_type;)\n+ AssertionPredicateType _assertion_predicate_type;\n- NOT_PRODUCT(IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);)\n+ IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);\n- NOT_PRODUCT(COMMA _assertion_predicate_type(AssertionPredicateType::None)) {\n+ _fcnt(fcnt),\n+ _assertion_predicate_type(AssertionPredicateType::None) {\n- NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n+ const bool rewire_uncommon_proj_phi_inputs,\n+ AssertionPredicateType assertion_predicate_type) {", "target": "- NOT_PRODUCT(AssertionPredicateType _assertion_predicate_type;)\n+ AssertionPredicateType _assertion_predicate_type;\n- NOT_PRODUCT(IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);)\n+ IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);\n- NOT_PRODUCT(COMMA _assertion_predicate_type(AssertionPredicateType::None)) {\n+ _fcnt(fcnt),\n+ _assertion_predicate_type(AssertionPredicateType::None) {\n- NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n+ const bool rewire_uncommon_proj_phi_inputs,\n+ AssertionPredicateType assertion_predicate_type) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：断言谓词类型（AssertionPredicateType）仅在非产品构建（NOT_PRODUCT）中可用，导致循环展开时无法正确更新最后值断言谓词（Last Value Assertion Predicates）。优化后：将断言谓词类型相关代码从NOT_PRODUCT宏中移除，使其在产品构建中也可用，确保循环展开时仅更新必要的最后值断言谓词，避免不必要的谓词更新开销。优化思路：通过使断言谓词类型信息在运行时可用，编译器能更精确地控制循环展开过程中的谓词更新，减少冗余操作，提升编译性能。"}
{"id": 606, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（C2 IR优化）", "optimization_description": "优化前：当AddP节点的偏移量输入发生变化时，工作列表仅更新相关的内存节点（Mem），但未重新处理具有常量偏移量的后续AddP节点，导致地址表达式扁平化机会被错过。优化后：在PhaseIterGVN中，当检测到AddP节点的偏移量输入变化时，额外将具有常量偏移量的后续AddP节点加入工作列表，触发进一步的理想化（如常量折叠和地址合并）。优化思路：通过更积极地重新审视常量偏移量AddP链，在编译时消除冗余地址计算，提升生成代码的效率。", "original_code": "当AddP节点的偏移量输入发生变化时，工作列表仅更新相关的内存节点（Mem），但未重新处理具有常量偏移量的后续AddP节点，导致地址表达式扁平化机会被错过。", "optimized_code": "if (use_op == Op_AddP) {\n+    bool offset_changed = n == use->in(AddPNode::Offset);\n    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n      Node* u = use->fast_out(i2);\n-      if (u->is_Mem())\n+      if (u->is_Mem()) {\n         worklist.push(u);\n+      } else if (offset_changed && u->is_AddP() && u->in(AddPNode::Offset)->is_Con()) {\n+        worklist.push(u);\n+      }\n    }\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/ec13364cdab5a52f704bc5d1575f3da17380b4f2", "code_v0_no_empty_lines": "当AddP节点的偏移量输入发生变化时，工作列表仅更新相关的内存节点（Mem），但未重新处理具有常量偏移量的后续AddP节点，导致地址表达式扁平化机会被错过。", "code_v1_no_empty_lines": "if (use_op == Op_AddP) {\n+    bool offset_changed = n == use->in(AddPNode::Offset);\n    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n      Node* u = use->fast_out(i2);\n-      if (u->is_Mem())\n+      if (u->is_Mem()) {\n         worklist.push(u);\n+      } else if (offset_changed && u->is_AddP() && u->in(AddPNode::Offset)->is_Con()) {\n+        worklist.push(u);\n+      }\n    }\n  }", "target": "if (use_op == Op_AddP) {\n+    bool offset_changed = n == use->in(AddPNode::Offset);\n    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n      Node* u = use->fast_out(i2);\n-      if (u->is_Mem())\n+      if (u->is_Mem()) {\n         worklist.push(u);\n+      } else if (offset_changed && u->is_AddP() && u->in(AddPNode::Offset)->is_Con()) {\n+        worklist.push(u);\n+      }\n    }\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当AddP节点的偏移量输入发生变化时，工作列表仅更新相关的内存节点（Mem），但未重新处理具有常量偏移量的后续AddP节点，导致地址表达式扁平化机会被错过。优化后：在PhaseIterGVN中，当检测到AddP节点的偏移量输入变化时，额外将具有常量偏移量的后续AddP节点加入工作列表，触发进一步的理想化（如常量折叠和地址合并）。优化思路：通过更积极地重新审视常量偏移量AddP链，在编译时消除冗余地址计算，提升生成代码的效率。"}
{"id": 607, "source": "riscv-dataset-excel", "optimization_type": "代码清理与维护优化", "optimization_description": "优化前：C1编译器指令类中包含了多个未使用的标志位（IsEliminatedFlag、NeedsStoreCheckFlag、NeedsWriteBarrierFlag、InWorkListFlag）及相关设置和检查代码，增加了代码复杂度和维护成本。优化后：完全移除这些未使用的标志位定义、设置逻辑和访问方法，简化了代码结构。优化思路：通过清理无用代码减少编译器的内存占用，提高代码可读性和维护性，同时可能带来微小的编译性能提升。", "original_code": "C1编译器指令类中包含了多个未使用的标志位（IsEliminatedFlag、NeedsStoreCheckFlag、NeedsWriteBarrierFlag、InWorkListFlag）及相关设置和检查代码，增加了代码复杂度和维护成本。", "optimized_code": "-    IsEliminatedFlag,\n-    NeedsStoreCheckFlag,\n-    NeedsWriteBarrierFlag,\n-    InWorkListFlag,\n-    set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())->is_object());\n-  bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }\n-    set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)->is_object()));\n-    set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)->is_object()));\n-  bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }\n-  bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }", "source_url": "https://github.com/openjdk/riscv-port/commit/ae6bb3cd29bd4cdbb2df320fbfe0dabb7c0647d7", "code_v0_no_empty_lines": "C1编译器指令类中包含了多个未使用的标志位（IsEliminatedFlag、NeedsStoreCheckFlag、NeedsWriteBarrierFlag、InWorkListFlag）及相关设置和检查代码，增加了代码复杂度和维护成本。", "code_v1_no_empty_lines": "-    IsEliminatedFlag,\n-    NeedsStoreCheckFlag,\n-    NeedsWriteBarrierFlag,\n-    InWorkListFlag,\n-    set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())->is_object());\n-  bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }\n-    set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)->is_object()));\n-    set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)->is_object()));\n-  bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }\n-  bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }", "target": "-    IsEliminatedFlag,\n-    NeedsStoreCheckFlag,\n-    NeedsWriteBarrierFlag,\n-    InWorkListFlag,\n-    set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())->is_object());\n-  bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }\n-    set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)->is_object()));\n-    set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)->is_object()));\n-  bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }\n-  bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C1编译器指令类中包含了多个未使用的标志位（IsEliminatedFlag、NeedsStoreCheckFlag、NeedsWriteBarrierFlag、InWorkListFlag）及相关设置和检查代码，增加了代码复杂度和维护成本。优化后：完全移除这些未使用的标志位定义、设置逻辑和访问方法，简化了代码结构。优化思路：通过清理无用代码减少编译器的内存占用，提高代码可读性和维护性，同时可能带来微小的编译性能提升。"}
{"id": 608, "source": "riscv-dataset-excel", "optimization_type": "代码重构+性能优化", "optimization_description": "优化前：在StringConcatHelper.java中，布尔值转换为字符串时，通过多个独立的字符赋值操作将'true'和'false'写入缓冲区，代码重复且冗长。优化后：复用StringLatin1::putCharsAt和StringUTF16::putCharsAt方法，通过单个方法调用完成多个字符的批量写入。优化思路：减少代码重复，提高代码可维护性，同时可能通过批量操作获得更好的缓存局部性和性能。", "original_code": "在StringConcatHelper.java中，布尔值转换为字符串时，通过多个独立的字符赋值操作将'true'和'false'写入缓冲区，代码重复且冗长。", "optimized_code": "- buf[index] = 't';\n- buf[index + 1] = 'r';\n- buf[index + 2] = 'u';\n- buf[index + 3] = 'e';\n+ StringLatin1.putCharsAt(buf, index, 't', 'r', 'u', 'e');\n\n- StringUTF16.putChar(buf, index, 't');\n- StringUTF16.putChar(buf, index + 1, 'r');\n- StringUTF16.putChar(buf, index + 2, 'u');\n- StringUTF16.putChar(buf, index + 3, 'e');\n+ StringUTF16.putCharsAt(buf, index, 't', 'r', 'u', 'e');", "source_url": "https://github.com/openjdk/riscv-port/commit/74ae3c688b37e693e20eb4e17c631897c5464400", "code_v0_no_empty_lines": "在StringConcatHelper.java中，布尔值转换为字符串时，通过多个独立的字符赋值操作将'true'和'false'写入缓冲区，代码重复且冗长。", "code_v1_no_empty_lines": "- buf[index] = 't';\n- buf[index + 1] = 'r';\n- buf[index + 2] = 'u';\n- buf[index + 3] = 'e';\n+ StringLatin1.putCharsAt(buf, index, 't', 'r', 'u', 'e');\n\n- StringUTF16.putChar(buf, index, 't');\n- StringUTF16.putChar(buf, index + 1, 'r');\n- StringUTF16.putChar(buf, index + 2, 'u');\n- StringUTF16.putChar(buf, index + 3, 'e');\n+ StringUTF16.putCharsAt(buf, index, 't', 'r', 'u', 'e');", "target": "- buf[index] = 't';\n- buf[index + 1] = 'r';\n- buf[index + 2] = 'u';\n- buf[index + 3] = 'e';\n+ StringLatin1.putCharsAt(buf, index, 't', 'r', 'u', 'e');\n\n- StringUTF16.putChar(buf, index, 't');\n- StringUTF16.putChar(buf, index + 1, 'r');\n- StringUTF16.putChar(buf, index + 2, 'u');\n- StringUTF16.putChar(buf, index + 3, 'e');\n+ StringUTF16.putCharsAt(buf, index, 't', 'r', 'u', 'e');", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在StringConcatHelper.java中，布尔值转换为字符串时，通过多个独立的字符赋值操作将'true'和'false'写入缓冲区，代码重复且冗长。优化后：复用StringLatin1::putCharsAt和StringUTF16::putCharsAt方法，通过单个方法调用完成多个字符的批量写入。优化思路：减少代码重复，提高代码可维护性，同时可能通过批量操作获得更好的缓存局部性和性能。"}
{"id": 609, "source": "riscv-dataset-excel", "optimization_type": "代码重构+设计模式优化", "optimization_description": "优化前：在循环展开时，update_main_loop_assertion_predicates函数通过手动遍历控制流图来查找和更新断言谓词，代码复杂且包含大量条件判断和手动节点操作。优化后：引入PredicateIterator访问器和UpdateStrideForAssertionPredicates函数对象，采用访问者模式重构代码。优化思路：将谓词遍历逻辑抽象为独立的迭代器，将更新操作封装为函数对象，通过for_each方法统一处理，提高了代码的可读性、可维护性和可扩展性，减少了手动控制流遍历的复杂性。", "original_code": "在循环展开时，update_main_loop_assertion_predicates函数通过手动遍历控制流图来查找和更新断言谓词，代码复杂且包含大量条件判断和手动节点操作。", "optimized_code": "- while (entry != nullptr && entry->is_Proj() && entry->in(0)->is_If()) {\n    IfNode* iff = entry->in(0)->as_If();\n    ProjNode* proj = iff->proj_out(1 - entry->as_Proj()->_con);\n    if (!proj->unique_ctrl_out()->is_Halt()) {\n      break;\n    }\n    Node* bol = iff->in(1);\n    if (bol->is_OpaqueTemplateAssertionPredicate()) {\n      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n      // This is a Template Assertion Predicate for the initial or last access.\n      // Create an Initialized Assertion Predicates for it accordingly:\n      // - For the initial access a[init] (same as before)\n      // - For the last access a[init+new_stride-orig_stride] (with the new unroll stride)\n      prev_proj = create_initialized_assertion_predicate(iff, init, max_value, prev_proj);\n    } else if (bol->is_OpaqueInitializedAssertionPredicate()) {\n      // This is one of the two Initialized Assertion Predicates:\n      // - For the initial access a[init]\n      // - For the last access a[init+old_stride-orig_stride]\n      // We could keep the one for the initial access but we do not know which one we currently have here. Just kill both.\n      _igvn.replace_input_of(iff, 1, _igvn.intcon(1));\n    }\n    assert(!bol->is_OpaqueNotNull() || !loop_head->is_main_loop(), \"OpaqueNotNull should not be at main loop\");\n    entry = entry->in(0)->in(0);\n  }\n  if (prev_proj != ctrl) {\n    _igvn.replace_input_of(outer_loop_head, LoopNode::EntryControl, prev_proj);\n    set_idom(outer_loop_head, prev_proj, dom_depth(outer_loop_head));\n  }\n+  Node* loop_entry = main_loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  PredicateIterator predicate_iterator(loop_entry);\n+  UpdateStrideForAssertionPredicates update_stride_for_assertion_predicates(unrolled_stride, this);\n+  predicate_iterator.for_each(update_stride_for_assertion_predicates);", "source_url": "https://github.com/openjdk/riscv-port/commit/5f338e9adbcf7fe7ee90abfd34a24a3a93c22211", "code_v0_no_empty_lines": "在循环展开时，update_main_loop_assertion_predicates函数通过手动遍历控制流图来查找和更新断言谓词，代码复杂且包含大量条件判断和手动节点操作。", "code_v1_no_empty_lines": "- while (entry != nullptr && entry->is_Proj() && entry->in(0)->is_If()) {\n    IfNode* iff = entry->in(0)->as_If();\n    ProjNode* proj = iff->proj_out(1 - entry->as_Proj()->_con);\n    if (!proj->unique_ctrl_out()->is_Halt()) {\n      break;\n    }\n    Node* bol = iff->in(1);\n    if (bol->is_OpaqueTemplateAssertionPredicate()) {\n      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n      // This is a Template Assertion Predicate for the initial or last access.\n      // Create an Initialized Assertion Predicates for it accordingly:\n      // - For the initial access a[init] (same as before)\n      // - For the last access a[init+new_stride-orig_stride] (with the new unroll stride)\n      prev_proj = create_initialized_assertion_predicate(iff, init, max_value, prev_proj);\n    } else if (bol->is_OpaqueInitializedAssertionPredicate()) {\n      // This is one of the two Initialized Assertion Predicates:\n      // - For the initial access a[init]\n      // - For the last access a[init+old_stride-orig_stride]\n      // We could keep the one for the initial access but we do not know which one we currently have here. Just kill both.\n      _igvn.replace_input_of(iff, 1, _igvn.intcon(1));\n    }\n    assert(!bol->is_OpaqueNotNull() || !loop_head->is_main_loop(), \"OpaqueNotNull should not be at main loop\");\n    entry = entry->in(0)->in(0);\n  }\n  if (prev_proj != ctrl) {\n    _igvn.replace_input_of(outer_loop_head, LoopNode::EntryControl, prev_proj);\n    set_idom(outer_loop_head, prev_proj, dom_depth(outer_loop_head));\n  }\n+  Node* loop_entry = main_loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  PredicateIterator predicate_iterator(loop_entry);\n+  UpdateStrideForAssertionPredicates update_stride_for_assertion_predicates(unrolled_stride, this);\n+  predicate_iterator.for_each(update_stride_for_assertion_predicates);", "target": "- while (entry != nullptr && entry->is_Proj() && entry->in(0)->is_If()) {\n    IfNode* iff = entry->in(0)->as_If();\n    ProjNode* proj = iff->proj_out(1 - entry->as_Proj()->_con);\n    if (!proj->unique_ctrl_out()->is_Halt()) {\n      break;\n    }\n    Node* bol = iff->in(1);\n    if (bol->is_OpaqueTemplateAssertionPredicate()) {\n      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n      // This is a Template Assertion Predicate for the initial or last access.\n      // Create an Initialized Assertion Predicates for it accordingly:\n      // - For the initial access a[init] (same as before)\n      // - For the last access a[init+new_stride-orig_stride] (with the new unroll stride)\n      prev_proj = create_initialized_assertion_predicate(iff, init, max_value, prev_proj);\n    } else if (bol->is_OpaqueInitializedAssertionPredicate()) {\n      // This is one of the two Initialized Assertion Predicates:\n      // - For the initial access a[init]\n      // - For the last access a[init+old_stride-orig_stride]\n      // We could keep the one for the initial access but we do not know which one we currently have here. Just kill both.\n      _igvn.replace_input_of(iff, 1, _igvn.intcon(1));\n    }\n    assert(!bol->is_OpaqueNotNull() || !loop_head->is_main_loop(), \"OpaqueNotNull should not be at main loop\");\n    entry = entry->in(0)->in(0);\n  }\n  if (prev_proj != ctrl) {\n    _igvn.replace_input_of(outer_loop_head, LoopNode::EntryControl, prev_proj);\n    set_idom(outer_loop_head, prev_proj, dom_depth(outer_loop_head));\n  }\n+  Node* loop_entry = main_loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  PredicateIterator predicate_iterator(loop_entry);\n+  UpdateStrideForAssertionPredicates update_stride_for_assertion_predicates(unrolled_stride, this);\n+  predicate_iterator.for_each(update_stride_for_assertion_predicates);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在循环展开时，update_main_loop_assertion_predicates函数通过手动遍历控制流图来查找和更新断言谓词，代码复杂且包含大量条件判断和手动节点操作。优化后：引入PredicateIterator访问器和UpdateStrideForAssertionPredicates函数对象，采用访问者模式重构代码。优化思路：将谓词遍历逻辑抽象为独立的迭代器，将更新操作封装为函数对象，通过for_each方法统一处理，提高了代码的可读性、可维护性和可扩展性，减少了手动控制流遍历的复杂性。"}
{"id": 610, "source": "riscv-dataset-excel", "optimization_type": "代码简化+类型安全优化", "optimization_description": "优化前：构造函数中使用reinterpret_cast将TypePtr*强制转换为Type*，type()方法中使用reinterpret_cast将Type*强制转换回TypePtr*，存在不必要的类型转换和潜在的类型安全问题。优化后：构造函数直接传递TypePtr*参数，type()方法使用类型安全的is_ptr()方法获取指针类型，消除了不必要的reinterpret_cast，提高了代码的可读性和类型安全性。", "original_code": "构造函数中使用reinterpret_cast将TypePtr*强制转换为Type*，type()方法中使用reinterpret_cast将Type*强制转换回TypePtr*，存在不必要的类型转换和潜在的类型安全问题。", "optimized_code": "-    C2AccessValue(node, reinterpret_cast<const Type*>(type)) {}\n+    C2AccessValue(node, type) {}\n-  const TypePtr* type() const { return reinterpret_cast<const TypePtr*>(_type); }\n+  const TypePtr* type() const { return _type->is_ptr(); }", "source_url": "https://github.com/openjdk/riscv-port/commit/5b2f7f3b30adf9942fa8a3382e7661d6816fbb38", "code_v0_no_empty_lines": "构造函数中使用reinterpret_cast将TypePtr*强制转换为Type*，type()方法中使用reinterpret_cast将Type*强制转换回TypePtr*，存在不必要的类型转换和潜在的类型安全问题。", "code_v1_no_empty_lines": "-    C2AccessValue(node, reinterpret_cast<const Type*>(type)) {}\n+    C2AccessValue(node, type) {}\n-  const TypePtr* type() const { return reinterpret_cast<const TypePtr*>(_type); }\n+  const TypePtr* type() const { return _type->is_ptr(); }", "target": "-    C2AccessValue(node, reinterpret_cast<const Type*>(type)) {}\n+    C2AccessValue(node, type) {}\n-  const TypePtr* type() const { return reinterpret_cast<const TypePtr*>(_type); }\n+  const TypePtr* type() const { return _type->is_ptr(); }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：构造函数中使用reinterpret_cast将TypePtr*强制转换为Type*，type()方法中使用reinterpret_cast将Type*强制转换回TypePtr*，存在不必要的类型转换和潜在的类型安全问题。优化后：构造函数直接传递TypePtr*参数，type()方法使用类型安全的is_ptr()方法获取指针类型，消除了不必要的reinterpret_cast，提高了代码的可读性和类型安全性。"}
{"id": 611, "source": "riscv-dataset-excel", "optimization_type": "GC算法优化+内存碎片整理", "optimization_description": "优化前：SplitInfo::record()方法基于源区域索引、部分对象大小和目标地址计算分割信息，逻辑复杂且容易出错，特别是在处理跨区域的部分对象时。优化后：重构为基于分割点、前导存活字数和目标地址的简化模型，直接记录分割区域索引、分割点位置和前导部分的目标信息，减少了计算复杂度。优化思路：通过重新设计数据结构和方法，简化Full GC中内存碎片整理的分割逻辑，提高并行压缩的效率和可靠性，减少碎片化问题。", "original_code": "SplitInfo::record()方法基于源区域索引、部分对象大小和目标地址计算分割信息，逻辑复杂且容易出错，特别是在处理跨区域的部分对象时。", "optimized_code": "- void SplitInfo::record(size_t src_region_idx, size_t partial_obj_size,\n-                        HeapWord* destination)\n+ void SplitInfo::record(size_t split_region_idx, HeapWord* split_point, size_t preceding_live_words)", "source_url": "https://github.com/openjdk/riscv-port/commit/423e8e0999f53aa0bf95a7505a771dab3dd5c8d6", "code_v0_no_empty_lines": "SplitInfo::record()方法基于源区域索引、部分对象大小和目标地址计算分割信息，逻辑复杂且容易出错，特别是在处理跨区域的部分对象时。", "code_v1_no_empty_lines": "- void SplitInfo::record(size_t src_region_idx, size_t partial_obj_size,\n-                        HeapWord* destination)\n+ void SplitInfo::record(size_t split_region_idx, HeapWord* split_point, size_t preceding_live_words)", "target": "- void SplitInfo::record(size_t src_region_idx, size_t partial_obj_size,\n-                        HeapWord* destination)\n+ void SplitInfo::record(size_t split_region_idx, HeapWord* split_point, size_t preceding_live_words)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SplitInfo::record()方法基于源区域索引、部分对象大小和目标地址计算分割信息，逻辑复杂且容易出错，特别是在处理跨区域的部分对象时。优化后：重构为基于分割点、前导存活字数和目标地址的简化模型，直接记录分割区域索引、分割点位置和前导部分的目标信息，减少了计算复杂度。优化思路：通过重新设计数据结构和方法，简化Full GC中内存碎片整理的分割逻辑，提高并行压缩的效率和可靠性，减少碎片化问题。"}
{"id": 612, "source": "riscv-dataset-excel", "optimization_type": "启动性能优化", "optimization_description": "优化前：set_initial()方法直接将初始值添加到_young_only_seq序列中，导致在启动阶段需要初始化序列数据结构，增加了启动开销。优化后：新增_initial_value成员变量存储初始值，set_initial()仅存储值而不操作序列，predict()方法在序列为空时直接返回_initial_value。优化思路：延迟序列数据结构的初始化，避免启动时的额外开销，从而改善G1垃圾收集器因预测器初始化导致的启动缓慢问题。", "original_code": "set_initial()方法直接将初始值添加到_young_only_seq序列中，导致在启动阶段需要初始化序列数据结构，增加了启动开销。", "optimized_code": "--- a/src/hotspot/share/gc/g1/g1AnalyticsSequences.hpp\n+++ b/src/hotspot/share/gc/g1/g1AnalyticsSequences.hpp\n@@ -35,6 +35,7 @@ class G1Predictions;\n // Container for TruncatedSeqs that need separate predictors by GC phase.\n class G1PhaseDependentSeq {\n   TruncatedSeq _young_only_seq;\n+  double _initial_value;\n   TruncatedSeq _mixed_seq;\n \n   NONCOPYABLE(G1PhaseDependentSeq);\n--- a/src/hotspot/share/gc/g1/g1AnalyticsSequences.inline.hpp\n+++ b/src/hotspot/share/gc/g1/g1AnalyticsSequences.inline.hpp\n@@ -42,7 +43,7 @@ TruncatedSeq* G1PhaseDependentSeq::seq_raw(bool use_young_only_phase_seq) {\n }\n \n void G1PhaseDependentSeq::set_initial(double value) {\n-  _young_only_seq.add(value);\n+  _initial_value = value;\n }\n \n void G1PhaseDependentSeq::add(double value, bool for_young_only_phase) {\n@@ -51,8 +52,12 @@ void G1PhaseDependentSeq::add(double value, bool for_young_only_phase) {\n \n double G1PhaseDependentSeq::predict(const G1Predictions* predictor, bool use_young_only_phase_seq) const {\n   if (use_young_only_phase_seq || !enough_samples_to_use_mixed_seq()) {\n+    if (_young_only_seq.num() == 0) {\n+      return _initial_value;\n+    }\n     return predictor->predict(&_young_only_seq);\n   } else {\n+    assert(_mixed_seq.num() > 0, \"must not ask this with no samples\");\n     return predictor->predict(&_mixed_seq);\n   }\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/c7f071cf36a6f064e293e82e7e5bb0abcc76ad70", "code_v0_no_empty_lines": "set_initial()方法直接将初始值添加到_young_only_seq序列中，导致在启动阶段需要初始化序列数据结构，增加了启动开销。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/gc/g1/g1AnalyticsSequences.hpp\n+++ b/src/hotspot/share/gc/g1/g1AnalyticsSequences.hpp\n@@ -35,6 +35,7 @@ class G1Predictions;\n // Container for TruncatedSeqs that need separate predictors by GC phase.\n class G1PhaseDependentSeq {\n   TruncatedSeq _young_only_seq;\n+  double _initial_value;\n   TruncatedSeq _mixed_seq;\n \n   NONCOPYABLE(G1PhaseDependentSeq);\n--- a/src/hotspot/share/gc/g1/g1AnalyticsSequences.inline.hpp\n+++ b/src/hotspot/share/gc/g1/g1AnalyticsSequences.inline.hpp\n@@ -42,7 +43,7 @@ TruncatedSeq* G1PhaseDependentSeq::seq_raw(bool use_young_only_phase_seq) {\n }\n \n void G1PhaseDependentSeq::set_initial(double value) {\n-  _young_only_seq.add(value);\n+  _initial_value = value;\n }\n \n void G1PhaseDependentSeq::add(double value, bool for_young_only_phase) {\n@@ -51,8 +52,12 @@ void G1PhaseDependentSeq::add(double value, bool for_young_only_phase) {\n \n double G1PhaseDependentSeq::predict(const G1Predictions* predictor, bool use_young_only_phase_seq) const {\n   if (use_young_only_phase_seq || !enough_samples_to_use_mixed_seq()) {\n+    if (_young_only_seq.num() == 0) {\n+      return _initial_value;\n+    }\n     return predictor->predict(&_young_only_seq);\n   } else {\n+    assert(_mixed_seq.num() > 0, \"must not ask this with no samples\");\n     return predictor->predict(&_mixed_seq);\n   }\n }", "target": "--- a/src/hotspot/share/gc/g1/g1AnalyticsSequences.hpp\n+++ b/src/hotspot/share/gc/g1/g1AnalyticsSequences.hpp\n@@ -35,6 +35,7 @@ class G1Predictions;\n // Container for TruncatedSeqs that need separate predictors by GC phase.\n class G1PhaseDependentSeq {\n   TruncatedSeq _young_only_seq;\n+  double _initial_value;\n   TruncatedSeq _mixed_seq;\n \n   NONCOPYABLE(G1PhaseDependentSeq);\n--- a/src/hotspot/share/gc/g1/g1AnalyticsSequences.inline.hpp\n+++ b/src/hotspot/share/gc/g1/g1AnalyticsSequences.inline.hpp\n@@ -42,7 +43,7 @@ TruncatedSeq* G1PhaseDependentSeq::seq_raw(bool use_young_only_phase_seq) {\n }\n \n void G1PhaseDependentSeq::set_initial(double value) {\n-  _young_only_seq.add(value);\n+  _initial_value = value;\n }\n \n void G1PhaseDependentSeq::add(double value, bool for_young_only_phase) {\n@@ -51,8 +52,12 @@ void G1PhaseDependentSeq::add(double value, bool for_young_only_phase) {\n \n double G1PhaseDependentSeq::predict(const G1Predictions* predictor, bool use_young_only_phase_seq) const {\n   if (use_young_only_phase_seq || !enough_samples_to_use_mixed_seq()) {\n+    if (_young_only_seq.num() == 0) {\n+      return _initial_value;\n+    }\n     return predictor->predict(&_young_only_seq);\n   } else {\n+    assert(_mixed_seq.num() > 0, \"must not ask this with no samples\");\n     return predictor->predict(&_mixed_seq);\n   }\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：set_initial()方法直接将初始值添加到_young_only_seq序列中，导致在启动阶段需要初始化序列数据结构，增加了启动开销。优化后：新增_initial_value成员变量存储初始值，set_initial()仅存储值而不操作序列，predict()方法在序列为空时直接返回_initial_value。优化思路：延迟序列数据结构的初始化，避免启动时的额外开销，从而改善G1垃圾收集器因预测器初始化导致的启动缓慢问题。"}
{"id": 613, "source": "riscv-dataset-excel", "optimization_type": "内存访问优化+指令集优化", "optimization_description": "优化前：secondary_super_cache 在多线程环境下扩展性差，C1 编译器和解释器中的子类型检查（如 instanceof/checkcast）性能受限，主要依赖缓存查找，存在竞争和缓存未命中问题。优化后：引入二级超类表（secondary supers table）机制，通过哈希槽（hash_slot）直接定位超类，减少内存访问和缓存竞争。具体修改包括：1. 在 aarch64.ad 中新增 partialSubtypeCheckVarSuper 和 partialSubtypeCheckConstSuper 指令，分别处理变量超类和常量超类情况，优化指令成本（如 ins_cost 从 1100 降至 10*INSN_COST）。2. 在宏汇编器（macroAssembler）中实现 lookup_secondary_supers_table 函数，利用向量寄存器（vtemp）和临时寄存器加速表查找。3. 移除过时的 partialSubtypeCheckVsZero 指令，简化代码路径。优化思路：通过数据结构改进（哈希表替代缓存）和指令级优化，提升子类型检查的并发性能和可扩展性，减少内存访问延迟，适用于高并发场景如Java虚拟机中的类型检查操作。", "original_code": "secondary_super_cache 在多线程环境下扩展性差，C1 编译器和解释器中的子类型检查（如 instanceof/checkcast）性能受限，主要依赖缓存查找，存在竞争和缓存未命中问题。", "optimized_code": "instruct partialSubtypeCheck(iRegP_R4 sub, iRegP_R0 super, iRegP_R2 temp, iRegP_R5 result, rFlagsReg cr)\n%{\n  match(Set result (PartialSubtypeCheck sub super));\n+ predicate(!UseSecondarySupersTable);\n  effect(KILL cr, KILL temp);\n\n- ins_cost(1100);  // slightly larger than the next version\n+ ins_cost(20 * INSN_COST);  // slightly larger than the next version\n  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n\n  ins_encode(aarch64_enc_partial_subtype_check(sub, super, temp, result));\n\n  opcode(0x0); // Don't zero result reg on hit\n\n  ins_pipe(pipe_class_memory);\n%}\n\n+instruct partialSubtypeCheckVarSuper(iRegP_R4 sub, iRegP_R0 super, vRegD_V0 vtemp, iRegP_R5 result,\n+                                     iRegP_R1 tempR1, iRegP_R2 tempR2, iRegP_R3 tempR3,\n+                                     rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP tempR1, TEMP tempR2, TEMP tempR3, TEMP vtemp);\n+\n+  ins_cost(10 * INSN_COST);  // slightly larger than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n+\n+  ins_encode %{\n+    __ lookup_secondary_supers_table_var($sub$$Register, $super$$Register,\n+                                         $tempR1$$Register, $tempR2$$Register, $tempR3$$Register,\n+                                         $vtemp$$FloatRegister,\n+                                         $result$$Register, /*L_success*/nullptr);\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}", "source_url": "https://github.com/openjdk/riscv-port/commit/ead0116f2624e0e34529e47e4f509142d588b994", "code_v0_no_empty_lines": "secondary_super_cache 在多线程环境下扩展性差，C1 编译器和解释器中的子类型检查（如 instanceof/checkcast）性能受限，主要依赖缓存查找，存在竞争和缓存未命中问题。", "code_v1_no_empty_lines": "instruct partialSubtypeCheck(iRegP_R4 sub, iRegP_R0 super, iRegP_R2 temp, iRegP_R5 result, rFlagsReg cr)\n%{\n  match(Set result (PartialSubtypeCheck sub super));\n+ predicate(!UseSecondarySupersTable);\n  effect(KILL cr, KILL temp);\n\n- ins_cost(1100);  // slightly larger than the next version\n+ ins_cost(20 * INSN_COST);  // slightly larger than the next version\n  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n\n  ins_encode(aarch64_enc_partial_subtype_check(sub, super, temp, result));\n\n  opcode(0x0); // Don't zero result reg on hit\n\n  ins_pipe(pipe_class_memory);\n%}\n\n+instruct partialSubtypeCheckVarSuper(iRegP_R4 sub, iRegP_R0 super, vRegD_V0 vtemp, iRegP_R5 result,\n+                                     iRegP_R1 tempR1, iRegP_R2 tempR2, iRegP_R3 tempR3,\n+                                     rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP tempR1, TEMP tempR2, TEMP tempR3, TEMP vtemp);\n+\n+  ins_cost(10 * INSN_COST);  // slightly larger than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n+\n+  ins_encode %{\n+    __ lookup_secondary_supers_table_var($sub$$Register, $super$$Register,\n+                                         $tempR1$$Register, $tempR2$$Register, $tempR3$$Register,\n+                                         $vtemp$$FloatRegister,\n+                                         $result$$Register, /*L_success*/nullptr);\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}", "target": "instruct partialSubtypeCheck(iRegP_R4 sub, iRegP_R0 super, iRegP_R2 temp, iRegP_R5 result, rFlagsReg cr)\n%{\n  match(Set result (PartialSubtypeCheck sub super));\n+ predicate(!UseSecondarySupersTable);\n  effect(KILL cr, KILL temp);\n\n- ins_cost(1100);  // slightly larger than the next version\n+ ins_cost(20 * INSN_COST);  // slightly larger than the next version\n  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n\n  ins_encode(aarch64_enc_partial_subtype_check(sub, super, temp, result));\n\n  opcode(0x0); // Don't zero result reg on hit\n\n  ins_pipe(pipe_class_memory);\n%}\n\n+instruct partialSubtypeCheckVarSuper(iRegP_R4 sub, iRegP_R0 super, vRegD_V0 vtemp, iRegP_R5 result,\n+                                     iRegP_R1 tempR1, iRegP_R2 tempR2, iRegP_R3 tempR3,\n+                                     rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP tempR1, TEMP tempR2, TEMP tempR3, TEMP vtemp);\n+\n+  ins_cost(10 * INSN_COST);  // slightly larger than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n+\n+  ins_encode %{\n+    __ lookup_secondary_supers_table_var($sub$$Register, $super$$Register,\n+                                         $tempR1$$Register, $tempR2$$Register, $tempR3$$Register,\n+                                         $vtemp$$FloatRegister,\n+                                         $result$$Register, /*L_success*/nullptr);\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：secondary_super_cache 在多线程环境下扩展性差，C1 编译器和解释器中的子类型检查（如 instanceof/checkcast）性能受限，主要依赖缓存查找，存在竞争和缓存未命中问题。优化后：引入二级超类表（secondary supers table）机制，通过哈希槽（hash_slot）直接定位超类，减少内存访问和缓存竞争。具体修改包括：1. 在 aarch64.ad 中新增 partialSubtypeCheckVarSuper 和 partialSubtypeCheckConstSuper 指令，分别处理变量超类和常量超类情况，优化指令成本（如 ins_cost 从 1100 降至 10*INSN_COST）。2. 在宏汇编器（macroAssembler）中实现 lookup_secondary_supers_table 函数，利用向量寄存器（vtemp）和临时寄存器加速表查找。3. 移除过时的 partialSubtypeCheckVsZero 指令，简化代码路径。优化思路：通过数据结构改进（哈希表替代缓存）和指令级优化，提升子类型检查的并发性能和可扩展性，减少内存访问延迟，适用于高并发场景如Java虚拟机中的类型检查操作。"}
{"id": 614, "source": "riscv-dataset-excel", "optimization_type": "代码重构+维护性优化", "optimization_description": "优化前：通过手动遍历和克隆谓词（predicate）来处理主循环和后循环的断言谓词，代码复杂且重复。优化后：引入PredicateVisitor模式，统一处理谓词的遍历和克隆，简化了代码结构。思路：将重复的谓词处理逻辑抽象为访问者模式，提高代码可维护性和可读性，同时减少代码量（净减少70行）。", "original_code": "通过手动遍历和克隆谓词（predicate）来处理主循环和后循环的断言谓词，代码复杂且重复。", "optimized_code": "-void PhaseIdealLoop::copy_assertion_predicates_to_main_loop_helper(const PredicateBlock* predicate_block, Node* init,\n+// 移除了copy_assertion_predicates_to_main_loop_helper函数，改用PredicateVisitor模式", "source_url": "https://github.com/openjdk/riscv-port/commit/4431852a880b06241231d346311170331c20ab2d", "code_v0_no_empty_lines": "通过手动遍历和克隆谓词（predicate）来处理主循环和后循环的断言谓词，代码复杂且重复。", "code_v1_no_empty_lines": "-void PhaseIdealLoop::copy_assertion_predicates_to_main_loop_helper(const PredicateBlock* predicate_block, Node* init,\n+// 移除了copy_assertion_predicates_to_main_loop_helper函数，改用PredicateVisitor模式", "target": "-void PhaseIdealLoop::copy_assertion_predicates_to_main_loop_helper(const PredicateBlock* predicate_block, Node* init,\n+// 移除了copy_assertion_predicates_to_main_loop_helper函数，改用PredicateVisitor模式", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：通过手动遍历和克隆谓词（predicate）来处理主循环和后循环的断言谓词，代码复杂且重复。优化后：引入PredicateVisitor模式，统一处理谓词的遍历和克隆，简化了代码结构。思路：将重复的谓词处理逻辑抽象为访问者模式，提高代码可维护性和可读性，同时减少代码量（净减少70行）。"}
{"id": 615, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（C2 JIT编译器）", "optimization_description": "优化前：在C2编译器的迭代全局值编号（IGVN）阶段，当AddX节点被修改时，其下游的CastX2P节点可能不会被重新加入工作列表进行处理，导致CastX2P的理想变换（Ideal transformation）无法应用。优化后：在PhaseIterGVN::add_users_of_use_to_worklist函数中添加了检查，当use节点是AddX时，会遍历其所有输出节点，如果找到CastX2P节点，则将其加入工作列表以确保后续处理。优化思路：修复了IGVN阶段的工作列表管理缺陷，确保CastX2P变换在AddX节点修改后能正确触发，从而生成更高效的指针运算代码（如用AddP替代AddL+CastX2P组合）。", "original_code": "在C2编译器的迭代全局值编号（IGVN）阶段，当AddX节点被修改时，其下游的CastX2P节点可能不会被重新加入工作列表进行处理，导致CastX2P的理想变换（Ideal transformation）无法应用。", "optimized_code": "if (use->Opcode() == Op_AddX) {\n  for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n    Node* u = use->fast_out(i2);\n    if (u->Opcode() == Op_CastX2P) {\n      worklist.push(u);\n    }\n  }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/57c3bb6091f8ba0caced6f5ecf21dc998ffeee9f", "code_v0_no_empty_lines": "在C2编译器的迭代全局值编号（IGVN）阶段，当AddX节点被修改时，其下游的CastX2P节点可能不会被重新加入工作列表进行处理，导致CastX2P的理想变换（Ideal transformation）无法应用。", "code_v1_no_empty_lines": "if (use->Opcode() == Op_AddX) {\n  for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n    Node* u = use->fast_out(i2);\n    if (u->Opcode() == Op_CastX2P) {\n      worklist.push(u);\n    }\n  }\n}", "target": "if (use->Opcode() == Op_AddX) {\n  for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n    Node* u = use->fast_out(i2);\n    if (u->Opcode() == Op_CastX2P) {\n      worklist.push(u);\n    }\n  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在C2编译器的迭代全局值编号（IGVN）阶段，当AddX节点被修改时，其下游的CastX2P节点可能不会被重新加入工作列表进行处理，导致CastX2P的理想变换（Ideal transformation）无法应用。优化后：在PhaseIterGVN::add_users_of_use_to_worklist函数中添加了检查，当use节点是AddX时，会遍历其所有输出节点，如果找到CastX2P节点，则将其加入工作列表以确保后续处理。优化思路：修复了IGVN阶段的工作列表管理缺陷，确保CastX2P变换在AddX节点修改后能正确触发，从而生成更高效的指针运算代码（如用AddP替代AddL+CastX2P组合）。"}
{"id": 616, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+死代码消除", "optimization_description": "优化前：在匹配地址表达式时，当存在两个立即偏移量时，编译器会错误地克隆地址表达式，导致生成死节点（dead node）。验证函数verify_new_nodes_only存在逻辑缺陷，可能导致断言失败。优化后：1. 在x86.ad中增加条件检查!adr->in(AddPNode::Offset)->is_Con()，防止在地址表达式中匹配两个立即偏移量。2. 修改matcher.cpp中的验证逻辑，使用visited.test_set()避免重复访问，并添加对输出边的遍历以确保所有节点都被正确验证。优化思路：修复地址表达式匹配逻辑，防止生成无效的中间节点，同时改进节点验证算法，确保编译器内部图结构的正确性。", "original_code": "在匹配地址表达式时，当存在两个立即偏移量时，编译器会错误地克隆地址表达式，导致生成死节点（dead node）。验证函数verify_new_nodes_only存在逻辑缺陷，可能导致断言失败。", "optimized_code": "--- a/src/hotspot/cpu/x86/x86.ad\n+++ b/src/hotspot/cpu/x86/x86.ad\n@@ -2512,11 +2512,12 @@ bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack& mstack,\n     address_visited.test_set(m->_idx); // Flag as address_visited\n     Node *adr = m->in(AddPNode::Address);\n \n-    // Intel can handle 2 adds in addressing mode\n+    // Intel can handle 2 adds in addressing mode, with one of them using an immediate offset.\n     // AtomicAdd is not an addressing expression.\n     // Cheap to find it by looking for screwy base.\n     if (adr->is_AddP() &&\n         !adr->in(AddPNode::Base)->is_top() &&\n+        !adr->in(AddPNode::Offset)->is_Con() &&\n         LP64_ONLY( off->get_long() == (int) (off->get_long()) && ) // immL32\n         // Are there other uses besides address expressions?\n         !is_visited(adr)) {\n--- a/src/hotspot/share/opto/matcher.cpp\n+++ b/src/hotspot/share/opto/matcher.cpp\n@@ -170,17 +170,19 @@ void Matcher::verify_new_nodes_only(Node* xroot) {\n   worklist.push(xroot);\n   while (worklist.size() > 0) {\n     Node* n = worklist.pop();\n-    visited.set(n->_idx);\n+    if (visited.test_set(n->_idx)) {\n+      continue;\n+    }\n     assert(C->node_arena()->contains(n), \"dead node\");\n     for (uint j = 0; j < n->req(); j++) {\n       Node* in = n->in(j);\n       if (in != nullptr) {\n-        assert(C->node_arena()->contains(in), \"dead node\");\n-        if (!visited.test(in->_idx)) {\n-          worklist.push(in);\n-        }\n+        worklist.push(in);\n       }\n     }\n+    for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+      worklist.push(n->fast_out(j));\n+    }\n   }\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/83f3d42d6bcefac80449987f4d951f8280eeee3a", "code_v0_no_empty_lines": "在匹配地址表达式时，当存在两个立即偏移量时，编译器会错误地克隆地址表达式，导致生成死节点（dead node）。验证函数verify_new_nodes_only存在逻辑缺陷，可能导致断言失败。", "code_v1_no_empty_lines": "--- a/src/hotspot/cpu/x86/x86.ad\n+++ b/src/hotspot/cpu/x86/x86.ad\n@@ -2512,11 +2512,12 @@ bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack& mstack,\n     address_visited.test_set(m->_idx); // Flag as address_visited\n     Node *adr = m->in(AddPNode::Address);\n \n-    // Intel can handle 2 adds in addressing mode\n+    // Intel can handle 2 adds in addressing mode, with one of them using an immediate offset.\n     // AtomicAdd is not an addressing expression.\n     // Cheap to find it by looking for screwy base.\n     if (adr->is_AddP() &&\n         !adr->in(AddPNode::Base)->is_top() &&\n+        !adr->in(AddPNode::Offset)->is_Con() &&\n         LP64_ONLY( off->get_long() == (int) (off->get_long()) && ) // immL32\n         // Are there other uses besides address expressions?\n         !is_visited(adr)) {\n--- a/src/hotspot/share/opto/matcher.cpp\n+++ b/src/hotspot/share/opto/matcher.cpp\n@@ -170,17 +170,19 @@ void Matcher::verify_new_nodes_only(Node* xroot) {\n   worklist.push(xroot);\n   while (worklist.size() > 0) {\n     Node* n = worklist.pop();\n-    visited.set(n->_idx);\n+    if (visited.test_set(n->_idx)) {\n+      continue;\n+    }\n     assert(C->node_arena()->contains(n), \"dead node\");\n     for (uint j = 0; j < n->req(); j++) {\n       Node* in = n->in(j);\n       if (in != nullptr) {\n-        assert(C->node_arena()->contains(in), \"dead node\");\n-        if (!visited.test(in->_idx)) {\n-          worklist.push(in);\n-        }\n+        worklist.push(in);\n       }\n     }\n+    for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+      worklist.push(n->fast_out(j));\n+    }\n   }\n }", "target": "--- a/src/hotspot/cpu/x86/x86.ad\n+++ b/src/hotspot/cpu/x86/x86.ad\n@@ -2512,11 +2512,12 @@ bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack& mstack,\n     address_visited.test_set(m->_idx); // Flag as address_visited\n     Node *adr = m->in(AddPNode::Address);\n \n-    // Intel can handle 2 adds in addressing mode\n+    // Intel can handle 2 adds in addressing mode, with one of them using an immediate offset.\n     // AtomicAdd is not an addressing expression.\n     // Cheap to find it by looking for screwy base.\n     if (adr->is_AddP() &&\n         !adr->in(AddPNode::Base)->is_top() &&\n+        !adr->in(AddPNode::Offset)->is_Con() &&\n         LP64_ONLY( off->get_long() == (int) (off->get_long()) && ) // immL32\n         // Are there other uses besides address expressions?\n         !is_visited(adr)) {\n--- a/src/hotspot/share/opto/matcher.cpp\n+++ b/src/hotspot/share/opto/matcher.cpp\n@@ -170,17 +170,19 @@ void Matcher::verify_new_nodes_only(Node* xroot) {\n   worklist.push(xroot);\n   while (worklist.size() > 0) {\n     Node* n = worklist.pop();\n-    visited.set(n->_idx);\n+    if (visited.test_set(n->_idx)) {\n+      continue;\n+    }\n     assert(C->node_arena()->contains(n), \"dead node\");\n     for (uint j = 0; j < n->req(); j++) {\n       Node* in = n->in(j);\n       if (in != nullptr) {\n-        assert(C->node_arena()->contains(in), \"dead node\");\n-        if (!visited.test(in->_idx)) {\n-          worklist.push(in);\n-        }\n+        worklist.push(in);\n       }\n     }\n+    for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+      worklist.push(n->fast_out(j));\n+    }\n   }\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在匹配地址表达式时，当存在两个立即偏移量时，编译器会错误地克隆地址表达式，导致生成死节点（dead node）。验证函数verify_new_nodes_only存在逻辑缺陷，可能导致断言失败。优化后：1. 在x86.ad中增加条件检查!adr->in(AddPNode::Offset)->is_Con()，防止在地址表达式中匹配两个立即偏移量。2. 修改matcher.cpp中的验证逻辑，使用visited.test_set()避免重复访问，并添加对输出边的遍历以确保所有节点都被正确验证。优化思路：修复地址表达式匹配逻辑，防止生成无效的中间节点，同时改进节点验证算法，确保编译器内部图结构的正确性。"}
{"id": 617, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+内存访问优化", "optimization_description": "优化前：StringBuilder.append(boolean)和append(null)方法中，对于Latin1编码，通过逐个字符赋值的方式写入字符串（如val[count++] = 't'），对于UTF16编码，使用putCharsAt方法但返回更新后的索引。优化后：1. 引入新的putCharsAt方法，使用Unsafe直接内存访问批量写入字符，避免C2编译器无法合并多个小存储操作的问题；2. 统一了Latin1和UTF16的处理逻辑，都调用putCharsAt方法；3. 简化了索引更新逻辑，直接计算最终count值。优化思路：通过批量内存写入和避免编译器优化障碍，提高字符串构建性能，特别是对于常见的小字符串（如\"true\"、\"false\"、\"null\"）。", "original_code": "StringBuilder.append(boolean)和append(null)方法中，对于Latin1编码，通过逐个字符赋值的方式写入字符串（如val[count++] = 't'），对于UTF16编码，使用putCharsAt方法但返回更新后的索引。", "optimized_code": "static void putCharsAt(byte[] val, int index, int c1, int c2, int c3, int c4) {\n    assert index >= 0 && index + 3 < length(val) : \"Trusted caller missed bounds check\";\n    // Don't use the putChar method, Its instrinsic will cause C2 unable to combining values into larger stores.\n    long address  = Unsafe.ARRAY_BYTE_BASE_OFFSET + index;\n    UNSAFE.putByte(val, address    , (byte)(c1));\n    UNSAFE.putByte(val, address + 1, (byte)(c2));\n    UNSAFE.putByte(val, address + 2, (byte)(c3));\n    UNSAFE.putByte(val, address + 3, (byte)(c4));\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/5890d9438bbde88b89070052926a2eafe13d7b42", "code_v0_no_empty_lines": "StringBuilder.append(boolean)和append(null)方法中，对于Latin1编码，通过逐个字符赋值的方式写入字符串（如val[count++] = 't'），对于UTF16编码，使用putCharsAt方法但返回更新后的索引。", "code_v1_no_empty_lines": "static void putCharsAt(byte[] val, int index, int c1, int c2, int c3, int c4) {\n    assert index >= 0 && index + 3 < length(val) : \"Trusted caller missed bounds check\";\n    // Don't use the putChar method, Its instrinsic will cause C2 unable to combining values into larger stores.\n    long address  = Unsafe.ARRAY_BYTE_BASE_OFFSET + index;\n    UNSAFE.putByte(val, address    , (byte)(c1));\n    UNSAFE.putByte(val, address + 1, (byte)(c2));\n    UNSAFE.putByte(val, address + 2, (byte)(c3));\n    UNSAFE.putByte(val, address + 3, (byte)(c4));\n}", "target": "static void putCharsAt(byte[] val, int index, int c1, int c2, int c3, int c4) {\n    assert index >= 0 && index + 3 < length(val) : \"Trusted caller missed bounds check\";\n    // Don't use the putChar method, Its instrinsic will cause C2 unable to combining values into larger stores.\n    long address  = Unsafe.ARRAY_BYTE_BASE_OFFSET + index;\n    UNSAFE.putByte(val, address    , (byte)(c1));\n    UNSAFE.putByte(val, address + 1, (byte)(c2));\n    UNSAFE.putByte(val, address + 2, (byte)(c3));\n    UNSAFE.putByte(val, address + 3, (byte)(c4));\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：StringBuilder.append(boolean)和append(null)方法中，对于Latin1编码，通过逐个字符赋值的方式写入字符串（如val[count++] = 't'），对于UTF16编码，使用putCharsAt方法但返回更新后的索引。优化后：1. 引入新的putCharsAt方法，使用Unsafe直接内存访问批量写入字符，避免C2编译器无法合并多个小存储操作的问题；2. 统一了Latin1和UTF16的处理逻辑，都调用putCharsAt方法；3. 简化了索引更新逻辑，直接计算最终count值。优化思路：通过批量内存写入和避免编译器优化障碍，提高字符串构建性能，特别是对于常见的小字符串（如\"true\"、\"false\"、\"null\"）。"}
{"id": 618, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+内存访问优化", "optimization_description": "优化前：C2编译器在处理连续存储操作时，指针解析能力有限，无法有效合并相邻的存储指令，导致生成冗余的内存访问代码。优化后：通过引入mempointer模块和增强的指针解析算法，编译器能够更精确地分析指针范围和内存访问模式，智能合并相邻的存储操作，减少内存访问次数。优化思路：重构存储节点处理逻辑，分离指针解析功能到独立模块，增加对MemorySegment和UnsafeArrayPointer等复杂场景的支持，通过改进数据流分析提升存储合并的准确性和覆盖率。", "original_code": "C2编译器在处理连续存储操作时，指针解析能力有限，无法有效合并相邻的存储指令，导致生成冗余的内存访问代码。", "optimized_code": "--- a/src/hotspot/share/opto/memnode.cpp\n+++ b/src/hotspot/share/opto/memnode.cpp\n@@ -1,335 +1,383 @@\n+// 新增mempointer.cpp和mempointer.hpp文件\n+// 实现增强的指针解析和存储合并逻辑\n+// 主要修改集中在StoreNode::Ideal()和MergeStores优化中", "source_url": "https://github.com/openjdk/riscv-port/commit/f3671beefb3ff07441a905e25619f0d1a0a2fe15", "code_v0_no_empty_lines": "C2编译器在处理连续存储操作时，指针解析能力有限，无法有效合并相邻的存储指令，导致生成冗余的内存访问代码。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/opto/memnode.cpp\n+++ b/src/hotspot/share/opto/memnode.cpp\n@@ -1,335 +1,383 @@\n+// 新增mempointer.cpp和mempointer.hpp文件\n+// 实现增强的指针解析和存储合并逻辑\n+// 主要修改集中在StoreNode::Ideal()和MergeStores优化中", "target": "--- a/src/hotspot/share/opto/memnode.cpp\n+++ b/src/hotspot/share/opto/memnode.cpp\n@@ -1,335 +1,383 @@\n+// 新增mempointer.cpp和mempointer.hpp文件\n+// 实现增强的指针解析和存储合并逻辑\n+// 主要修改集中在StoreNode::Ideal()和MergeStores优化中", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器在处理连续存储操作时，指针解析能力有限，无法有效合并相邻的存储指令，导致生成冗余的内存访问代码。优化后：通过引入mempointer模块和增强的指针解析算法，编译器能够更精确地分析指针范围和内存访问模式，智能合并相邻的存储操作，减少内存访问次数。优化思路：重构存储节点处理逻辑，分离指针解析功能到独立模块，增加对MemorySegment和UnsafeArrayPointer等复杂场景的支持，通过改进数据流分析提升存储合并的准确性和覆盖率。"}
{"id": 619, "source": "riscv-dataset-excel", "optimization_type": "SIMD向量化优化", "optimization_description": "优化前：数组哈希码计算使用标量指令逐元素处理，效率较低。优化后：在AArch64架构上实现向量化哈希码计算（VectorizedHashCode），利用SIMD指令（如smlalv、mulvs等）并行处理多个数组元素，显著提升哈希计算性能。优化思路：通过新增arrays_hashcode指令匹配VectorizedHashCode节点，扩展汇编器支持相关SIMD操作，并添加必要的寄存器操作数和测试验证。", "original_code": "数组哈希码计算使用标量指令逐元素处理，效率较低。", "optimized_code": "instruct arrays_hashcode(iRegP_R1 ary, iRegI_R2 cnt, iRegI_R0 result, immI basic_type,\n                         vRegD_V0 vtmp0, vRegD_V1 vtmp1, vRegD_V2 vtmp2, vRegD_V3 vtmp3,\n                         vRegD_V4 vtmp4, vRegD_V5 vtmp5, vRegD_V6 vtmp6, vRegD_V7 vtmp7,\n                         vRegD_V12 vtmp8, vRegD_V13 vtmp9, rFlagsReg cr)\n%{\n  match(Set result (VectorizedHashCode (Binary ary cnt) (Binary result basic_type)));\n  effect(TEMP vtmp0, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP vtmp5, TEMP vtmp6,\n         TEMP vtmp7, TEMP vtmp8, TEMP vtmp9, USE_KILL ary, USE_KILL cnt, USE basic_type, KILL cr);\n\n  format %{ \"Array HashCode array[] $ary,$cnt,$result,$basic_type -> $result   // KILL all\" %}", "source_url": "https://github.com/openjdk/riscv-port/commit/4fc6d4135e795d18a024a6035908f380b81082d1", "code_v0_no_empty_lines": "数组哈希码计算使用标量指令逐元素处理，效率较低。", "code_v1_no_empty_lines": "instruct arrays_hashcode(iRegP_R1 ary, iRegI_R2 cnt, iRegI_R0 result, immI basic_type,\n                         vRegD_V0 vtmp0, vRegD_V1 vtmp1, vRegD_V2 vtmp2, vRegD_V3 vtmp3,\n                         vRegD_V4 vtmp4, vRegD_V5 vtmp5, vRegD_V6 vtmp6, vRegD_V7 vtmp7,\n                         vRegD_V12 vtmp8, vRegD_V13 vtmp9, rFlagsReg cr)\n%{\n  match(Set result (VectorizedHashCode (Binary ary cnt) (Binary result basic_type)));\n  effect(TEMP vtmp0, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP vtmp5, TEMP vtmp6,\n         TEMP vtmp7, TEMP vtmp8, TEMP vtmp9, USE_KILL ary, USE_KILL cnt, USE basic_type, KILL cr);\n\n  format %{ \"Array HashCode array[] $ary,$cnt,$result,$basic_type -> $result   // KILL all\" %}", "target": "instruct arrays_hashcode(iRegP_R1 ary, iRegI_R2 cnt, iRegI_R0 result, immI basic_type,\n                         vRegD_V0 vtmp0, vRegD_V1 vtmp1, vRegD_V2 vtmp2, vRegD_V3 vtmp3,\n                         vRegD_V4 vtmp4, vRegD_V5 vtmp5, vRegD_V6 vtmp6, vRegD_V7 vtmp7,\n                         vRegD_V12 vtmp8, vRegD_V13 vtmp9, rFlagsReg cr)\n%{\n  match(Set result (VectorizedHashCode (Binary ary cnt) (Binary result basic_type)));\n  effect(TEMP vtmp0, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP vtmp5, TEMP vtmp6,\n         TEMP vtmp7, TEMP vtmp8, TEMP vtmp9, USE_KILL ary, USE_KILL cnt, USE basic_type, KILL cr);\n\n  format %{ \"Array HashCode array[] $ary,$cnt,$result,$basic_type -> $result   // KILL all\" %}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：数组哈希码计算使用标量指令逐元素处理，效率较低。优化后：在AArch64架构上实现向量化哈希码计算（VectorizedHashCode），利用SIMD指令（如smlalv、mulvs等）并行处理多个数组元素，显著提升哈希计算性能。优化思路：通过新增arrays_hashcode指令匹配VectorizedHashCode节点，扩展汇编器支持相关SIMD操作，并添加必要的寄存器操作数和测试验证。"}
{"id": 620, "source": "riscv-dataset-excel", "optimization_type": "测试用例添加", "optimization_description": "优化前：缺少针对SuperWord向量化优化中特定场景的测试用例，该场景涉及当SuperWord对齐到字段存储时，对应的分配被消除的情况。优化后：新增了TestEliminateAllocationWithCastP2XUse.java测试文件，专门测试在特定编译器优化序列（包括逃逸分析、循环优化、SuperWord向量化、宏扩展）下，当分配被标记为NoEscape但因SuperWord对齐插入CastP2X节点时，分配消除的正确性。思路：通过创建复杂的控制流和延迟常量折叠，模拟实际优化过程中可能出现的边缘情况，确保编译器优化组合的健壮性。", "original_code": "缺少针对SuperWord向量化优化中特定场景的测试用例，该场景涉及当SuperWord对齐到字段存储时，对应的分配被消除的情况。", "optimized_code": "new file mode 100644\nindex 00000000000..416781d1b00\n--- /dev/null\n+++ b/test/hotspot/jtreg/compiler/loopopts/superword/TestEliminateAllocationWithCastP2XUse.java\n@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2024, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package compiler.loopopts.superword;\n+\n+/*\n+ * @test\n+ * @bug 8342498\n+ * @summary Test SuperWord, when it aligns to field-store, and the corresponding allocation is eliminated.\n+ * @run driver compiler.loopopts.superword.TestEliminateAllocationWithCastP2XUse\n+ * @run main/othervm -Xbatch\n+ *                   -XX:-SplitIfBlocks -XX:LoopMaxUnroll=8\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:DominatorSearchLimit=45\n+ *                   compiler.loopopts.superword.TestEliminateAllocationWithCastP2XUse\n+ */", "source_url": "https://github.com/openjdk/riscv-port/commit/f62fc4844125cc20a91dc2be39ba05a2d3aca8cf", "code_v0_no_empty_lines": "缺少针对SuperWord向量化优化中特定场景的测试用例，该场景涉及当SuperWord对齐到字段存储时，对应的分配被消除的情况。", "code_v1_no_empty_lines": "new file mode 100644\nindex 00000000000..416781d1b00\n--- /dev/null\n+++ b/test/hotspot/jtreg/compiler/loopopts/superword/TestEliminateAllocationWithCastP2XUse.java\n@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2024, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package compiler.loopopts.superword;\n+\n+/*\n+ * @test\n+ * @bug 8342498\n+ * @summary Test SuperWord, when it aligns to field-store, and the corresponding allocation is eliminated.\n+ * @run driver compiler.loopopts.superword.TestEliminateAllocationWithCastP2XUse\n+ * @run main/othervm -Xbatch\n+ *                   -XX:-SplitIfBlocks -XX:LoopMaxUnroll=8\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:DominatorSearchLimit=45\n+ *                   compiler.loopopts.superword.TestEliminateAllocationWithCastP2XUse\n+ */", "target": "new file mode 100644\nindex 00000000000..416781d1b00\n--- /dev/null\n+++ b/test/hotspot/jtreg/compiler/loopopts/superword/TestEliminateAllocationWithCastP2XUse.java\n@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2024, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package compiler.loopopts.superword;\n+\n+/*\n+ * @test\n+ * @bug 8342498\n+ * @summary Test SuperWord, when it aligns to field-store, and the corresponding allocation is eliminated.\n+ * @run driver compiler.loopopts.superword.TestEliminateAllocationWithCastP2XUse\n+ * @run main/othervm -Xbatch\n+ *                   -XX:-SplitIfBlocks -XX:LoopMaxUnroll=8\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:DominatorSearchLimit=45\n+ *                   compiler.loopopts.superword.TestEliminateAllocationWithCastP2XUse\n+ */", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：缺少针对SuperWord向量化优化中特定场景的测试用例，该场景涉及当SuperWord对齐到字段存储时，对应的分配被消除的情况。优化后：新增了TestEliminateAllocationWithCastP2XUse.java测试文件，专门测试在特定编译器优化序列（包括逃逸分析、循环优化、SuperWord向量化、宏扩展）下，当分配被标记为NoEscape但因SuperWord对齐插入CastP2X节点时，分配消除的正确性。思路：通过创建复杂的控制流和延迟常量折叠，模拟实际优化过程中可能出现的边缘情况，确保编译器优化组合的健壮性。"}
{"id": 621, "source": "riscv-dataset-excel", "optimization_type": "代码简化+字符串操作优化", "optimization_description": "优化前使用StringBuilder手动构建数组描述符字符串，需要计算长度、重复字符和拼接。优化后直接使用String.repeat()和concat()方法，代码更简洁，减少临时对象创建和长度计算开销。", "original_code": "// No original code extracted from description\n", "optimized_code": "-        var componentDesc = elementType.descriptorString();\n-        StringBuilder sb = new StringBuilder(rank + componentDesc.length());\n-        sb.repeat('[', rank);\n-        sb.append(componentDesc);\n-        return sb.toString();\n+        return \"[\".repeat(rank).concat(elementType.descriptorString());", "source_url": "https://github.com/openjdk/riscv-port/commit/67907d5e8985ee47ddadb51dae1220404a18dd47", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "-        var componentDesc = elementType.descriptorString();\n-        StringBuilder sb = new StringBuilder(rank + componentDesc.length());\n-        sb.repeat('[', rank);\n-        sb.append(componentDesc);\n-        return sb.toString();\n+        return \"[\".repeat(rank).concat(elementType.descriptorString());", "target": "-        var componentDesc = elementType.descriptorString();\n-        StringBuilder sb = new StringBuilder(rank + componentDesc.length());\n-        sb.repeat('[', rank);\n-        sb.append(componentDesc);\n-        return sb.toString();\n+        return \"[\".repeat(rank).concat(elementType.descriptorString());", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用StringBuilder手动构建数组描述符字符串，需要计算长度、重复字符和拼接。优化后直接使用String.repeat()和concat()方法，代码更简洁，减少临时对象创建和长度计算开销。"}
{"id": 622, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+数学库优化", "optimization_description": "优化前：AArch64平台上的向量数学运算（如sin、cos等）缺乏高效实现，向量调用约定未实现，无法利用硬件向量指令。优化后：集成SLEEF向量数学库，为NEON和SVE指令集提供优化的向量数学函数实现；实现向量调用约定，支持向量参数传递；添加构建系统支持，自动检测SVE ACLE支持并编译相应代码。优化思路：通过使用高度优化的SLEEF库替代标量数学运算，利用SIMD指令并行处理多个数据元素，显著提升向量数学运算性能，特别是在科学计算和图形处理等场景。", "original_code": "AArch64平台上的向量数学运算（如sin、cos等）缺乏高效实现，向量调用约定未实现，无法利用硬件向量指令。", "optimized_code": "--- a/src/hotspot/cpu/aarch64/aarch64.ad\n+++ b/src/hotspot/cpu/aarch64/aarch64.ad\n@@ -2307,14 +2307,18 @@ const RegMask* Matcher::predicate_reg_mask(void) {\n   return &_PR_REG_mask;\n }\n \n-// Vector calling convention not yet implemented.\n bool Matcher::supports_vector_calling_convention(void) {\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n }\n \n OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  int lo = V0_num;\n+  int hi = V0_H_num;\n+  if (ideal_reg == Op_VecX || ideal_reg == Op_VecA) {\n+    hi = V0_K_num;\n+  }\n+  return OptoRegPair(hi, lo);\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/df08a9ec0d813fcd4ea88a3773c230af6d65e045", "code_v0_no_empty_lines": "AArch64平台上的向量数学运算（如sin、cos等）缺乏高效实现，向量调用约定未实现，无法利用硬件向量指令。", "code_v1_no_empty_lines": "--- a/src/hotspot/cpu/aarch64/aarch64.ad\n+++ b/src/hotspot/cpu/aarch64/aarch64.ad\n@@ -2307,14 +2307,18 @@ const RegMask* Matcher::predicate_reg_mask(void) {\n   return &_PR_REG_mask;\n }\n \n-// Vector calling convention not yet implemented.\n bool Matcher::supports_vector_calling_convention(void) {\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n }\n \n OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  int lo = V0_num;\n+  int hi = V0_H_num;\n+  if (ideal_reg == Op_VecX || ideal_reg == Op_VecA) {\n+    hi = V0_K_num;\n+  }\n+  return OptoRegPair(hi, lo);\n }", "target": "--- a/src/hotspot/cpu/aarch64/aarch64.ad\n+++ b/src/hotspot/cpu/aarch64/aarch64.ad\n@@ -2307,14 +2307,18 @@ const RegMask* Matcher::predicate_reg_mask(void) {\n   return &_PR_REG_mask;\n }\n \n-// Vector calling convention not yet implemented.\n bool Matcher::supports_vector_calling_convention(void) {\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n }\n \n OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  int lo = V0_num;\n+  int hi = V0_H_num;\n+  if (ideal_reg == Op_VecX || ideal_reg == Op_VecA) {\n+    hi = V0_K_num;\n+  }\n+  return OptoRegPair(hi, lo);\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AArch64平台上的向量数学运算（如sin、cos等）缺乏高效实现，向量调用约定未实现，无法利用硬件向量指令。优化后：集成SLEEF向量数学库，为NEON和SVE指令集提供优化的向量数学函数实现；实现向量调用约定，支持向量参数传递；添加构建系统支持，自动检测SVE ACLE支持并编译相应代码。优化思路：通过使用高度优化的SLEEF库替代标量数学运算，利用SIMD指令并行处理多个数据元素，显著提升向量数学运算性能，特别是在科学计算和图形处理等场景。"}
{"id": 623, "source": "riscv-dataset-excel", "optimization_type": "性能优化+资源管理优化", "optimization_description": "优化前：possibly_add_compiler_threads函数每次调用都会执行昂贵的os::free_memory()和CodeCache::unallocated_capacity()操作来检查可用内存，即使编译器线程数量已经足够。这导致频繁的内存轮询开销。优化后：1. 添加快速检查逻辑，在获取锁之前先计算是否需要添加线程，如果不需要则直接返回；2. 将硬编码的2和4改为常量c2_tasks_per_thread和c1_tasks_per_thread；3. 使用get_c2_thread_count()和get_c1_thread_count()替代直接访问_compilers数组。优化思路：通过提前检查避免不必要的昂贵内存查询操作，减少锁竞争和系统调用开销，提高编译器线程管理的效率。", "original_code": "possibly_add_compiler_threads函数每次调用都会执行昂贵的os::free_memory()和CodeCache::unallocated_capacity()操作来检查可用内存，即使编译器线程数量已经足够。这导致频繁的内存轮询开销。", "optimized_code": "-  int old_c2_count = _compilers[1]->num_compiler_threads();\n-  int new_c2_count = MIN4(_c2_count,\n-      _c2_compile_queue->size() / 2,\n+  int old_c2_count = 0, new_c2_count = 0, old_c1_count = 0, new_c1_count = 0;\n+  const int c2_tasks_per_thread = 2, c1_tasks_per_thread = 4;\n+\n+  // Quick check if we already have enough compiler threads without taking the lock.\n+  if (new_c2_count <= old_c2_count && new_c1_count <= old_c1_count) return;\n+\n+  // Now, we do the more expensive operations.\n+  old_c2_count = get_c2_thread_count();\n+  new_c2_count = MIN4(_c2_count,\n+      _c2_compile_queue->size() / c2_tasks_per_thread,", "source_url": "https://github.com/openjdk/riscv-port/commit/75801992a7c626d409f66e2491082dba84c6fe45", "code_v0_no_empty_lines": "possibly_add_compiler_threads函数每次调用都会执行昂贵的os::free_memory()和CodeCache::unallocated_capacity()操作来检查可用内存，即使编译器线程数量已经足够。这导致频繁的内存轮询开销。", "code_v1_no_empty_lines": "-  int old_c2_count = _compilers[1]->num_compiler_threads();\n-  int new_c2_count = MIN4(_c2_count,\n-      _c2_compile_queue->size() / 2,\n+  int old_c2_count = 0, new_c2_count = 0, old_c1_count = 0, new_c1_count = 0;\n+  const int c2_tasks_per_thread = 2, c1_tasks_per_thread = 4;\n+\n+  // Quick check if we already have enough compiler threads without taking the lock.\n+  if (new_c2_count <= old_c2_count && new_c1_count <= old_c1_count) return;\n+\n+  // Now, we do the more expensive operations.\n+  old_c2_count = get_c2_thread_count();\n+  new_c2_count = MIN4(_c2_count,\n+      _c2_compile_queue->size() / c2_tasks_per_thread,", "target": "-  int old_c2_count = _compilers[1]->num_compiler_threads();\n-  int new_c2_count = MIN4(_c2_count,\n-      _c2_compile_queue->size() / 2,\n+  int old_c2_count = 0, new_c2_count = 0, old_c1_count = 0, new_c1_count = 0;\n+  const int c2_tasks_per_thread = 2, c1_tasks_per_thread = 4;\n+\n+  // Quick check if we already have enough compiler threads without taking the lock.\n+  if (new_c2_count <= old_c2_count && new_c1_count <= old_c1_count) return;\n+\n+  // Now, we do the more expensive operations.\n+  old_c2_count = get_c2_thread_count();\n+  new_c2_count = MIN4(_c2_count,\n+      _c2_compile_queue->size() / c2_tasks_per_thread,", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：possibly_add_compiler_threads函数每次调用都会执行昂贵的os::free_memory()和CodeCache::unallocated_capacity()操作来检查可用内存，即使编译器线程数量已经足够。这导致频繁的内存轮询开销。优化后：1. 添加快速检查逻辑，在获取锁之前先计算是否需要添加线程，如果不需要则直接返回；2. 将硬编码的2和4改为常量c2_tasks_per_thread和c1_tasks_per_thread；3. 使用get_c2_thread_count()和get_c1_thread_count()替代直接访问_compilers数组。优化思路：通过提前检查避免不必要的昂贵内存查询操作，减少锁竞争和系统调用开销，提高编译器线程管理的效率。"}
{"id": 624, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+性能优化", "optimization_description": "优化前：Java的Integer.divideUnsigned()和Long.divideUnsigned()/remainderUnsigned()方法在s390x架构上使用软件模拟实现，性能较低。优化后：为s390x架构添加了z_dlr和z_dlgr硬件指令的intrinsics实现，直接映射到硬件除法指令。优化思路：利用s390x架构的DLR（32位无符号除法）和DLGR（64位无符号除法）硬件指令，将Java的无符号除法和取余操作编译为单条机器指令，大幅提升性能。同时修正了DLR_ZOPC和DLGR_ZOPC的编码值。", "original_code": "Java的Integer.divideUnsigned()和Long.divideUnsigned()/remainderUnsigned()方法在s390x架构上使用软件模拟实现，性能较低。", "optimized_code": "instruct udivI_reg_reg(roddRegI r5_rodd_dst, iRegI src2, revenRegI r4_reven_tmp, flagsReg cr) %{\n  match(Set r5_rodd_dst (UDivI r5_rodd_dst src2));\n  effect(TEMP r4_reven_tmp, KILL cr);\n  // TODO: size(4);\n  format %{ \"UDIV $r5_rodd_dst,$r5_rodd_dst,$src2\" %}\n  ins_encode %{\n    Register b = $src2$$Register;\n    Register r4_reven_tmp = $r4_reven_tmp$$Register;\n    Register r5_rodd_dst  = $r5_rodd_dst$$Register;\n    assert_different_registers(r4_reven_tmp, r5_rodd_dst, b);\n    assert(r4_reven_tmp->successor() == r5_rodd_dst, \"even-odd pair required for the instruction\");\n\n    __ block_comment(\"unsigned_div_int {\");\n    __ z_lhi(r4_reven_tmp, 0); // make upper 32bits 0\n    __ z_dlr(r4_reven_tmp, b);\n    __ block_comment(\"} unsigned_div_int\");\n  %}\n  ins_pipe(pipe_class_dummy);\n%}", "source_url": "https://github.com/openjdk/riscv-port/commit/c125178065664fdf96c42dfc6dcfa2431e6011a4", "code_v0_no_empty_lines": "Java的Integer.divideUnsigned()和Long.divideUnsigned()/remainderUnsigned()方法在s390x架构上使用软件模拟实现，性能较低。", "code_v1_no_empty_lines": "instruct udivI_reg_reg(roddRegI r5_rodd_dst, iRegI src2, revenRegI r4_reven_tmp, flagsReg cr) %{\n  match(Set r5_rodd_dst (UDivI r5_rodd_dst src2));\n  effect(TEMP r4_reven_tmp, KILL cr);\n  // TODO: size(4);\n  format %{ \"UDIV $r5_rodd_dst,$r5_rodd_dst,$src2\" %}\n  ins_encode %{\n    Register b = $src2$$Register;\n    Register r4_reven_tmp = $r4_reven_tmp$$Register;\n    Register r5_rodd_dst  = $r5_rodd_dst$$Register;\n    assert_different_registers(r4_reven_tmp, r5_rodd_dst, b);\n    assert(r4_reven_tmp->successor() == r5_rodd_dst, \"even-odd pair required for the instruction\");\n\n    __ block_comment(\"unsigned_div_int {\");\n    __ z_lhi(r4_reven_tmp, 0); // make upper 32bits 0\n    __ z_dlr(r4_reven_tmp, b);\n    __ block_comment(\"} unsigned_div_int\");\n  %}\n  ins_pipe(pipe_class_dummy);\n%}", "target": "instruct udivI_reg_reg(roddRegI r5_rodd_dst, iRegI src2, revenRegI r4_reven_tmp, flagsReg cr) %{\n  match(Set r5_rodd_dst (UDivI r5_rodd_dst src2));\n  effect(TEMP r4_reven_tmp, KILL cr);\n  // TODO: size(4);\n  format %{ \"UDIV $r5_rodd_dst,$r5_rodd_dst,$src2\" %}\n  ins_encode %{\n    Register b = $src2$$Register;\n    Register r4_reven_tmp = $r4_reven_tmp$$Register;\n    Register r5_rodd_dst  = $r5_rodd_dst$$Register;\n    assert_different_registers(r4_reven_tmp, r5_rodd_dst, b);\n    assert(r4_reven_tmp->successor() == r5_rodd_dst, \"even-odd pair required for the instruction\");\n\n    __ block_comment(\"unsigned_div_int {\");\n    __ z_lhi(r4_reven_tmp, 0); // make upper 32bits 0\n    __ z_dlr(r4_reven_tmp, b);\n    __ block_comment(\"} unsigned_div_int\");\n  %}\n  ins_pipe(pipe_class_dummy);\n%}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Java的Integer.divideUnsigned()和Long.divideUnsigned()/remainderUnsigned()方法在s390x架构上使用软件模拟实现，性能较低。优化后：为s390x架构添加了z_dlr和z_dlgr硬件指令的intrinsics实现，直接映射到硬件除法指令。优化思路：利用s390x架构的DLR（32位无符号除法）和DLGR（64位无符号除法）硬件指令，将Java的无符号除法和取余操作编译为单条机器指令，大幅提升性能。同时修正了DLR_ZOPC和DLGR_ZOPC的编码值。"}
{"id": 625, "source": "riscv-dataset-excel", "optimization_type": "内存布局优化+断言增强", "optimization_description": "优化前：在最终图重塑阶段，抽象类或接口类的指针可能被错误压缩，导致内存访问错误。优化后：为Op_ConNKlass节点添加断言检查，确保类指针在压缩编码范围内，防止对抽象类或接口类指针进行无效压缩。优化思路：通过运行时断言验证内存布局假设，避免因指针压缩导致的运行时错误，提升编译器生成的代码可靠性。", "original_code": "在最终图重塑阶段，抽象类或接口类的指针可能被错误压缩，导致内存访问错误。", "optimized_code": "+#ifdef ASSERT\n+  case Op_ConNKlass: {\n+    const TypePtr* tp = n->as_Type()->type()->make_ptr();\n+    ciKlass* klass = tp->is_klassptr()->exact_klass();\n+    assert(klass->is_in_encoding_range(), \"klass cannot be compressed\");\n+    break;\n+  }\n+#endif", "source_url": "https://github.com/openjdk/riscv-port/commit/2432c4f862e66e91c60e75ccc43b376020d80a1f", "code_v0_no_empty_lines": "在最终图重塑阶段，抽象类或接口类的指针可能被错误压缩，导致内存访问错误。", "code_v1_no_empty_lines": "+#ifdef ASSERT\n+  case Op_ConNKlass: {\n+    const TypePtr* tp = n->as_Type()->type()->make_ptr();\n+    ciKlass* klass = tp->is_klassptr()->exact_klass();\n+    assert(klass->is_in_encoding_range(), \"klass cannot be compressed\");\n+    break;\n+  }\n+#endif", "target": "+#ifdef ASSERT\n+  case Op_ConNKlass: {\n+    const TypePtr* tp = n->as_Type()->type()->make_ptr();\n+    ciKlass* klass = tp->is_klassptr()->exact_klass();\n+    assert(klass->is_in_encoding_range(), \"klass cannot be compressed\");\n+    break;\n+  }\n+#endif", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在最终图重塑阶段，抽象类或接口类的指针可能被错误压缩，导致内存访问错误。优化后：为Op_ConNKlass节点添加断言检查，确保类指针在压缩编码范围内，防止对抽象类或接口类指针进行无效压缩。优化思路：通过运行时断言验证内存布局假设，避免因指针压缩导致的运行时错误，提升编译器生成的代码可靠性。"}
{"id": 626, "source": "riscv-dataset-excel", "optimization_type": "性能优化", "optimization_description": "优化前：先调用Hashtable.containsKey()检查键是否存在，再调用get()获取值，导致两次哈希查找。优化后：直接调用get()获取值，通过判断返回值是否为null来确定键是否存在，减少一次哈希查找操作。优化思路：消除冗余的containsKey调用，将两次哈希查找合并为一次，提高反序列化时的性能。", "original_code": "先调用Hashtable.containsKey()检查键是否存在，再调用get()获取值，导致两次哈希查找。", "optimized_code": "-            if (cfs.containsKey(certType)) {\n-                // reuse certificate factory\n-                cf = cfs.get(certType);\n-            } else {\n+            CertificateFactory cf = cfs.get(certType);\n+            if (cf == null) {", "source_url": "https://github.com/openjdk/riscv-port/commit/f77a5144a12fc31bad8b672a3cc9caa688d78e72", "code_v0_no_empty_lines": "先调用Hashtable.containsKey()检查键是否存在，再调用get()获取值，导致两次哈希查找。", "code_v1_no_empty_lines": "-            if (cfs.containsKey(certType)) {\n-                // reuse certificate factory\n-                cf = cfs.get(certType);\n-            } else {\n+            CertificateFactory cf = cfs.get(certType);\n+            if (cf == null) {", "target": "-            if (cfs.containsKey(certType)) {\n-                // reuse certificate factory\n-                cf = cfs.get(certType);\n-            } else {\n+            CertificateFactory cf = cfs.get(certType);\n+            if (cf == null) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：先调用Hashtable.containsKey()检查键是否存在，再调用get()获取值，导致两次哈希查找。优化后：直接调用get()获取值，通过判断返回值是否为null来确定键是否存在，减少一次哈希查找操作。优化思路：消除冗余的containsKey调用，将两次哈希查找合并为一次，提高反序列化时的性能。"}
{"id": 627, "source": "riscv-dataset-excel", "optimization_type": "断言修复+逃逸分析优化", "optimization_description": "优化前：在逃逸分析的can_reduce_check_users函数中，当遇到非标准If节点（如OuterStripMinedLoopEnd或ParsePredicate）时，会触发断言失败，错误地假设这些节点必须包含OpaqueNotNull。优化后：移除了错误的断言，并扩展了注释说明，明确处理IfNode的子类情况，当遇到这些特殊节点时直接安全地退出优化。优化思路：修复了C2编译器在特定逃逸分析场景下的断言崩溃问题，提高了编译器的健壮性。", "original_code": "在逃逸分析的can_reduce_check_users函数中，当遇到非标准If节点（如OuterStripMinedLoopEnd或ParsePredicate）时，会触发断言失败，错误地假设这些节点必须包含OpaqueNotNull。", "optimized_code": "-          bool can_reduce = (iff->Opcode() == Op_If) && iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp();\n+          // We may have an OpaqueNotNull node between If and Bool nodes. But we could also have a sub class of IfNode,\n+          // for example, an OuterStripMinedLoopEnd or a Parse Predicate. Bail out in all these cases.\n+          bool can_reduce = (iff->Opcode() == Op_If) && iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp();\n-          } else {\n-            assert(iff->in(1)->is_OpaqueNotNull(), \"must be OpaqueNotNull\");\n           }", "source_url": "https://github.com/openjdk/riscv-port/commit/6f6cfe643b48c21c9b7349b584d31b813c025abd", "code_v0_no_empty_lines": "在逃逸分析的can_reduce_check_users函数中，当遇到非标准If节点（如OuterStripMinedLoopEnd或ParsePredicate）时，会触发断言失败，错误地假设这些节点必须包含OpaqueNotNull。", "code_v1_no_empty_lines": "-          bool can_reduce = (iff->Opcode() == Op_If) && iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp();\n+          // We may have an OpaqueNotNull node between If and Bool nodes. But we could also have a sub class of IfNode,\n+          // for example, an OuterStripMinedLoopEnd or a Parse Predicate. Bail out in all these cases.\n+          bool can_reduce = (iff->Opcode() == Op_If) && iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp();\n-          } else {\n-            assert(iff->in(1)->is_OpaqueNotNull(), \"must be OpaqueNotNull\");\n           }", "target": "-          bool can_reduce = (iff->Opcode() == Op_If) && iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp();\n+          // We may have an OpaqueNotNull node between If and Bool nodes. But we could also have a sub class of IfNode,\n+          // for example, an OuterStripMinedLoopEnd or a Parse Predicate. Bail out in all these cases.\n+          bool can_reduce = (iff->Opcode() == Op_If) && iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp();\n-          } else {\n-            assert(iff->in(1)->is_OpaqueNotNull(), \"must be OpaqueNotNull\");\n           }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在逃逸分析的can_reduce_check_users函数中，当遇到非标准If节点（如OuterStripMinedLoopEnd或ParsePredicate）时，会触发断言失败，错误地假设这些节点必须包含OpaqueNotNull。优化后：移除了错误的断言，并扩展了注释说明，明确处理IfNode的子类情况，当遇到这些特殊节点时直接安全地退出优化。优化思路：修复了C2编译器在特定逃逸分析场景下的断言崩溃问题，提高了编译器的健壮性。"}
{"id": 628, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化", "optimization_description": "优化前：线程ID分配使用临界区（spinlock）保护，存在锁竞争开销。优化后：移除临界区，通过断言确保仅在安全状态（线程新建或JNI附加）下分配ID，主线程ID在初始化时直接设为1。思路：利用线程生命周期保证ID分配的安全性，避免不必要的同步开销。", "original_code": "线程ID分配使用临界区（spinlock）保护，存在锁竞争开销。", "optimized_code": "-  JfrSpinlockHelper spinlock(&tl->_critical_section);\n+  assert(can_assign(t), \"invariant\");", "source_url": "https://github.com/openjdk/riscv-port/commit/5995786dbd69ed11dd1cacb2a3ac86e3e6f43ab7", "code_v0_no_empty_lines": "线程ID分配使用临界区（spinlock）保护，存在锁竞争开销。", "code_v1_no_empty_lines": "-  JfrSpinlockHelper spinlock(&tl->_critical_section);\n+  assert(can_assign(t), \"invariant\");", "target": "-  JfrSpinlockHelper spinlock(&tl->_critical_section);\n+  assert(can_assign(t), \"invariant\");", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：线程ID分配使用临界区（spinlock）保护，存在锁竞争开销。优化后：移除临界区，通过断言确保仅在安全状态（线程新建或JNI附加）下分配ID，主线程ID在初始化时直接设为1。思路：利用线程生命周期保证ID分配的安全性，避免不必要的同步开销。"}
{"id": 629, "source": "riscv-dataset-excel", "optimization_type": "指令优化+代码生成优化", "optimization_description": "优化前：使用la指令加载运行时地址（需要6条指令：lui + addi + slli + addi + slli + addi），然后调用jalr。优化后：使用movptr指令（需要4条指令：lui + lui + slli + add）加载地址，然后调用jalr。思路：减少运行时调用所需的指令数量，从11条指令减少到9条，通过更高效的地址加载方式提升性能。", "original_code": "使用la指令加载运行时地址（需要6条指令：lui + addi + slli + addi + slli + addi），然后调用jalr。", "optimized_code": "-  __ la(t1, RuntimeAddress(entry));\n-  __ jalr(t1);\n+  int32_t offset = 0;\n+  // No relocation needed\n+  __ movptr(t1, entry, offset, t0); // lui + lui + slli + add\n+  __ jalr(t1, offset);", "source_url": "https://github.com/openjdk/riscv-port/commit/cbda758010c22b0c1b9aec16004d4bfd24ab5c81", "code_v0_no_empty_lines": "使用la指令加载运行时地址（需要6条指令：lui + addi + slli + addi + slli + addi），然后调用jalr。", "code_v1_no_empty_lines": "-  __ la(t1, RuntimeAddress(entry));\n-  __ jalr(t1);\n+  int32_t offset = 0;\n+  // No relocation needed\n+  __ movptr(t1, entry, offset, t0); // lui + lui + slli + add\n+  __ jalr(t1, offset);", "target": "-  __ la(t1, RuntimeAddress(entry));\n-  __ jalr(t1);\n+  int32_t offset = 0;\n+  // No relocation needed\n+  __ movptr(t1, entry, offset, t0); // lui + lui + slli + add\n+  __ jalr(t1, offset);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用la指令加载运行时地址（需要6条指令：lui + addi + slli + addi + slli + addi），然后调用jalr。优化后：使用movptr指令（需要4条指令：lui + lui + slli + add）加载地址，然后调用jalr。思路：减少运行时调用所需的指令数量，从11条指令减少到9条，通过更高效的地址加载方式提升性能。"}
{"id": 630, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+加密算法优化", "optimization_description": "优化前：RISC-V平台缺少AES加密/解密指令集支持，相关操作需要通过软件模拟实现，性能较低。优化后：实现了RISC-V的AES单块加密/解密指令集（Zvkned扩展），包括vaesem_vv、vaesef_vv、vaesdm_vv、vaesdf_vv等指令，并添加了对应的加密/解密函数生成器。优化思路：利用RISC-V向量扩展指令集硬件加速AES算法，通过直接调用硬件指令替代软件模拟，显著提升加密/解密性能，支持AES-128、AES-192、AES-256三种密钥长度。", "original_code": "RISC-V平台缺少AES加密/解密指令集支持，相关操作需要通过软件模拟实现，性能较低。", "optimized_code": "+  // Vector AES instructions (Zvkned extension)\n+  INSN(vaesem_vv,   0b1110111, 0b010, 0b00010, 0b101000);\n+  INSN(vaesef_vv,   0b1110111, 0b010, 0b00011, 0b101000);\n+\n+  INSN(vaesdm_vv,   0b1110111, 0b010, 0b00000, 0b101000);\n+  INSN(vaesdf_vv,   0b1110111, 0b010, 0b00001, 0b101000);\n+\n+  void generate_aes_encrypt(const VectorRegister &res, VectorRegister *working_vregs, int rounds) {\n+    assert(rounds <= 15, \"rounds should be less than or equal to working_vregs size\");\n+\n+    __ vxor_vv(res, res, working_vregs[0]);\n+    for (int i = 1; i < rounds - 1; i++) {\n+      __ vaesem_vv(res, working_vregs[i]);\n+    }\n+    __ vaesef_vv(res, working_vregs[rounds - 1]);\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/e5bbad059d5dc293288ac415c9f7d0fa89c64b74", "code_v0_no_empty_lines": "RISC-V平台缺少AES加密/解密指令集支持，相关操作需要通过软件模拟实现，性能较低。", "code_v1_no_empty_lines": "+  // Vector AES instructions (Zvkned extension)\n+  INSN(vaesem_vv,   0b1110111, 0b010, 0b00010, 0b101000);\n+  INSN(vaesef_vv,   0b1110111, 0b010, 0b00011, 0b101000);\n+\n+  INSN(vaesdm_vv,   0b1110111, 0b010, 0b00000, 0b101000);\n+  INSN(vaesdf_vv,   0b1110111, 0b010, 0b00001, 0b101000);\n+\n+  void generate_aes_encrypt(const VectorRegister &res, VectorRegister *working_vregs, int rounds) {\n+    assert(rounds <= 15, \"rounds should be less than or equal to working_vregs size\");\n+\n+    __ vxor_vv(res, res, working_vregs[0]);\n+    for (int i = 1; i < rounds - 1; i++) {\n+      __ vaesem_vv(res, working_vregs[i]);\n+    }\n+    __ vaesef_vv(res, working_vregs[rounds - 1]);\n+  }", "target": "+  // Vector AES instructions (Zvkned extension)\n+  INSN(vaesem_vv,   0b1110111, 0b010, 0b00010, 0b101000);\n+  INSN(vaesef_vv,   0b1110111, 0b010, 0b00011, 0b101000);\n+\n+  INSN(vaesdm_vv,   0b1110111, 0b010, 0b00000, 0b101000);\n+  INSN(vaesdf_vv,   0b1110111, 0b010, 0b00001, 0b101000);\n+\n+  void generate_aes_encrypt(const VectorRegister &res, VectorRegister *working_vregs, int rounds) {\n+    assert(rounds <= 15, \"rounds should be less than or equal to working_vregs size\");\n+\n+    __ vxor_vv(res, res, working_vregs[0]);\n+    for (int i = 1; i < rounds - 1; i++) {\n+      __ vaesem_vv(res, working_vregs[i]);\n+    }\n+    __ vaesef_vv(res, working_vregs[rounds - 1]);\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V平台缺少AES加密/解密指令集支持，相关操作需要通过软件模拟实现，性能较低。优化后：实现了RISC-V的AES单块加密/解密指令集（Zvkned扩展），包括vaesem_vv、vaesef_vv、vaesdm_vv、vaesdf_vv等指令，并添加了对应的加密/解密函数生成器。优化思路：利用RISC-V向量扩展指令集硬件加速AES算法，通过直接调用硬件指令替代软件模拟，显著提升加密/解密性能，支持AES-128、AES-192、AES-256三种密钥长度。"}
{"id": 631, "source": "riscv-dataset-excel", "optimization_type": "指令优化+常量池处理优化", "optimization_description": "优化前：writeLoadConstant方法统一处理所有常量加载，包含不必要的类型检查和索引范围判断，且ldc方法直接调用writeLoadConstant。优化后：拆分为writeAdaptLoadConstant（处理外部常量池条目）和writeDirectLoadConstant（处理可写入的常量池条目），优化了指令选择逻辑（仅当外部条目且非LDC2_W时才重写指令），ldc方法直接调用writeDirectLoadConstant。优化思路：通过分离处理逻辑，减少不必要的检查和分支，提高常量加载指令生成的效率和一致性，特别是处理跨常量池的常量加载时。", "original_code": "writeLoadConstant方法统一处理所有常量加载，包含不必要的类型检查和索引范围判断，且ldc方法直接调用writeLoadConstant。", "optimized_code": "@@ -670,16 +670,22 @@\n-    public void writeLoadConstant(Opcode opcode, LoadableConstantEntry value) {\n-        // Make sure Long and Double have LDC2_W and\n-        // rewrite to _W if index is >= 256\n-        int index = AbstractPoolEntry.maybeClone(constantPool, value).index();\n-        if (value instanceof LongEntry || value instanceof DoubleEntry) {\n-            opcode = Opcode.LDC2_W;\n-        } else if (index >= 256)\n-            opcode = Opcode.LDC_W;\n+    // value may not be writable to this constant pool\n+    public void writeAdaptLoadConstant(Opcode opcode, LoadableConstantEntry value) {\n+        var pe = AbstractPoolEntry.maybeClone(constantPool, value);\n+        int index = pe.index();\n+        if (pe != value && opcode != Opcode.LDC2_W) {\n+            // rewrite ldc/ldc_w if external entry; ldc2_w never needs rewrites\n+            opcode = index <= 0xFF ? Opcode.LDC : Opcode.LDC_W;\n+        }\n \n-        assert !opcode.isWide();\n+        writeDirectLoadConstant(opcode, pe);\n+    }\n+\n+    // the loadable entry is writable to this constant pool\n+    public void writeDirectLoadConstant(Opcode opcode, LoadableConstantEntry pe) {\n+        assert !opcode.isWide() && canWriteDirect(pe.constantPool());\n+        int index = pe.index();\n         if (opcode.sizeIfFixed() == 3) {\n             bytecodesBufWriter.writeU1U2(opcode.bytecode(), index);\n         } else {\n@@ -1654,7 +1660,8 @@\n \n     @Override\n     public CodeBuilder ldc(LoadableConstantEntry entry) {\n-        writeLoadConstant(BytecodeHelpers.ldcOpcode(entry), entry);\n+        var direct = AbstractPoolEntry.maybeClone(constantPool, entry);\n+        writeDirectLoadConstant(BytecodeHelpers.ldcOpcode(direct), direct);\n         return this;\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/3ccd2f757d069c16147b331a90b1590c8ad4ae24", "code_v0_no_empty_lines": "writeLoadConstant方法统一处理所有常量加载，包含不必要的类型检查和索引范围判断，且ldc方法直接调用writeLoadConstant。", "code_v1_no_empty_lines": "@@ -670,16 +670,22 @@\n-    public void writeLoadConstant(Opcode opcode, LoadableConstantEntry value) {\n-        // Make sure Long and Double have LDC2_W and\n-        // rewrite to _W if index is >= 256\n-        int index = AbstractPoolEntry.maybeClone(constantPool, value).index();\n-        if (value instanceof LongEntry || value instanceof DoubleEntry) {\n-            opcode = Opcode.LDC2_W;\n-        } else if (index >= 256)\n-            opcode = Opcode.LDC_W;\n+    // value may not be writable to this constant pool\n+    public void writeAdaptLoadConstant(Opcode opcode, LoadableConstantEntry value) {\n+        var pe = AbstractPoolEntry.maybeClone(constantPool, value);\n+        int index = pe.index();\n+        if (pe != value && opcode != Opcode.LDC2_W) {\n+            // rewrite ldc/ldc_w if external entry; ldc2_w never needs rewrites\n+            opcode = index <= 0xFF ? Opcode.LDC : Opcode.LDC_W;\n+        }\n \n-        assert !opcode.isWide();\n+        writeDirectLoadConstant(opcode, pe);\n+    }\n+\n+    // the loadable entry is writable to this constant pool\n+    public void writeDirectLoadConstant(Opcode opcode, LoadableConstantEntry pe) {\n+        assert !opcode.isWide() && canWriteDirect(pe.constantPool());\n+        int index = pe.index();\n         if (opcode.sizeIfFixed() == 3) {\n             bytecodesBufWriter.writeU1U2(opcode.bytecode(), index);\n         } else {\n@@ -1654,7 +1660,8 @@\n \n     @Override\n     public CodeBuilder ldc(LoadableConstantEntry entry) {\n-        writeLoadConstant(BytecodeHelpers.ldcOpcode(entry), entry);\n+        var direct = AbstractPoolEntry.maybeClone(constantPool, entry);\n+        writeDirectLoadConstant(BytecodeHelpers.ldcOpcode(direct), direct);\n         return this;\n     }", "target": "@@ -670,16 +670,22 @@\n-    public void writeLoadConstant(Opcode opcode, LoadableConstantEntry value) {\n-        // Make sure Long and Double have LDC2_W and\n-        // rewrite to _W if index is >= 256\n-        int index = AbstractPoolEntry.maybeClone(constantPool, value).index();\n-        if (value instanceof LongEntry || value instanceof DoubleEntry) {\n-            opcode = Opcode.LDC2_W;\n-        } else if (index >= 256)\n-            opcode = Opcode.LDC_W;\n+    // value may not be writable to this constant pool\n+    public void writeAdaptLoadConstant(Opcode opcode, LoadableConstantEntry value) {\n+        var pe = AbstractPoolEntry.maybeClone(constantPool, value);\n+        int index = pe.index();\n+        if (pe != value && opcode != Opcode.LDC2_W) {\n+            // rewrite ldc/ldc_w if external entry; ldc2_w never needs rewrites\n+            opcode = index <= 0xFF ? Opcode.LDC : Opcode.LDC_W;\n+        }\n \n-        assert !opcode.isWide();\n+        writeDirectLoadConstant(opcode, pe);\n+    }\n+\n+    // the loadable entry is writable to this constant pool\n+    public void writeDirectLoadConstant(Opcode opcode, LoadableConstantEntry pe) {\n+        assert !opcode.isWide() && canWriteDirect(pe.constantPool());\n+        int index = pe.index();\n         if (opcode.sizeIfFixed() == 3) {\n             bytecodesBufWriter.writeU1U2(opcode.bytecode(), index);\n         } else {\n@@ -1654,7 +1660,8 @@\n \n     @Override\n     public CodeBuilder ldc(LoadableConstantEntry entry) {\n-        writeLoadConstant(BytecodeHelpers.ldcOpcode(entry), entry);\n+        var direct = AbstractPoolEntry.maybeClone(constantPool, entry);\n+        writeDirectLoadConstant(BytecodeHelpers.ldcOpcode(direct), direct);\n         return this;\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：writeLoadConstant方法统一处理所有常量加载，包含不必要的类型检查和索引范围判断，且ldc方法直接调用writeLoadConstant。优化后：拆分为writeAdaptLoadConstant（处理外部常量池条目）和writeDirectLoadConstant（处理可写入的常量池条目），优化了指令选择逻辑（仅当外部条目且非LDC2_W时才重写指令），ldc方法直接调用writeDirectLoadConstant。优化思路：通过分离处理逻辑，减少不必要的检查和分支，提高常量加载指令生成的效率和一致性，特别是处理跨常量池的常量加载时。"}
{"id": 632, "source": "riscv-dataset-excel", "optimization_type": "代码重构+设计模式优化", "optimization_description": "优化前：循环剥离（Loop Peeling）中的断言谓词处理采用手动遍历和克隆代码的方式，代码复杂且容易出错。优化后：引入谓词访问者模式（Predicate Visitor），通过CreateAssertionPredicatesVisitor和PredicateIterator封装遍历逻辑，简化了代码结构。优化思路：将复杂的谓词遍历和初始化逻辑抽象为访问者模式，提高代码可维护性和可读性，减少重复代码，同时保持相同的功能语义。", "original_code": "循环剥离（Loop Peeling）中的断言谓词处理采用手动遍历和克隆代码的方式，代码复杂且容易出错。", "optimized_code": "- void PhaseIdealLoop::initialize_assertion_predicates_for_peeled_loop(const PredicateBlock* predicate_block,\n                                                                     LoopNode* outer_loop_head,\n                                                                     const int dd_outer_loop_head, Node* init,\n                                                                     Node* stride, IdealLoopTree* outer_loop,\n                                                                     const uint idx_before_clone,\n                                                                     const Node_List &old_new) {\n+ void PhaseIdealLoop::initialize_assertion_predicates_for_peeled_loop(CountedLoopNode* peeled_loop_head,\n                                                                     CountedLoopNode* remaining_loop_head,\n                                                                     const uint first_node_index_in_cloned_loop_body,\n                                                                     const Node_List& old_new) {\n+   const NodeInOriginalLoopBody node_in_original_loop_body(first_node_index_in_cloned_loop_body, old_new);\n+   create_assertion_predicates_at_loop(peeled_loop_head, remaining_loop_head, node_in_original_loop_body);\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/63c19d3db586920108808866c7a094a5ae41bc22", "code_v0_no_empty_lines": "循环剥离（Loop Peeling）中的断言谓词处理采用手动遍历和克隆代码的方式，代码复杂且容易出错。", "code_v1_no_empty_lines": "- void PhaseIdealLoop::initialize_assertion_predicates_for_peeled_loop(const PredicateBlock* predicate_block,\n                                                                     LoopNode* outer_loop_head,\n                                                                     const int dd_outer_loop_head, Node* init,\n                                                                     Node* stride, IdealLoopTree* outer_loop,\n                                                                     const uint idx_before_clone,\n                                                                     const Node_List &old_new) {\n+ void PhaseIdealLoop::initialize_assertion_predicates_for_peeled_loop(CountedLoopNode* peeled_loop_head,\n                                                                     CountedLoopNode* remaining_loop_head,\n                                                                     const uint first_node_index_in_cloned_loop_body,\n                                                                     const Node_List& old_new) {\n+   const NodeInOriginalLoopBody node_in_original_loop_body(first_node_index_in_cloned_loop_body, old_new);\n+   create_assertion_predicates_at_loop(peeled_loop_head, remaining_loop_head, node_in_original_loop_body);\n+ }", "target": "- void PhaseIdealLoop::initialize_assertion_predicates_for_peeled_loop(const PredicateBlock* predicate_block,\n                                                                     LoopNode* outer_loop_head,\n                                                                     const int dd_outer_loop_head, Node* init,\n                                                                     Node* stride, IdealLoopTree* outer_loop,\n                                                                     const uint idx_before_clone,\n                                                                     const Node_List &old_new) {\n+ void PhaseIdealLoop::initialize_assertion_predicates_for_peeled_loop(CountedLoopNode* peeled_loop_head,\n                                                                     CountedLoopNode* remaining_loop_head,\n                                                                     const uint first_node_index_in_cloned_loop_body,\n                                                                     const Node_List& old_new) {\n+   const NodeInOriginalLoopBody node_in_original_loop_body(first_node_index_in_cloned_loop_body, old_new);\n+   create_assertion_predicates_at_loop(peeled_loop_head, remaining_loop_head, node_in_original_loop_body);\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：循环剥离（Loop Peeling）中的断言谓词处理采用手动遍历和克隆代码的方式，代码复杂且容易出错。优化后：引入谓词访问者模式（Predicate Visitor），通过CreateAssertionPredicatesVisitor和PredicateIterator封装遍历逻辑，简化了代码结构。优化思路：将复杂的谓词遍历和初始化逻辑抽象为访问者模式，提高代码可维护性和可读性，减少重复代码，同时保持相同的功能语义。"}
{"id": 633, "source": "riscv-dataset-excel", "optimization_type": "代码重构与组织优化", "optimization_description": "优化前：Shenandoah GC的闭包实现分散在多个文件中，存在代码重复和冗余。优化后：将共享的闭包功能整合到shenandoahClosures.hpp中，引入统一的基类层次结构，删除了冗余的oopClosures文件。优化思路：通过代码重构减少重复代码，改善代码组织，提高可维护性，可能带来编译时性能提升和代码清晰度改进。", "original_code": "Shenandoah GC的闭包实现分散在多个文件中，存在代码重复和冗余。", "optimized_code": "- 删除shenandoahOopClosures.hpp和shenandoahOopClosures.inline.hpp文件\n+ 在shenandoahClosures.hpp中新增ShenandoahSuperClosure、ShenandoahMarkRefsSuperClosure等基类\n+ 重构闭包继承层次，将共享功能集中到基类", "source_url": "https://github.com/openjdk/riscv-port/commit/9003524c8bbe5041b8d51deb6000b688a29027f8", "code_v0_no_empty_lines": "Shenandoah GC的闭包实现分散在多个文件中，存在代码重复和冗余。", "code_v1_no_empty_lines": "- 删除shenandoahOopClosures.hpp和shenandoahOopClosures.inline.hpp文件\n+ 在shenandoahClosures.hpp中新增ShenandoahSuperClosure、ShenandoahMarkRefsSuperClosure等基类\n+ 重构闭包继承层次，将共享功能集中到基类", "target": "- 删除shenandoahOopClosures.hpp和shenandoahOopClosures.inline.hpp文件\n+ 在shenandoahClosures.hpp中新增ShenandoahSuperClosure、ShenandoahMarkRefsSuperClosure等基类\n+ 重构闭包继承层次，将共享功能集中到基类", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Shenandoah GC的闭包实现分散在多个文件中，存在代码重复和冗余。优化后：将共享的闭包功能整合到shenandoahClosures.hpp中，引入统一的基类层次结构，删除了冗余的oopClosures文件。优化思路：通过代码重构减少重复代码，改善代码组织，提高可维护性，可能带来编译时性能提升和代码清晰度改进。"}
{"id": 634, "source": "riscv-dataset-excel", "optimization_type": "代码清理与架构简化", "optimization_description": "优化前：ZGC保留非分代模式（XGC）的完整代码实现，增加了代码复杂性和维护成本。优化后：根据JEP 490规范，完全移除XGC（非分代模式）的所有代码，包括屏障集、内存管理、平台适配等组件。优化思路：简化ZGC架构，消除冗余代码路径，减少编译产物大小，降低运行时分支判断开销，提升代码可维护性。", "original_code": "ZGC保留非分代模式（XGC）的完整代码实现，增加了代码复杂性和维护成本。", "optimized_code": "- src/hotspot/share/gc/x/xBarrierSet.cpp\n- src/hotspot/share/gc/x/xBarrierSet.hpp\n- src/hotspot/share/gc/x/xCollectedHeap.cpp\n- src/hotspot/share/gc/x/xCollectedHeap.hpp\n- ... (大量XGC相关文件删除)", "source_url": "https://github.com/openjdk/riscv-port/commit/821c514a132e809a14648ddbb56f2ffee85fd35a", "code_v0_no_empty_lines": "ZGC保留非分代模式（XGC）的完整代码实现，增加了代码复杂性和维护成本。", "code_v1_no_empty_lines": "- src/hotspot/share/gc/x/xBarrierSet.cpp\n- src/hotspot/share/gc/x/xBarrierSet.hpp\n- src/hotspot/share/gc/x/xCollectedHeap.cpp\n- src/hotspot/share/gc/x/xCollectedHeap.hpp\n- ... (大量XGC相关文件删除)", "target": "- src/hotspot/share/gc/x/xBarrierSet.cpp\n- src/hotspot/share/gc/x/xBarrierSet.hpp\n- src/hotspot/share/gc/x/xCollectedHeap.cpp\n- src/hotspot/share/gc/x/xCollectedHeap.hpp\n- ... (大量XGC相关文件删除)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ZGC保留非分代模式（XGC）的完整代码实现，增加了代码复杂性和维护成本。优化后：根据JEP 490规范，完全移除XGC（非分代模式）的所有代码，包括屏障集、内存管理、平台适配等组件。优化思路：简化ZGC架构，消除冗余代码路径，减少编译产物大小，降低运行时分支判断开销，提升代码可维护性。"}
{"id": 635, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+性能优化", "optimization_description": "优化前：SHA3算法在x86平台上缺乏AVX-512指令集支持，无法利用现代CPU的向量化计算能力。优化后：为SHA3算法添加AVX-512指令集支持，包括evmovdquw（向量加载）、vpmuldq（向量乘法）、evpmulhw（向量高位乘法）和evpermt2w/d/q（向量置换）等指令。优化思路：通过实现AVX-512指令集支持，使SHA3算法能够利用512位向量寄存器进行并行计算，显著提升SHA3哈希计算的性能，特别是在支持AVX-512的现代x86处理器上。", "original_code": "SHA3算法在x86平台上缺乏AVX-512指令集支持，无法利用现代CPU的向量化计算能力。", "optimized_code": "+void Assembler::evmovdquw(XMMRegister dst, XMMRegister src, int vector_len) {\n+  // Unmasked instruction\n+  evmovdquw(dst, k0, src, /*merge*/ false, vector_len);\n+}\n\n+void Assembler::vpmuldq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_evex()), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_rex_vex_w_reverted();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x28, (0xC0 | encode));\n+}\n\n+void Assembler::evpmulhw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false,/* legacy_mode */ false, /* no_mask_reg */ false,/* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE5, (0xC0 | encode));\n+}\n\n+void Assembler::evpermt2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len <= AVX_256bit ? VM_Version::supports_avx512vlbw() : VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x7D, (0xC0 | encode));\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/9cfb0f7f7ad31081c917be1eb0e39e2552e45382", "code_v0_no_empty_lines": "SHA3算法在x86平台上缺乏AVX-512指令集支持，无法利用现代CPU的向量化计算能力。", "code_v1_no_empty_lines": "+void Assembler::evmovdquw(XMMRegister dst, XMMRegister src, int vector_len) {\n+  // Unmasked instruction\n+  evmovdquw(dst, k0, src, /*merge*/ false, vector_len);\n+}\n\n+void Assembler::vpmuldq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_evex()), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_rex_vex_w_reverted();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x28, (0xC0 | encode));\n+}\n\n+void Assembler::evpmulhw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false,/* legacy_mode */ false, /* no_mask_reg */ false,/* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE5, (0xC0 | encode));\n+}\n\n+void Assembler::evpermt2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len <= AVX_256bit ? VM_Version::supports_avx512vlbw() : VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x7D, (0xC0 | encode));\n+}", "target": "+void Assembler::evmovdquw(XMMRegister dst, XMMRegister src, int vector_len) {\n+  // Unmasked instruction\n+  evmovdquw(dst, k0, src, /*merge*/ false, vector_len);\n+}\n\n+void Assembler::vpmuldq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_evex()), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_rex_vex_w_reverted();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x28, (0xC0 | encode));\n+}\n\n+void Assembler::evpmulhw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false,/* legacy_mode */ false, /* no_mask_reg */ false,/* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE5, (0xC0 | encode));\n+}\n\n+void Assembler::evpermt2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len <= AVX_256bit ? VM_Version::supports_avx512vlbw() : VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x7D, (0xC0 | encode));\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SHA3算法在x86平台上缺乏AVX-512指令集支持，无法利用现代CPU的向量化计算能力。优化后：为SHA3算法添加AVX-512指令集支持，包括evmovdquw（向量加载）、vpmuldq（向量乘法）、evpmulhw（向量高位乘法）和evpermt2w/d/q（向量置换）等指令。优化思路：通过实现AVX-512指令集支持，使SHA3算法能够利用512位向量寄存器进行并行计算，显著提升SHA3哈希计算的性能，特别是在支持AVX-512的现代x86处理器上。"}
{"id": 636, "source": "riscv-dataset-excel", "optimization_type": "代码重构/API扩展", "optimization_description": "优化前：PPC64汇编器只有基于RegisterOrConstant参数的load/store函数，使用Address对象时需要手动提取其base、index和displacement分量。优化后：新增了直接接受Address对象参数的load/store函数重载，简化了调用代码，提高了可读性和维护性。优化思路：通过封装Address对象的内部结构，提供更简洁的API接口，减少调用时的代码复杂度。", "original_code": "PPC64汇编器只有基于RegisterOrConstant参数的load/store函数，使用Address对象时需要手动提取其base、index和displacement分量。", "optimized_code": "void ld( Register d, Address &a);\nvoid lwa(Register d, Address &a);\nvoid lwz(Register d, Address &a);\nvoid lha(Register d, Address &a);\nvoid lhz(Register d, Address &a);\nvoid lbz(Register d, Address &a);\nvoid std(Register d, Address &a, Register tmp = noreg);\nvoid stw(Register d, Address &a, Register tmp = noreg);\nvoid sth(Register d, Address &a, Register tmp = noreg);\nvoid stb(Register d, Address &a, Register tmp = noreg);", "source_url": "https://github.com/openjdk/riscv-port/commit/520ddac97053be669d9678375266ccfd6724e3e1", "code_v0_no_empty_lines": "PPC64汇编器只有基于RegisterOrConstant参数的load/store函数，使用Address对象时需要手动提取其base、index和displacement分量。", "code_v1_no_empty_lines": "void ld( Register d, Address &a);\nvoid lwa(Register d, Address &a);\nvoid lwz(Register d, Address &a);\nvoid lha(Register d, Address &a);\nvoid lhz(Register d, Address &a);\nvoid lbz(Register d, Address &a);\nvoid std(Register d, Address &a, Register tmp = noreg);\nvoid stw(Register d, Address &a, Register tmp = noreg);\nvoid sth(Register d, Address &a, Register tmp = noreg);\nvoid stb(Register d, Address &a, Register tmp = noreg);", "target": "void ld( Register d, Address &a);\nvoid lwa(Register d, Address &a);\nvoid lwz(Register d, Address &a);\nvoid lha(Register d, Address &a);\nvoid lhz(Register d, Address &a);\nvoid lbz(Register d, Address &a);\nvoid std(Register d, Address &a, Register tmp = noreg);\nvoid stw(Register d, Address &a, Register tmp = noreg);\nvoid sth(Register d, Address &a, Register tmp = noreg);\nvoid stb(Register d, Address &a, Register tmp = noreg);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PPC64汇编器只有基于RegisterOrConstant参数的load/store函数，使用Address对象时需要手动提取其base、index和displacement分量。优化后：新增了直接接受Address对象参数的load/store函数重载，简化了调用代码，提高了可读性和维护性。优化思路：通过封装Address对象的内部结构，提供更简洁的API接口，减少调用时的代码复杂度。"}
{"id": 637, "source": "riscv-dataset-excel", "optimization_type": "代码缓存优化", "optimization_description": "优化前：CodeCacheSegmentSize在分层编译时额外增加64字节，CodeEntryAlignment在AArch64上默认为64字节。优化后：统一CodeCacheSegmentSize为64字节，在支持特定指令集的AArch64处理器上将CodeEntryAlignment默认值调整为32字节。优化思路：简化代码缓存段大小配置，根据处理器特性优化代码入口对齐，减少内存浪费并提高缓存效率。", "original_code": "CodeCacheSegmentSize在分层编译时额外增加64字节，CodeEntryAlignment在AArch64上默认为64字节。", "optimized_code": "define_pd_global(uintx, CodeCacheSegmentSize,    64 COMPILER1_AND_COMPILER2_PRESENT(+64));\n+define_pd_global(uintx, CodeCacheSegmentSize,    64);\n+if (FLAG_IS_DEFAULT(CodeEntryAlignment)) {\n+  FLAG_SET_DEFAULT(CodeEntryAlignment, 32);\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/d8430efb5e159b8e08d2cac66b46cb4ff1112927", "code_v0_no_empty_lines": "CodeCacheSegmentSize在分层编译时额外增加64字节，CodeEntryAlignment在AArch64上默认为64字节。", "code_v1_no_empty_lines": "define_pd_global(uintx, CodeCacheSegmentSize,    64 COMPILER1_AND_COMPILER2_PRESENT(+64));\n+define_pd_global(uintx, CodeCacheSegmentSize,    64);\n+if (FLAG_IS_DEFAULT(CodeEntryAlignment)) {\n+  FLAG_SET_DEFAULT(CodeEntryAlignment, 32);\n+}", "target": "define_pd_global(uintx, CodeCacheSegmentSize,    64 COMPILER1_AND_COMPILER2_PRESENT(+64));\n+define_pd_global(uintx, CodeCacheSegmentSize,    64);\n+if (FLAG_IS_DEFAULT(CodeEntryAlignment)) {\n+  FLAG_SET_DEFAULT(CodeEntryAlignment, 32);\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CodeCacheSegmentSize在分层编译时额外增加64字节，CodeEntryAlignment在AArch64上默认为64字节。优化后：统一CodeCacheSegmentSize为64字节，在支持特定指令集的AArch64处理器上将CodeEntryAlignment默认值调整为32字节。优化思路：简化代码缓存段大小配置，根据处理器特性优化代码入口对齐，减少内存浪费并提高缓存效率。"}
{"id": 638, "source": "riscv-dataset-excel", "optimization_type": "锁优化+内存管理优化", "optimization_description": "优化前：NMT（Native Memory Tracking）使用ThreadCritical进行内存跟踪操作的同步，ThreadCritical是一个全局临界区，会导致不必要的线程阻塞和性能开销。优化后：引入NmtVirtualMemoryLocker（基于Mutex的细粒度锁）替代ThreadCritical，减少锁竞争，提高并发性能。优化思路：将粗粒度的全局锁替换为细粒度的专用锁，降低同步开销，提升多线程环境下内存跟踪的效率。", "original_code": "NMT（Native Memory Tracking）使用ThreadCritical进行内存跟踪操作的同步，ThreadCritical是一个全局临界区，会导致不必要的线程阻塞和性能开销。", "optimized_code": "- ThreadCritical tc;\n+ NmtVirtualMemoryLocker ml;", "source_url": "https://github.com/openjdk/riscv-port/commit/0abfa3ba8f72538f62be838c1ebac8cfbdd14cdf", "code_v0_no_empty_lines": "NMT（Native Memory Tracking）使用ThreadCritical进行内存跟踪操作的同步，ThreadCritical是一个全局临界区，会导致不必要的线程阻塞和性能开销。", "code_v1_no_empty_lines": "- ThreadCritical tc;\n+ NmtVirtualMemoryLocker ml;", "target": "- ThreadCritical tc;\n+ NmtVirtualMemoryLocker ml;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：NMT（Native Memory Tracking）使用ThreadCritical进行内存跟踪操作的同步，ThreadCritical是一个全局临界区，会导致不必要的线程阻塞和性能开销。优化后：引入NmtVirtualMemoryLocker（基于Mutex的细粒度锁）替代ThreadCritical，减少锁竞争，提高并发性能。优化思路：将粗粒度的全局锁替换为细粒度的专用锁，降低同步开销，提升多线程环境下内存跟踪的效率。"}
{"id": 639, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（循环优化/谓词消除）", "optimization_description": "优化前：在消除无用的模板断言谓词时，直接将不透明节点替换为常量1，但未设置该常量的控制节点（ctrl），导致后续验证失败（VerifyLoopOptimizations）。优化后：创建常量1节点后，显式调用set_ctrl()将其控制节点设置为根节点（C->root()），确保图结构正确。优化思路：修复编译器内部图结构一致性，避免因缺失控制节点而触发验证断言失败，确保循环优化过程正确进行。", "original_code": "在消除无用的模板断言谓词时，直接将不透明节点替换为常量1，但未设置该常量的控制节点（ctrl），导致后续验证失败（VerifyLoopOptimizations）。", "optimized_code": "-      _igvn.replace_node(opaque_node, _igvn.intcon(1));\n+      ConINode* one = _igvn.intcon(1);\n+      set_ctrl(one, C->root());\n+      _igvn.replace_node(opaque_node, one);", "source_url": "https://github.com/openjdk/riscv-port/commit/e389f82b1b2365a43fef744936b222328d71494b", "code_v0_no_empty_lines": "在消除无用的模板断言谓词时，直接将不透明节点替换为常量1，但未设置该常量的控制节点（ctrl），导致后续验证失败（VerifyLoopOptimizations）。", "code_v1_no_empty_lines": "-      _igvn.replace_node(opaque_node, _igvn.intcon(1));\n+      ConINode* one = _igvn.intcon(1);\n+      set_ctrl(one, C->root());\n+      _igvn.replace_node(opaque_node, one);", "target": "-      _igvn.replace_node(opaque_node, _igvn.intcon(1));\n+      ConINode* one = _igvn.intcon(1);\n+      set_ctrl(one, C->root());\n+      _igvn.replace_node(opaque_node, one);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在消除无用的模板断言谓词时，直接将不透明节点替换为常量1，但未设置该常量的控制节点（ctrl），导致后续验证失败（VerifyLoopOptimizations）。优化后：创建常量1节点后，显式调用set_ctrl()将其控制节点设置为根节点（C->root()），确保图结构正确。优化思路：修复编译器内部图结构一致性，避免因缺失控制节点而触发验证断言失败，确保循环优化过程正确进行。"}
{"id": 640, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：Metaspace为生成的反射类维护了专门的ReflectionMetaspaceType类型及相关配置（如g_sequ_refl_class/g_sequ_refl_non_class数组），增加了内存管理复杂性和代码维护成本。优化后：完全移除ReflectionMetaspaceType枚举值、相关配置数组和分支逻辑，将原本使用ReflectionMetaspaceType的微元空间（micro）场景改为使用现有的ClassMirrorHolderMetaspaceType。优化思路：简化Metaspace类型系统，减少不必要的内存管理开销和代码复杂度，同时更新相关测试用例以保持功能一致性。", "original_code": "Metaspace为生成的反射类维护了专门的ReflectionMetaspaceType类型及相关配置（如g_sequ_refl_class/g_sequ_refl_non_class数组），增加了内存管理复杂性和代码维护成本。", "optimized_code": "-    ReflectionMetaspaceType = ClassMirrorHolderMetaspaceType + 1,\n-    MetaspaceTypeCount\n+    MetaspaceTypeCount\n-static const chunklevel_t g_sequ_refl_non_class[] = {\n-    chunklevel::CHUNK_LEVEL_2K,\n-    chunklevel::CHUNK_LEVEL_1K\n-    // .. repeat last\n-};\n-\n-static const chunklevel_t g_sequ_refl_class[] = {\n-    chunklevel::CHUNK_LEVEL_1K,\n-    // .. repeat last\n-};\n-  DEFINE_CLASS_FOR_ARRAY(refl_non_class)\n-  DEFINE_CLASS_FOR_ARRAY(refl_class)\n-    case Metaspace::ReflectionMetaspaceType:        return &chunk_alloc_sequence_refl_class;\n-    case Metaspace::ReflectionMetaspaceType:        return &chunk_alloc_sequence_refl_non_class;\n-  const Metaspace::MetaspaceType type = is_micro ? Metaspace::ReflectionMetaspaceType : Metaspace::StandardMetaspaceType;\n+  const Metaspace::MetaspaceType type = is_micro ? Metaspace::ClassMirrorHolderMetaspaceType : Metaspace::StandardMetaspaceType;", "source_url": "https://github.com/openjdk/riscv-port/commit/120a9357b3cf63427a6c8539128b69b11b9beca3", "code_v0_no_empty_lines": "Metaspace为生成的反射类维护了专门的ReflectionMetaspaceType类型及相关配置（如g_sequ_refl_class/g_sequ_refl_non_class数组），增加了内存管理复杂性和代码维护成本。", "code_v1_no_empty_lines": "-    ReflectionMetaspaceType = ClassMirrorHolderMetaspaceType + 1,\n-    MetaspaceTypeCount\n+    MetaspaceTypeCount\n-static const chunklevel_t g_sequ_refl_non_class[] = {\n-    chunklevel::CHUNK_LEVEL_2K,\n-    chunklevel::CHUNK_LEVEL_1K\n-    // .. repeat last\n-};\n-\n-static const chunklevel_t g_sequ_refl_class[] = {\n-    chunklevel::CHUNK_LEVEL_1K,\n-    // .. repeat last\n-};\n-  DEFINE_CLASS_FOR_ARRAY(refl_non_class)\n-  DEFINE_CLASS_FOR_ARRAY(refl_class)\n-    case Metaspace::ReflectionMetaspaceType:        return &chunk_alloc_sequence_refl_class;\n-    case Metaspace::ReflectionMetaspaceType:        return &chunk_alloc_sequence_refl_non_class;\n-  const Metaspace::MetaspaceType type = is_micro ? Metaspace::ReflectionMetaspaceType : Metaspace::StandardMetaspaceType;\n+  const Metaspace::MetaspaceType type = is_micro ? Metaspace::ClassMirrorHolderMetaspaceType : Metaspace::StandardMetaspaceType;", "target": "-    ReflectionMetaspaceType = ClassMirrorHolderMetaspaceType + 1,\n-    MetaspaceTypeCount\n+    MetaspaceTypeCount\n-static const chunklevel_t g_sequ_refl_non_class[] = {\n-    chunklevel::CHUNK_LEVEL_2K,\n-    chunklevel::CHUNK_LEVEL_1K\n-    // .. repeat last\n-};\n-\n-static const chunklevel_t g_sequ_refl_class[] = {\n-    chunklevel::CHUNK_LEVEL_1K,\n-    // .. repeat last\n-};\n-  DEFINE_CLASS_FOR_ARRAY(refl_non_class)\n-  DEFINE_CLASS_FOR_ARRAY(refl_class)\n-    case Metaspace::ReflectionMetaspaceType:        return &chunk_alloc_sequence_refl_class;\n-    case Metaspace::ReflectionMetaspaceType:        return &chunk_alloc_sequence_refl_non_class;\n-  const Metaspace::MetaspaceType type = is_micro ? Metaspace::ReflectionMetaspaceType : Metaspace::StandardMetaspaceType;\n+  const Metaspace::MetaspaceType type = is_micro ? Metaspace::ClassMirrorHolderMetaspaceType : Metaspace::StandardMetaspaceType;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Metaspace为生成的反射类维护了专门的ReflectionMetaspaceType类型及相关配置（如g_sequ_refl_class/g_sequ_refl_non_class数组），增加了内存管理复杂性和代码维护成本。优化后：完全移除ReflectionMetaspaceType枚举值、相关配置数组和分支逻辑，将原本使用ReflectionMetaspaceType的微元空间（micro）场景改为使用现有的ClassMirrorHolderMetaspaceType。优化思路：简化Metaspace类型系统，减少不必要的内存管理开销和代码复杂度，同时更新相关测试用例以保持功能一致性。"}
{"id": 641, "source": "riscv-dataset-excel", "optimization_type": "向量化指令集扩展", "optimization_description": "优化前：VectorAPI缺少对无符号和饱和向量操作的支持，限制了向量化性能优化。优化后：扩展x86后端汇编器支持新的无符号和饱和向量操作符，添加EVEX指令集支持（如evmovdqub/w），改进断言条件以支持更广泛的AVX-512指令集变体，并新增VectorMath类和相关测试模板。优化思路：通过硬件向量指令集扩展，提升数值计算密集型操作的并行处理能力，减少循环开销，充分利用现代CPU的SIMD能力。", "original_code": "VectorAPI缺少对无符号和饱和向量操作的支持，限制了向量化性能优化。", "optimized_code": "+#ifndef PRODUCT\n+bool Assembler::needs_evex(XMMRegister reg1, XMMRegister reg2, XMMRegister reg3) {\n+  return (reg1->is_valid() && reg1->encoding() >= 16) ||\n+         (reg2->is_valid() && reg2->encoding() >= 16) ||\n+         (reg3->is_valid() && reg3->encoding() >= 16);\n+}\n+#endif\n...\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");", "source_url": "https://github.com/openjdk/riscv-port/commit/52382e285fdf853c01605f8e0d7f3f5d34965802", "code_v0_no_empty_lines": "VectorAPI缺少对无符号和饱和向量操作的支持，限制了向量化性能优化。", "code_v1_no_empty_lines": "+#ifndef PRODUCT\n+bool Assembler::needs_evex(XMMRegister reg1, XMMRegister reg2, XMMRegister reg3) {\n+  return (reg1->is_valid() && reg1->encoding() >= 16) ||\n+         (reg2->is_valid() && reg2->encoding() >= 16) ||\n+         (reg3->is_valid() && reg3->encoding() >= 16);\n+}\n+#endif\n...\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");", "target": "+#ifndef PRODUCT\n+bool Assembler::needs_evex(XMMRegister reg1, XMMRegister reg2, XMMRegister reg3) {\n+  return (reg1->is_valid() && reg1->encoding() >= 16) ||\n+         (reg2->is_valid() && reg2->encoding() >= 16) ||\n+         (reg3->is_valid() && reg3->encoding() >= 16);\n+}\n+#endif\n...\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：VectorAPI缺少对无符号和饱和向量操作的支持，限制了向量化性能优化。优化后：扩展x86后端汇编器支持新的无符号和饱和向量操作符，添加EVEX指令集支持（如evmovdqub/w），改进断言条件以支持更广泛的AVX-512指令集变体，并新增VectorMath类和相关测试模板。优化思路：通过硬件向量指令集扩展，提升数值计算密集型操作的并行处理能力，减少循环开销，充分利用现代CPU的SIMD能力。"}
{"id": 642, "source": "riscv-dataset-excel", "optimization_type": "内存初始化优化", "optimization_description": "优化前使用循环逐个初始化ntarjan数组的_control字段为nullptr，存在循环开销。优化后改用memset一次性将整个ntarjan数组（包括所有字段）初始化为0，减少了循环迭代次数，提高了内存初始化效率，同时确保所有字段都被正确初始化。", "original_code": "// No original code extracted from description\n", "optimized_code": "-  // Initialize _control field for fast reference\n-  int i;\n-  for( i= C->unique()-1; i>=0; i-- )\n-    ntarjan[i]._control = nullptr;\n+  // Initialize all fields at once for safety and extra performance.\n+  // Among other things, this initializes _control field for fast reference.\n+  memset(ntarjan, 0, (C->unique() + 1)*sizeof(NTarjan));", "source_url": "https://github.com/openjdk/riscv-port/commit/e659d9da5d6198ad9c85efd6472e138a6a3961c2", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "-  // Initialize _control field for fast reference\n-  int i;\n-  for( i= C->unique()-1; i>=0; i-- )\n-    ntarjan[i]._control = nullptr;\n+  // Initialize all fields at once for safety and extra performance.\n+  // Among other things, this initializes _control field for fast reference.\n+  memset(ntarjan, 0, (C->unique() + 1)*sizeof(NTarjan));", "target": "-  // Initialize _control field for fast reference\n-  int i;\n-  for( i= C->unique()-1; i>=0; i-- )\n-    ntarjan[i]._control = nullptr;\n+  // Initialize all fields at once for safety and extra performance.\n+  // Among other things, this initializes _control field for fast reference.\n+  memset(ntarjan, 0, (C->unique() + 1)*sizeof(NTarjan));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用循环逐个初始化ntarjan数组的_control字段为nullptr，存在循环开销。优化后改用memset一次性将整个ntarjan数组（包括所有字段）初始化为0，减少了循环迭代次数，提高了内存初始化效率，同时确保所有字段都被正确初始化。"}
{"id": 643, "source": "riscv-dataset-excel", "optimization_type": "内存访问优化+代码简化", "optimization_description": "优化前：VectorSet和Node_Array的grow()方法在每次调用时都检查是否需要扩容，即使容量足够也会执行条件判断，增加了函数调用开销和分支预测负担。优化后：引入maybe_grow()内联函数，将条件检查与扩容逻辑分离，在调用方直接内联条件判断，避免不必要的函数调用。优化思路：通过内联小函数减少调用开销，简化控制流，提高热点代码路径的执行效率。", "original_code": "VectorSet和Node_Array的grow()方法在每次调用时都检查是否需要扩容，即使容量足够也会执行条件判断，增加了函数调用开销和分支预测负担。", "optimized_code": "void maybe_grow(uint new_word_capacity) {\n    if (new_word_capacity >= _size) {\n        grow(new_word_capacity);\n    }\n}\n...\nvoid insert(uint elem) {\n    uint32_t word = elem >> word_bits;\n    uint32_t mask = 1U << (elem & bit_mask);\n    maybe_grow(word);\n    _data[word] |= mask;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/a5ad974bec932c63ddc647c9986a513ae32ef663", "code_v0_no_empty_lines": "VectorSet和Node_Array的grow()方法在每次调用时都检查是否需要扩容，即使容量足够也会执行条件判断，增加了函数调用开销和分支预测负担。", "code_v1_no_empty_lines": "void maybe_grow(uint new_word_capacity) {\n    if (new_word_capacity >= _size) {\n        grow(new_word_capacity);\n    }\n}\n...\nvoid insert(uint elem) {\n    uint32_t word = elem >> word_bits;\n    uint32_t mask = 1U << (elem & bit_mask);\n    maybe_grow(word);\n    _data[word] |= mask;\n}", "target": "void maybe_grow(uint new_word_capacity) {\n    if (new_word_capacity >= _size) {\n        grow(new_word_capacity);\n    }\n}\n...\nvoid insert(uint elem) {\n    uint32_t word = elem >> word_bits;\n    uint32_t mask = 1U << (elem & bit_mask);\n    maybe_grow(word);\n    _data[word] |= mask;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：VectorSet和Node_Array的grow()方法在每次调用时都检查是否需要扩容，即使容量足够也会执行条件判断，增加了函数调用开销和分支预测负担。优化后：引入maybe_grow()内联函数，将条件检查与扩容逻辑分离，在调用方直接内联条件判断，避免不必要的函数调用。优化思路：通过内联小函数减少调用开销，简化控制流，提高热点代码路径的执行效率。"}
{"id": 644, "source": "riscv-dataset-excel", "optimization_type": "同步性能优化", "optimization_description": "优化前：在fast_unlock操作中，检查等待线程列表时先加载cxq（竞争队列）再加载EntryList（入口列表），顺序不一致可能导致性能问题。优化后：统一改为先加载EntryList再加载cxq，遵循约定顺序。优化思路：通过统一加载顺序，减少潜在的性能开销和一致性风险，提高同步操作的稳定性和可预测性。", "original_code": "在fast_unlock操作中，检查等待线程列表时先加载cxq（竞争队列）再加载EntryList（入口列表），顺序不一致可能导致性能问题。", "optimized_code": "- movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+ movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n- orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+ orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));", "source_url": "https://github.com/openjdk/riscv-port/commit/eb3669a5869d3066341e63dfb8792bd967663656", "code_v0_no_empty_lines": "在fast_unlock操作中，检查等待线程列表时先加载cxq（竞争队列）再加载EntryList（入口列表），顺序不一致可能导致性能问题。", "code_v1_no_empty_lines": "- movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+ movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n- orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+ orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));", "target": "- movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+ movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n- orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+ orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在fast_unlock操作中，检查等待线程列表时先加载cxq（竞争队列）再加载EntryList（入口列表），顺序不一致可能导致性能问题。优化后：统一改为先加载EntryList再加载cxq，遵循约定顺序。优化思路：通过统一加载顺序，减少潜在的性能开销和一致性风险，提高同步操作的稳定性和可预测性。"}
{"id": 645, "source": "riscv-dataset-excel", "optimization_type": "寄存器优化+指令优化", "optimization_description": "优化前：使用t0寄存器加载pending_exception并判断，然后将跳转地址x10保存到t0的栈槽，最后需要额外的mv指令将t0复制到t1才能跳转。优化后：直接使用t1寄存器加载pending_exception并判断，将跳转地址x10保存到t1的栈槽，最后直接使用t1跳转，消除了冗余的寄存器复制指令。思路：通过统一使用t1寄存器，避免了t0到t1的复制操作，减少了指令数量，提高了代码执行效率。", "original_code": "使用t0寄存器加载pending_exception并判断，然后将跳转地址x10保存到t0的栈槽，最后需要额外的mv指令将t0复制到t1才能跳转。", "optimized_code": "-  __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n-  __ bnez(t0, pending);\n+  __ ld(t1, Address(xthread, Thread::pending_exception_offset()));\n+  __ bnez(t1, pending);\n-  __ sd(x10, Address(sp, reg_saver.reg_offset_in_bytes(t0)));\n+  __ sd(x10, Address(sp, reg_saver.reg_offset_in_bytes(t1)));\n-  __ mv(t1, t0);", "source_url": "https://github.com/openjdk/riscv-port/commit/1e35da8d3341ed1af266e5b59aa90bfcfae6576a", "code_v0_no_empty_lines": "使用t0寄存器加载pending_exception并判断，然后将跳转地址x10保存到t0的栈槽，最后需要额外的mv指令将t0复制到t1才能跳转。", "code_v1_no_empty_lines": "-  __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n-  __ bnez(t0, pending);\n+  __ ld(t1, Address(xthread, Thread::pending_exception_offset()));\n+  __ bnez(t1, pending);\n-  __ sd(x10, Address(sp, reg_saver.reg_offset_in_bytes(t0)));\n+  __ sd(x10, Address(sp, reg_saver.reg_offset_in_bytes(t1)));\n-  __ mv(t1, t0);", "target": "-  __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n-  __ bnez(t0, pending);\n+  __ ld(t1, Address(xthread, Thread::pending_exception_offset()));\n+  __ bnez(t1, pending);\n-  __ sd(x10, Address(sp, reg_saver.reg_offset_in_bytes(t0)));\n+  __ sd(x10, Address(sp, reg_saver.reg_offset_in_bytes(t1)));\n-  __ mv(t1, t0);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用t0寄存器加载pending_exception并判断，然后将跳转地址x10保存到t0的栈槽，最后需要额外的mv指令将t0复制到t1才能跳转。优化后：直接使用t1寄存器加载pending_exception并判断，将跳转地址x10保存到t1的栈槽，最后直接使用t1跳转，消除了冗余的寄存器复制指令。思路：通过统一使用t1寄存器，避免了t0到t1的复制操作，减少了指令数量，提高了代码执行效率。"}
{"id": 646, "source": "riscv-dataset-excel", "optimization_type": "启动性能优化", "optimization_description": "优化前：set_initial()方法直接将初始值添加到_young_only_seq序列中，导致预测器在启动阶段需要处理不必要的数据序列初始化开销。优化后：新增_initial_value成员变量存储初始值，set_initial()仅设置该值而不操作序列；在predict()方法中，当_young_only_seq为空时直接返回_initial_value，避免了对空序列的预测计算。优化思路：延迟序列操作，减少G1垃圾收集器启动时的预测器初始化开销，改善启动性能。", "original_code": "set_initial()方法直接将初始值添加到_young_only_seq序列中，导致预测器在启动阶段需要处理不必要的数据序列初始化开销。", "optimized_code": "--- a/src/hotspot/share/gc/g1/g1AnalyticsSequences.inline.hpp\n+++ b/src/hotspot/share/gc/g1/g1AnalyticsSequences.inline.hpp\n@@ -42,7 +43,7 @@ TruncatedSeq* G1PhaseDependentSeq::seq_raw(bool use_young_only_phase_seq) {\n }\n \n void G1PhaseDependentSeq::set_initial(double value) {\n-  _young_only_seq.add(value);\n+  _initial_value = value;\n }\n \n void G1PhaseDependentSeq::add(double value, bool for_young_only_phase) {\n@@ -51,8 +52,12 @@ void G1PhaseDependentSeq::add(double value, bool for_young_only_phase) {\n \n double G1PhaseDependentSeq::predict(const G1Predictions* predictor, bool use_young_only_phase_seq) const {\n   if (use_young_only_phase_seq || !enough_samples_to_use_mixed_seq()) {\n+    if (_young_only_seq.num() == 0) {\n+      return _initial_value;\n+    }\n     return predictor->predict(&_young_only_seq);\n   } else {\n+    assert(_mixed_seq.num() > 0, \"must not ask this with no samples\");\n     return predictor->predict(&_mixed_seq);\n   }\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/c202a2f7b231152136bd8960c55e43bc96cf1eb9", "code_v0_no_empty_lines": "set_initial()方法直接将初始值添加到_young_only_seq序列中，导致预测器在启动阶段需要处理不必要的数据序列初始化开销。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/gc/g1/g1AnalyticsSequences.inline.hpp\n+++ b/src/hotspot/share/gc/g1/g1AnalyticsSequences.inline.hpp\n@@ -42,7 +43,7 @@ TruncatedSeq* G1PhaseDependentSeq::seq_raw(bool use_young_only_phase_seq) {\n }\n \n void G1PhaseDependentSeq::set_initial(double value) {\n-  _young_only_seq.add(value);\n+  _initial_value = value;\n }\n \n void G1PhaseDependentSeq::add(double value, bool for_young_only_phase) {\n@@ -51,8 +52,12 @@ void G1PhaseDependentSeq::add(double value, bool for_young_only_phase) {\n \n double G1PhaseDependentSeq::predict(const G1Predictions* predictor, bool use_young_only_phase_seq) const {\n   if (use_young_only_phase_seq || !enough_samples_to_use_mixed_seq()) {\n+    if (_young_only_seq.num() == 0) {\n+      return _initial_value;\n+    }\n     return predictor->predict(&_young_only_seq);\n   } else {\n+    assert(_mixed_seq.num() > 0, \"must not ask this with no samples\");\n     return predictor->predict(&_mixed_seq);\n   }\n }", "target": "--- a/src/hotspot/share/gc/g1/g1AnalyticsSequences.inline.hpp\n+++ b/src/hotspot/share/gc/g1/g1AnalyticsSequences.inline.hpp\n@@ -42,7 +43,7 @@ TruncatedSeq* G1PhaseDependentSeq::seq_raw(bool use_young_only_phase_seq) {\n }\n \n void G1PhaseDependentSeq::set_initial(double value) {\n-  _young_only_seq.add(value);\n+  _initial_value = value;\n }\n \n void G1PhaseDependentSeq::add(double value, bool for_young_only_phase) {\n@@ -51,8 +52,12 @@ void G1PhaseDependentSeq::add(double value, bool for_young_only_phase) {\n \n double G1PhaseDependentSeq::predict(const G1Predictions* predictor, bool use_young_only_phase_seq) const {\n   if (use_young_only_phase_seq || !enough_samples_to_use_mixed_seq()) {\n+    if (_young_only_seq.num() == 0) {\n+      return _initial_value;\n+    }\n     return predictor->predict(&_young_only_seq);\n   } else {\n+    assert(_mixed_seq.num() > 0, \"must not ask this with no samples\");\n     return predictor->predict(&_mixed_seq);\n   }\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：set_initial()方法直接将初始值添加到_young_only_seq序列中，导致预测器在启动阶段需要处理不必要的数据序列初始化开销。优化后：新增_initial_value成员变量存储初始值，set_initial()仅设置该值而不操作序列；在predict()方法中，当_young_only_seq为空时直接返回_initial_value，避免了对空序列的预测计算。优化思路：延迟序列操作，减少G1垃圾收集器启动时的预测器初始化开销，改善启动性能。"}
{"id": 647, "source": "riscv-dataset-excel", "optimization_type": "测试代码重构", "optimization_description": "优化前：测试文件包含大量重复注释和过时测试配置，文件体积庞大（约15979行），维护困难。优化后：精简文件结构，移除冗余注释和无效测试配置，添加必要的编译指令，文件体积大幅减小（492行新增，15487行删除）。思路：通过重构测试代码，提高可维护性，减少编译和测试开销，同时保持测试覆盖范围。", "original_code": "测试文件包含大量重复注释和过时测试配置，文件体积庞大（约15979行），维护困难。", "optimized_code": "- 删除了大量注释和测试配置（15487行删除）\n+ 添加了@compile ../../lib/ir_framework/TestFramework.java指令（多行）\n- 移除了sse4-v002-A和sse4-v002-U测试配置", "source_url": "https://github.com/openjdk/riscv-port/commit/e96b4cf0a81914c6a615bb4f62ea3f139a4737f3", "code_v0_no_empty_lines": "测试文件包含大量重复注释和过时测试配置，文件体积庞大（约15979行），维护困难。", "code_v1_no_empty_lines": "- 删除了大量注释和测试配置（15487行删除）\n+ 添加了@compile ../../lib/ir_framework/TestFramework.java指令（多行）\n- 移除了sse4-v002-A和sse4-v002-U测试配置", "target": "- 删除了大量注释和测试配置（15487行删除）\n+ 添加了@compile ../../lib/ir_framework/TestFramework.java指令（多行）\n- 移除了sse4-v002-A和sse4-v002-U测试配置", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：测试文件包含大量重复注释和过时测试配置，文件体积庞大（约15979行），维护困难。优化后：精简文件结构，移除冗余注释和无效测试配置，添加必要的编译指令，文件体积大幅减小（492行新增，15487行删除）。思路：通过重构测试代码，提高可维护性，减少编译和测试开销，同时保持测试覆盖范围。"}
{"id": 648, "source": "riscv-dataset-excel", "optimization_type": "代码重构+指令优化", "optimization_description": "优化前：多个地方使用`la`加载运行时地址到寄存器，再通过`jalr`或`jr`跳转，代码冗余且需要额外寄存器。优化后：统一使用`rt_call`或`j(RuntimeAddress(...))`封装跳转逻辑，简化代码、减少指令数、提高可维护性。思路：通过统一跳转到运行时的处理方式，消除重复代码模式，提升RISC-V后端代码质量。", "original_code": "多个地方使用`la`加载运行时地址到寄存器，再通过`jalr`或`jr`跳转，代码冗余且需要额外寄存器。", "optimized_code": "- __ la(t1, RuntimeAddress(ZBarrierSetRuntime::store_barrier_on_native_oop_field_without_healing_addr()));\n- __ jalr(t1);\n+ __ rt_call(ZBarrierSetRuntime::store_barrier_on_native_oop_field_without_healing_addr());", "source_url": "https://github.com/openjdk/riscv-port/commit/85774b713edf8782f162ac25b61ce99a77e116f4", "code_v0_no_empty_lines": "多个地方使用`la`加载运行时地址到寄存器，再通过`jalr`或`jr`跳转，代码冗余且需要额外寄存器。", "code_v1_no_empty_lines": "- __ la(t1, RuntimeAddress(ZBarrierSetRuntime::store_barrier_on_native_oop_field_without_healing_addr()));\n- __ jalr(t1);\n+ __ rt_call(ZBarrierSetRuntime::store_barrier_on_native_oop_field_without_healing_addr());", "target": "- __ la(t1, RuntimeAddress(ZBarrierSetRuntime::store_barrier_on_native_oop_field_without_healing_addr()));\n- __ jalr(t1);\n+ __ rt_call(ZBarrierSetRuntime::store_barrier_on_native_oop_field_without_healing_addr());", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多个地方使用`la`加载运行时地址到寄存器，再通过`jalr`或`jr`跳转，代码冗余且需要额外寄存器。优化后：统一使用`rt_call`或`j(RuntimeAddress(...))`封装跳转逻辑，简化代码、减少指令数、提高可维护性。思路：通过统一跳转到运行时的处理方式，消除重复代码模式，提升RISC-V后端代码质量。"}
{"id": 649, "source": "riscv-dataset-excel", "optimization_type": "HTTP/2流控制优化", "optimization_description": "优化前：HTTP/2流控制检查不完善，可能导致连接窗口管理不当，未正确处理未消费数据帧的窗口释放，以及连接窗口超限时的错误处理。优化后：1. 修正连接窗口大小计算，确保最小值为INITIAL_CONNECTION_WINDOW_SIZE和streamWindow的最大值；2. 新增releaseUnconsumed()方法，在数据帧被丢弃时正确释放窗口资源；3. 改进连接窗口更新逻辑，使用正确的初始连接窗口大小；4. 增强窗口超限检测，当连接窗口超出时发送FLOW_CONTROL_ERROR并关闭连接。优化思路：完善HTTP/2流控制机制，确保窗口资源正确管理，避免资源泄漏和协议错误。", "original_code": "HTTP/2流控制检查不完善，可能导致连接窗口管理不当，未正确处理未消费数据帧的窗口释放，以及连接窗口超限时的错误处理。", "optimized_code": "1. Http2ClientImpl.java: getConnectionWindowSize方法中minValue计算从Math.max(streamWindow, K*K*32)改为Math.max(INITIAL_CONNECTION_WINDOW_SIZE, streamWindow)\n2. Http2Connection.java: 新增releaseUnconsumed()方法处理未消费数据帧的窗口释放\n3. Http2Connection.java: sendConnectionPreface()中窗口更新计算从DEFAULT_INITIAL_WINDOW_SIZE改为INITIAL_CONNECTION_WINDOW_SIZE\n4. Http2Connection.java: ConnectionWindowUpdateSender新增windowSizeExceeded()方法处理连接窗口超限", "source_url": "https://github.com/openjdk/riscv-port/commit/b0ac633b2d0076d64b463b2a6ce19abf6b12c50f", "code_v0_no_empty_lines": "HTTP/2流控制检查不完善，可能导致连接窗口管理不当，未正确处理未消费数据帧的窗口释放，以及连接窗口超限时的错误处理。", "code_v1_no_empty_lines": "1. Http2ClientImpl.java: getConnectionWindowSize方法中minValue计算从Math.max(streamWindow, K*K*32)改为Math.max(INITIAL_CONNECTION_WINDOW_SIZE, streamWindow)\n2. Http2Connection.java: 新增releaseUnconsumed()方法处理未消费数据帧的窗口释放\n3. Http2Connection.java: sendConnectionPreface()中窗口更新计算从DEFAULT_INITIAL_WINDOW_SIZE改为INITIAL_CONNECTION_WINDOW_SIZE\n4. Http2Connection.java: ConnectionWindowUpdateSender新增windowSizeExceeded()方法处理连接窗口超限", "target": "1. Http2ClientImpl.java: getConnectionWindowSize方法中minValue计算从Math.max(streamWindow, K*K*32)改为Math.max(INITIAL_CONNECTION_WINDOW_SIZE, streamWindow)\n2. Http2Connection.java: 新增releaseUnconsumed()方法处理未消费数据帧的窗口释放\n3. Http2Connection.java: sendConnectionPreface()中窗口更新计算从DEFAULT_INITIAL_WINDOW_SIZE改为INITIAL_CONNECTION_WINDOW_SIZE\n4. Http2Connection.java: ConnectionWindowUpdateSender新增windowSizeExceeded()方法处理连接窗口超限", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：HTTP/2流控制检查不完善，可能导致连接窗口管理不当，未正确处理未消费数据帧的窗口释放，以及连接窗口超限时的错误处理。优化后：1. 修正连接窗口大小计算，确保最小值为INITIAL_CONNECTION_WINDOW_SIZE和streamWindow的最大值；2. 新增releaseUnconsumed()方法，在数据帧被丢弃时正确释放窗口资源；3. 改进连接窗口更新逻辑，使用正确的初始连接窗口大小；4. 增强窗口超限检测，当连接窗口超出时发送FLOW_CONTROL_ERROR并关闭连接。优化思路：完善HTTP/2流控制机制，确保窗口资源正确管理，避免资源泄漏和协议错误。"}
{"id": 650, "source": "riscv-dataset-excel", "optimization_type": "指令优化+微架构优化", "optimization_description": "优化前：当shift为0时，仍然执行逻辑右移指令(lsr)，产生不必要的指令开销。优化后：1) 添加显式条件判断(shift > 0)，避免shift为0时的无效右移操作；2) 当shift为0时，使用mov指令替代lsr指令，利用零延迟移动指令的优势。优化思路：通过消除冗余的移位操作和利用更高效的mov指令，减少指令执行周期，提升内存复制性能。", "original_code": "当shift为0时，仍然执行逻辑右移指令(lsr)，产生不必要的指令开销。", "optimized_code": "- if (shift)  __ lsr(r15, r15, shift);\n+ if (shift > 0) {\n+   __ lsr(r15, r15, shift);\n+ }\n- __ lsr(r15, count, exact_log2(wordSize/granularity));\n+ int shift = exact_log2(wordSize/granularity);\n+ if (shift > 0) {\n+   __ lsr(r15, count, shift);\n+ } else {\n+   __ mov(r15, count);\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/893266c48f26e089d0449d2c161b04430741970c", "code_v0_no_empty_lines": "当shift为0时，仍然执行逻辑右移指令(lsr)，产生不必要的指令开销。", "code_v1_no_empty_lines": "- if (shift)  __ lsr(r15, r15, shift);\n+ if (shift > 0) {\n+   __ lsr(r15, r15, shift);\n+ }\n- __ lsr(r15, count, exact_log2(wordSize/granularity));\n+ int shift = exact_log2(wordSize/granularity);\n+ if (shift > 0) {\n+   __ lsr(r15, count, shift);\n+ } else {\n+   __ mov(r15, count);\n+ }", "target": "- if (shift)  __ lsr(r15, r15, shift);\n+ if (shift > 0) {\n+   __ lsr(r15, r15, shift);\n+ }\n- __ lsr(r15, count, exact_log2(wordSize/granularity));\n+ int shift = exact_log2(wordSize/granularity);\n+ if (shift > 0) {\n+   __ lsr(r15, count, shift);\n+ } else {\n+   __ mov(r15, count);\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当shift为0时，仍然执行逻辑右移指令(lsr)，产生不必要的指令开销。优化后：1) 添加显式条件判断(shift > 0)，避免shift为0时的无效右移操作；2) 当shift为0时，使用mov指令替代lsr指令，利用零延迟移动指令的优势。优化思路：通过消除冗余的移位操作和利用更高效的mov指令，减少指令执行周期，提升内存复制性能。"}
{"id": 651, "source": "riscv-dataset-excel", "optimization_type": "代码重构+内存管理优化", "optimization_description": "优化前：ZPreTouchTask依赖ZPhysicalMemoryManager对象调用pretouch方法进行内存预触，存在不必要的对象依赖和间接调用。优化后：将pretouch逻辑内联到ZPreTouchTask类中，移除对ZPhysicalMemoryManager的依赖，简化了代码结构。优化思路：通过代码重构消除中间层，减少函数调用开销，使预触操作更直接高效，同时清理了不再使用的接口声明。", "original_code": "ZPreTouchTask依赖ZPhysicalMemoryManager对象调用pretouch方法进行内存预触，存在不必要的对象依赖和间接调用。", "optimized_code": "-  ZPreTouchTask(const ZPhysicalMemoryManager* physical, zoffset start, zoffset_end end)\n+  ZPreTouchTask(zoffset start, zoffset_end end)\n-  _physical->pretouch(offset, size);\n+  pretouch(addr, size);\n-  ZPreTouchTask task(&_physical, page->start(), page->end());\n+  ZPreTouchTask task(page->start(), page->end());\n-  void pretouch(zoffset offset, size_t size) const;\n+  // 从ZPhysicalMemoryManager类中完全移除pretouch方法", "source_url": "https://github.com/openjdk/riscv-port/commit/264d7014a11b113d309dde2301ea23d6eba71f57", "code_v0_no_empty_lines": "ZPreTouchTask依赖ZPhysicalMemoryManager对象调用pretouch方法进行内存预触，存在不必要的对象依赖和间接调用。", "code_v1_no_empty_lines": "-  ZPreTouchTask(const ZPhysicalMemoryManager* physical, zoffset start, zoffset_end end)\n+  ZPreTouchTask(zoffset start, zoffset_end end)\n-  _physical->pretouch(offset, size);\n+  pretouch(addr, size);\n-  ZPreTouchTask task(&_physical, page->start(), page->end());\n+  ZPreTouchTask task(page->start(), page->end());\n-  void pretouch(zoffset offset, size_t size) const;\n+  // 从ZPhysicalMemoryManager类中完全移除pretouch方法", "target": "-  ZPreTouchTask(const ZPhysicalMemoryManager* physical, zoffset start, zoffset_end end)\n+  ZPreTouchTask(zoffset start, zoffset_end end)\n-  _physical->pretouch(offset, size);\n+  pretouch(addr, size);\n-  ZPreTouchTask task(&_physical, page->start(), page->end());\n+  ZPreTouchTask task(page->start(), page->end());\n-  void pretouch(zoffset offset, size_t size) const;\n+  // 从ZPhysicalMemoryManager类中完全移除pretouch方法", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ZPreTouchTask依赖ZPhysicalMemoryManager对象调用pretouch方法进行内存预触，存在不必要的对象依赖和间接调用。优化后：将pretouch逻辑内联到ZPreTouchTask类中，移除对ZPhysicalMemoryManager的依赖，简化了代码结构。优化思路：通过代码重构消除中间层，减少函数调用开销，使预触操作更直接高效，同时清理了不再使用的接口声明。"}
{"id": 652, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：G1OldGenAllocationTracker在记录老年代分配时，只统计了疏散分配（evacuation allocations），忽略了直接分配（direct allocations），导致IHOP（Initiating Heap Occupancy Percentage）控制不准确。优化后：通过将_old_evac_stats.allocated()和_old_evac_stats.direct_allocated()相加，完整统计老年代的总分配量，确保IHOP控制能更精确地触发垃圾回收，避免过早或过晚触发GC。", "original_code": "G1OldGenAllocationTracker在记录老年代分配时，只统计了疏散分配（evacuation allocations），忽略了直接分配（direct allocations），导致IHOP（Initiating Heap Occupancy Percentage）控制不准确。", "optimized_code": "-    add_allocated_bytes_since_last_gc(_old_evac_stats.allocated() * HeapWordSize);\n+    add_allocated_bytes_since_last_gc(total_old_allocated * HeapWordSize);", "source_url": "https://github.com/openjdk/riscv-port/commit/f70ecc27a787a96795452c11262fe427ad03f96a", "code_v0_no_empty_lines": "G1OldGenAllocationTracker在记录老年代分配时，只统计了疏散分配（evacuation allocations），忽略了直接分配（direct allocations），导致IHOP（Initiating Heap Occupancy Percentage）控制不准确。", "code_v1_no_empty_lines": "-    add_allocated_bytes_since_last_gc(_old_evac_stats.allocated() * HeapWordSize);\n+    add_allocated_bytes_since_last_gc(total_old_allocated * HeapWordSize);", "target": "-    add_allocated_bytes_since_last_gc(_old_evac_stats.allocated() * HeapWordSize);\n+    add_allocated_bytes_since_last_gc(total_old_allocated * HeapWordSize);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：G1OldGenAllocationTracker在记录老年代分配时，只统计了疏散分配（evacuation allocations），忽略了直接分配（direct allocations），导致IHOP（Initiating Heap Occupancy Percentage）控制不准确。优化后：通过将_old_evac_stats.allocated()和_old_evac_stats.direct_allocated()相加，完整统计老年代的总分配量，确保IHOP控制能更精确地触发垃圾回收，避免过早或过晚触发GC。"}
{"id": 653, "source": "riscv-dataset-excel", "optimization_type": "循环优化+断言修复", "optimization_description": "优化前：在循环优化中，当节点从预循环下沉到主循环时，如果该节点作为被范围检查消除（RCE）消除的检查的输入，会导致断言失败“node pinned on loop exit test?”，因为节点被固定在预循环退出测试之上。优化后：修改了ctrl_of_use_out_of_loop函数中的条件检查，使用支配关系（is_dominator）来判断节点是否被固定在预循环退出测试之上，从而避免断言失败。思路：通过更精确的支配关系检查来确保节点在循环优化中的正确放置，防止因RCE导致的断言失败，提升编译器的稳定性和正确性。", "original_code": "在循环优化中，当节点从预循环下沉到主循环时，如果该节点作为被范围检查消除（RCE）消除的检查的输入，会导致断言失败“node pinned on loop exit test?”，因为节点被固定在预循环退出测试之上。", "optimized_code": "-  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop() &&\n-      u_loop->_head->is_CountedLoop() && u_loop->_head->as_CountedLoop()->is_main_loop() &&\n-      n_loop->_next == get_loop(u_loop->_head->as_CountedLoop()->skip_strip_mined())) {\n-    return false;\n+  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop()) {\n+    CountedLoopNode* pre_loop = n_loop->_head->as_CountedLoop();\n+    if (is_dominator(pre_loop->loopexit(), ctrl)) {\n+      return false;\n+    }\n   }", "source_url": "https://github.com/openjdk/riscv-port/commit/004aaea76db091569aa88eeb6b08db3408f288cd", "code_v0_no_empty_lines": "在循环优化中，当节点从预循环下沉到主循环时，如果该节点作为被范围检查消除（RCE）消除的检查的输入，会导致断言失败“node pinned on loop exit test?”，因为节点被固定在预循环退出测试之上。", "code_v1_no_empty_lines": "-  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop() &&\n-      u_loop->_head->is_CountedLoop() && u_loop->_head->as_CountedLoop()->is_main_loop() &&\n-      n_loop->_next == get_loop(u_loop->_head->as_CountedLoop()->skip_strip_mined())) {\n-    return false;\n+  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop()) {\n+    CountedLoopNode* pre_loop = n_loop->_head->as_CountedLoop();\n+    if (is_dominator(pre_loop->loopexit(), ctrl)) {\n+      return false;\n+    }\n   }", "target": "-  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop() &&\n-      u_loop->_head->is_CountedLoop() && u_loop->_head->as_CountedLoop()->is_main_loop() &&\n-      n_loop->_next == get_loop(u_loop->_head->as_CountedLoop()->skip_strip_mined())) {\n-    return false;\n+  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop()) {\n+    CountedLoopNode* pre_loop = n_loop->_head->as_CountedLoop();\n+    if (is_dominator(pre_loop->loopexit(), ctrl)) {\n+      return false;\n+    }\n   }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在循环优化中，当节点从预循环下沉到主循环时，如果该节点作为被范围检查消除（RCE）消除的检查的输入，会导致断言失败“node pinned on loop exit test?”，因为节点被固定在预循环退出测试之上。优化后：修改了ctrl_of_use_out_of_loop函数中的条件检查，使用支配关系（is_dominator）来判断节点是否被固定在预循环退出测试之上，从而避免断言失败。思路：通过更精确的支配关系检查来确保节点在循环优化中的正确放置，防止因RCE导致的断言失败，提升编译器的稳定性和正确性。"}
{"id": 654, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+性能优化", "optimization_description": "优化前：1. 拷贝构造函数先初始化空_segments，再通过add_segments()逐个添加元素，导致多次内存分配和复制操作。2. 赋值运算符未检查自赋值，直接清空并重新分配内存，存在潜在问题。优化后：1. 拷贝构造函数通过_segments(pmem.nsegments())预分配正确容量，使用appendAll()批量复制，减少内存分配次数。2. 赋值运算符添加自赋值检查，避免无效操作；使用reserve()预分配内存，提高复制效率。优化思路：通过预分配内存和批量操作减少动态内存分配开销，提升ZGC物理内存管理的性能。", "original_code": "1. 拷贝构造函数先初始化空_segments，再通过add_segments()逐个添加元素，导致多次内存分配和复制操作。2. 赋值运算符未检查自赋值，直接清空并重新分配内存，存在潜在问题。", "optimized_code": "ZPhysicalMemory::ZPhysicalMemory(const ZPhysicalMemory& pmem)\n  : _segments(pmem.nsegments()) {\n  _segments.appendAll(&pmem._segments);\n}\n\nconst ZPhysicalMemory& ZPhysicalMemory::operator=(const ZPhysicalMemory& pmem) {\n  // Check for self-assignment\n  if (this == &pmem) {\n    return *this;\n  }\n\n  // Free and copy segments\n  _segments.clear_and_deallocate();\n  _segments.reserve(pmem.nsegments());\n  _segments.appendAll(&pmem._segments);\n\n  return *this;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/1f3574855e79221739d8800235583b7c47ebae97", "code_v0_no_empty_lines": "1. 拷贝构造函数先初始化空_segments，再通过add_segments()逐个添加元素，导致多次内存分配和复制操作。2. 赋值运算符未检查自赋值，直接清空并重新分配内存，存在潜在问题。", "code_v1_no_empty_lines": "ZPhysicalMemory::ZPhysicalMemory(const ZPhysicalMemory& pmem)\n  : _segments(pmem.nsegments()) {\n  _segments.appendAll(&pmem._segments);\n}\n\nconst ZPhysicalMemory& ZPhysicalMemory::operator=(const ZPhysicalMemory& pmem) {\n  // Check for self-assignment\n  if (this == &pmem) {\n    return *this;\n  }\n\n  // Free and copy segments\n  _segments.clear_and_deallocate();\n  _segments.reserve(pmem.nsegments());\n  _segments.appendAll(&pmem._segments);\n\n  return *this;\n}", "target": "ZPhysicalMemory::ZPhysicalMemory(const ZPhysicalMemory& pmem)\n  : _segments(pmem.nsegments()) {\n  _segments.appendAll(&pmem._segments);\n}\n\nconst ZPhysicalMemory& ZPhysicalMemory::operator=(const ZPhysicalMemory& pmem) {\n  // Check for self-assignment\n  if (this == &pmem) {\n    return *this;\n  }\n\n  // Free and copy segments\n  _segments.clear_and_deallocate();\n  _segments.reserve(pmem.nsegments());\n  _segments.appendAll(&pmem._segments);\n\n  return *this;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 拷贝构造函数先初始化空_segments，再通过add_segments()逐个添加元素，导致多次内存分配和复制操作。2. 赋值运算符未检查自赋值，直接清空并重新分配内存，存在潜在问题。优化后：1. 拷贝构造函数通过_segments(pmem.nsegments())预分配正确容量，使用appendAll()批量复制，减少内存分配次数。2. 赋值运算符添加自赋值检查，避免无效操作；使用reserve()预分配内存，提高复制效率。优化思路：通过预分配内存和批量操作减少动态内存分配开销，提升ZGC物理内存管理的性能。"}
{"id": 655, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+加密算法加速", "optimization_description": "优化前：SHA-512算法使用纯软件实现，性能受限于通用指令执行效率。优化后：利用x86处理器的SHA-NI指令集（sha512msg1、sha512msg2、sha512rnds2等专用指令）实现硬件加速。优化思路：通过添加SHA-512专用指令的汇编器支持，在支持SHA-NI的CPU上直接调用硬件指令，大幅提升SHA-512哈希计算性能，减少指令数量和时钟周期消耗。", "original_code": "SHA-512算法使用纯软件实现，性能受限于通用指令执行效率。", "optimized_code": "void Assembler::sha512msg1(XMMRegister dst, XMMRegister src) {\n  assert(VM_Version::supports_sha512() && VM_Version::supports_avx(), \"\");\n  InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);\n  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n  emit_int16((unsigned char)0xCC, (0xC0 | encode));\n}\n\nvoid Assembler::sha512msg2(XMMRegister dst, XMMRegister src) {\n  assert(VM_Version::supports_sha512() && VM_Version::supports_avx(), \"\");\n  InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);\n  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n  emit_int16((unsigned char)0xCD, (0xC0 | encode));\n}\n\nvoid Assembler::sha512rnds2(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n  assert(VM_Version::supports_sha512() && VM_Version::supports_avx(), \"\");\n  InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);\n  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n  emit_int16((unsigned char)0xCB, (0xC0 | encode));\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/18bcbf7941f7567449983b3f317401efb3e34d39", "code_v0_no_empty_lines": "SHA-512算法使用纯软件实现，性能受限于通用指令执行效率。", "code_v1_no_empty_lines": "void Assembler::sha512msg1(XMMRegister dst, XMMRegister src) {\n  assert(VM_Version::supports_sha512() && VM_Version::supports_avx(), \"\");\n  InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);\n  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n  emit_int16((unsigned char)0xCC, (0xC0 | encode));\n}\n\nvoid Assembler::sha512msg2(XMMRegister dst, XMMRegister src) {\n  assert(VM_Version::supports_sha512() && VM_Version::supports_avx(), \"\");\n  InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);\n  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n  emit_int16((unsigned char)0xCD, (0xC0 | encode));\n}\n\nvoid Assembler::sha512rnds2(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n  assert(VM_Version::supports_sha512() && VM_Version::supports_avx(), \"\");\n  InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);\n  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n  emit_int16((unsigned char)0xCB, (0xC0 | encode));\n}", "target": "void Assembler::sha512msg1(XMMRegister dst, XMMRegister src) {\n  assert(VM_Version::supports_sha512() && VM_Version::supports_avx(), \"\");\n  InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);\n  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n  emit_int16((unsigned char)0xCC, (0xC0 | encode));\n}\n\nvoid Assembler::sha512msg2(XMMRegister dst, XMMRegister src) {\n  assert(VM_Version::supports_sha512() && VM_Version::supports_avx(), \"\");\n  InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);\n  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n  emit_int16((unsigned char)0xCD, (0xC0 | encode));\n}\n\nvoid Assembler::sha512rnds2(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n  assert(VM_Version::supports_sha512() && VM_Version::supports_avx(), \"\");\n  InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);\n  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n  emit_int16((unsigned char)0xCB, (0xC0 | encode));\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SHA-512算法使用纯软件实现，性能受限于通用指令执行效率。优化后：利用x86处理器的SHA-NI指令集（sha512msg1、sha512msg2、sha512rnds2等专用指令）实现硬件加速。优化思路：通过添加SHA-512专用指令的汇编器支持，在支持SHA-NI的CPU上直接调用硬件指令，大幅提升SHA-512哈希计算性能，减少指令数量和时钟周期消耗。"}
{"id": 656, "source": "riscv-dataset-excel", "optimization_type": "循环优化+类型转换优化", "optimization_description": "优化前：C2编译器在处理int计数循环中的long类型并行归纳变量时，由于类型不匹配，无法进行并行IV优化，导致循环无法被消除。优化后：扩展replace_parallel_iv函数支持long类型并行IV，通过添加类型转换节点（insert_convert_node_if_needed）和通用算术节点创建（MulNode::make等），使int循环中的long并行IV能够被正确优化。优化思路：检测并行IV的类型（int或long），在需要时插入类型转换，使用通用算术操作处理不同类型，从而消除类型不匹配导致的优化障碍，使循环能够被完全消除。", "original_code": "C2编译器在处理int计数循环中的long类型并行归纳变量时，由于类型不匹配，无法进行并行IV优化，导致循环无法被消除。", "optimized_code": "- int stride_con = cl->stride_con();\n+ jlong stride_con = cl->stride_con();\n- if (incr2->Opcode() != Op_AddI ||\n+ if ((incr2->Opcode() != Op_AddI && incr2->Opcode() != Op_AddL) ||\n- int stride_con2 = incr2->in(2)->get_int();\n+ jlong stride_con2 = incr2->in(2)->get_integer_as_long(stride_con2_bt);\n- int ratio_con = stride_con2/stride_con;\n+ jlong ratio_con = stride_con2 / stride_con;\n- Node* ratio = _igvn.intcon(ratio_con);\n+ Node* ratio = _igvn.integercon(ratio_con, stride_con2_bt);\n- Node* ratio_init = new MulINode(init, ratio);\n+ Node* ratio_init = MulNode::make(init_converted, ratio, stride_con2_bt);", "source_url": "https://github.com/openjdk/riscv-port/commit/80ec552248470dda2d0d003be9315e9e39eb5276", "code_v0_no_empty_lines": "C2编译器在处理int计数循环中的long类型并行归纳变量时，由于类型不匹配，无法进行并行IV优化，导致循环无法被消除。", "code_v1_no_empty_lines": "- int stride_con = cl->stride_con();\n+ jlong stride_con = cl->stride_con();\n- if (incr2->Opcode() != Op_AddI ||\n+ if ((incr2->Opcode() != Op_AddI && incr2->Opcode() != Op_AddL) ||\n- int stride_con2 = incr2->in(2)->get_int();\n+ jlong stride_con2 = incr2->in(2)->get_integer_as_long(stride_con2_bt);\n- int ratio_con = stride_con2/stride_con;\n+ jlong ratio_con = stride_con2 / stride_con;\n- Node* ratio = _igvn.intcon(ratio_con);\n+ Node* ratio = _igvn.integercon(ratio_con, stride_con2_bt);\n- Node* ratio_init = new MulINode(init, ratio);\n+ Node* ratio_init = MulNode::make(init_converted, ratio, stride_con2_bt);", "target": "- int stride_con = cl->stride_con();\n+ jlong stride_con = cl->stride_con();\n- if (incr2->Opcode() != Op_AddI ||\n+ if ((incr2->Opcode() != Op_AddI && incr2->Opcode() != Op_AddL) ||\n- int stride_con2 = incr2->in(2)->get_int();\n+ jlong stride_con2 = incr2->in(2)->get_integer_as_long(stride_con2_bt);\n- int ratio_con = stride_con2/stride_con;\n+ jlong ratio_con = stride_con2 / stride_con;\n- Node* ratio = _igvn.intcon(ratio_con);\n+ Node* ratio = _igvn.integercon(ratio_con, stride_con2_bt);\n- Node* ratio_init = new MulINode(init, ratio);\n+ Node* ratio_init = MulNode::make(init_converted, ratio, stride_con2_bt);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器在处理int计数循环中的long类型并行归纳变量时，由于类型不匹配，无法进行并行IV优化，导致循环无法被消除。优化后：扩展replace_parallel_iv函数支持long类型并行IV，通过添加类型转换节点（insert_convert_node_if_needed）和通用算术节点创建（MulNode::make等），使int循环中的long并行IV能够被正确优化。优化思路：检测并行IV的类型（int或long），在需要时插入类型转换，使用通用算术操作处理不同类型，从而消除类型不匹配导致的优化障碍，使循环能够被完全消除。"}
{"id": 657, "source": "riscv-dataset-excel", "optimization_type": "算法优化+性能优化", "optimization_description": "优化前：stripTrailingZeros()方法通过循环除以10来移除尾随零，每次除法都需要完整的BigInteger除法操作，时间复杂度较高。优化后：1. 引入预计算的5的幂次表（FIVE_TO_2_TO）和log5(2)近似值，快速估算可移除的5的幂次数量。2. 使用二分法策略，先通过大幂次（5^(2^i)）快速移除大量因子，再逐步细化。3. 利用整数的二进制特性（最低设置位）快速确定可移除的2的幂次。优化思路：将O(n)的线性除法操作优化为O(log n)的二分查找，显著减少大数除法次数，特别对大数值的性能提升明显。", "original_code": "stripTrailingZeros()方法通过循环除以10来移除尾随零，每次除法都需要完整的BigInteger除法操作，时间复杂度较高。", "optimized_code": "public BigDecimal stripTrailingZeros() {\n-        if (intCompact == 0 || (intVal != null && intVal.signum() == 0)) {\n-            return BigDecimal.ZERO;\n-        } else if (intCompact != INFLATED) {\n-            return createAndStripZerosToMatchScale(intCompact, scale, Long.MIN_VALUE);\n-        } else {\n-            return createAndStripZerosToMatchScale(intVal, scale, Long.MIN_VALUE);\n-        }\n+        return intCompact == 0 || (intVal != null && intVal.signum() == 0)\n+                ? BigDecimal.ZERO\n+                : stripZerosToMatchScale(intVal, intCompact, scale, Long.MIN_VALUE);\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/27ef6c9df47326508ee9b2b29f2ff4cec6e38377", "code_v0_no_empty_lines": "stripTrailingZeros()方法通过循环除以10来移除尾随零，每次除法都需要完整的BigInteger除法操作，时间复杂度较高。", "code_v1_no_empty_lines": "public BigDecimal stripTrailingZeros() {\n-        if (intCompact == 0 || (intVal != null && intVal.signum() == 0)) {\n-            return BigDecimal.ZERO;\n-        } else if (intCompact != INFLATED) {\n-            return createAndStripZerosToMatchScale(intCompact, scale, Long.MIN_VALUE);\n-        } else {\n-            return createAndStripZerosToMatchScale(intVal, scale, Long.MIN_VALUE);\n-        }\n+        return intCompact == 0 || (intVal != null && intVal.signum() == 0)\n+                ? BigDecimal.ZERO\n+                : stripZerosToMatchScale(intVal, intCompact, scale, Long.MIN_VALUE);\n     }", "target": "public BigDecimal stripTrailingZeros() {\n-        if (intCompact == 0 || (intVal != null && intVal.signum() == 0)) {\n-            return BigDecimal.ZERO;\n-        } else if (intCompact != INFLATED) {\n-            return createAndStripZerosToMatchScale(intCompact, scale, Long.MIN_VALUE);\n-        } else {\n-            return createAndStripZerosToMatchScale(intVal, scale, Long.MIN_VALUE);\n-        }\n+        return intCompact == 0 || (intVal != null && intVal.signum() == 0)\n+                ? BigDecimal.ZERO\n+                : stripZerosToMatchScale(intVal, intCompact, scale, Long.MIN_VALUE);\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：stripTrailingZeros()方法通过循环除以10来移除尾随零，每次除法都需要完整的BigInteger除法操作，时间复杂度较高。优化后：1. 引入预计算的5的幂次表（FIVE_TO_2_TO）和log5(2)近似值，快速估算可移除的5的幂次数量。2. 使用二分法策略，先通过大幂次（5^(2^i)）快速移除大量因子，再逐步细化。3. 利用整数的二进制特性（最低设置位）快速确定可移除的2的幂次。优化思路：将O(n)的线性除法操作优化为O(log n)的二分查找，显著减少大数除法次数，特别对大数值的性能提升明显。"}
{"id": 658, "source": "riscv-dataset-excel", "optimization_type": "分支预测优化+寄存器分配优化", "optimization_description": "优化前：在RISC-V架构中，使用t0寄存器（x5）作为跳转目标寄存器，但t0在某些情况下可能被用作临时寄存器，导致分支预测器可能错误预测返回地址。优化后：将跳转目标寄存器从t0改为t1（x6），避免使用x5寄存器进行跳转调用，确保分支预测器能正确预测返回地址。优化思路：RISC-V架构中x5（t0）寄存器在某些上下文中可能被用作临时寄存器，而分支预测器依赖于链接寄存器（通常是x1/ra）进行返回地址预测，使用x5作为跳转目标可能导致预测失败，改为使用t1（x6）可避免此问题。", "original_code": "在RISC-V架构中，使用t0寄存器（x5）作为跳转目标寄存器，但t0在某些情况下可能被用作临时寄存器，导致分支预测器可能错误预测返回地址。", "optimized_code": "- __ mv(t0, runtime_path);\n+ __ mv(t1, runtime_path);\n- __ jalr(t0);\n+ __ jalr(t1);", "source_url": "https://github.com/openjdk/riscv-port/commit/66ddaaa3591851cc420ec9e0ffe460c78a9a51f5", "code_v0_no_empty_lines": "在RISC-V架构中，使用t0寄存器（x5）作为跳转目标寄存器，但t0在某些情况下可能被用作临时寄存器，导致分支预测器可能错误预测返回地址。", "code_v1_no_empty_lines": "- __ mv(t0, runtime_path);\n+ __ mv(t1, runtime_path);\n- __ jalr(t0);\n+ __ jalr(t1);", "target": "- __ mv(t0, runtime_path);\n+ __ mv(t1, runtime_path);\n- __ jalr(t0);\n+ __ jalr(t1);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在RISC-V架构中，使用t0寄存器（x5）作为跳转目标寄存器，但t0在某些情况下可能被用作临时寄存器，导致分支预测器可能错误预测返回地址。优化后：将跳转目标寄存器从t0改为t1（x6），避免使用x5寄存器进行跳转调用，确保分支预测器能正确预测返回地址。优化思路：RISC-V架构中x5（t0）寄存器在某些上下文中可能被用作临时寄存器，而分支预测器依赖于链接寄存器（通常是x1/ra）进行返回地址预测，使用x5作为跳转目标可能导致预测失败，改为使用t1（x6）可避免此问题。"}
{"id": 659, "source": "riscv-dataset-excel", "optimization_type": "寄存器分配优化", "optimization_description": "优化前：多个调用指令（CallDynamicJavaDirect、CallRuntimeDirect、CallLeafDirect等）在effect声明中包含了KILL cr（条件标志寄存器），这会强制编译器在调用前后保存和恢复标志寄存器状态，增加了不必要的开销。优化后：移除了所有相关调用指令中的rFlagsReg cr参数和KILL cr声明，允许编译器更灵活地管理标志寄存器，减少寄存器保存/恢复操作。优化思路：清理不必要的标志寄存器kill声明，让编译器根据实际使用情况优化寄存器分配，提高代码生成效率。", "original_code": "多个调用指令（CallDynamicJavaDirect、CallRuntimeDirect、CallLeafDirect等）在effect声明中包含了KILL cr（条件标志寄存器），这会强制编译器在调用前后保存和恢复标志寄存器状态，增加了不必要的开销。", "optimized_code": "-instruct CallDynamicJavaDirect(method meth, rFlagsReg cr)\n+instruct CallDynamicJavaDirect(method meth)\n   match(CallDynamicJava);\n \n-  effect(USE meth, KILL cr);\n+  effect(USE meth);", "source_url": "https://github.com/openjdk/riscv-port/commit/76ae072a1fec5f2af4ac4c633bc67a0c4c756a90", "code_v0_no_empty_lines": "多个调用指令（CallDynamicJavaDirect、CallRuntimeDirect、CallLeafDirect等）在effect声明中包含了KILL cr（条件标志寄存器），这会强制编译器在调用前后保存和恢复标志寄存器状态，增加了不必要的开销。", "code_v1_no_empty_lines": "-instruct CallDynamicJavaDirect(method meth, rFlagsReg cr)\n+instruct CallDynamicJavaDirect(method meth)\n   match(CallDynamicJava);\n \n-  effect(USE meth, KILL cr);\n+  effect(USE meth);", "target": "-instruct CallDynamicJavaDirect(method meth, rFlagsReg cr)\n+instruct CallDynamicJavaDirect(method meth)\n   match(CallDynamicJava);\n \n-  effect(USE meth, KILL cr);\n+  effect(USE meth);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多个调用指令（CallDynamicJavaDirect、CallRuntimeDirect、CallLeafDirect等）在effect声明中包含了KILL cr（条件标志寄存器），这会强制编译器在调用前后保存和恢复标志寄存器状态，增加了不必要的开销。优化后：移除了所有相关调用指令中的rFlagsReg cr参数和KILL cr声明，允许编译器更灵活地管理标志寄存器，减少寄存器保存/恢复操作。优化思路：清理不必要的标志寄存器kill声明，让编译器根据实际使用情况优化寄存器分配，提高代码生成效率。"}
{"id": 661, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（C2范围检查消除）", "optimization_description": "优化前：在范围检查消除过程中，当无法消除范围检查时，new_limit_ctrl变量会过早更新，导致后续节点注册时使用错误的控制节点，触发断言失败。优化后：引入临时变量next_limit_ctrl存储dominated_node结果，仅在确认范围检查可以被消除且循环限制已更新后，才将next_limit_ctrl赋值给new_limit_ctrl。优化思路：延迟控制节点的更新，确保节点注册与范围检查消除状态的一致性，修复断言失败问题。", "original_code": "在范围检查消除过程中，当无法消除范围检查时，new_limit_ctrl变量会过早更新，导致后续节点注册时使用错误的控制节点，触发断言失败。", "optimized_code": "-      new_limit_ctrl = dominated_node(new_limit_ctrl, offset_ctrl, limit_ctrl);\n+      Node* next_limit_ctrl = dominated_node(new_limit_ctrl, offset_ctrl, limit_ctrl);\n...\n+      // Only update variable tracking control for new nodes if it's indeed a range check that can be eliminated (and\n+      // limits are updated)\n+      new_limit_ctrl = next_limit_ctrl;", "source_url": "https://github.com/openjdk/riscv-port/commit/8f2b23bb53e81e3f9d8d84720719d129aea82a78", "code_v0_no_empty_lines": "在范围检查消除过程中，当无法消除范围检查时，new_limit_ctrl变量会过早更新，导致后续节点注册时使用错误的控制节点，触发断言失败。", "code_v1_no_empty_lines": "-      new_limit_ctrl = dominated_node(new_limit_ctrl, offset_ctrl, limit_ctrl);\n+      Node* next_limit_ctrl = dominated_node(new_limit_ctrl, offset_ctrl, limit_ctrl);\n...\n+      // Only update variable tracking control for new nodes if it's indeed a range check that can be eliminated (and\n+      // limits are updated)\n+      new_limit_ctrl = next_limit_ctrl;", "target": "-      new_limit_ctrl = dominated_node(new_limit_ctrl, offset_ctrl, limit_ctrl);\n+      Node* next_limit_ctrl = dominated_node(new_limit_ctrl, offset_ctrl, limit_ctrl);\n...\n+      // Only update variable tracking control for new nodes if it's indeed a range check that can be eliminated (and\n+      // limits are updated)\n+      new_limit_ctrl = next_limit_ctrl;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在范围检查消除过程中，当无法消除范围检查时，new_limit_ctrl变量会过早更新，导致后续节点注册时使用错误的控制节点，触发断言失败。优化后：引入临时变量next_limit_ctrl存储dominated_node结果，仅在确认范围检查可以被消除且循环限制已更新后，才将next_limit_ctrl赋值给new_limit_ctrl。优化思路：延迟控制节点的更新，确保节点注册与范围检查消除状态的一致性，修复断言失败问题。"}
{"id": 662, "source": "riscv-dataset-excel", "optimization_type": "编译器断言优化+空指针检查优化", "optimization_description": "优化前：C2编译器在处理包含两个UCT（Uncommon Trap）的模板断言谓词时，可能将失败路径投影误判为成功路径，导致断言失败。优化后：1. 重构断言谓词检测逻辑，通过may_be_assertion_predicate_if()函数统一检查IfTrue投影；2. 在PredicateIterator中正确处理UseLoopPredicate和UseProfiledLoopPredicate标志；3. 在skip_assertion_predicates_with_halt()中添加空指针检查。优化思路：通过更精确的谓词识别和边界条件处理，避免无效节点访问，修复编译器断言失败问题。", "original_code": "C2编译器在处理包含两个UCT（Uncommon Trap）的模板断言谓词时，可能将失败路径投影误判为成功路径，导致断言失败。", "optimized_code": "1. predicates.cpp: - if (maybe_success_proj == nullptr || !maybe_success_proj->is_IfProj() || !maybe_success_proj->in(0)->is_If()) {\n+ if (!may_be_assertion_predicate_if(maybe_success_proj)) {\n2. predicates.hpp: - return loop_predicate_iterator.for_each(predicate_visitor);\n+ return current;\n3. loopnode.cpp: + if (ctrl == nullptr) {\n+   // Dying loop.\n+   return nullptr;\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/d61f56a3001f2f574f49c36f5bb40e96bb6b827d", "code_v0_no_empty_lines": "C2编译器在处理包含两个UCT（Uncommon Trap）的模板断言谓词时，可能将失败路径投影误判为成功路径，导致断言失败。", "code_v1_no_empty_lines": "1. predicates.cpp: - if (maybe_success_proj == nullptr || !maybe_success_proj->is_IfProj() || !maybe_success_proj->in(0)->is_If()) {\n+ if (!may_be_assertion_predicate_if(maybe_success_proj)) {\n2. predicates.hpp: - return loop_predicate_iterator.for_each(predicate_visitor);\n+ return current;\n3. loopnode.cpp: + if (ctrl == nullptr) {\n+   // Dying loop.\n+   return nullptr;\n+ }", "target": "1. predicates.cpp: - if (maybe_success_proj == nullptr || !maybe_success_proj->is_IfProj() || !maybe_success_proj->in(0)->is_If()) {\n+ if (!may_be_assertion_predicate_if(maybe_success_proj)) {\n2. predicates.hpp: - return loop_predicate_iterator.for_each(predicate_visitor);\n+ return current;\n3. loopnode.cpp: + if (ctrl == nullptr) {\n+   // Dying loop.\n+   return nullptr;\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器在处理包含两个UCT（Uncommon Trap）的模板断言谓词时，可能将失败路径投影误判为成功路径，导致断言失败。优化后：1. 重构断言谓词检测逻辑，通过may_be_assertion_predicate_if()函数统一检查IfTrue投影；2. 在PredicateIterator中正确处理UseLoopPredicate和UseProfiledLoopPredicate标志；3. 在skip_assertion_predicates_with_halt()中添加空指针检查。优化思路：通过更精确的谓词识别和边界条件处理，避免无效节点访问，修复编译器断言失败问题。"}
{"id": 663, "source": "riscv-dataset-excel", "optimization_type": "代码简化+内存优化", "optimization_description": "优化前：存在一个专门的ShenandoahUpdateRefsClosure类用于更新引用，但该闭包功能与现有闭包重复。优化后：移除了ShenandoahUpdateRefsClosure类及其相关实现，统一使用现有的ShenandoahNonConcUpdateRefsClosure。优化思路：消除冗余代码，减少内存占用和编译开销，简化代码结构，同时保持相同的功能。在需要更新引用的地方（如线程握手、根处理、弱根清理等）直接使用现有的非并发更新引用闭包。", "original_code": "存在一个专门的ShenandoahUpdateRefsClosure类用于更新引用，但该闭包功能与现有闭包重复。", "optimized_code": "-class ShenandoahUpdateRefsClosure: public ShenandoahOopClosureBase {\n-private:\n-  ShenandoahHeap* _heap;\n-public:\n-  inline ShenandoahUpdateRefsClosure();\n-  inline void do_oop(oop* p);\n-  inline void do_oop(narrowOop* p);\n-private:\n-  template <class T>\n-  inline void do_oop_work(T* p);\n-};\n\n+// This closure runs when thread is stopped for handshake, which means\n+// we can use non-concurrent closure here, as long as it only updates\n+// locations modified by the thread itself, i.e. stack locations.\n+  ShenandoahNonConcUpdateRefsClosure _cl;", "source_url": "https://github.com/openjdk/riscv-port/commit/b993227e2f3233c7b34a77eebbeeb1c51d2b7cfe", "code_v0_no_empty_lines": "存在一个专门的ShenandoahUpdateRefsClosure类用于更新引用，但该闭包功能与现有闭包重复。", "code_v1_no_empty_lines": "-class ShenandoahUpdateRefsClosure: public ShenandoahOopClosureBase {\n-private:\n-  ShenandoahHeap* _heap;\n-public:\n-  inline ShenandoahUpdateRefsClosure();\n-  inline void do_oop(oop* p);\n-  inline void do_oop(narrowOop* p);\n-private:\n-  template <class T>\n-  inline void do_oop_work(T* p);\n-};\n\n+// This closure runs when thread is stopped for handshake, which means\n+// we can use non-concurrent closure here, as long as it only updates\n+// locations modified by the thread itself, i.e. stack locations.\n+  ShenandoahNonConcUpdateRefsClosure _cl;", "target": "-class ShenandoahUpdateRefsClosure: public ShenandoahOopClosureBase {\n-private:\n-  ShenandoahHeap* _heap;\n-public:\n-  inline ShenandoahUpdateRefsClosure();\n-  inline void do_oop(oop* p);\n-  inline void do_oop(narrowOop* p);\n-private:\n-  template <class T>\n-  inline void do_oop_work(T* p);\n-};\n\n+// This closure runs when thread is stopped for handshake, which means\n+// we can use non-concurrent closure here, as long as it only updates\n+// locations modified by the thread itself, i.e. stack locations.\n+  ShenandoahNonConcUpdateRefsClosure _cl;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：存在一个专门的ShenandoahUpdateRefsClosure类用于更新引用，但该闭包功能与现有闭包重复。优化后：移除了ShenandoahUpdateRefsClosure类及其相关实现，统一使用现有的ShenandoahNonConcUpdateRefsClosure。优化思路：消除冗余代码，减少内存占用和编译开销，简化代码结构，同时保持相同的功能。在需要更新引用的地方（如线程握手、根处理、弱根清理等）直接使用现有的非并发更新引用闭包。"}
{"id": 664, "source": "riscv-dataset-excel", "optimization_type": "代码简化+内存优化", "optimization_description": "优化前：使用专门的ShenandoahInitMarkRootsClosure模板类进行根标记，包含完整的类定义和实现，代码冗余。优化后：移除整个ShenandoahInitMarkRootsClosure类，直接使用现有的ShenandoahMarkRefsClosure，简化代码结构。优化思路：消除重复代码，减少编译产物大小，提高代码可维护性，同时保持相同的标记功能。", "original_code": "使用专门的ShenandoahInitMarkRootsClosure模板类进行根标记，包含完整的类定义和实现，代码冗余。", "optimized_code": "-template<ShenandoahGenerationType GENERATION>\n-class ShenandoahInitMarkRootsClosure : public OopClosure {\n-private:\n-  ShenandoahObjToScanQueue* const _queue;\n-  ShenandoahMarkingContext* const _mark_context;\n-\n-  template <class T>\n-  inline void do_oop_work(T* p);\n-public:\n-  ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q);\n-\n-  void do_oop(narrowOop* p) { do_oop_work(p); }\n-  void do_oop(oop* p)       { do_oop_work(p); }\n-};\n-\n-template <ShenandoahGenerationType GENERATION>\n-ShenandoahInitMarkRootsClosure<GENERATION>::ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :\n-  _queue(q),\n-  _mark_context(ShenandoahHeap::heap()->marking_context()) {\n-}\n-\n-template <ShenandoahGenerationType GENERATION>\n-template <class T>\n-void ShenandoahInitMarkRootsClosure<GENERATION>::do_oop_work(T* p) {\n-  ShenandoahMark::mark_through_ref<T, GENERATION>(p, _queue, _mark_context, false);\n-}\n+  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->ref_processor();\n+  ShenandoahMarkRefsClosure<NON_GEN> cl(task_queues()->queue(worker_id), rp);\n+  _root_scanner.roots_do(&cl, worker_id);", "source_url": "https://github.com/openjdk/riscv-port/commit/979895d175797a71c52da12f245d1040a27172cf", "code_v0_no_empty_lines": "使用专门的ShenandoahInitMarkRootsClosure模板类进行根标记，包含完整的类定义和实现，代码冗余。", "code_v1_no_empty_lines": "-template<ShenandoahGenerationType GENERATION>\n-class ShenandoahInitMarkRootsClosure : public OopClosure {\n-private:\n-  ShenandoahObjToScanQueue* const _queue;\n-  ShenandoahMarkingContext* const _mark_context;\n-\n-  template <class T>\n-  inline void do_oop_work(T* p);\n-public:\n-  ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q);\n-\n-  void do_oop(narrowOop* p) { do_oop_work(p); }\n-  void do_oop(oop* p)       { do_oop_work(p); }\n-};\n-\n-template <ShenandoahGenerationType GENERATION>\n-ShenandoahInitMarkRootsClosure<GENERATION>::ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :\n-  _queue(q),\n-  _mark_context(ShenandoahHeap::heap()->marking_context()) {\n-}\n-\n-template <ShenandoahGenerationType GENERATION>\n-template <class T>\n-void ShenandoahInitMarkRootsClosure<GENERATION>::do_oop_work(T* p) {\n-  ShenandoahMark::mark_through_ref<T, GENERATION>(p, _queue, _mark_context, false);\n-}\n+  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->ref_processor();\n+  ShenandoahMarkRefsClosure<NON_GEN> cl(task_queues()->queue(worker_id), rp);\n+  _root_scanner.roots_do(&cl, worker_id);", "target": "-template<ShenandoahGenerationType GENERATION>\n-class ShenandoahInitMarkRootsClosure : public OopClosure {\n-private:\n-  ShenandoahObjToScanQueue* const _queue;\n-  ShenandoahMarkingContext* const _mark_context;\n-\n-  template <class T>\n-  inline void do_oop_work(T* p);\n-public:\n-  ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q);\n-\n-  void do_oop(narrowOop* p) { do_oop_work(p); }\n-  void do_oop(oop* p)       { do_oop_work(p); }\n-};\n-\n-template <ShenandoahGenerationType GENERATION>\n-ShenandoahInitMarkRootsClosure<GENERATION>::ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :\n-  _queue(q),\n-  _mark_context(ShenandoahHeap::heap()->marking_context()) {\n-}\n-\n-template <ShenandoahGenerationType GENERATION>\n-template <class T>\n-void ShenandoahInitMarkRootsClosure<GENERATION>::do_oop_work(T* p) {\n-  ShenandoahMark::mark_through_ref<T, GENERATION>(p, _queue, _mark_context, false);\n-}\n+  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->ref_processor();\n+  ShenandoahMarkRefsClosure<NON_GEN> cl(task_queues()->queue(worker_id), rp);\n+  _root_scanner.roots_do(&cl, worker_id);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用专门的ShenandoahInitMarkRootsClosure模板类进行根标记，包含完整的类定义和实现，代码冗余。优化后：移除整个ShenandoahInitMarkRootsClosure类，直接使用现有的ShenandoahMarkRefsClosure，简化代码结构。优化思路：消除重复代码，减少编译产物大小，提高代码可维护性，同时保持相同的标记功能。"}
{"id": 665, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+GC屏障优化", "optimization_description": "优化前：Reference.clear()方法通过JNI调用或运行时调用，需要完整的GC屏障处理，包括保持引用对象存活的开销。优化后：C2编译器将Reference.clear()方法内联为编译器内部函数，直接生成设置引用字段为null的机器码，并使用ZBarrierNoKeepalive标志避免不必要的保持存活屏障。优化思路：通过编译器内联消除方法调用开销，利用GC屏障优化减少内存屏障操作，提高引用清除操作的性能。", "original_code": "Reference.clear()方法通过JNI调用或运行时调用，需要完整的GC屏障处理，包括保持引用对象存活的开销。", "optimized_code": "--- a/src/hotspot/share/opto/library_call.cpp\n+++ b/src/hotspot/share/opto/library_call.cpp\n@@ -1,5 +1,5 @@\n+bool LibraryCallKit::inline_reference_clear() {\n+  // 内联Reference.clear()方法\n+  // 避免调用开销，直接设置引用字段为null\n+  Node* ref = argument(0);\n+  Node* null = makecon(TypePtr::NULL_PTR);\n+  set_barrier_data(ZBarrierNoKeepalive);\n+  store_to_memory(control(), ref, null, T_OBJECT, TypePtr::BOTTOM, MemNode::unordered);\n+  return true;\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/7625b29920e95f9b754057fe0a2c4ab0afa5cb0c", "code_v0_no_empty_lines": "Reference.clear()方法通过JNI调用或运行时调用，需要完整的GC屏障处理，包括保持引用对象存活的开销。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/opto/library_call.cpp\n+++ b/src/hotspot/share/opto/library_call.cpp\n@@ -1,5 +1,5 @@\n+bool LibraryCallKit::inline_reference_clear() {\n+  // 内联Reference.clear()方法\n+  // 避免调用开销，直接设置引用字段为null\n+  Node* ref = argument(0);\n+  Node* null = makecon(TypePtr::NULL_PTR);\n+  set_barrier_data(ZBarrierNoKeepalive);\n+  store_to_memory(control(), ref, null, T_OBJECT, TypePtr::BOTTOM, MemNode::unordered);\n+  return true;\n+}", "target": "--- a/src/hotspot/share/opto/library_call.cpp\n+++ b/src/hotspot/share/opto/library_call.cpp\n@@ -1,5 +1,5 @@\n+bool LibraryCallKit::inline_reference_clear() {\n+  // 内联Reference.clear()方法\n+  // 避免调用开销，直接设置引用字段为null\n+  Node* ref = argument(0);\n+  Node* null = makecon(TypePtr::NULL_PTR);\n+  set_barrier_data(ZBarrierNoKeepalive);\n+  store_to_memory(control(), ref, null, T_OBJECT, TypePtr::BOTTOM, MemNode::unordered);\n+  return true;\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Reference.clear()方法通过JNI调用或运行时调用，需要完整的GC屏障处理，包括保持引用对象存活的开销。优化后：C2编译器将Reference.clear()方法内联为编译器内部函数，直接生成设置引用字段为null的机器码，并使用ZBarrierNoKeepalive标志避免不必要的保持存活屏障。优化思路：通过编译器内联消除方法调用开销，利用GC屏障优化减少内存屏障操作，提高引用清除操作的性能。"}
{"id": 666, "source": "riscv-dataset-excel", "optimization_type": "代码重构+性能优化", "optimization_description": "优化前：存在ShenandoahMarkUpdateRefsSuperClosure中间类，导致模板参数传递和虚函数调用存在额外间接层。优化后：移除中间类，将ShenandoahMarkUpdateRefsClosure直接继承自ShenandoahMarkRefsSuperClosure，简化类层次结构。优化思路：消除不必要的类继承层次，减少虚函数调用开销，简化模板参数传递，提升垃圾回收标记更新阶段的性能。", "original_code": "存在ShenandoahMarkUpdateRefsSuperClosure中间类，导致模板参数传递和虚函数调用存在额外间接层。", "optimized_code": "-class ShenandoahMarkUpdateRefsSuperClosure : public ShenandoahMarkRefsSuperClosure {\n+template <ShenandoahGenerationType GENERATION>\n+class ShenandoahMarkUpdateRefsClosure : public ShenandoahMarkRefsSuperClosure {\n-  template <class T, ShenandoahGenerationType GENERATION>\n+  template <class T>\n   inline void work(T* p);\n-  ShenandoahMarkUpdateRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n+  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(oop* p)       { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }", "source_url": "https://github.com/openjdk/riscv-port/commit/724de682091623cd9877ee4e5f13123ef1d92ddf", "code_v0_no_empty_lines": "存在ShenandoahMarkUpdateRefsSuperClosure中间类，导致模板参数传递和虚函数调用存在额外间接层。", "code_v1_no_empty_lines": "-class ShenandoahMarkUpdateRefsSuperClosure : public ShenandoahMarkRefsSuperClosure {\n+template <ShenandoahGenerationType GENERATION>\n+class ShenandoahMarkUpdateRefsClosure : public ShenandoahMarkRefsSuperClosure {\n-  template <class T, ShenandoahGenerationType GENERATION>\n+  template <class T>\n   inline void work(T* p);\n-  ShenandoahMarkUpdateRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n+  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(oop* p)       { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }", "target": "-class ShenandoahMarkUpdateRefsSuperClosure : public ShenandoahMarkRefsSuperClosure {\n+template <ShenandoahGenerationType GENERATION>\n+class ShenandoahMarkUpdateRefsClosure : public ShenandoahMarkRefsSuperClosure {\n-  template <class T, ShenandoahGenerationType GENERATION>\n+  template <class T>\n   inline void work(T* p);\n-  ShenandoahMarkUpdateRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n+  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(oop* p)       { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：存在ShenandoahMarkUpdateRefsSuperClosure中间类，导致模板参数传递和虚函数调用存在额外间接层。优化后：移除中间类，将ShenandoahMarkUpdateRefsClosure直接继承自ShenandoahMarkRefsSuperClosure，简化类层次结构。优化思路：消除不必要的类继承层次，减少虚函数调用开销，简化模板参数传递，提升垃圾回收标记更新阶段的性能。"}
{"id": 667, "source": "riscv-dataset-excel", "optimization_type": "向量化指令优化", "optimization_description": "优化前：缺少对特定向量数据类型的selectFrom操作支持，限制了向量化性能。优化后：新增evpermi2b和evpermi2w等向量指令实现，支持字节和字类型的向量选择操作，利用AVX-512指令集提升向量操作性能。思路：通过扩展向量指令集支持，为Java Vector API提供更完整的硬件加速，减少标量回退，提高数据并行处理效率。", "original_code": "缺少对特定向量数据类型的selectFrom操作支持，限制了向量化性能。", "optimized_code": "-void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n-  InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x76, (0xC0 | encode));\n-}\n-\n-void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_avx512_vbmi(), \"\");\n-  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x7D, (0xC0 | encode));\n-}\n+\n+void Assembler::evpermi2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x75, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == Assembler::AVX_512bit ||", "source_url": "https://github.com/openjdk/riscv-port/commit/709914fc92dd180c8f081ff70ef476554a04f4ce", "code_v0_no_empty_lines": "缺少对特定向量数据类型的selectFrom操作支持，限制了向量化性能。", "code_v1_no_empty_lines": "-void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n-  InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x76, (0xC0 | encode));\n-}\n-\n-void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_avx512_vbmi(), \"\");\n-  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x7D, (0xC0 | encode));\n-}\n+\n+void Assembler::evpermi2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x75, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == Assembler::AVX_512bit ||", "target": "-void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n-  InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x76, (0xC0 | encode));\n-}\n-\n-void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_avx512_vbmi(), \"\");\n-  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x7D, (0xC0 | encode));\n-}\n+\n+void Assembler::evpermi2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x75, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == Assembler::AVX_512bit ||", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：缺少对特定向量数据类型的selectFrom操作支持，限制了向量化性能。优化后：新增evpermi2b和evpermi2w等向量指令实现，支持字节和字类型的向量选择操作，利用AVX-512指令集提升向量操作性能。思路：通过扩展向量指令集支持，为Java Vector API提供更完整的硬件加速，减少标量回退，提高数据并行处理效率。"}
{"id": 668, "source": "riscv-dataset-excel", "optimization_type": "向量化分析优化", "optimization_description": "优化前：向量化分析在处理减法操作和左移操作时，直接进行算术运算，可能导致整数溢出，从而错误地拒绝有效的向量化机会。\n优化后：1. 在scaled_iv_plus_offset函数中，对减法操作进行更精确的处理，使用临时VPointer对象解析右操作数，并显式处理偏移、不变量和比例的减法，同时添加乘法溢出检查。2. 在scaled_iv函数中，对左移操作添加溢出检查，避免因溢出而错误拒绝向量化。3. 新增try_MulI_no_overflow函数，用于安全地进行乘法运算并检查溢出。\n优化思路：通过添加溢出检查和更精确的算术运算处理，增强向量化分析的鲁棒性，避免因整数溢出而错误地拒绝有效的向量化机会，从而提高向量化成功率，提升程序性能。", "original_code": "向量化分析在处理减法操作和左移操作时，直接进行算术运算，可能导致整数溢出，从而错误地拒绝有效的向量化机会。", "optimized_code": "1. 在scaled_iv_plus_offset函数中，优化减法操作的处理逻辑：\n-  if (offset_plus_k(n->in(1)) && scaled_iv_plus_offset(n->in(2))) {\n-    _scale *= -1;\n+  VPointer tmp(this);\n+  if (offset_plus_k(n->in(1)) && tmp.scaled_iv_plus_offset(n->in(2))) {\n+    // (offset1 + invar1) - (offset2 + invar2 + scale * iv)\n+    // Subtraction handled explicitly below.\n+    assert(_scale == 0, \"shouldn't be set yet\");\n+    // _scale = -tmp._scale\n+    if (!try_MulI_no_overflow(-1, tmp._scale, _scale)) {\n+      return false; // mul overflow.\n+    }\n+    // _offset -= tmp._offset\n+    if (!try_SubI_no_overflow(_offset, tmp._offset, _offset)) {\n+      return false; // sub overflow.\n+    }\n+    // _invar -= tmp._invar\n+    if (tmp._invar != nullptr) {\n+      maybe_add_to_invar(tmp._invar, true);\n\n2. 在scaled_iv函数中，优化左移操作和整数索引处理：\n-    if (n->in(1) == iv() && n->in(2)->is_Con()) {\n-      _scale = 1 << n->in(2)->get_int();\n+    if (n->in(1) == iv() && n->in(2)->is_Con()) {\n+      if (!try_LShiftI_no_overflow(1, n->in(2)->get_int(), _scale)) {\n+        return false; // shift overflow.\n+      }\n\n3. 新增溢出检查函数：\n+bool VPointer::try_MulI_no_overflow(int offset1, int offset2, int& result) {\n+  jlong long_offset = java_multiply((jlong)(offset1), (jlong)(offset2));\n+  jint  int_offset  = java_multiply(        offset1,          offset2);\n+  if (long_offset != int_offset) {\n+    return false;\n+  }\n+  result = int_offset;\n+  return true;\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/490d099e234f27adef7d691d3c5a08ebdb550c5d", "code_v0_no_empty_lines": "向量化分析在处理减法操作和左移操作时，直接进行算术运算，可能导致整数溢出，从而错误地拒绝有效的向量化机会。", "code_v1_no_empty_lines": "1. 在scaled_iv_plus_offset函数中，优化减法操作的处理逻辑：\n-  if (offset_plus_k(n->in(1)) && scaled_iv_plus_offset(n->in(2))) {\n-    _scale *= -1;\n+  VPointer tmp(this);\n+  if (offset_plus_k(n->in(1)) && tmp.scaled_iv_plus_offset(n->in(2))) {\n+    // (offset1 + invar1) - (offset2 + invar2 + scale * iv)\n+    // Subtraction handled explicitly below.\n+    assert(_scale == 0, \"shouldn't be set yet\");\n+    // _scale = -tmp._scale\n+    if (!try_MulI_no_overflow(-1, tmp._scale, _scale)) {\n+      return false; // mul overflow.\n+    }\n+    // _offset -= tmp._offset\n+    if (!try_SubI_no_overflow(_offset, tmp._offset, _offset)) {\n+      return false; // sub overflow.\n+    }\n+    // _invar -= tmp._invar\n+    if (tmp._invar != nullptr) {\n+      maybe_add_to_invar(tmp._invar, true);\n\n2. 在scaled_iv函数中，优化左移操作和整数索引处理：\n-    if (n->in(1) == iv() && n->in(2)->is_Con()) {\n-      _scale = 1 << n->in(2)->get_int();\n+    if (n->in(1) == iv() && n->in(2)->is_Con()) {\n+      if (!try_LShiftI_no_overflow(1, n->in(2)->get_int(), _scale)) {\n+        return false; // shift overflow.\n+      }\n\n3. 新增溢出检查函数：\n+bool VPointer::try_MulI_no_overflow(int offset1, int offset2, int& result) {\n+  jlong long_offset = java_multiply((jlong)(offset1), (jlong)(offset2));\n+  jint  int_offset  = java_multiply(        offset1,          offset2);\n+  if (long_offset != int_offset) {\n+    return false;\n+  }\n+  result = int_offset;\n+  return true;\n+}", "target": "1. 在scaled_iv_plus_offset函数中，优化减法操作的处理逻辑：\n-  if (offset_plus_k(n->in(1)) && scaled_iv_plus_offset(n->in(2))) {\n-    _scale *= -1;\n+  VPointer tmp(this);\n+  if (offset_plus_k(n->in(1)) && tmp.scaled_iv_plus_offset(n->in(2))) {\n+    // (offset1 + invar1) - (offset2 + invar2 + scale * iv)\n+    // Subtraction handled explicitly below.\n+    assert(_scale == 0, \"shouldn't be set yet\");\n+    // _scale = -tmp._scale\n+    if (!try_MulI_no_overflow(-1, tmp._scale, _scale)) {\n+      return false; // mul overflow.\n+    }\n+    // _offset -= tmp._offset\n+    if (!try_SubI_no_overflow(_offset, tmp._offset, _offset)) {\n+      return false; // sub overflow.\n+    }\n+    // _invar -= tmp._invar\n+    if (tmp._invar != nullptr) {\n+      maybe_add_to_invar(tmp._invar, true);\n\n2. 在scaled_iv函数中，优化左移操作和整数索引处理：\n-    if (n->in(1) == iv() && n->in(2)->is_Con()) {\n-      _scale = 1 << n->in(2)->get_int();\n+    if (n->in(1) == iv() && n->in(2)->is_Con()) {\n+      if (!try_LShiftI_no_overflow(1, n->in(2)->get_int(), _scale)) {\n+        return false; // shift overflow.\n+      }\n\n3. 新增溢出检查函数：\n+bool VPointer::try_MulI_no_overflow(int offset1, int offset2, int& result) {\n+  jlong long_offset = java_multiply((jlong)(offset1), (jlong)(offset2));\n+  jint  int_offset  = java_multiply(        offset1,          offset2);\n+  if (long_offset != int_offset) {\n+    return false;\n+  }\n+  result = int_offset;\n+  return true;\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：向量化分析在处理减法操作和左移操作时，直接进行算术运算，可能导致整数溢出，从而错误地拒绝有效的向量化机会。\n优化后：1. 在scaled_iv_plus_offset函数中，对减法操作进行更精确的处理，使用临时VPointer对象解析右操作数，并显式处理偏移、不变量和比例的减法，同时添加乘法溢出检查。2. 在scaled_iv函数中，对左移操作添加溢出检查，避免因溢出而错误拒绝向量化。3. 新增try_MulI_no_overflow函数，用于安全地进行乘法运算并检查溢出。\n优化思路：通过添加溢出检查和更精确的算术运算处理，增强向量化分析的鲁棒性，避免因整数溢出而错误地拒绝有效的向量化机会，从而提高向量化成功率，提升程序性能。"}
{"id": 669, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：向量化分析在处理包含ConvI2L（int转long）转换的指针表达式时，可能错误地将复合long-int形式简化为简单形式，导致指针计算不准确，影响向量化决策的正确性。优化后：新增is_safe_to_use_as_simple_form方法，通过检查int_index的偏移、不变量和缩放因子，确保简单形式与复合long-int形式在运行时等价，避免因int溢出导致的指针计算错误。思路：增强向量化指针分析的安全性，仅当能证明简单形式与原始复合形式等价时才允许向量化，防止错误的内存别名分析和打包决策。", "original_code": "向量化分析在处理包含ConvI2L（int转long）转换的指针表达式时，可能错误地将复合long-int形式简化为简单形式，导致指针计算不准确，影响向量化决策的正确性。", "optimized_code": "+  _has_int_index_after_convI2L(false),\n+  _int_index_after_convI2L_offset(0),\n+  _int_index_after_convI2L_invar(nullptr),\n+  _int_index_after_convI2L_scale(0),\n+  if (!is_safe_to_use_as_simple_form(base, adr)) {\n+    assert(!valid(), \"does not have simple form\");\n+    return;\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/cfa25b71a65bfff1b31efe0d37ded37c50a98247", "code_v0_no_empty_lines": "向量化分析在处理包含ConvI2L（int转long）转换的指针表达式时，可能错误地将复合long-int形式简化为简单形式，导致指针计算不准确，影响向量化决策的正确性。", "code_v1_no_empty_lines": "+  _has_int_index_after_convI2L(false),\n+  _int_index_after_convI2L_offset(0),\n+  _int_index_after_convI2L_invar(nullptr),\n+  _int_index_after_convI2L_scale(0),\n+  if (!is_safe_to_use_as_simple_form(base, adr)) {\n+    assert(!valid(), \"does not have simple form\");\n+    return;\n+  }", "target": "+  _has_int_index_after_convI2L(false),\n+  _int_index_after_convI2L_offset(0),\n+  _int_index_after_convI2L_invar(nullptr),\n+  _int_index_after_convI2L_scale(0),\n+  if (!is_safe_to_use_as_simple_form(base, adr)) {\n+    assert(!valid(), \"does not have simple form\");\n+    return;\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：向量化分析在处理包含ConvI2L（int转long）转换的指针表达式时，可能错误地将复合long-int形式简化为简单形式，导致指针计算不准确，影响向量化决策的正确性。优化后：新增is_safe_to_use_as_simple_form方法，通过检查int_index的偏移、不变量和缩放因子，确保简单形式与复合long-int形式在运行时等价，避免因int溢出导致的指针计算错误。思路：增强向量化指针分析的安全性，仅当能证明简单形式与原始复合形式等价时才允许向量化，防止错误的内存别名分析和打包决策。"}
{"id": 670, "source": "riscv-dataset-excel", "optimization_type": "类型安全优化+数值精度优化", "optimization_description": "优化前：stride_p使用int类型，在负步长情况下-stride_con可能溢出；max直接转换min_jint为julong时符号扩展导致高位填充1。优化后：stride_p改为jlong类型并添加显式类型转换，避免溢出；max通过双重转换(juint)min_jint确保无符号扩展，得到正确的无符号值0x80000000。思路：通过类型提升和精确的类型转换，消除潜在溢出和符号扩展问题，提高循环边界计算的正确性和稳定性。", "original_code": "stride_p使用int类型，在负步长情况下-stride_con可能溢出；max直接转换min_jint为julong时符号扩展导致高位填充1。", "optimized_code": "- int stride_p;\n+ jlong stride_p;\n- stride_p = -stride_con;\n+ stride_p = -(jlong)stride_con;\n- max = (julong)min_jint;\n+ max = (julong)(juint)min_jint;", "source_url": "https://github.com/openjdk/riscv-port/commit/c89f76c0b9ca085192775af9bd9368562b582dd6", "code_v0_no_empty_lines": "stride_p使用int类型，在负步长情况下-stride_con可能溢出；max直接转换min_jint为julong时符号扩展导致高位填充1。", "code_v1_no_empty_lines": "- int stride_p;\n+ jlong stride_p;\n- stride_p = -stride_con;\n+ stride_p = -(jlong)stride_con;\n- max = (julong)min_jint;\n+ max = (julong)(juint)min_jint;", "target": "- int stride_p;\n+ jlong stride_p;\n- stride_p = -stride_con;\n+ stride_p = -(jlong)stride_con;\n- max = (julong)min_jint;\n+ max = (julong)(juint)min_jint;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：stride_p使用int类型，在负步长情况下-stride_con可能溢出；max直接转换min_jint为julong时符号扩展导致高位填充1。优化后：stride_p改为jlong类型并添加显式类型转换，避免溢出；max通过双重转换(juint)min_jint确保无符号扩展，得到正确的无符号值0x80000000。思路：通过类型提升和精确的类型转换，消除潜在溢出和符号扩展问题，提高循环边界计算的正确性和稳定性。"}
{"id": 671, "source": "riscv-dataset-excel", "optimization_type": "指令优化+分支优化", "optimization_description": "优化前：条件判断使用逻辑或(||)合并两个条件，当shift为0且d==s时，会执行不必要的lsl指令（左移0位）。优化后：将条件拆分为两个独立分支，先检查shift!=0执行lsl，否则检查d!=s执行mov，避免冗余操作。思路：通过分离条件减少指令执行，提升压缩指针解码性能。", "original_code": "条件判断使用逻辑或(||)合并两个条件，当shift为0且d==s时，会执行不必要的lsl指令（左移0位）。", "optimized_code": "-    if (CompressedOops::shift() != 0 || d != s) {\n+    if (CompressedOops::shift() != 0) {\n       lsl(d, s, CompressedOops::shift());\n+    } else if (d != s) {\n+      mov(d, s);\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/e3f650393744790e24820b2d6d99dd1da1a44de6", "code_v0_no_empty_lines": "条件判断使用逻辑或(||)合并两个条件，当shift为0且d==s时，会执行不必要的lsl指令（左移0位）。", "code_v1_no_empty_lines": "-    if (CompressedOops::shift() != 0 || d != s) {\n+    if (CompressedOops::shift() != 0) {\n       lsl(d, s, CompressedOops::shift());\n+    } else if (d != s) {\n+      mov(d, s);\n     }", "target": "-    if (CompressedOops::shift() != 0 || d != s) {\n+    if (CompressedOops::shift() != 0) {\n       lsl(d, s, CompressedOops::shift());\n+    } else if (d != s) {\n+      mov(d, s);\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：条件判断使用逻辑或(||)合并两个条件，当shift为0且d==s时，会执行不必要的lsl指令（左移0位）。优化后：将条件拆分为两个独立分支，先检查shift!=0执行lsl，否则检查d!=s执行mov，避免冗余操作。思路：通过分离条件减少指令执行，提升压缩指针解码性能。"}
{"id": 672, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+内存布局优化", "optimization_description": "优化前：_poll_data字段位于JavaThread类中，导致安全点轮询指令编码时偏移量较大（可能超过128字节），在x86_64等架构上无法使用更高效的disp8编码。优化后：将_poll_data字段上移至基类Thread中更靠前的位置，确保其偏移量小于128字节。优化思路：通过调整内存布局，使安全点轮询指令可以使用更紧凑的编码格式（disp8），减少指令大小，提高代码缓存利用率和执行效率。", "original_code": "_poll_data字段位于JavaThread类中，导致安全点轮询指令编码时偏移量较大（可能超过128字节），在x86_64等架构上无法使用更高效的disp8编码。", "optimized_code": "-  nonstatic_field(JavaThread,                  _poll_data,                                    SafepointMechanism::ThreadData)        \\\n+  nonstatic_field(Thread,                   _poll_data,                                       SafepointMechanism::ThreadData)        \\\n-  SafepointMechanism::ThreadData _poll_data;\n+  SafepointMechanism::ThreadData _poll_data;\n-  static ByteSize polling_word_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_word);}\n-  static ByteSize polling_page_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_page);}\n+  static ByteSize polling_word_offset() {\n+    ByteSize offset = byte_offset_of(Thread, _poll_data) +\n+                      byte_offset_of(SafepointMechanism::ThreadData, _polling_word);\n+    assert(in_bytes(offset) < 128, \"Offset >= 128\");\n+    return offset;\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/037f11b864734734dd7fbce029b2e8b4bc17f3ab", "code_v0_no_empty_lines": "_poll_data字段位于JavaThread类中，导致安全点轮询指令编码时偏移量较大（可能超过128字节），在x86_64等架构上无法使用更高效的disp8编码。", "code_v1_no_empty_lines": "-  nonstatic_field(JavaThread,                  _poll_data,                                    SafepointMechanism::ThreadData)        \\\n+  nonstatic_field(Thread,                   _poll_data,                                       SafepointMechanism::ThreadData)        \\\n-  SafepointMechanism::ThreadData _poll_data;\n+  SafepointMechanism::ThreadData _poll_data;\n-  static ByteSize polling_word_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_word);}\n-  static ByteSize polling_page_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_page);}\n+  static ByteSize polling_word_offset() {\n+    ByteSize offset = byte_offset_of(Thread, _poll_data) +\n+                      byte_offset_of(SafepointMechanism::ThreadData, _polling_word);\n+    assert(in_bytes(offset) < 128, \"Offset >= 128\");\n+    return offset;\n+  }", "target": "-  nonstatic_field(JavaThread,                  _poll_data,                                    SafepointMechanism::ThreadData)        \\\n+  nonstatic_field(Thread,                   _poll_data,                                       SafepointMechanism::ThreadData)        \\\n-  SafepointMechanism::ThreadData _poll_data;\n+  SafepointMechanism::ThreadData _poll_data;\n-  static ByteSize polling_word_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_word);}\n-  static ByteSize polling_page_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_page);}\n+  static ByteSize polling_word_offset() {\n+    ByteSize offset = byte_offset_of(Thread, _poll_data) +\n+                      byte_offset_of(SafepointMechanism::ThreadData, _polling_word);\n+    assert(in_bytes(offset) < 128, \"Offset >= 128\");\n+    return offset;\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：_poll_data字段位于JavaThread类中，导致安全点轮询指令编码时偏移量较大（可能超过128字节），在x86_64等架构上无法使用更高效的disp8编码。优化后：将_poll_data字段上移至基类Thread中更靠前的位置，确保其偏移量小于128字节。优化思路：通过调整内存布局，使安全点轮询指令可以使用更紧凑的编码格式（disp8），减少指令大小，提高代码缓存利用率和执行效率。"}
{"id": 673, "source": "riscv-dataset-excel", "optimization_type": "条件逻辑优化+代码简化", "optimization_description": "优化前：嵌套条件逻辑复杂，存在重复的条件判断和代码路径。优化后：提取公共条件变量codeMatch，重构条件结构，减少嵌套层次，消除重复代码。优化思路：通过提前计算并缓存条件结果，简化控制流，提高代码可读性和执行效率，减少分支预测开销。", "original_code": "嵌套条件逻辑复杂，存在重复的条件判断和代码路径。", "optimized_code": "-                var context = dcb.context;\n-                if (dcb.original != null && codeAndExceptionsMatch(codeLength)) {\n-                    if (context.stackMapsWhenRequired()) {\n+                boolean codeMatch = dcb.original != null && codeAndExceptionsMatch(codeLength);\n+                var context = dcb.context;\n+                if (context.stackMapsWhenRequired()) {\n+                    if (codeMatch) {\n                         dcb.attributes.withAttribute(dcb.original.findAttribute(Attributes.stackMapTable()).orElse(null));\n                         writeCounters(true, buf);\n-                    } else if (context.generateStackMaps()) {\n-                        generateStackMaps(buf);\n-                    } else if (context.dropStackMaps()) {\n-                        writeCounters(true, buf);\n-                    }\n-                } else {\n-                    if (context.stackMapsWhenRequired()) {\n+                    } else {\n                         tryGenerateStackMaps(false, buf);\n-                    } else if (context.generateStackMaps()) {\n-                        generateStackMaps(buf);\n-                    } else if (context.dropStackMaps()) {\n-                        writeCounters(false, buf);\n                     }\n+                } else if (context.generateStackMaps()) {\n+                    generateStackMaps(buf);\n+                } else if (context.dropStackMaps()) {\n+                    writeCounters(codeMatch, buf);", "source_url": "https://github.com/openjdk/riscv-port/commit/472db922fabfb8942f15d39ebd58125189bc8600", "code_v0_no_empty_lines": "嵌套条件逻辑复杂，存在重复的条件判断和代码路径。", "code_v1_no_empty_lines": "-                var context = dcb.context;\n-                if (dcb.original != null && codeAndExceptionsMatch(codeLength)) {\n-                    if (context.stackMapsWhenRequired()) {\n+                boolean codeMatch = dcb.original != null && codeAndExceptionsMatch(codeLength);\n+                var context = dcb.context;\n+                if (context.stackMapsWhenRequired()) {\n+                    if (codeMatch) {\n                         dcb.attributes.withAttribute(dcb.original.findAttribute(Attributes.stackMapTable()).orElse(null));\n                         writeCounters(true, buf);\n-                    } else if (context.generateStackMaps()) {\n-                        generateStackMaps(buf);\n-                    } else if (context.dropStackMaps()) {\n-                        writeCounters(true, buf);\n-                    }\n-                } else {\n-                    if (context.stackMapsWhenRequired()) {\n+                    } else {\n                         tryGenerateStackMaps(false, buf);\n-                    } else if (context.generateStackMaps()) {\n-                        generateStackMaps(buf);\n-                    } else if (context.dropStackMaps()) {\n-                        writeCounters(false, buf);\n                     }\n+                } else if (context.generateStackMaps()) {\n+                    generateStackMaps(buf);\n+                } else if (context.dropStackMaps()) {\n+                    writeCounters(codeMatch, buf);", "target": "-                var context = dcb.context;\n-                if (dcb.original != null && codeAndExceptionsMatch(codeLength)) {\n-                    if (context.stackMapsWhenRequired()) {\n+                boolean codeMatch = dcb.original != null && codeAndExceptionsMatch(codeLength);\n+                var context = dcb.context;\n+                if (context.stackMapsWhenRequired()) {\n+                    if (codeMatch) {\n                         dcb.attributes.withAttribute(dcb.original.findAttribute(Attributes.stackMapTable()).orElse(null));\n                         writeCounters(true, buf);\n-                    } else if (context.generateStackMaps()) {\n-                        generateStackMaps(buf);\n-                    } else if (context.dropStackMaps()) {\n-                        writeCounters(true, buf);\n-                    }\n-                } else {\n-                    if (context.stackMapsWhenRequired()) {\n+                    } else {\n                         tryGenerateStackMaps(false, buf);\n-                    } else if (context.generateStackMaps()) {\n-                        generateStackMaps(buf);\n-                    } else if (context.dropStackMaps()) {\n-                        writeCounters(false, buf);\n                     }\n+                } else if (context.generateStackMaps()) {\n+                    generateStackMaps(buf);\n+                } else if (context.dropStackMaps()) {\n+                    writeCounters(codeMatch, buf);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：嵌套条件逻辑复杂，存在重复的条件判断和代码路径。优化后：提取公共条件变量codeMatch，重构条件结构，减少嵌套层次，消除重复代码。优化思路：通过提前计算并缓存条件结果，简化控制流，提高代码可读性和执行效率，减少分支预测开销。"}
{"id": 674, "source": "riscv-dataset-excel", "optimization_type": "内存访问优化+代码简化", "optimization_description": "优化前：每个属性写入时多次调用独立的writeU2/writeInt方法，产生多次方法调用开销和可能的缓冲区边界检查。优化后：引入组合写入方法writeU2U2/writeIntInt，将多个相关值的写入合并为单次方法调用，减少方法调用次数和边界检查开销，同时通过类型转换(BufWriter→BufWriterImpl)直接访问常量池索引方法。", "original_code": "每个属性写入时多次调用独立的writeU2/writeInt方法，产生多次方法调用开销和可能的缓冲区边界检查。", "optimized_code": "- buf.writeU2(info.startPc());\n- buf.writeU2(info.endPc());\n- buf.writeInt(info.characterRangeStart());\n- buf.writeInt(info.characterRangeEnd());\n+ buf.writeU2U2(info.startPc(), info.endPc());\n+ buf.writeIntInt(info.characterRangeStart(), info.characterRangeEnd());", "source_url": "https://github.com/openjdk/riscv-port/commit/24eb360147a5ca548abc89eb6480f46b89e11d19", "code_v0_no_empty_lines": "每个属性写入时多次调用独立的writeU2/writeInt方法，产生多次方法调用开销和可能的缓冲区边界检查。", "code_v1_no_empty_lines": "- buf.writeU2(info.startPc());\n- buf.writeU2(info.endPc());\n- buf.writeInt(info.characterRangeStart());\n- buf.writeInt(info.characterRangeEnd());\n+ buf.writeU2U2(info.startPc(), info.endPc());\n+ buf.writeIntInt(info.characterRangeStart(), info.characterRangeEnd());", "target": "- buf.writeU2(info.startPc());\n- buf.writeU2(info.endPc());\n- buf.writeInt(info.characterRangeStart());\n- buf.writeInt(info.characterRangeEnd());\n+ buf.writeU2U2(info.startPc(), info.endPc());\n+ buf.writeIntInt(info.characterRangeStart(), info.characterRangeEnd());", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每个属性写入时多次调用独立的writeU2/writeInt方法，产生多次方法调用开销和可能的缓冲区边界检查。优化后：引入组合写入方法writeU2U2/writeIntInt，将多个相关值的写入合并为单次方法调用，减少方法调用次数和边界检查开销，同时通过类型转换(BufWriter→BufWriterImpl)直接访问常量池索引方法。"}
{"id": 675, "source": "riscv-dataset-excel", "optimization_type": "内存访问优化", "optimization_description": "优化前：每次循环都无条件执行数组赋值操作 types[compressed++] = types[i]，即使 compressed == i 时也会进行不必要的自赋值。优化后：添加条件判断 if (compressed != i)，仅在需要时才执行数组赋值，避免了冗余的内存写入操作。思路：通过减少不必要的数组元素自赋值，降低内存访问开销，提升压缩算法的执行效率。", "original_code": "每次循环都无条件执行数组赋值操作 types[compressed++] = types[i]，即使 compressed == i 时也会进行不必要的自赋值。", "optimized_code": "-                    types[compressed++] = types[i];\n+                    if (compressed != i) {\n+                        types[compressed] = types[i];\n+                    }\n+                    compressed++;", "source_url": "https://github.com/openjdk/riscv-port/commit/6e0138450ab4b0af917cbf61701b0d1d17eeaa44", "code_v0_no_empty_lines": "每次循环都无条件执行数组赋值操作 types[compressed++] = types[i]，即使 compressed == i 时也会进行不必要的自赋值。", "code_v1_no_empty_lines": "-                    types[compressed++] = types[i];\n+                    if (compressed != i) {\n+                        types[compressed] = types[i];\n+                    }\n+                    compressed++;", "target": "-                    types[compressed++] = types[i];\n+                    if (compressed != i) {\n+                        types[compressed] = types[i];\n+                    }\n+                    compressed++;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次循环都无条件执行数组赋值操作 types[compressed++] = types[i]，即使 compressed == i 时也会进行不必要的自赋值。优化后：添加条件判断 if (compressed != i)，仅在需要时才执行数组赋值，避免了冗余的内存写入操作。思路：通过减少不必要的数组元素自赋值，降低内存访问开销，提升压缩算法的执行效率。"}
{"id": 676, "source": "riscv-dataset-excel", "optimization_type": "代码重构与性能优化", "optimization_description": "优化前：StackMapGenerator在处理字节码指令时，对栈操作（如decStack、pushStack、popStack）采用链式调用和显式临时变量赋值，代码冗长且重复。优化后：1. 引入新的辅助方法（如decStack2PushStack、decStack、dup、dup_x1等），将常见操作模式封装为单一方法调用，减少代码量和临时变量使用。2. 重构DUP系列和SWAP指令的处理逻辑，用简洁的方法调用替代复杂的多步操作。优化思路：通过方法封装减少重复代码，提高代码可读性和维护性，同时可能通过减少方法调用链和临时对象创建来提升运行时性能。", "original_code": "StackMapGenerator在处理字节码指令时，对栈操作（如decStack、pushStack、popStack）采用链式调用和显式临时变量赋值，代码冗长且重复。", "optimized_code": "-                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack2PushStack(Type.INTEGER_TYPE);\n-                currentFrame.decStack(2).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack2PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n-                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack2PushStack(Type.FLOAT_TYPE);\n-                currentFrame.decStack(2).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack2PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n-                currentFrame.pushStack((type1 = currentFrame.decStack(1).popStack()) == Type.NULL_TYPE ? Type.NULL_TYPE : type1.getComponent());\n+                currentFrame.pushStack((type1 = currentFrame.decStack().popStack()) == Type.NULL_TYPE ? Type.NULL_TYPE : type1.getComponent());\n-                currentFrame.decStack(1).setLocal(bcs.getIndex(), Type.INTEGER_TYPE);\n+                currentFrame.decStack().setLocal(bcs.getIndex(), Type.INTEGER_TYPE);\n-                currentFrame.decStack(1).setLocal(opcode - ISTORE_0, Type.INTEGER_TYPE);\n+                currentFrame.decStack().setLocal(opcode - ISTORE_0, Type.INTEGER_TYPE);\n-                currentFrame.decStack(1).setLocal(bcs.getIndex(), Type.FLOAT_TYPE);\n+                currentFrame.decStack().setLocal(bcs.getIndex(), Type.FLOAT_TYPE);\n-                currentFrame.decStack(1).setLocal(opcode - FSTORE_0, Type.FLOAT_TYPE);\n+                currentFrame.decStack().setLocal(opcode - FSTORE_0, Type.FLOAT_TYPE);\n-                currentFrame.decStack(1);\n+                currentFrame.decStack();\n-            case DUP ->\n-                currentFrame.pushStack(type1 = currentFrame.popStack()).pushStack(type1);\n-            case DUP_X1 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type1).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP_X2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                currentFrame.pushStack(type1).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2_X1 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2_X2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                type4 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type4).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case SWAP -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type1);\n-                currentFrame.pushStack(type2);\n-            }\n+            case DUP ->\n+                currentFrame.dup();\n+            case DUP_X1 ->\n+                currentFrame.dup_x1();", "source_url": "https://github.com/openjdk/riscv-port/commit/e9327b6e3c1fcc47ec790fa4e4019f7651a8f912", "code_v0_no_empty_lines": "StackMapGenerator在处理字节码指令时，对栈操作（如decStack、pushStack、popStack）采用链式调用和显式临时变量赋值，代码冗长且重复。", "code_v1_no_empty_lines": "-                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack2PushStack(Type.INTEGER_TYPE);\n-                currentFrame.decStack(2).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack2PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n-                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack2PushStack(Type.FLOAT_TYPE);\n-                currentFrame.decStack(2).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack2PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n-                currentFrame.pushStack((type1 = currentFrame.decStack(1).popStack()) == Type.NULL_TYPE ? Type.NULL_TYPE : type1.getComponent());\n+                currentFrame.pushStack((type1 = currentFrame.decStack().popStack()) == Type.NULL_TYPE ? Type.NULL_TYPE : type1.getComponent());\n-                currentFrame.decStack(1).setLocal(bcs.getIndex(), Type.INTEGER_TYPE);\n+                currentFrame.decStack().setLocal(bcs.getIndex(), Type.INTEGER_TYPE);\n-                currentFrame.decStack(1).setLocal(opcode - ISTORE_0, Type.INTEGER_TYPE);\n+                currentFrame.decStack().setLocal(opcode - ISTORE_0, Type.INTEGER_TYPE);\n-                currentFrame.decStack(1).setLocal(bcs.getIndex(), Type.FLOAT_TYPE);\n+                currentFrame.decStack().setLocal(bcs.getIndex(), Type.FLOAT_TYPE);\n-                currentFrame.decStack(1).setLocal(opcode - FSTORE_0, Type.FLOAT_TYPE);\n+                currentFrame.decStack().setLocal(opcode - FSTORE_0, Type.FLOAT_TYPE);\n-                currentFrame.decStack(1);\n+                currentFrame.decStack();\n-            case DUP ->\n-                currentFrame.pushStack(type1 = currentFrame.popStack()).pushStack(type1);\n-            case DUP_X1 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type1).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP_X2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                currentFrame.pushStack(type1).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2_X1 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2_X2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                type4 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type4).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case SWAP -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type1);\n-                currentFrame.pushStack(type2);\n-            }\n+            case DUP ->\n+                currentFrame.dup();\n+            case DUP_X1 ->\n+                currentFrame.dup_x1();", "target": "-                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack2PushStack(Type.INTEGER_TYPE);\n-                currentFrame.decStack(2).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack2PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n-                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack2PushStack(Type.FLOAT_TYPE);\n-                currentFrame.decStack(2).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack2PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n-                currentFrame.pushStack((type1 = currentFrame.decStack(1).popStack()) == Type.NULL_TYPE ? Type.NULL_TYPE : type1.getComponent());\n+                currentFrame.pushStack((type1 = currentFrame.decStack().popStack()) == Type.NULL_TYPE ? Type.NULL_TYPE : type1.getComponent());\n-                currentFrame.decStack(1).setLocal(bcs.getIndex(), Type.INTEGER_TYPE);\n+                currentFrame.decStack().setLocal(bcs.getIndex(), Type.INTEGER_TYPE);\n-                currentFrame.decStack(1).setLocal(opcode - ISTORE_0, Type.INTEGER_TYPE);\n+                currentFrame.decStack().setLocal(opcode - ISTORE_0, Type.INTEGER_TYPE);\n-                currentFrame.decStack(1).setLocal(bcs.getIndex(), Type.FLOAT_TYPE);\n+                currentFrame.decStack().setLocal(bcs.getIndex(), Type.FLOAT_TYPE);\n-                currentFrame.decStack(1).setLocal(opcode - FSTORE_0, Type.FLOAT_TYPE);\n+                currentFrame.decStack().setLocal(opcode - FSTORE_0, Type.FLOAT_TYPE);\n-                currentFrame.decStack(1);\n+                currentFrame.decStack();\n-            case DUP ->\n-                currentFrame.pushStack(type1 = currentFrame.popStack()).pushStack(type1);\n-            case DUP_X1 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type1).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP_X2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                currentFrame.pushStack(type1).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2_X1 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2_X2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                type4 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type4).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case SWAP -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type1);\n-                currentFrame.pushStack(type2);\n-            }\n+            case DUP ->\n+                currentFrame.dup();\n+            case DUP_X1 ->\n+                currentFrame.dup_x1();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：StackMapGenerator在处理字节码指令时，对栈操作（如decStack、pushStack、popStack）采用链式调用和显式临时变量赋值，代码冗长且重复。优化后：1. 引入新的辅助方法（如decStack2PushStack、decStack、dup、dup_x1等），将常见操作模式封装为单一方法调用，减少代码量和临时变量使用。2. 重构DUP系列和SWAP指令的处理逻辑，用简洁的方法调用替代复杂的多步操作。优化思路：通过方法封装减少重复代码，提高代码可读性和维护性，同时可能通过减少方法调用链和临时对象创建来提升运行时性能。"}
{"id": 677, "source": "riscv-dataset-excel", "optimization_type": "代码清理/无用代码移除", "optimization_description": "优化前：C2编译器包含未使用的StoreCM节点及相关指令定义，这些代码用于CMS垃圾收集器的卡标记操作，但CMS已被G1等现代收集器取代。优化后：完全移除StoreCM节点定义、相关指令模板及所有引用代码，减少编译器代码库大小和复杂度。思路：清理过时、无用的代码，简化编译器实现，提高可维护性。", "original_code": "C2编译器包含未使用的StoreCM节点及相关指令定义，这些代码用于CMS垃圾收集器的卡标记操作，但CMS已被G1等现代收集器取代。", "optimized_code": "- instruct storeimmCM0(immI0 zero, memory1 mem)\n%{\n  match(Set mem (StoreCM mem zero));\n  ins_cost(INSN_COST);\n  format %{ \"storestore (elided)\\n\\t\"\n            \"strb zr, $mem\\t# byte\" %}", "source_url": "https://github.com/openjdk/riscv-port/commit/16042556f394adfa93e54173944198397ad29dea", "code_v0_no_empty_lines": "C2编译器包含未使用的StoreCM节点及相关指令定义，这些代码用于CMS垃圾收集器的卡标记操作，但CMS已被G1等现代收集器取代。", "code_v1_no_empty_lines": "- instruct storeimmCM0(immI0 zero, memory1 mem)\n%{\n  match(Set mem (StoreCM mem zero));\n  ins_cost(INSN_COST);\n  format %{ \"storestore (elided)\\n\\t\"\n            \"strb zr, $mem\\t# byte\" %}", "target": "- instruct storeimmCM0(immI0 zero, memory1 mem)\n%{\n  match(Set mem (StoreCM mem zero));\n  ins_cost(INSN_COST);\n  format %{ \"storestore (elided)\\n\\t\"\n            \"strb zr, $mem\\t# byte\" %}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器包含未使用的StoreCM节点及相关指令定义，这些代码用于CMS垃圾收集器的卡标记操作，但CMS已被G1等现代收集器取代。优化后：完全移除StoreCM节点定义、相关指令模板及所有引用代码，减少编译器代码库大小和复杂度。思路：清理过时、无用的代码，简化编译器实现，提高可维护性。"}
{"id": 678, "source": "riscv-dataset-excel", "optimization_type": "内存优化+性能优化", "optimization_description": "优化前：每次创建lambda表达式时动态生成参数名称数组（argNames），为每个参数分配新字符串对象，增加内存分配和初始化开销。优化后：使用静态缓存数组ARG_NAME_CACHE存储常用参数名称（arg$1到arg$8），通过argName(i)方法按索引获取，超出缓存范围时才动态生成。优化思路：减少字符串对象创建和内存分配，利用@Stable注解确保缓存数组不可变，提高lambda表达式生成性能。", "original_code": "每次创建lambda表达式时动态生成参数名称数组（argNames），为每个参数分配新字符串对象，增加内存分配和初始化开销。", "optimized_code": "- private static final String[] EMPTY_STRING_ARRAY = new String[0];\n+ private static final @Stable String[] ARG_NAME_CACHE = {\"arg$1\", \"arg$2\", \"arg$3\", \"arg$4\", \"arg$5\", \"arg$6\", \"arg$7\", \"arg$8\"};\n- private final String[] argNames;\n- argNames = new String[parameterCount];\n- argNames[i] = \"arg$\" + (i + 1);\n- argNames = EMPTY_STRING_ARRAY;\n+ private static String argName(int i) {\n+     return i < ARG_NAME_CACHE.length ? ARG_NAME_CACHE[i] :  \"arg$\" + (i + 1);\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/c850ecb20a095cb69da81f6fbe5da9c4bce66e77", "code_v0_no_empty_lines": "每次创建lambda表达式时动态生成参数名称数组（argNames），为每个参数分配新字符串对象，增加内存分配和初始化开销。", "code_v1_no_empty_lines": "- private static final String[] EMPTY_STRING_ARRAY = new String[0];\n+ private static final @Stable String[] ARG_NAME_CACHE = {\"arg$1\", \"arg$2\", \"arg$3\", \"arg$4\", \"arg$5\", \"arg$6\", \"arg$7\", \"arg$8\"};\n- private final String[] argNames;\n- argNames = new String[parameterCount];\n- argNames[i] = \"arg$\" + (i + 1);\n- argNames = EMPTY_STRING_ARRAY;\n+ private static String argName(int i) {\n+     return i < ARG_NAME_CACHE.length ? ARG_NAME_CACHE[i] :  \"arg$\" + (i + 1);\n+ }", "target": "- private static final String[] EMPTY_STRING_ARRAY = new String[0];\n+ private static final @Stable String[] ARG_NAME_CACHE = {\"arg$1\", \"arg$2\", \"arg$3\", \"arg$4\", \"arg$5\", \"arg$6\", \"arg$7\", \"arg$8\"};\n- private final String[] argNames;\n- argNames = new String[parameterCount];\n- argNames[i] = \"arg$\" + (i + 1);\n- argNames = EMPTY_STRING_ARRAY;\n+ private static String argName(int i) {\n+     return i < ARG_NAME_CACHE.length ? ARG_NAME_CACHE[i] :  \"arg$\" + (i + 1);\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次创建lambda表达式时动态生成参数名称数组（argNames），为每个参数分配新字符串对象，增加内存分配和初始化开销。优化后：使用静态缓存数组ARG_NAME_CACHE存储常用参数名称（arg$1到arg$8），通过argName(i)方法按索引获取，超出缓存范围时才动态生成。优化思路：减少字符串对象创建和内存分配，利用@Stable注解确保缓存数组不可变，提高lambda表达式生成性能。"}
{"id": 679, "source": "riscv-dataset-excel", "optimization_type": "代码重构+性能优化", "optimization_description": "优化前：inflate()方法中处理非ASCII字符的逻辑直接内联在else分支中，代码结构不够清晰，可能影响可读性和维护性。优化后：将非ASCII字符处理逻辑提取为独立的inflateNonAscii()方法，通过方法重构提高代码模块化程度。优化思路：通过提取方法重构代码，使主方法逻辑更清晰，同时保持原有功能不变，可能带来更好的JIT优化机会和代码维护性。", "original_code": "inflate()方法中处理非ASCII字符的逻辑直接内联在else分支中，代码结构不够清晰，可能影响可读性和维护性。", "optimized_code": "-            else {\n-                char[] chararr = new char[rawLen];\n-                int chararr_count = singleBytes;\n-                // Inflate prefix of bytes to characters\n-                JLA.inflateBytesToChars(rawBytes, offset, chararr, 0, singleBytes);\n-                ...\n-                this.contentHash = hash;\n-                charLen = chararr_count;\n-                this.chars = chararr;\n-                state = State.CHAR;\n-            }\n+            } else {\n+                inflateNonAscii(singleBytes, hash);\n+            }\n+        }\n+\n+        private void inflateNonAscii(int singleBytes, int hash) {\n+            char[] chararr = new char[rawLen];\n+            int chararr_count = singleBytes;\n+            // Inflate prefix of bytes to characters\n+            JLA.inflateBytesToChars(rawBytes, offset, chararr, 0, singleBytes);\n+            ...\n+            this.contentHash = hash;\n+            charLen = chararr_count;\n+            this.chars = chararr;\n+            state = State.CHAR;\n+        }", "source_url": "https://github.com/openjdk/riscv-port/commit/a24525b67b97d38a33e42871bd2e8d03cd327568", "code_v0_no_empty_lines": "inflate()方法中处理非ASCII字符的逻辑直接内联在else分支中，代码结构不够清晰，可能影响可读性和维护性。", "code_v1_no_empty_lines": "-            else {\n-                char[] chararr = new char[rawLen];\n-                int chararr_count = singleBytes;\n-                // Inflate prefix of bytes to characters\n-                JLA.inflateBytesToChars(rawBytes, offset, chararr, 0, singleBytes);\n-                ...\n-                this.contentHash = hash;\n-                charLen = chararr_count;\n-                this.chars = chararr;\n-                state = State.CHAR;\n-            }\n+            } else {\n+                inflateNonAscii(singleBytes, hash);\n+            }\n+        }\n+\n+        private void inflateNonAscii(int singleBytes, int hash) {\n+            char[] chararr = new char[rawLen];\n+            int chararr_count = singleBytes;\n+            // Inflate prefix of bytes to characters\n+            JLA.inflateBytesToChars(rawBytes, offset, chararr, 0, singleBytes);\n+            ...\n+            this.contentHash = hash;\n+            charLen = chararr_count;\n+            this.chars = chararr;\n+            state = State.CHAR;\n+        }", "target": "-            else {\n-                char[] chararr = new char[rawLen];\n-                int chararr_count = singleBytes;\n-                // Inflate prefix of bytes to characters\n-                JLA.inflateBytesToChars(rawBytes, offset, chararr, 0, singleBytes);\n-                ...\n-                this.contentHash = hash;\n-                charLen = chararr_count;\n-                this.chars = chararr;\n-                state = State.CHAR;\n-            }\n+            } else {\n+                inflateNonAscii(singleBytes, hash);\n+            }\n+        }\n+\n+        private void inflateNonAscii(int singleBytes, int hash) {\n+            char[] chararr = new char[rawLen];\n+            int chararr_count = singleBytes;\n+            // Inflate prefix of bytes to characters\n+            JLA.inflateBytesToChars(rawBytes, offset, chararr, 0, singleBytes);\n+            ...\n+            this.contentHash = hash;\n+            charLen = chararr_count;\n+            this.chars = chararr;\n+            state = State.CHAR;\n+        }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：inflate()方法中处理非ASCII字符的逻辑直接内联在else分支中，代码结构不够清晰，可能影响可读性和维护性。优化后：将非ASCII字符处理逻辑提取为独立的inflateNonAscii()方法，通过方法重构提高代码模块化程度。优化思路：通过提取方法重构代码，使主方法逻辑更清晰，同时保持原有功能不变，可能带来更好的JIT优化机会和代码维护性。"}
{"id": 680, "source": "riscv-dataset-excel", "optimization_type": "循环优化+内存优化", "optimization_description": "优化前：在循环中每次迭代都动态构造方法名字符串（\"main\" + ((xi == 0) ? \"\" : \"\" + xi)），导致重复的字符串拼接操作和临时对象创建。优化后：将方法名数组预计算并缓存到静态常量METHOD_NAMES中，循环中直接通过索引访问。优化思路：通过预计算和缓存消除循环中的重复计算，减少字符串拼接开销和临时对象分配，提高基准测试性能。", "original_code": "在循环中每次迭代都动态构造方法名字符串（\"main\" + ((xi == 0) ? \"\" : \"\" + xi)），导致重复的字符串拼接操作和临时对象创建。", "optimized_code": "static final int REPEATS = 40;\nstatic final String[] METHOD_NAMES;\nstatic {\n    var names = new String[REPEATS];\n    for (int xi = 0; xi < REPEATS; ++xi) {\n        names[xi] = \"main\" + ((xi == 0) ? \"\" : \"\" + xi);\n    }\n    METHOD_NAMES = names;\n}\n...\nfor (int xi = 0; xi < REPEATS; ++xi) {\n    MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC+Opcodes.ACC_STATIC, METHOD_NAMES[xi], \"([Ljava/lang/String;)V\", null, null);\n    ...\n}\n...\nfor (int xi = 0; xi < REPEATS; ++xi) {\n    cb.withMethod(METHOD_NAMES[xi], MTD_void_StringArray,\n                  ACC_PUBLIC | ACC_STATIC,\n                  mb -> mb.withCode(c0 -> {", "source_url": "https://github.com/openjdk/riscv-port/commit/475f8f94e038e10c796b5d56f939384d7b84da54", "code_v0_no_empty_lines": "在循环中每次迭代都动态构造方法名字符串（\"main\" + ((xi == 0) ? \"\" : \"\" + xi)），导致重复的字符串拼接操作和临时对象创建。", "code_v1_no_empty_lines": "static final int REPEATS = 40;\nstatic final String[] METHOD_NAMES;\nstatic {\n    var names = new String[REPEATS];\n    for (int xi = 0; xi < REPEATS; ++xi) {\n        names[xi] = \"main\" + ((xi == 0) ? \"\" : \"\" + xi);\n    }\n    METHOD_NAMES = names;\n}\n...\nfor (int xi = 0; xi < REPEATS; ++xi) {\n    MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC+Opcodes.ACC_STATIC, METHOD_NAMES[xi], \"([Ljava/lang/String;)V\", null, null);\n    ...\n}\n...\nfor (int xi = 0; xi < REPEATS; ++xi) {\n    cb.withMethod(METHOD_NAMES[xi], MTD_void_StringArray,\n                  ACC_PUBLIC | ACC_STATIC,\n                  mb -> mb.withCode(c0 -> {", "target": "static final int REPEATS = 40;\nstatic final String[] METHOD_NAMES;\nstatic {\n    var names = new String[REPEATS];\n    for (int xi = 0; xi < REPEATS; ++xi) {\n        names[xi] = \"main\" + ((xi == 0) ? \"\" : \"\" + xi);\n    }\n    METHOD_NAMES = names;\n}\n...\nfor (int xi = 0; xi < REPEATS; ++xi) {\n    MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC+Opcodes.ACC_STATIC, METHOD_NAMES[xi], \"([Ljava/lang/String;)V\", null, null);\n    ...\n}\n...\nfor (int xi = 0; xi < REPEATS; ++xi) {\n    cb.withMethod(METHOD_NAMES[xi], MTD_void_StringArray,\n                  ACC_PUBLIC | ACC_STATIC,\n                  mb -> mb.withCode(c0 -> {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在循环中每次迭代都动态构造方法名字符串（\"main\" + ((xi == 0) ? \"\" : \"\" + xi)），导致重复的字符串拼接操作和临时对象创建。优化后：将方法名数组预计算并缓存到静态常量METHOD_NAMES中，循环中直接通过索引访问。优化思路：通过预计算和缓存消除循环中的重复计算，减少字符串拼接开销和临时对象分配，提高基准测试性能。"}
{"id": 681, "source": "riscv-dataset-excel", "optimization_type": "指令优化", "optimization_description": "优化前使用testl指令测试monitor寄存器自身，虽然能设置ZF=0但会产生额外的依赖和延迟。优化后改用orl(t, 1)指令，通过将t寄存器与1进行或操作来确保ZF=0，同时避免了不必要的寄存器依赖，提高了指令执行效率。", "original_code": "// No original code extracted from description\n", "optimized_code": "-    testl(monitor, monitor);            // Fast Unlock ZF = 0\n+    orl(t, 1); // Fast Unlock ZF = 0", "source_url": "https://github.com/openjdk/riscv-port/commit/fcc9c8d570396506068e0a1d4123e32b195e6653", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "-    testl(monitor, monitor);            // Fast Unlock ZF = 0\n+    orl(t, 1); // Fast Unlock ZF = 0", "target": "-    testl(monitor, monitor);            // Fast Unlock ZF = 0\n+    orl(t, 1); // Fast Unlock ZF = 0", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用testl指令测试monitor寄存器自身，虽然能设置ZF=0但会产生额外的依赖和延迟。优化后改用orl(t, 1)指令，通过将t寄存器与1进行或操作来确保ZF=0，同时避免了不必要的寄存器依赖，提高了指令执行效率。"}
{"id": 682, "source": "riscv-dataset-excel", "optimization_type": "算术优化+强度削减", "optimization_description": "优化前：C2编译器在处理连续加法序列（如a + a + ... + a）时，会生成多个AddNode指令，导致指令数量增加和计算效率降低。优化后：通过新增convert_serial_additions函数，识别并转换连续加法模式为单个乘法指令（a * n）。具体优化包括：1) 将a + a转换为2 * a；2) 将(a << CON) + a转换为((1 << CON) + 1) * a；3) 将(CON * a) + a转换为(CON + 1) * a；4) 将(a << CON1) + (a << CON2)转换为((1 << CON1) + (1 << CON2)) * a。优化思路：通过强度削减（strength reduction）将多个加法操作合并为单个乘法操作，减少指令数量，提高计算效率，同时避免与现有幂次加法优化产生无限循环。", "original_code": "C2编译器在处理连续加法序列（如a + a + ... + a）时，会生成多个AddNode指令，导致指令数量增加和计算效率降低。", "optimized_code": "+  // Convert a + a + ... + a into a*n\n+  Node* serial_additions = convert_serial_additions(phase, bt);\n+  if (serial_additions != nullptr) {\n+    return serial_additions;\n+  }\n\n+Node* AddNode::convert_serial_additions(PhaseGVN* phase, BasicType bt) {\n+  // We need to make sure that the current AddNode is not part of a MulNode that has already been optimized to a\n+  // power-of-2 addition (e.g., 3 * a => (a << 2) + a). Without this check, GVN would keep trying to optimize the same\n+  // node and can't progress. For example, 3 * a => (a << 2) + a => 3 * a => (a << 2) + a => ...\n+  if (find_power_of_two_addition_pattern(this, bt, nullptr) != nullptr) {\n+    return nullptr;\n+  }\n\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  jlong multiplier;\n\n+  // While multiplications can be potentially optimized to power-of-2 subtractions (e.g., a * 7 => (a << 3) - a),\n+  // (x - y) + y => x is already handled by the Identity() methods. So, we don't need to check for that pattern here.\n+  if (find_simple_addition_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_lshift_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_multiplication_pattern(in1, bt, &multiplier) == in2\n+      || find_power_of_two_addition_pattern(in1, bt, &multiplier) == in2) {\n+    multiplier++; // +1 for the in2 term\n\n+    Node* con = (bt == T_INT)\n+                ? (Node*) phase->intcon((jint) multiplier) // intentional type narrowing to allow overflow at max_jint\n+                : (Node*) phase->longcon(multiplier);\n+    return MulNode::make(con, in2, bt);\n+  }\n\n+  return nullptr;\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/c30ad0124e7743f3a4c29ef901761f8fcc53de10", "code_v0_no_empty_lines": "C2编译器在处理连续加法序列（如a + a + ... + a）时，会生成多个AddNode指令，导致指令数量增加和计算效率降低。", "code_v1_no_empty_lines": "+  // Convert a + a + ... + a into a*n\n+  Node* serial_additions = convert_serial_additions(phase, bt);\n+  if (serial_additions != nullptr) {\n+    return serial_additions;\n+  }\n\n+Node* AddNode::convert_serial_additions(PhaseGVN* phase, BasicType bt) {\n+  // We need to make sure that the current AddNode is not part of a MulNode that has already been optimized to a\n+  // power-of-2 addition (e.g., 3 * a => (a << 2) + a). Without this check, GVN would keep trying to optimize the same\n+  // node and can't progress. For example, 3 * a => (a << 2) + a => 3 * a => (a << 2) + a => ...\n+  if (find_power_of_two_addition_pattern(this, bt, nullptr) != nullptr) {\n+    return nullptr;\n+  }\n\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  jlong multiplier;\n\n+  // While multiplications can be potentially optimized to power-of-2 subtractions (e.g., a * 7 => (a << 3) - a),\n+  // (x - y) + y => x is already handled by the Identity() methods. So, we don't need to check for that pattern here.\n+  if (find_simple_addition_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_lshift_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_multiplication_pattern(in1, bt, &multiplier) == in2\n+      || find_power_of_two_addition_pattern(in1, bt, &multiplier) == in2) {\n+    multiplier++; // +1 for the in2 term\n\n+    Node* con = (bt == T_INT)\n+                ? (Node*) phase->intcon((jint) multiplier) // intentional type narrowing to allow overflow at max_jint\n+                : (Node*) phase->longcon(multiplier);\n+    return MulNode::make(con, in2, bt);\n+  }\n\n+  return nullptr;\n+}", "target": "+  // Convert a + a + ... + a into a*n\n+  Node* serial_additions = convert_serial_additions(phase, bt);\n+  if (serial_additions != nullptr) {\n+    return serial_additions;\n+  }\n\n+Node* AddNode::convert_serial_additions(PhaseGVN* phase, BasicType bt) {\n+  // We need to make sure that the current AddNode is not part of a MulNode that has already been optimized to a\n+  // power-of-2 addition (e.g., 3 * a => (a << 2) + a). Without this check, GVN would keep trying to optimize the same\n+  // node and can't progress. For example, 3 * a => (a << 2) + a => 3 * a => (a << 2) + a => ...\n+  if (find_power_of_two_addition_pattern(this, bt, nullptr) != nullptr) {\n+    return nullptr;\n+  }\n\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  jlong multiplier;\n\n+  // While multiplications can be potentially optimized to power-of-2 subtractions (e.g., a * 7 => (a << 3) - a),\n+  // (x - y) + y => x is already handled by the Identity() methods. So, we don't need to check for that pattern here.\n+  if (find_simple_addition_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_lshift_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_multiplication_pattern(in1, bt, &multiplier) == in2\n+      || find_power_of_two_addition_pattern(in1, bt, &multiplier) == in2) {\n+    multiplier++; // +1 for the in2 term\n\n+    Node* con = (bt == T_INT)\n+                ? (Node*) phase->intcon((jint) multiplier) // intentional type narrowing to allow overflow at max_jint\n+                : (Node*) phase->longcon(multiplier);\n+    return MulNode::make(con, in2, bt);\n+  }\n\n+  return nullptr;\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器在处理连续加法序列（如a + a + ... + a）时，会生成多个AddNode指令，导致指令数量增加和计算效率降低。优化后：通过新增convert_serial_additions函数，识别并转换连续加法模式为单个乘法指令（a * n）。具体优化包括：1) 将a + a转换为2 * a；2) 将(a << CON) + a转换为((1 << CON) + 1) * a；3) 将(CON * a) + a转换为(CON + 1) * a；4) 将(a << CON1) + (a << CON2)转换为((1 << CON1) + (1 << CON2)) * a。优化思路：通过强度削减（strength reduction）将多个加法操作合并为单个乘法操作，减少指令数量，提高计算效率，同时避免与现有幂次加法优化产生无限循环。"}
{"id": 683, "source": "riscv-dataset-excel", "optimization_type": "代码重构+设计模式优化", "optimization_description": "优化前：代码直接使用ParsePredicateIterator遍历谓词链并手动调用mark_useful()方法，逻辑分散且重复。优化后：引入PredicateVisitor设计模式，创建专门的ParsePredicateUsefulMarker访问器类，通过统一的PredicateIterator.for_each()方法进行遍历，简化了谓词遍历逻辑，提高了代码的可维护性和可扩展性。", "original_code": "代码直接使用ParsePredicateIterator遍历谓词链并手动调用mark_useful()方法，逻辑分散且重复。", "optimized_code": "- const Predicates predicates(entry);\n  ParsePredicateIterator iterator(predicates);\n  while (iterator.has_next()) {\n    iterator.next()->mark_useful();\n  }\n+ const PredicateIterator predicate_iterator(entry);\n  ParsePredicateUsefulMarker useful_marker;\n  predicate_iterator.for_each(useful_marker);", "source_url": "https://github.com/openjdk/riscv-port/commit/3fba1702cd8dc817b11bfa51077c41424d289281", "code_v0_no_empty_lines": "代码直接使用ParsePredicateIterator遍历谓词链并手动调用mark_useful()方法，逻辑分散且重复。", "code_v1_no_empty_lines": "- const Predicates predicates(entry);\n  ParsePredicateIterator iterator(predicates);\n  while (iterator.has_next()) {\n    iterator.next()->mark_useful();\n  }\n+ const PredicateIterator predicate_iterator(entry);\n  ParsePredicateUsefulMarker useful_marker;\n  predicate_iterator.for_each(useful_marker);", "target": "- const Predicates predicates(entry);\n  ParsePredicateIterator iterator(predicates);\n  while (iterator.has_next()) {\n    iterator.next()->mark_useful();\n  }\n+ const PredicateIterator predicate_iterator(entry);\n  ParsePredicateUsefulMarker useful_marker;\n  predicate_iterator.for_each(useful_marker);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：代码直接使用ParsePredicateIterator遍历谓词链并手动调用mark_useful()方法，逻辑分散且重复。优化后：引入PredicateVisitor设计模式，创建专门的ParsePredicateUsefulMarker访问器类，通过统一的PredicateIterator.for_each()方法进行遍历，简化了谓词遍历逻辑，提高了代码的可维护性和可扩展性。"}
{"id": 684, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+内存优化", "optimization_description": "优化前：1. 常量池条目写入时多次调用writeU1/writeU2等小方法，产生额外调用开销；2. 局部变量操作指令生成时统一调用writeLocalVar方法，未区分单字节指令；3. 属性存储使用ArrayList，有动态扩容开销。优化后：1. 将多个小写入方法合并为writeU1U2等批量写入方法，减少方法调用次数；2. 对单字节局部变量操作指令直接调用writeBytecode优化代码生成路径；3. 将ArrayList改为预分配数组，避免动态扩容。优化思路：通过减少方法调用、优化代码生成路径和预分配内存来提升DirectCodeBuilder的性能。", "original_code": "1. 常量池条目写入时多次调用writeU1/writeU2等小方法，产生额外调用开销；2. 局部变量操作指令生成时统一调用writeLocalVar方法，未区分单字节指令；3. 属性存储使用ArrayList，有动态扩容开销。", "optimized_code": "- pool.writeU1(tag());\n- pool.writeU2(ref1.index());\n+ pool.writeU1U2(tag(), ref1.index());\n\n- writer.writeLocalVar(op, slot);\n+ var op = this.op;\n+ if (op.sizeIfFixed() == 1) {\n+     writer.writeBytecode(op);\n+ } else {\n+     writer.writeLocalVar(op, slot);\n+ }\n\n- private final List<Attribute<?>> attributes = new ArrayList<>();\n+ private static final Attribute<?>[] EMPTY_ATTRIBUTE_ARRAY = {};\n+ private int attributesCount = 0;\n+ private Attribute<?>[] attributes = EMPTY_ATTRIBUTE_ARRAY;", "source_url": "https://github.com/openjdk/riscv-port/commit/047c2d7f2676b8c3c8b5645134fb5c00c540e43f", "code_v0_no_empty_lines": "1. 常量池条目写入时多次调用writeU1/writeU2等小方法，产生额外调用开销；2. 局部变量操作指令生成时统一调用writeLocalVar方法，未区分单字节指令；3. 属性存储使用ArrayList，有动态扩容开销。", "code_v1_no_empty_lines": "- pool.writeU1(tag());\n- pool.writeU2(ref1.index());\n+ pool.writeU1U2(tag(), ref1.index());\n\n- writer.writeLocalVar(op, slot);\n+ var op = this.op;\n+ if (op.sizeIfFixed() == 1) {\n+     writer.writeBytecode(op);\n+ } else {\n+     writer.writeLocalVar(op, slot);\n+ }\n\n- private final List<Attribute<?>> attributes = new ArrayList<>();\n+ private static final Attribute<?>[] EMPTY_ATTRIBUTE_ARRAY = {};\n+ private int attributesCount = 0;\n+ private Attribute<?>[] attributes = EMPTY_ATTRIBUTE_ARRAY;", "target": "- pool.writeU1(tag());\n- pool.writeU2(ref1.index());\n+ pool.writeU1U2(tag(), ref1.index());\n\n- writer.writeLocalVar(op, slot);\n+ var op = this.op;\n+ if (op.sizeIfFixed() == 1) {\n+     writer.writeBytecode(op);\n+ } else {\n+     writer.writeLocalVar(op, slot);\n+ }\n\n- private final List<Attribute<?>> attributes = new ArrayList<>();\n+ private static final Attribute<?>[] EMPTY_ATTRIBUTE_ARRAY = {};\n+ private int attributesCount = 0;\n+ private Attribute<?>[] attributes = EMPTY_ATTRIBUTE_ARRAY;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 常量池条目写入时多次调用writeU1/writeU2等小方法，产生额外调用开销；2. 局部变量操作指令生成时统一调用writeLocalVar方法，未区分单字节指令；3. 属性存储使用ArrayList，有动态扩容开销。优化后：1. 将多个小写入方法合并为writeU1U2等批量写入方法，减少方法调用次数；2. 对单字节局部变量操作指令直接调用writeBytecode优化代码生成路径；3. 将ArrayList改为预分配数组，避免动态扩容。优化思路：通过减少方法调用、优化代码生成路径和预分配内存来提升DirectCodeBuilder的性能。"}
{"id": 685, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+锁优化", "optimization_description": "优化前：线程启动和退出时直接竞争Threads_lock全局锁，当大量线程并发创建/销毁时，VM线程执行安全点操作需要等待Threads_lock，导致安全点延迟。\n\n优化后：引入ThreadsLockThrottle_lock作为二级锁，在Threads_lock之前先获取该锁（通过ConditionalMutexLocker），通过UseThreadsLockThrottleLock标志控制。\n\n优化思路：通过增加一个额外的锁来分散对Threads_lock的竞争，让VM线程在执行安全点操作时能够优先获取Threads_lock，减少安全点延迟，提高系统响应性。", "original_code": "线程启动和退出时直接竞争Threads_lock全局锁，当大量线程并发创建/销毁时，VM线程执行安全点操作需要等待Threads_lock，导致安全点延迟。", "optimized_code": "1. 在JVM_StartThread函数中：\n- MutexLocker mu(Threads_lock);\n+ ConditionalMutexLocker throttle_ml(ThreadsLockThrottle_lock, UseThreadsLockThrottleLock);\n+ MutexLocker ml(Threads_lock);\n\n2. 在Threads::remove函数中：\n- { MonitorLocker ml(Threads_lock);\n+ { ConditionalMutexLocker throttle_ml(ThreadsLockThrottle_lock, UseThreadsLockThrottleLock);\n+ MonitorLocker ml(Threads_lock);", "source_url": "https://github.com/openjdk/riscv-port/commit/e704c055a4cf2aab77cc2b3d034f5a8b8d9e3331", "code_v0_no_empty_lines": "线程启动和退出时直接竞争Threads_lock全局锁，当大量线程并发创建/销毁时，VM线程执行安全点操作需要等待Threads_lock，导致安全点延迟。", "code_v1_no_empty_lines": "1. 在JVM_StartThread函数中：\n- MutexLocker mu(Threads_lock);\n+ ConditionalMutexLocker throttle_ml(ThreadsLockThrottle_lock, UseThreadsLockThrottleLock);\n+ MutexLocker ml(Threads_lock);\n\n2. 在Threads::remove函数中：\n- { MonitorLocker ml(Threads_lock);\n+ { ConditionalMutexLocker throttle_ml(ThreadsLockThrottle_lock, UseThreadsLockThrottleLock);\n+ MonitorLocker ml(Threads_lock);", "target": "1. 在JVM_StartThread函数中：\n- MutexLocker mu(Threads_lock);\n+ ConditionalMutexLocker throttle_ml(ThreadsLockThrottle_lock, UseThreadsLockThrottleLock);\n+ MutexLocker ml(Threads_lock);\n\n2. 在Threads::remove函数中：\n- { MonitorLocker ml(Threads_lock);\n+ { ConditionalMutexLocker throttle_ml(ThreadsLockThrottle_lock, UseThreadsLockThrottleLock);\n+ MonitorLocker ml(Threads_lock);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：线程启动和退出时直接竞争Threads_lock全局锁，当大量线程并发创建/销毁时，VM线程执行安全点操作需要等待Threads_lock，导致安全点延迟。\n\n优化后：引入ThreadsLockThrottle_lock作为二级锁，在Threads_lock之前先获取该锁（通过ConditionalMutexLocker），通过UseThreadsLockThrottleLock标志控制。\n\n优化思路：通过增加一个额外的锁来分散对Threads_lock的竞争，让VM线程在执行安全点操作时能够优先获取Threads_lock，减少安全点延迟，提高系统响应性。"}
{"id": 686, "source": "riscv-dataset-excel", "optimization_type": "向量化数学运算优化", "optimization_description": "优化前：RISC-V平台上的向量数学运算（如sin、cos等）缺乏专门的向量化实现，可能使用标量运算或未优化的向量路径，导致性能低下。\n优化后：通过集成SLEEF向量数学库，为RISC-V的RVV向量扩展提供高效的向量数学运算实现，包括构建libsleef库、实现向量调用约定、添加向量参数传递支持、生成向量数学stub等。\n优化思路：利用SLEEF库提供的高精度向量数学函数，结合RISC-V的RVV向量指令集，通过向量化调用约定和参数传递机制，将向量数学运算委托给优化的本地库实现，从而大幅提升向量数学运算的性能。", "original_code": "RISC-V平台上的向量数学运算（如sin、cos等）缺乏专门的向量化实现，可能使用标量运算或未优化的向量路径，导致性能低下。", "optimized_code": "diff --git a/src/hotspot/cpu/riscv/riscv.ad b/src/hotspot/cpu/riscv/riscv.ad\nindex 563dfd4cde9..a76d1722670 100644\n--- a/src/hotspot/cpu/riscv/riscv.ad\n+++ b/src/hotspot/cpu/riscv/riscv.ad\n@@ -1972,12 +1972,16 @@ const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length)\n \n // Vector calling convention not yet implemented.\n bool Matcher::supports_vector_calling_convention(void) {\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n }\n \n OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(ideal_reg == Op_VecA, \"sanity\");\n+  // check more info at https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc\n+  int lo = V8_num;\n+  int hi = V8_K_num;\n+  return OptoRegPair(hi, lo);\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/580eb62dc097efeb51c76b095c1404106859b673", "code_v0_no_empty_lines": "RISC-V平台上的向量数学运算（如sin、cos等）缺乏专门的向量化实现，可能使用标量运算或未优化的向量路径，导致性能低下。", "code_v1_no_empty_lines": "diff --git a/src/hotspot/cpu/riscv/riscv.ad b/src/hotspot/cpu/riscv/riscv.ad\nindex 563dfd4cde9..a76d1722670 100644\n--- a/src/hotspot/cpu/riscv/riscv.ad\n+++ b/src/hotspot/cpu/riscv/riscv.ad\n@@ -1972,12 +1972,16 @@ const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length)\n \n // Vector calling convention not yet implemented.\n bool Matcher::supports_vector_calling_convention(void) {\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n }\n \n OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(ideal_reg == Op_VecA, \"sanity\");\n+  // check more info at https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc\n+  int lo = V8_num;\n+  int hi = V8_K_num;\n+  return OptoRegPair(hi, lo);\n }", "target": "diff --git a/src/hotspot/cpu/riscv/riscv.ad b/src/hotspot/cpu/riscv/riscv.ad\nindex 563dfd4cde9..a76d1722670 100644\n--- a/src/hotspot/cpu/riscv/riscv.ad\n+++ b/src/hotspot/cpu/riscv/riscv.ad\n@@ -1972,12 +1972,16 @@ const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length)\n \n // Vector calling convention not yet implemented.\n bool Matcher::supports_vector_calling_convention(void) {\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n }\n \n OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(ideal_reg == Op_VecA, \"sanity\");\n+  // check more info at https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc\n+  int lo = V8_num;\n+  int hi = V8_K_num;\n+  return OptoRegPair(hi, lo);\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V平台上的向量数学运算（如sin、cos等）缺乏专门的向量化实现，可能使用标量运算或未优化的向量路径，导致性能低下。\n优化后：通过集成SLEEF向量数学库，为RISC-V的RVV向量扩展提供高效的向量数学运算实现，包括构建libsleef库、实现向量调用约定、添加向量参数传递支持、生成向量数学stub等。\n优化思路：利用SLEEF库提供的高精度向量数学函数，结合RISC-V的RVV向量指令集，通过向量化调用约定和参数传递机制，将向量数学运算委托给优化的本地库实现，从而大幅提升向量数学运算的性能。"}
{"id": 687, "source": "riscv-dataset-excel", "optimization_type": "内存访问优化", "optimization_description": "优化前：通过多次独立的字节读取操作（如buf[i+0]、buf[i+1]等）来检查ZIP文件签名，以及使用get64()进行8字节读取，这可能导致多次内存访问和边界检查开销。优化后：使用get32()和get64S()方法，这些方法利用Unsafe API实现内存读取的合并（coalescing），将多个字节的读取合并为单次操作。优化思路：减少内存访问次数，利用底层Unsafe操作提高读取效率，特别是在处理ZIP文件元数据时提升性能。", "original_code": "通过多次独立的字节读取操作（如buf[i+0]、buf[i+1]等）来检查ZIP文件签名，以及使用get64()进行8字节读取，这可能导致多次内存访问和边界检查开销。", "optimized_code": "- if (buf[i+0] == (byte)'P' && buf[i+1] == (byte)'K' && buf[i+2] == (byte)'\\005' && buf[i+3] == (byte)'\\006') {\n+ if (get32(buf, i) == ENDSIG) {\n- if (GETSIG(sbuf) != CENSIG || ... GETSIG(sbuf) != LOCSIG) {\n+ if (get32(sbuf, 0) != CENSIG || ... get32(sbuf, 0) != LOCSIG) {\n- size = get64(extra, off);\n+ size = get64S(extra, off);", "source_url": "https://github.com/openjdk/riscv-port/commit/ffb60e55cd77a92d19e1fde305f5d204b9fae429", "code_v0_no_empty_lines": "通过多次独立的字节读取操作（如buf[i+0]、buf[i+1]等）来检查ZIP文件签名，以及使用get64()进行8字节读取，这可能导致多次内存访问和边界检查开销。", "code_v1_no_empty_lines": "- if (buf[i+0] == (byte)'P' && buf[i+1] == (byte)'K' && buf[i+2] == (byte)'\\005' && buf[i+3] == (byte)'\\006') {\n+ if (get32(buf, i) == ENDSIG) {\n- if (GETSIG(sbuf) != CENSIG || ... GETSIG(sbuf) != LOCSIG) {\n+ if (get32(sbuf, 0) != CENSIG || ... get32(sbuf, 0) != LOCSIG) {\n- size = get64(extra, off);\n+ size = get64S(extra, off);", "target": "- if (buf[i+0] == (byte)'P' && buf[i+1] == (byte)'K' && buf[i+2] == (byte)'\\005' && buf[i+3] == (byte)'\\006') {\n+ if (get32(buf, i) == ENDSIG) {\n- if (GETSIG(sbuf) != CENSIG || ... GETSIG(sbuf) != LOCSIG) {\n+ if (get32(sbuf, 0) != CENSIG || ... get32(sbuf, 0) != LOCSIG) {\n- size = get64(extra, off);\n+ size = get64S(extra, off);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：通过多次独立的字节读取操作（如buf[i+0]、buf[i+1]等）来检查ZIP文件签名，以及使用get64()进行8字节读取，这可能导致多次内存访问和边界检查开销。优化后：使用get32()和get64S()方法，这些方法利用Unsafe API实现内存读取的合并（coalescing），将多个字节的读取合并为单次操作。优化思路：减少内存访问次数，利用底层Unsafe操作提高读取效率，特别是在处理ZIP文件元数据时提升性能。"}
{"id": 688, "source": "riscv-dataset-excel", "optimization_type": "位运算优化", "optimization_description": "优化前使用(slot & mask) == slot检查slot是否在mask范围内，需要两次位运算和一次比较。优化后使用(slot & ~mask) == 0，只需一次位运算和一次比较，减少了指令数量。思路是将检查slot是否在0-255或0-65535范围内的条件判断从'与运算后等于原值'改为'取反后等于0'，更高效地验证slot值是否在有效范围内。", "original_code": "// No original code extracted from description\n", "optimized_code": "- if ((slot & 0xFF) == slot)\n+ if ((slot & ~0xFF) == 0)\n- if ((slot & 0xFFFF) == slot)\n+ if ((slot & ~0xFFFF) == 0)", "source_url": "https://github.com/openjdk/riscv-port/commit/d996ca863deef50ba7c1c8878cc4c202fa1a9d6b", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- if ((slot & 0xFF) == slot)\n+ if ((slot & ~0xFF) == 0)\n- if ((slot & 0xFFFF) == slot)\n+ if ((slot & ~0xFFFF) == 0)", "target": "- if ((slot & 0xFF) == slot)\n+ if ((slot & ~0xFF) == 0)\n- if ((slot & 0xFFFF) == slot)\n+ if ((slot & ~0xFFFF) == 0)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用(slot & mask) == slot检查slot是否在mask范围内，需要两次位运算和一次比较。优化后使用(slot & ~mask) == 0，只需一次位运算和一次比较，减少了指令数量。思路是将检查slot是否在0-255或0-65535范围内的条件判断从'与运算后等于原值'改为'取反后等于0'，更高效地验证slot值是否在有效范围内。"}
{"id": 689, "source": "riscv-dataset-excel", "optimization_type": "代码可读性/维护性优化", "optimization_description": "优化前：RISC-V汇编代码中直接使用x28-x31等原始寄存器编号，代码可读性较差，难以理解寄存器用途。优化后：在assembler_riscv.hpp中为x28-x31寄存器添加t3-t6别名定义，并在stubGenerator_riscv.cpp中将所有x28-x31的使用替换为对应的t3-t6别名。优化思路：通过使用寄存器别名提高代码可读性和维护性，使代码更符合RISC-V ABI规范，便于开发者理解寄存器用途，同时保持相同的运行时性能。", "original_code": "RISC-V汇编代码中直接使用x28-x31等原始寄存器编号，代码可读性较差，难以理解寄存器用途。", "optimized_code": "--- a/src/hotspot/cpu/riscv/assembler_riscv.hpp\n+++ b/src/hotspot/cpu/riscv/assembler_riscv.hpp\n@@ -143,6 +143,10 @@ constexpr Register x19_sender_sp = x19; // Sender's SP while in interpreter\n constexpr Register t0 = x5;\n constexpr Register t1 = x6;\n constexpr Register t2 = x7;\n+constexpr Register t3 = x28;\n+constexpr Register t4 = x29;\n+constexpr Register t5 = x30;\n+constexpr Register t6 = x31;\n \n const Register g_INTArgReg[Argument::n_int_register_parameters_c] = {\n   c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5, c_rarg6, c_rarg7\n--- a/src/hotspot/cpu/riscv/stubGenerator_riscv.cpp\n+++ b/src/hotspot/cpu/riscv/stubGenerator_riscv.cpp\n@@ -4482,7 +4482,7 @@ class StubGenerator: public StubCodeGenerator {\n     RegSet reg_cache_saved_regs = RegSet::of(x24, x25, x26, x27); // s8, s9, s10, s11\n     RegSet reg_cache_regs;\n     reg_cache_regs += reg_cache_saved_regs;\n-    reg_cache_regs += RegSet::of(x28, x29, x30, x31); // t3, t4, t5, t6\n+    reg_cache_regs += RegSet::of(t3, t4, t5, t6);\n     BufRegCache reg_cache(_masm, reg_cache_regs);\n \n     RegSet saved_regs;\n@@ -5462,8 +5462,8 @@ class StubGenerator: public StubCodeGenerator {\n     Register isMIME = c_rarg6;\n \n     Register codec     = c_rarg7;\n-    Register dstBackup = x31;\n-    Register length    = x28;     // t3, total length of src data in bytes\n+    Register dstBackup = t6;\n+    Register length    = t3;     // total length of src data in bytes\n \n     Label ProcessData, Exit;\n     Label ProcessScalar, ScalarLoop;\n@@ -5498,7 +5498,7 @@ class StubGenerator: public StubCodeGenerator {\n       Register stepSrcM1 = send;\n       Register stepSrcM2 = doff;\n       Register stepDst   = isURL;\n-      Register size      = x29;   // t4\n+      Register size      = t4;\n \n       __ mv(size, MaxVectorSize * 2);\n       __ mv(stepSrcM1, MaxVectorSize * 4);\n@@ -5550,7 +5550,7 @@ class StubGenerator: public StubCodeGenerator {\n     // scalar version\n     {\n       Register byte0 = soff, byte1 = send, byte2 = doff, byte3 = isURL;\n-      Register combined32Bits = x29; // t5\n+      Register combined32Bits = t4;\n \n       // encoded:   [byte0[5:0] : byte1[5:0] : byte2[5:0]] : byte3[5:0]] =>\n       // plain:     [byte0[5:0]+byte1[5:4] : byte1[3:0]+byte2[5:2] : byte2[1:0]+byte3[5:0]]\n@@ -5708,10 +5708,10 @@ class StubGenerator: public StubCodeGenerator {\n     Register nmax  = c_rarg4;\n     Register base  = c_rarg5;\n     Register count = c_rarg6;\n-    Register temp0 = x28; // t3\n-    Register temp1 = x29; // t4\n-    Register temp2 = x30; // t5\n-    Register temp3 = x31; // t6\n+    Register temp0 = t3;\n+    Register temp1 = t4;\n+    Register temp2 = t5;\n+    Register temp3 = t6;\n \n     VectorRegister vzero = v31;\n     VectorRegister vbytes = v8; // group: v8, v9, v10, v11\n@@ -6102,7 +6102,7 @@ static const int64_t right_3_bits = right_n_bits(3);\n \n     __ kernel_crc32(crc, buf, len,\n                     c_rarg3, c_rarg4, c_rarg5, c_rarg6, // tmp's for tables\n-                    c_rarg7, t2, x28, x29, x30, x31);   // misc tmps\n+                    c_rarg7, t2, t3, t4, t5, t6);       // misc tmps\n \n     __ leave(); // required for proper stackwalking of RuntimeStub frame\n     __ ret();", "source_url": "https://github.com/openjdk/riscv-port/commit/28977972a0129892543222eada4dc99f4cd62574", "code_v0_no_empty_lines": "RISC-V汇编代码中直接使用x28-x31等原始寄存器编号，代码可读性较差，难以理解寄存器用途。", "code_v1_no_empty_lines": "--- a/src/hotspot/cpu/riscv/assembler_riscv.hpp\n+++ b/src/hotspot/cpu/riscv/assembler_riscv.hpp\n@@ -143,6 +143,10 @@ constexpr Register x19_sender_sp = x19; // Sender's SP while in interpreter\n constexpr Register t0 = x5;\n constexpr Register t1 = x6;\n constexpr Register t2 = x7;\n+constexpr Register t3 = x28;\n+constexpr Register t4 = x29;\n+constexpr Register t5 = x30;\n+constexpr Register t6 = x31;\n \n const Register g_INTArgReg[Argument::n_int_register_parameters_c] = {\n   c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5, c_rarg6, c_rarg7\n--- a/src/hotspot/cpu/riscv/stubGenerator_riscv.cpp\n+++ b/src/hotspot/cpu/riscv/stubGenerator_riscv.cpp\n@@ -4482,7 +4482,7 @@ class StubGenerator: public StubCodeGenerator {\n     RegSet reg_cache_saved_regs = RegSet::of(x24, x25, x26, x27); // s8, s9, s10, s11\n     RegSet reg_cache_regs;\n     reg_cache_regs += reg_cache_saved_regs;\n-    reg_cache_regs += RegSet::of(x28, x29, x30, x31); // t3, t4, t5, t6\n+    reg_cache_regs += RegSet::of(t3, t4, t5, t6);\n     BufRegCache reg_cache(_masm, reg_cache_regs);\n \n     RegSet saved_regs;\n@@ -5462,8 +5462,8 @@ class StubGenerator: public StubCodeGenerator {\n     Register isMIME = c_rarg6;\n \n     Register codec     = c_rarg7;\n-    Register dstBackup = x31;\n-    Register length    = x28;     // t3, total length of src data in bytes\n+    Register dstBackup = t6;\n+    Register length    = t3;     // total length of src data in bytes\n \n     Label ProcessData, Exit;\n     Label ProcessScalar, ScalarLoop;\n@@ -5498,7 +5498,7 @@ class StubGenerator: public StubCodeGenerator {\n       Register stepSrcM1 = send;\n       Register stepSrcM2 = doff;\n       Register stepDst   = isURL;\n-      Register size      = x29;   // t4\n+      Register size      = t4;\n \n       __ mv(size, MaxVectorSize * 2);\n       __ mv(stepSrcM1, MaxVectorSize * 4);\n@@ -5550,7 +5550,7 @@ class StubGenerator: public StubCodeGenerator {\n     // scalar version\n     {\n       Register byte0 = soff, byte1 = send, byte2 = doff, byte3 = isURL;\n-      Register combined32Bits = x29; // t5\n+      Register combined32Bits = t4;\n \n       // encoded:   [byte0[5:0] : byte1[5:0] : byte2[5:0]] : byte3[5:0]] =>\n       // plain:     [byte0[5:0]+byte1[5:4] : byte1[3:0]+byte2[5:2] : byte2[1:0]+byte3[5:0]]\n@@ -5708,10 +5708,10 @@ class StubGenerator: public StubCodeGenerator {\n     Register nmax  = c_rarg4;\n     Register base  = c_rarg5;\n     Register count = c_rarg6;\n-    Register temp0 = x28; // t3\n-    Register temp1 = x29; // t4\n-    Register temp2 = x30; // t5\n-    Register temp3 = x31; // t6\n+    Register temp0 = t3;\n+    Register temp1 = t4;\n+    Register temp2 = t5;\n+    Register temp3 = t6;\n \n     VectorRegister vzero = v31;\n     VectorRegister vbytes = v8; // group: v8, v9, v10, v11\n@@ -6102,7 +6102,7 @@ static const int64_t right_3_bits = right_n_bits(3);\n \n     __ kernel_crc32(crc, buf, len,\n                     c_rarg3, c_rarg4, c_rarg5, c_rarg6, // tmp's for tables\n-                    c_rarg7, t2, x28, x29, x30, x31);   // misc tmps\n+                    c_rarg7, t2, t3, t4, t5, t6);       // misc tmps\n \n     __ leave(); // required for proper stackwalking of RuntimeStub frame\n     __ ret();", "target": "--- a/src/hotspot/cpu/riscv/assembler_riscv.hpp\n+++ b/src/hotspot/cpu/riscv/assembler_riscv.hpp\n@@ -143,6 +143,10 @@ constexpr Register x19_sender_sp = x19; // Sender's SP while in interpreter\n constexpr Register t0 = x5;\n constexpr Register t1 = x6;\n constexpr Register t2 = x7;\n+constexpr Register t3 = x28;\n+constexpr Register t4 = x29;\n+constexpr Register t5 = x30;\n+constexpr Register t6 = x31;\n \n const Register g_INTArgReg[Argument::n_int_register_parameters_c] = {\n   c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5, c_rarg6, c_rarg7\n--- a/src/hotspot/cpu/riscv/stubGenerator_riscv.cpp\n+++ b/src/hotspot/cpu/riscv/stubGenerator_riscv.cpp\n@@ -4482,7 +4482,7 @@ class StubGenerator: public StubCodeGenerator {\n     RegSet reg_cache_saved_regs = RegSet::of(x24, x25, x26, x27); // s8, s9, s10, s11\n     RegSet reg_cache_regs;\n     reg_cache_regs += reg_cache_saved_regs;\n-    reg_cache_regs += RegSet::of(x28, x29, x30, x31); // t3, t4, t5, t6\n+    reg_cache_regs += RegSet::of(t3, t4, t5, t6);\n     BufRegCache reg_cache(_masm, reg_cache_regs);\n \n     RegSet saved_regs;\n@@ -5462,8 +5462,8 @@ class StubGenerator: public StubCodeGenerator {\n     Register isMIME = c_rarg6;\n \n     Register codec     = c_rarg7;\n-    Register dstBackup = x31;\n-    Register length    = x28;     // t3, total length of src data in bytes\n+    Register dstBackup = t6;\n+    Register length    = t3;     // total length of src data in bytes\n \n     Label ProcessData, Exit;\n     Label ProcessScalar, ScalarLoop;\n@@ -5498,7 +5498,7 @@ class StubGenerator: public StubCodeGenerator {\n       Register stepSrcM1 = send;\n       Register stepSrcM2 = doff;\n       Register stepDst   = isURL;\n-      Register size      = x29;   // t4\n+      Register size      = t4;\n \n       __ mv(size, MaxVectorSize * 2);\n       __ mv(stepSrcM1, MaxVectorSize * 4);\n@@ -5550,7 +5550,7 @@ class StubGenerator: public StubCodeGenerator {\n     // scalar version\n     {\n       Register byte0 = soff, byte1 = send, byte2 = doff, byte3 = isURL;\n-      Register combined32Bits = x29; // t5\n+      Register combined32Bits = t4;\n \n       // encoded:   [byte0[5:0] : byte1[5:0] : byte2[5:0]] : byte3[5:0]] =>\n       // plain:     [byte0[5:0]+byte1[5:4] : byte1[3:0]+byte2[5:2] : byte2[1:0]+byte3[5:0]]\n@@ -5708,10 +5708,10 @@ class StubGenerator: public StubCodeGenerator {\n     Register nmax  = c_rarg4;\n     Register base  = c_rarg5;\n     Register count = c_rarg6;\n-    Register temp0 = x28; // t3\n-    Register temp1 = x29; // t4\n-    Register temp2 = x30; // t5\n-    Register temp3 = x31; // t6\n+    Register temp0 = t3;\n+    Register temp1 = t4;\n+    Register temp2 = t5;\n+    Register temp3 = t6;\n \n     VectorRegister vzero = v31;\n     VectorRegister vbytes = v8; // group: v8, v9, v10, v11\n@@ -6102,7 +6102,7 @@ static const int64_t right_3_bits = right_n_bits(3);\n \n     __ kernel_crc32(crc, buf, len,\n                     c_rarg3, c_rarg4, c_rarg5, c_rarg6, // tmp's for tables\n-                    c_rarg7, t2, x28, x29, x30, x31);   // misc tmps\n+                    c_rarg7, t2, t3, t4, t5, t6);       // misc tmps\n \n     __ leave(); // required for proper stackwalking of RuntimeStub frame\n     __ ret();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V汇编代码中直接使用x28-x31等原始寄存器编号，代码可读性较差，难以理解寄存器用途。优化后：在assembler_riscv.hpp中为x28-x31寄存器添加t3-t6别名定义，并在stubGenerator_riscv.cpp中将所有x28-x31的使用替换为对应的t3-t6别名。优化思路：通过使用寄存器别名提高代码可读性和维护性，使代码更符合RISC-V ABI规范，便于开发者理解寄存器用途，同时保持相同的运行时性能。"}
{"id": 690, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前：对于紧密耦合的初始化存储，使用异或操作（^）切换预屏障标志，可能导致不必要的屏障开销。优化后：通过位清除操作（& ~）明确移除预屏障标志，避免不必要的内存屏障。优化思路：在紧密耦合的初始化存储场景中，预屏障是不必要的，直接清除标志比切换标志更高效，减少了内存屏障的开销。", "original_code": "对于紧密耦合的初始化存储，使用异或操作（^）切换预屏障标志，可能导致不必要的屏障开销。", "optimized_code": "-      access.set_barrier_data(access.barrier_data() ^ G1C2BarrierPre);\n+      // Pre-barriers are unnecessary for tightly-coupled initialization stores.\n+      access.set_barrier_data(access.barrier_data() & ~G1C2BarrierPre);", "source_url": "https://github.com/openjdk/riscv-port/commit/81ebbb2463df8b014bb209dc4028668fc78e8327", "code_v0_no_empty_lines": "对于紧密耦合的初始化存储，使用异或操作（^）切换预屏障标志，可能导致不必要的屏障开销。", "code_v1_no_empty_lines": "-      access.set_barrier_data(access.barrier_data() ^ G1C2BarrierPre);\n+      // Pre-barriers are unnecessary for tightly-coupled initialization stores.\n+      access.set_barrier_data(access.barrier_data() & ~G1C2BarrierPre);", "target": "-      access.set_barrier_data(access.barrier_data() ^ G1C2BarrierPre);\n+      // Pre-barriers are unnecessary for tightly-coupled initialization stores.\n+      access.set_barrier_data(access.barrier_data() & ~G1C2BarrierPre);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于紧密耦合的初始化存储，使用异或操作（^）切换预屏障标志，可能导致不必要的屏障开销。优化后：通过位清除操作（& ~）明确移除预屏障标志，避免不必要的内存屏障。优化思路：在紧密耦合的初始化存储场景中，预屏障是不必要的，直接清除标志比切换标志更高效，减少了内存屏障的开销。"}
{"id": 691, "source": "riscv-dataset-excel", "optimization_type": "代码优化+性能优化", "optimization_description": "优化前：在StackMapGenerator::processInvokeInstructions等方法中，通过nameAndType()获取方法类型符号，需要额外解析名称和类型信息。优化后：直接调用type()方法获取已计算好的类型信息，避免重复解析。思路：减少方法调用链长度，消除不必要的中间步骤，提高字节码处理性能。", "original_code": "在StackMapGenerator::processInvokeInstructions等方法中，通过nameAndType()获取方法类型符号，需要额外解析名称和类型信息。", "optimized_code": "- var mtd = Util.methodTypeSymbol(nameAndType);\n+ var mtd = Util.methodTypeSymbol(nameAndType.type());", "source_url": "https://github.com/openjdk/riscv-port/commit/1c3e56c3e45be3626afec0461d4ae8059b0b577f", "code_v0_no_empty_lines": "在StackMapGenerator::processInvokeInstructions等方法中，通过nameAndType()获取方法类型符号，需要额外解析名称和类型信息。", "code_v1_no_empty_lines": "- var mtd = Util.methodTypeSymbol(nameAndType);\n+ var mtd = Util.methodTypeSymbol(nameAndType.type());", "target": "- var mtd = Util.methodTypeSymbol(nameAndType);\n+ var mtd = Util.methodTypeSymbol(nameAndType.type());", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在StackMapGenerator::processInvokeInstructions等方法中，通过nameAndType()获取方法类型符号，需要额外解析名称和类型信息。优化后：直接调用type()方法获取已计算好的类型信息，避免重复解析。思路：减少方法调用链长度，消除不必要的中间步骤，提高字节码处理性能。"}
{"id": 692, "source": "riscv-dataset-excel", "optimization_type": "代码简化+性能优化", "optimization_description": "优化前：1. 通过nameAndType()间接获取类型符号，增加方法调用开销；2. 使用多个popStack()调用处理栈操作，代码冗余且效率较低。优化后：1. 直接调用type()方法获取类型符号，减少间接调用；2. 统一使用decStack()方法处理栈操作，减少方法调用次数并简化代码逻辑。优化思路：通过消除中间调用层和合并重复操作，减少运行时开销，提高字节码处理性能。", "original_code": "1. 通过nameAndType()间接获取类型符号，增加方法调用开销；2. 使用多个popStack()调用处理栈操作，代码冗余且效率较低。", "optimized_code": "private void processFieldInstructions(RawBytecodeHelper bcs) {\n-        var desc = Util.fieldTypeSymbol(cp.entryByIndex(bcs.getIndexU2(), MemberRefEntry.class).nameAndType());\n+        var desc = Util.fieldTypeSymbol(cp.entryByIndex(bcs.getIndexU2(), MemberRefEntry.class).type());\n+        var currentFrame = this.currentFrame;\n         switch (bcs.opcode()) {\n             case GETSTATIC ->\n                 currentFrame.pushStack(desc);\n             case PUTSTATIC -> {\n-                currentFrame.popStack();\n-                if (Util.isDoubleSlot(desc)) currentFrame.popStack();\n+                currentFrame.decStack(Util.isDoubleSlot(desc) ? 2 : 1);\n             }\n             case GETFIELD -> {\n-                currentFrame.popStack();\n+                currentFrame.decStack(1);\n                 currentFrame.pushStack(desc);\n             }\n             case PUTFIELD -> {\n-                currentFrame.popStack();\n-                currentFrame.popStack();\n-                if (Util.isDoubleSlot(desc)) currentFrame.popStack();\n+                currentFrame.decStack(Util.isDoubleSlot(desc) ? 3 : 2);\n             }\n             default -> throw new AssertionError(\"Should not reach here\");\n         }\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/f8db3a831b61bb585c5494a7a8657e37000892b4", "code_v0_no_empty_lines": "1. 通过nameAndType()间接获取类型符号，增加方法调用开销；2. 使用多个popStack()调用处理栈操作，代码冗余且效率较低。", "code_v1_no_empty_lines": "private void processFieldInstructions(RawBytecodeHelper bcs) {\n-        var desc = Util.fieldTypeSymbol(cp.entryByIndex(bcs.getIndexU2(), MemberRefEntry.class).nameAndType());\n+        var desc = Util.fieldTypeSymbol(cp.entryByIndex(bcs.getIndexU2(), MemberRefEntry.class).type());\n+        var currentFrame = this.currentFrame;\n         switch (bcs.opcode()) {\n             case GETSTATIC ->\n                 currentFrame.pushStack(desc);\n             case PUTSTATIC -> {\n-                currentFrame.popStack();\n-                if (Util.isDoubleSlot(desc)) currentFrame.popStack();\n+                currentFrame.decStack(Util.isDoubleSlot(desc) ? 2 : 1);\n             }\n             case GETFIELD -> {\n-                currentFrame.popStack();\n+                currentFrame.decStack(1);\n                 currentFrame.pushStack(desc);\n             }\n             case PUTFIELD -> {\n-                currentFrame.popStack();\n-                currentFrame.popStack();\n-                if (Util.isDoubleSlot(desc)) currentFrame.popStack();\n+                currentFrame.decStack(Util.isDoubleSlot(desc) ? 3 : 2);\n             }\n             default -> throw new AssertionError(\"Should not reach here\");\n         }\n     }", "target": "private void processFieldInstructions(RawBytecodeHelper bcs) {\n-        var desc = Util.fieldTypeSymbol(cp.entryByIndex(bcs.getIndexU2(), MemberRefEntry.class).nameAndType());\n+        var desc = Util.fieldTypeSymbol(cp.entryByIndex(bcs.getIndexU2(), MemberRefEntry.class).type());\n+        var currentFrame = this.currentFrame;\n         switch (bcs.opcode()) {\n             case GETSTATIC ->\n                 currentFrame.pushStack(desc);\n             case PUTSTATIC -> {\n-                currentFrame.popStack();\n-                if (Util.isDoubleSlot(desc)) currentFrame.popStack();\n+                currentFrame.decStack(Util.isDoubleSlot(desc) ? 2 : 1);\n             }\n             case GETFIELD -> {\n-                currentFrame.popStack();\n+                currentFrame.decStack(1);\n                 currentFrame.pushStack(desc);\n             }\n             case PUTFIELD -> {\n-                currentFrame.popStack();\n-                currentFrame.popStack();\n-                if (Util.isDoubleSlot(desc)) currentFrame.popStack();\n+                currentFrame.decStack(Util.isDoubleSlot(desc) ? 3 : 2);\n             }\n             default -> throw new AssertionError(\"Should not reach here\");\n         }\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 通过nameAndType()间接获取类型符号，增加方法调用开销；2. 使用多个popStack()调用处理栈操作，代码冗余且效率较低。优化后：1. 直接调用type()方法获取类型符号，减少间接调用；2. 统一使用decStack()方法处理栈操作，减少方法调用次数并简化代码逻辑。优化思路：通过消除中间调用层和合并重复操作，减少运行时开销，提高字节码处理性能。"}
{"id": 693, "source": "riscv-dataset-excel", "optimization_type": "字符串处理性能优化", "optimization_description": "优化前：DataOutputStream.writeUTF()通过手动遍历字符串字符计算UTF长度并逐个编码，涉及多次charAt()调用和条件判断。优化后：1) 使用JavaLangAccess.countNonZeroAscii()快速统计ASCII字符数量；2) 新增ModifiedUtf工具类集中处理UTF编码逻辑；3) 对ASCII字符使用str.getBytes()批量复制，减少方法调用和边界检查。优化思路：将字符级操作提升为批量操作，减少方法调用开销，利用平台内部优化提升字符串处理性能。", "original_code": "DataOutputStream.writeUTF()通过手动遍历字符串字符计算UTF长度并逐个编码，涉及多次charAt()调用和条件判断。", "optimized_code": "- int utflen = strlen; // optimized for ASCII\n- for (int i = 0; i < strlen; i++) {\n-     int c = str.charAt(i);\n-     if (c >= 0x80 || c == 0)\n-         utflen += (c >= 0x800) ? 2 : 1;\n- }\n+ int countNonZeroAscii = JLA.countNonZeroAscii(str);\n+ int utflen = utfLen(str, countNonZeroAscii);\n- for (i = 0; i < strlen; i++) { // optimized for initial run of ASCII\n-     int c = str.charAt(i);\n-     if (c >= 0x80 || c == 0) break;\n-     bytearr[count++] = (byte) c;\n- }\n+ str.getBytes(0, countNonZeroAscii, bytearr, count);\n+ count += countNonZeroAscii;", "source_url": "https://github.com/openjdk/riscv-port/commit/b42fbf43dfd62ae64973ff0e406b6609cd8e1aa6", "code_v0_no_empty_lines": "DataOutputStream.writeUTF()通过手动遍历字符串字符计算UTF长度并逐个编码，涉及多次charAt()调用和条件判断。", "code_v1_no_empty_lines": "- int utflen = strlen; // optimized for ASCII\n- for (int i = 0; i < strlen; i++) {\n-     int c = str.charAt(i);\n-     if (c >= 0x80 || c == 0)\n-         utflen += (c >= 0x800) ? 2 : 1;\n- }\n+ int countNonZeroAscii = JLA.countNonZeroAscii(str);\n+ int utflen = utfLen(str, countNonZeroAscii);\n- for (i = 0; i < strlen; i++) { // optimized for initial run of ASCII\n-     int c = str.charAt(i);\n-     if (c >= 0x80 || c == 0) break;\n-     bytearr[count++] = (byte) c;\n- }\n+ str.getBytes(0, countNonZeroAscii, bytearr, count);\n+ count += countNonZeroAscii;", "target": "- int utflen = strlen; // optimized for ASCII\n- for (int i = 0; i < strlen; i++) {\n-     int c = str.charAt(i);\n-     if (c >= 0x80 || c == 0)\n-         utflen += (c >= 0x800) ? 2 : 1;\n- }\n+ int countNonZeroAscii = JLA.countNonZeroAscii(str);\n+ int utflen = utfLen(str, countNonZeroAscii);\n- for (i = 0; i < strlen; i++) { // optimized for initial run of ASCII\n-     int c = str.charAt(i);\n-     if (c >= 0x80 || c == 0) break;\n-     bytearr[count++] = (byte) c;\n- }\n+ str.getBytes(0, countNonZeroAscii, bytearr, count);\n+ count += countNonZeroAscii;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：DataOutputStream.writeUTF()通过手动遍历字符串字符计算UTF长度并逐个编码，涉及多次charAt()调用和条件判断。优化后：1) 使用JavaLangAccess.countNonZeroAscii()快速统计ASCII字符数量；2) 新增ModifiedUtf工具类集中处理UTF编码逻辑；3) 对ASCII字符使用str.getBytes()批量复制，减少方法调用和边界检查。优化思路：将字符级操作提升为批量操作，减少方法调用开销，利用平台内部优化提升字符串处理性能。"}
{"id": 694, "source": "riscv-dataset-excel", "optimization_type": "锁竞争优化+批处理优化", "optimization_description": "优化前：每次获取堆锁后处理垃圾区域直到30微秒超时，频繁的锁获取和释放导致高锁竞争开销。优化后：1) 将超时时间缩短为10微秒，减少单次锁持有时间；2) 引入批处理机制（每批32个区域），减少锁获取次数；3) 使用时间预测模型（基于历史批处理时间估计）动态决定是否继续处理下一批，避免频繁的时间查询；4) 只在非首次迭代时执行yield操作。优化思路：通过减少锁持有时间和锁获取频率来降低多线程环境下的锁竞争，同时通过批处理和时间预测提高处理效率。", "original_code": "每次获取堆锁后处理垃圾区域直到30微秒超时，频繁的锁获取和释放导致高锁竞争开销。", "optimized_code": "-  // Relinquish the lock after this much time passed.\n-  static constexpr jlong deadline_ns = 30000; // 30 us\n-  size_t idx = 0;\n-  while (idx < count) {\n-    os::naked_yield(); // Yield to allow allocators to take the lock\n-    ShenandoahHeapLocker locker(_heap->lock());\n-    const jlong deadline = os::javaTimeNanos() + deadline_ns;\n-    while (idx < count && os::javaTimeNanos() < deadline) {\n-      try_recycle_trashed(_trash_regions[idx++]);\n-    }\n-  }\n+  size_t total_batches = 0;\n+  jlong batch_start_time = 0;\n+  jlong recycle_trash_start_time = os::javaTimeNanos();    // This value will be treated as the initial batch_start_time\n+  jlong batch_end_time = recycle_trash_start_time;\n+  // Process as many batches as can be processed within 10 us.\n+  static constexpr jlong deadline_ns = 10000;               // 10 us\n+  size_t idx = 0;\n+  jlong predicted_next_batch_end_time;\n+  jlong batch_process_time_estimate = 0;\n+  while (idx < count) {\n+    if (idx > 0) {\n+      os::naked_yield(); // Yield to allow allocators to take the lock, except on the first iteration\n+    }\n+    // Avoid another call to javaTimeNanos() if we already know time at which last batch ended\n+    batch_start_time = batch_end_time;\n+    const jlong deadline = batch_start_time + deadline_ns;\n+\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    do {\n+      // Measurements on typical 2024 hardware suggest it typically requires between 1400 and 2000 ns to process a batch of\n+      // 32 regions, assuming low contention with other threads.  Sometimes this goes higher, when mutator threads\n+      // are contending for CPU cores and/or the heap lock.  On this hardware with a 10 us deadline, we expect 3-6 batches\n+      // to be processed between yields most of the time.\n+      //\n+      // Note that deadline is enforced since the end of previous batch.  In the case that yield() or acquisition of heap lock\n+      // takes a \"long time\", we will have less time to process regions, but we will always process at least one batch between\n+      // yields.  Yielding more frequently when there is heavy contention for the heap lock or for CPU cores is considered the\n+      // right thing to do.\n+      const size_t REGIONS_PER_BATCH = 32;\n+      size_t max_idx = MIN2(count, idx + REGIONS_PER_BATCH);\n+      while (idx < max_idx) {\n+        try_recycle_trashed(_trash_regions[idx++]);\n+      }\n+      total_batches++;\n+      batch_end_time = os::javaTimeNanos();\n+      // Estimate includes historic combination of yield times and heap lock acquisition times.\n+      batch_process_time_estimate = (batch_end_time - recycle_trash_start_time) / total_batches;\n+      predicted_next_batch_end_time = batch_end_time + batch_process_time_estimate;\n+    } while ((idx < count) && (predicted_next_batch_end_time < deadline));\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/f5f0852f51d3dc1001bf3d68b89f4aab31e05e61", "code_v0_no_empty_lines": "每次获取堆锁后处理垃圾区域直到30微秒超时，频繁的锁获取和释放导致高锁竞争开销。", "code_v1_no_empty_lines": "-  // Relinquish the lock after this much time passed.\n-  static constexpr jlong deadline_ns = 30000; // 30 us\n-  size_t idx = 0;\n-  while (idx < count) {\n-    os::naked_yield(); // Yield to allow allocators to take the lock\n-    ShenandoahHeapLocker locker(_heap->lock());\n-    const jlong deadline = os::javaTimeNanos() + deadline_ns;\n-    while (idx < count && os::javaTimeNanos() < deadline) {\n-      try_recycle_trashed(_trash_regions[idx++]);\n-    }\n-  }\n+  size_t total_batches = 0;\n+  jlong batch_start_time = 0;\n+  jlong recycle_trash_start_time = os::javaTimeNanos();    // This value will be treated as the initial batch_start_time\n+  jlong batch_end_time = recycle_trash_start_time;\n+  // Process as many batches as can be processed within 10 us.\n+  static constexpr jlong deadline_ns = 10000;               // 10 us\n+  size_t idx = 0;\n+  jlong predicted_next_batch_end_time;\n+  jlong batch_process_time_estimate = 0;\n+  while (idx < count) {\n+    if (idx > 0) {\n+      os::naked_yield(); // Yield to allow allocators to take the lock, except on the first iteration\n+    }\n+    // Avoid another call to javaTimeNanos() if we already know time at which last batch ended\n+    batch_start_time = batch_end_time;\n+    const jlong deadline = batch_start_time + deadline_ns;\n+\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    do {\n+      // Measurements on typical 2024 hardware suggest it typically requires between 1400 and 2000 ns to process a batch of\n+      // 32 regions, assuming low contention with other threads.  Sometimes this goes higher, when mutator threads\n+      // are contending for CPU cores and/or the heap lock.  On this hardware with a 10 us deadline, we expect 3-6 batches\n+      // to be processed between yields most of the time.\n+      //\n+      // Note that deadline is enforced since the end of previous batch.  In the case that yield() or acquisition of heap lock\n+      // takes a \"long time\", we will have less time to process regions, but we will always process at least one batch between\n+      // yields.  Yielding more frequently when there is heavy contention for the heap lock or for CPU cores is considered the\n+      // right thing to do.\n+      const size_t REGIONS_PER_BATCH = 32;\n+      size_t max_idx = MIN2(count, idx + REGIONS_PER_BATCH);\n+      while (idx < max_idx) {\n+        try_recycle_trashed(_trash_regions[idx++]);\n+      }\n+      total_batches++;\n+      batch_end_time = os::javaTimeNanos();\n+      // Estimate includes historic combination of yield times and heap lock acquisition times.\n+      batch_process_time_estimate = (batch_end_time - recycle_trash_start_time) / total_batches;\n+      predicted_next_batch_end_time = batch_end_time + batch_process_time_estimate;\n+    } while ((idx < count) && (predicted_next_batch_end_time < deadline));\n+  }", "target": "-  // Relinquish the lock after this much time passed.\n-  static constexpr jlong deadline_ns = 30000; // 30 us\n-  size_t idx = 0;\n-  while (idx < count) {\n-    os::naked_yield(); // Yield to allow allocators to take the lock\n-    ShenandoahHeapLocker locker(_heap->lock());\n-    const jlong deadline = os::javaTimeNanos() + deadline_ns;\n-    while (idx < count && os::javaTimeNanos() < deadline) {\n-      try_recycle_trashed(_trash_regions[idx++]);\n-    }\n-  }\n+  size_t total_batches = 0;\n+  jlong batch_start_time = 0;\n+  jlong recycle_trash_start_time = os::javaTimeNanos();    // This value will be treated as the initial batch_start_time\n+  jlong batch_end_time = recycle_trash_start_time;\n+  // Process as many batches as can be processed within 10 us.\n+  static constexpr jlong deadline_ns = 10000;               // 10 us\n+  size_t idx = 0;\n+  jlong predicted_next_batch_end_time;\n+  jlong batch_process_time_estimate = 0;\n+  while (idx < count) {\n+    if (idx > 0) {\n+      os::naked_yield(); // Yield to allow allocators to take the lock, except on the first iteration\n+    }\n+    // Avoid another call to javaTimeNanos() if we already know time at which last batch ended\n+    batch_start_time = batch_end_time;\n+    const jlong deadline = batch_start_time + deadline_ns;\n+\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    do {\n+      // Measurements on typical 2024 hardware suggest it typically requires between 1400 and 2000 ns to process a batch of\n+      // 32 regions, assuming low contention with other threads.  Sometimes this goes higher, when mutator threads\n+      // are contending for CPU cores and/or the heap lock.  On this hardware with a 10 us deadline, we expect 3-6 batches\n+      // to be processed between yields most of the time.\n+      //\n+      // Note that deadline is enforced since the end of previous batch.  In the case that yield() or acquisition of heap lock\n+      // takes a \"long time\", we will have less time to process regions, but we will always process at least one batch between\n+      // yields.  Yielding more frequently when there is heavy contention for the heap lock or for CPU cores is considered the\n+      // right thing to do.\n+      const size_t REGIONS_PER_BATCH = 32;\n+      size_t max_idx = MIN2(count, idx + REGIONS_PER_BATCH);\n+      while (idx < max_idx) {\n+        try_recycle_trashed(_trash_regions[idx++]);\n+      }\n+      total_batches++;\n+      batch_end_time = os::javaTimeNanos();\n+      // Estimate includes historic combination of yield times and heap lock acquisition times.\n+      batch_process_time_estimate = (batch_end_time - recycle_trash_start_time) / total_batches;\n+      predicted_next_batch_end_time = batch_end_time + batch_process_time_estimate;\n+    } while ((idx < count) && (predicted_next_batch_end_time < deadline));\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次获取堆锁后处理垃圾区域直到30微秒超时，频繁的锁获取和释放导致高锁竞争开销。优化后：1) 将超时时间缩短为10微秒，减少单次锁持有时间；2) 引入批处理机制（每批32个区域），减少锁获取次数；3) 使用时间预测模型（基于历史批处理时间估计）动态决定是否继续处理下一批，避免频繁的时间查询；4) 只在非首次迭代时执行yield操作。优化思路：通过减少锁持有时间和锁获取频率来降低多线程环境下的锁竞争，同时通过批处理和时间预测提高处理效率。"}
{"id": 695, "source": "riscv-dataset-excel", "optimization_type": "内存分配路径优化", "optimization_description": "优化前：内存碎片整理（defragment）操作在分配路径中执行，当分配过程中发现需要整理碎片时，会中断分配流程并执行整理操作，增加了分配延迟。\n优化后：将碎片整理操作从分配路径中移除，改为在页面释放路径中可选执行。通过新增prepare_to_recycle()函数，在释放页面时根据allow_defragment参数决定是否执行碎片整理。\n优化思路：将碎片整理这种可能耗时的操作从关键分配路径中移出，减少分配延迟，提高内存分配性能，同时通过控制参数保持碎片整理功能在适当场景下可用。", "original_code": "内存碎片整理（defragment）操作在分配路径中执行，当分配过程中发现需要整理碎片时，会中断分配流程并执行整理操作，增加了分配延迟。", "optimized_code": "- void ZPageAllocator::free_page(ZPage* page) {\n+ void ZPageAllocator::free_page(ZPage* page, bool allow_defragment) {\n  // ...\n- ZPage* const to_recycle = _safe_recycle.register_and_clone_if_activated(page);\n+ ZPage* const to_recycle = prepare_to_recycle(page, allow_defragment);\n\n+ ZPage* ZPageAllocator::prepare_to_recycle(ZPage* page, bool allow_defragment) {\n+   // Make sure we have a page that is safe to recycle\n+   ZPage* const to_recycle = _safe_recycle.register_and_clone_if_activated(page);\n+ \n+   // Defragment the page before recycle if allowed and needed\n+   if (allow_defragment && should_defragment(to_recycle)) {\n+     return defragment_page(to_recycle);\n+   }\n+ \n+   return to_recycle;\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/ec020f3fc988553ad1eda460d889b5ba24e76e8e", "code_v0_no_empty_lines": "内存碎片整理（defragment）操作在分配路径中执行，当分配过程中发现需要整理碎片时，会中断分配流程并执行整理操作，增加了分配延迟。", "code_v1_no_empty_lines": "- void ZPageAllocator::free_page(ZPage* page) {\n+ void ZPageAllocator::free_page(ZPage* page, bool allow_defragment) {\n  // ...\n- ZPage* const to_recycle = _safe_recycle.register_and_clone_if_activated(page);\n+ ZPage* const to_recycle = prepare_to_recycle(page, allow_defragment);\n\n+ ZPage* ZPageAllocator::prepare_to_recycle(ZPage* page, bool allow_defragment) {\n+   // Make sure we have a page that is safe to recycle\n+   ZPage* const to_recycle = _safe_recycle.register_and_clone_if_activated(page);\n+ \n+   // Defragment the page before recycle if allowed and needed\n+   if (allow_defragment && should_defragment(to_recycle)) {\n+     return defragment_page(to_recycle);\n+   }\n+ \n+   return to_recycle;\n+ }", "target": "- void ZPageAllocator::free_page(ZPage* page) {\n+ void ZPageAllocator::free_page(ZPage* page, bool allow_defragment) {\n  // ...\n- ZPage* const to_recycle = _safe_recycle.register_and_clone_if_activated(page);\n+ ZPage* const to_recycle = prepare_to_recycle(page, allow_defragment);\n\n+ ZPage* ZPageAllocator::prepare_to_recycle(ZPage* page, bool allow_defragment) {\n+   // Make sure we have a page that is safe to recycle\n+   ZPage* const to_recycle = _safe_recycle.register_and_clone_if_activated(page);\n+ \n+   // Defragment the page before recycle if allowed and needed\n+   if (allow_defragment && should_defragment(to_recycle)) {\n+     return defragment_page(to_recycle);\n+   }\n+ \n+   return to_recycle;\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：内存碎片整理（defragment）操作在分配路径中执行，当分配过程中发现需要整理碎片时，会中断分配流程并执行整理操作，增加了分配延迟。\n优化后：将碎片整理操作从分配路径中移除，改为在页面释放路径中可选执行。通过新增prepare_to_recycle()函数，在释放页面时根据allow_defragment参数决定是否执行碎片整理。\n优化思路：将碎片整理这种可能耗时的操作从关键分配路径中移出，减少分配延迟，提高内存分配性能，同时通过控制参数保持碎片整理功能在适当场景下可用。"}
{"id": 696, "source": "riscv-dataset-excel", "optimization_type": "内联优化", "optimization_description": "优化前：MethodHandle::asType方法在内存段变量句柄调用中未能内联，导致额外的调用开销。优化后：1. 为asType方法添加@ForceInline注解，强制编译器内联快速路径；2. 将setAsTypeCache方法参数从MethodHandle改为MethodType，并在方法内部调用asTypeUncached，同时添加@DontInline注解防止慢速路径代码过度内联。优化思路：通过精细控制内联策略，既确保常见快速路径能够内联以减少调用开销，又避免慢速路径代码过度内联导致方法体过大影响性能，从而提升内存段变量句柄调用的性能。", "original_code": "MethodHandle::asType方法在内存段变量句柄调用中未能内联，导致额外的调用开销。", "optimized_code": "@ForceInline\n    public final MethodHandle asType(MethodType newType) {\n        // Fast path alternative to a heavyweight {@code asType} call.\n        // Return 'this' if the conversion will be a no-op.\n        if (type == newType) {\n            return this;\n        }\n        MethodHandle at = asTypeCached(newType);\n        if (at != null) {\n            return at;\n        }\n        return setAsTypeCache(newType);\n    }\n\n    /*\n     * We disable inlining here to prevent complex code in the slow path\n     * of MethodHandle::asType from being inlined into that method.\n     * Excessive inlining into MethodHandle::asType can cause that method\n     * to become too big, which will then cause performance issues during\n     * var handle and method handle calls.\n     */\n    @DontInline\n    private MethodHandle setAsTypeCache(MethodType newType) {\n        MethodHandle at = asTypeUncached(newType);\n        // Don't introduce a strong reference in the cache if newType depends on any class loader other than\n        // current method handle already does to avoid class loader leaks.\n        if (isSafeToCache(at.type)) {\n            asTypeCache = newType;\n            asTypeCacheTarget = at;\n        }\n        return at;\n    }", "source_url": "https://github.com/openjdk/riscv-port/commit/7fa2f229fbee68112cbdd18b811d95721adfe2ec", "code_v0_no_empty_lines": "MethodHandle::asType方法在内存段变量句柄调用中未能内联，导致额外的调用开销。", "code_v1_no_empty_lines": "@ForceInline\n    public final MethodHandle asType(MethodType newType) {\n        // Fast path alternative to a heavyweight {@code asType} call.\n        // Return 'this' if the conversion will be a no-op.\n        if (type == newType) {\n            return this;\n        }\n        MethodHandle at = asTypeCached(newType);\n        if (at != null) {\n            return at;\n        }\n        return setAsTypeCache(newType);\n    }\n\n    /*\n     * We disable inlining here to prevent complex code in the slow path\n     * of MethodHandle::asType from being inlined into that method.\n     * Excessive inlining into MethodHandle::asType can cause that method\n     * to become too big, which will then cause performance issues during\n     * var handle and method handle calls.\n     */\n    @DontInline\n    private MethodHandle setAsTypeCache(MethodType newType) {\n        MethodHandle at = asTypeUncached(newType);\n        // Don't introduce a strong reference in the cache if newType depends on any class loader other than\n        // current method handle already does to avoid class loader leaks.\n        if (isSafeToCache(at.type)) {\n            asTypeCache = newType;\n            asTypeCacheTarget = at;\n        }\n        return at;\n    }", "target": "@ForceInline\n    public final MethodHandle asType(MethodType newType) {\n        // Fast path alternative to a heavyweight {@code asType} call.\n        // Return 'this' if the conversion will be a no-op.\n        if (type == newType) {\n            return this;\n        }\n        MethodHandle at = asTypeCached(newType);\n        if (at != null) {\n            return at;\n        }\n        return setAsTypeCache(newType);\n    }\n\n    /*\n     * We disable inlining here to prevent complex code in the slow path\n     * of MethodHandle::asType from being inlined into that method.\n     * Excessive inlining into MethodHandle::asType can cause that method\n     * to become too big, which will then cause performance issues during\n     * var handle and method handle calls.\n     */\n    @DontInline\n    private MethodHandle setAsTypeCache(MethodType newType) {\n        MethodHandle at = asTypeUncached(newType);\n        // Don't introduce a strong reference in the cache if newType depends on any class loader other than\n        // current method handle already does to avoid class loader leaks.\n        if (isSafeToCache(at.type)) {\n            asTypeCache = newType;\n            asTypeCacheTarget = at;\n        }\n        return at;\n    }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：MethodHandle::asType方法在内存段变量句柄调用中未能内联，导致额外的调用开销。优化后：1. 为asType方法添加@ForceInline注解，强制编译器内联快速路径；2. 将setAsTypeCache方法参数从MethodHandle改为MethodType，并在方法内部调用asTypeUncached，同时添加@DontInline注解防止慢速路径代码过度内联。优化思路：通过精细控制内联策略，既确保常见快速路径能够内联以减少调用开销，又避免慢速路径代码过度内联导致方法体过大影响性能，从而提升内存段变量句柄调用的性能。"}
{"id": 697, "source": "riscv-dataset-excel", "optimization_type": "内存优化+平台特性支持", "optimization_description": "优化前：Windows平台Hotspot仅支持单一的大页尺寸（最大4MB），且对AMD64架构有硬性限制。优化后：通过新增EnableAllLargePageSizesForWindows标志，支持Windows Server上的多种大页尺寸（如2MB、4MB、8MB等），并移除了AMD64架构的4MB限制。优化思路：1) 引入配置开关控制多尺寸大页支持；2) 在large_page_init()中动态构建大页尺寸列表（按2的幂次递增）；3) 修改pd_reserve_memory_special()移除对单一页尺寸的断言，适配多尺寸场景；4) 增强错误提示和参数校验逻辑。", "original_code": "Windows平台Hotspot仅支持单一的大页尺寸（最大4MB），且对AMD64架构有硬性限制。", "optimized_code": "--- a/src/hotspot/os/windows/os_windows.cpp\n+++ b/src/hotspot/os/windows/os_windows.cpp\n@@ -3328,15 +3328,26 @@ static size_t large_page_init_decide_size() {\n     return 0;\n   }\n \n-#if defined(IA32) || defined(AMD64)\n-  if (size > 4*M || LargePageSizeInBytes > 4*M) {\n+#if defined(IA32)\n+  if (size > 4 * M || LargePageSizeInBytes > 4 * M) {\n     WARN(\"JVM cannot use large pages bigger than 4mb.\");\n     return 0;\n   }\n+#elif defined(AMD64)\n+  if (!EnableAllLargePageSizesForWindows) {\n+    if (size > 4 * M || LargePageSizeInBytes > 4 * M) {\n+      WARN(\"JVM cannot use large pages bigger than 4mb.\");\n+      return 0;\n+    }\n+  }\n #endif\n \n-  if (LargePageSizeInBytes > 0 && LargePageSizeInBytes % size == 0) {\n-    size = LargePageSizeInBytes;\n+  if (LargePageSizeInBytes > 0) {\n+    if (LargePageSizeInBytes % size == 0) {\n+      size = LargePageSizeInBytes;\n+    } else {\n+      WARN(\"The specified large page size (%d) is not a multiple of the minimum large page size (%d), defaulting to minimum page size.\", LargePageSizeInBytes, size);\n+    }\n   }\n \n #undef WARN\n@@ -3349,12 +3360,23 @@ void os::large_page_init() {\n     return;\n   }\n \n-  _large_page_size = large_page_init_decide_size();\n+  _large_page_size = os::win32::large_page_init_decide_size();\n   const size_t default_page_size = os::vm_page_size();\n   if (_large_page_size > default_page_size) {\n+#if !defined(IA32)\n+    if (EnableAllLargePageSizesForWindows) {\n+      size_t min_size = GetLargePageMinimum();\n+\n+      // Populate _page_sizes with large page sizes less than or equal to _large_page_size, ensuring each page size is double the size of the previous one.\n+      for (size_t page_size = min_size; page_size < _large_page_size; page_size *= 2) {\n+        _page_sizes.add(page_size);\n+      }\n+    }\n+#endif\n+\n     _page_sizes.add(_large_page_size);\n   }\n-\n+  // Set UseLargePages based on whether a large page size was successfully determined\n   UseLargePages = _large_page_size != 0;\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/4ded28380b6756e0679d80706f76bd6e78c370b9", "code_v0_no_empty_lines": "Windows平台Hotspot仅支持单一的大页尺寸（最大4MB），且对AMD64架构有硬性限制。", "code_v1_no_empty_lines": "--- a/src/hotspot/os/windows/os_windows.cpp\n+++ b/src/hotspot/os/windows/os_windows.cpp\n@@ -3328,15 +3328,26 @@ static size_t large_page_init_decide_size() {\n     return 0;\n   }\n \n-#if defined(IA32) || defined(AMD64)\n-  if (size > 4*M || LargePageSizeInBytes > 4*M) {\n+#if defined(IA32)\n+  if (size > 4 * M || LargePageSizeInBytes > 4 * M) {\n     WARN(\"JVM cannot use large pages bigger than 4mb.\");\n     return 0;\n   }\n+#elif defined(AMD64)\n+  if (!EnableAllLargePageSizesForWindows) {\n+    if (size > 4 * M || LargePageSizeInBytes > 4 * M) {\n+      WARN(\"JVM cannot use large pages bigger than 4mb.\");\n+      return 0;\n+    }\n+  }\n #endif\n \n-  if (LargePageSizeInBytes > 0 && LargePageSizeInBytes % size == 0) {\n-    size = LargePageSizeInBytes;\n+  if (LargePageSizeInBytes > 0) {\n+    if (LargePageSizeInBytes % size == 0) {\n+      size = LargePageSizeInBytes;\n+    } else {\n+      WARN(\"The specified large page size (%d) is not a multiple of the minimum large page size (%d), defaulting to minimum page size.\", LargePageSizeInBytes, size);\n+    }\n   }\n \n #undef WARN\n@@ -3349,12 +3360,23 @@ void os::large_page_init() {\n     return;\n   }\n \n-  _large_page_size = large_page_init_decide_size();\n+  _large_page_size = os::win32::large_page_init_decide_size();\n   const size_t default_page_size = os::vm_page_size();\n   if (_large_page_size > default_page_size) {\n+#if !defined(IA32)\n+    if (EnableAllLargePageSizesForWindows) {\n+      size_t min_size = GetLargePageMinimum();\n+\n+      // Populate _page_sizes with large page sizes less than or equal to _large_page_size, ensuring each page size is double the size of the previous one.\n+      for (size_t page_size = min_size; page_size < _large_page_size; page_size *= 2) {\n+        _page_sizes.add(page_size);\n+      }\n+    }\n+#endif\n+\n     _page_sizes.add(_large_page_size);\n   }\n-\n+  // Set UseLargePages based on whether a large page size was successfully determined\n   UseLargePages = _large_page_size != 0;\n }", "target": "--- a/src/hotspot/os/windows/os_windows.cpp\n+++ b/src/hotspot/os/windows/os_windows.cpp\n@@ -3328,15 +3328,26 @@ static size_t large_page_init_decide_size() {\n     return 0;\n   }\n \n-#if defined(IA32) || defined(AMD64)\n-  if (size > 4*M || LargePageSizeInBytes > 4*M) {\n+#if defined(IA32)\n+  if (size > 4 * M || LargePageSizeInBytes > 4 * M) {\n     WARN(\"JVM cannot use large pages bigger than 4mb.\");\n     return 0;\n   }\n+#elif defined(AMD64)\n+  if (!EnableAllLargePageSizesForWindows) {\n+    if (size > 4 * M || LargePageSizeInBytes > 4 * M) {\n+      WARN(\"JVM cannot use large pages bigger than 4mb.\");\n+      return 0;\n+    }\n+  }\n #endif\n \n-  if (LargePageSizeInBytes > 0 && LargePageSizeInBytes % size == 0) {\n-    size = LargePageSizeInBytes;\n+  if (LargePageSizeInBytes > 0) {\n+    if (LargePageSizeInBytes % size == 0) {\n+      size = LargePageSizeInBytes;\n+    } else {\n+      WARN(\"The specified large page size (%d) is not a multiple of the minimum large page size (%d), defaulting to minimum page size.\", LargePageSizeInBytes, size);\n+    }\n   }\n \n #undef WARN\n@@ -3349,12 +3360,23 @@ void os::large_page_init() {\n     return;\n   }\n \n-  _large_page_size = large_page_init_decide_size();\n+  _large_page_size = os::win32::large_page_init_decide_size();\n   const size_t default_page_size = os::vm_page_size();\n   if (_large_page_size > default_page_size) {\n+#if !defined(IA32)\n+    if (EnableAllLargePageSizesForWindows) {\n+      size_t min_size = GetLargePageMinimum();\n+\n+      // Populate _page_sizes with large page sizes less than or equal to _large_page_size, ensuring each page size is double the size of the previous one.\n+      for (size_t page_size = min_size; page_size < _large_page_size; page_size *= 2) {\n+        _page_sizes.add(page_size);\n+      }\n+    }\n+#endif\n+\n     _page_sizes.add(_large_page_size);\n   }\n-\n+  // Set UseLargePages based on whether a large page size was successfully determined\n   UseLargePages = _large_page_size != 0;\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Windows平台Hotspot仅支持单一的大页尺寸（最大4MB），且对AMD64架构有硬性限制。优化后：通过新增EnableAllLargePageSizesForWindows标志，支持Windows Server上的多种大页尺寸（如2MB、4MB、8MB等），并移除了AMD64架构的4MB限制。优化思路：1) 引入配置开关控制多尺寸大页支持；2) 在large_page_init()中动态构建大页尺寸列表（按2的幂次递增）；3) 修改pd_reserve_memory_special()移除对单一页尺寸的断言，适配多尺寸场景；4) 增强错误提示和参数校验逻辑。"}
{"id": 698, "source": "riscv-dataset-excel", "optimization_type": "数据结构优化+算法优化", "optimization_description": "优化前使用ArrayList存储Frame对象，存在动态扩容开销和额外的对象包装开销。优化后改为使用预分配的Frame数组，减少了内存分配和访问开销。同时重构了detectFrames()方法，将异常处理逻辑分离到generateHandlers()，将死代码处理逻辑分离到deadCodePatching()，提高了代码的可读性和局部性。整体上通过数据结构优化和算法重构，提升了StackMapGenerator的性能和内存效率。", "original_code": "// No original code extracted from description\n", "optimized_code": "- private List<Frame> frames;\n+ private Frame[] frames = EMPTY_FRAME_ARRAY;\n+ private int framesCount = 0;\n- frames = new ArrayList<>(framesCount);\n- frames.add(new Frame(offset, classHierarchy));\n+ frames = new Frame[framesCount];\n+ frames[framesCount++] = new Frame(offset, classHierarchy);\n- for (var f : frames) {\n-     if (f.dirty) return true;\n+ for (int i = 0; i < framesCount; i++) {\n+     if (frames[i].dirty) return true;", "source_url": "https://github.com/openjdk/riscv-port/commit/12028000db2ef3b1c784af119c495aa3ef9590cf", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- private List<Frame> frames;\n+ private Frame[] frames = EMPTY_FRAME_ARRAY;\n+ private int framesCount = 0;\n- frames = new ArrayList<>(framesCount);\n- frames.add(new Frame(offset, classHierarchy));\n+ frames = new Frame[framesCount];\n+ frames[framesCount++] = new Frame(offset, classHierarchy);\n- for (var f : frames) {\n-     if (f.dirty) return true;\n+ for (int i = 0; i < framesCount; i++) {\n+     if (frames[i].dirty) return true;", "target": "- private List<Frame> frames;\n+ private Frame[] frames = EMPTY_FRAME_ARRAY;\n+ private int framesCount = 0;\n- frames = new ArrayList<>(framesCount);\n- frames.add(new Frame(offset, classHierarchy));\n+ frames = new Frame[framesCount];\n+ frames[framesCount++] = new Frame(offset, classHierarchy);\n- for (var f : frames) {\n-     if (f.dirty) return true;\n+ for (int i = 0; i < framesCount; i++) {\n+     if (frames[i].dirty) return true;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用ArrayList存储Frame对象，存在动态扩容开销和额外的对象包装开销。优化后改为使用预分配的Frame数组，减少了内存分配和访问开销。同时重构了detectFrames()方法，将异常处理逻辑分离到generateHandlers()，将死代码处理逻辑分离到deadCodePatching()，提高了代码的可读性和局部性。整体上通过数据结构优化和算法重构，提升了StackMapGenerator的性能和内存效率。"}
{"id": 699, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码简化", "optimization_description": "优化前：1. 使用单独的isWide布尔字段跟踪WIDE指令状态，增加内存开销和状态管理复杂度。2. opcode()方法直接返回opcode字段，未处理WIDE指令的编码。3. next()方法中先检查len<=0再调用checkSpecialInstruction，然后再次检查len<=0，存在冗余条件判断。4. checkSpecialInstruction方法使用多个独立if语句，结构松散，且错误处理分散。优化后：1. 移除isWide字段，通过opcode字段的高8位编码WIDE状态（(opcode & (WIDE << 8)) != 0），减少内存占用。2. opcode()方法返回opcode & 0xFF，确保正确提取操作码。3. 重构checkSpecialInstruction方法：使用if-else链整合逻辑，集中错误处理（当len<=0时设置opcode=ILLEGAL），简化控制流。4. next()方法移除冗余的len<=0检查，直接依赖checkSpecialInstruction的返回值处理。优化思路：通过位操作编码状态替代额外字段，减少内存访问；重构条件逻辑消除冗余检查，提高代码执行效率；整合错误处理路径，使代码更紧凑、可维护。", "original_code": "1. 使用单独的isWide布尔字段跟踪WIDE指令状态，增加内存开销和状态管理复杂度。2. opcode()方法直接返回opcode字段，未处理WIDE指令的编码。3. next()方法中先检查len<=0再调用checkSpecialInstruction，然后再次检查len<=0，存在冗余条件判断。4. checkSpecialInstruction方法使用多个独立if语句，结构松散，且错误处理分散。", "optimized_code": "- private boolean isWide;\n+ return opcode & 0xFF;\n+ return (opcode & (WIDE << 8)) != 0;\n+ return isWide() ? getU2Unchecked(bci + 2) : getIndexU1();\n- isWide = false;\n- if (len <= 0) {\n-     len = checkSpecialInstruction(bci, end, code); // sets opcode\n- }\n- if (len <= 0 || (nextBci += len) > end) {\n+ if ((nextBci += len) > end) {\n+ private int checkSpecialInstruction(int bci, int end, int code) {\n+     int len = -1;\n+     if (code == WIDE) {\n+         if (bci + 1 < end) {\n+             opcode = (WIDE << 8) | (code = getIndexU1());\n+             len = LENGTHS[code] * 2;\n+         }\n+     } else if (code == TABLESWITCH) {\n+         int alignedBci = align(bci + 1);\n+         if (alignedBci + 3 * 4 < end) {\n+             int lo = getIntUnchecked(alignedBci + 1 * 4);\n+             int hi = getIntUnchecked(alignedBci + 2 * 4);\n+             long l = alignedBci - bci + (3L + (long) hi - lo + 1L) * 4L;\n+             len = l > 0 && ((int) l == l) ? (int) l : -1;\n+         }\n+     } else if (code == LOOKUPSWITCH) {\n+         int alignedBci = align(bci + 1);\n+         if (alignedBci + 2 * 4 < end) {\n+             int npairs = getIntUnchecked(alignedBci + 4);\n+             if (npairs >= 0) {\n+                 long l = alignedBci - bci + (2L + 2L * npairs) * 4L;\n+                 len = l > 0 && ((int) l == l) ? (int) l : -1;\n+             }\n+         }\n+     }\n+     if (len <= 0) {\n+         opcode = ILLEGAL;\n+     }\n+     return len;\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/d7f32d891cde2278fe7158fb28d29235db5c818c", "code_v0_no_empty_lines": "1. 使用单独的isWide布尔字段跟踪WIDE指令状态，增加内存开销和状态管理复杂度。2. opcode()方法直接返回opcode字段，未处理WIDE指令的编码。3. next()方法中先检查len<=0再调用checkSpecialInstruction，然后再次检查len<=0，存在冗余条件判断。4. checkSpecialInstruction方法使用多个独立if语句，结构松散，且错误处理分散。", "code_v1_no_empty_lines": "- private boolean isWide;\n+ return opcode & 0xFF;\n+ return (opcode & (WIDE << 8)) != 0;\n+ return isWide() ? getU2Unchecked(bci + 2) : getIndexU1();\n- isWide = false;\n- if (len <= 0) {\n-     len = checkSpecialInstruction(bci, end, code); // sets opcode\n- }\n- if (len <= 0 || (nextBci += len) > end) {\n+ if ((nextBci += len) > end) {\n+ private int checkSpecialInstruction(int bci, int end, int code) {\n+     int len = -1;\n+     if (code == WIDE) {\n+         if (bci + 1 < end) {\n+             opcode = (WIDE << 8) | (code = getIndexU1());\n+             len = LENGTHS[code] * 2;\n+         }\n+     } else if (code == TABLESWITCH) {\n+         int alignedBci = align(bci + 1);\n+         if (alignedBci + 3 * 4 < end) {\n+             int lo = getIntUnchecked(alignedBci + 1 * 4);\n+             int hi = getIntUnchecked(alignedBci + 2 * 4);\n+             long l = alignedBci - bci + (3L + (long) hi - lo + 1L) * 4L;\n+             len = l > 0 && ((int) l == l) ? (int) l : -1;\n+         }\n+     } else if (code == LOOKUPSWITCH) {\n+         int alignedBci = align(bci + 1);\n+         if (alignedBci + 2 * 4 < end) {\n+             int npairs = getIntUnchecked(alignedBci + 4);\n+             if (npairs >= 0) {\n+                 long l = alignedBci - bci + (2L + 2L * npairs) * 4L;\n+                 len = l > 0 && ((int) l == l) ? (int) l : -1;\n+             }\n+         }\n+     }\n+     if (len <= 0) {\n+         opcode = ILLEGAL;\n+     }\n+     return len;\n+ }", "target": "- private boolean isWide;\n+ return opcode & 0xFF;\n+ return (opcode & (WIDE << 8)) != 0;\n+ return isWide() ? getU2Unchecked(bci + 2) : getIndexU1();\n- isWide = false;\n- if (len <= 0) {\n-     len = checkSpecialInstruction(bci, end, code); // sets opcode\n- }\n- if (len <= 0 || (nextBci += len) > end) {\n+ if ((nextBci += len) > end) {\n+ private int checkSpecialInstruction(int bci, int end, int code) {\n+     int len = -1;\n+     if (code == WIDE) {\n+         if (bci + 1 < end) {\n+             opcode = (WIDE << 8) | (code = getIndexU1());\n+             len = LENGTHS[code] * 2;\n+         }\n+     } else if (code == TABLESWITCH) {\n+         int alignedBci = align(bci + 1);\n+         if (alignedBci + 3 * 4 < end) {\n+             int lo = getIntUnchecked(alignedBci + 1 * 4);\n+             int hi = getIntUnchecked(alignedBci + 2 * 4);\n+             long l = alignedBci - bci + (3L + (long) hi - lo + 1L) * 4L;\n+             len = l > 0 && ((int) l == l) ? (int) l : -1;\n+         }\n+     } else if (code == LOOKUPSWITCH) {\n+         int alignedBci = align(bci + 1);\n+         if (alignedBci + 2 * 4 < end) {\n+             int npairs = getIntUnchecked(alignedBci + 4);\n+             if (npairs >= 0) {\n+                 long l = alignedBci - bci + (2L + 2L * npairs) * 4L;\n+                 len = l > 0 && ((int) l == l) ? (int) l : -1;\n+             }\n+         }\n+     }\n+     if (len <= 0) {\n+         opcode = ILLEGAL;\n+     }\n+     return len;\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 使用单独的isWide布尔字段跟踪WIDE指令状态，增加内存开销和状态管理复杂度。2. opcode()方法直接返回opcode字段，未处理WIDE指令的编码。3. next()方法中先检查len<=0再调用checkSpecialInstruction，然后再次检查len<=0，存在冗余条件判断。4. checkSpecialInstruction方法使用多个独立if语句，结构松散，且错误处理分散。优化后：1. 移除isWide字段，通过opcode字段的高8位编码WIDE状态（(opcode & (WIDE << 8)) != 0），减少内存占用。2. opcode()方法返回opcode & 0xFF，确保正确提取操作码。3. 重构checkSpecialInstruction方法：使用if-else链整合逻辑，集中错误处理（当len<=0时设置opcode=ILLEGAL），简化控制流。4. next()方法移除冗余的len<=0检查，直接依赖checkSpecialInstruction的返回值处理。优化思路：通过位操作编码状态替代额外字段，减少内存访问；重构条件逻辑消除冗余检查，提高代码执行效率；整合错误处理路径，使代码更紧凑、可维护。"}
{"id": 700, "source": "riscv-dataset-excel", "optimization_type": "垃圾收集优化+编译器优化", "optimization_description": "优化前：G1垃圾收集器的屏障（barrier）在编译早期就生成，导致代码膨胀和性能开销。优化后：实现“Late Barrier Expansion”（延迟屏障扩展），将屏障生成推迟到编译后期，通过barrier_data字段标记需要屏障的内存操作，在代码生成阶段再插入实际屏障指令。优化思路：减少不必要的屏障代码生成，提高代码质量，降低运行时开销，同时为多个CPU架构（aarch64、x86、ppc等）创建专门的G1屏障汇编文件。", "original_code": "G1垃圾收集器的屏障（barrier）在编译早期就生成，导致代码膨胀和性能开销。", "optimized_code": "predicate(!needs_acquiring_load(n) && n->as_Load()->barrier_data() == 0);\npredicate(!needs_releasing_store(n) && n->as_Store()->barrier_data() == 0);\npredicate(n->as_Load()->barrier_data() == 0);\npredicate(n->as_Store()->barrier_data() == 0);", "source_url": "https://github.com/openjdk/riscv-port/commit/0b467e902d591ae9feeec1669918d1588987cd1c", "code_v0_no_empty_lines": "G1垃圾收集器的屏障（barrier）在编译早期就生成，导致代码膨胀和性能开销。", "code_v1_no_empty_lines": "predicate(!needs_acquiring_load(n) && n->as_Load()->barrier_data() == 0);\npredicate(!needs_releasing_store(n) && n->as_Store()->barrier_data() == 0);\npredicate(n->as_Load()->barrier_data() == 0);\npredicate(n->as_Store()->barrier_data() == 0);", "target": "predicate(!needs_acquiring_load(n) && n->as_Load()->barrier_data() == 0);\npredicate(!needs_releasing_store(n) && n->as_Store()->barrier_data() == 0);\npredicate(n->as_Load()->barrier_data() == 0);\npredicate(n->as_Store()->barrier_data() == 0);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：G1垃圾收集器的屏障（barrier）在编译早期就生成，导致代码膨胀和性能开销。优化后：实现“Late Barrier Expansion”（延迟屏障扩展），将屏障生成推迟到编译后期，通过barrier_data字段标记需要屏障的内存操作，在代码生成阶段再插入实际屏障指令。优化思路：减少不必要的屏障代码生成，提高代码质量，降低运行时开销，同时为多个CPU架构（aarch64、x86、ppc等）创建专门的G1屏障汇编文件。"}
{"id": 701, "source": "riscv-dataset-excel", "optimization_type": "代码重构/测试优化", "optimization_description": "优化前：两个测试文件各自实现positionTestWindows方法，手动计算窗口位置并设置坐标，代码重复且维护成本高。优化后：使用标准布局方法positionTestUIRightRow()替代自定义方法，消除重复代码，简化测试逻辑，提高代码可维护性。", "original_code": "两个测试文件各自实现positionTestWindows方法，手动计算窗口位置并设置坐标，代码重复且维护成本高。", "optimized_code": "- .positionTestUI(DefaultFrameIconTest::positionTestWindows)\n+ .positionTestUIRightRow()", "source_url": "https://github.com/openjdk/riscv-port/commit/c43202baf6eb7e49ec458037971a9efa392d053e", "code_v0_no_empty_lines": "两个测试文件各自实现positionTestWindows方法，手动计算窗口位置并设置坐标，代码重复且维护成本高。", "code_v1_no_empty_lines": "- .positionTestUI(DefaultFrameIconTest::positionTestWindows)\n+ .positionTestUIRightRow()", "target": "- .positionTestUI(DefaultFrameIconTest::positionTestWindows)\n+ .positionTestUIRightRow()", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：两个测试文件各自实现positionTestWindows方法，手动计算窗口位置并设置坐标，代码重复且维护成本高。优化后：使用标准布局方法positionTestUIRightRow()替代自定义方法，消除重复代码，简化测试逻辑，提高代码可维护性。"}
{"id": 702, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前：在多个load-acquire操作前使用了不必要的AnyAny内存屏障，这会强制所有内存访问顺序化，增加性能开销。优化后：移除了这些多余的AnyAny屏障，仅保留必要的LoadLoad|LoadStore屏障，确保load-acquire语义的同时减少内存屏障开销。优化思路：RISC-V架构的load-acquire操作本身已提供足够的内存顺序保证，额外的AnyAny屏障是冗余的，移除后可提升模板解释器的执行性能。", "original_code": "在多个load-acquire操作前使用了不必要的AnyAny内存屏障，这会强制所有内存访问顺序化，增加性能开销。", "optimized_code": "-      __ membar(MacroAssembler::AnyAny);", "source_url": "https://github.com/openjdk/riscv-port/commit/a4ca6267e17815153f8fa119db19b97b1da2bd84", "code_v0_no_empty_lines": "在多个load-acquire操作前使用了不必要的AnyAny内存屏障，这会强制所有内存访问顺序化，增加性能开销。", "code_v1_no_empty_lines": "-      __ membar(MacroAssembler::AnyAny);", "target": "-      __ membar(MacroAssembler::AnyAny);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在多个load-acquire操作前使用了不必要的AnyAny内存屏障，这会强制所有内存访问顺序化，增加性能开销。优化后：移除了这些多余的AnyAny屏障，仅保留必要的LoadLoad|LoadStore屏障，确保load-acquire语义的同时减少内存屏障开销。优化思路：RISC-V架构的load-acquire操作本身已提供足够的内存顺序保证，额外的AnyAny屏障是冗余的，移除后可提升模板解释器的执行性能。"}
{"id": 703, "source": "riscv-dataset-excel", "optimization_type": "代码重构+性能优化", "optimization_description": "优化前：CRC32标量版本代码结构复杂，包含冗余的标签和分支逻辑，循环控制使用多个临时变量和条件判断，代码可读性和维护性较差。优化后：重构了代码结构，简化了标签定义（如移除L_by16_loop、L_unroll_loop_entry等），统一使用loop_buf_end作为循环结束指针，优化了分支跳转逻辑（如用blt替代bge/ble组合），减少了指令数量和寄存器使用。优化思路：通过代码重构消除冗余，简化控制流，提高汇编代码的清晰度和执行效率，同时保持功能不变。", "original_code": "CRC32标量版本代码结构复杂，包含冗余的标签和分支逻辑，循环控制使用多个临时变量和条件判断，代码可读性和维护性较差。", "optimized_code": "--- a/src/hotspot/cpu/riscv/macroAssembler_riscv.cpp\n+++ b/src/hotspot/cpu/riscv/macroAssembler_riscv.cpp\n@@ -1564,7 +1564,10 @@ void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n         Register table0, Register table1, Register table2, Register table3,\n         Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register tmp6) {\n   assert_different_registers(crc, buf, len, table0, table1, table2, table3, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n-  Label L_by16_loop, L_vector_entry, L_unroll_loop, L_unroll_loop_entry, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;\n+  Label L_vector_entry,\n+        L_unroll_loop,\n+        L_by4_loop_entry, L_by4_loop,\n+        L_by1_loop, L_exit;\n \n   const int64_t single_table_size = 256;\n   const int64_t unroll = 16;\n@@ -1585,21 +1588,17 @@ void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n     bge(len, tmp1, L_vector_entry);\n   }\n #endif // COMPILER2\n-  subw(len, len, unroll_words);\n-  bge(len, zr, L_unroll_loop_entry);\n \n-  addiw(len, len, unroll_words-4);\n-  bge(len, zr, L_by4_loop);\n-  addiw(len, len, 4);\n-  bgt(len, zr, L_by1_loop);\n-  j(L_exit);\n+  mv(tmp1, unroll_words);\n+  blt(len, tmp1, L_by4_loop_entry);\n+\n+  const Register loop_buf_end = tmp3;\n \n   align(CodeEntryAlignment);\n-  bind(L_unroll_loop_entry);\n-    const Register buf_end = tmp3;\n-    add(buf_end, buf, len); // buf_end will be used as endpoint for loop below\n+  // Entry for L_unroll_loop\n+    add(loop_buf_end, buf, len);    // loop_buf_end will be used as endpoint for loop below\n     andi(len, len, unroll_words-1); // len = (len % unroll_words)\n-    sub(len, len, unroll_words); // Length after all iterations\n+    sub(loop_buf_end, loop_buf_end, len);", "source_url": "https://github.com/openjdk/riscv-port/commit/52c2ea65c4ab6a2d25e9de465fbf20034fe79028", "code_v0_no_empty_lines": "CRC32标量版本代码结构复杂，包含冗余的标签和分支逻辑，循环控制使用多个临时变量和条件判断，代码可读性和维护性较差。", "code_v1_no_empty_lines": "--- a/src/hotspot/cpu/riscv/macroAssembler_riscv.cpp\n+++ b/src/hotspot/cpu/riscv/macroAssembler_riscv.cpp\n@@ -1564,7 +1564,10 @@ void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n         Register table0, Register table1, Register table2, Register table3,\n         Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register tmp6) {\n   assert_different_registers(crc, buf, len, table0, table1, table2, table3, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n-  Label L_by16_loop, L_vector_entry, L_unroll_loop, L_unroll_loop_entry, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;\n+  Label L_vector_entry,\n+        L_unroll_loop,\n+        L_by4_loop_entry, L_by4_loop,\n+        L_by1_loop, L_exit;\n \n   const int64_t single_table_size = 256;\n   const int64_t unroll = 16;\n@@ -1585,21 +1588,17 @@ void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n     bge(len, tmp1, L_vector_entry);\n   }\n #endif // COMPILER2\n-  subw(len, len, unroll_words);\n-  bge(len, zr, L_unroll_loop_entry);\n \n-  addiw(len, len, unroll_words-4);\n-  bge(len, zr, L_by4_loop);\n-  addiw(len, len, 4);\n-  bgt(len, zr, L_by1_loop);\n-  j(L_exit);\n+  mv(tmp1, unroll_words);\n+  blt(len, tmp1, L_by4_loop_entry);\n+\n+  const Register loop_buf_end = tmp3;\n \n   align(CodeEntryAlignment);\n-  bind(L_unroll_loop_entry);\n-    const Register buf_end = tmp3;\n-    add(buf_end, buf, len); // buf_end will be used as endpoint for loop below\n+  // Entry for L_unroll_loop\n+    add(loop_buf_end, buf, len);    // loop_buf_end will be used as endpoint for loop below\n     andi(len, len, unroll_words-1); // len = (len % unroll_words)\n-    sub(len, len, unroll_words); // Length after all iterations\n+    sub(loop_buf_end, loop_buf_end, len);", "target": "--- a/src/hotspot/cpu/riscv/macroAssembler_riscv.cpp\n+++ b/src/hotspot/cpu/riscv/macroAssembler_riscv.cpp\n@@ -1564,7 +1564,10 @@ void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n         Register table0, Register table1, Register table2, Register table3,\n         Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register tmp6) {\n   assert_different_registers(crc, buf, len, table0, table1, table2, table3, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n-  Label L_by16_loop, L_vector_entry, L_unroll_loop, L_unroll_loop_entry, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;\n+  Label L_vector_entry,\n+        L_unroll_loop,\n+        L_by4_loop_entry, L_by4_loop,\n+        L_by1_loop, L_exit;\n \n   const int64_t single_table_size = 256;\n   const int64_t unroll = 16;\n@@ -1585,21 +1588,17 @@ void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n     bge(len, tmp1, L_vector_entry);\n   }\n #endif // COMPILER2\n-  subw(len, len, unroll_words);\n-  bge(len, zr, L_unroll_loop_entry);\n \n-  addiw(len, len, unroll_words-4);\n-  bge(len, zr, L_by4_loop);\n-  addiw(len, len, 4);\n-  bgt(len, zr, L_by1_loop);\n-  j(L_exit);\n+  mv(tmp1, unroll_words);\n+  blt(len, tmp1, L_by4_loop_entry);\n+\n+  const Register loop_buf_end = tmp3;\n \n   align(CodeEntryAlignment);\n-  bind(L_unroll_loop_entry);\n-    const Register buf_end = tmp3;\n-    add(buf_end, buf, len); // buf_end will be used as endpoint for loop below\n+  // Entry for L_unroll_loop\n+    add(loop_buf_end, buf, len);    // loop_buf_end will be used as endpoint for loop below\n     andi(len, len, unroll_words-1); // len = (len % unroll_words)\n-    sub(len, len, unroll_words); // Length after all iterations\n+    sub(loop_buf_end, loop_buf_end, len);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CRC32标量版本代码结构复杂，包含冗余的标签和分支逻辑，循环控制使用多个临时变量和条件判断，代码可读性和维护性较差。优化后：重构了代码结构，简化了标签定义（如移除L_by16_loop、L_unroll_loop_entry等），统一使用loop_buf_end作为循环结束指针，优化了分支跳转逻辑（如用blt替代bge/ble组合），减少了指令数量和寄存器使用。优化思路：通过代码重构消除冗余，简化控制流，提高汇编代码的清晰度和执行效率，同时保持功能不变。"}
{"id": 704, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：TypeInterfaces对象和其内部的GrowableArray接口列表是分开分配的两块内存，当hashcons()发现重复类型时，只能回收TypeInterfaces对象本身的内存，无法回收GrowableArray占用的内存，导致内存泄漏。优化后：通过一次性分配连续内存块，将TypeInterfaces对象和接口数组放在同一块内存中，使得hashcons()在发现重复类型时可以完整回收所有相关内存。优化思路：利用内存连续分配特性，确保TypeInterfaces对象及其数据成员在物理内存上连续，从而解决内存泄漏问题。", "original_code": "TypeInterfaces对象和其内部的GrowableArray接口列表是分开分配的两块内存，当hashcons()发现重复类型时，只能回收TypeInterfaces对象本身的内存，无法回收GrowableArray占用的内存，导致内存泄漏。", "optimized_code": "TypeInterfaces* result = (interfaces == nullptr) ? new TypeInterfaces() : new TypeInterfaces(interfaces);\n+  int nb_interfaces = interfaces == nullptr ? 0 : interfaces->length();\n+  size_t total_size = sizeof(TypeInterfaces) + nb_interfaces * sizeof(ciInstanceKlass*);\n+  void* allocated_mem = operator new(total_size);\n+  ciInstanceKlass** interfaces_base = (ciInstanceKlass**)((char*)allocated_mem + sizeof(TypeInterfaces));\n+  for (int i = 0; i < nb_interfaces; ++i) {\n+    interfaces_base[i] = interfaces->at(i);\n+  }\n+  TypeInterfaces* result = ::new (allocated_mem) TypeInterfaces(interfaces_base, nb_interfaces);", "source_url": "https://github.com/openjdk/riscv-port/commit/90c944fefe4a7827c08a8e6a81f137c3157a749b", "code_v0_no_empty_lines": "TypeInterfaces对象和其内部的GrowableArray接口列表是分开分配的两块内存，当hashcons()发现重复类型时，只能回收TypeInterfaces对象本身的内存，无法回收GrowableArray占用的内存，导致内存泄漏。", "code_v1_no_empty_lines": "TypeInterfaces* result = (interfaces == nullptr) ? new TypeInterfaces() : new TypeInterfaces(interfaces);\n+  int nb_interfaces = interfaces == nullptr ? 0 : interfaces->length();\n+  size_t total_size = sizeof(TypeInterfaces) + nb_interfaces * sizeof(ciInstanceKlass*);\n+  void* allocated_mem = operator new(total_size);\n+  ciInstanceKlass** interfaces_base = (ciInstanceKlass**)((char*)allocated_mem + sizeof(TypeInterfaces));\n+  for (int i = 0; i < nb_interfaces; ++i) {\n+    interfaces_base[i] = interfaces->at(i);\n+  }\n+  TypeInterfaces* result = ::new (allocated_mem) TypeInterfaces(interfaces_base, nb_interfaces);", "target": "TypeInterfaces* result = (interfaces == nullptr) ? new TypeInterfaces() : new TypeInterfaces(interfaces);\n+  int nb_interfaces = interfaces == nullptr ? 0 : interfaces->length();\n+  size_t total_size = sizeof(TypeInterfaces) + nb_interfaces * sizeof(ciInstanceKlass*);\n+  void* allocated_mem = operator new(total_size);\n+  ciInstanceKlass** interfaces_base = (ciInstanceKlass**)((char*)allocated_mem + sizeof(TypeInterfaces));\n+  for (int i = 0; i < nb_interfaces; ++i) {\n+    interfaces_base[i] = interfaces->at(i);\n+  }\n+  TypeInterfaces* result = ::new (allocated_mem) TypeInterfaces(interfaces_base, nb_interfaces);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：TypeInterfaces对象和其内部的GrowableArray接口列表是分开分配的两块内存，当hashcons()发现重复类型时，只能回收TypeInterfaces对象本身的内存，无法回收GrowableArray占用的内存，导致内存泄漏。优化后：通过一次性分配连续内存块，将TypeInterfaces对象和接口数组放在同一块内存中，使得hashcons()在发现重复类型时可以完整回收所有相关内存。优化思路：利用内存连续分配特性，确保TypeInterfaces对象及其数据成员在物理内存上连续，从而解决内存泄漏问题。"}
{"id": 705, "source": "riscv-dataset-excel", "optimization_type": "编译器Bug修复+类型系统优化", "optimization_description": "优化前：当Unsafe访问的base参数为null但被CheckCastPP节点包装时，编译器错误地使用base_type（来自_gvn.type(base)）判断null指针，导致无法正确识别null base，引发编译崩溃。优化后：通过base->uncast()获取原始节点类型，正确识别null指针，修复了C2编译器在处理Unsafe::getShortUnaligned等操作时的崩溃问题。优化思路：在类型检查时穿透CheckCastPP等包装节点，直接检查底层节点的真实类型，确保null指针的正确处理。", "original_code": "当Unsafe访问的base参数为null但被CheckCastPP节点包装时，编译器错误地使用base_type（来自_gvn.type(base)）判断null指针，导致无法正确识别null base，引发编译崩溃。", "optimized_code": "@@ -2052,7 +2052,7 @@ LibraryCallKit::classify_unsafe_addr(Node* &base, Node* &offset, BasicType type)\n   if (base_type == nullptr) {\n     // Unknown type.\n     return Type::AnyPtr;\n-  } else if (base_type == TypePtr::NULL_PTR) {\n+  } else if (_gvn.type(base->uncast()) == TypePtr::NULL_PTR) {\n     // Since this is a null+long form, we have to switch to a rawptr.\n     base   = _gvn.transform(new CastX2PNode(offset));\n     offset = MakeConX(0);\n@@ -2370,8 +2370,9 @@ bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, c\n   SafePointNode* old_map = clone_map();\n \n   Node* adr = make_unsafe_address(base, offset, type, kind == Relaxed);\n+  assert(!stopped(), \"Inlining of unsafe access failed: address construction stopped unexpectedly\");\n \n-  if (_gvn.type(base)->isa_ptr() == TypePtr::NULL_PTR) {\n+  if (_gvn.type(base->uncast())->isa_ptr() == TypePtr::NULL_PTR) {\n     if (type != T_OBJECT) {\n       decorators |= IN_NATIVE; // off-heap primitive access\n     } else {\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/8d6d37fea133380d4143f5db38ad3790efa84f68", "code_v0_no_empty_lines": "当Unsafe访问的base参数为null但被CheckCastPP节点包装时，编译器错误地使用base_type（来自_gvn.type(base)）判断null指针，导致无法正确识别null base，引发编译崩溃。", "code_v1_no_empty_lines": "@@ -2052,7 +2052,7 @@ LibraryCallKit::classify_unsafe_addr(Node* &base, Node* &offset, BasicType type)\n   if (base_type == nullptr) {\n     // Unknown type.\n     return Type::AnyPtr;\n-  } else if (base_type == TypePtr::NULL_PTR) {\n+  } else if (_gvn.type(base->uncast()) == TypePtr::NULL_PTR) {\n     // Since this is a null+long form, we have to switch to a rawptr.\n     base   = _gvn.transform(new CastX2PNode(offset));\n     offset = MakeConX(0);\n@@ -2370,8 +2370,9 @@ bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, c\n   SafePointNode* old_map = clone_map();\n \n   Node* adr = make_unsafe_address(base, offset, type, kind == Relaxed);\n+  assert(!stopped(), \"Inlining of unsafe access failed: address construction stopped unexpectedly\");\n \n-  if (_gvn.type(base)->isa_ptr() == TypePtr::NULL_PTR) {\n+  if (_gvn.type(base->uncast())->isa_ptr() == TypePtr::NULL_PTR) {\n     if (type != T_OBJECT) {\n       decorators |= IN_NATIVE; // off-heap primitive access\n     } else {\n     }", "target": "@@ -2052,7 +2052,7 @@ LibraryCallKit::classify_unsafe_addr(Node* &base, Node* &offset, BasicType type)\n   if (base_type == nullptr) {\n     // Unknown type.\n     return Type::AnyPtr;\n-  } else if (base_type == TypePtr::NULL_PTR) {\n+  } else if (_gvn.type(base->uncast()) == TypePtr::NULL_PTR) {\n     // Since this is a null+long form, we have to switch to a rawptr.\n     base   = _gvn.transform(new CastX2PNode(offset));\n     offset = MakeConX(0);\n@@ -2370,8 +2370,9 @@ bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, c\n   SafePointNode* old_map = clone_map();\n \n   Node* adr = make_unsafe_address(base, offset, type, kind == Relaxed);\n+  assert(!stopped(), \"Inlining of unsafe access failed: address construction stopped unexpectedly\");\n \n-  if (_gvn.type(base)->isa_ptr() == TypePtr::NULL_PTR) {\n+  if (_gvn.type(base->uncast())->isa_ptr() == TypePtr::NULL_PTR) {\n     if (type != T_OBJECT) {\n       decorators |= IN_NATIVE; // off-heap primitive access\n     } else {\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当Unsafe访问的base参数为null但被CheckCastPP节点包装时，编译器错误地使用base_type（来自_gvn.type(base)）判断null指针，导致无法正确识别null base，引发编译崩溃。优化后：通过base->uncast()获取原始节点类型，正确识别null指针，修复了C2编译器在处理Unsafe::getShortUnaligned等操作时的崩溃问题。优化思路：在类型检查时穿透CheckCastPP等包装节点，直接检查底层节点的真实类型，确保null指针的正确处理。"}
{"id": 706, "source": "riscv-dataset-excel", "optimization_type": "内存分配优化", "optimization_description": "优化前：多个类中硬编码数组最大尺寸为Integer.MAX_VALUE-8，存在平台兼容性问题且注释过时。优化后：统一使用ArraysSupport.SOFT_MAX_ARRAY_LENGTH常量，该常量根据JVM实际支持动态计算最大安全数组尺寸。思路：通过集中管理数组大小限制，提高代码可维护性，确保在不同JVM实现中都能安全分配最大可能数组，避免硬编码导致的潜在兼容性问题。", "original_code": "多个类中硬编码数组最大尺寸为Integer.MAX_VALUE-8，存在平台兼容性问题且注释过时。", "optimized_code": "- private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n+ private static final int MAX_BUFFER_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;", "source_url": "https://github.com/openjdk/riscv-port/commit/0f381137cb9338453a7d77a7ebdfaa9b34b5028b", "code_v0_no_empty_lines": "多个类中硬编码数组最大尺寸为Integer.MAX_VALUE-8，存在平台兼容性问题且注释过时。", "code_v1_no_empty_lines": "- private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n+ private static final int MAX_BUFFER_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;", "target": "- private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n+ private static final int MAX_BUFFER_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多个类中硬编码数组最大尺寸为Integer.MAX_VALUE-8，存在平台兼容性问题且注释过时。优化后：统一使用ArraysSupport.SOFT_MAX_ARRAY_LENGTH常量，该常量根据JVM实际支持动态计算最大安全数组尺寸。思路：通过集中管理数组大小限制，提高代码可维护性，确保在不同JVM实现中都能安全分配最大可能数组，避免硬编码导致的潜在兼容性问题。"}
{"id": 707, "source": "riscv-dataset-excel", "optimization_type": "算法优化+性能优化", "optimization_description": "优化前：使用BigInteger.bitLengthForInt计算高位有效位数，通过(32-bitsInHighWord)判断是否需要移动数组，逻辑复杂且包含冗余计算。优化后：使用Integer.numberOfLeadingZeros直接获取前导零数量，简化判断逻辑；重构移位算法，通过新增的primitiveLeftShift/primitiveRightShift重载方法直接操作目标数组，避免不必要的数组复制和临时变量。优化思路：减少方法调用开销，简化条件判断，优化内存访问模式，提升大整数左移操作的性能。", "original_code": "使用BigInteger.bitLengthForInt计算高位有效位数，通过(32-bitsInHighWord)判断是否需要移动数组，逻辑复杂且包含冗余计算。", "optimized_code": "int bitsInHighWord = BigInteger.bitLengthForInt(value[offset]);\n-        if (n <= (32-bitsInHighWord)) {\n+        int leadingZeros = Integer.numberOfLeadingZeros(value[offset]);\n+        if (n <= leadingZeros) {\n-        if (nBits <= (32-bitsInHighWord))\n-            newLen--;\n+        if (nBits > leadingZeros)\n+            newLen++;\n-        if (nBits <= (32-bitsInHighWord))\n-            primitiveLeftShift(nBits);\n-        else\n-            primitiveRightShift(32 -nBits);\n+        if (nBits <= leadingZeros) {\n+            primitiveLeftShift(nBits, result, newOffset);\n+        } else {\n+            int lastInt = value[offset + intLen - 1];\n+            primitiveRightShift(32 - nBits, result, newOffset);\n+            result[trailingZerosPos++] = lastInt << nBits;\n+        }", "source_url": "https://github.com/openjdk/riscv-port/commit/d6820d1324711eac95a297dd68ec94e6f6be4b35", "code_v0_no_empty_lines": "使用BigInteger.bitLengthForInt计算高位有效位数，通过(32-bitsInHighWord)判断是否需要移动数组，逻辑复杂且包含冗余计算。", "code_v1_no_empty_lines": "int bitsInHighWord = BigInteger.bitLengthForInt(value[offset]);\n-        if (n <= (32-bitsInHighWord)) {\n+        int leadingZeros = Integer.numberOfLeadingZeros(value[offset]);\n+        if (n <= leadingZeros) {\n-        if (nBits <= (32-bitsInHighWord))\n-            newLen--;\n+        if (nBits > leadingZeros)\n+            newLen++;\n-        if (nBits <= (32-bitsInHighWord))\n-            primitiveLeftShift(nBits);\n-        else\n-            primitiveRightShift(32 -nBits);\n+        if (nBits <= leadingZeros) {\n+            primitiveLeftShift(nBits, result, newOffset);\n+        } else {\n+            int lastInt = value[offset + intLen - 1];\n+            primitiveRightShift(32 - nBits, result, newOffset);\n+            result[trailingZerosPos++] = lastInt << nBits;\n+        }", "target": "int bitsInHighWord = BigInteger.bitLengthForInt(value[offset]);\n-        if (n <= (32-bitsInHighWord)) {\n+        int leadingZeros = Integer.numberOfLeadingZeros(value[offset]);\n+        if (n <= leadingZeros) {\n-        if (nBits <= (32-bitsInHighWord))\n-            newLen--;\n+        if (nBits > leadingZeros)\n+            newLen++;\n-        if (nBits <= (32-bitsInHighWord))\n-            primitiveLeftShift(nBits);\n-        else\n-            primitiveRightShift(32 -nBits);\n+        if (nBits <= leadingZeros) {\n+            primitiveLeftShift(nBits, result, newOffset);\n+        } else {\n+            int lastInt = value[offset + intLen - 1];\n+            primitiveRightShift(32 - nBits, result, newOffset);\n+            result[trailingZerosPos++] = lastInt << nBits;\n+        }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用BigInteger.bitLengthForInt计算高位有效位数，通过(32-bitsInHighWord)判断是否需要移动数组，逻辑复杂且包含冗余计算。优化后：使用Integer.numberOfLeadingZeros直接获取前导零数量，简化判断逻辑；重构移位算法，通过新增的primitiveLeftShift/primitiveRightShift重载方法直接操作目标数组，避免不必要的数组复制和临时变量。优化思路：减少方法调用开销，简化条件判断，优化内存访问模式，提升大整数左移操作的性能。"}
{"id": 708, "source": "riscv-dataset-excel", "optimization_type": "编译器优化/GC屏障匹配修复", "optimization_description": "优化前：is_gc_barrier_node函数仅通过is_shenandoah_lrb_call检测LRB节点，导致某些LRB节点未被正确识别为GC屏障。优化后：在检测逻辑中显式添加对Op_ShenandoahLoadReferenceBarrier操作码的直接检查，确保所有LRB节点都能被正确匹配为GC屏障。思路：修复因JDK-8340183引入的回归问题，确保编译器优化阶段能正确识别GC屏障节点，避免因屏障识别错误导致的潜在性能问题或正确性问题。", "original_code": "is_gc_barrier_node函数仅通过is_shenandoah_lrb_call检测LRB节点，导致某些LRB节点未被正确识别为GC屏障。", "optimized_code": "-  return is_shenandoah_lrb_call(node) ||\n+  return (node->Opcode() == Op_ShenandoahLoadReferenceBarrier) ||\n+         is_shenandoah_lrb_call(node) ||", "source_url": "https://github.com/openjdk/riscv-port/commit/684d246ccf497f599ffcd498f2fbe4b1b2357e27", "code_v0_no_empty_lines": "is_gc_barrier_node函数仅通过is_shenandoah_lrb_call检测LRB节点，导致某些LRB节点未被正确识别为GC屏障。", "code_v1_no_empty_lines": "-  return is_shenandoah_lrb_call(node) ||\n+  return (node->Opcode() == Op_ShenandoahLoadReferenceBarrier) ||\n+         is_shenandoah_lrb_call(node) ||", "target": "-  return is_shenandoah_lrb_call(node) ||\n+  return (node->Opcode() == Op_ShenandoahLoadReferenceBarrier) ||\n+         is_shenandoah_lrb_call(node) ||", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：is_gc_barrier_node函数仅通过is_shenandoah_lrb_call检测LRB节点，导致某些LRB节点未被正确识别为GC屏障。优化后：在检测逻辑中显式添加对Op_ShenandoahLoadReferenceBarrier操作码的直接检查，确保所有LRB节点都能被正确匹配为GC屏障。思路：修复因JDK-8340183引入的回归问题，确保编译器优化阶段能正确识别GC屏障节点，避免因屏障识别错误导致的潜在性能问题或正确性问题。"}
{"id": 709, "source": "riscv-dataset-excel", "optimization_type": "代码重构+内存优化", "optimization_description": "优化前：使用全局静态变量_global_dumper和_global_writer管理堆转储状态，通过静态方法do_load_class处理类加载记录，存在线程安全隐患和全局状态管理复杂性。优化后：移除所有静态变量和方法，引入LoadedClassDumper类封装类加载记录逻辑，将_writer作为实例变量管理。优化思路：消除全局状态，提高代码可维护性和线程安全性，通过对象封装替代静态方法调用，简化内存管理。", "original_code": "使用全局静态变量_global_dumper和_global_writer管理堆转储状态，通过静态方法do_load_class处理类加载记录，存在线程安全隐患和全局状态管理复杂性。", "optimized_code": "- static VM_HeapDumper*   _global_dumper;\n- static DumpWriter*      _global_writer;\n- DumpWriter*             _local_writer;\n+ DumpWriter*             _writer;\n- static void do_load_class(Klass* k);\n+ class LoadedClassDumper : public LockedClassesDo {\n+   void do_klass(Klass* k) {\n+     // write HPROF_LOAD_CLASS record\n+   }\n+ };\n- LockedClassesDo locked_load_classes(&do_load_class);\n+ LoadedClassDumper loaded_class_dumper(writer(), _klass_map);", "source_url": "https://github.com/openjdk/riscv-port/commit/03149735e59b7d1d409a6e29ee05ae0537e03d53", "code_v0_no_empty_lines": "使用全局静态变量_global_dumper和_global_writer管理堆转储状态，通过静态方法do_load_class处理类加载记录，存在线程安全隐患和全局状态管理复杂性。", "code_v1_no_empty_lines": "- static VM_HeapDumper*   _global_dumper;\n- static DumpWriter*      _global_writer;\n- DumpWriter*             _local_writer;\n+ DumpWriter*             _writer;\n- static void do_load_class(Klass* k);\n+ class LoadedClassDumper : public LockedClassesDo {\n+   void do_klass(Klass* k) {\n+     // write HPROF_LOAD_CLASS record\n+   }\n+ };\n- LockedClassesDo locked_load_classes(&do_load_class);\n+ LoadedClassDumper loaded_class_dumper(writer(), _klass_map);", "target": "- static VM_HeapDumper*   _global_dumper;\n- static DumpWriter*      _global_writer;\n- DumpWriter*             _local_writer;\n+ DumpWriter*             _writer;\n- static void do_load_class(Klass* k);\n+ class LoadedClassDumper : public LockedClassesDo {\n+   void do_klass(Klass* k) {\n+     // write HPROF_LOAD_CLASS record\n+   }\n+ };\n- LockedClassesDo locked_load_classes(&do_load_class);\n+ LoadedClassDumper loaded_class_dumper(writer(), _klass_map);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用全局静态变量_global_dumper和_global_writer管理堆转储状态，通过静态方法do_load_class处理类加载记录，存在线程安全隐患和全局状态管理复杂性。优化后：移除所有静态变量和方法，引入LoadedClassDumper类封装类加载记录逻辑，将_writer作为实例变量管理。优化思路：消除全局状态，提高代码可维护性和线程安全性，通过对象封装替代静态方法调用，简化内存管理。"}
{"id": 710, "source": "riscv-dataset-excel", "optimization_type": "线程资源分配优化", "optimization_description": "优化前：libjvmci线程分配比例为0.33，可能导致libgraal线程数量不足，影响JVMCI编译器性能。优化后：将线程分配比例提高到0.66，增加libjvmci可用的编译器线程数量，提升JVMCI编译性能，但可能增加内存占用（RSS）。优化思路：通过调整线程资源分配比例，在内存占用和编译性能之间取得更好的平衡。", "original_code": "libjvmci线程分配比例为0.33，可能导致libgraal线程数量不足，影响JVMCI编译器性能。", "optimized_code": "-  product(double, JVMCINativeLibraryThreadFraction, 0.33, EXPERIMENTAL,     \\\n+  product(double, JVMCINativeLibraryThreadFraction, 0.66, EXPERIMENTAL,     \\", "source_url": "https://github.com/openjdk/riscv-port/commit/7cc7c080b5dbab61914512bf63227944697c0cbe", "code_v0_no_empty_lines": "libjvmci线程分配比例为0.33，可能导致libgraal线程数量不足，影响JVMCI编译器性能。", "code_v1_no_empty_lines": "-  product(double, JVMCINativeLibraryThreadFraction, 0.33, EXPERIMENTAL,     \\\n+  product(double, JVMCINativeLibraryThreadFraction, 0.66, EXPERIMENTAL,     \\", "target": "-  product(double, JVMCINativeLibraryThreadFraction, 0.33, EXPERIMENTAL,     \\\n+  product(double, JVMCINativeLibraryThreadFraction, 0.66, EXPERIMENTAL,     \\", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：libjvmci线程分配比例为0.33，可能导致libgraal线程数量不足，影响JVMCI编译器性能。优化后：将线程分配比例提高到0.66，增加libjvmci可用的编译器线程数量，提升JVMCI编译性能，但可能增加内存占用（RSS）。优化思路：通过调整线程资源分配比例，在内存占用和编译性能之间取得更好的平衡。"}
{"id": 711, "source": "riscv-dataset-excel", "optimization_type": "JVMCI接口扩展", "optimization_description": "优化前：JVMCI无法访问JavaThread::_unlocked_inflated_monitor字段，限制了JVMCI编译器的监控和优化能力。优化后：将该字段导出到JVMCI的vmStructs中，使JVMCI编译器能够直接访问该字段。思路：通过扩展JVMCI接口，为JVMCI编译器提供更多运行时信息，支持更精确的锁优化和监控分析。", "original_code": "JVMCI无法访问JavaThread::_unlocked_inflated_monitor字段，限制了JVMCI编译器的监控和优化能力。", "optimized_code": "+  nonstatic_field(JavaThread,                  _unlocked_inflated_monitor,                    ObjectMonitor*)                        \\", "source_url": "https://github.com/openjdk/riscv-port/commit/2120a8414ef9c34d5875d33ac9a16594908fe403", "code_v0_no_empty_lines": "JVMCI无法访问JavaThread::_unlocked_inflated_monitor字段，限制了JVMCI编译器的监控和优化能力。", "code_v1_no_empty_lines": "+  nonstatic_field(JavaThread,                  _unlocked_inflated_monitor,                    ObjectMonitor*)                        \\", "target": "+  nonstatic_field(JavaThread,                  _unlocked_inflated_monitor,                    ObjectMonitor*)                        \\", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：JVMCI无法访问JavaThread::_unlocked_inflated_monitor字段，限制了JVMCI编译器的监控和优化能力。优化后：将该字段导出到JVMCI的vmStructs中，使JVMCI编译器能够直接访问该字段。思路：通过扩展JVMCI接口，为JVMCI编译器提供更多运行时信息，支持更精确的锁优化和监控分析。"}
{"id": 712, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前：在RISC-V模板解释器的多个load-acquire操作前使用了不必要的AnyAny内存屏障。优化后：移除了这些冗余的AnyAny内存屏障，仅保留必要的LoadLoad|LoadStore屏障。思路：根据RISC-V内存模型，load-acquire操作本身已提供足够的顺序保证，额外的AnyAny屏障是冗余的，移除后可减少指令开销，提升解释器性能。", "original_code": "在RISC-V模板解释器的多个load-acquire操作前使用了不必要的AnyAny内存屏障。", "optimized_code": "-      __ membar(MacroAssembler::AnyAny);", "source_url": "https://github.com/openjdk/riscv-port/commit/a4ca6267e17815153f8fa119db19b97b1da2bd84", "code_v0_no_empty_lines": "在RISC-V模板解释器的多个load-acquire操作前使用了不必要的AnyAny内存屏障。", "code_v1_no_empty_lines": "-      __ membar(MacroAssembler::AnyAny);", "target": "-      __ membar(MacroAssembler::AnyAny);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在RISC-V模板解释器的多个load-acquire操作前使用了不必要的AnyAny内存屏障。优化后：移除了这些冗余的AnyAny内存屏障，仅保留必要的LoadLoad|LoadStore屏障。思路：根据RISC-V内存模型，load-acquire操作本身已提供足够的顺序保证，额外的AnyAny屏障是冗余的，移除后可减少指令开销，提升解释器性能。"}
{"id": 713, "source": "riscv-dataset-excel", "optimization_type": "代码重构+性能优化", "optimization_description": "优化前：CRC32标量版本代码结构复杂，包含冗余的标签和分支逻辑，循环控制变量处理不够清晰，存在不必要的寄存器操作。优化后：重构了循环控制逻辑，简化了标签结构（如移除L_by16_loop、L_unroll_loop_entry等），使用统一的loop_buf_end寄存器管理循环边界，优化了分支跳转路径（如将多个条件跳转合并为blt指令），减少了指令数量和寄存器操作。优化思路：通过代码重构提高可读性和维护性，同时优化控制流减少分支预测失败和指令执行开销，提升CRC32计算性能。", "original_code": "CRC32标量版本代码结构复杂，包含冗余的标签和分支逻辑，循环控制变量处理不够清晰，存在不必要的寄存器操作。", "optimized_code": "--- a/src/hotspot/cpu/riscv/macroAssembler_riscv.cpp\n+++ b/src/hotspot/cpu/riscv/macroAssembler_riscv.cpp\n@@ -1564,7 +1564,10 @@ void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n         Register table0, Register table1, Register table2, Register table3,\n         Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register tmp6) {\n   assert_different_registers(crc, buf, len, table0, table1, table2, table3, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n-  Label L_by16_loop, L_vector_entry, L_unroll_loop, L_unroll_loop_entry, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;\n+  Label L_vector_entry,\n+        L_unroll_loop,\n+        L_by4_loop_entry, L_by4_loop,\n+        L_by1_loop, L_exit;\n \n   const int64_t single_table_size = 256;\n   const int64_t unroll = 16;\n@@ -1585,21 +1588,17 @@ void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n     bge(len, tmp1, L_vector_entry);\n   }\n #endif // COMPILER2\n-  subw(len, len, unroll_words);\n-  bge(len, zr, L_unroll_loop_entry);\n \n-  addiw(len, len, unroll_words-4);\n-  bge(len, zr, L_by4_loop);\n-  addiw(len, len, 4);\n-  bgt(len, zr, L_by1_loop);\n-  j(L_exit);\n+  mv(tmp1, unroll_words);\n+  blt(len, tmp1, L_by4_loop_entry);\n+\n+  const Register loop_buf_end = tmp3;\n \n   align(CodeEntryAlignment);\n-  bind(L_unroll_loop_entry);\n-    const Register buf_end = tmp3;\n-    add(buf_end, buf, len); // buf_end will be used as endpoint for loop below\n+  // Entry for L_unroll_loop\n+    add(loop_buf_end, buf, len);    // loop_buf_end will be used as endpoint for loop below\n     andi(len, len, unroll_words-1); // len = (len % unroll_words)\n-    sub(len, len, unroll_words); // Length after all iterations\n+    sub(loop_buf_end, loop_buf_end, len);", "source_url": "https://github.com/openjdk/riscv-port/commit/52c2ea65c4ab6a2d25e9de465fbf20034fe79028", "code_v0_no_empty_lines": "CRC32标量版本代码结构复杂，包含冗余的标签和分支逻辑，循环控制变量处理不够清晰，存在不必要的寄存器操作。", "code_v1_no_empty_lines": "--- a/src/hotspot/cpu/riscv/macroAssembler_riscv.cpp\n+++ b/src/hotspot/cpu/riscv/macroAssembler_riscv.cpp\n@@ -1564,7 +1564,10 @@ void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n         Register table0, Register table1, Register table2, Register table3,\n         Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register tmp6) {\n   assert_different_registers(crc, buf, len, table0, table1, table2, table3, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n-  Label L_by16_loop, L_vector_entry, L_unroll_loop, L_unroll_loop_entry, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;\n+  Label L_vector_entry,\n+        L_unroll_loop,\n+        L_by4_loop_entry, L_by4_loop,\n+        L_by1_loop, L_exit;\n \n   const int64_t single_table_size = 256;\n   const int64_t unroll = 16;\n@@ -1585,21 +1588,17 @@ void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n     bge(len, tmp1, L_vector_entry);\n   }\n #endif // COMPILER2\n-  subw(len, len, unroll_words);\n-  bge(len, zr, L_unroll_loop_entry);\n \n-  addiw(len, len, unroll_words-4);\n-  bge(len, zr, L_by4_loop);\n-  addiw(len, len, 4);\n-  bgt(len, zr, L_by1_loop);\n-  j(L_exit);\n+  mv(tmp1, unroll_words);\n+  blt(len, tmp1, L_by4_loop_entry);\n+\n+  const Register loop_buf_end = tmp3;\n \n   align(CodeEntryAlignment);\n-  bind(L_unroll_loop_entry);\n-    const Register buf_end = tmp3;\n-    add(buf_end, buf, len); // buf_end will be used as endpoint for loop below\n+  // Entry for L_unroll_loop\n+    add(loop_buf_end, buf, len);    // loop_buf_end will be used as endpoint for loop below\n     andi(len, len, unroll_words-1); // len = (len % unroll_words)\n-    sub(len, len, unroll_words); // Length after all iterations\n+    sub(loop_buf_end, loop_buf_end, len);", "target": "--- a/src/hotspot/cpu/riscv/macroAssembler_riscv.cpp\n+++ b/src/hotspot/cpu/riscv/macroAssembler_riscv.cpp\n@@ -1564,7 +1564,10 @@ void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n         Register table0, Register table1, Register table2, Register table3,\n         Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register tmp6) {\n   assert_different_registers(crc, buf, len, table0, table1, table2, table3, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n-  Label L_by16_loop, L_vector_entry, L_unroll_loop, L_unroll_loop_entry, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;\n+  Label L_vector_entry,\n+        L_unroll_loop,\n+        L_by4_loop_entry, L_by4_loop,\n+        L_by1_loop, L_exit;\n \n   const int64_t single_table_size = 256;\n   const int64_t unroll = 16;\n@@ -1585,21 +1588,17 @@ void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n     bge(len, tmp1, L_vector_entry);\n   }\n #endif // COMPILER2\n-  subw(len, len, unroll_words);\n-  bge(len, zr, L_unroll_loop_entry);\n \n-  addiw(len, len, unroll_words-4);\n-  bge(len, zr, L_by4_loop);\n-  addiw(len, len, 4);\n-  bgt(len, zr, L_by1_loop);\n-  j(L_exit);\n+  mv(tmp1, unroll_words);\n+  blt(len, tmp1, L_by4_loop_entry);\n+\n+  const Register loop_buf_end = tmp3;\n \n   align(CodeEntryAlignment);\n-  bind(L_unroll_loop_entry);\n-    const Register buf_end = tmp3;\n-    add(buf_end, buf, len); // buf_end will be used as endpoint for loop below\n+  // Entry for L_unroll_loop\n+    add(loop_buf_end, buf, len);    // loop_buf_end will be used as endpoint for loop below\n     andi(len, len, unroll_words-1); // len = (len % unroll_words)\n-    sub(len, len, unroll_words); // Length after all iterations\n+    sub(loop_buf_end, loop_buf_end, len);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CRC32标量版本代码结构复杂，包含冗余的标签和分支逻辑，循环控制变量处理不够清晰，存在不必要的寄存器操作。优化后：重构了循环控制逻辑，简化了标签结构（如移除L_by16_loop、L_unroll_loop_entry等），使用统一的loop_buf_end寄存器管理循环边界，优化了分支跳转路径（如将多个条件跳转合并为blt指令），减少了指令数量和寄存器操作。优化思路：通过代码重构提高可读性和维护性，同时优化控制流减少分支预测失败和指令执行开销，提升CRC32计算性能。"}
{"id": 714, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：TypeInterfaces对象和其接口数组分开分配内存，导致hashcons()无法回收TypeInterfaces占用的内存，造成内存泄漏。优化后：将TypeInterfaces对象和接口数组分配为连续内存块，使得hashcons()能够一次性回收整个内存块。优化思路：通过自定义内存分配，确保对象和数组在物理上连续，解决内存回收问题。", "original_code": "TypeInterfaces对象和其接口数组分开分配内存，导致hashcons()无法回收TypeInterfaces占用的内存，造成内存泄漏。", "optimized_code": "TypeInterfaces* result = (interfaces == nullptr) ? new TypeInterfaces() : new TypeInterfaces(interfaces);\n+  int nb_interfaces = interfaces == nullptr ? 0 : interfaces->length();\n+  size_t total_size = sizeof(TypeInterfaces) + nb_interfaces * sizeof(ciInstanceKlass*);\n+  void* allocated_mem = operator new(total_size);\n+  ciInstanceKlass** interfaces_base = (ciInstanceKlass**)((char*)allocated_mem + sizeof(TypeInterfaces));\n+  for (int i = 0; i < nb_interfaces; ++i) {\n+    interfaces_base[i] = interfaces->at(i);\n+  }\n+  TypeInterfaces* result = ::new (allocated_mem) TypeInterfaces(interfaces_base, nb_interfaces);", "source_url": "https://github.com/openjdk/riscv-port/commit/90c944fefe4a7827c08a8e6a81f137c3157a749b", "code_v0_no_empty_lines": "TypeInterfaces对象和其接口数组分开分配内存，导致hashcons()无法回收TypeInterfaces占用的内存，造成内存泄漏。", "code_v1_no_empty_lines": "TypeInterfaces* result = (interfaces == nullptr) ? new TypeInterfaces() : new TypeInterfaces(interfaces);\n+  int nb_interfaces = interfaces == nullptr ? 0 : interfaces->length();\n+  size_t total_size = sizeof(TypeInterfaces) + nb_interfaces * sizeof(ciInstanceKlass*);\n+  void* allocated_mem = operator new(total_size);\n+  ciInstanceKlass** interfaces_base = (ciInstanceKlass**)((char*)allocated_mem + sizeof(TypeInterfaces));\n+  for (int i = 0; i < nb_interfaces; ++i) {\n+    interfaces_base[i] = interfaces->at(i);\n+  }\n+  TypeInterfaces* result = ::new (allocated_mem) TypeInterfaces(interfaces_base, nb_interfaces);", "target": "TypeInterfaces* result = (interfaces == nullptr) ? new TypeInterfaces() : new TypeInterfaces(interfaces);\n+  int nb_interfaces = interfaces == nullptr ? 0 : interfaces->length();\n+  size_t total_size = sizeof(TypeInterfaces) + nb_interfaces * sizeof(ciInstanceKlass*);\n+  void* allocated_mem = operator new(total_size);\n+  ciInstanceKlass** interfaces_base = (ciInstanceKlass**)((char*)allocated_mem + sizeof(TypeInterfaces));\n+  for (int i = 0; i < nb_interfaces; ++i) {\n+    interfaces_base[i] = interfaces->at(i);\n+  }\n+  TypeInterfaces* result = ::new (allocated_mem) TypeInterfaces(interfaces_base, nb_interfaces);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：TypeInterfaces对象和其接口数组分开分配内存，导致hashcons()无法回收TypeInterfaces占用的内存，造成内存泄漏。优化后：将TypeInterfaces对象和接口数组分配为连续内存块，使得hashcons()能够一次性回收整个内存块。优化思路：通过自定义内存分配，确保对象和数组在物理上连续，解决内存回收问题。"}
{"id": 715, "source": "riscv-dataset-excel", "optimization_type": "编译器Bug修复+类型系统优化", "optimization_description": "优化前：C2编译器在处理Unsafe::getShortUnaligned等操作时，当null指针被CheckCastPP节点包装后，原有的类型检查base_type == TypePtr::NULL_PTR无法正确识别null指针，导致编译器崩溃。优化后：通过_gvn.type(base->uncast())获取底层节点的真实类型，能够穿透CheckCastPP节点正确识别null指针。优化思路：修复类型系统检查逻辑，确保在存在CheckCastPP节点的情况下仍能正确识别null指针，避免编译器崩溃，同时添加断言确保地址构造不会意外停止。", "original_code": "C2编译器在处理Unsafe::getShortUnaligned等操作时，当null指针被CheckCastPP节点包装后，原有的类型检查base_type == TypePtr::NULL_PTR无法正确识别null指针，导致编译器崩溃。", "optimized_code": "@@ -2052,7 +2052,7 @@ LibraryCallKit::classify_unsafe_addr(Node* &base, Node* &offset, BasicType type)\n   if (base_type == nullptr) {\n     // Unknown type.\n     return Type::AnyPtr;\n-  } else if (base_type == TypePtr::NULL_PTR) {\n+  } else if (_gvn.type(base->uncast()) == TypePtr::NULL_PTR) {\n     // Since this is a null+long form, we have to switch to a rawptr.\n     base   = _gvn.transform(new CastX2PNode(offset));\n     offset = MakeConX(0);\n@@ -2370,8 +2370,9 @@ bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, c\n   SafePointNode* old_map = clone_map();\n \n   Node* adr = make_unsafe_address(base, offset, type, kind == Relaxed);\n+  assert(!stopped(), \"Inlining of unsafe access failed: address construction stopped unexpectedly\");\n \n-  if (_gvn.type(base)->isa_ptr() == TypePtr::NULL_PTR) {\n+  if (_gvn.type(base->uncast())->isa_ptr() == TypePtr::NULL_PTR) {\n     if (type != T_OBJECT) {\n       decorators |= IN_NATIVE; // off-heap primitive access\n     } else {", "source_url": "https://github.com/openjdk/riscv-port/commit/8d6d37fea133380d4143f5db38ad3790efa84f68", "code_v0_no_empty_lines": "C2编译器在处理Unsafe::getShortUnaligned等操作时，当null指针被CheckCastPP节点包装后，原有的类型检查base_type == TypePtr::NULL_PTR无法正确识别null指针，导致编译器崩溃。", "code_v1_no_empty_lines": "@@ -2052,7 +2052,7 @@ LibraryCallKit::classify_unsafe_addr(Node* &base, Node* &offset, BasicType type)\n   if (base_type == nullptr) {\n     // Unknown type.\n     return Type::AnyPtr;\n-  } else if (base_type == TypePtr::NULL_PTR) {\n+  } else if (_gvn.type(base->uncast()) == TypePtr::NULL_PTR) {\n     // Since this is a null+long form, we have to switch to a rawptr.\n     base   = _gvn.transform(new CastX2PNode(offset));\n     offset = MakeConX(0);\n@@ -2370,8 +2370,9 @@ bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, c\n   SafePointNode* old_map = clone_map();\n \n   Node* adr = make_unsafe_address(base, offset, type, kind == Relaxed);\n+  assert(!stopped(), \"Inlining of unsafe access failed: address construction stopped unexpectedly\");\n \n-  if (_gvn.type(base)->isa_ptr() == TypePtr::NULL_PTR) {\n+  if (_gvn.type(base->uncast())->isa_ptr() == TypePtr::NULL_PTR) {\n     if (type != T_OBJECT) {\n       decorators |= IN_NATIVE; // off-heap primitive access\n     } else {", "target": "@@ -2052,7 +2052,7 @@ LibraryCallKit::classify_unsafe_addr(Node* &base, Node* &offset, BasicType type)\n   if (base_type == nullptr) {\n     // Unknown type.\n     return Type::AnyPtr;\n-  } else if (base_type == TypePtr::NULL_PTR) {\n+  } else if (_gvn.type(base->uncast()) == TypePtr::NULL_PTR) {\n     // Since this is a null+long form, we have to switch to a rawptr.\n     base   = _gvn.transform(new CastX2PNode(offset));\n     offset = MakeConX(0);\n@@ -2370,8 +2370,9 @@ bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, c\n   SafePointNode* old_map = clone_map();\n \n   Node* adr = make_unsafe_address(base, offset, type, kind == Relaxed);\n+  assert(!stopped(), \"Inlining of unsafe access failed: address construction stopped unexpectedly\");\n \n-  if (_gvn.type(base)->isa_ptr() == TypePtr::NULL_PTR) {\n+  if (_gvn.type(base->uncast())->isa_ptr() == TypePtr::NULL_PTR) {\n     if (type != T_OBJECT) {\n       decorators |= IN_NATIVE; // off-heap primitive access\n     } else {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：C2编译器在处理Unsafe::getShortUnaligned等操作时，当null指针被CheckCastPP节点包装后，原有的类型检查base_type == TypePtr::NULL_PTR无法正确识别null指针，导致编译器崩溃。优化后：通过_gvn.type(base->uncast())获取底层节点的真实类型，能够穿透CheckCastPP节点正确识别null指针。优化思路：修复类型系统检查逻辑，确保在存在CheckCastPP节点的情况下仍能正确识别null指针，避免编译器崩溃，同时添加断言确保地址构造不会意外停止。"}
{"id": 716, "source": "riscv-dataset-excel", "optimization_type": "内存分配优化", "optimization_description": "优化前：多个类中硬编码使用Integer.MAX_VALUE - 8作为最大数组大小限制，这个值在某些VM中可能不是最优选择。优化后：统一使用ArraysSupport.SOFT_MAX_ARRAY_LENGTH常量，该常量根据VM特性动态确定最大数组大小，能更好地利用可用内存并避免不必要的内存限制。思路：通过集中管理最大数组大小常量，提高代码一致性，并允许VM根据实际内存布局优化数组分配。", "original_code": "多个类中硬编码使用Integer.MAX_VALUE - 8作为最大数组大小限制，这个值在某些VM中可能不是最优选择。", "optimized_code": "- private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n+ private static final int MAX_BUFFER_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;", "source_url": "https://github.com/openjdk/riscv-port/commit/0f381137cb9338453a7d77a7ebdfaa9b34b5028b", "code_v0_no_empty_lines": "多个类中硬编码使用Integer.MAX_VALUE - 8作为最大数组大小限制，这个值在某些VM中可能不是最优选择。", "code_v1_no_empty_lines": "- private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n+ private static final int MAX_BUFFER_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;", "target": "- private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n+ private static final int MAX_BUFFER_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多个类中硬编码使用Integer.MAX_VALUE - 8作为最大数组大小限制，这个值在某些VM中可能不是最优选择。优化后：统一使用ArraysSupport.SOFT_MAX_ARRAY_LENGTH常量，该常量根据VM特性动态确定最大数组大小，能更好地利用可用内存并避免不必要的内存限制。思路：通过集中管理最大数组大小常量，提高代码一致性，并允许VM根据实际内存布局优化数组分配。"}
{"id": 717, "source": "riscv-dataset-excel", "optimization_type": "算法优化+性能优化", "optimization_description": "优化前：leftShift方法使用bitLengthForInt计算高位位数，逻辑复杂且包含多个分支；copyAndShift方法用于除法中的移位操作，代码重复。优化后：1. 使用Integer.numberOfLeadingZeros替代bitLengthForInt，更高效；2. 重构leftShift算法，简化逻辑，减少分支；3. 新增primitiveLeftShift/primitiveRightShift的重载版本，支持直接写入目标数组，避免额外复制；4. 移除copyAndShift方法，在divideMagnitude中直接调用新的移位方法，消除代码重复。优化思路：通过使用更高效的API和重构算法，减少计算开销和代码冗余，提升大整数左移操作的性能。", "original_code": "leftShift方法使用bitLengthForInt计算高位位数，逻辑复杂且包含多个分支；copyAndShift方法用于除法中的移位操作，代码重复。", "optimized_code": "1. leftShift方法重构：\n- int bitsInHighWord = BigInteger.bitLengthForInt(value[offset]);\n+ int leadingZeros = Integer.numberOfLeadingZeros(value[offset]);\n- if (n <= (32-bitsInHighWord)) {\n+ if (n <= leadingZeros) {\n\n2. 新增primitiveLeftShift/primitiveRightShift重载方法：\n+ private void primitiveRightShift(int n, int[] result, int resFrom) {\n+ private void primitiveLeftShift(int n, int[] result, int resFrom) {\n\n3. 移除copyAndShift方法：\n- private static void copyAndShift(int[] src, int srcFrom, int srcLen, int[] dst, int dstFrom, int shift) {\n\n4. 在divideMagnitude中使用新方法：\n- copyAndShift(div.value,div.offset,dlen,divisor,0,shift);\n+ div.primitiveLeftShift(shift, divisor, 0);\n- copyAndShift(value,offset,intLen,remarr,1,shift);\n+ this.primitiveLeftShift(shift, remarr, 1);", "source_url": "https://github.com/openjdk/riscv-port/commit/d6820d1324711eac95a297dd68ec94e6f6be4b35", "code_v0_no_empty_lines": "leftShift方法使用bitLengthForInt计算高位位数，逻辑复杂且包含多个分支；copyAndShift方法用于除法中的移位操作，代码重复。", "code_v1_no_empty_lines": "1. leftShift方法重构：\n- int bitsInHighWord = BigInteger.bitLengthForInt(value[offset]);\n+ int leadingZeros = Integer.numberOfLeadingZeros(value[offset]);\n- if (n <= (32-bitsInHighWord)) {\n+ if (n <= leadingZeros) {\n\n2. 新增primitiveLeftShift/primitiveRightShift重载方法：\n+ private void primitiveRightShift(int n, int[] result, int resFrom) {\n+ private void primitiveLeftShift(int n, int[] result, int resFrom) {\n\n3. 移除copyAndShift方法：\n- private static void copyAndShift(int[] src, int srcFrom, int srcLen, int[] dst, int dstFrom, int shift) {\n\n4. 在divideMagnitude中使用新方法：\n- copyAndShift(div.value,div.offset,dlen,divisor,0,shift);\n+ div.primitiveLeftShift(shift, divisor, 0);\n- copyAndShift(value,offset,intLen,remarr,1,shift);\n+ this.primitiveLeftShift(shift, remarr, 1);", "target": "1. leftShift方法重构：\n- int bitsInHighWord = BigInteger.bitLengthForInt(value[offset]);\n+ int leadingZeros = Integer.numberOfLeadingZeros(value[offset]);\n- if (n <= (32-bitsInHighWord)) {\n+ if (n <= leadingZeros) {\n\n2. 新增primitiveLeftShift/primitiveRightShift重载方法：\n+ private void primitiveRightShift(int n, int[] result, int resFrom) {\n+ private void primitiveLeftShift(int n, int[] result, int resFrom) {\n\n3. 移除copyAndShift方法：\n- private static void copyAndShift(int[] src, int srcFrom, int srcLen, int[] dst, int dstFrom, int shift) {\n\n4. 在divideMagnitude中使用新方法：\n- copyAndShift(div.value,div.offset,dlen,divisor,0,shift);\n+ div.primitiveLeftShift(shift, divisor, 0);\n- copyAndShift(value,offset,intLen,remarr,1,shift);\n+ this.primitiveLeftShift(shift, remarr, 1);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：leftShift方法使用bitLengthForInt计算高位位数，逻辑复杂且包含多个分支；copyAndShift方法用于除法中的移位操作，代码重复。优化后：1. 使用Integer.numberOfLeadingZeros替代bitLengthForInt，更高效；2. 重构leftShift算法，简化逻辑，减少分支；3. 新增primitiveLeftShift/primitiveRightShift的重载版本，支持直接写入目标数组，避免额外复制；4. 移除copyAndShift方法，在divideMagnitude中直接调用新的移位方法，消除代码重复。优化思路：通过使用更高效的API和重构算法，减少计算开销和代码冗余，提升大整数左移操作的性能。"}
{"id": 718, "source": "riscv-dataset-excel", "optimization_type": "向量化API优化", "optimization_description": "优化前：Vector API的rearrange/selectFrom方法使用checkIndexes进行索引边界检查，当索引越界时抛出异常。优化后：改为使用wrapIndexes进行索引包装，将越界索引通过取模运算包装到有效范围内。优化思路：避免异常处理开销，通过数学运算替代边界检查，提升向量重排和选择操作的性能，特别是在循环和重复模式中。", "original_code": "Vector API的rearrange/selectFrom方法使用checkIndexes进行索引边界检查，当索引越界时抛出异常。", "optimized_code": "do_intrinsic(_VectorWrapShuffleIndexes, jdk_internal_vm_vector_VectorSupport, vector_wrap_shuffle_indexes_name, vector_wrap_shuffle_indexes_sig, F_S)\n   do_signature(vector_wrap_shuffle_indexes_sig, \"(Ljava/lang/Class;\"\n                                                  \"Ljava/lang/Class;\"\n                                                  \"Ljdk/internal/vm/vector/VectorSupport$VectorShuffle;\"\n                                                  \"ILjdk/internal/vm/vector/VectorSupport$WrapShuffleIndexesOperation;)\"\n                                                  \"Ljdk/internal/vm/vector/VectorSupport$VectorShuffle;\")", "source_url": "https://github.com/openjdk/riscv-port/commit/83dcb02d776448aa04f3f41df489bd4355443a4d", "code_v0_no_empty_lines": "Vector API的rearrange/selectFrom方法使用checkIndexes进行索引边界检查，当索引越界时抛出异常。", "code_v1_no_empty_lines": "do_intrinsic(_VectorWrapShuffleIndexes, jdk_internal_vm_vector_VectorSupport, vector_wrap_shuffle_indexes_name, vector_wrap_shuffle_indexes_sig, F_S)\n   do_signature(vector_wrap_shuffle_indexes_sig, \"(Ljava/lang/Class;\"\n                                                  \"Ljava/lang/Class;\"\n                                                  \"Ljdk/internal/vm/vector/VectorSupport$VectorShuffle;\"\n                                                  \"ILjdk/internal/vm/vector/VectorSupport$WrapShuffleIndexesOperation;)\"\n                                                  \"Ljdk/internal/vm/vector/VectorSupport$VectorShuffle;\")", "target": "do_intrinsic(_VectorWrapShuffleIndexes, jdk_internal_vm_vector_VectorSupport, vector_wrap_shuffle_indexes_name, vector_wrap_shuffle_indexes_sig, F_S)\n   do_signature(vector_wrap_shuffle_indexes_sig, \"(Ljava/lang/Class;\"\n                                                  \"Ljava/lang/Class;\"\n                                                  \"Ljdk/internal/vm/vector/VectorSupport$VectorShuffle;\"\n                                                  \"ILjdk/internal/vm/vector/VectorSupport$WrapShuffleIndexesOperation;)\"\n                                                  \"Ljdk/internal/vm/vector/VectorSupport$VectorShuffle;\")", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Vector API的rearrange/selectFrom方法使用checkIndexes进行索引边界检查，当索引越界时抛出异常。优化后：改为使用wrapIndexes进行索引包装，将越界索引通过取模运算包装到有效范围内。优化思路：避免异常处理开销，通过数学运算替代边界检查，提升向量重排和选择操作的性能，特别是在循环和重复模式中。"}
{"id": 719, "source": "riscv-dataset-excel", "optimization_type": "代码重构+内存优化", "optimization_description": "优化前：使用全局静态变量_global_dumper和_global_writer管理堆转储状态，通过静态方法do_load_class处理类加载记录，存在线程安全隐患和全局状态管理复杂性。优化后：移除所有静态变量和方法，将do_load_class重构为LoadedClassDumper类，作为LockedClassesDo的实现，通过实例方法do_klass生成HPROF_LOAD_CLASS记录，并将_writer作为成员变量直接使用。优化思路：消除全局状态，提高代码可维护性和线程安全性，简化内存管理，减少潜在的内存泄漏风险。", "original_code": "使用全局静态变量_global_dumper和_global_writer管理堆转储状态，通过静态方法do_load_class处理类加载记录，存在线程安全隐患和全局状态管理复杂性。", "optimized_code": "- static VM_HeapDumper*   _global_dumper;\n- static DumpWriter*      _global_writer;\n- DumpWriter*             _local_writer;\n+ DumpWriter*             _writer;\n- static void do_load_class(Klass* k);\n+ class LoadedClassDumper : public LockedClassesDo {\n+   void do_klass(Klass* k) {\n+     // ... 生成HPROF_LOAD_CLASS记录\n+   }\n+ };\n- LockedClassesDo locked_load_classes(&do_load_class);\n+ LoadedClassDumper loaded_class_dumper(writer(), _klass_map);", "source_url": "https://github.com/openjdk/riscv-port/commit/03149735e59b7d1d409a6e29ee05ae0537e03d53", "code_v0_no_empty_lines": "使用全局静态变量_global_dumper和_global_writer管理堆转储状态，通过静态方法do_load_class处理类加载记录，存在线程安全隐患和全局状态管理复杂性。", "code_v1_no_empty_lines": "- static VM_HeapDumper*   _global_dumper;\n- static DumpWriter*      _global_writer;\n- DumpWriter*             _local_writer;\n+ DumpWriter*             _writer;\n- static void do_load_class(Klass* k);\n+ class LoadedClassDumper : public LockedClassesDo {\n+   void do_klass(Klass* k) {\n+     // ... 生成HPROF_LOAD_CLASS记录\n+   }\n+ };\n- LockedClassesDo locked_load_classes(&do_load_class);\n+ LoadedClassDumper loaded_class_dumper(writer(), _klass_map);", "target": "- static VM_HeapDumper*   _global_dumper;\n- static DumpWriter*      _global_writer;\n- DumpWriter*             _local_writer;\n+ DumpWriter*             _writer;\n- static void do_load_class(Klass* k);\n+ class LoadedClassDumper : public LockedClassesDo {\n+   void do_klass(Klass* k) {\n+     // ... 生成HPROF_LOAD_CLASS记录\n+   }\n+ };\n- LockedClassesDo locked_load_classes(&do_load_class);\n+ LoadedClassDumper loaded_class_dumper(writer(), _klass_map);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用全局静态变量_global_dumper和_global_writer管理堆转储状态，通过静态方法do_load_class处理类加载记录，存在线程安全隐患和全局状态管理复杂性。优化后：移除所有静态变量和方法，将do_load_class重构为LoadedClassDumper类，作为LockedClassesDo的实现，通过实例方法do_klass生成HPROF_LOAD_CLASS记录，并将_writer作为成员变量直接使用。优化思路：消除全局状态，提高代码可维护性和线程安全性，简化内存管理，减少潜在的内存泄漏风险。"}
{"id": 720, "source": "riscv-dataset-excel", "optimization_type": "编译器优化/GC屏障匹配修复", "optimization_description": "优化前：is_gc_barrier_node函数仅通过is_shenandoah_lrb_call检查LRB节点，导致某些LRB节点未被正确识别为GC屏障。优化后：显式添加对Op_ShenandoahLoadReferenceBarrier操作码的直接检查，确保所有LRB节点都能被正确匹配为GC屏障。思路：修复JDK-8340183引入的回归问题，确保编译器优化阶段能正确处理Shenandoah GC的屏障节点。", "original_code": "is_gc_barrier_node函数仅通过is_shenandoah_lrb_call检查LRB节点，导致某些LRB节点未被正确识别为GC屏障。", "optimized_code": "-  return is_shenandoah_lrb_call(node) ||\n+  return (node->Opcode() == Op_ShenandoahLoadReferenceBarrier) ||\n+         is_shenandoah_lrb_call(node) ||", "source_url": "https://github.com/openjdk/riscv-port/commit/684d246ccf497f599ffcd498f2fbe4b1b2357e27", "code_v0_no_empty_lines": "is_gc_barrier_node函数仅通过is_shenandoah_lrb_call检查LRB节点，导致某些LRB节点未被正确识别为GC屏障。", "code_v1_no_empty_lines": "-  return is_shenandoah_lrb_call(node) ||\n+  return (node->Opcode() == Op_ShenandoahLoadReferenceBarrier) ||\n+         is_shenandoah_lrb_call(node) ||", "target": "-  return is_shenandoah_lrb_call(node) ||\n+  return (node->Opcode() == Op_ShenandoahLoadReferenceBarrier) ||\n+         is_shenandoah_lrb_call(node) ||", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：is_gc_barrier_node函数仅通过is_shenandoah_lrb_call检查LRB节点，导致某些LRB节点未被正确识别为GC屏障。优化后：显式添加对Op_ShenandoahLoadReferenceBarrier操作码的直接检查，确保所有LRB节点都能被正确匹配为GC屏障。思路：修复JDK-8340183引入的回归问题，确保编译器优化阶段能正确处理Shenandoah GC的屏障节点。"}
{"id": 721, "source": "riscv-dataset-excel", "optimization_type": "JVMCI接口扩展", "optimization_description": "优化前：JVMCI无法访问JavaThread::_unlocked_inflated_monitor字段，限制了JVMCI编译器的监控和优化能力。优化后：将该字段导出到JVMCI的vmStructs中，使JVMCI编译器能够直接访问此监控器信息。思路：通过扩展JVMCI接口，为JVMCI编译器提供更多运行时信息，支持更精细的性能分析和优化决策。", "original_code": "JVMCI无法访问JavaThread::_unlocked_inflated_monitor字段，限制了JVMCI编译器的监控和优化能力。", "optimized_code": "+  nonstatic_field(JavaThread,                  _unlocked_inflated_monitor,                    ObjectMonitor*)                        \\", "source_url": "https://github.com/openjdk/riscv-port/commit/2120a8414ef9c34d5875d33ac9a16594908fe403", "code_v0_no_empty_lines": "JVMCI无法访问JavaThread::_unlocked_inflated_monitor字段，限制了JVMCI编译器的监控和优化能力。", "code_v1_no_empty_lines": "+  nonstatic_field(JavaThread,                  _unlocked_inflated_monitor,                    ObjectMonitor*)                        \\", "target": "+  nonstatic_field(JavaThread,                  _unlocked_inflated_monitor,                    ObjectMonitor*)                        \\", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：JVMCI无法访问JavaThread::_unlocked_inflated_monitor字段，限制了JVMCI编译器的监控和优化能力。优化后：将该字段导出到JVMCI的vmStructs中，使JVMCI编译器能够直接访问此监控器信息。思路：通过扩展JVMCI接口，为JVMCI编译器提供更多运行时信息，支持更精细的性能分析和优化决策。"}
{"id": 722, "source": "riscv-dataset-excel", "optimization_type": "线程资源分配优化", "optimization_description": "优化前：libjvmci线程分配比例为0.33，可能导致libgraal线程数不足，影响JVMCI编译器性能。优化后：将线程分配比例提高到0.66，增加libjvmci可用的编译器线程数量，提升JVMCI编译性能，但可能增加内存占用（RSS）。优化思路：通过调整线程资源分配比例，在内存占用和编译性能之间取得更好平衡。", "original_code": "libjvmci线程分配比例为0.33，可能导致libgraal线程数不足，影响JVMCI编译器性能。", "optimized_code": "-  product(double, JVMCINativeLibraryThreadFraction, 0.33, EXPERIMENTAL,     \\\n+  product(double, JVMCINativeLibraryThreadFraction, 0.66, EXPERIMENTAL,     \\", "source_url": "https://github.com/openjdk/riscv-port/commit/7cc7c080b5dbab61914512bf63227944697c0cbe", "code_v0_no_empty_lines": "libjvmci线程分配比例为0.33，可能导致libgraal线程数不足，影响JVMCI编译器性能。", "code_v1_no_empty_lines": "-  product(double, JVMCINativeLibraryThreadFraction, 0.33, EXPERIMENTAL,     \\\n+  product(double, JVMCINativeLibraryThreadFraction, 0.66, EXPERIMENTAL,     \\", "target": "-  product(double, JVMCINativeLibraryThreadFraction, 0.33, EXPERIMENTAL,     \\\n+  product(double, JVMCINativeLibraryThreadFraction, 0.66, EXPERIMENTAL,     \\", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：libjvmci线程分配比例为0.33，可能导致libgraal线程数不足，影响JVMCI编译器性能。优化后：将线程分配比例提高到0.66，增加libjvmci可用的编译器线程数量，提升JVMCI编译性能，但可能增加内存占用（RSS）。优化思路：通过调整线程资源分配比例，在内存占用和编译性能之间取得更好平衡。"}
{"id": 723, "source": "riscv-dataset-excel", "optimization_type": "代码清理/编译优化", "optimization_description": "优化前：psScavenge.hpp头文件中包含两个不必要的前向声明（ReferenceProcessor和ParallelScavengeTracer），增加了编译依赖和编译时间。优化后：移除这两个未使用的类前向声明，减少头文件依赖，简化编译过程，提高编译效率。", "original_code": "psScavenge.hpp头文件中包含两个不必要的前向声明（ReferenceProcessor和ParallelScavengeTracer），增加了编译依赖和编译时间。", "optimized_code": "-class ReferenceProcessor;\n-class ParallelScavengeTracer;", "source_url": "https://github.com/openjdk/riscv-port/commit/7b1e6f8ed9dbc07158717a32d341393afaa54b66", "code_v0_no_empty_lines": "psScavenge.hpp头文件中包含两个不必要的前向声明（ReferenceProcessor和ParallelScavengeTracer），增加了编译依赖和编译时间。", "code_v1_no_empty_lines": "-class ReferenceProcessor;\n-class ParallelScavengeTracer;", "target": "-class ReferenceProcessor;\n-class ParallelScavengeTracer;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：psScavenge.hpp头文件中包含两个不必要的前向声明（ReferenceProcessor和ParallelScavengeTracer），增加了编译依赖和编译时间。优化后：移除这两个未使用的类前向声明，减少头文件依赖，简化编译过程，提高编译效率。"}
{"id": 724, "source": "riscv-dataset-excel", "optimization_type": "指令级并行优化", "optimization_description": "优化前：MD5计算中的关键步骤存在数据依赖链，and/bic/or/add操作串行执行，限制了CPU的指令级并行能力。优化后：重构计算顺序，将or操作替换为独立的add操作，打破数据依赖，允许and/bic/add等操作并行执行。优化思路：通过减少指令间的数据依赖，提高CPU流水线利用率和指令级并行度，从而提升MD5哈希计算的性能。", "original_code": "MD5计算中的关键步骤存在数据依赖链，and/bic/or/add操作串行执行，限制了CPU的指令级并行能力。", "optimized_code": "AArch64: __ andw(rscratch3, r2, r4);\n__ bicw(rscratch4, r3, r4);\n__ orrw(rscratch3, rscratch3, rscratch4);\n__ addw(rscratch3, rscratch3, rscratch4);\n__ rorw(rscratch2, rscratch3, 32 - s);\n改为:\n__ bicw(rscratch2, r3, r4);\n__ andw(rscratch3, r2, r4);\n__ addw(rscratch2, rscratch2, rscratch4);\n__ addw(rscratch2, rscratch2, rscratch3);\n__ rorw(rscratch2, rscratch2, 32 - s);\nx86: orl(rsi, rdi);\naddl(r1, rsi);\n改为:\naddl(r1, rsi);\naddl(r1, rdi);", "source_url": "https://github.com/openjdk/riscv-port/commit/1cf26a5179e619f17909426fdb26a3fb3b748483", "code_v0_no_empty_lines": "MD5计算中的关键步骤存在数据依赖链，and/bic/or/add操作串行执行，限制了CPU的指令级并行能力。", "code_v1_no_empty_lines": "AArch64: __ andw(rscratch3, r2, r4);\n__ bicw(rscratch4, r3, r4);\n__ orrw(rscratch3, rscratch3, rscratch4);\n__ addw(rscratch3, rscratch3, rscratch4);\n__ rorw(rscratch2, rscratch3, 32 - s);\n改为:\n__ bicw(rscratch2, r3, r4);\n__ andw(rscratch3, r2, r4);\n__ addw(rscratch2, rscratch2, rscratch4);\n__ addw(rscratch2, rscratch2, rscratch3);\n__ rorw(rscratch2, rscratch2, 32 - s);\nx86: orl(rsi, rdi);\naddl(r1, rsi);\n改为:\naddl(r1, rsi);\naddl(r1, rdi);", "target": "AArch64: __ andw(rscratch3, r2, r4);\n__ bicw(rscratch4, r3, r4);\n__ orrw(rscratch3, rscratch3, rscratch4);\n__ addw(rscratch3, rscratch3, rscratch4);\n__ rorw(rscratch2, rscratch3, 32 - s);\n改为:\n__ bicw(rscratch2, r3, r4);\n__ andw(rscratch3, r2, r4);\n__ addw(rscratch2, rscratch2, rscratch4);\n__ addw(rscratch2, rscratch2, rscratch3);\n__ rorw(rscratch2, rscratch2, 32 - s);\nx86: orl(rsi, rdi);\naddl(r1, rsi);\n改为:\naddl(r1, rsi);\naddl(r1, rdi);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：MD5计算中的关键步骤存在数据依赖链，and/bic/or/add操作串行执行，限制了CPU的指令级并行能力。优化后：重构计算顺序，将or操作替换为独立的add操作，打破数据依赖，允许and/bic/add等操作并行执行。优化思路：通过减少指令间的数据依赖，提高CPU流水线利用率和指令级并行度，从而提升MD5哈希计算的性能。"}
{"id": 725, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+算法优化", "optimization_description": "优化前：AES-GCM算法在x86_64平台上使用较旧的AVX2指令集实现，性能有限。优化后：新增AVX-512指令集支持（如evinserti64x2、evbroadcastf64x2），重构stubGenerator中的AES-GCM实现，使用更高效的并行处理（ghash16_encrypt_parallel16_avx512等函数）。优化思路：利用AVX-512的512位向量寄存器和增强指令，提高AES加密和GHASH操作的并行度，减少指令数量，提升加解密吞吐量。", "original_code": "AES-GCM算法在x86_64平台上使用较旧的AVX2指令集实现，性能有限。", "optimized_code": "void Assembler::evinserti64x2(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8, int vector_len) {\n   assert(VM_Version::supports_avx512dq(), \"\");\n   assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n   attributes.set_is_evex_instruction();\n   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n   emit_int24(0x38, (0xC0 | encode), imm8 & 0x03);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/a6b318863fa2775b6381977875b4f466af47beb8", "code_v0_no_empty_lines": "AES-GCM算法在x86_64平台上使用较旧的AVX2指令集实现，性能有限。", "code_v1_no_empty_lines": "void Assembler::evinserti64x2(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8, int vector_len) {\n   assert(VM_Version::supports_avx512dq(), \"\");\n   assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n   attributes.set_is_evex_instruction();\n   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n   emit_int24(0x38, (0xC0 | encode), imm8 & 0x03);\n}", "target": "void Assembler::evinserti64x2(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8, int vector_len) {\n   assert(VM_Version::supports_avx512dq(), \"\");\n   assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);\n   attributes.set_is_evex_instruction();\n   int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n   emit_int24(0x38, (0xC0 | encode), imm8 & 0x03);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AES-GCM算法在x86_64平台上使用较旧的AVX2指令集实现，性能有限。优化后：新增AVX-512指令集支持（如evinserti64x2、evbroadcastf64x2），重构stubGenerator中的AES-GCM实现，使用更高效的并行处理（ghash16_encrypt_parallel16_avx512等函数）。优化思路：利用AVX-512的512位向量寄存器和增强指令，提高AES加密和GHASH操作的并行度，减少指令数量，提升加解密吞吐量。"}
{"id": 726, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码重构", "optimization_description": "优化前：claim_for_alloc函数接受bool force参数，在循环中每次调用都需要传递参数并检查条件。优化后：将函数改为模板函数，通过模板参数FORCE在编译时确定行为，消除了运行时参数传递和条件检查的开销。同时重构了pace_for_alloc函数，简化了等待逻辑，使用更精确的时间计算（纳秒计数器替代毫秒计时），减少了不必要的循环和条件判断。", "original_code": "claim_for_alloc函数接受bool force参数，在循环中每次调用都需要传递参数并检查条件。", "optimized_code": "- bool claimed = claim_for_alloc(words, false);\n+ bool claimed = claim_for_alloc<false>(words);\n- claimed = claim_for_alloc(words, true);\n+ claimed = claim_for_alloc<true>(words);\n- bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {\n+ template<bool FORCE>\n+ bool ShenandoahPacer::claim_for_alloc(size_t words) {\n- if (cur < tax && !force) {\n+ if (cur < tax && !FORCE) {", "source_url": "https://github.com/openjdk/riscv-port/commit/65200a9589e46956a2194b20c4c90d003351a539", "code_v0_no_empty_lines": "claim_for_alloc函数接受bool force参数，在循环中每次调用都需要传递参数并检查条件。", "code_v1_no_empty_lines": "- bool claimed = claim_for_alloc(words, false);\n+ bool claimed = claim_for_alloc<false>(words);\n- claimed = claim_for_alloc(words, true);\n+ claimed = claim_for_alloc<true>(words);\n- bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {\n+ template<bool FORCE>\n+ bool ShenandoahPacer::claim_for_alloc(size_t words) {\n- if (cur < tax && !force) {\n+ if (cur < tax && !FORCE) {", "target": "- bool claimed = claim_for_alloc(words, false);\n+ bool claimed = claim_for_alloc<false>(words);\n- claimed = claim_for_alloc(words, true);\n+ claimed = claim_for_alloc<true>(words);\n- bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {\n+ template<bool FORCE>\n+ bool ShenandoahPacer::claim_for_alloc(size_t words) {\n- if (cur < tax && !force) {\n+ if (cur < tax && !FORCE) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：claim_for_alloc函数接受bool force参数，在循环中每次调用都需要传递参数并检查条件。优化后：将函数改为模板函数，通过模板参数FORCE在编译时确定行为，消除了运行时参数传递和条件检查的开销。同时重构了pace_for_alloc函数，简化了等待逻辑，使用更精确的时间计算（纳秒计数器替代毫秒计时），减少了不必要的循环和条件判断。"}
{"id": 727, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前使用AtomicInteger的lazySet(0)作为存储屏障，存在不必要的对象创建和间接调用开销。优化后直接调用UNSAFE.storeFence()显式内存屏障，消除AtomicInteger实例开销，提供更清晰的内存语义，提升性能。", "original_code": "// No original code extracted from description\n", "optimized_code": "-        STORE_BARRIER.lazySet(0);\n+        UNSAFE.storeFence();\n-    private static final AtomicInteger STORE_BARRIER = new AtomicInteger();", "source_url": "https://github.com/openjdk/riscv-port/commit/df1959fd7a57f11839d58858bab4ea61f5b2bb8d", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "-        STORE_BARRIER.lazySet(0);\n+        UNSAFE.storeFence();\n-    private static final AtomicInteger STORE_BARRIER = new AtomicInteger();", "target": "-        STORE_BARRIER.lazySet(0);\n+        UNSAFE.storeFence();\n-    private static final AtomicInteger STORE_BARRIER = new AtomicInteger();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用AtomicInteger的lazySet(0)作为存储屏障，存在不必要的对象创建和间接调用开销。优化后直接调用UNSAFE.storeFence()显式内存屏障，消除AtomicInteger实例开销，提供更清晰的内存语义，提升性能。"}
{"id": 728, "source": "riscv-dataset-excel", "optimization_type": "缓存优化+指令集优化", "optimization_description": "优化前：每次代码修改后都需要显式调用ICache::invalidate_range()进行指令缓存刷新，这会带来性能开销和序列化点。优化后：引入UseCtxFencei选项，当启用时利用RISC-V的fence.i指令和内核的PR_RISCV_CTX_SW_FENCEI_ON机制，在上下文切换时自动同步指令缓存，避免显式的缓存刷新操作。优化思路：利用硬件特性减少不必要的缓存刷新，通过条件编译和运行时选项控制两种缓存同步策略，提升整体系统性能。", "original_code": "每次代码修改后都需要显式调用ICache::invalidate_range()进行指令缓存刷新，这会带来性能开销和序列化点。", "optimized_code": "void fencei() {\n    unsigned insn = 0;\n    patch((address)&insn,  6,  0, 0b0001111);      // opcode\n    patch((address)&insn, 11,  7, 0b00000);        // rd\n    patch((address)&insn, 14, 12, 0b001);          // func\n    patch((address)&insn, 19, 15, 0b00000);        // rs1\n    patch((address)&insn, 31, 20, 0b000000000000); // fm\n    emit(insn);\n  }\n\n  // 在多个文件中添加条件判断\n  if (!UseCtxFencei) {\n    ICache::invalidate_range(addr, bytes);\n  }\n\n  // 在stubGenerator中添加\n  if (UseCtxFencei) {\n    __ cmodx_fence();\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/97a3933f1be2cabfc574689bb60618fe6fa3a8a4", "code_v0_no_empty_lines": "每次代码修改后都需要显式调用ICache::invalidate_range()进行指令缓存刷新，这会带来性能开销和序列化点。", "code_v1_no_empty_lines": "void fencei() {\n    unsigned insn = 0;\n    patch((address)&insn,  6,  0, 0b0001111);      // opcode\n    patch((address)&insn, 11,  7, 0b00000);        // rd\n    patch((address)&insn, 14, 12, 0b001);          // func\n    patch((address)&insn, 19, 15, 0b00000);        // rs1\n    patch((address)&insn, 31, 20, 0b000000000000); // fm\n    emit(insn);\n  }\n\n  // 在多个文件中添加条件判断\n  if (!UseCtxFencei) {\n    ICache::invalidate_range(addr, bytes);\n  }\n\n  // 在stubGenerator中添加\n  if (UseCtxFencei) {\n    __ cmodx_fence();\n  }", "target": "void fencei() {\n    unsigned insn = 0;\n    patch((address)&insn,  6,  0, 0b0001111);      // opcode\n    patch((address)&insn, 11,  7, 0b00000);        // rd\n    patch((address)&insn, 14, 12, 0b001);          // func\n    patch((address)&insn, 19, 15, 0b00000);        // rs1\n    patch((address)&insn, 31, 20, 0b000000000000); // fm\n    emit(insn);\n  }\n\n  // 在多个文件中添加条件判断\n  if (!UseCtxFencei) {\n    ICache::invalidate_range(addr, bytes);\n  }\n\n  // 在stubGenerator中添加\n  if (UseCtxFencei) {\n    __ cmodx_fence();\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次代码修改后都需要显式调用ICache::invalidate_range()进行指令缓存刷新，这会带来性能开销和序列化点。优化后：引入UseCtxFencei选项，当启用时利用RISC-V的fence.i指令和内核的PR_RISCV_CTX_SW_FENCEI_ON机制，在上下文切换时自动同步指令缓存，避免显式的缓存刷新操作。优化思路：利用硬件特性减少不必要的缓存刷新，通过条件编译和运行时选项控制两种缓存同步策略，提升整体系统性能。"}
{"id": 729, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+数学函数优化", "optimization_description": "优化前：Java Math.tanh() 函数通过通用的软件实现或调用标准库函数，性能较低。优化后：为 x86_64 架构添加了 tanh 双曲正切函数的内置实现（intrinsic），通过新增 stubGenerator_x86_64_tanh.cpp 文件提供高度优化的汇编代码实现，并添加了 andnpd 指令支持。优化思路：利用 x86_64 架构的 SIMD 指令和 Intel 数学库（LIBM）优化，将数学函数调用从通用的软件路径转换为硬件优化的内置实现，显著提升双曲正切函数的计算性能。", "original_code": "Java Math.tanh() 函数通过通用的软件实现或调用标准库函数，性能较低。", "optimized_code": "diff --git a/src/hotspot/cpu/x86/stubGenerator_x86_64_tanh.cpp b/src/hotspot/cpu/x86/stubGenerator_x86_64_tanh.cpp\nnew file mode 100644\nindex 00000000000..92ac78e15cb\n--- /dev/null\n+++ b/src/hotspot/cpu/x86/stubGenerator_x86_64_tanh.cpp\n@@ -0,0 +1,502 @@\n+/*\n+* Copyright (c) 2024, Intel Corporation. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+/*********************************************************", "source_url": "https://github.com/openjdk/riscv-port/commit/212e32931cafe446d94219d6c3ffd92261984dff", "code_v0_no_empty_lines": "Java Math.tanh() 函数通过通用的软件实现或调用标准库函数，性能较低。", "code_v1_no_empty_lines": "diff --git a/src/hotspot/cpu/x86/stubGenerator_x86_64_tanh.cpp b/src/hotspot/cpu/x86/stubGenerator_x86_64_tanh.cpp\nnew file mode 100644\nindex 00000000000..92ac78e15cb\n--- /dev/null\n+++ b/src/hotspot/cpu/x86/stubGenerator_x86_64_tanh.cpp\n@@ -0,0 +1,502 @@\n+/*\n+* Copyright (c) 2024, Intel Corporation. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+/*********************************************************", "target": "diff --git a/src/hotspot/cpu/x86/stubGenerator_x86_64_tanh.cpp b/src/hotspot/cpu/x86/stubGenerator_x86_64_tanh.cpp\nnew file mode 100644\nindex 00000000000..92ac78e15cb\n--- /dev/null\n+++ b/src/hotspot/cpu/x86/stubGenerator_x86_64_tanh.cpp\n@@ -0,0 +1,502 @@\n+/*\n+* Copyright (c) 2024, Intel Corporation. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+/*********************************************************", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Java Math.tanh() 函数通过通用的软件实现或调用标准库函数，性能较低。优化后：为 x86_64 架构添加了 tanh 双曲正切函数的内置实现（intrinsic），通过新增 stubGenerator_x86_64_tanh.cpp 文件提供高度优化的汇编代码实现，并添加了 andnpd 指令支持。优化思路：利用 x86_64 架构的 SIMD 指令和 Intel 数学库（LIBM）优化，将数学函数调用从通用的软件路径转换为硬件优化的内置实现，显著提升双曲正切函数的计算性能。"}
{"id": 730, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码优化", "optimization_description": "优化前：1. 多个独立的write调用产生额外开销；2. 手动数组拼接效率较低；3. 循环使用迭代器访问有额外开销；4. 关键方法未内联化；5. 异常处理逻辑内联在方法中。优化后：1. 合并write操作为单个writeLong减少调用次数；2. 使用专门的join方法提高数组拼接效率；3. 循环改为索引访问避免迭代器开销；4. 关键方法添加@ForceInline注解促进JVM内联优化；5. 提取异常处理逻辑到单独方法。优化思路：通过减少方法调用开销、优化内存操作、促进JVM内联等方式提升类文件构建性能。", "original_code": "1. 多个独立的write调用产生额外开销；2. 手动数组拼接效率较低；3. 循环使用迭代器访问有额外开销；4. 关键方法未内联化；5. 异常处理逻辑内联在方法中。", "optimized_code": "1. BufWriterImpl.java: 添加@ForceInline注解到writeU2和writeIndex方法；提取异常处理逻辑到invalidIndex方法；添加join方法。\n2. DirectClassBuilder.java: 将三个独立的writeInt/writeU2调用合并为一个writeLong调用；使用BufWriterImpl.join方法替换手动数组拼接；优化循环使用索引访问。\n3. DirectCodeBuilder.java: 添加writeExceptionHandlers方法分离条件逻辑。\n4. Util.java: 添加@ForceInline注解到writeAttributes和writeList方法；优化循环使用索引访问。", "source_url": "https://github.com/openjdk/riscv-port/commit/2e0554a69548dae6e8ce9eec48c82e08dd3c1ffa", "code_v0_no_empty_lines": "1. 多个独立的write调用产生额外开销；2. 手动数组拼接效率较低；3. 循环使用迭代器访问有额外开销；4. 关键方法未内联化；5. 异常处理逻辑内联在方法中。", "code_v1_no_empty_lines": "1. BufWriterImpl.java: 添加@ForceInline注解到writeU2和writeIndex方法；提取异常处理逻辑到invalidIndex方法；添加join方法。\n2. DirectClassBuilder.java: 将三个独立的writeInt/writeU2调用合并为一个writeLong调用；使用BufWriterImpl.join方法替换手动数组拼接；优化循环使用索引访问。\n3. DirectCodeBuilder.java: 添加writeExceptionHandlers方法分离条件逻辑。\n4. Util.java: 添加@ForceInline注解到writeAttributes和writeList方法；优化循环使用索引访问。", "target": "1. BufWriterImpl.java: 添加@ForceInline注解到writeU2和writeIndex方法；提取异常处理逻辑到invalidIndex方法；添加join方法。\n2. DirectClassBuilder.java: 将三个独立的writeInt/writeU2调用合并为一个writeLong调用；使用BufWriterImpl.join方法替换手动数组拼接；优化循环使用索引访问。\n3. DirectCodeBuilder.java: 添加writeExceptionHandlers方法分离条件逻辑。\n4. Util.java: 添加@ForceInline注解到writeAttributes和writeList方法；优化循环使用索引访问。", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 多个独立的write调用产生额外开销；2. 手动数组拼接效率较低；3. 循环使用迭代器访问有额外开销；4. 关键方法未内联化；5. 异常处理逻辑内联在方法中。优化后：1. 合并write操作为单个writeLong减少调用次数；2. 使用专门的join方法提高数组拼接效率；3. 循环改为索引访问避免迭代器开销；4. 关键方法添加@ForceInline注解促进JVM内联优化；5. 提取异常处理逻辑到单独方法。优化思路：通过减少方法调用开销、优化内存操作、促进JVM内联等方式提升类文件构建性能。"}
{"id": 731, "source": "riscv-dataset-excel", "optimization_type": "内存优化+性能优化", "optimization_description": "优化前：使用Arrays.copyOf()复制locals和stack数组，即使stackSize为0也会分配新数组。优化后：1. 使用clone()替代Arrays.copyOf()，减少方法调用开销；2. 添加stackSize>0的条件判断，避免在stackSize为0时不必要的数组克隆操作。优化思路：减少不必要的数组分配和复制操作，提升StackMapGenerator的性能。", "original_code": "使用Arrays.copyOf()复制locals和stack数组，即使stackSize为0也会分配新数组。", "optimized_code": "-                target.locals = locals == null ? null : Arrays.copyOf(locals, localsSize);\n+                target.locals = locals == null ? null : locals.clone();\n-                target.stack = stack == null ? null : Arrays.copyOf(stack, stackSize);\n-                target.stackSize = stackSize;\n+                if (stackSize > 0) {\n+                    target.stack = stack.clone();\n+                    target.stackSize = stackSize;\n+                }", "source_url": "https://github.com/openjdk/riscv-port/commit/2d38af61e4133ca98d5a98b3cfb6a6dde2877026", "code_v0_no_empty_lines": "使用Arrays.copyOf()复制locals和stack数组，即使stackSize为0也会分配新数组。", "code_v1_no_empty_lines": "-                target.locals = locals == null ? null : Arrays.copyOf(locals, localsSize);\n+                target.locals = locals == null ? null : locals.clone();\n-                target.stack = stack == null ? null : Arrays.copyOf(stack, stackSize);\n-                target.stackSize = stackSize;\n+                if (stackSize > 0) {\n+                    target.stack = stack.clone();\n+                    target.stackSize = stackSize;\n+                }", "target": "-                target.locals = locals == null ? null : Arrays.copyOf(locals, localsSize);\n+                target.locals = locals == null ? null : locals.clone();\n-                target.stack = stack == null ? null : Arrays.copyOf(stack, stackSize);\n-                target.stackSize = stackSize;\n+                if (stackSize > 0) {\n+                    target.stack = stack.clone();\n+                    target.stackSize = stackSize;\n+                }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用Arrays.copyOf()复制locals和stack数组，即使stackSize为0也会分配新数组。优化后：1. 使用clone()替代Arrays.copyOf()，减少方法调用开销；2. 添加stackSize>0的条件判断，避免在stackSize为0时不必要的数组克隆操作。优化思路：减少不必要的数组分配和复制操作，提升StackMapGenerator的性能。"}
{"id": 732, "source": "riscv-dataset-excel", "optimization_type": "局部变量优化+代码重构", "optimization_description": "优化前：1. 方法内多次通过this.frames和this.currentFrame访问成员变量，增加this指针解引用开销；2. 在条件判断中重复调用frames.get(stackmapIndex)获取nextFrame；3. 使用new ClassFormatError创建异常对象。优化后：1. 在方法开头将成员变量frames和currentFrame缓存到局部变量，减少this指针访问；2. 提前获取nextFrame并复用，避免重复调用get方法；3. 使用generatorError方法创建异常，简化代码。优化思路：通过局部变量缓存和代码重构减少方法调用开销，提高栈映射生成性能。", "original_code": "1. 方法内多次通过this.frames和this.currentFrame访问成员变量，增加this指针解引用开销；2. 在条件判断中重复调用frames.get(stackmapIndex)获取nextFrame；3. 使用new ClassFormatError创建异常对象。", "optimized_code": "@@ -400,6 +400,8 @@ private static Type cpIndexToType(int index, ConstantPoolBuilder cp) {\n     }\n \n     private void processMethod() {\n+        var frames = this.frames;\n+        var currentFrame = this.currentFrame;\n         currentFrame.setLocalsFromArg(methodName, methodDesc, isStatic, thisType);\n         currentFrame.stackSize = 0;\n         currentFrame.flags = 0;\n@@ -415,10 +417,10 @@ private void processMethod() {\n                     throw generatorError(\"Expecting a stack map frame\");\n                 }\n                 if (thisOffset == bcs.bci()) {\n+                    Frame nextFrame = frames.get(stackmapIndex++);\n                     if (!ncf) {\n-                        currentFrame.checkAssignableTo(frames.get(stackmapIndex));\n+                        currentFrame.checkAssignableTo(nextFrame);\n                     }\n-                    Frame nextFrame = frames.get(stackmapIndex++);\n                     while (!nextFrame.dirty) { //skip unmatched frames\n                         if (stackmapIndex == frames.size()) return; //skip the rest of this round\n                         nextFrame = frames.get(stackmapIndex++);\n@@ -429,7 +431,7 @@ private void processMethod() {\n                     currentFrame.copyFrom(nextFrame);\n                     nextFrame.dirty = false;\n                 } else if (thisOffset < bcs.bci()) {\n-                    throw new ClassFormatError(String.format(\"Bad stack map offset %d\", thisOffset));\n+                    throw generatorError(\"Bad stack map offset\");\n                 }\n             } else if (ncf) {\n                 throw generatorError(\"Expecting a stack map frame\");", "source_url": "https://github.com/openjdk/riscv-port/commit/9bcc7b66de6495d3da8fc7f30a2a88187dbe847d", "code_v0_no_empty_lines": "1. 方法内多次通过this.frames和this.currentFrame访问成员变量，增加this指针解引用开销；2. 在条件判断中重复调用frames.get(stackmapIndex)获取nextFrame；3. 使用new ClassFormatError创建异常对象。", "code_v1_no_empty_lines": "@@ -400,6 +400,8 @@ private static Type cpIndexToType(int index, ConstantPoolBuilder cp) {\n     }\n \n     private void processMethod() {\n+        var frames = this.frames;\n+        var currentFrame = this.currentFrame;\n         currentFrame.setLocalsFromArg(methodName, methodDesc, isStatic, thisType);\n         currentFrame.stackSize = 0;\n         currentFrame.flags = 0;\n@@ -415,10 +417,10 @@ private void processMethod() {\n                     throw generatorError(\"Expecting a stack map frame\");\n                 }\n                 if (thisOffset == bcs.bci()) {\n+                    Frame nextFrame = frames.get(stackmapIndex++);\n                     if (!ncf) {\n-                        currentFrame.checkAssignableTo(frames.get(stackmapIndex));\n+                        currentFrame.checkAssignableTo(nextFrame);\n                     }\n-                    Frame nextFrame = frames.get(stackmapIndex++);\n                     while (!nextFrame.dirty) { //skip unmatched frames\n                         if (stackmapIndex == frames.size()) return; //skip the rest of this round\n                         nextFrame = frames.get(stackmapIndex++);\n@@ -429,7 +431,7 @@ private void processMethod() {\n                     currentFrame.copyFrom(nextFrame);\n                     nextFrame.dirty = false;\n                 } else if (thisOffset < bcs.bci()) {\n-                    throw new ClassFormatError(String.format(\"Bad stack map offset %d\", thisOffset));\n+                    throw generatorError(\"Bad stack map offset\");\n                 }\n             } else if (ncf) {\n                 throw generatorError(\"Expecting a stack map frame\");", "target": "@@ -400,6 +400,8 @@ private static Type cpIndexToType(int index, ConstantPoolBuilder cp) {\n     }\n \n     private void processMethod() {\n+        var frames = this.frames;\n+        var currentFrame = this.currentFrame;\n         currentFrame.setLocalsFromArg(methodName, methodDesc, isStatic, thisType);\n         currentFrame.stackSize = 0;\n         currentFrame.flags = 0;\n@@ -415,10 +417,10 @@ private void processMethod() {\n                     throw generatorError(\"Expecting a stack map frame\");\n                 }\n                 if (thisOffset == bcs.bci()) {\n+                    Frame nextFrame = frames.get(stackmapIndex++);\n                     if (!ncf) {\n-                        currentFrame.checkAssignableTo(frames.get(stackmapIndex));\n+                        currentFrame.checkAssignableTo(nextFrame);\n                     }\n-                    Frame nextFrame = frames.get(stackmapIndex++);\n                     while (!nextFrame.dirty) { //skip unmatched frames\n                         if (stackmapIndex == frames.size()) return; //skip the rest of this round\n                         nextFrame = frames.get(stackmapIndex++);\n@@ -429,7 +431,7 @@ private void processMethod() {\n                     currentFrame.copyFrom(nextFrame);\n                     nextFrame.dirty = false;\n                 } else if (thisOffset < bcs.bci()) {\n-                    throw new ClassFormatError(String.format(\"Bad stack map offset %d\", thisOffset));\n+                    throw generatorError(\"Bad stack map offset\");\n                 }\n             } else if (ncf) {\n                 throw generatorError(\"Expecting a stack map frame\");", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 方法内多次通过this.frames和this.currentFrame访问成员变量，增加this指针解引用开销；2. 在条件判断中重复调用frames.get(stackmapIndex)获取nextFrame；3. 使用new ClassFormatError创建异常对象。优化后：1. 在方法开头将成员变量frames和currentFrame缓存到局部变量，减少this指针访问；2. 提前获取nextFrame并复用，避免重复调用get方法；3. 使用generatorError方法创建异常，简化代码。优化思路：通过局部变量缓存和代码重构减少方法调用开销，提高栈映射生成性能。"}
{"id": 733, "source": "riscv-dataset-excel", "optimization_type": "代码清理+性能优化", "optimization_description": "优化前：在并发标记和STW标记阶段分别调用print_taskqueue_stats()和reset_taskqueue_stats()两个函数来打印和重置任务队列统计信息，存在冗余的函数调用开销。优化后：合并两个操作为一个函数print_and_reset_taskqueue_stats()，减少了函数调用次数和代码重复。优化思路：通过重构代码，将原本需要两次调用的统计操作合并为一次，简化了代码结构，减少了运行时开销，同时移除了不再需要的独立函数实现，提高了代码可维护性。", "original_code": "在并发标记和STW标记阶段分别调用print_taskqueue_stats()和reset_taskqueue_stats()两个函数来打印和重置任务队列统计信息，存在冗余的函数调用开销。", "optimized_code": "- TASKQUEUE_STATS_ONLY(task_queues()->print_taskqueue_stats());\n- TASKQUEUE_STATS_ONLY(task_queues()->reset_taskqueue_stats());\n+ TASKQUEUE_STATS_ONLY(task_queues()->print_and_reset_taskqueue_stats(\"\"));", "source_url": "https://github.com/openjdk/riscv-port/commit/279086d4ce7e05972e099022e8045f39680dd4e8", "code_v0_no_empty_lines": "在并发标记和STW标记阶段分别调用print_taskqueue_stats()和reset_taskqueue_stats()两个函数来打印和重置任务队列统计信息，存在冗余的函数调用开销。", "code_v1_no_empty_lines": "- TASKQUEUE_STATS_ONLY(task_queues()->print_taskqueue_stats());\n- TASKQUEUE_STATS_ONLY(task_queues()->reset_taskqueue_stats());\n+ TASKQUEUE_STATS_ONLY(task_queues()->print_and_reset_taskqueue_stats(\"\"));", "target": "- TASKQUEUE_STATS_ONLY(task_queues()->print_taskqueue_stats());\n- TASKQUEUE_STATS_ONLY(task_queues()->reset_taskqueue_stats());\n+ TASKQUEUE_STATS_ONLY(task_queues()->print_and_reset_taskqueue_stats(\"\"));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在并发标记和STW标记阶段分别调用print_taskqueue_stats()和reset_taskqueue_stats()两个函数来打印和重置任务队列统计信息，存在冗余的函数调用开销。优化后：合并两个操作为一个函数print_and_reset_taskqueue_stats()，减少了函数调用次数和代码重复。优化思路：通过重构代码，将原本需要两次调用的统计操作合并为一次，简化了代码结构，减少了运行时开销，同时移除了不再需要的独立函数实现，提高了代码可维护性。"}
{"id": 734, "source": "riscv-dataset-excel", "optimization_type": "指令优化+向量化优化", "optimization_description": "优化前：gather load和scatter store指令需要先将索引向量复制到临时寄存器，再对临时寄存器进行移位操作。优化后：直接对原始索引向量进行移位操作，消除了冗余的向量寄存器复制指令（vmv1r_v）。优化思路：通过分析指令依赖关系，发现索引向量可以直接作为移位操作的源操作数，无需额外复制，减少了指令数量和寄存器压力，提升了向量内存操作的性能。", "original_code": "gather load和scatter store指令需要先将索引向量复制到临时寄存器，再对临时寄存器进行移位操作。", "optimized_code": "-    __ vmv1r_v(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg));\n     BasicType bt = Matcher::vector_element_basic_type(this);\n     Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n     __ vsetvli_helper(bt, Matcher::vector_length(this));\n-    __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg), (int)sew);\n+    __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg), (int)sew);", "source_url": "https://github.com/openjdk/riscv-port/commit/88801caef6ccdc5ba9ade2af830f3b3cd96e1467", "code_v0_no_empty_lines": "gather load和scatter store指令需要先将索引向量复制到临时寄存器，再对临时寄存器进行移位操作。", "code_v1_no_empty_lines": "-    __ vmv1r_v(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg));\n     BasicType bt = Matcher::vector_element_basic_type(this);\n     Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n     __ vsetvli_helper(bt, Matcher::vector_length(this));\n-    __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg), (int)sew);\n+    __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg), (int)sew);", "target": "-    __ vmv1r_v(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg));\n     BasicType bt = Matcher::vector_element_basic_type(this);\n     Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n     __ vsetvli_helper(bt, Matcher::vector_length(this));\n-    __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg), (int)sew);\n+    __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg), (int)sew);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：gather load和scatter store指令需要先将索引向量复制到临时寄存器，再对临时寄存器进行移位操作。优化后：直接对原始索引向量进行移位操作，消除了冗余的向量寄存器复制指令（vmv1r_v）。优化思路：通过分析指令依赖关系，发现索引向量可以直接作为移位操作的源操作数，无需额外复制，减少了指令数量和寄存器压力，提升了向量内存操作的性能。"}
{"id": 735, "source": "riscv-dataset-excel", "optimization_type": "循环优化+溢出保护", "optimization_description": "优化前：在计算final_correction = canonicalized_correction + limit_correction时，当stride值过大可能导致jlong溢出，产生未定义行为。优化后：添加安全检查，当stride等于最小整数值或绝对值超过最大整数值一半时，直接返回false放弃循环优化，避免溢出。优化思路：通过预检查防止算术溢出，确保循环优化在安全范围内进行，同时避免处理罕见的大步长循环（这类循环迭代次数极少，优化收益有限）。", "original_code": "在计算final_correction = canonicalized_correction + limit_correction时，当stride值过大可能导致jlong溢出，产生未定义行为。", "optimized_code": "if (stride_con == min_signed_integer(iv_bt) || (ABS(stride_con) > max_signed_integer(iv_bt) / 2)) {\n    return false;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/1dd60b62e384090b13a08d2afa62e49ef52bc46c", "code_v0_no_empty_lines": "在计算final_correction = canonicalized_correction + limit_correction时，当stride值过大可能导致jlong溢出，产生未定义行为。", "code_v1_no_empty_lines": "if (stride_con == min_signed_integer(iv_bt) || (ABS(stride_con) > max_signed_integer(iv_bt) / 2)) {\n    return false;\n}", "target": "if (stride_con == min_signed_integer(iv_bt) || (ABS(stride_con) > max_signed_integer(iv_bt) / 2)) {\n    return false;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在计算final_correction = canonicalized_correction + limit_correction时，当stride值过大可能导致jlong溢出，产生未定义行为。优化后：添加安全检查，当stride等于最小整数值或绝对值超过最大整数值一半时，直接返回false放弃循环优化，避免溢出。优化思路：通过预检查防止算术溢出，确保循环优化在安全范围内进行，同时避免处理罕见的大步长循环（这类循环迭代次数极少，优化收益有限）。"}
{"id": 736, "source": "riscv-dataset-excel", "optimization_type": "内存优化+代码简化", "optimization_description": "优化前：ZGC的remembered sets（记忆集）在页面生命周期中需要多次初始化和清理操作，增加了内存管理和代码复杂度。优化后：移除了未使用的remembered sets相关功能，简化了内存管理逻辑，减少了不必要的内存分配和清理开销。思路：通过分析发现某些记忆集功能未被实际使用，直接移除相关代码可以简化实现并减少运行时开销。", "original_code": "ZGC的remembered sets（记忆集）在页面生命周期中需要多次初始化和清理操作，增加了内存管理和代码复杂度。", "optimized_code": "-void ZPage::remset_initialize() {\n+void ZPage::remset_alloc() {\n-void ZPage::remset_clear() {\n+void ZPage::remset_delete() {\n-  _remembered_set.clear_all();\n+  _remembered_set.delete_all();\n-  _remembered_set.resize(size());\n+  // Removed line", "source_url": "https://github.com/openjdk/riscv-port/commit/37ec80df8d3b014292fc3d31a1b2aad4e8218ea5", "code_v0_no_empty_lines": "ZGC的remembered sets（记忆集）在页面生命周期中需要多次初始化和清理操作，增加了内存管理和代码复杂度。", "code_v1_no_empty_lines": "-void ZPage::remset_initialize() {\n+void ZPage::remset_alloc() {\n-void ZPage::remset_clear() {\n+void ZPage::remset_delete() {\n-  _remembered_set.clear_all();\n+  _remembered_set.delete_all();\n-  _remembered_set.resize(size());\n+  // Removed line", "target": "-void ZPage::remset_initialize() {\n+void ZPage::remset_alloc() {\n-void ZPage::remset_clear() {\n+void ZPage::remset_delete() {\n-  _remembered_set.clear_all();\n+  _remembered_set.delete_all();\n-  _remembered_set.resize(size());\n+  // Removed line", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ZGC的remembered sets（记忆集）在页面生命周期中需要多次初始化和清理操作，增加了内存管理和代码复杂度。优化后：移除了未使用的remembered sets相关功能，简化了内存管理逻辑，减少了不必要的内存分配和清理开销。思路：通过分析发现某些记忆集功能未被实际使用，直接移除相关代码可以简化实现并减少运行时开销。"}
{"id": 737, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码重构", "optimization_description": "优化前：1. 使用methodDesc.parameterCount()计算参数槽位不准确，可能导致数组越界；2. 通过setLocalRawInternal方法间接设置locals数组，存在方法调用开销；3. 对long/double类型参数需要两次方法调用。优化后：1. 使用Util.parameterSlots()准确计算参数槽位；2. 直接操作locals数组，避免方法调用开销；3. 对long/double类型参数使用批量赋值，减少操作次数。优化思路：通过直接数组操作和准确槽位计算，减少方法调用开销，提高局部变量设置的性能。", "original_code": "1. 使用methodDesc.parameterCount()计算参数槽位不准确，可能导致数组越界；2. 通过setLocalRawInternal方法间接设置locals数组，存在方法调用开销；3. 对long/double类型参数需要两次方法调用。", "optimized_code": "- checkLocal(methodDesc.parameterCount() + (isStatic ? -1 : 0));\n+ checkLocal(Util.parameterSlots(methodDesc) + (isStatic ? -1 : 0));\n- setLocalRawInternal(localsSize++, Type.referenceType(desc));\n+ locals[localsSize++] = type;\n- setLocalRawInternal(localsSize++, Type.LONG_TYPE);\n  setLocalRawInternal(localsSize++, Type.LONG2_TYPE);\n+ locals[localsSize    ] = Type.LONG_TYPE;\n  locals[localsSize + 1] = Type.LONG2_TYPE;\n  localsSize += 2;", "source_url": "https://github.com/openjdk/riscv-port/commit/ab06a878f888827026424530781f0af414a8a611", "code_v0_no_empty_lines": "1. 使用methodDesc.parameterCount()计算参数槽位不准确，可能导致数组越界；2. 通过setLocalRawInternal方法间接设置locals数组，存在方法调用开销；3. 对long/double类型参数需要两次方法调用。", "code_v1_no_empty_lines": "- checkLocal(methodDesc.parameterCount() + (isStatic ? -1 : 0));\n+ checkLocal(Util.parameterSlots(methodDesc) + (isStatic ? -1 : 0));\n- setLocalRawInternal(localsSize++, Type.referenceType(desc));\n+ locals[localsSize++] = type;\n- setLocalRawInternal(localsSize++, Type.LONG_TYPE);\n  setLocalRawInternal(localsSize++, Type.LONG2_TYPE);\n+ locals[localsSize    ] = Type.LONG_TYPE;\n  locals[localsSize + 1] = Type.LONG2_TYPE;\n  localsSize += 2;", "target": "- checkLocal(methodDesc.parameterCount() + (isStatic ? -1 : 0));\n+ checkLocal(Util.parameterSlots(methodDesc) + (isStatic ? -1 : 0));\n- setLocalRawInternal(localsSize++, Type.referenceType(desc));\n+ locals[localsSize++] = type;\n- setLocalRawInternal(localsSize++, Type.LONG_TYPE);\n  setLocalRawInternal(localsSize++, Type.LONG2_TYPE);\n+ locals[localsSize    ] = Type.LONG_TYPE;\n  locals[localsSize + 1] = Type.LONG2_TYPE;\n  localsSize += 2;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 使用methodDesc.parameterCount()计算参数槽位不准确，可能导致数组越界；2. 通过setLocalRawInternal方法间接设置locals数组，存在方法调用开销；3. 对long/double类型参数需要两次方法调用。优化后：1. 使用Util.parameterSlots()准确计算参数槽位；2. 直接操作locals数组，避免方法调用开销；3. 对long/double类型参数使用批量赋值，减少操作次数。优化思路：通过直接数组操作和准确槽位计算，减少方法调用开销，提高局部变量设置的性能。"}
{"id": 738, "source": "riscv-dataset-excel", "optimization_type": "代码重构+性能优化", "optimization_description": "优化前：loadConstant(ConstantDesc)方法内联处理所有数值类型的常量加载逻辑，代码冗长且重复。优化后：重构为多个重载的loadConstant方法（int/long/float/double），将类型检查和加载逻辑分离。优化思路：通过方法重载消除类型检查和装箱开销，提高代码可读性和运行时性能，同时保持API向后兼容。", "original_code": "loadConstant(ConstantDesc)方法内联处理所有数值类型的常量加载逻辑，代码冗长且重复。", "optimized_code": "if (value instanceof Integer) return loadConstant((int)    value);\nif (value instanceof Long   ) return loadConstant((long)   value);\nif (value instanceof Float  ) return loadConstant((float)  value);\nif (value instanceof Double ) return loadConstant((double) value);", "source_url": "https://github.com/openjdk/riscv-port/commit/2461263aac35b25e2a48b6fc84da49e4b553dbc3", "code_v0_no_empty_lines": "loadConstant(ConstantDesc)方法内联处理所有数值类型的常量加载逻辑，代码冗长且重复。", "code_v1_no_empty_lines": "if (value instanceof Integer) return loadConstant((int)    value);\nif (value instanceof Long   ) return loadConstant((long)   value);\nif (value instanceof Float  ) return loadConstant((float)  value);\nif (value instanceof Double ) return loadConstant((double) value);", "target": "if (value instanceof Integer) return loadConstant((int)    value);\nif (value instanceof Long   ) return loadConstant((long)   value);\nif (value instanceof Float  ) return loadConstant((float)  value);\nif (value instanceof Double ) return loadConstant((double) value);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：loadConstant(ConstantDesc)方法内联处理所有数值类型的常量加载逻辑，代码冗长且重复。优化后：重构为多个重载的loadConstant方法（int/long/float/double），将类型检查和加载逻辑分离。优化思路：通过方法重载消除类型检查和装箱开销，提高代码可读性和运行时性能，同时保持API向后兼容。"}
{"id": 739, "source": "riscv-dataset-excel", "optimization_type": "内存优化+代码重构", "optimization_description": "优化前：AbstractPoolEntry类包含一个final byte tag字段，所有子类实例都存储这个字段，即使对于LONG/DOUBLE类型需要特殊处理width()方法。优化后：移除了tag字段，改为抽象方法tag()，由各子类实现返回常量值。width()方法简化为固定返回1（因为LONG/DOUBLE类型不再使用这个类）。优化思路：通过移除冗余的tag字段存储，减少每个实例的内存占用，同时通过抽象方法提供类型信息，简化了代码结构。", "original_code": "AbstractPoolEntry类包含一个final byte tag字段，所有子类实例都存储这个字段，即使对于LONG/DOUBLE类型需要特殊处理width()方法。", "optimized_code": "- public final byte tag;\n- private AbstractPoolEntry(ConstantPool constantPool, int tag, int index, int hash) {\n-     this.tag = (byte) tag;\n+ private AbstractPoolEntry(ConstantPool constantPool, int index, int hash) {\n- public byte tag() {\n-     return tag;\n- }\n+ public abstract byte tag();\n-     return (tag == ClassFile.TAG_LONG || tag == ClassFile.TAG_DOUBLE) ? 2 : 1;\n+     return 1;\n-     pool.writeU1(tag);\n+     pool.writeU1(TAG_UTF8);\n-     pool.writeU1(tag);\n+     pool.writeU1(tag());", "source_url": "https://github.com/openjdk/riscv-port/commit/ab81197d0ded93b82eea9f8fb35d1647c4520f1e", "code_v0_no_empty_lines": "AbstractPoolEntry类包含一个final byte tag字段，所有子类实例都存储这个字段，即使对于LONG/DOUBLE类型需要特殊处理width()方法。", "code_v1_no_empty_lines": "- public final byte tag;\n- private AbstractPoolEntry(ConstantPool constantPool, int tag, int index, int hash) {\n-     this.tag = (byte) tag;\n+ private AbstractPoolEntry(ConstantPool constantPool, int index, int hash) {\n- public byte tag() {\n-     return tag;\n- }\n+ public abstract byte tag();\n-     return (tag == ClassFile.TAG_LONG || tag == ClassFile.TAG_DOUBLE) ? 2 : 1;\n+     return 1;\n-     pool.writeU1(tag);\n+     pool.writeU1(TAG_UTF8);\n-     pool.writeU1(tag);\n+     pool.writeU1(tag());", "target": "- public final byte tag;\n- private AbstractPoolEntry(ConstantPool constantPool, int tag, int index, int hash) {\n-     this.tag = (byte) tag;\n+ private AbstractPoolEntry(ConstantPool constantPool, int index, int hash) {\n- public byte tag() {\n-     return tag;\n- }\n+ public abstract byte tag();\n-     return (tag == ClassFile.TAG_LONG || tag == ClassFile.TAG_DOUBLE) ? 2 : 1;\n+     return 1;\n-     pool.writeU1(tag);\n+     pool.writeU1(TAG_UTF8);\n-     pool.writeU1(tag);\n+     pool.writeU1(tag());", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AbstractPoolEntry类包含一个final byte tag字段，所有子类实例都存储这个字段，即使对于LONG/DOUBLE类型需要特殊处理width()方法。优化后：移除了tag字段，改为抽象方法tag()，由各子类实现返回常量值。width()方法简化为固定返回1（因为LONG/DOUBLE类型不再使用这个类）。优化思路：通过移除冗余的tag字段存储，减少每个实例的内存占用，同时通过抽象方法提供类型信息，简化了代码结构。"}
{"id": 740, "source": "riscv-dataset-excel", "optimization_type": "指令优化+寄存器优化", "optimization_description": "优化前：使用寄存器minusOne存储常量-1，通过比较指令bne检查failedIdx是否为-1。优化后：移除minusOne寄存器及其初始化，利用failedIdx为负时只能是-1的特性，改用bgez指令直接检查failedIdx是否非负。思路：减少寄存器占用和指令数量，利用已知约束简化条件判断。", "original_code": "使用寄存器minusOne存储常量-1，通过比较指令bne检查failedIdx是否为-1。", "optimized_code": "-      Register minusOne  = x30;   // t5\n-      __ mv(minusOne, -1);\n-      __ bne(failedIdx, minusOne, Exit);\n+      // valid value of failedIdx can only be -1 when < 0\n+      __ bgez(failedIdx, Exit);", "source_url": "https://github.com/openjdk/riscv-port/commit/3ad6e31d81bb8a47dc73a6342a6524a901f07687", "code_v0_no_empty_lines": "使用寄存器minusOne存储常量-1，通过比较指令bne检查failedIdx是否为-1。", "code_v1_no_empty_lines": "-      Register minusOne  = x30;   // t5\n-      __ mv(minusOne, -1);\n-      __ bne(failedIdx, minusOne, Exit);\n+      // valid value of failedIdx can only be -1 when < 0\n+      __ bgez(failedIdx, Exit);", "target": "-      Register minusOne  = x30;   // t5\n-      __ mv(minusOne, -1);\n-      __ bne(failedIdx, minusOne, Exit);\n+      // valid value of failedIdx can only be -1 when < 0\n+      __ bgez(failedIdx, Exit);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用寄存器minusOne存储常量-1，通过比较指令bne检查failedIdx是否为-1。优化后：移除minusOne寄存器及其初始化，利用failedIdx为负时只能是-1的特性，改用bgez指令直接检查failedIdx是否非负。思路：减少寄存器占用和指令数量，利用已知约束简化条件判断。"}
{"id": 741, "source": "riscv-dataset-excel", "optimization_type": "反射性能优化+内存优化", "optimization_description": "优化前：每次创建ProxyMethod对象时都调用Method.getSharedParameterTypes()获取参数类型数组，导致重复计算和内存分配开销。优化后：1) 预计算Object方法（hashCode、equals、toString）的签名并缓存；2) 移除ProxyMethod中的parameterTypes字段，改为通过parameterTypes()方法按需获取；3) 简化构造函数参数列表。优化思路：减少反射操作中的重复计算和临时对象分配，通过缓存和延迟计算降低代理类生成的开销。", "original_code": "每次创建ProxyMethod对象时都调用Method.getSharedParameterTypes()获取参数类型数组，导致重复计算和内存分配开销。", "optimized_code": "-        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, \"m0\"));\n-        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, \"m1\"));\n-        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, \"m2\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, OBJECT_HASH_CODE_SIG, \"m0\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, OBJECT_EQUALS_SIG, \"m1\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, OBJECT_TO_STRING_SIG, \"m2\"));\n\n-        sigmethods.add(new ProxyMethod(m, sig, m.getSharedParameterTypes(), returnType,\n+        sigmethods.add(new ProxyMethod(m, sig, returnType,\n\n-        private final Class<?>[] parameterTypes;\n+        private Class<?>[] parameterTypes() {\n+            return method.getSharedParameterTypes();\n+        }", "source_url": "https://github.com/openjdk/riscv-port/commit/a50440fadcd1aa9d8bfddc153dbde6fd55ceb9fa", "code_v0_no_empty_lines": "每次创建ProxyMethod对象时都调用Method.getSharedParameterTypes()获取参数类型数组，导致重复计算和内存分配开销。", "code_v1_no_empty_lines": "-        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, \"m0\"));\n-        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, \"m1\"));\n-        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, \"m2\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, OBJECT_HASH_CODE_SIG, \"m0\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, OBJECT_EQUALS_SIG, \"m1\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, OBJECT_TO_STRING_SIG, \"m2\"));\n\n-        sigmethods.add(new ProxyMethod(m, sig, m.getSharedParameterTypes(), returnType,\n+        sigmethods.add(new ProxyMethod(m, sig, returnType,\n\n-        private final Class<?>[] parameterTypes;\n+        private Class<?>[] parameterTypes() {\n+            return method.getSharedParameterTypes();\n+        }", "target": "-        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, \"m0\"));\n-        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, \"m1\"));\n-        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, \"m2\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, OBJECT_HASH_CODE_SIG, \"m0\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, OBJECT_EQUALS_SIG, \"m1\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, OBJECT_TO_STRING_SIG, \"m2\"));\n\n-        sigmethods.add(new ProxyMethod(m, sig, m.getSharedParameterTypes(), returnType,\n+        sigmethods.add(new ProxyMethod(m, sig, returnType,\n\n-        private final Class<?>[] parameterTypes;\n+        private Class<?>[] parameterTypes() {\n+            return method.getSharedParameterTypes();\n+        }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次创建ProxyMethod对象时都调用Method.getSharedParameterTypes()获取参数类型数组，导致重复计算和内存分配开销。优化后：1) 预计算Object方法（hashCode、equals、toString）的签名并缓存；2) 移除ProxyMethod中的parameterTypes字段，改为通过parameterTypes()方法按需获取；3) 简化构造函数参数列表。优化思路：减少反射操作中的重复计算和临时对象分配，通过缓存和延迟计算降低代理类生成的开销。"}
{"id": 742, "source": "riscv-dataset-excel", "optimization_type": "字符串处理优化+内存优化", "optimization_description": "优化前：readUTF方法对所有UTF-8编码的字节进行逐个字符解码，即使字符串完全由ASCII字符组成也需要遍历整个字节数组。\n优化后：1. 使用JLA.countPositives快速检测ASCII字符数量，如果全部是ASCII字符，则直接使用ISO_8859_1编码创建字符串，避免字符解码开销。2. 对于包含ASCII前缀的字符串，使用JLA.inflateBytesToChars批量转换ASCII字符，减少循环次数。\n优化思路：通过添加ASCII检测快速路径和批量处理机制，减少不必要的字符解码操作，提高纯ASCII或ASCII前缀字符串的处理性能。", "original_code": "readUTF方法对所有UTF-8编码的字节进行逐个字符解码，即使字符串完全由ASCII字符组成也需要遍历整个字节数组。", "optimized_code": "1. 添加了ASCII字符检测和快速路径：\n   int ascii = JLA.countPositives(bytearr, 0, utflen);\n   if (ascii == utflen) {\n       String str;\n       if (trusted) {\n           str = JLA.newStringNoRepl(bytearr, StandardCharsets.ISO_8859_1);\n       } else {\n           str = new String(bytearr, 0, utflen, StandardCharsets.ISO_8859_1);\n       }\n       return str;\n   }\n\n2. 优化了字符数组分配逻辑：\n   if (ascii != 0) {\n       JLA.inflateBytesToChars(bytearr, 0, chararr, 0, ascii);\n       count += ascii;\n       chararr_count += ascii;\n   }", "source_url": "https://github.com/openjdk/riscv-port/commit/40fba148125b9e0d35755b6e6fd701e69d22f7da", "code_v0_no_empty_lines": "readUTF方法对所有UTF-8编码的字节进行逐个字符解码，即使字符串完全由ASCII字符组成也需要遍历整个字节数组。", "code_v1_no_empty_lines": "1. 添加了ASCII字符检测和快速路径：\n   int ascii = JLA.countPositives(bytearr, 0, utflen);\n   if (ascii == utflen) {\n       String str;\n       if (trusted) {\n           str = JLA.newStringNoRepl(bytearr, StandardCharsets.ISO_8859_1);\n       } else {\n           str = new String(bytearr, 0, utflen, StandardCharsets.ISO_8859_1);\n       }\n       return str;\n   }\n\n2. 优化了字符数组分配逻辑：\n   if (ascii != 0) {\n       JLA.inflateBytesToChars(bytearr, 0, chararr, 0, ascii);\n       count += ascii;\n       chararr_count += ascii;\n   }", "target": "1. 添加了ASCII字符检测和快速路径：\n   int ascii = JLA.countPositives(bytearr, 0, utflen);\n   if (ascii == utflen) {\n       String str;\n       if (trusted) {\n           str = JLA.newStringNoRepl(bytearr, StandardCharsets.ISO_8859_1);\n       } else {\n           str = new String(bytearr, 0, utflen, StandardCharsets.ISO_8859_1);\n       }\n       return str;\n   }\n\n2. 优化了字符数组分配逻辑：\n   if (ascii != 0) {\n       JLA.inflateBytesToChars(bytearr, 0, chararr, 0, ascii);\n       count += ascii;\n       chararr_count += ascii;\n   }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：readUTF方法对所有UTF-8编码的字节进行逐个字符解码，即使字符串完全由ASCII字符组成也需要遍历整个字节数组。\n优化后：1. 使用JLA.countPositives快速检测ASCII字符数量，如果全部是ASCII字符，则直接使用ISO_8859_1编码创建字符串，避免字符解码开销。2. 对于包含ASCII前缀的字符串，使用JLA.inflateBytesToChars批量转换ASCII字符，减少循环次数。\n优化思路：通过添加ASCII检测快速路径和批量处理机制，减少不必要的字符解码操作，提高纯ASCII或ASCII前缀字符串的处理性能。"}
{"id": 743, "source": "riscv-dataset-excel", "optimization_type": "内存对齐优化", "optimization_description": "优化前：CDS归档堆的最小GC区域对齐要求为1MB，仅考虑G1收集器。优化后：将最小对齐要求降低至256KB，同时支持G1和Shenandoah收集器。优化思路：通过减小最小对齐要求，允许更灵活的内存布局，减少内存浪费，提高CDS归档堆的空间利用率。", "original_code": "CDS归档堆的最小GC区域对齐要求为1MB，仅考虑G1收集器。", "optimized_code": "- static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n+ static constexpr int MIN_GC_REGION_ALIGNMENT = 256 * K;", "source_url": "https://github.com/openjdk/riscv-port/commit/15ae1155a11b401e3d1dd39177c209f17f077119", "code_v0_no_empty_lines": "CDS归档堆的最小GC区域对齐要求为1MB，仅考虑G1收集器。", "code_v1_no_empty_lines": "- static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n+ static constexpr int MIN_GC_REGION_ALIGNMENT = 256 * K;", "target": "- static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n+ static constexpr int MIN_GC_REGION_ALIGNMENT = 256 * K;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CDS归档堆的最小GC区域对齐要求为1MB，仅考虑G1收集器。优化后：将最小对齐要求降低至256KB，同时支持G1和Shenandoah收集器。优化思路：通过减小最小对齐要求，允许更灵活的内存布局，减少内存浪费，提高CDS归档堆的空间利用率。"}
{"id": 744, "source": "riscv-dataset-excel", "optimization_type": "代码清理与API简化", "optimization_description": "优化前：存在冗余的API方法ptrs_base()和ptrs_base_addr()，分别返回压缩指针的基地址及其地址。优化后：移除了这两个冗余方法，统一使用base()和base_addr()方法，简化了代码结构，减少了维护成本。优化思路：消除重复的API，保持接口一致性，提高代码可读性和可维护性。", "original_code": "存在冗余的API方法ptrs_base()和ptrs_base_addr()，分别返回压缩指针的基地址及其地址。", "optimized_code": "- static address  ptrs_base_addr()           { return (address)&_narrow_oop._base; }\n- static address  ptrs_base()                { return _narrow_oop._base; }", "source_url": "https://github.com/openjdk/riscv-port/commit/296b49634eed83bca6cfdee514b9c7c4f8252d59", "code_v0_no_empty_lines": "存在冗余的API方法ptrs_base()和ptrs_base_addr()，分别返回压缩指针的基地址及其地址。", "code_v1_no_empty_lines": "- static address  ptrs_base_addr()           { return (address)&_narrow_oop._base; }\n- static address  ptrs_base()                { return _narrow_oop._base; }", "target": "- static address  ptrs_base_addr()           { return (address)&_narrow_oop._base; }\n- static address  ptrs_base()                { return _narrow_oop._base; }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：存在冗余的API方法ptrs_base()和ptrs_base_addr()，分别返回压缩指针的基地址及其地址。优化后：移除了这两个冗余方法，统一使用base()和base_addr()方法，简化了代码结构，减少了维护成本。优化思路：消除重复的API，保持接口一致性，提高代码可读性和可维护性。"}
{"id": 745, "source": "riscv-dataset-excel", "optimization_type": "代码清理/无用代码移除", "optimization_description": "优化前：CompressedOops枚举中定义了未使用的AnyNarrowOopMode常量。优化后：移除了未使用的AnyNarrowOopMode枚举值，简化了代码结构。思路：清理无用代码，减少编译产物大小，提高代码可读性，避免未来维护时的混淆。", "original_code": "CompressedOops枚举中定义了未使用的AnyNarrowOopMode常量。", "optimized_code": "-    HeapBasedNarrowOop = 3,\n-    AnyNarrowOopMode = 4\n+    HeapBasedNarrowOop = 3", "source_url": "https://github.com/openjdk/riscv-port/commit/0f7d9e599593bb8e31e7e33a559d25ec803c7ba4", "code_v0_no_empty_lines": "CompressedOops枚举中定义了未使用的AnyNarrowOopMode常量。", "code_v1_no_empty_lines": "-    HeapBasedNarrowOop = 3,\n-    AnyNarrowOopMode = 4\n+    HeapBasedNarrowOop = 3", "target": "-    HeapBasedNarrowOop = 3,\n-    AnyNarrowOopMode = 4\n+    HeapBasedNarrowOop = 3", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CompressedOops枚举中定义了未使用的AnyNarrowOopMode常量。优化后：移除了未使用的AnyNarrowOopMode枚举值，简化了代码结构。思路：清理无用代码，减少编译产物大小，提高代码可读性，避免未来维护时的混淆。"}
{"id": 746, "source": "riscv-dataset-excel", "optimization_type": "锁优化+内存布局优化", "optimization_description": "优化前：PPC64架构的轻量级锁实现未适配新的Object到ObjectMonitor映射机制，缺少对ObjectMonitor表的支持，可能导致锁操作效率低下。优化后：1) 修改函数签名，增加box参数用于处理锁对象；2) 添加对UseObjectMonitorTable标志的支持，在快速锁成功时清除对象监视器缓存；3) 更新多个调用点传递正确的寄存器参数。优化思路：实现PPC64平台对新对象监视器映射的支持，通过适配缓存机制减少锁操作开销，提升并发性能。", "original_code": "PPC64架构的轻量级锁实现未适配新的Object到ObjectMonitor映射机制，缺少对ObjectMonitor表的支持，可能导致锁操作效率低下。", "optimized_code": "- void MacroAssembler::compiler_fast_lock_lightweight_object(ConditionRegister flag, Register obj, Register tmp1,\n+ void MacroAssembler::compiler_fast_lock_lightweight_object(ConditionRegister flag, Register obj, Register box,\n-   assert_different_registers(obj, tmp1, tmp2, tmp3);\n+   assert_different_registers(obj, box, tmp1, tmp2, tmp3);\n+   if (UseObjectMonitorTable) {\n+     // Clear cache in case fast locking succeeds.\n+     li(tmp1, 0);\n+     std(tmp1, in_bytes(BasicObjectLock::lock_offset()) + BasicLock::object_monitor_cache_offset_in_bytes(), box);\n+   }", "source_url": "https://github.com/openjdk/riscv-port/commit/7579d3740217e4a819cbf63837ec929f00464585", "code_v0_no_empty_lines": "PPC64架构的轻量级锁实现未适配新的Object到ObjectMonitor映射机制，缺少对ObjectMonitor表的支持，可能导致锁操作效率低下。", "code_v1_no_empty_lines": "- void MacroAssembler::compiler_fast_lock_lightweight_object(ConditionRegister flag, Register obj, Register tmp1,\n+ void MacroAssembler::compiler_fast_lock_lightweight_object(ConditionRegister flag, Register obj, Register box,\n-   assert_different_registers(obj, tmp1, tmp2, tmp3);\n+   assert_different_registers(obj, box, tmp1, tmp2, tmp3);\n+   if (UseObjectMonitorTable) {\n+     // Clear cache in case fast locking succeeds.\n+     li(tmp1, 0);\n+     std(tmp1, in_bytes(BasicObjectLock::lock_offset()) + BasicLock::object_monitor_cache_offset_in_bytes(), box);\n+   }", "target": "- void MacroAssembler::compiler_fast_lock_lightweight_object(ConditionRegister flag, Register obj, Register tmp1,\n+ void MacroAssembler::compiler_fast_lock_lightweight_object(ConditionRegister flag, Register obj, Register box,\n-   assert_different_registers(obj, tmp1, tmp2, tmp3);\n+   assert_different_registers(obj, box, tmp1, tmp2, tmp3);\n+   if (UseObjectMonitorTable) {\n+     // Clear cache in case fast locking succeeds.\n+     li(tmp1, 0);\n+     std(tmp1, in_bytes(BasicObjectLock::lock_offset()) + BasicLock::object_monitor_cache_offset_in_bytes(), box);\n+   }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PPC64架构的轻量级锁实现未适配新的Object到ObjectMonitor映射机制，缺少对ObjectMonitor表的支持，可能导致锁操作效率低下。优化后：1) 修改函数签名，增加box参数用于处理锁对象；2) 添加对UseObjectMonitorTable标志的支持，在快速锁成功时清除对象监视器缓存；3) 更新多个调用点传递正确的寄存器参数。优化思路：实现PPC64平台对新对象监视器映射的支持，通过适配缓存机制减少锁操作开销，提升并发性能。"}
{"id": 747, "source": "riscv-dataset-excel", "optimization_type": "功能扩展+兼容性优化", "optimization_description": "优化前：CDS堆转储仅支持G1垃圾收集器，存在实现限制。优化后：扩展支持SerialGC和ParallelGC，通过条件判断适配不同GC的内存布局，移除G1专用断言，增加对齐处理。思路：扩大CDS堆转储的GC兼容性，提升功能适用范围。", "original_code": "CDS堆转储仅支持G1垃圾收集器，存在实现限制。", "optimized_code": "- guarantee(UseG1GC, \"implementation limitation\");\n- assert(UseG1GC, \"must be\");\n+ return (UseG1GC || UseParallelGC || UseSerialGC) && UseCompressedClassPointers;", "source_url": "https://github.com/openjdk/riscv-port/commit/d555f072b2036664711242a242a35fb30d277e5a", "code_v0_no_empty_lines": "CDS堆转储仅支持G1垃圾收集器，存在实现限制。", "code_v1_no_empty_lines": "- guarantee(UseG1GC, \"implementation limitation\");\n- assert(UseG1GC, \"must be\");\n+ return (UseG1GC || UseParallelGC || UseSerialGC) && UseCompressedClassPointers;", "target": "- guarantee(UseG1GC, \"implementation limitation\");\n- assert(UseG1GC, \"must be\");\n+ return (UseG1GC || UseParallelGC || UseSerialGC) && UseCompressedClassPointers;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CDS堆转储仅支持G1垃圾收集器，存在实现限制。优化后：扩展支持SerialGC和ParallelGC，通过条件判断适配不同GC的内存布局，移除G1专用断言，增加对齐处理。思路：扩大CDS堆转储的GC兼容性，提升功能适用范围。"}
{"id": 748, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：RISC-V平台的CRC32计算仅使用标量指令实现，处理大量数据时性能受限。优化后：新增vector_update_crc32函数，利用RISC-V向量扩展（RVV）指令集实现CRC32计算的向量化版本，支持16个32位元素的并行处理。优化思路：1) 基于zlib的zcrc32.c算法进行向量化适配；2) 新增向量化专用查找表；3) 在kernel_crc32函数中根据数据长度和UseRVV标志动态选择标量或向量化路径，当数据量足够大时自动切换到向量化实现以提高吞吐量。", "original_code": "RISC-V平台的CRC32计算仅使用标量指令实现，处理大量数据时性能受限。", "optimized_code": "void MacroAssembler::vector_update_crc32(Register crc, Register buf, Register len,\n                                         Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5,\n                                         Register table0, Register table3) {\n    // ... 向量化CRC32计算实现 ...\n}\n\n// 在kernel_crc32函数中添加向量化路径\nif (UseRVV) {\n    const int64_t tmp_limit = MaxVectorSize >= 32 ? unroll_words*3 : unroll_words*5;\n    mv(tmp1, tmp_limit);\n    bge(len, tmp1, L_vector_entry);\n}\n\n// ...\n\nif (UseRVV) {\n    j(L_exit);\n    bind(L_vector_entry);\n    vector_update_crc32(crc, buf, len, tmp1, tmp2, tmp3, tmp4, tmp6, table0, table3);\n    // ...\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/08a2f841ec78a10f8d6d54b2ac3a92e89f765f14", "code_v0_no_empty_lines": "RISC-V平台的CRC32计算仅使用标量指令实现，处理大量数据时性能受限。", "code_v1_no_empty_lines": "void MacroAssembler::vector_update_crc32(Register crc, Register buf, Register len,\n                                         Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5,\n                                         Register table0, Register table3) {\n    // ... 向量化CRC32计算实现 ...\n}\n\n// 在kernel_crc32函数中添加向量化路径\nif (UseRVV) {\n    const int64_t tmp_limit = MaxVectorSize >= 32 ? unroll_words*3 : unroll_words*5;\n    mv(tmp1, tmp_limit);\n    bge(len, tmp1, L_vector_entry);\n}\n\n// ...\n\nif (UseRVV) {\n    j(L_exit);\n    bind(L_vector_entry);\n    vector_update_crc32(crc, buf, len, tmp1, tmp2, tmp3, tmp4, tmp6, table0, table3);\n    // ...\n}", "target": "void MacroAssembler::vector_update_crc32(Register crc, Register buf, Register len,\n                                         Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5,\n                                         Register table0, Register table3) {\n    // ... 向量化CRC32计算实现 ...\n}\n\n// 在kernel_crc32函数中添加向量化路径\nif (UseRVV) {\n    const int64_t tmp_limit = MaxVectorSize >= 32 ? unroll_words*3 : unroll_words*5;\n    mv(tmp1, tmp_limit);\n    bge(len, tmp1, L_vector_entry);\n}\n\n// ...\n\nif (UseRVV) {\n    j(L_exit);\n    bind(L_vector_entry);\n    vector_update_crc32(crc, buf, len, tmp1, tmp2, tmp3, tmp4, tmp6, table0, table3);\n    // ...\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V平台的CRC32计算仅使用标量指令实现，处理大量数据时性能受限。优化后：新增vector_update_crc32函数，利用RISC-V向量扩展（RVV）指令集实现CRC32计算的向量化版本，支持16个32位元素的并行处理。优化思路：1) 基于zlib的zcrc32.c算法进行向量化适配；2) 新增向量化专用查找表；3) 在kernel_crc32函数中根据数据长度和UseRVV标志动态选择标量或向量化路径，当数据量足够大时自动切换到向量化实现以提高吞吐量。"}
{"id": 749, "source": "riscv-dataset-excel", "optimization_type": "指令优化+控制流优化", "optimization_description": "优化前：使用额外的minusOne寄存器与failedIdx比较，判断是否失败（-1表示无失败）。优化后：移除minusOne参数，通过bltz指令直接检查failedIdx是否为负数（-1），并新增FailureAtIdx0标签处理索引0失败的情况。思路：减少寄存器使用，简化比较逻辑，并优化失败处理流程，当第一个数据失败时直接跳转，避免不必要的处理。", "original_code": "使用额外的minusOne寄存器与failedIdx比较，判断是否失败（-1表示无失败）。", "optimized_code": "-    Register minusOne,\n+    // valid value can only be -1 when < 0\n+    __ bltz(failedIdx, NoFailure);\n+    // when the first data (at index 0) fails, no need to process data anymore\n+    __ beqz(failedIdx, FailureAtIdx0);", "source_url": "https://github.com/openjdk/riscv-port/commit/ae39a6603c6c33a36dce30c3290a634b08a6bf05", "code_v0_no_empty_lines": "使用额外的minusOne寄存器与failedIdx比较，判断是否失败（-1表示无失败）。", "code_v1_no_empty_lines": "-    Register minusOne,\n+    // valid value can only be -1 when < 0\n+    __ bltz(failedIdx, NoFailure);\n+    // when the first data (at index 0) fails, no need to process data anymore\n+    __ beqz(failedIdx, FailureAtIdx0);", "target": "-    Register minusOne,\n+    // valid value can only be -1 when < 0\n+    __ bltz(failedIdx, NoFailure);\n+    // when the first data (at index 0) fails, no need to process data anymore\n+    __ beqz(failedIdx, FailureAtIdx0);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用额外的minusOne寄存器与failedIdx比较，判断是否失败（-1表示无失败）。优化后：移除minusOne参数，通过bltz指令直接检查failedIdx是否为负数（-1），并新增FailureAtIdx0标签处理索引0失败的情况。思路：减少寄存器使用，简化比较逻辑，并优化失败处理流程，当第一个数据失败时直接跳转，避免不必要的处理。"}
{"id": 750, "source": "riscv-dataset-excel", "optimization_type": "内存优化+算法优化", "optimization_description": "优化前：PhaseCFG::insert_anti_dependences()函数使用三个独立的Node_List（worklist_mem、worklist_store、worklist_visited）来管理内存状态遍历，导致高内存使用和重复处理问题。优化后：引入DefUseMemStatesQueue类，将三个列表合并为一个队列，通过DefUsePair结构体配对def-use关系，并添加专门的重复检测逻辑（already_enqueued方法）避免Phi节点的重复处理。优化思路：通过数据结构重构减少内存分配，消除重复处理，从而降低内存使用并提高算法效率。", "original_code": "PhaseCFG::insert_anti_dependences()函数使用三个独立的Node_List（worklist_mem、worklist_store、worklist_visited）来管理内存状态遍历，导致高内存使用和重复处理问题。", "optimized_code": "class DefUseMemStatesQueue : public StackObj {\nprivate:\n  class DefUsePair : public StackObj {\n  private:\n    Node* _def; // memory state\n    Node* _use; // use of the memory state that also modifies the memory state\n\n  public:\n    DefUsePair(Node* def, Node* use) :\n      _def(def), _use(use) {\n    }\n\n    DefUsePair() :\n      _def(nullptr), _use(nullptr) {\n    }\n\n    Node* def() const {\n      return _def;\n    }\n\n    Node* use() const {\n      return _use;\n    }\n  };\n\n  GrowableArray<DefUsePair> _queue;\n  GrowableArray<MergeMemNode*> _worklist_visited; // visited mergemem nodes\n\n  bool already_enqueued(Node* def_mem, PhiNode* use_phi) const {\n    // def_mem is one of the inputs of use_phi and at least one input of use_phi is\n    // not def_mem. It's however possible that use_phi has def_mem as input multiple\n    // times. If that happens, use_phi is recorded as a use of def_mem multiple\n    // times as well. When PhaseCFG::insert_anti_dependences() goes over\n    // uses of def_mem and enqueues them for processing, use_phi would then be\n    // enqueued for processing multiple times when it only needs to be\n    // processed once. The code below checks if use_phi as a use of def_mem was\n    // already enqueued to avoid redundant processing of use_phi.\n    int j = _queue.length()-1;\n    // If there are any use of def_mem already enqueued, they were enqueued\n    // last (all use of def_mem are processed in one go).\n    for (; j >= 0; j--) {\n      const DefUsePair& def_use_pair = _queue.at(j);\n      if (def_use_pair.def() != def_mem) {\n        // We're done with the uses of def_mem\n        break;\n      }\n      if (def_use_pair.use() == use_phi) {\n        return true;\n      }\n    }\n#ifdef ASSERT\n    for (; j >= 0; j--) {\n      const DefUsePair& def_use_pair = _queue.at(j);\n      assert(def_use_pair.def() != def_mem, \"Should be done with the uses of def_mem\");\n    }\n#endif\n    return false;\n  }\n\npublic:\n  DefUseMemStatesQueue(ResourceArea* area) {\n  }\n\n  void push(Node* def_mem_state, Node* use_mem_state) {\n    if (use_mem_state->is_MergeMem()) {\n      // Be sure we don't get into combinatorial problems.\n      if (!_worklist_visited.append_if_missing(use_mem_state->as_MergeMem())) {\n        return; // already on work list; do not repeat\n      }\n    } else if (use_mem_state->is_Phi()) {\n      // A Phi could have the same mem as input multiple times. If that's the case, we don't need to enqueue it\n      // more than once. We otherwise allow phis to be repeated; they can merge two relevant states.\n      if (already_enqueued(def_mem_state, use_mem_state->as_Phi())) {\n        return;\n      }\n    }\n\n    _queue.push(DefUsePair(def_mem_state, use_mem_state));\n  }\n\n  bool is_nonempty() const {\n    return _queue.is_nonempty();\n  }\n\n  Node* top_def() const {\n    return _queue.top().def();\n  }\n\n  Node* top_use() const {\n    return _queue.top().use();\n  }\n\n  void pop() {\n    _queue.pop();\n  }\n};", "source_url": "https://github.com/openjdk/riscv-port/commit/5381f553ad61ddaa44d49c3039a05511cc68bdd0", "code_v0_no_empty_lines": "PhaseCFG::insert_anti_dependences()函数使用三个独立的Node_List（worklist_mem、worklist_store、worklist_visited）来管理内存状态遍历，导致高内存使用和重复处理问题。", "code_v1_no_empty_lines": "class DefUseMemStatesQueue : public StackObj {\nprivate:\n  class DefUsePair : public StackObj {\n  private:\n    Node* _def; // memory state\n    Node* _use; // use of the memory state that also modifies the memory state\n\n  public:\n    DefUsePair(Node* def, Node* use) :\n      _def(def), _use(use) {\n    }\n\n    DefUsePair() :\n      _def(nullptr), _use(nullptr) {\n    }\n\n    Node* def() const {\n      return _def;\n    }\n\n    Node* use() const {\n      return _use;\n    }\n  };\n\n  GrowableArray<DefUsePair> _queue;\n  GrowableArray<MergeMemNode*> _worklist_visited; // visited mergemem nodes\n\n  bool already_enqueued(Node* def_mem, PhiNode* use_phi) const {\n    // def_mem is one of the inputs of use_phi and at least one input of use_phi is\n    // not def_mem. It's however possible that use_phi has def_mem as input multiple\n    // times. If that happens, use_phi is recorded as a use of def_mem multiple\n    // times as well. When PhaseCFG::insert_anti_dependences() goes over\n    // uses of def_mem and enqueues them for processing, use_phi would then be\n    // enqueued for processing multiple times when it only needs to be\n    // processed once. The code below checks if use_phi as a use of def_mem was\n    // already enqueued to avoid redundant processing of use_phi.\n    int j = _queue.length()-1;\n    // If there are any use of def_mem already enqueued, they were enqueued\n    // last (all use of def_mem are processed in one go).\n    for (; j >= 0; j--) {\n      const DefUsePair& def_use_pair = _queue.at(j);\n      if (def_use_pair.def() != def_mem) {\n        // We're done with the uses of def_mem\n        break;\n      }\n      if (def_use_pair.use() == use_phi) {\n        return true;\n      }\n    }\n#ifdef ASSERT\n    for (; j >= 0; j--) {\n      const DefUsePair& def_use_pair = _queue.at(j);\n      assert(def_use_pair.def() != def_mem, \"Should be done with the uses of def_mem\");\n    }\n#endif\n    return false;\n  }\n\npublic:\n  DefUseMemStatesQueue(ResourceArea* area) {\n  }\n\n  void push(Node* def_mem_state, Node* use_mem_state) {\n    if (use_mem_state->is_MergeMem()) {\n      // Be sure we don't get into combinatorial problems.\n      if (!_worklist_visited.append_if_missing(use_mem_state->as_MergeMem())) {\n        return; // already on work list; do not repeat\n      }\n    } else if (use_mem_state->is_Phi()) {\n      // A Phi could have the same mem as input multiple times. If that's the case, we don't need to enqueue it\n      // more than once. We otherwise allow phis to be repeated; they can merge two relevant states.\n      if (already_enqueued(def_mem_state, use_mem_state->as_Phi())) {\n        return;\n      }\n    }\n\n    _queue.push(DefUsePair(def_mem_state, use_mem_state));\n  }\n\n  bool is_nonempty() const {\n    return _queue.is_nonempty();\n  }\n\n  Node* top_def() const {\n    return _queue.top().def();\n  }\n\n  Node* top_use() const {\n    return _queue.top().use();\n  }\n\n  void pop() {\n    _queue.pop();\n  }\n};", "target": "class DefUseMemStatesQueue : public StackObj {\nprivate:\n  class DefUsePair : public StackObj {\n  private:\n    Node* _def; // memory state\n    Node* _use; // use of the memory state that also modifies the memory state\n\n  public:\n    DefUsePair(Node* def, Node* use) :\n      _def(def), _use(use) {\n    }\n\n    DefUsePair() :\n      _def(nullptr), _use(nullptr) {\n    }\n\n    Node* def() const {\n      return _def;\n    }\n\n    Node* use() const {\n      return _use;\n    }\n  };\n\n  GrowableArray<DefUsePair> _queue;\n  GrowableArray<MergeMemNode*> _worklist_visited; // visited mergemem nodes\n\n  bool already_enqueued(Node* def_mem, PhiNode* use_phi) const {\n    // def_mem is one of the inputs of use_phi and at least one input of use_phi is\n    // not def_mem. It's however possible that use_phi has def_mem as input multiple\n    // times. If that happens, use_phi is recorded as a use of def_mem multiple\n    // times as well. When PhaseCFG::insert_anti_dependences() goes over\n    // uses of def_mem and enqueues them for processing, use_phi would then be\n    // enqueued for processing multiple times when it only needs to be\n    // processed once. The code below checks if use_phi as a use of def_mem was\n    // already enqueued to avoid redundant processing of use_phi.\n    int j = _queue.length()-1;\n    // If there are any use of def_mem already enqueued, they were enqueued\n    // last (all use of def_mem are processed in one go).\n    for (; j >= 0; j--) {\n      const DefUsePair& def_use_pair = _queue.at(j);\n      if (def_use_pair.def() != def_mem) {\n        // We're done with the uses of def_mem\n        break;\n      }\n      if (def_use_pair.use() == use_phi) {\n        return true;\n      }\n    }\n#ifdef ASSERT\n    for (; j >= 0; j--) {\n      const DefUsePair& def_use_pair = _queue.at(j);\n      assert(def_use_pair.def() != def_mem, \"Should be done with the uses of def_mem\");\n    }\n#endif\n    return false;\n  }\n\npublic:\n  DefUseMemStatesQueue(ResourceArea* area) {\n  }\n\n  void push(Node* def_mem_state, Node* use_mem_state) {\n    if (use_mem_state->is_MergeMem()) {\n      // Be sure we don't get into combinatorial problems.\n      if (!_worklist_visited.append_if_missing(use_mem_state->as_MergeMem())) {\n        return; // already on work list; do not repeat\n      }\n    } else if (use_mem_state->is_Phi()) {\n      // A Phi could have the same mem as input multiple times. If that's the case, we don't need to enqueue it\n      // more than once. We otherwise allow phis to be repeated; they can merge two relevant states.\n      if (already_enqueued(def_mem_state, use_mem_state->as_Phi())) {\n        return;\n      }\n    }\n\n    _queue.push(DefUsePair(def_mem_state, use_mem_state));\n  }\n\n  bool is_nonempty() const {\n    return _queue.is_nonempty();\n  }\n\n  Node* top_def() const {\n    return _queue.top().def();\n  }\n\n  Node* top_use() const {\n    return _queue.top().use();\n  }\n\n  void pop() {\n    _queue.pop();\n  }\n};", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PhaseCFG::insert_anti_dependences()函数使用三个独立的Node_List（worklist_mem、worklist_store、worklist_visited）来管理内存状态遍历，导致高内存使用和重复处理问题。优化后：引入DefUseMemStatesQueue类，将三个列表合并为一个队列，通过DefUsePair结构体配对def-use关系，并添加专门的重复检测逻辑（already_enqueued方法）避免Phi节点的重复处理。优化思路：通过数据结构重构减少内存分配，消除重复处理，从而降低内存使用并提高算法效率。"}
{"id": 751, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+代码生成优化", "optimization_description": "优化前：在x86_64架构中，setcc操作需要两条指令（setb + movzbl）来设置条件码并清除高位。优化后：支持Intel APX指令集的setzucc指令，该指令在一条指令中完成条件设置和零扩展操作。优化思路：通过检测CPU是否支持APX指令集，在支持时使用新的setzucc指令替换原有的两条指令序列，减少指令数量，提高代码生成效率，特别在compare-and-swap等原子操作中能显著提升性能。", "original_code": "在x86_64架构中，setcc操作需要两条指令（setb + movzbl）来设置条件码并清除高位。", "optimized_code": "void Assembler::esetzucc(Condition cc, Register dst) {\n  assert(VM_Version::supports_apx_f(), \"\");\n  assert(0 <= cc && cc < 16, \"illegal cc\");\n  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n  // Encoding Format : eevex_prefix (4 bytes) | opcode_cc | modrm\n  int encode =  evex_prefix_and_encode_ndd(0, 0, dst->encoding(), VEX_SIMD_F2, /* MAP4 */VEX_OPCODE_0F_3C, &attributes);\n  emit_opcode_prefix_and_encoding((0x40 | cc), 0xC0, encode);\n}\n\nvoid MacroAssembler::setcc(Assembler::Condition comparison, Register dst) {\n  if (VM_Version::supports_apx_f()) {\n    esetzucc(comparison, dst);\n  } else {\n    setb(comparison, dst);\n    movzbl(dst, dst);\n  }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/90e92f98a6685b196b979853436668cf2b9f2117", "code_v0_no_empty_lines": "在x86_64架构中，setcc操作需要两条指令（setb + movzbl）来设置条件码并清除高位。", "code_v1_no_empty_lines": "void Assembler::esetzucc(Condition cc, Register dst) {\n  assert(VM_Version::supports_apx_f(), \"\");\n  assert(0 <= cc && cc < 16, \"illegal cc\");\n  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n  // Encoding Format : eevex_prefix (4 bytes) | opcode_cc | modrm\n  int encode =  evex_prefix_and_encode_ndd(0, 0, dst->encoding(), VEX_SIMD_F2, /* MAP4 */VEX_OPCODE_0F_3C, &attributes);\n  emit_opcode_prefix_and_encoding((0x40 | cc), 0xC0, encode);\n}\n\nvoid MacroAssembler::setcc(Assembler::Condition comparison, Register dst) {\n  if (VM_Version::supports_apx_f()) {\n    esetzucc(comparison, dst);\n  } else {\n    setb(comparison, dst);\n    movzbl(dst, dst);\n  }\n}", "target": "void Assembler::esetzucc(Condition cc, Register dst) {\n  assert(VM_Version::supports_apx_f(), \"\");\n  assert(0 <= cc && cc < 16, \"illegal cc\");\n  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n  // Encoding Format : eevex_prefix (4 bytes) | opcode_cc | modrm\n  int encode =  evex_prefix_and_encode_ndd(0, 0, dst->encoding(), VEX_SIMD_F2, /* MAP4 */VEX_OPCODE_0F_3C, &attributes);\n  emit_opcode_prefix_and_encoding((0x40 | cc), 0xC0, encode);\n}\n\nvoid MacroAssembler::setcc(Assembler::Condition comparison, Register dst) {\n  if (VM_Version::supports_apx_f()) {\n    esetzucc(comparison, dst);\n  } else {\n    setb(comparison, dst);\n    movzbl(dst, dst);\n  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在x86_64架构中，setcc操作需要两条指令（setb + movzbl）来设置条件码并清除高位。优化后：支持Intel APX指令集的setzucc指令，该指令在一条指令中完成条件设置和零扩展操作。优化思路：通过检测CPU是否支持APX指令集，在支持时使用新的setzucc指令替换原有的两条指令序列，减少指令数量，提高代码生成效率，特别在compare-and-swap等原子操作中能显著提升性能。"}
{"id": 752, "source": "riscv-dataset-excel", "optimization_type": "算法优化+代码简化", "optimization_description": "优化前：Math.scalb(double)方法使用复杂的循环算法，包含大量中间变量计算、循环迭代和取模运算，代码冗长且难以维护。优化后：采用基于指数范围的分支判断算法，直接根据scaleFactor的值选择预定义的常量（F_UP=2^1023, F_DOWN=2^-1023）和primPowerOfTwoD()函数进行计算，消除了循环和取模运算。优化思路：通过数学分析将复杂的循环逻辑转换为简单的分支结构，利用预计算常量减少运行时计算，显著简化代码逻辑并提高性能。", "original_code": "Math.scalb(double)方法使用复杂的循环算法，包含大量中间变量计算、循环迭代和取模运算，代码冗长且难以维护。", "optimized_code": "public static double scalb(double d, int scaleFactor) {\n-        /*\n-         * When scaling up, it does not matter what order the\n-         * multiply-store operations are done; the result will be\n-         * finite or overflow regardless of the operation ordering.\n-         * However, to get the correct result when scaling down, a\n-         * particular ordering must be used.\n-         *\n-         * When scaling down, the multiply-store operations are\n-         * sequenced so that it is not possible for two consecutive\n-         * multiply-stores to return subnormal results.  If one\n-         * multiply-store result is subnormal, the next multiply will\n-         * round it away to zero.  This is done by first multiplying\n-         * by 2 ^ (scaleFactor % n) and then multiplying several\n-         * times by 2^n as needed where n is the exponent of number\n-         * that is a convenient power of two.  In this way, at most one\n-         * real rounding error occurs.\n-         */\n-\n-        // magnitude of a power of two so large that scaling a finite\n-        // nonzero value by it would be guaranteed to over or\n-         // underflow; due to rounding, scaling down takes an\n-         // additional power of two which is reflected here\n-        final int MAX_SCALE = Double.MAX_EXPONENT + -Double.MIN_EXPONENT +\n-                              DoubleConsts.SIGNIFICAND_WIDTH + 1;\n-        int exp_adjust = 0;\n-        int scale_increment = 0;\n-        double exp_delta = Double.NaN;\n-\n-        // Make sure scaling factor is in a reasonable range\n-\n-        if(scaleFactor < 0) {\n-            scaleFactor = Math.max(scaleFactor, -MAX_SCALE);\n-            scale_increment = -512;\n-            exp_delta = 0x1p-512;\n+        if (scaleFactor > -DoubleConsts.EXP_BIAS) {\n+            if (scaleFactor <= DoubleConsts.EXP_BIAS) {\n+                return d * primPowerOfTwoD(scaleFactor);\n+            }\n+            if (scaleFactor <= 2 * DoubleConsts.EXP_BIAS) {\n+                return d * primPowerOfTwoD(scaleFactor - DoubleConsts.EXP_BIAS) * F_UP;\n+            }\n+            if (scaleFactor < 2 * DoubleConsts.EXP_BIAS + PRECISION - 1) {\n+                return d * primPowerOfTwoD(scaleFactor - 2 * DoubleConsts.EXP_BIAS) * F_UP * F_UP;\n+            }\n+            return d * F_UP * F_UP * F_UP;\n         }\n-        else {\n-            scaleFactor = Math.min(scaleFactor, MAX_SCALE);\n-            scale_increment = 512;\n-            exp_delta = 0x1p512;\n+        if (scaleFactor > -2 * DoubleConsts.EXP_BIAS) {\n+            return d * primPowerOfTwoD(scaleFactor + DoubleConsts.EXP_BIAS) * F_DOWN;\n         }\n-\n-        // Calculate (scaleFactor % +/-512), 512 = 2^9, using\n-        // technique from \"Hacker's Delight\" section 10-2.\n-        int t = (scaleFactor >> 9-1) >>> 32 - 9;\n-        exp_adjust = ((scaleFactor + t) & (512 -1)) - t;\n-\n-        d *= powerOfTwoD(exp_adjust);\n-        scaleFactor -= exp_adjust;\n-\n-        while(scaleFactor != 0) {\n-            d *= exp_delta;\n-            scaleFactor -= scale_increment;\n+        if (scaleFactor > -2 * DoubleConsts.EXP_BIAS - PRECISION) {\n+            return d * primPowerOfTwoD(scaleFactor + 2 * DoubleConsts.EXP_BIAS) * F_DOWN * F_DOWN;\n         }\n-        return d;\n+        return d * MIN_VALUE * MIN_VALUE;\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/28d009ce0ecd4369351de859c491831b7f7bbb28", "code_v0_no_empty_lines": "Math.scalb(double)方法使用复杂的循环算法，包含大量中间变量计算、循环迭代和取模运算，代码冗长且难以维护。", "code_v1_no_empty_lines": "public static double scalb(double d, int scaleFactor) {\n-        /*\n-         * When scaling up, it does not matter what order the\n-         * multiply-store operations are done; the result will be\n-         * finite or overflow regardless of the operation ordering.\n-         * However, to get the correct result when scaling down, a\n-         * particular ordering must be used.\n-         *\n-         * When scaling down, the multiply-store operations are\n-         * sequenced so that it is not possible for two consecutive\n-         * multiply-stores to return subnormal results.  If one\n-         * multiply-store result is subnormal, the next multiply will\n-         * round it away to zero.  This is done by first multiplying\n-         * by 2 ^ (scaleFactor % n) and then multiplying several\n-         * times by 2^n as needed where n is the exponent of number\n-         * that is a convenient power of two.  In this way, at most one\n-         * real rounding error occurs.\n-         */\n-\n-        // magnitude of a power of two so large that scaling a finite\n-        // nonzero value by it would be guaranteed to over or\n-         // underflow; due to rounding, scaling down takes an\n-         // additional power of two which is reflected here\n-        final int MAX_SCALE = Double.MAX_EXPONENT + -Double.MIN_EXPONENT +\n-                              DoubleConsts.SIGNIFICAND_WIDTH + 1;\n-        int exp_adjust = 0;\n-        int scale_increment = 0;\n-        double exp_delta = Double.NaN;\n-\n-        // Make sure scaling factor is in a reasonable range\n-\n-        if(scaleFactor < 0) {\n-            scaleFactor = Math.max(scaleFactor, -MAX_SCALE);\n-            scale_increment = -512;\n-            exp_delta = 0x1p-512;\n+        if (scaleFactor > -DoubleConsts.EXP_BIAS) {\n+            if (scaleFactor <= DoubleConsts.EXP_BIAS) {\n+                return d * primPowerOfTwoD(scaleFactor);\n+            }\n+            if (scaleFactor <= 2 * DoubleConsts.EXP_BIAS) {\n+                return d * primPowerOfTwoD(scaleFactor - DoubleConsts.EXP_BIAS) * F_UP;\n+            }\n+            if (scaleFactor < 2 * DoubleConsts.EXP_BIAS + PRECISION - 1) {\n+                return d * primPowerOfTwoD(scaleFactor - 2 * DoubleConsts.EXP_BIAS) * F_UP * F_UP;\n+            }\n+            return d * F_UP * F_UP * F_UP;\n         }\n-        else {\n-            scaleFactor = Math.min(scaleFactor, MAX_SCALE);\n-            scale_increment = 512;\n-            exp_delta = 0x1p512;\n+        if (scaleFactor > -2 * DoubleConsts.EXP_BIAS) {\n+            return d * primPowerOfTwoD(scaleFactor + DoubleConsts.EXP_BIAS) * F_DOWN;\n         }\n-\n-        // Calculate (scaleFactor % +/-512), 512 = 2^9, using\n-        // technique from \"Hacker's Delight\" section 10-2.\n-        int t = (scaleFactor >> 9-1) >>> 32 - 9;\n-        exp_adjust = ((scaleFactor + t) & (512 -1)) - t;\n-\n-        d *= powerOfTwoD(exp_adjust);\n-        scaleFactor -= exp_adjust;\n-\n-        while(scaleFactor != 0) {\n-            d *= exp_delta;\n-            scaleFactor -= scale_increment;\n+        if (scaleFactor > -2 * DoubleConsts.EXP_BIAS - PRECISION) {\n+            return d * primPowerOfTwoD(scaleFactor + 2 * DoubleConsts.EXP_BIAS) * F_DOWN * F_DOWN;\n         }\n-        return d;\n+        return d * MIN_VALUE * MIN_VALUE;\n     }", "target": "public static double scalb(double d, int scaleFactor) {\n-        /*\n-         * When scaling up, it does not matter what order the\n-         * multiply-store operations are done; the result will be\n-         * finite or overflow regardless of the operation ordering.\n-         * However, to get the correct result when scaling down, a\n-         * particular ordering must be used.\n-         *\n-         * When scaling down, the multiply-store operations are\n-         * sequenced so that it is not possible for two consecutive\n-         * multiply-stores to return subnormal results.  If one\n-         * multiply-store result is subnormal, the next multiply will\n-         * round it away to zero.  This is done by first multiplying\n-         * by 2 ^ (scaleFactor % n) and then multiplying several\n-         * times by 2^n as needed where n is the exponent of number\n-         * that is a convenient power of two.  In this way, at most one\n-         * real rounding error occurs.\n-         */\n-\n-        // magnitude of a power of two so large that scaling a finite\n-        // nonzero value by it would be guaranteed to over or\n-         // underflow; due to rounding, scaling down takes an\n-         // additional power of two which is reflected here\n-        final int MAX_SCALE = Double.MAX_EXPONENT + -Double.MIN_EXPONENT +\n-                              DoubleConsts.SIGNIFICAND_WIDTH + 1;\n-        int exp_adjust = 0;\n-        int scale_increment = 0;\n-        double exp_delta = Double.NaN;\n-\n-        // Make sure scaling factor is in a reasonable range\n-\n-        if(scaleFactor < 0) {\n-            scaleFactor = Math.max(scaleFactor, -MAX_SCALE);\n-            scale_increment = -512;\n-            exp_delta = 0x1p-512;\n+        if (scaleFactor > -DoubleConsts.EXP_BIAS) {\n+            if (scaleFactor <= DoubleConsts.EXP_BIAS) {\n+                return d * primPowerOfTwoD(scaleFactor);\n+            }\n+            if (scaleFactor <= 2 * DoubleConsts.EXP_BIAS) {\n+                return d * primPowerOfTwoD(scaleFactor - DoubleConsts.EXP_BIAS) * F_UP;\n+            }\n+            if (scaleFactor < 2 * DoubleConsts.EXP_BIAS + PRECISION - 1) {\n+                return d * primPowerOfTwoD(scaleFactor - 2 * DoubleConsts.EXP_BIAS) * F_UP * F_UP;\n+            }\n+            return d * F_UP * F_UP * F_UP;\n         }\n-        else {\n-            scaleFactor = Math.min(scaleFactor, MAX_SCALE);\n-            scale_increment = 512;\n-            exp_delta = 0x1p512;\n+        if (scaleFactor > -2 * DoubleConsts.EXP_BIAS) {\n+            return d * primPowerOfTwoD(scaleFactor + DoubleConsts.EXP_BIAS) * F_DOWN;\n         }\n-\n-        // Calculate (scaleFactor % +/-512), 512 = 2^9, using\n-        // technique from \"Hacker's Delight\" section 10-2.\n-        int t = (scaleFactor >> 9-1) >>> 32 - 9;\n-        exp_adjust = ((scaleFactor + t) & (512 -1)) - t;\n-\n-        d *= powerOfTwoD(exp_adjust);\n-        scaleFactor -= exp_adjust;\n-\n-        while(scaleFactor != 0) {\n-            d *= exp_delta;\n-            scaleFactor -= scale_increment;\n+        if (scaleFactor > -2 * DoubleConsts.EXP_BIAS - PRECISION) {\n+            return d * primPowerOfTwoD(scaleFactor + 2 * DoubleConsts.EXP_BIAS) * F_DOWN * F_DOWN;\n         }\n-        return d;\n+        return d * MIN_VALUE * MIN_VALUE;\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Math.scalb(double)方法使用复杂的循环算法，包含大量中间变量计算、循环迭代和取模运算，代码冗长且难以维护。优化后：采用基于指数范围的分支判断算法，直接根据scaleFactor的值选择预定义的常量（F_UP=2^1023, F_DOWN=2^-1023）和primPowerOfTwoD()函数进行计算，消除了循环和取模运算。优化思路：通过数学分析将复杂的循环逻辑转换为简单的分支结构，利用预计算常量减少运行时计算，显著简化代码逻辑并提高性能。"}
{"id": 753, "source": "riscv-dataset-excel", "optimization_type": "代码简化+冗余消除", "optimization_description": "优化前：SegmentBulkOperations::mismatch方法包含冗余的8字节循环比较代码，该循环逻辑已被更高效的向量化实现替代。优化后：删除冗余的8字节循环比较代码，简化函数实现。优化思路：通过代码审查发现该循环已不再需要，因为向量化实现已覆盖所有情况，删除冗余代码可减少代码体积、提高可维护性，同时保持相同功能。", "original_code": "SegmentBulkOperations::mismatch方法包含冗余的8字节循环比较代码，该循环逻辑已被更高效的向量化实现替代。", "optimized_code": "-        // 0...XXX000\n-        for (; remaining >= 8; remaining -= 8) {\n-            final long s = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset, !Architecture.isLittleEndian());\n-            final long d = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset, !Architecture.isLittleEndian());\n-            if (s != d) {\n-                return start + offset + mismatch(s, d);\n-            }\n-            offset += 8;\n-        }", "source_url": "https://github.com/openjdk/riscv-port/commit/1a0a53883f7c6f523b5fefb722e137258d527362", "code_v0_no_empty_lines": "SegmentBulkOperations::mismatch方法包含冗余的8字节循环比较代码，该循环逻辑已被更高效的向量化实现替代。", "code_v1_no_empty_lines": "-        // 0...XXX000\n-        for (; remaining >= 8; remaining -= 8) {\n-            final long s = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset, !Architecture.isLittleEndian());\n-            final long d = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset, !Architecture.isLittleEndian());\n-            if (s != d) {\n-                return start + offset + mismatch(s, d);\n-            }\n-            offset += 8;\n-        }", "target": "-        // 0...XXX000\n-        for (; remaining >= 8; remaining -= 8) {\n-            final long s = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset, !Architecture.isLittleEndian());\n-            final long d = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset, !Architecture.isLittleEndian());\n-            if (s != d) {\n-                return start + offset + mismatch(s, d);\n-            }\n-            offset += 8;\n-        }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SegmentBulkOperations::mismatch方法包含冗余的8字节循环比较代码，该循环逻辑已被更高效的向量化实现替代。优化后：删除冗余的8字节循环比较代码，简化函数实现。优化思路：通过代码审查发现该循环已不再需要，因为向量化实现已覆盖所有情况，删除冗余代码可减少代码体积、提高可维护性，同时保持相同功能。"}
{"id": 754, "source": "riscv-dataset-excel", "optimization_type": "代码简化+性能优化", "optimization_description": "优化前：使用GetPropertyAction获取字符串属性，需要手动解析字符串为整数，处理null值和NumberFormatException异常，代码复杂且存在额外开销。优化后：直接使用GetIntegerAction获取整数属性，自动处理默认值和转换，简化了代码逻辑，减少了异常处理开销，提高了执行效率。", "original_code": "使用GetPropertyAction获取字符串属性，需要手动解析字符串为整数，处理null值和NumberFormatException异常，代码复杂且存在额外开销。", "optimized_code": "-        final String property = GetPropertyAction.privilegedGetProperty(PROPERTY_PATH + name);\n-        if (property != null) {\n-            try {\n-                return 1 << Math.clamp(Integer.parseInt(property), 0, Integer.SIZE - 2);\n-            } catch (NumberFormatException _) {\n-                // ignore\n-            }\n-        }\n-        return defaultPower;\n+        final int power = GetIntegerAction.privilegedGetProperty(PROPERTY_PATH + name, defaultPower);\n+        return 1 << Math.clamp(power, 0, Integer.SIZE - 2);", "source_url": "https://github.com/openjdk/riscv-port/commit/0c36177fead8b64a4cee9da3c895e3799f8ba231", "code_v0_no_empty_lines": "使用GetPropertyAction获取字符串属性，需要手动解析字符串为整数，处理null值和NumberFormatException异常，代码复杂且存在额外开销。", "code_v1_no_empty_lines": "-        final String property = GetPropertyAction.privilegedGetProperty(PROPERTY_PATH + name);\n-        if (property != null) {\n-            try {\n-                return 1 << Math.clamp(Integer.parseInt(property), 0, Integer.SIZE - 2);\n-            } catch (NumberFormatException _) {\n-                // ignore\n-            }\n-        }\n-        return defaultPower;\n+        final int power = GetIntegerAction.privilegedGetProperty(PROPERTY_PATH + name, defaultPower);\n+        return 1 << Math.clamp(power, 0, Integer.SIZE - 2);", "target": "-        final String property = GetPropertyAction.privilegedGetProperty(PROPERTY_PATH + name);\n-        if (property != null) {\n-            try {\n-                return 1 << Math.clamp(Integer.parseInt(property), 0, Integer.SIZE - 2);\n-            } catch (NumberFormatException _) {\n-                // ignore\n-            }\n-        }\n-        return defaultPower;\n+        final int power = GetIntegerAction.privilegedGetProperty(PROPERTY_PATH + name, defaultPower);\n+        return 1 << Math.clamp(power, 0, Integer.SIZE - 2);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用GetPropertyAction获取字符串属性，需要手动解析字符串为整数，处理null值和NumberFormatException异常，代码复杂且存在额外开销。优化后：直接使用GetIntegerAction获取整数属性，自动处理默认值和转换，简化了代码逻辑，减少了异常处理开销，提高了执行效率。"}
{"id": 755, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+浮点运算优化", "optimization_description": "优化前：RISC-V平台缺少Math.round()函数的向量化实现，浮点取整操作只能通过标量指令执行，无法利用RVV向量指令集的并行计算能力。\n优化后：实现了java_round_float_v和java_round_double_v两个向量化函数，使用RVV指令集并行处理浮点数组的取整操作。关键优化包括：1) 使用vfadd_vf和vfcvt_x_f_v指令实现向量化浮点加法和类型转换；2) 采用rdn舍入模式配合0.5偏移实现Java规范的取整语义；3) 用vmfeq_vv替代vfclass检测NaN值，提升性能；4) 根据MaxVectorSize阈值选择性启用（float≥32，double≥64）。\n优化思路：利用RISC-V向量扩展指令集实现浮点取整操作的SIMD并行化，通过批量处理数据减少指令开销，同时保持与Java规范完全一致的舍入行为。", "original_code": "RISC-V平台缺少Math.round()函数的向量化实现，浮点取整操作只能通过标量指令执行，无法利用RVV向量指令集的并行计算能力。", "optimized_code": "void C2_MacroAssembler::java_round_float_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp, BasicType bt, uint vector_length) {\n  csrwi(CSR_FRM, C2_MacroAssembler::rdn);\n  vsetvli_helper(bt, vector_length);\n  mv(t0, jint_cast(0.5f));\n  fmv_w_x(ftmp, t0);\n  vmfeq_vv(v0, src, src);\n  vmv_v_x(dst, zr);\n  vfadd_vf(dst, src, ftmp, Assembler::v0_t);\n  vfcvt_x_f_v(dst, dst, Assembler::v0_t);\n  csrwi(CSR_FRM, C2_MacroAssembler::rne);\n}\n\nvoid C2_MacroAssembler::java_round_double_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp, BasicType bt, uint vector_length) {\n  csrwi(CSR_FRM, C2_MacroAssembler::rdn);\n  vsetvli_helper(bt, vector_length);\n  mv(t0, julong_cast(0.5));\n  fmv_d_x(ftmp, t0);\n  vmfeq_vv(v0, src, src);\n  vmv_v_x(dst, zr);\n  vfadd_vf(dst, src, ftmp, Assembler::v0_t);\n  vfcvt_x_f_v(dst, dst, Assembler::v0_t);\n  csrwi(CSR_FRM, C2_MacroAssembler::rne);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/bacd046062bffb4c95ec7a508a1080ad651a94a4", "code_v0_no_empty_lines": "RISC-V平台缺少Math.round()函数的向量化实现，浮点取整操作只能通过标量指令执行，无法利用RVV向量指令集的并行计算能力。", "code_v1_no_empty_lines": "void C2_MacroAssembler::java_round_float_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp, BasicType bt, uint vector_length) {\n  csrwi(CSR_FRM, C2_MacroAssembler::rdn);\n  vsetvli_helper(bt, vector_length);\n  mv(t0, jint_cast(0.5f));\n  fmv_w_x(ftmp, t0);\n  vmfeq_vv(v0, src, src);\n  vmv_v_x(dst, zr);\n  vfadd_vf(dst, src, ftmp, Assembler::v0_t);\n  vfcvt_x_f_v(dst, dst, Assembler::v0_t);\n  csrwi(CSR_FRM, C2_MacroAssembler::rne);\n}\n\nvoid C2_MacroAssembler::java_round_double_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp, BasicType bt, uint vector_length) {\n  csrwi(CSR_FRM, C2_MacroAssembler::rdn);\n  vsetvli_helper(bt, vector_length);\n  mv(t0, julong_cast(0.5));\n  fmv_d_x(ftmp, t0);\n  vmfeq_vv(v0, src, src);\n  vmv_v_x(dst, zr);\n  vfadd_vf(dst, src, ftmp, Assembler::v0_t);\n  vfcvt_x_f_v(dst, dst, Assembler::v0_t);\n  csrwi(CSR_FRM, C2_MacroAssembler::rne);\n}", "target": "void C2_MacroAssembler::java_round_float_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp, BasicType bt, uint vector_length) {\n  csrwi(CSR_FRM, C2_MacroAssembler::rdn);\n  vsetvli_helper(bt, vector_length);\n  mv(t0, jint_cast(0.5f));\n  fmv_w_x(ftmp, t0);\n  vmfeq_vv(v0, src, src);\n  vmv_v_x(dst, zr);\n  vfadd_vf(dst, src, ftmp, Assembler::v0_t);\n  vfcvt_x_f_v(dst, dst, Assembler::v0_t);\n  csrwi(CSR_FRM, C2_MacroAssembler::rne);\n}\n\nvoid C2_MacroAssembler::java_round_double_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp, BasicType bt, uint vector_length) {\n  csrwi(CSR_FRM, C2_MacroAssembler::rdn);\n  vsetvli_helper(bt, vector_length);\n  mv(t0, julong_cast(0.5));\n  fmv_d_x(ftmp, t0);\n  vmfeq_vv(v0, src, src);\n  vmv_v_x(dst, zr);\n  vfadd_vf(dst, src, ftmp, Assembler::v0_t);\n  vfcvt_x_f_v(dst, dst, Assembler::v0_t);\n  csrwi(CSR_FRM, C2_MacroAssembler::rne);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V平台缺少Math.round()函数的向量化实现，浮点取整操作只能通过标量指令执行，无法利用RVV向量指令集的并行计算能力。\n优化后：实现了java_round_float_v和java_round_double_v两个向量化函数，使用RVV指令集并行处理浮点数组的取整操作。关键优化包括：1) 使用vfadd_vf和vfcvt_x_f_v指令实现向量化浮点加法和类型转换；2) 采用rdn舍入模式配合0.5偏移实现Java规范的取整语义；3) 用vmfeq_vv替代vfclass检测NaN值，提升性能；4) 根据MaxVectorSize阈值选择性启用（float≥32，double≥64）。\n优化思路：利用RISC-V向量扩展指令集实现浮点取整操作的SIMD并行化，通过批量处理数据减少指令开销，同时保持与Java规范完全一致的舍入行为。"}
{"id": 756, "source": "riscv-dataset-excel", "optimization_type": "代码重构与维护优化", "optimization_description": "优化前：直接使用Runtime1::StubID枚举值（如Runtime1::counter_overflow_id）调用运行时函数，代码分散且维护困难。优化后：引入C1StubId枚举类型，统一管理所有C1编译器的stub ID，通过代码生成器自动生成枚举、名称和调用代码。思路：将硬编码的stub ID替换为类型安全的枚举，提高代码可维护性、减少错误，并为后续优化（如静态分析、代码生成）提供基础设施。", "original_code": "直接使用Runtime1::StubID枚举值（如Runtime1::counter_overflow_id）调用运行时函数，代码分散且维护困难。", "optimized_code": "- __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::counter_overflow_id)));\n+ __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));", "source_url": "https://github.com/openjdk/riscv-port/commit/b88ff9c986bfe5e14e2ba5803a464fbf6e131df8", "code_v0_no_empty_lines": "直接使用Runtime1::StubID枚举值（如Runtime1::counter_overflow_id）调用运行时函数，代码分散且维护困难。", "code_v1_no_empty_lines": "- __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::counter_overflow_id)));\n+ __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));", "target": "- __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::counter_overflow_id)));\n+ __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：直接使用Runtime1::StubID枚举值（如Runtime1::counter_overflow_id）调用运行时函数，代码分散且维护困难。优化后：引入C1StubId枚举类型，统一管理所有C1编译器的stub ID，通过代码生成器自动生成枚举、名称和调用代码。思路：将硬编码的stub ID替换为类型安全的枚举，提高代码可维护性、减少错误，并为后续优化（如静态分析、代码生成）提供基础设施。"}
{"id": 757, "source": "riscv-dataset-excel", "optimization_type": "文档优化", "optimization_description": "优化前：MemorySegment的getString方法文档缺少如何从已知偏移量和长度的段中读取字符串的具体示例。优化后：在文档中添加了代码片段，展示了使用MemorySegment.copy和String构造函数从已知偏移量和长度的段中读取字符串的正确方法。思路：通过提供具体的代码示例，帮助开发者更高效地使用MemorySegment API读取字符串，避免潜在的性能问题或错误用法。", "original_code": "MemorySegment的getString方法文档缺少如何从已知偏移量和长度的段中读取字符串的具体示例。", "optimized_code": "+     * <p>\n+     * Getting a string from a segment with a known byte offset and\n+     * known byte length can be done like so:\n+     * {@snippet lang=java :\n+     *     byte[] bytes = new byte[length];\n+     *     MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, length);\n+     *     return new String(bytes, charset);\n+     * }", "source_url": "https://github.com/openjdk/riscv-port/commit/3e0da58ee6553fc0ed841db4a8800d50bc444517", "code_v0_no_empty_lines": "MemorySegment的getString方法文档缺少如何从已知偏移量和长度的段中读取字符串的具体示例。", "code_v1_no_empty_lines": "+     * <p>\n+     * Getting a string from a segment with a known byte offset and\n+     * known byte length can be done like so:\n+     * {@snippet lang=java :\n+     *     byte[] bytes = new byte[length];\n+     *     MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, length);\n+     *     return new String(bytes, charset);\n+     * }", "target": "+     * <p>\n+     * Getting a string from a segment with a known byte offset and\n+     * known byte length can be done like so:\n+     * {@snippet lang=java :\n+     *     byte[] bytes = new byte[length];\n+     *     MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, length);\n+     *     return new String(bytes, charset);\n+     * }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：MemorySegment的getString方法文档缺少如何从已知偏移量和长度的段中读取字符串的具体示例。优化后：在文档中添加了代码片段，展示了使用MemorySegment.copy和String构造函数从已知偏移量和长度的段中读取字符串的正确方法。思路：通过提供具体的代码示例，帮助开发者更高效地使用MemorySegment API读取字符串，避免潜在的性能问题或错误用法。"}
{"id": 758, "source": "riscv-dataset-excel", "optimization_type": "算法优化+代码重构", "optimization_description": "优化前：mismatch、copy、fill等批量操作分散在AbstractMemorySegmentImpl中实现，代码重复且难以优化。优化后：创建专门的SegmentBulkOperations类集中处理批量操作，通过重构实现了：1) 代码复用和简化，2) 为后续向量化优化提供统一接口，3) 提高内存操作性能。思路是将相关的批量操作逻辑抽取到独立类中，便于统一优化和维护。", "original_code": "mismatch、copy、fill等批量操作分散在AbstractMemorySegmentImpl中实现，代码重复且难以优化。", "optimized_code": "- 从AbstractMemorySegmentImpl中移除了mismatch和fill方法的实现\n+ 创建了新的SegmentBulkOperations类，将mismatch、copy、fill等批量操作集中实现\n+ 在MemorySegment.java中修改了mismatch和copy方法的调用，改为调用SegmentBulkOperations中的实现", "source_url": "https://github.com/openjdk/riscv-port/commit/81ff91ef27a6a856ae2c453a9a9b8333b91da3ab", "code_v0_no_empty_lines": "mismatch、copy、fill等批量操作分散在AbstractMemorySegmentImpl中实现，代码重复且难以优化。", "code_v1_no_empty_lines": "- 从AbstractMemorySegmentImpl中移除了mismatch和fill方法的实现\n+ 创建了新的SegmentBulkOperations类，将mismatch、copy、fill等批量操作集中实现\n+ 在MemorySegment.java中修改了mismatch和copy方法的调用，改为调用SegmentBulkOperations中的实现", "target": "- 从AbstractMemorySegmentImpl中移除了mismatch和fill方法的实现\n+ 创建了新的SegmentBulkOperations类，将mismatch、copy、fill等批量操作集中实现\n+ 在MemorySegment.java中修改了mismatch和copy方法的调用，改为调用SegmentBulkOperations中的实现", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：mismatch、copy、fill等批量操作分散在AbstractMemorySegmentImpl中实现，代码重复且难以优化。优化后：创建专门的SegmentBulkOperations类集中处理批量操作，通过重构实现了：1) 代码复用和简化，2) 为后续向量化优化提供统一接口，3) 提高内存操作性能。思路是将相关的批量操作逻辑抽取到独立类中，便于统一优化和维护。"}
{"id": 759, "source": "riscv-dataset-excel", "optimization_type": "指令集扩展", "optimization_description": "优化前：x86汇编器缺少对新型数据目标指令（如eaddl、eandl、ecmovl等）的支持，这些指令使用EVEX编码格式，支持更高效的向量操作和条件移动。优化后：在assembler_x86.cpp和assembler_x86.hpp中新增了多个以'e'前缀开头的指令实现（如eaddl、eandl、ecmovl），这些指令使用EVEX前缀，支持NDD（新数据目标）操作模式，允许更灵活的寄存器寻址和可选的标志位控制（通过no_flags参数）。优化思路：通过扩展汇编器支持新的x86指令集特性，提升代码生成效率，特别是在向量化和条件操作场景下，能够生成更紧凑、更高效的机器码。", "original_code": "x86汇编器缺少对新型数据目标指令（如eaddl、eandl、ecmovl等）的支持，这些指令使用EVEX编码格式，支持更高效的向量操作和条件移动。", "optimized_code": "+void Assembler::eaddl(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n+  attributes.set_address_attributes(/* tuple_type */ EVEX_NOSCALE, /* input_size_in_bits */ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rax, src, imm32);\n+}\n\n+void Assembler::ecmovl(Condition cc, Register dst, Register src1, Register src2) {\n+  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int16((0x40 | cc), (0xC0 | encode));\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/ab9b72c50a5f324e53b8c6535f401cc185b98c75", "code_v0_no_empty_lines": "x86汇编器缺少对新型数据目标指令（如eaddl、eandl、ecmovl等）的支持，这些指令使用EVEX编码格式，支持更高效的向量操作和条件移动。", "code_v1_no_empty_lines": "+void Assembler::eaddl(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n+  attributes.set_address_attributes(/* tuple_type */ EVEX_NOSCALE, /* input_size_in_bits */ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rax, src, imm32);\n+}\n\n+void Assembler::ecmovl(Condition cc, Register dst, Register src1, Register src2) {\n+  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int16((0x40 | cc), (0xC0 | encode));\n+}", "target": "+void Assembler::eaddl(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n+  attributes.set_address_attributes(/* tuple_type */ EVEX_NOSCALE, /* input_size_in_bits */ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rax, src, imm32);\n+}\n\n+void Assembler::ecmovl(Condition cc, Register dst, Register src1, Register src2) {\n+  InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int16((0x40 | cc), (0xC0 | encode));\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：x86汇编器缺少对新型数据目标指令（如eaddl、eandl、ecmovl等）的支持，这些指令使用EVEX编码格式，支持更高效的向量操作和条件移动。优化后：在assembler_x86.cpp和assembler_x86.hpp中新增了多个以'e'前缀开头的指令实现（如eaddl、eandl、ecmovl），这些指令使用EVEX前缀，支持NDD（新数据目标）操作模式，允许更灵活的寄存器寻址和可选的标志位控制（通过no_flags参数）。优化思路：通过扩展汇编器支持新的x86指令集特性，提升代码生成效率，特别是在向量化和条件操作场景下，能够生成更紧凑、更高效的机器码。"}
{"id": 760, "source": "riscv-dataset-excel", "optimization_type": "代码重构+性能优化", "optimization_description": "优化前：ZipCoder中维护复杂的slashBytes缓存和字符编码相关的hasTrailingSlash检查，每次调用getEntryPos时都需要重复检查尾部斜杠，代码冗余且效率较低。优化后：1) 移除ZipCoder中与字符编码相关的斜杠处理逻辑，简化实现；2) 将斜杠检查逻辑集中到getEntryPos方法中，避免重复检查；3) 引入EntryPos记录类，一次性返回解析后的名称和位置信息；4) 重构getZipEntry方法，提前创建ZipEntry对象，简化流程。优化思路：通过重构消除重复的尾部斜杠检查逻辑，减少方法调用和对象创建开销，提高Zip文件条目查找性能，同时使代码更清晰易维护。", "original_code": "ZipCoder中维护复杂的slashBytes缓存和字符编码相关的hasTrailingSlash检查，每次调用getEntryPos时都需要重复检查尾部斜杠，代码冗余且效率较低。", "optimized_code": "1. 移除ZipCoder中的hasTrailingSlash()和slashBytes()方法\n2. 将hasTrailingSlash()改为私有方法，仅处理ASCII '/'字符\n3. 引入EntryPos记录类，getEntryPos()返回包含名称和位置的对象\n4. 重构getZipEntry()方法，提前创建ZipEntry对象，简化尾部斜杠处理逻辑", "source_url": "https://github.com/openjdk/riscv-port/commit/7f1dae12e5e24d204a70cf610a8c482996556931", "code_v0_no_empty_lines": "ZipCoder中维护复杂的slashBytes缓存和字符编码相关的hasTrailingSlash检查，每次调用getEntryPos时都需要重复检查尾部斜杠，代码冗余且效率较低。", "code_v1_no_empty_lines": "1. 移除ZipCoder中的hasTrailingSlash()和slashBytes()方法\n2. 将hasTrailingSlash()改为私有方法，仅处理ASCII '/'字符\n3. 引入EntryPos记录类，getEntryPos()返回包含名称和位置的对象\n4. 重构getZipEntry()方法，提前创建ZipEntry对象，简化尾部斜杠处理逻辑", "target": "1. 移除ZipCoder中的hasTrailingSlash()和slashBytes()方法\n2. 将hasTrailingSlash()改为私有方法，仅处理ASCII '/'字符\n3. 引入EntryPos记录类，getEntryPos()返回包含名称和位置的对象\n4. 重构getZipEntry()方法，提前创建ZipEntry对象，简化尾部斜杠处理逻辑", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ZipCoder中维护复杂的slashBytes缓存和字符编码相关的hasTrailingSlash检查，每次调用getEntryPos时都需要重复检查尾部斜杠，代码冗余且效率较低。优化后：1) 移除ZipCoder中与字符编码相关的斜杠处理逻辑，简化实现；2) 将斜杠检查逻辑集中到getEntryPos方法中，避免重复检查；3) 引入EntryPos记录类，一次性返回解析后的名称和位置信息；4) 重构getZipEntry方法，提前创建ZipEntry对象，简化流程。优化思路：通过重构消除重复的尾部斜杠检查逻辑，减少方法调用和对象创建开销，提高Zip文件条目查找性能，同时使代码更清晰易维护。"}
{"id": 761, "source": "riscv-dataset-excel", "optimization_type": "代码清理/无用代码移除", "optimization_description": "优化前：x86汇编器包含未使用的addw、andw、orw、xorw指令编码函数（寄存器到寄存器操作）。优化后：完全移除这些未使用的函数实现和声明。优化思路：清理代码库，减少二进制大小，简化维护，避免未来误用这些未使用的编码。", "original_code": "x86汇编器包含未使用的addw、andw、orw、xorw指令编码函数（寄存器到寄存器操作）。", "optimized_code": "- void Assembler::addw(Register dst, Register src) {\n  emit_int8(0x66);\n  (void)prefix_and_encode(dst->encoding(), src->encoding());\n  emit_arith(0x03, 0xC0, dst, src);\n}\n\n- void Assembler::andw(Register dst, Register src) {\n  (void)prefix_and_encode(dst->encoding(), src->encoding());\n  emit_arith(0x23, 0xC0, dst, src);\n}\n\n- void Assembler::orw(Register dst, Register src) {\n  (void)prefix_and_encode(dst->encoding(), src->encoding());\n  emit_arith(0x0B, 0xC0, dst, src);\n}\n\n- void Assembler::xorw(Register dst, Register src) {\n  (void)prefix_and_encode(dst->encoding(), src->encoding());\n  emit_arith(0x33, 0xC0, dst, src);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/be0dca046a43ecef2dcd012da6399cbed4cd0454", "code_v0_no_empty_lines": "x86汇编器包含未使用的addw、andw、orw、xorw指令编码函数（寄存器到寄存器操作）。", "code_v1_no_empty_lines": "- void Assembler::addw(Register dst, Register src) {\n  emit_int8(0x66);\n  (void)prefix_and_encode(dst->encoding(), src->encoding());\n  emit_arith(0x03, 0xC0, dst, src);\n}\n\n- void Assembler::andw(Register dst, Register src) {\n  (void)prefix_and_encode(dst->encoding(), src->encoding());\n  emit_arith(0x23, 0xC0, dst, src);\n}\n\n- void Assembler::orw(Register dst, Register src) {\n  (void)prefix_and_encode(dst->encoding(), src->encoding());\n  emit_arith(0x0B, 0xC0, dst, src);\n}\n\n- void Assembler::xorw(Register dst, Register src) {\n  (void)prefix_and_encode(dst->encoding(), src->encoding());\n  emit_arith(0x33, 0xC0, dst, src);\n}", "target": "- void Assembler::addw(Register dst, Register src) {\n  emit_int8(0x66);\n  (void)prefix_and_encode(dst->encoding(), src->encoding());\n  emit_arith(0x03, 0xC0, dst, src);\n}\n\n- void Assembler::andw(Register dst, Register src) {\n  (void)prefix_and_encode(dst->encoding(), src->encoding());\n  emit_arith(0x23, 0xC0, dst, src);\n}\n\n- void Assembler::orw(Register dst, Register src) {\n  (void)prefix_and_encode(dst->encoding(), src->encoding());\n  emit_arith(0x0B, 0xC0, dst, src);\n}\n\n- void Assembler::xorw(Register dst, Register src) {\n  (void)prefix_and_encode(dst->encoding(), src->encoding());\n  emit_arith(0x33, 0xC0, dst, src);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：x86汇编器包含未使用的addw、andw、orw、xorw指令编码函数（寄存器到寄存器操作）。优化后：完全移除这些未使用的函数实现和声明。优化思路：清理代码库，减少二进制大小，简化维护，避免未来误用这些未使用的编码。"}
{"id": 762, "source": "riscv-dataset-excel", "optimization_type": "字节码生成优化+常量池复用", "optimization_description": "优化前：每次字节码生成都重新创建常量池条目，导致重复的常量池构建开销。优化后：引入ConstantPoolBuilder复用常量池，将ClassDesc替换为ClassEntry，减少重复的常量池条目创建。优化思路：通过预构建和复用常量池，减少lambda和invoker字节码生成时的内存分配和计算开销，提升运行时性能。", "original_code": "每次字节码生成都重新创建常量池条目，导致重复的常量池构建开销。", "optimized_code": "- private final ClassDesc lambdaClassDesc;\n+ private final ConstantPoolBuilder pool = ConstantPoolBuilder.of();\n+ private final ClassEntry lambdaClassEntry;\n- lambdaClassDesc = ClassDesc.ofInternalName(lambdaClassName);\n+ lambdaClassEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(ConstantUtils.concat(\"L\", lambdaClassName, \";\")));\n- final byte[] classBytes = ClassFile.of().build(lambdaClassDesc, new Consumer<ClassBuilder>() {\n+ final byte[] classBytes = ClassFile.of().build(lambdaClassEntry, pool, new Consumer<ClassBuilder>() {\n- cob.new_(lambdaClassDesc)\n+ cob.new_(lambdaClassEntry)\n- .invokespecial(lambdaClassDesc, INIT_NAME, constructorTypeDesc)\n+ .invokespecial(pool.methodRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(INIT_NAME, constructorTypeDesc)))", "source_url": "https://github.com/openjdk/riscv-port/commit/c246ede163d675cfdacf741565195751981afb41", "code_v0_no_empty_lines": "每次字节码生成都重新创建常量池条目，导致重复的常量池构建开销。", "code_v1_no_empty_lines": "- private final ClassDesc lambdaClassDesc;\n+ private final ConstantPoolBuilder pool = ConstantPoolBuilder.of();\n+ private final ClassEntry lambdaClassEntry;\n- lambdaClassDesc = ClassDesc.ofInternalName(lambdaClassName);\n+ lambdaClassEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(ConstantUtils.concat(\"L\", lambdaClassName, \";\")));\n- final byte[] classBytes = ClassFile.of().build(lambdaClassDesc, new Consumer<ClassBuilder>() {\n+ final byte[] classBytes = ClassFile.of().build(lambdaClassEntry, pool, new Consumer<ClassBuilder>() {\n- cob.new_(lambdaClassDesc)\n+ cob.new_(lambdaClassEntry)\n- .invokespecial(lambdaClassDesc, INIT_NAME, constructorTypeDesc)\n+ .invokespecial(pool.methodRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(INIT_NAME, constructorTypeDesc)))", "target": "- private final ClassDesc lambdaClassDesc;\n+ private final ConstantPoolBuilder pool = ConstantPoolBuilder.of();\n+ private final ClassEntry lambdaClassEntry;\n- lambdaClassDesc = ClassDesc.ofInternalName(lambdaClassName);\n+ lambdaClassEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(ConstantUtils.concat(\"L\", lambdaClassName, \";\")));\n- final byte[] classBytes = ClassFile.of().build(lambdaClassDesc, new Consumer<ClassBuilder>() {\n+ final byte[] classBytes = ClassFile.of().build(lambdaClassEntry, pool, new Consumer<ClassBuilder>() {\n- cob.new_(lambdaClassDesc)\n+ cob.new_(lambdaClassEntry)\n- .invokespecial(lambdaClassDesc, INIT_NAME, constructorTypeDesc)\n+ .invokespecial(pool.methodRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(INIT_NAME, constructorTypeDesc)))", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次字节码生成都重新创建常量池条目，导致重复的常量池构建开销。优化后：引入ConstantPoolBuilder复用常量池，将ClassDesc替换为ClassEntry，减少重复的常量池条目创建。优化思路：通过预构建和复用常量池，减少lambda和invoker字节码生成时的内存分配和计算开销，提升运行时性能。"}
{"id": 763, "source": "riscv-dataset-excel", "optimization_type": "浮点运算优化", "optimization_description": "优化前：在Vector API的withLaneHelper和laneHelper方法中，对浮点数使用Double.doubleToLongBits和Float.floatToIntBits进行位转换，这些方法会处理NaN值的规范化，引入额外开销。优化后：改用Double.doubleToRawLongBits和Float.floatToRawIntBits，直接进行原始位转换，避免NaN规范化处理，减少浮点运算开销，提升向量操作性能。", "original_code": "在Vector API的withLaneHelper和laneHelper方法中，对浮点数使用Double.doubleToLongBits和Float.floatToIntBits进行位转换，这些方法会处理NaN值的规范化，引入额外开销。", "optimized_code": "- return Double.doubleToLongBits(e);\n+ return Double.doubleToRawLongBits(e);\n- return Float.floatToIntBits(e);\n+ return Float.floatToRawIntBits(e);", "source_url": "https://github.com/openjdk/riscv-port/commit/38441b3f2d0e735089c29a9a9ce441b2d7c75db1", "code_v0_no_empty_lines": "在Vector API的withLaneHelper和laneHelper方法中，对浮点数使用Double.doubleToLongBits和Float.floatToIntBits进行位转换，这些方法会处理NaN值的规范化，引入额外开销。", "code_v1_no_empty_lines": "- return Double.doubleToLongBits(e);\n+ return Double.doubleToRawLongBits(e);\n- return Float.floatToIntBits(e);\n+ return Float.floatToRawIntBits(e);", "target": "- return Double.doubleToLongBits(e);\n+ return Double.doubleToRawLongBits(e);\n- return Float.floatToIntBits(e);\n+ return Float.floatToRawIntBits(e);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在Vector API的withLaneHelper和laneHelper方法中，对浮点数使用Double.doubleToLongBits和Float.floatToIntBits进行位转换，这些方法会处理NaN值的规范化，引入额外开销。优化后：改用Double.doubleToRawLongBits和Float.floatToRawIntBits，直接进行原始位转换，避免NaN规范化处理，减少浮点运算开销，提升向量操作性能。"}
{"id": 764, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：抽象类和接口类的Klass对象存储在class metaspace中，占用宝贵的压缩类指针编码空间。优化后：通过新增use_class_space参数，明确控制是否使用class metaspace，避免将抽象类和接口类的Klass对象存储在其中，从而减少class metaspace的使用，提高内存效率。优化思路：区分具体类与抽象/接口类的存储需求，优化内存布局。", "original_code": "抽象类和接口类的Klass对象存储在class metaspace中，占用宝贵的压缩类指针编码空间。", "optimized_code": "-  MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;\n+  MetadataType mdtype = use_class_space ? ClassType : NonClassType;", "source_url": "https://github.com/openjdk/riscv-port/commit/ad104932e6c26806c353ad048ce5cff7d2b4c29a", "code_v0_no_empty_lines": "抽象类和接口类的Klass对象存储在class metaspace中，占用宝贵的压缩类指针编码空间。", "code_v1_no_empty_lines": "-  MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;\n+  MetadataType mdtype = use_class_space ? ClassType : NonClassType;", "target": "-  MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;\n+  MetadataType mdtype = use_class_space ? ClassType : NonClassType;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：抽象类和接口类的Klass对象存储在class metaspace中，占用宝贵的压缩类指针编码空间。优化后：通过新增use_class_space参数，明确控制是否使用class metaspace，避免将抽象类和接口类的Klass对象存储在其中，从而减少class metaspace的使用，提高内存效率。优化思路：区分具体类与抽象/接口类的存储需求，优化内存布局。"}
{"id": 765, "source": "riscv-dataset-excel", "optimization_type": "方法调用优化", "optimization_description": "性能提升：优化前使用invokeExact方法调用引导方法（Bootstrap Method），需要严格的类型检查。优化后改用invokeBasic方法，减少类型检查开销，提高动态方法调用的性能。", "original_code": "// No original code extracted from description\n", "optimized_code": "-                            .invokeExact(caller, name, (MethodType)type,\n+                            .invokeBasic(caller, name, (MethodType)type,", "source_url": "https://github.com/openjdk/riscv-port/commit/0d8e52b382432674533c9b80565eadf39ae83c64", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "-                            .invokeExact(caller, name, (MethodType)type,\n+                            .invokeBasic(caller, name, (MethodType)type,", "target": "-                            .invokeExact(caller, name, (MethodType)type,\n+                            .invokeBasic(caller, name, (MethodType)type,", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升：优化前使用invokeExact方法调用引导方法（Bootstrap Method），需要严格的类型检查。优化后改用invokeBasic方法，减少类型检查开销，提高动态方法调用的性能。"}
{"id": 766, "source": "riscv-dataset-excel", "optimization_type": "字符串解析优化", "optimization_description": "优化前：使用switch语句仅支持月份缩写（如\"Jan\"），需要额外的HashMap缓存来支持完整月份名称。优化后：使用regionMatches方法支持不区分大小写的部分匹配，既能处理缩写也能处理完整名称，同时移除了HashMap缓存，减少了内存占用和初始化开销。优化思路：通过更灵活的字符串匹配机制，简化代码结构，提高解析的鲁棒性和性能。", "original_code": "使用switch语句仅支持月份缩写（如\"Jan\"），需要额外的HashMap缓存来支持完整月份名称。", "optimized_code": "- switch (mon) {\n- case \"Jan\": return Month.JANUARY;\n- case \"Feb\": return Month.FEBRUARY;\n- ...\n- }\n+ int len = mon.length();\n+ if (mon.regionMatches(true, 0, \"January\", 0, len)) return Month.JANUARY;\n+ if (mon.regionMatches(true, 0, \"February\", 0, len)) return Month.FEBRUARY;\n+ ...", "source_url": "https://github.com/openjdk/riscv-port/commit/86a2f9c7dcb6585cabf03c0940511d11560e85b7", "code_v0_no_empty_lines": "使用switch语句仅支持月份缩写（如\"Jan\"），需要额外的HashMap缓存来支持完整月份名称。", "code_v1_no_empty_lines": "- switch (mon) {\n- case \"Jan\": return Month.JANUARY;\n- case \"Feb\": return Month.FEBRUARY;\n- ...\n- }\n+ int len = mon.length();\n+ if (mon.regionMatches(true, 0, \"January\", 0, len)) return Month.JANUARY;\n+ if (mon.regionMatches(true, 0, \"February\", 0, len)) return Month.FEBRUARY;\n+ ...", "target": "- switch (mon) {\n- case \"Jan\": return Month.JANUARY;\n- case \"Feb\": return Month.FEBRUARY;\n- ...\n- }\n+ int len = mon.length();\n+ if (mon.regionMatches(true, 0, \"January\", 0, len)) return Month.JANUARY;\n+ if (mon.regionMatches(true, 0, \"February\", 0, len)) return Month.FEBRUARY;\n+ ...", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用switch语句仅支持月份缩写（如\"Jan\"），需要额外的HashMap缓存来支持完整月份名称。优化后：使用regionMatches方法支持不区分大小写的部分匹配，既能处理缩写也能处理完整名称，同时移除了HashMap缓存，减少了内存占用和初始化开销。优化思路：通过更灵活的字符串匹配机制，简化代码结构，提高解析的鲁棒性和性能。"}
{"id": 767, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+内存分配优化", "optimization_description": "优化前：多个线程并发分配中等页面对象时，直接调用alloc_object_in_shared_page可能导致多个线程同时从页面缓存请求新页面，造成资源竞争和性能下降。优化后：新增alloc_object_in_medium_page方法，使用_medium_page_alloc_lock同步新页面的分配过程。首先尝试原子加载现有页面分配对象，失败时通过锁保护确保只有一个线程能从页面缓存获取新页面，避免多个线程同时请求。同时采用非阻塞分配优先策略，仅在必要时进行阻塞分配。优化思路：通过细粒度锁减少并发竞争，提高中等页面分配的性能和可扩展性。", "original_code": "多个线程并发分配中等页面对象时，直接调用alloc_object_in_shared_page可能导致多个线程同时从页面缓存请求新页面，造成资源竞争和性能下降。", "optimized_code": "zaddress ZObjectAllocator::alloc_medium_object(size_t size, ZAllocationFlags flags) {\n-  return alloc_object_in_shared_page(_shared_medium_page.addr(), ZPageType::medium, ZPageSizeMedium, size, flags);\n+  return alloc_object_in_medium_page(size, flags);\n}\n\n+zaddress ZObjectAllocator::alloc_object_in_medium_page(size_t size,\n+                                                       ZAllocationFlags flags) {\n+  zaddress addr = zaddress::null;\n+  ZPage** shared_medium_page = _shared_medium_page.addr();\n+  ZPage* page = Atomic::load_acquire(shared_medium_page);\n+\n+  if (page != nullptr) {\n+    addr = page->alloc_object_atomic(size);\n+  }\n+\n+  if (is_null(addr)) {\n+    ZLocker<ZLock> locker(&_medium_page_alloc_lock);\n+    ZAllocationFlags non_blocking_flags = flags;\n+    non_blocking_flags.set_non_blocking();\n+    addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMedium, size, non_blocking_flags);\n+  }\n+\n+  if (is_null(addr) && !flags.non_blocking()) {\n+    addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMedium, size, flags);\n+  }\n+\n+  return addr;\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/347d5728e69ae1f7d1a24820cc2c17bb0b8c0af5", "code_v0_no_empty_lines": "多个线程并发分配中等页面对象时，直接调用alloc_object_in_shared_page可能导致多个线程同时从页面缓存请求新页面，造成资源竞争和性能下降。", "code_v1_no_empty_lines": "zaddress ZObjectAllocator::alloc_medium_object(size_t size, ZAllocationFlags flags) {\n-  return alloc_object_in_shared_page(_shared_medium_page.addr(), ZPageType::medium, ZPageSizeMedium, size, flags);\n+  return alloc_object_in_medium_page(size, flags);\n}\n\n+zaddress ZObjectAllocator::alloc_object_in_medium_page(size_t size,\n+                                                       ZAllocationFlags flags) {\n+  zaddress addr = zaddress::null;\n+  ZPage** shared_medium_page = _shared_medium_page.addr();\n+  ZPage* page = Atomic::load_acquire(shared_medium_page);\n+\n+  if (page != nullptr) {\n+    addr = page->alloc_object_atomic(size);\n+  }\n+\n+  if (is_null(addr)) {\n+    ZLocker<ZLock> locker(&_medium_page_alloc_lock);\n+    ZAllocationFlags non_blocking_flags = flags;\n+    non_blocking_flags.set_non_blocking();\n+    addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMedium, size, non_blocking_flags);\n+  }\n+\n+  if (is_null(addr) && !flags.non_blocking()) {\n+    addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMedium, size, flags);\n+  }\n+\n+  return addr;\n+}", "target": "zaddress ZObjectAllocator::alloc_medium_object(size_t size, ZAllocationFlags flags) {\n-  return alloc_object_in_shared_page(_shared_medium_page.addr(), ZPageType::medium, ZPageSizeMedium, size, flags);\n+  return alloc_object_in_medium_page(size, flags);\n}\n\n+zaddress ZObjectAllocator::alloc_object_in_medium_page(size_t size,\n+                                                       ZAllocationFlags flags) {\n+  zaddress addr = zaddress::null;\n+  ZPage** shared_medium_page = _shared_medium_page.addr();\n+  ZPage* page = Atomic::load_acquire(shared_medium_page);\n+\n+  if (page != nullptr) {\n+    addr = page->alloc_object_atomic(size);\n+  }\n+\n+  if (is_null(addr)) {\n+    ZLocker<ZLock> locker(&_medium_page_alloc_lock);\n+    ZAllocationFlags non_blocking_flags = flags;\n+    non_blocking_flags.set_non_blocking();\n+    addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMedium, size, non_blocking_flags);\n+  }\n+\n+  if (is_null(addr) && !flags.non_blocking()) {\n+    addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMedium, size, flags);\n+  }\n+\n+  return addr;\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多个线程并发分配中等页面对象时，直接调用alloc_object_in_shared_page可能导致多个线程同时从页面缓存请求新页面，造成资源竞争和性能下降。优化后：新增alloc_object_in_medium_page方法，使用_medium_page_alloc_lock同步新页面的分配过程。首先尝试原子加载现有页面分配对象，失败时通过锁保护确保只有一个线程能从页面缓存获取新页面，避免多个线程同时请求。同时采用非阻塞分配优先策略，仅在必要时进行阻塞分配。优化思路：通过细粒度锁减少并发竞争，提高中等页面分配的性能和可扩展性。"}
{"id": 768, "source": "riscv-dataset-excel", "optimization_type": "内存访问优化+代码简化", "optimization_description": "优化前：在写入属性时，需要先写入一个占位的长度值（0），然后计算实际写入的字节数，最后回填长度值。这需要额外的计算和内存访问。优化后：通过新增skip()方法预留空间并返回位置索引，新增专门的patchU2()和patchInt()方法直接写入2字节或4字节值。优化思路：减少不必要的内存写入操作，避免中间计算，直接使用专用方法进行回填，提高ClassFile写入性能。", "original_code": "在写入属性时，需要先写入一个占位的长度值（0），然后计算实际写入的字节数，最后回填长度值。这需要额外的计算和内存访问。", "optimized_code": "public int skip(int bytes) {\n    int now = offset;\n    reserveSpace(bytes);\n    offset += bytes;\n    return now;\n}\n\npublic void patchU2(int offset, int x) {\n    byte[] elems = this.elems;\n    elems[offset    ] = (byte) (x >> 8);\n    elems[offset + 1] = (byte)  x;\n}\n\npublic void patchInt(int offset, int x) {\n    byte[] elems = this.elems;\n    elems[offset    ] = (byte) (x >> 24);\n    elems[offset + 1] = (byte) (x >> 16);\n    elems[offset + 2] = (byte) (x >> 8);\n    elems[offset + 3] = (byte)  x;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/9ebc2ecbf613da3bcee1dd5e8920a26d5f6d6df7", "code_v0_no_empty_lines": "在写入属性时，需要先写入一个占位的长度值（0），然后计算实际写入的字节数，最后回填长度值。这需要额外的计算和内存访问。", "code_v1_no_empty_lines": "public int skip(int bytes) {\n    int now = offset;\n    reserveSpace(bytes);\n    offset += bytes;\n    return now;\n}\n\npublic void patchU2(int offset, int x) {\n    byte[] elems = this.elems;\n    elems[offset    ] = (byte) (x >> 8);\n    elems[offset + 1] = (byte)  x;\n}\n\npublic void patchInt(int offset, int x) {\n    byte[] elems = this.elems;\n    elems[offset    ] = (byte) (x >> 24);\n    elems[offset + 1] = (byte) (x >> 16);\n    elems[offset + 2] = (byte) (x >> 8);\n    elems[offset + 3] = (byte)  x;\n}", "target": "public int skip(int bytes) {\n    int now = offset;\n    reserveSpace(bytes);\n    offset += bytes;\n    return now;\n}\n\npublic void patchU2(int offset, int x) {\n    byte[] elems = this.elems;\n    elems[offset    ] = (byte) (x >> 8);\n    elems[offset + 1] = (byte)  x;\n}\n\npublic void patchInt(int offset, int x) {\n    byte[] elems = this.elems;\n    elems[offset    ] = (byte) (x >> 24);\n    elems[offset + 1] = (byte) (x >> 16);\n    elems[offset + 2] = (byte) (x >> 8);\n    elems[offset + 3] = (byte)  x;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在写入属性时，需要先写入一个占位的长度值（0），然后计算实际写入的字节数，最后回填长度值。这需要额外的计算和内存访问。优化后：通过新增skip()方法预留空间并返回位置索引，新增专门的patchU2()和patchInt()方法直接写入2字节或4字节值。优化思路：减少不必要的内存写入操作，避免中间计算，直接使用专用方法进行回填，提高ClassFile写入性能。"}
{"id": 769, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+内存优化", "optimization_description": "优化前：1. localsMap计算使用Wrapper.forBasicType()方法调用，存在额外开销；2. classDataValues()方法中多次调用classData.size()；3. clinit()方法中静态字段添加与初始化逻辑分离，且循环中重复获取classData；4. 方法注解在运行时动态构建。优化后：1. 直接检查参数类型是否为long/double，避免Wrapper调用；2. 缓存size变量，减少方法调用；3. 延迟静态字段添加（仅在需要时），合并循环逻辑；4. 预构建注解常量，避免运行时分配。优化思路：减少方法调用、缓存计算结果、延迟初始化、预计算常量，从而降低InvokerBytecodeGenerator的运行时开销。", "original_code": "1. localsMap计算使用Wrapper.forBasicType()方法调用，存在额外开销；2. classDataValues()方法中多次调用classData.size()；3. clinit()方法中静态字段添加与初始化逻辑分离，且循环中重复获取classData；4. 方法注解在运行时动态构建。", "optimized_code": "-        for (int i = 1, index = 0; i < localsMap.length; i++) {\n-            Wrapper w = Wrapper.forBasicType(mt.parameterType(i - 1));\n-            index += w.stackSlots();\n+        for (int i = 1, index = 0; i < localsMap.length; i++) {\n+            Class<?> cl = mt.parameterType(i - 1);\n+            index += (cl == long.class || cl == double.class) ? 2 : 1;\n-        int size = cd.size();\n-        return switch (size) {\n+        int size = cd.size();\n+        return switch (size) {\n             case 0 -> null;             // special case (classData is not used by <clinit>)\n             case 1 -> cd.get(0).value;  // special case (single object)\n             case 2 -> List.of(cd.get(0).value, cd.get(1).value);\n             case 3 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value);\n             case 4 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value, cd.get(3).value);\n             default -> {\n-                Object[] data = new Object[classData.size()];\n-                for (int i = 0; i < classData.size(); i++) {\n+                Object[] data = new Object[size];\n+                for (int i = 0; i < size; i++) {\n                     data[i] = classData.get(i).value;\n                 }\n                 yield List.of(data);\n-        for (ClassData p : classData) {\n-            // add the static field\n-            clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n-        }\n+                int size = classData.size();\n+                if (size == 1) {\n+                    ClassData p = classData.get(0);\n+                    // add the static field\n+                    clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n-                if (classData.size() == 1) {\n-                    ClassData p = classData.get(0);\n-                    cob.checkcast(p.desc)\n-                       .putstatic(classDesc, p.name, p.desc);\n+                if (size == 1) {\n+                    ClassData p = classData.get(0);\n+                    // add the static field\n+                    clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n+                    cob.checkcast(p.desc)\n+                       .putstatic(classDesc, p.name, p.desc);\n-                    for (ClassData p : classData) {\n+                    for (int i = 0; i < size; i++) {\n+                        ClassData p = classData.get(i);\n+                        // add the static field\n+                        clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n-                List<Annotation> annotations = new ArrayList<>(3);\n-                // Suppress this method in backtraces displayed to the user.\n-                annotations.add(HIDDEN);\n-                // Mark this method as a compiled LambdaForm\n-                annotations.add(LF_COMPILED);\n+    // Suppress method in backtraces displayed to the user, mark this method as\n+    // a compiled LambdaForm, then either force or prohibit inlining.\n+    public static final RuntimeVisibleAnnotationsAttribute LF_DONTINLINE_ANNOTATIONS = RuntimeVisibleAnnotationsAttribute.of(HIDDEN, LF_COMPILED, DONTINLINE);\n+    public static final RuntimeVisibleAnnotationsAttribute LF_FORCEINLINE_ANNOTATIONS = RuntimeVisibleAnnotationsAttribute.of(HIDDEN, LF_COMPILED, FORCEINLINE);", "source_url": "https://github.com/openjdk/riscv-port/commit/d2b36f09072e03370ee02b063fcc4a1f0e6cb2ee", "code_v0_no_empty_lines": "1. localsMap计算使用Wrapper.forBasicType()方法调用，存在额外开销；2. classDataValues()方法中多次调用classData.size()；3. clinit()方法中静态字段添加与初始化逻辑分离，且循环中重复获取classData；4. 方法注解在运行时动态构建。", "code_v1_no_empty_lines": "-        for (int i = 1, index = 0; i < localsMap.length; i++) {\n-            Wrapper w = Wrapper.forBasicType(mt.parameterType(i - 1));\n-            index += w.stackSlots();\n+        for (int i = 1, index = 0; i < localsMap.length; i++) {\n+            Class<?> cl = mt.parameterType(i - 1);\n+            index += (cl == long.class || cl == double.class) ? 2 : 1;\n-        int size = cd.size();\n-        return switch (size) {\n+        int size = cd.size();\n+        return switch (size) {\n             case 0 -> null;             // special case (classData is not used by <clinit>)\n             case 1 -> cd.get(0).value;  // special case (single object)\n             case 2 -> List.of(cd.get(0).value, cd.get(1).value);\n             case 3 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value);\n             case 4 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value, cd.get(3).value);\n             default -> {\n-                Object[] data = new Object[classData.size()];\n-                for (int i = 0; i < classData.size(); i++) {\n+                Object[] data = new Object[size];\n+                for (int i = 0; i < size; i++) {\n                     data[i] = classData.get(i).value;\n                 }\n                 yield List.of(data);\n-        for (ClassData p : classData) {\n-            // add the static field\n-            clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n-        }\n+                int size = classData.size();\n+                if (size == 1) {\n+                    ClassData p = classData.get(0);\n+                    // add the static field\n+                    clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n-                if (classData.size() == 1) {\n-                    ClassData p = classData.get(0);\n-                    cob.checkcast(p.desc)\n-                       .putstatic(classDesc, p.name, p.desc);\n+                if (size == 1) {\n+                    ClassData p = classData.get(0);\n+                    // add the static field\n+                    clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n+                    cob.checkcast(p.desc)\n+                       .putstatic(classDesc, p.name, p.desc);\n-                    for (ClassData p : classData) {\n+                    for (int i = 0; i < size; i++) {\n+                        ClassData p = classData.get(i);\n+                        // add the static field\n+                        clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n-                List<Annotation> annotations = new ArrayList<>(3);\n-                // Suppress this method in backtraces displayed to the user.\n-                annotations.add(HIDDEN);\n-                // Mark this method as a compiled LambdaForm\n-                annotations.add(LF_COMPILED);\n+    // Suppress method in backtraces displayed to the user, mark this method as\n+    // a compiled LambdaForm, then either force or prohibit inlining.\n+    public static final RuntimeVisibleAnnotationsAttribute LF_DONTINLINE_ANNOTATIONS = RuntimeVisibleAnnotationsAttribute.of(HIDDEN, LF_COMPILED, DONTINLINE);\n+    public static final RuntimeVisibleAnnotationsAttribute LF_FORCEINLINE_ANNOTATIONS = RuntimeVisibleAnnotationsAttribute.of(HIDDEN, LF_COMPILED, FORCEINLINE);", "target": "-        for (int i = 1, index = 0; i < localsMap.length; i++) {\n-            Wrapper w = Wrapper.forBasicType(mt.parameterType(i - 1));\n-            index += w.stackSlots();\n+        for (int i = 1, index = 0; i < localsMap.length; i++) {\n+            Class<?> cl = mt.parameterType(i - 1);\n+            index += (cl == long.class || cl == double.class) ? 2 : 1;\n-        int size = cd.size();\n-        return switch (size) {\n+        int size = cd.size();\n+        return switch (size) {\n             case 0 -> null;             // special case (classData is not used by <clinit>)\n             case 1 -> cd.get(0).value;  // special case (single object)\n             case 2 -> List.of(cd.get(0).value, cd.get(1).value);\n             case 3 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value);\n             case 4 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value, cd.get(3).value);\n             default -> {\n-                Object[] data = new Object[classData.size()];\n-                for (int i = 0; i < classData.size(); i++) {\n+                Object[] data = new Object[size];\n+                for (int i = 0; i < size; i++) {\n                     data[i] = classData.get(i).value;\n                 }\n                 yield List.of(data);\n-        for (ClassData p : classData) {\n-            // add the static field\n-            clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n-        }\n+                int size = classData.size();\n+                if (size == 1) {\n+                    ClassData p = classData.get(0);\n+                    // add the static field\n+                    clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n-                if (classData.size() == 1) {\n-                    ClassData p = classData.get(0);\n-                    cob.checkcast(p.desc)\n-                       .putstatic(classDesc, p.name, p.desc);\n+                if (size == 1) {\n+                    ClassData p = classData.get(0);\n+                    // add the static field\n+                    clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n+                    cob.checkcast(p.desc)\n+                       .putstatic(classDesc, p.name, p.desc);\n-                    for (ClassData p : classData) {\n+                    for (int i = 0; i < size; i++) {\n+                        ClassData p = classData.get(i);\n+                        // add the static field\n+                        clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n-                List<Annotation> annotations = new ArrayList<>(3);\n-                // Suppress this method in backtraces displayed to the user.\n-                annotations.add(HIDDEN);\n-                // Mark this method as a compiled LambdaForm\n-                annotations.add(LF_COMPILED);\n+    // Suppress method in backtraces displayed to the user, mark this method as\n+    // a compiled LambdaForm, then either force or prohibit inlining.\n+    public static final RuntimeVisibleAnnotationsAttribute LF_DONTINLINE_ANNOTATIONS = RuntimeVisibleAnnotationsAttribute.of(HIDDEN, LF_COMPILED, DONTINLINE);\n+    public static final RuntimeVisibleAnnotationsAttribute LF_FORCEINLINE_ANNOTATIONS = RuntimeVisibleAnnotationsAttribute.of(HIDDEN, LF_COMPILED, FORCEINLINE);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. localsMap计算使用Wrapper.forBasicType()方法调用，存在额外开销；2. classDataValues()方法中多次调用classData.size()；3. clinit()方法中静态字段添加与初始化逻辑分离，且循环中重复获取classData；4. 方法注解在运行时动态构建。优化后：1. 直接检查参数类型是否为long/double，避免Wrapper调用；2. 缓存size变量，减少方法调用；3. 延迟静态字段添加（仅在需要时），合并循环逻辑；4. 预构建注解常量，避免运行时分配。优化思路：减少方法调用、缓存计算结果、延迟初始化、预计算常量，从而降低InvokerBytecodeGenerator的运行时开销。"}
{"id": 770, "source": "riscv-dataset-excel", "optimization_type": "字符串处理优化", "optimization_description": "优化前：StringConcatFactory在CompactStrings关闭时仍尝试UTF16优化路径，导致不必要的计算开销。优化后：通过新增stringInitCoder()方法检测CompactStrings状态，当CompactStrings关闭时直接返回null，避免无效的UTF16参数分析。优化思路：根据CompactStrings配置动态调整字符串拼接优化策略，减少条件判断开销。", "original_code": "StringConcatFactory在CompactStrings关闭时仍尝试UTF16优化路径，导致不必要的计算开销。", "optimized_code": "if (JLA.stringInitCoder() != 0) {\n    return null;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/fbe2629303bcee5855673b7e37d8c49f19dc9849", "code_v0_no_empty_lines": "StringConcatFactory在CompactStrings关闭时仍尝试UTF16优化路径，导致不必要的计算开销。", "code_v1_no_empty_lines": "if (JLA.stringInitCoder() != 0) {\n    return null;\n}", "target": "if (JLA.stringInitCoder() != 0) {\n    return null;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：StringConcatFactory在CompactStrings关闭时仍尝试UTF16优化路径，导致不必要的计算开销。优化后：通过新增stringInitCoder()方法检测CompactStrings状态，当CompactStrings关闭时直接返回null，避免无效的UTF16参数分析。优化思路：根据CompactStrings配置动态调整字符串拼接优化策略，减少条件判断开销。"}
{"id": 771, "source": "riscv-dataset-excel", "optimization_type": "测试维护", "optimization_description": "优化前：TestJhsdbJstackUpcall.java测试用例未在ProblemList-generational-zgc.txt中列出，可能导致在generational ZGC环境下测试失败。优化后：将该测试用例添加到问题列表中，标记为generic-all，确保测试套件在generational ZGC环境下的正确维护和稳定性。思路：通过将已知有问题的测试用例添加到问题列表，避免测试失败干扰开发流程，属于测试基础设施的维护优化。", "original_code": "TestJhsdbJstackUpcall.java测试用例未在ProblemList-generational-zgc.txt中列出，可能导致在generational ZGC环境下测试失败。", "optimized_code": "+serviceability/sa/TestJhsdbJstackUpcall.java                  8307393   generic-all", "source_url": "https://github.com/openjdk/riscv-port/commit/f0e84b7617aebc421483f36bb7d0b14d0fc39616", "code_v0_no_empty_lines": "TestJhsdbJstackUpcall.java测试用例未在ProblemList-generational-zgc.txt中列出，可能导致在generational ZGC环境下测试失败。", "code_v1_no_empty_lines": "+serviceability/sa/TestJhsdbJstackUpcall.java                  8307393   generic-all", "target": "+serviceability/sa/TestJhsdbJstackUpcall.java                  8307393   generic-all", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：TestJhsdbJstackUpcall.java测试用例未在ProblemList-generational-zgc.txt中列出，可能导致在generational ZGC环境下测试失败。优化后：将该测试用例添加到问题列表中，标记为generic-all，确保测试套件在generational ZGC环境下的正确维护和稳定性。思路：通过将已知有问题的测试用例添加到问题列表，避免测试失败干扰开发流程，属于测试基础设施的维护优化。"}
{"id": 772, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码优化", "optimization_description": "优化前：1. parameterSlots方法通过遍历参数并累加slotSize计算总槽数，每次迭代都调用slotSize；2. maxLocals方法重复计算参数槽数；3. slotSize和isDoubleSlot方法通过字符串比较判断类型。优化后：1. parameterSlots方法改为从参数数量开始，仅对双槽类型（long/double）进行额外计数，减少方法调用；2. maxLocals方法复用parameterSlots结果，避免重复计算；3. 新增paramSlotSize方法专门处理参数槽大小；4. slotSize和isDoubleSlot改用常量比较，避免字符串操作。优化思路：通过减少方法调用、复用计算结果、优化类型比较逻辑，提升ClassFile处理性能。", "original_code": "1. parameterSlots方法通过遍历参数并累加slotSize计算总槽数，每次迭代都调用slotSize；2. maxLocals方法重复计算参数槽数；3. slotSize和isDoubleSlot方法通过字符串比较判断类型。", "optimized_code": "public static int parameterSlots(MethodTypeDesc mDesc) {\n-        int count = 0;\n-        for (int i = 0; i < mDesc.parameterCount(); i++) {\n-            count += slotSize(mDesc.parameterType(i));\n+        int count = mDesc.parameterCount();\n+        for (int i = count - 1; i >= 0; i--) {\n+            if (isDoubleSlot(mDesc.parameterType(i))) {\n+                count++;\n+            }\n         }\n         return count;\n     }\n\n     public static int maxLocals(int flags, MethodTypeDesc mDesc) {\n-        int count = ((flags & ACC_STATIC) != 0) ? 0 : 1;\n-        for (int i = 0; i < mDesc.parameterCount(); i++) {\n-            count += slotSize(mDesc.parameterType(i));\n-        }\n-        return count;\n+        return parameterSlots(mDesc) + ((flags & ACC_STATIC) == 0 ? 1 : 0) ;\n     }\n\n     public static int slotSize(ClassDesc desc) {\n-        return switch (desc.descriptorString().charAt(0)) {\n-            case 'V' -> 0;\n-            case 'D','J' -> 2;\n-            default -> 1;\n-        };\n+        return desc == CD_void ? 0 : isDoubleSlot(desc) ? 2 : 1;\n+    }\n\n+    public static int paramSlotSize(ClassDesc desc) {\n+        return isDoubleSlot(desc) ? 2 : 1;\n     }\n\n     public static boolean isDoubleSlot(ClassDesc desc) {\n-        char ch = desc.descriptorString().charAt(0);\n-        return ch == 'D' || ch == 'J';\n+        return desc == CD_double || desc == CD_long;\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/febbd998ee72054353e816e9b7b588c9ea2c0500", "code_v0_no_empty_lines": "1. parameterSlots方法通过遍历参数并累加slotSize计算总槽数，每次迭代都调用slotSize；2. maxLocals方法重复计算参数槽数；3. slotSize和isDoubleSlot方法通过字符串比较判断类型。", "code_v1_no_empty_lines": "public static int parameterSlots(MethodTypeDesc mDesc) {\n-        int count = 0;\n-        for (int i = 0; i < mDesc.parameterCount(); i++) {\n-            count += slotSize(mDesc.parameterType(i));\n+        int count = mDesc.parameterCount();\n+        for (int i = count - 1; i >= 0; i--) {\n+            if (isDoubleSlot(mDesc.parameterType(i))) {\n+                count++;\n+            }\n         }\n         return count;\n     }\n\n     public static int maxLocals(int flags, MethodTypeDesc mDesc) {\n-        int count = ((flags & ACC_STATIC) != 0) ? 0 : 1;\n-        for (int i = 0; i < mDesc.parameterCount(); i++) {\n-            count += slotSize(mDesc.parameterType(i));\n-        }\n-        return count;\n+        return parameterSlots(mDesc) + ((flags & ACC_STATIC) == 0 ? 1 : 0) ;\n     }\n\n     public static int slotSize(ClassDesc desc) {\n-        return switch (desc.descriptorString().charAt(0)) {\n-            case 'V' -> 0;\n-            case 'D','J' -> 2;\n-            default -> 1;\n-        };\n+        return desc == CD_void ? 0 : isDoubleSlot(desc) ? 2 : 1;\n+    }\n\n+    public static int paramSlotSize(ClassDesc desc) {\n+        return isDoubleSlot(desc) ? 2 : 1;\n     }\n\n     public static boolean isDoubleSlot(ClassDesc desc) {\n-        char ch = desc.descriptorString().charAt(0);\n-        return ch == 'D' || ch == 'J';\n+        return desc == CD_double || desc == CD_long;\n     }", "target": "public static int parameterSlots(MethodTypeDesc mDesc) {\n-        int count = 0;\n-        for (int i = 0; i < mDesc.parameterCount(); i++) {\n-            count += slotSize(mDesc.parameterType(i));\n+        int count = mDesc.parameterCount();\n+        for (int i = count - 1; i >= 0; i--) {\n+            if (isDoubleSlot(mDesc.parameterType(i))) {\n+                count++;\n+            }\n         }\n         return count;\n     }\n\n     public static int maxLocals(int flags, MethodTypeDesc mDesc) {\n-        int count = ((flags & ACC_STATIC) != 0) ? 0 : 1;\n-        for (int i = 0; i < mDesc.parameterCount(); i++) {\n-            count += slotSize(mDesc.parameterType(i));\n-        }\n-        return count;\n+        return parameterSlots(mDesc) + ((flags & ACC_STATIC) == 0 ? 1 : 0) ;\n     }\n\n     public static int slotSize(ClassDesc desc) {\n-        return switch (desc.descriptorString().charAt(0)) {\n-            case 'V' -> 0;\n-            case 'D','J' -> 2;\n-            default -> 1;\n-        };\n+        return desc == CD_void ? 0 : isDoubleSlot(desc) ? 2 : 1;\n+    }\n\n+    public static int paramSlotSize(ClassDesc desc) {\n+        return isDoubleSlot(desc) ? 2 : 1;\n     }\n\n     public static boolean isDoubleSlot(ClassDesc desc) {\n-        char ch = desc.descriptorString().charAt(0);\n-        return ch == 'D' || ch == 'J';\n+        return desc == CD_double || desc == CD_long;\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. parameterSlots方法通过遍历参数并累加slotSize计算总槽数，每次迭代都调用slotSize；2. maxLocals方法重复计算参数槽数；3. slotSize和isDoubleSlot方法通过字符串比较判断类型。优化后：1. parameterSlots方法改为从参数数量开始，仅对双槽类型（long/double）进行额外计数，减少方法调用；2. maxLocals方法复用parameterSlots结果，避免重复计算；3. 新增paramSlotSize方法专门处理参数槽大小；4. slotSize和isDoubleSlot改用常量比较，避免字符串操作。优化思路：通过减少方法调用、复用计算结果、优化类型比较逻辑，提升ClassFile处理性能。"}
{"id": 773, "source": "riscv-dataset-excel", "optimization_type": "字节码处理性能优化", "optimization_description": "优化前：使用ByteBuffer包装字节码数组，涉及内存分配和包装开销。优化后：引入RawBytecodeHelper.CodeRange直接操作原始字节数组，避免ByteBuffer分配和包装开销。思路：通过直接内存访问和预计算的字节码长度表（LENGTHS数组）提高字节码解析速度，减少中间对象创建和内存拷贝。", "original_code": "使用ByteBuffer包装字节码数组，涉及内存分配和包装开销。", "optimized_code": "- public ByteBuffer asByteBuffer() {\n-     return ByteBuffer.wrap(elems, 0, offset).slice();\n- }\n+ public RawBytecodeHelper.CodeRange bytecodeView() {\n+     return RawBytecodeHelper.of(elems, offset);\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/a1eebbdf8a62b641b765bf4cec5066690c11a8e5", "code_v0_no_empty_lines": "使用ByteBuffer包装字节码数组，涉及内存分配和包装开销。", "code_v1_no_empty_lines": "- public ByteBuffer asByteBuffer() {\n-     return ByteBuffer.wrap(elems, 0, offset).slice();\n- }\n+ public RawBytecodeHelper.CodeRange bytecodeView() {\n+     return RawBytecodeHelper.of(elems, offset);\n+ }", "target": "- public ByteBuffer asByteBuffer() {\n-     return ByteBuffer.wrap(elems, 0, offset).slice();\n- }\n+ public RawBytecodeHelper.CodeRange bytecodeView() {\n+     return RawBytecodeHelper.of(elems, offset);\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用ByteBuffer包装字节码数组，涉及内存分配和包装开销。优化后：引入RawBytecodeHelper.CodeRange直接操作原始字节数组，避免ByteBuffer分配和包装开销。思路：通过直接内存访问和预计算的字节码长度表（LENGTHS数组）提高字节码解析速度，减少中间对象创建和内存拷贝。"}
{"id": 774, "source": "riscv-dataset-excel", "optimization_type": "方法调用优化+内存优化", "optimization_description": "优化前：使用invoke方法调用构造函数，需要额外的类型检查和转换开销。优化后：改用invokeBasic方法直接调用构造函数，避免类型转换和检查，减少构造开销。同时修复了拼写错误（'argment'→'argument'），并统一了变量命名（'concat'→'concatenator'）。", "original_code": "使用invoke方法调用构造函数，需要额外的类型检查和转换开销。", "optimized_code": "- var instance = hiddenClass.cast(constructor.invoke(constants));\n+ var instance = constructor.invokeBasic((Object)constants);\n- var instance = handlePair.constructor.invoke(constants);\n+ var instance = handlePair.constructor.invokeBasic((Object)constants);", "source_url": "https://github.com/openjdk/riscv-port/commit/cb00333d6a47760cb2ab17e867ea8dab32289f98", "code_v0_no_empty_lines": "使用invoke方法调用构造函数，需要额外的类型检查和转换开销。", "code_v1_no_empty_lines": "- var instance = hiddenClass.cast(constructor.invoke(constants));\n+ var instance = constructor.invokeBasic((Object)constants);\n- var instance = handlePair.constructor.invoke(constants);\n+ var instance = handlePair.constructor.invokeBasic((Object)constants);", "target": "- var instance = hiddenClass.cast(constructor.invoke(constants));\n+ var instance = constructor.invokeBasic((Object)constants);\n- var instance = handlePair.constructor.invoke(constants);\n+ var instance = handlePair.constructor.invokeBasic((Object)constants);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用invoke方法调用构造函数，需要额外的类型检查和转换开销。优化后：改用invokeBasic方法直接调用构造函数，避免类型转换和检查，减少构造开销。同时修复了拼写错误（'argment'→'argument'），并统一了变量命名（'concat'→'concatenator'）。"}
{"id": 775, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+内存访问优化", "optimization_description": "优化前：clear_all()方法顺序调用clear_current()和clear_previous()，这两个方法内部可能包含额外的逻辑和检查，在并发场景下可能存在竞态条件，导致只有一个remembered set被正确清理。优化后：直接调用_bitmap数组的clear_large()方法，减少函数调用开销，消除潜在的竞态条件，确保两个remembered set都能被正确且高效地清理。", "original_code": "clear_all()方法顺序调用clear_current()和clear_previous()，这两个方法内部可能包含额外的逻辑和检查，在并发场景下可能存在竞态条件，导致只有一个remembered set被正确清理。", "optimized_code": "-  clear_current();\n-  clear_previous();\n+  _bitmap[0].clear_large();\n+  _bitmap[1].clear_large();", "source_url": "https://github.com/openjdk/riscv-port/commit/ab656c3aab8157ed8e70bc126881cbadc825de93", "code_v0_no_empty_lines": "clear_all()方法顺序调用clear_current()和clear_previous()，这两个方法内部可能包含额外的逻辑和检查，在并发场景下可能存在竞态条件，导致只有一个remembered set被正确清理。", "code_v1_no_empty_lines": "-  clear_current();\n-  clear_previous();\n+  _bitmap[0].clear_large();\n+  _bitmap[1].clear_large();", "target": "-  clear_current();\n-  clear_previous();\n+  _bitmap[0].clear_large();\n+  _bitmap[1].clear_large();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：clear_all()方法顺序调用clear_current()和clear_previous()，这两个方法内部可能包含额外的逻辑和检查，在并发场景下可能存在竞态条件，导致只有一个remembered set被正确清理。优化后：直接调用_bitmap数组的clear_large()方法，减少函数调用开销，消除潜在的竞态条件，确保两个remembered set都能被正确且高效地清理。"}
{"id": 776, "source": "riscv-dataset-excel", "optimization_type": "循环优化+断言修复", "optimization_description": "优化前：处理无限循环时，将循环头设置为根循环(_ltree_root)，导致后续断言失败(assert(!n_loop->is_member(get_loop(lca))) failed)。优化后：不再将无限循环标记为根循环，而是为无限循环创建NeverBranch退出边，并将退出边节点正确设置为根循环。优化思路：修复无限循环处理逻辑，确保控制流图正确构建，避免断言失败，同时移除冗余的only_has_infinite_loops()验证函数。", "original_code": "处理无限循环时，将循环头设置为根循环(_ltree_root)，导致后续断言失败(assert(!n_loop->is_member(get_loop(lca))) failed)。", "optimized_code": "-        l = _ltree_root;        // Oops, found infinite loop\n+        // Now create the never-taken loop exit\n+          Node *if_f = new CProjNode( iff, 1 );\n+          _igvn.register_new_node_with_optimizer(if_f);\n+          set_loop(if_f, _ltree_root);", "source_url": "https://github.com/openjdk/riscv-port/commit/e203df46faf610e35e2c2510271ad68199f4fa3f", "code_v0_no_empty_lines": "处理无限循环时，将循环头设置为根循环(_ltree_root)，导致后续断言失败(assert(!n_loop->is_member(get_loop(lca))) failed)。", "code_v1_no_empty_lines": "-        l = _ltree_root;        // Oops, found infinite loop\n+        // Now create the never-taken loop exit\n+          Node *if_f = new CProjNode( iff, 1 );\n+          _igvn.register_new_node_with_optimizer(if_f);\n+          set_loop(if_f, _ltree_root);", "target": "-        l = _ltree_root;        // Oops, found infinite loop\n+        // Now create the never-taken loop exit\n+          Node *if_f = new CProjNode( iff, 1 );\n+          _igvn.register_new_node_with_optimizer(if_f);\n+          set_loop(if_f, _ltree_root);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：处理无限循环时，将循环头设置为根循环(_ltree_root)，导致后续断言失败(assert(!n_loop->is_member(get_loop(lca))) failed)。优化后：不再将无限循环标记为根循环，而是为无限循环创建NeverBranch退出边，并将退出边节点正确设置为根循环。优化思路：修复无限循环处理逻辑，确保控制流图正确构建，避免断言失败，同时移除冗余的only_has_infinite_loops()验证函数。"}
{"id": 777, "source": "riscv-dataset-excel", "optimization_type": "内存复制性能优化", "optimization_description": "优化前：MemorySegment::copy方法直接调用底层copy方法，对小内存复制没有特殊优化，统一使用native调用。优化后：1. 新增COPY_NATIVE_THRESHOLD阈值（64字节），小于该阈值且内存段不重叠时，使用Java循环进行复制；2. 采用8字节、4字节、2字节、1字节的分级复制策略，减少方法调用开销；3. 添加overlaps()方法优化重叠检测逻辑。优化思路：针对小内存复制场景，避免native调用的开销，通过inline和循环展开提高性能；对大内存复制仍使用native方法保持效率。", "original_code": "MemorySegment::copy方法直接调用底层copy方法，对小内存复制没有特殊优化，统一使用native调用。", "optimized_code": "@ForceInline\npublic static void copy(AbstractMemorySegmentImpl src, long srcOffset,\n                        AbstractMemorySegmentImpl dst, long dstOffset,\n                        long size) {\n    // ...\n    if (size <= 0) {\n        // Do nothing\n    } else if (size < COPY_NATIVE_THRESHOLD && !src.overlaps(dst)) {\n        // 0 < size < FILL_NATIVE_LIMIT : 0...0X...XXXX\n        //\n        // Strictly, we could check for !src.asSlice(srcOffset, size).overlaps(dst.asSlice(dstOffset, size) but\n        // this is a bit slower and it likely very unusual there is any difference in the outcome. Also, if there\n        // is an overlap, we could tolerate one particular direction of overlap (but not the other).\n\n        // 0...0X...X000\n        final int limit = (int) (size & (COPY_NATIVE_THRESHOLD - 8));\n        int offset = 0;\n        for (; offset < limit; offset += 8) {\n            final long v = SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n            SCOPED_MEMORY_ACCESS.putLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n        }\n        int remaining = (int) size - offset;\n        // 0...0X00\n        if (remaining >= 4) {\n            final int v = SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(),src.unsafeGetOffset() + srcOffset + offset);\n            SCOPED_MEMORY_ACCESS.putInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n            offset += 4;\n            remaining -= 4;\n        }\n        // 0...00X0\n        if (remaining >= 2) {\n            final short v = SCOPED_MEMORY_ACCESS.getShort(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n            SCOPED_MEMORY_ACCESS.putShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n            offset += 2;\n            remaining -=2;\n        }\n        // 0...000X\n        if (remaining == 1) {\n            final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n            SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n        }\n        // We have now fully handled 0...0X...XXXX\n    } else {\n        // For larger sizes, the transition to native code pays off\n        SCOPED_MEMORY_ACCESS.copyMemory(src.sessionImpl(), dst.sessionImpl(),\n                src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset,\n                dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, size);\n    }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/6be927260a84b1d7542167e526ff41f7dc26cab0", "code_v0_no_empty_lines": "MemorySegment::copy方法直接调用底层copy方法，对小内存复制没有特殊优化，统一使用native调用。", "code_v1_no_empty_lines": "@ForceInline\npublic static void copy(AbstractMemorySegmentImpl src, long srcOffset,\n                        AbstractMemorySegmentImpl dst, long dstOffset,\n                        long size) {\n    // ...\n    if (size <= 0) {\n        // Do nothing\n    } else if (size < COPY_NATIVE_THRESHOLD && !src.overlaps(dst)) {\n        // 0 < size < FILL_NATIVE_LIMIT : 0...0X...XXXX\n        //\n        // Strictly, we could check for !src.asSlice(srcOffset, size).overlaps(dst.asSlice(dstOffset, size) but\n        // this is a bit slower and it likely very unusual there is any difference in the outcome. Also, if there\n        // is an overlap, we could tolerate one particular direction of overlap (but not the other).\n\n        // 0...0X...X000\n        final int limit = (int) (size & (COPY_NATIVE_THRESHOLD - 8));\n        int offset = 0;\n        for (; offset < limit; offset += 8) {\n            final long v = SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n            SCOPED_MEMORY_ACCESS.putLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n        }\n        int remaining = (int) size - offset;\n        // 0...0X00\n        if (remaining >= 4) {\n            final int v = SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(),src.unsafeGetOffset() + srcOffset + offset);\n            SCOPED_MEMORY_ACCESS.putInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n            offset += 4;\n            remaining -= 4;\n        }\n        // 0...00X0\n        if (remaining >= 2) {\n            final short v = SCOPED_MEMORY_ACCESS.getShort(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n            SCOPED_MEMORY_ACCESS.putShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n            offset += 2;\n            remaining -=2;\n        }\n        // 0...000X\n        if (remaining == 1) {\n            final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n            SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n        }\n        // We have now fully handled 0...0X...XXXX\n    } else {\n        // For larger sizes, the transition to native code pays off\n        SCOPED_MEMORY_ACCESS.copyMemory(src.sessionImpl(), dst.sessionImpl(),\n                src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset,\n                dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, size);\n    }\n}", "target": "@ForceInline\npublic static void copy(AbstractMemorySegmentImpl src, long srcOffset,\n                        AbstractMemorySegmentImpl dst, long dstOffset,\n                        long size) {\n    // ...\n    if (size <= 0) {\n        // Do nothing\n    } else if (size < COPY_NATIVE_THRESHOLD && !src.overlaps(dst)) {\n        // 0 < size < FILL_NATIVE_LIMIT : 0...0X...XXXX\n        //\n        // Strictly, we could check for !src.asSlice(srcOffset, size).overlaps(dst.asSlice(dstOffset, size) but\n        // this is a bit slower and it likely very unusual there is any difference in the outcome. Also, if there\n        // is an overlap, we could tolerate one particular direction of overlap (but not the other).\n\n        // 0...0X...X000\n        final int limit = (int) (size & (COPY_NATIVE_THRESHOLD - 8));\n        int offset = 0;\n        for (; offset < limit; offset += 8) {\n            final long v = SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n            SCOPED_MEMORY_ACCESS.putLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n        }\n        int remaining = (int) size - offset;\n        // 0...0X00\n        if (remaining >= 4) {\n            final int v = SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(),src.unsafeGetOffset() + srcOffset + offset);\n            SCOPED_MEMORY_ACCESS.putInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n            offset += 4;\n            remaining -= 4;\n        }\n        // 0...00X0\n        if (remaining >= 2) {\n            final short v = SCOPED_MEMORY_ACCESS.getShort(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n            SCOPED_MEMORY_ACCESS.putShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n            offset += 2;\n            remaining -=2;\n        }\n        // 0...000X\n        if (remaining == 1) {\n            final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n            SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n        }\n        // We have now fully handled 0...0X...XXXX\n    } else {\n        // For larger sizes, the transition to native code pays off\n        SCOPED_MEMORY_ACCESS.copyMemory(src.sessionImpl(), dst.sessionImpl(),\n                src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset,\n                dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, size);\n    }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：MemorySegment::copy方法直接调用底层copy方法，对小内存复制没有特殊优化，统一使用native调用。优化后：1. 新增COPY_NATIVE_THRESHOLD阈值（64字节），小于该阈值且内存段不重叠时，使用Java循环进行复制；2. 采用8字节、4字节、2字节、1字节的分级复制策略，减少方法调用开销；3. 添加overlaps()方法优化重叠检测逻辑。优化思路：针对小内存复制场景，避免native调用的开销，通过inline和循环展开提高性能；对大内存复制仍使用native方法保持效率。"}
{"id": 778, "source": "riscv-dataset-excel", "optimization_type": "内存优化+性能优化", "optimization_description": "优化前使用TreeMap存储和排序StackMapFrameInfo对象，导致大量内存分配和额外开销。优化后改为使用数组（entries.toArray(NO_STACK_FRAME_INFOS)）配合Arrays.sort进行排序，减少了对象分配和内存占用，同时避免了TreeMap的内部节点开销。优化思路是替换复杂数据结构为简单数组，降低内存分配频率，提升性能。", "original_code": "// No original code extracted from description\n", "optimized_code": "- var map = new TreeMap<Integer, StackMapFrameInfo>();\n- for (var fr : entries) {\n-     map.put(dcb.labelToBci(fr.target()), fr);\n- }\n- b.writeU2(map.size());\n- for (var me : map.entrySet()) {\n-     int offset = me.getKey();\n-     var fr = me.getValue();\n+ // avoid using method handles due to early bootstrap\n+ StackMapFrameInfo[] infos = entries.toArray(NO_STACK_FRAME_INFOS);\n+ //sort by resolved label offsets first to allow unordered entries\n+ Arrays.sort(infos, new Comparator<StackMapFrameInfo>() {\n+     public int compare(final StackMapFrameInfo o1, final StackMapFrameInfo o2) {\n+         return Integer.compare(dcb.labelToBci(o1.target()), dcb.labelToBci(o2.target()));\n+     }\n+ });\n+ b.writeU2(infos.length);\n+ for (var fr : infos) {\n+     int offset = dcb.labelToBci(fr.target());", "source_url": "https://github.com/openjdk/riscv-port/commit/433f6d8a0643b59663bf76c0f3a2af27a6cc56b7", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- var map = new TreeMap<Integer, StackMapFrameInfo>();\n- for (var fr : entries) {\n-     map.put(dcb.labelToBci(fr.target()), fr);\n- }\n- b.writeU2(map.size());\n- for (var me : map.entrySet()) {\n-     int offset = me.getKey();\n-     var fr = me.getValue();\n+ // avoid using method handles due to early bootstrap\n+ StackMapFrameInfo[] infos = entries.toArray(NO_STACK_FRAME_INFOS);\n+ //sort by resolved label offsets first to allow unordered entries\n+ Arrays.sort(infos, new Comparator<StackMapFrameInfo>() {\n+     public int compare(final StackMapFrameInfo o1, final StackMapFrameInfo o2) {\n+         return Integer.compare(dcb.labelToBci(o1.target()), dcb.labelToBci(o2.target()));\n+     }\n+ });\n+ b.writeU2(infos.length);\n+ for (var fr : infos) {\n+     int offset = dcb.labelToBci(fr.target());", "target": "- var map = new TreeMap<Integer, StackMapFrameInfo>();\n- for (var fr : entries) {\n-     map.put(dcb.labelToBci(fr.target()), fr);\n- }\n- b.writeU2(map.size());\n- for (var me : map.entrySet()) {\n-     int offset = me.getKey();\n-     var fr = me.getValue();\n+ // avoid using method handles due to early bootstrap\n+ StackMapFrameInfo[] infos = entries.toArray(NO_STACK_FRAME_INFOS);\n+ //sort by resolved label offsets first to allow unordered entries\n+ Arrays.sort(infos, new Comparator<StackMapFrameInfo>() {\n+     public int compare(final StackMapFrameInfo o1, final StackMapFrameInfo o2) {\n+         return Integer.compare(dcb.labelToBci(o1.target()), dcb.labelToBci(o2.target()));\n+     }\n+ });\n+ b.writeU2(infos.length);\n+ for (var fr : infos) {\n+     int offset = dcb.labelToBci(fr.target());", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前使用TreeMap存储和排序StackMapFrameInfo对象，导致大量内存分配和额外开销。优化后改为使用数组（entries.toArray(NO_STACK_FRAME_INFOS)）配合Arrays.sort进行排序，减少了对象分配和内存占用，同时避免了TreeMap的内部节点开销。优化思路是替换复杂数据结构为简单数组，降低内存分配频率，提升性能。"}
{"id": 779, "source": "riscv-dataset-excel", "optimization_type": "字符串处理优化+性能优化", "optimization_description": "优化前：Utf8EntryImpl#writeTo方法中，字符串编码为UTF-8时采用复杂的手动编码逻辑，包含字符遍历、长度计算和条件分支，性能开销较大。优化后：1. 新增StringCoding.countNonZeroAscii()方法快速统计前导ASCII字符；2. 在BufWriterImpl中实现优化的writeUtf8()方法，利用新统计方法减少分支判断；3. 简化AbstractPoolEntry.writeTo()，将复杂编码逻辑委托给BufWriterImpl.writeUtf8()。优化思路：通过预计算前导ASCII字符数量，避免逐字符的复杂条件判断，减少循环和分支开销，提升UTF-8编码写入性能。", "original_code": "Utf8EntryImpl#writeTo方法中，字符串编码为UTF-8时采用复杂的手动编码逻辑，包含字符遍历、长度计算和条件分支，性能开销较大。", "optimized_code": "--- a/src/java.base/share/classes/jdk/internal/classfile/impl/AbstractPoolEntry.java\n+++ b/src/java.base/share/classes/jdk/internal/classfile/impl/AbstractPoolEntry.java\n@@ -409,60 +410,14 @@ public boolean equalsString(String s) {\n \n         @Override\n         void writeTo(BufWriterImpl pool) {\n+            pool.writeU1(tag);\n             if (rawBytes != null) {\n-                pool.writeU1(tag);\n                 pool.writeU2(rawLen);\n                 pool.writeBytes(rawBytes, offset, rawLen);\n             }\n             else {\n                 // state == STRING and no raw bytes\n-                if (stringValue.length() > 65535) {\n-                    throw new IllegalArgumentException(\"string too long\");\n-                }\n-                pool.writeU1(tag);\n-                pool.writeU2(charLen);\n-                for (int i = 0; i < charLen; ++i) {\n-                    char c = stringValue.charAt(i);\n-                    if (c >= '\\001' && c <= '\\177') {\n-                        // Optimistic writing -- hope everything is bytes\n-                        // If not, we bail out, and alternate path patches the length\n-                        pool.writeU1((byte) c);\n-                    }\n-                    else {\n-                        int charLength = stringValue.length();\n-                        int byteLength = i;\n-                        char c1;\n-                        for (int j = i; j < charLength; ++j) {\n-                            c1 = (stringValue).charAt(j);\n-                            if (c1 >= '\\001' && c1 <= '\\177') {\n-                                byteLength++;\n-                            } else if (c1 > '\\u07FF') {\n-                                byteLength += 3;\n-                            } else {\n-                                byteLength += 2;\n-                            }\n-                        }\n-                        if (byteLength > 65535) {\n-                            throw new IllegalArgumentException();\n-                        }\n-                        int byteLengthFinal = byteLength;\n-                        pool.patchInt(pool.size() - i - 2, 2, byteLengthFinal);\n-                        for (int j = i; j < charLength; ++j) {\n-                            c1 = (stringValue).charAt(j);\n-                            if (c1 >= '\\001' && c1 <= '\\177') {\n-                                pool.writeU1((byte) c1);\n-                            } else if (c1 > '\\u07FF') {\n-                                pool.writeU1((byte) (0xE0 | c1 >> 12 & 0xF));\n-                                pool.writeU1((byte) (0x80 | c1 >> 6 & 0x3F));\n-                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n-                            } else {\n-                                pool.writeU1((byte) (0xC0 | c1 >> 6 & 0x1F));\n-                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n-                            }\n-                        }\n-  \n+                pool.writeU2(charLen);\n+                pool.writeUtf8(stringValue);\n             }\n         }", "source_url": "https://github.com/openjdk/riscv-port/commit/cb9f5c5791d17afbf72f7debe8013b77e45b3b56", "code_v0_no_empty_lines": "Utf8EntryImpl#writeTo方法中，字符串编码为UTF-8时采用复杂的手动编码逻辑，包含字符遍历、长度计算和条件分支，性能开销较大。", "code_v1_no_empty_lines": "--- a/src/java.base/share/classes/jdk/internal/classfile/impl/AbstractPoolEntry.java\n+++ b/src/java.base/share/classes/jdk/internal/classfile/impl/AbstractPoolEntry.java\n@@ -409,60 +410,14 @@ public boolean equalsString(String s) {\n \n         @Override\n         void writeTo(BufWriterImpl pool) {\n+            pool.writeU1(tag);\n             if (rawBytes != null) {\n-                pool.writeU1(tag);\n                 pool.writeU2(rawLen);\n                 pool.writeBytes(rawBytes, offset, rawLen);\n             }\n             else {\n                 // state == STRING and no raw bytes\n-                if (stringValue.length() > 65535) {\n-                    throw new IllegalArgumentException(\"string too long\");\n-                }\n-                pool.writeU1(tag);\n-                pool.writeU2(charLen);\n-                for (int i = 0; i < charLen; ++i) {\n-                    char c = stringValue.charAt(i);\n-                    if (c >= '\\001' && c <= '\\177') {\n-                        // Optimistic writing -- hope everything is bytes\n-                        // If not, we bail out, and alternate path patches the length\n-                        pool.writeU1((byte) c);\n-                    }\n-                    else {\n-                        int charLength = stringValue.length();\n-                        int byteLength = i;\n-                        char c1;\n-                        for (int j = i; j < charLength; ++j) {\n-                            c1 = (stringValue).charAt(j);\n-                            if (c1 >= '\\001' && c1 <= '\\177') {\n-                                byteLength++;\n-                            } else if (c1 > '\\u07FF') {\n-                                byteLength += 3;\n-                            } else {\n-                                byteLength += 2;\n-                            }\n-                        }\n-                        if (byteLength > 65535) {\n-                            throw new IllegalArgumentException();\n-                        }\n-                        int byteLengthFinal = byteLength;\n-                        pool.patchInt(pool.size() - i - 2, 2, byteLengthFinal);\n-                        for (int j = i; j < charLength; ++j) {\n-                            c1 = (stringValue).charAt(j);\n-                            if (c1 >= '\\001' && c1 <= '\\177') {\n-                                pool.writeU1((byte) c1);\n-                            } else if (c1 > '\\u07FF') {\n-                                pool.writeU1((byte) (0xE0 | c1 >> 12 & 0xF));\n-                                pool.writeU1((byte) (0x80 | c1 >> 6 & 0x3F));\n-                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n-                            } else {\n-                                pool.writeU1((byte) (0xC0 | c1 >> 6 & 0x1F));\n-                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n-                            }\n-                        }\n-  \n+                pool.writeU2(charLen);\n+                pool.writeUtf8(stringValue);\n             }\n         }", "target": "--- a/src/java.base/share/classes/jdk/internal/classfile/impl/AbstractPoolEntry.java\n+++ b/src/java.base/share/classes/jdk/internal/classfile/impl/AbstractPoolEntry.java\n@@ -409,60 +410,14 @@ public boolean equalsString(String s) {\n \n         @Override\n         void writeTo(BufWriterImpl pool) {\n+            pool.writeU1(tag);\n             if (rawBytes != null) {\n-                pool.writeU1(tag);\n                 pool.writeU2(rawLen);\n                 pool.writeBytes(rawBytes, offset, rawLen);\n             }\n             else {\n                 // state == STRING and no raw bytes\n-                if (stringValue.length() > 65535) {\n-                    throw new IllegalArgumentException(\"string too long\");\n-                }\n-                pool.writeU1(tag);\n-                pool.writeU2(charLen);\n-                for (int i = 0; i < charLen; ++i) {\n-                    char c = stringValue.charAt(i);\n-                    if (c >= '\\001' && c <= '\\177') {\n-                        // Optimistic writing -- hope everything is bytes\n-                        // If not, we bail out, and alternate path patches the length\n-                        pool.writeU1((byte) c);\n-                    }\n-                    else {\n-                        int charLength = stringValue.length();\n-                        int byteLength = i;\n-                        char c1;\n-                        for (int j = i; j < charLength; ++j) {\n-                            c1 = (stringValue).charAt(j);\n-                            if (c1 >= '\\001' && c1 <= '\\177') {\n-                                byteLength++;\n-                            } else if (c1 > '\\u07FF') {\n-                                byteLength += 3;\n-                            } else {\n-                                byteLength += 2;\n-                            }\n-                        }\n-                        if (byteLength > 65535) {\n-                            throw new IllegalArgumentException();\n-                        }\n-                        int byteLengthFinal = byteLength;\n-                        pool.patchInt(pool.size() - i - 2, 2, byteLengthFinal);\n-                        for (int j = i; j < charLength; ++j) {\n-                            c1 = (stringValue).charAt(j);\n-                            if (c1 >= '\\001' && c1 <= '\\177') {\n-                                pool.writeU1((byte) c1);\n-                            } else if (c1 > '\\u07FF') {\n-                                pool.writeU1((byte) (0xE0 | c1 >> 12 & 0xF));\n-                                pool.writeU1((byte) (0x80 | c1 >> 6 & 0x3F));\n-                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n-                            } else {\n-                                pool.writeU1((byte) (0xC0 | c1 >> 6 & 0x1F));\n-                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n-                            }\n-                        }\n-  \n+                pool.writeU2(charLen);\n+                pool.writeUtf8(stringValue);\n             }\n         }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Utf8EntryImpl#writeTo方法中，字符串编码为UTF-8时采用复杂的手动编码逻辑，包含字符遍历、长度计算和条件分支，性能开销较大。优化后：1. 新增StringCoding.countNonZeroAscii()方法快速统计前导ASCII字符；2. 在BufWriterImpl中实现优化的writeUtf8()方法，利用新统计方法减少分支判断；3. 简化AbstractPoolEntry.writeTo()，将复杂编码逻辑委托给BufWriterImpl.writeUtf8()。优化思路：通过预计算前导ASCII字符数量，避免逐字符的复杂条件判断，减少循环和分支开销，提升UTF-8编码写入性能。"}
{"id": 780, "source": "riscv-dataset-excel", "optimization_type": "字符串拼接优化", "optimization_description": "优化前：多处使用字符串拼接操作符（+）或低效的字符串构建方式，导致不必要的StringBuilder对象创建和字符串复制开销。优化后：1. 对于简单拼接（如\"[\" + str），改用String.concat()方法避免创建StringBuilder。2. 对于三部分拼接（如\"L\" + name + \";\"），使用新增的StringConcatHelper.concat()方法进行高效拼接。3. 对于需要填充前导零的场景，改用StringBuilder的repeat()方法避免循环拼接。优化思路：减少临时对象分配和字符串复制，利用专门的字符串拼接工具方法提高性能，特别是在ClassDesc相关操作中频繁调用的场景。", "original_code": "多处使用字符串拼接操作符（+）或低效的字符串构建方式，导致不必要的StringBuilder对象创建和字符串复制开销。", "optimized_code": "- return \"[\" + componentType.descriptorString();\n+ return \"[\".concat(componentType.descriptorString());\n- return new StringBuilder(name.length() + 2)\n        .append('L')\n        .append(name)\n        .append(';')\n        .toString();\n+ return StringConcatHelper.concat(\"L\", name, \";\");\n- return ClassDesc.ofDescriptor(\"L\" + binaryToInternal(name) + \";\");\n+ return ClassDesc.ofDescriptor(concat(\"L\", binaryToInternal(name), \";\"));\n- this.className = CLASS_PREFIX + name;\n+ this.className = CLASS_PREFIX.concat(name);\n- String sfx = ctr.toString();\n  while (sfx.length() < 3)\n      sfx = \"0\" + sfx;\n  className += sfx;\n  return className;\n+ var buf = new StringBuilder(className.length() + 3).append(className);\n  int ctrVal = ctr;\n  if (ctrVal < 10) {\n      buf.repeat('0', 2);\n  } else if (ctrVal < 100) {\n      buf.append('0');\n  }\n  buf.append(ctrVal);\n  return buf.toString();", "source_url": "https://github.com/openjdk/riscv-port/commit/55312e1549c36be46b0f3b3b40763a33311c3e25", "code_v0_no_empty_lines": "多处使用字符串拼接操作符（+）或低效的字符串构建方式，导致不必要的StringBuilder对象创建和字符串复制开销。", "code_v1_no_empty_lines": "- return \"[\" + componentType.descriptorString();\n+ return \"[\".concat(componentType.descriptorString());\n- return new StringBuilder(name.length() + 2)\n        .append('L')\n        .append(name)\n        .append(';')\n        .toString();\n+ return StringConcatHelper.concat(\"L\", name, \";\");\n- return ClassDesc.ofDescriptor(\"L\" + binaryToInternal(name) + \";\");\n+ return ClassDesc.ofDescriptor(concat(\"L\", binaryToInternal(name), \";\"));\n- this.className = CLASS_PREFIX + name;\n+ this.className = CLASS_PREFIX.concat(name);\n- String sfx = ctr.toString();\n  while (sfx.length() < 3)\n      sfx = \"0\" + sfx;\n  className += sfx;\n  return className;\n+ var buf = new StringBuilder(className.length() + 3).append(className);\n  int ctrVal = ctr;\n  if (ctrVal < 10) {\n      buf.repeat('0', 2);\n  } else if (ctrVal < 100) {\n      buf.append('0');\n  }\n  buf.append(ctrVal);\n  return buf.toString();", "target": "- return \"[\" + componentType.descriptorString();\n+ return \"[\".concat(componentType.descriptorString());\n- return new StringBuilder(name.length() + 2)\n        .append('L')\n        .append(name)\n        .append(';')\n        .toString();\n+ return StringConcatHelper.concat(\"L\", name, \";\");\n- return ClassDesc.ofDescriptor(\"L\" + binaryToInternal(name) + \";\");\n+ return ClassDesc.ofDescriptor(concat(\"L\", binaryToInternal(name), \";\"));\n- this.className = CLASS_PREFIX + name;\n+ this.className = CLASS_PREFIX.concat(name);\n- String sfx = ctr.toString();\n  while (sfx.length() < 3)\n      sfx = \"0\" + sfx;\n  className += sfx;\n  return className;\n+ var buf = new StringBuilder(className.length() + 3).append(className);\n  int ctrVal = ctr;\n  if (ctrVal < 10) {\n      buf.repeat('0', 2);\n  } else if (ctrVal < 100) {\n      buf.append('0');\n  }\n  buf.append(ctrVal);\n  return buf.toString();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多处使用字符串拼接操作符（+）或低效的字符串构建方式，导致不必要的StringBuilder对象创建和字符串复制开销。优化后：1. 对于简单拼接（如\"[\" + str），改用String.concat()方法避免创建StringBuilder。2. 对于三部分拼接（如\"L\" + name + \";\"），使用新增的StringConcatHelper.concat()方法进行高效拼接。3. 对于需要填充前导零的场景，改用StringBuilder的repeat()方法避免循环拼接。优化思路：减少临时对象分配和字符串复制，利用专门的字符串拼接工具方法提高性能，特别是在ClassDesc相关操作中频繁调用的场景。"}
{"id": 781, "source": "riscv-dataset-excel", "optimization_type": "指令优化+类型匹配优化", "optimization_description": "优化前：CMoveL指令的源操作数使用immI_1（32位整数常量1），但目标寄存器是64位长整型，需要额外的符号扩展或零扩展操作。优化后：将源操作数改为immL1（64位长整型常量1），直接匹配目标寄存器的类型，消除不必要的扩展操作，提高指令执行效率。优化思路：通过精确匹配操作数类型，减少指令执行时的类型转换开销。", "original_code": "CMoveL指令的源操作数使用immI_1（32位整数常量1），但目标寄存器是64位长整型，需要额外的符号扩展或零扩展操作。", "optimized_code": "-instruct cmovL_imm_01(rRegL dst, immI_1 src, rFlagsReg cr, cmpOp cop)\n+instruct cmovL_imm_01(rRegL dst, immL1 src, rFlagsReg cr, cmpOp cop)", "source_url": "https://github.com/openjdk/riscv-port/commit/6f8714ee197eb48923209299fd842f6757f0a945", "code_v0_no_empty_lines": "CMoveL指令的源操作数使用immI_1（32位整数常量1），但目标寄存器是64位长整型，需要额外的符号扩展或零扩展操作。", "code_v1_no_empty_lines": "-instruct cmovL_imm_01(rRegL dst, immI_1 src, rFlagsReg cr, cmpOp cop)\n+instruct cmovL_imm_01(rRegL dst, immL1 src, rFlagsReg cr, cmpOp cop)", "target": "-instruct cmovL_imm_01(rRegL dst, immI_1 src, rFlagsReg cr, cmpOp cop)\n+instruct cmovL_imm_01(rRegL dst, immL1 src, rFlagsReg cr, cmpOp cop)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CMoveL指令的源操作数使用immI_1（32位整数常量1），但目标寄存器是64位长整型，需要额外的符号扩展或零扩展操作。优化后：将源操作数改为immL1（64位长整型常量1），直接匹配目标寄存器的类型，消除不必要的扩展操作，提高指令执行效率。优化思路：通过精确匹配操作数类型，减少指令执行时的类型转换开销。"}
{"id": 782, "source": "riscv-dataset-excel", "optimization_type": "调试信息增强", "optimization_description": "优化前：打印方法信息时，对于调用节点（CallNode）只显示节点ID和操作码名称，缺少具体的调用方法信息，不利于增量内联的调试分析。优化后：当节点是调用节点时，检查并打印调用名称（如call->_name）或Java方法的短名称（通过call_java->method()->print_short_name()），从而在IGV（Ideal Graph Visualizer）的相位名称中显式包含增量内联的方法名。优化思路：增强调试输出，为编译器开发者和性能分析人员提供更详细的调用上下文信息，便于理解和优化增量内联过程。", "original_code": "打印方法信息时，对于调用节点（CallNode）只显示节点ID和操作码名称，缺少具体的调用方法信息，不利于增量内联的调试分析。", "optimized_code": "if (n != nullptr) {\n-    ss.print(\": %d %s \", n->_idx, NodeClassNames[n->Opcode()]);\n+    ss.print(\": %d %s\", n->_idx, NodeClassNames[n->Opcode()]);\n+    if (n->is_Call()) {\n+      CallNode* call = n->as_Call();\n+      if (call->_name != nullptr) {\n+        // E.g. uncommon traps etc.\n+        ss.print(\" - %s\", call->_name);\n+      } else if (call->is_CallJava()) {\n+        CallJavaNode* call_java = call->as_CallJava();\n+        if (call_java->method() != nullptr) {\n+          ss.print(\" -\");\n+          call_java->method()->print_short_name(&ss);\n+        }\n+      }\n+    }\n   }", "source_url": "https://github.com/openjdk/riscv-port/commit/340e131d616bd81ccd0bdc3817aead0284014cac", "code_v0_no_empty_lines": "打印方法信息时，对于调用节点（CallNode）只显示节点ID和操作码名称，缺少具体的调用方法信息，不利于增量内联的调试分析。", "code_v1_no_empty_lines": "if (n != nullptr) {\n-    ss.print(\": %d %s \", n->_idx, NodeClassNames[n->Opcode()]);\n+    ss.print(\": %d %s\", n->_idx, NodeClassNames[n->Opcode()]);\n+    if (n->is_Call()) {\n+      CallNode* call = n->as_Call();\n+      if (call->_name != nullptr) {\n+        // E.g. uncommon traps etc.\n+        ss.print(\" - %s\", call->_name);\n+      } else if (call->is_CallJava()) {\n+        CallJavaNode* call_java = call->as_CallJava();\n+        if (call_java->method() != nullptr) {\n+          ss.print(\" -\");\n+          call_java->method()->print_short_name(&ss);\n+        }\n+      }\n+    }\n   }", "target": "if (n != nullptr) {\n-    ss.print(\": %d %s \", n->_idx, NodeClassNames[n->Opcode()]);\n+    ss.print(\": %d %s\", n->_idx, NodeClassNames[n->Opcode()]);\n+    if (n->is_Call()) {\n+      CallNode* call = n->as_Call();\n+      if (call->_name != nullptr) {\n+        // E.g. uncommon traps etc.\n+        ss.print(\" - %s\", call->_name);\n+      } else if (call->is_CallJava()) {\n+        CallJavaNode* call_java = call->as_CallJava();\n+        if (call_java->method() != nullptr) {\n+          ss.print(\" -\");\n+          call_java->method()->print_short_name(&ss);\n+        }\n+      }\n+    }\n   }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：打印方法信息时，对于调用节点（CallNode）只显示节点ID和操作码名称，缺少具体的调用方法信息，不利于增量内联的调试分析。优化后：当节点是调用节点时，检查并打印调用名称（如call->_name）或Java方法的短名称（通过call_java->method()->print_short_name()），从而在IGV（Ideal Graph Visualizer）的相位名称中显式包含增量内联的方法名。优化思路：增强调试输出，为编译器开发者和性能分析人员提供更详细的调用上下文信息，便于理解和优化增量内联过程。"}
{"id": 783, "source": "riscv-dataset-excel", "optimization_type": "算法优化+代码重构", "optimization_description": "优化前：ArrayList的subList在调用sort()方法时，会通过默认的List接口实现进行排序，这需要额外的数组拷贝和范围检查。优化后：1. 在ArrayList中新增sortRange()私有方法，支持指定范围的排序；2. 在SubList类中重写sort()方法，直接调用父类的sortRange()方法进行原地排序。优化思路：避免subList排序时的数组拷贝开销，直接对原始数组的指定范围进行排序，提高性能并减少内存占用。", "original_code": "ArrayList的subList在调用sort()方法时，会通过默认的List接口实现进行排序，这需要额外的数组拷贝和范围检查。", "optimized_code": "@Override\npublic void sort(Comparator<? super E> c) {\n    sortRange(c, 0, size);\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void sortRange(Comparator<? super E> c, int fromIndex, int toIndex) {\n    final int expectedModCount = modCount;\n    Arrays.sort((E[]) elementData, fromIndex, toIndex, c);\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n    modCount++;\n}\n\n@Override\npublic void sort(Comparator<? super E> c) {\n    checkForComodification();\n    root.sortRange(c, offset, offset + size);\n    updateSizeAndModCount(0);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/c7d15f1fe09e61c1e61ee253e7e3df4c2b9306a1", "code_v0_no_empty_lines": "ArrayList的subList在调用sort()方法时，会通过默认的List接口实现进行排序，这需要额外的数组拷贝和范围检查。", "code_v1_no_empty_lines": "@Override\npublic void sort(Comparator<? super E> c) {\n    sortRange(c, 0, size);\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void sortRange(Comparator<? super E> c, int fromIndex, int toIndex) {\n    final int expectedModCount = modCount;\n    Arrays.sort((E[]) elementData, fromIndex, toIndex, c);\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n    modCount++;\n}\n\n@Override\npublic void sort(Comparator<? super E> c) {\n    checkForComodification();\n    root.sortRange(c, offset, offset + size);\n    updateSizeAndModCount(0);\n}", "target": "@Override\npublic void sort(Comparator<? super E> c) {\n    sortRange(c, 0, size);\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void sortRange(Comparator<? super E> c, int fromIndex, int toIndex) {\n    final int expectedModCount = modCount;\n    Arrays.sort((E[]) elementData, fromIndex, toIndex, c);\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n    modCount++;\n}\n\n@Override\npublic void sort(Comparator<? super E> c) {\n    checkForComodification();\n    root.sortRange(c, offset, offset + size);\n    updateSizeAndModCount(0);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ArrayList的subList在调用sort()方法时，会通过默认的List接口实现进行排序，这需要额外的数组拷贝和范围检查。优化后：1. 在ArrayList中新增sortRange()私有方法，支持指定范围的排序；2. 在SubList类中重写sort()方法，直接调用父类的sortRange()方法进行原地排序。优化思路：避免subList排序时的数组拷贝开销，直接对原始数组的指定范围进行排序，提高性能并减少内存占用。"}
{"id": 784, "source": "riscv-dataset-excel", "optimization_type": "内存操作性能优化", "optimization_description": "优化前：MemorySegment::fill方法对所有大小的内存段都直接调用原生setMemory方法，对于小内存段存在不必要的原生调用开销。优化后：引入FILL_NATIVE_THRESHOLD阈值（AArch64为1024字节，其他架构为32字节），对于小于阈值的小内存段，使用Java层面的批量写入优化（先按8字节写入，再处理4字节、2字节、1字节的剩余部分），避免原生调用开销；对于大内存段仍使用原生setMemory方法。优化思路：通过减少小内存段操作时的上下文切换开销，提升fill操作的性能，同时保持大内存段的高效原生操作。", "original_code": "MemorySegment::fill方法对所有大小的内存段都直接调用原生setMemory方法，对于小内存段存在不必要的原生调用开销。", "optimized_code": "@Override\n@ForceInline\npublic final MemorySegment fill(byte value) {\n    checkReadOnly(false);\n    if (length == 0) {\n        // Implicit state check\n        checkValidState();\n    } else if (length < FILL_NATIVE_THRESHOLD) {\n        // 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n\n        // Handle smaller segments directly without transitioning to native code\n        final long u = Byte.toUnsignedLong(value);\n        final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n\n        int offset = 0;\n        // 0...0X...X000\n        final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n        for (; offset < limit; offset += 8) {\n            SCOPED_MEMORY_ACCESS.putLong(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, longValue);\n        }\n        int remaining = (int) length - limit;\n        // 0...0X00\n        if (remaining >= 4) {\n            SCOPED_MEMORY_ACCESS.putInt(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (int) longValue);\n            offset += 4;\n            remaining -= 4;\n        }\n        // 0...00X0\n        if (remaining >= 2) {\n            SCOPED_MEMORY_ACCESS.putShort(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (short) longValue);\n            offset += 2;\n            remaining -= 2;\n        }\n        // 0...000X\n        if (remaining == 1) {\n            SCOPED_MEMORY_ACCESS.putByte(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, value);\n        }\n        // We have now fully handled 0...0X...XXXX\n    } else {\n        // Handle larger segments via native calls\n        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n    }\n    return this;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/7a418fc07464fe359a0b45b6d797c65c573770cb", "code_v0_no_empty_lines": "MemorySegment::fill方法对所有大小的内存段都直接调用原生setMemory方法，对于小内存段存在不必要的原生调用开销。", "code_v1_no_empty_lines": "@Override\n@ForceInline\npublic final MemorySegment fill(byte value) {\n    checkReadOnly(false);\n    if (length == 0) {\n        // Implicit state check\n        checkValidState();\n    } else if (length < FILL_NATIVE_THRESHOLD) {\n        // 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n\n        // Handle smaller segments directly without transitioning to native code\n        final long u = Byte.toUnsignedLong(value);\n        final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n\n        int offset = 0;\n        // 0...0X...X000\n        final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n        for (; offset < limit; offset += 8) {\n            SCOPED_MEMORY_ACCESS.putLong(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, longValue);\n        }\n        int remaining = (int) length - limit;\n        // 0...0X00\n        if (remaining >= 4) {\n            SCOPED_MEMORY_ACCESS.putInt(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (int) longValue);\n            offset += 4;\n            remaining -= 4;\n        }\n        // 0...00X0\n        if (remaining >= 2) {\n            SCOPED_MEMORY_ACCESS.putShort(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (short) longValue);\n            offset += 2;\n            remaining -= 2;\n        }\n        // 0...000X\n        if (remaining == 1) {\n            SCOPED_MEMORY_ACCESS.putByte(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, value);\n        }\n        // We have now fully handled 0...0X...XXXX\n    } else {\n        // Handle larger segments via native calls\n        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n    }\n    return this;\n}", "target": "@Override\n@ForceInline\npublic final MemorySegment fill(byte value) {\n    checkReadOnly(false);\n    if (length == 0) {\n        // Implicit state check\n        checkValidState();\n    } else if (length < FILL_NATIVE_THRESHOLD) {\n        // 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n\n        // Handle smaller segments directly without transitioning to native code\n        final long u = Byte.toUnsignedLong(value);\n        final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n\n        int offset = 0;\n        // 0...0X...X000\n        final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n        for (; offset < limit; offset += 8) {\n            SCOPED_MEMORY_ACCESS.putLong(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, longValue);\n        }\n        int remaining = (int) length - limit;\n        // 0...0X00\n        if (remaining >= 4) {\n            SCOPED_MEMORY_ACCESS.putInt(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (int) longValue);\n            offset += 4;\n            remaining -= 4;\n        }\n        // 0...00X0\n        if (remaining >= 2) {\n            SCOPED_MEMORY_ACCESS.putShort(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (short) longValue);\n            offset += 2;\n            remaining -= 2;\n        }\n        // 0...000X\n        if (remaining == 1) {\n            SCOPED_MEMORY_ACCESS.putByte(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, value);\n        }\n        // We have now fully handled 0...0X...XXXX\n    } else {\n        // Handle larger segments via native calls\n        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n    }\n    return this;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：MemorySegment::fill方法对所有大小的内存段都直接调用原生setMemory方法，对于小内存段存在不必要的原生调用开销。优化后：引入FILL_NATIVE_THRESHOLD阈值（AArch64为1024字节，其他架构为32字节），对于小于阈值的小内存段，使用Java层面的批量写入优化（先按8字节写入，再处理4字节、2字节、1字节的剩余部分），避免原生调用开销；对于大内存段仍使用原生setMemory方法。优化思路：通过减少小内存段操作时的上下文切换开销，提升fill操作的性能，同时保持大内存段的高效原生操作。"}
{"id": 785, "source": "riscv-dataset-excel", "optimization_type": "向量化优化+条件检查优化", "optimization_description": "优化前：每次调用verify_sve_vector_length都会无条件检查UseSVE标志，即使硬件只支持128位SVE向量长度（最小值）时仍需执行完整验证。优化后：添加提前返回条件，当SVE未启用或硬件最大支持向量长度等于最小值（128位）时跳过验证。优化思路：对于只支持128位SVE向量长度的硬件，向量长度不会在native调用中被改变，因此可以安全跳过验证开销，减少不必要的运行时检查。", "original_code": "每次调用verify_sve_vector_length都会无条件检查UseSVE标志，即使硬件只支持128位SVE向量长度（最小值）时仍需执行完整验证。", "optimized_code": "void MacroAssembler::verify_sve_vector_length(Register tmp) {\n+  if (!UseSVE || VM_Version::get_max_supported_sve_vector_length() == FloatRegister::sve_vl_min) {\n+    return;\n+  }\n   // Make sure that native code does not change SVE vector length.\n-  if (!UseSVE) return;\n   Label verify_ok;\n   movw(tmp, zr);\n   sve_inc(tmp, B);", "source_url": "https://github.com/openjdk/riscv-port/commit/0e6bb514c8ec7c4a7100fe06eaa9e954a74fda30", "code_v0_no_empty_lines": "每次调用verify_sve_vector_length都会无条件检查UseSVE标志，即使硬件只支持128位SVE向量长度（最小值）时仍需执行完整验证。", "code_v1_no_empty_lines": "void MacroAssembler::verify_sve_vector_length(Register tmp) {\n+  if (!UseSVE || VM_Version::get_max_supported_sve_vector_length() == FloatRegister::sve_vl_min) {\n+    return;\n+  }\n   // Make sure that native code does not change SVE vector length.\n-  if (!UseSVE) return;\n   Label verify_ok;\n   movw(tmp, zr);\n   sve_inc(tmp, B);", "target": "void MacroAssembler::verify_sve_vector_length(Register tmp) {\n+  if (!UseSVE || VM_Version::get_max_supported_sve_vector_length() == FloatRegister::sve_vl_min) {\n+    return;\n+  }\n   // Make sure that native code does not change SVE vector length.\n-  if (!UseSVE) return;\n   Label verify_ok;\n   movw(tmp, zr);\n   sve_inc(tmp, B);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次调用verify_sve_vector_length都会无条件检查UseSVE标志，即使硬件只支持128位SVE向量长度（最小值）时仍需执行完整验证。优化后：添加提前返回条件，当SVE未启用或硬件最大支持向量长度等于最小值（128位）时跳过验证。优化思路：对于只支持128位SVE向量长度的硬件，向量长度不会在native调用中被改变，因此可以安全跳过验证开销，减少不必要的运行时检查。"}
{"id": 786, "source": "riscv-dataset-excel", "optimization_type": "指令优化+代码生成优化", "optimization_description": "优化前：far_jump和far_call使用la指令加载目标地址，call指令间接调用，需要两条指令且la可能生成多条指令。优化后：显式使用auipc指令计算PC相对地址，配合jr/jalr实现跳转/调用，利用RISC-V的PC相对寻址特性，减少指令数量，提高代码密度和性能。思路：基于代码缓存不超过2GB的假设，将绝对地址访问转换为PC相对访问，避免la指令可能的多指令展开，生成更紧凑的代码序列。", "original_code": "far_jump和far_call使用la指令加载目标地址，call指令间接调用，需要两条指令且la可能生成多条指令。", "optimized_code": "-    int32_t offset;\n-    la(tmp, entry.target(), offset);\n+    int64_t distance = entry.target() - pc();\n+    int32_t offset = ((int32_t)distance << 20) >> 20;\n+    assert(is_valid_32bit_offset(distance), \"Far jump using wrong instructions.\");\n+    auipc(tmp, (int32_t)distance + 0x800);\n-    call(entry.target(), tmp);\n+    int64_t distance = entry.target() - pc();\n+    int32_t offset = ((int32_t)distance << 20) >> 20;\n+    assert(is_valid_32bit_offset(distance), \"Far call using wrong instructions.\");\n+    auipc(tmp, (int32_t)distance + 0x800);\n+    jalr(tmp, offset);", "source_url": "https://github.com/openjdk/riscv-port/commit/dc4fd896289db1d2f6f7bbf5795fec533448a48c", "code_v0_no_empty_lines": "far_jump和far_call使用la指令加载目标地址，call指令间接调用，需要两条指令且la可能生成多条指令。", "code_v1_no_empty_lines": "-    int32_t offset;\n-    la(tmp, entry.target(), offset);\n+    int64_t distance = entry.target() - pc();\n+    int32_t offset = ((int32_t)distance << 20) >> 20;\n+    assert(is_valid_32bit_offset(distance), \"Far jump using wrong instructions.\");\n+    auipc(tmp, (int32_t)distance + 0x800);\n-    call(entry.target(), tmp);\n+    int64_t distance = entry.target() - pc();\n+    int32_t offset = ((int32_t)distance << 20) >> 20;\n+    assert(is_valid_32bit_offset(distance), \"Far call using wrong instructions.\");\n+    auipc(tmp, (int32_t)distance + 0x800);\n+    jalr(tmp, offset);", "target": "-    int32_t offset;\n-    la(tmp, entry.target(), offset);\n+    int64_t distance = entry.target() - pc();\n+    int32_t offset = ((int32_t)distance << 20) >> 20;\n+    assert(is_valid_32bit_offset(distance), \"Far jump using wrong instructions.\");\n+    auipc(tmp, (int32_t)distance + 0x800);\n-    call(entry.target(), tmp);\n+    int64_t distance = entry.target() - pc();\n+    int32_t offset = ((int32_t)distance << 20) >> 20;\n+    assert(is_valid_32bit_offset(distance), \"Far call using wrong instructions.\");\n+    auipc(tmp, (int32_t)distance + 0x800);\n+    jalr(tmp, offset);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：far_jump和far_call使用la指令加载目标地址，call指令间接调用，需要两条指令且la可能生成多条指令。优化后：显式使用auipc指令计算PC相对地址，配合jr/jalr实现跳转/调用，利用RISC-V的PC相对寻址特性，减少指令数量，提高代码密度和性能。思路：基于代码缓存不超过2GB的假设，将绝对地址访问转换为PC相对访问，避免la指令可能的多指令展开，生成更紧凑的代码序列。"}
{"id": 787, "source": "riscv-dataset-excel", "optimization_type": "代码重构+性能优化", "optimization_description": "优化前：loadOpcode和storeOpcode方法使用嵌套switch语句直接处理所有类型和槽位的组合，代码重复且可读性差。优化后：重构为模块化设计，将每种类型的加载/存储逻辑提取到独立的辅助方法（如aload、fload、astore等），然后在主方法中调用这些辅助方法。优化思路：通过代码重构提高可维护性和可读性，同时可能带来微小的性能提升（减少重复代码，提高JIT内联机会），并支持更好的代码复用。", "original_code": "loadOpcode和storeOpcode方法使用嵌套switch语句直接处理所有类型和槽位的组合，代码重复且可读性差。", "optimized_code": "public static Opcode loadOpcode(TypeKind tk, int slot) {\n    return switch (tk) {\n        case INT, SHORT, BYTE, CHAR, BOOLEAN\n                           -> iload(slot);\n        case LONG      -> lload(slot);\n        case DOUBLE    -> dload(slot);\n        case FLOAT     -> fload(slot);\n        case REFERENCE -> aload(slot);\n        case VOID      -> throw new IllegalArgumentException(\"void\");\n    };\n}\n\npublic static Opcode aload(int slot) {\n    return switch (slot) {\n        case 0 -> Opcode.ALOAD_0;\n        case 1 -> Opcode.ALOAD_1;\n        case 2 -> Opcode.ALOAD_2;\n        case 3 -> Opcode.ALOAD_3;\n        default -> (slot < 256) ? Opcode.ALOAD : Opcode.ALOAD_W;\n    };\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/b94c3debf5083dbf5bc21ed7794c1656743ab48e", "code_v0_no_empty_lines": "loadOpcode和storeOpcode方法使用嵌套switch语句直接处理所有类型和槽位的组合，代码重复且可读性差。", "code_v1_no_empty_lines": "public static Opcode loadOpcode(TypeKind tk, int slot) {\n    return switch (tk) {\n        case INT, SHORT, BYTE, CHAR, BOOLEAN\n                           -> iload(slot);\n        case LONG      -> lload(slot);\n        case DOUBLE    -> dload(slot);\n        case FLOAT     -> fload(slot);\n        case REFERENCE -> aload(slot);\n        case VOID      -> throw new IllegalArgumentException(\"void\");\n    };\n}\n\npublic static Opcode aload(int slot) {\n    return switch (slot) {\n        case 0 -> Opcode.ALOAD_0;\n        case 1 -> Opcode.ALOAD_1;\n        case 2 -> Opcode.ALOAD_2;\n        case 3 -> Opcode.ALOAD_3;\n        default -> (slot < 256) ? Opcode.ALOAD : Opcode.ALOAD_W;\n    };\n}", "target": "public static Opcode loadOpcode(TypeKind tk, int slot) {\n    return switch (tk) {\n        case INT, SHORT, BYTE, CHAR, BOOLEAN\n                           -> iload(slot);\n        case LONG      -> lload(slot);\n        case DOUBLE    -> dload(slot);\n        case FLOAT     -> fload(slot);\n        case REFERENCE -> aload(slot);\n        case VOID      -> throw new IllegalArgumentException(\"void\");\n    };\n}\n\npublic static Opcode aload(int slot) {\n    return switch (slot) {\n        case 0 -> Opcode.ALOAD_0;\n        case 1 -> Opcode.ALOAD_1;\n        case 2 -> Opcode.ALOAD_2;\n        case 3 -> Opcode.ALOAD_3;\n        default -> (slot < 256) ? Opcode.ALOAD : Opcode.ALOAD_W;\n    };\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：loadOpcode和storeOpcode方法使用嵌套switch语句直接处理所有类型和槽位的组合，代码重复且可读性差。优化后：重构为模块化设计，将每种类型的加载/存储逻辑提取到独立的辅助方法（如aload、fload、astore等），然后在主方法中调用这些辅助方法。优化思路：通过代码重构提高可维护性和可读性，同时可能带来微小的性能提升（减少重复代码，提高JIT内联机会），并支持更好的代码复用。"}
{"id": 788, "source": "riscv-dataset-excel", "optimization_type": "循环优化+代码简化", "optimization_description": "优化前：在创建pre/post/main循环时，cast_incr_before_loop()函数会插入CastII节点来维护依赖关系，但这会阻碍类型传播并增加编译复杂度。优化后：完全移除cast_incr_before_loop()函数及其调用，直接使用原始induction变量值，简化了copy_assertion_predicates_to_post_loop()函数签名。优化思路：消除不必要的CastII节点插入，让类型系统能更直接地传播induction变量的类型信息，减少编译开销并可能改善后续优化效果。", "original_code": "在创建pre/post/main循环时，cast_incr_before_loop()函数会插入CastII节点来维护依赖关系，但这会阻碍类型传播并增加编译复杂度。", "optimized_code": "-Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {\n-  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n-  register_new_node(castii, ctrl);\n-  for (DUIterator_Fast imax, i = incr->fast_outs(imax); i < imax; i++) {\n-    Node* n = incr->fast_out(i);\n-    if (n->is_Phi() && n->in(0) == loop) {\n-      int nrep = n->replace_edge(incr, castii, &_igvn);\n-      return castii;\n-    }\n-  }\n-  return nullptr;\n-}\n\n-  // CastII for the main loop:\n-  Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);\n-  assert(castii != nullptr, \"no castII inserted\");\n  assert(post_head->in(1)->is_IfProj(), \"must be zero-trip guard If node projection of the post loop\");\n-  copy_assertion_predicates_to_main_loop(pre_head, castii, stride, outer_loop, outer_main_head, dd_main_head,\n+  copy_assertion_predicates_to_main_loop(pre_head, pre_incr, stride, outer_loop, outer_main_head, dd_main_head,\n                                          idx_before_pre_post, idx_after_post_before_pre, min_taken, post_head->in(1),\n                                          old_new);\n-  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, post_incr, stride);\n+  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, stride);", "source_url": "https://github.com/openjdk/riscv-port/commit/3a88fd437dfb218df5d3338c8ee7d70416839cf8", "code_v0_no_empty_lines": "在创建pre/post/main循环时，cast_incr_before_loop()函数会插入CastII节点来维护依赖关系，但这会阻碍类型传播并增加编译复杂度。", "code_v1_no_empty_lines": "-Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {\n-  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n-  register_new_node(castii, ctrl);\n-  for (DUIterator_Fast imax, i = incr->fast_outs(imax); i < imax; i++) {\n-    Node* n = incr->fast_out(i);\n-    if (n->is_Phi() && n->in(0) == loop) {\n-      int nrep = n->replace_edge(incr, castii, &_igvn);\n-      return castii;\n-    }\n-  }\n-  return nullptr;\n-}\n\n-  // CastII for the main loop:\n-  Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);\n-  assert(castii != nullptr, \"no castII inserted\");\n  assert(post_head->in(1)->is_IfProj(), \"must be zero-trip guard If node projection of the post loop\");\n-  copy_assertion_predicates_to_main_loop(pre_head, castii, stride, outer_loop, outer_main_head, dd_main_head,\n+  copy_assertion_predicates_to_main_loop(pre_head, pre_incr, stride, outer_loop, outer_main_head, dd_main_head,\n                                          idx_before_pre_post, idx_after_post_before_pre, min_taken, post_head->in(1),\n                                          old_new);\n-  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, post_incr, stride);\n+  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, stride);", "target": "-Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {\n-  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n-  register_new_node(castii, ctrl);\n-  for (DUIterator_Fast imax, i = incr->fast_outs(imax); i < imax; i++) {\n-    Node* n = incr->fast_out(i);\n-    if (n->is_Phi() && n->in(0) == loop) {\n-      int nrep = n->replace_edge(incr, castii, &_igvn);\n-      return castii;\n-    }\n-  }\n-  return nullptr;\n-}\n\n-  // CastII for the main loop:\n-  Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);\n-  assert(castii != nullptr, \"no castII inserted\");\n  assert(post_head->in(1)->is_IfProj(), \"must be zero-trip guard If node projection of the post loop\");\n-  copy_assertion_predicates_to_main_loop(pre_head, castii, stride, outer_loop, outer_main_head, dd_main_head,\n+  copy_assertion_predicates_to_main_loop(pre_head, pre_incr, stride, outer_loop, outer_main_head, dd_main_head,\n                                          idx_before_pre_post, idx_after_post_before_pre, min_taken, post_head->in(1),\n                                          old_new);\n-  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, post_incr, stride);\n+  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, stride);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在创建pre/post/main循环时，cast_incr_before_loop()函数会插入CastII节点来维护依赖关系，但这会阻碍类型传播并增加编译复杂度。优化后：完全移除cast_incr_before_loop()函数及其调用，直接使用原始induction变量值，简化了copy_assertion_predicates_to_post_loop()函数签名。优化思路：消除不必要的CastII节点插入，让类型系统能更直接地传播induction变量的类型信息，减少编译开销并可能改善后续优化效果。"}
{"id": 789, "source": "riscv-dataset-excel", "optimization_type": "并行GC性能优化+内存管理优化", "optimization_description": "优化前：大对象数组在并行GC疏散期间使用简单的数组分块机制，通过修改源数组长度来跟踪处理进度，存在同步开销和内存访问模式问题。优化后：引入PartialArrayState和PartialArrayTaskStepper来管理数组分块状态，使用专门的分配器管理状态对象，通过步进器控制分块逻辑，减少同步竞争。优化思路：将数组分块状态管理与实际数组对象解耦，使用更高效的状态跟踪机制，提高并行GC处理大对象数组时的吞吐量和可扩展性。", "original_code": "大对象数组在并行GC疏散期间使用简单的数组分块机制，通过修改源数组长度来跟踪处理进度，存在同步开销和内存访问模式问题。", "optimized_code": "- void PSPromotionManager::process_array_chunk(PartialArrayScanTask task) {\n+ void PSPromotionManager::process_array_chunk(PartialArrayState* state) {\n-   oop old = task.to_source_array();\n-   assert(old->is_objArray(), \"invariant\");\n-   assert(old->is_forwarded(), \"invariant\");\n-   oop const obj = old->forwardee();\n-   int start;\n-   int const end = arrayOop(old)->length();\n-   if (end > (int) _min_array_size_for_chunking) {\n-     start = end - _array_chunk_size;\n-     assert(start > 0, \"invariant\");\n-     arrayOop(old)->set_length(start);\n-     push_depth(ScannerTask(PartialArrayScanTask(old)));\n-     TASKQUEUE_STATS_ONLY(++_array_chunk_pushes);\n-   } else {\n-     start = 0;\n-     int const actual_length = arrayOop(obj)->length();\n-     arrayOop(old)->set_length(actual_length);\n-   }\n+   PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n+   if (step._ncreate > 0) {\n+     state->add_references(step._ncreate);\n+     for (uint i = 0; i < step._ncreate; ++i) {\n+       push_depth(ScannerTask(state));\n+     }\n+     TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n+   }\n+   int start = checked_cast<int>(step._index);\n+   int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n+   assert(start < end, \"invariant\");", "source_url": "https://github.com/openjdk/riscv-port/commit/4f071ce074b934d5610e213d348cff8326f1499d", "code_v0_no_empty_lines": "大对象数组在并行GC疏散期间使用简单的数组分块机制，通过修改源数组长度来跟踪处理进度，存在同步开销和内存访问模式问题。", "code_v1_no_empty_lines": "- void PSPromotionManager::process_array_chunk(PartialArrayScanTask task) {\n+ void PSPromotionManager::process_array_chunk(PartialArrayState* state) {\n-   oop old = task.to_source_array();\n-   assert(old->is_objArray(), \"invariant\");\n-   assert(old->is_forwarded(), \"invariant\");\n-   oop const obj = old->forwardee();\n-   int start;\n-   int const end = arrayOop(old)->length();\n-   if (end > (int) _min_array_size_for_chunking) {\n-     start = end - _array_chunk_size;\n-     assert(start > 0, \"invariant\");\n-     arrayOop(old)->set_length(start);\n-     push_depth(ScannerTask(PartialArrayScanTask(old)));\n-     TASKQUEUE_STATS_ONLY(++_array_chunk_pushes);\n-   } else {\n-     start = 0;\n-     int const actual_length = arrayOop(obj)->length();\n-     arrayOop(old)->set_length(actual_length);\n-   }\n+   PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n+   if (step._ncreate > 0) {\n+     state->add_references(step._ncreate);\n+     for (uint i = 0; i < step._ncreate; ++i) {\n+       push_depth(ScannerTask(state));\n+     }\n+     TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n+   }\n+   int start = checked_cast<int>(step._index);\n+   int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n+   assert(start < end, \"invariant\");", "target": "- void PSPromotionManager::process_array_chunk(PartialArrayScanTask task) {\n+ void PSPromotionManager::process_array_chunk(PartialArrayState* state) {\n-   oop old = task.to_source_array();\n-   assert(old->is_objArray(), \"invariant\");\n-   assert(old->is_forwarded(), \"invariant\");\n-   oop const obj = old->forwardee();\n-   int start;\n-   int const end = arrayOop(old)->length();\n-   if (end > (int) _min_array_size_for_chunking) {\n-     start = end - _array_chunk_size;\n-     assert(start > 0, \"invariant\");\n-     arrayOop(old)->set_length(start);\n-     push_depth(ScannerTask(PartialArrayScanTask(old)));\n-     TASKQUEUE_STATS_ONLY(++_array_chunk_pushes);\n-   } else {\n-     start = 0;\n-     int const actual_length = arrayOop(obj)->length();\n-     arrayOop(old)->set_length(actual_length);\n-   }\n+   PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n+   if (step._ncreate > 0) {\n+     state->add_references(step._ncreate);\n+     for (uint i = 0; i < step._ncreate; ++i) {\n+       push_depth(ScannerTask(state));\n+     }\n+     TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n+   }\n+   int start = checked_cast<int>(step._index);\n+   int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n+   assert(start < end, \"invariant\");", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：大对象数组在并行GC疏散期间使用简单的数组分块机制，通过修改源数组长度来跟踪处理进度，存在同步开销和内存访问模式问题。优化后：引入PartialArrayState和PartialArrayTaskStepper来管理数组分块状态，使用专门的分配器管理状态对象，通过步进器控制分块逻辑，减少同步竞争。优化思路：将数组分块状态管理与实际数组对象解耦，使用更高效的状态跟踪机制，提高并行GC处理大对象数组时的吞吐量和可扩展性。"}
{"id": 790, "source": "riscv-dataset-excel", "optimization_type": "内存优化+性能优化", "optimization_description": "优化前：DirectCodeBuilder在写入字节码时需要为每个指令分配Instruction对象，导致内存分配开销。优化后：通过重构DirectCodeBuilder，使其能够直接写入字节码而不创建中间指令对象，减少内存分配和垃圾回收压力。关键修改包括：1) 在loadConstant方法中添加Number类型检查，优化常量加载路径；2) 简化ldc方法，使用BytecodeHelpers.ldcOpcode统一处理操作码选择；3) 移除AbstractInstruction中不必要的writeTo方法；4) 重构BytecodeHelpers中的验证方法，提高代码清晰度。整体思路是通过避免对象分配来提升字节码生成性能。", "original_code": "DirectCodeBuilder在写入字节码时需要为每个指令分配Instruction对象，导致内存分配开销。", "optimized_code": "- return with(ConstantInstruction.ofLoad(\n                entry.typeKind().slotSize() == 2 ? Opcode.LDC2_W\n                : entry.index() > 0xff ? Opcode.LDC_W\n                : Opcode.LDC, entry));\n+ return with(ConstantInstruction.ofLoad(BytecodeHelpers.ldcOpcode(entry), entry));", "source_url": "https://github.com/openjdk/riscv-port/commit/777ed2b5d2ef8371407cc9bf0370a7cef937cfb7", "code_v0_no_empty_lines": "DirectCodeBuilder在写入字节码时需要为每个指令分配Instruction对象，导致内存分配开销。", "code_v1_no_empty_lines": "- return with(ConstantInstruction.ofLoad(\n                entry.typeKind().slotSize() == 2 ? Opcode.LDC2_W\n                : entry.index() > 0xff ? Opcode.LDC_W\n                : Opcode.LDC, entry));\n+ return with(ConstantInstruction.ofLoad(BytecodeHelpers.ldcOpcode(entry), entry));", "target": "- return with(ConstantInstruction.ofLoad(\n                entry.typeKind().slotSize() == 2 ? Opcode.LDC2_W\n                : entry.index() > 0xff ? Opcode.LDC_W\n                : Opcode.LDC, entry));\n+ return with(ConstantInstruction.ofLoad(BytecodeHelpers.ldcOpcode(entry), entry));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：DirectCodeBuilder在写入字节码时需要为每个指令分配Instruction对象，导致内存分配开销。优化后：通过重构DirectCodeBuilder，使其能够直接写入字节码而不创建中间指令对象，减少内存分配和垃圾回收压力。关键修改包括：1) 在loadConstant方法中添加Number类型检查，优化常量加载路径；2) 简化ldc方法，使用BytecodeHelpers.ldcOpcode统一处理操作码选择；3) 移除AbstractInstruction中不必要的writeTo方法；4) 重构BytecodeHelpers中的验证方法，提高代码清晰度。整体思路是通过避免对象分配来提升字节码生成性能。"}
{"id": 791, "source": "riscv-dataset-excel", "optimization_type": "性能优化+内联优化", "optimization_description": "优化前：writeU1/U2/Int/Long方法都调用通用的writeIntBytes方法，该方法包含循环和条件判断，导致额外的函数调用开销和分支预测开销。优化后：将writeIntBytes的逻辑内联到各个具体方法中，直接进行字节操作，消除了函数调用开销，并简化了reserveSpace方法的实现（将扩容逻辑提取到单独的grow方法）。优化思路：通过内联优化减少函数调用开销，直接操作字节数组提高性能，同时重构reserveSpace方法使其更清晰。", "original_code": "writeU1/U2/Int/Long方法都调用通用的writeIntBytes方法，该方法包含循环和条件判断，导致额外的函数调用开销和分支预测开销。", "optimized_code": "-    public void writeU1(int x) {\n-        writeIntBytes(1, x);\n+    public void writeU1(int x) {\n+        reserveSpace(1);\n+        elems[offset++] = (byte) x;\n     }\n \n     @Override\n     public void writeU2(int x) {\n-        writeIntBytes(2, x);\n+        reserveSpace(2);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 8);\n+        elems[offset + 1] = (byte) x;\n+        this.offset = offset + 2;\n     }\n \n     @Override\n     public void writeInt(int x) {\n-        writeIntBytes(4, x);\n+        reserveSpace(4);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 24);\n+        elems[offset + 1] = (byte) (x >> 16);\n+        elems[offset + 2] = (byte) (x >> 8);\n+        elems[offset + 3] = (byte)  x;\n+        this.offset = offset + 4;\n     }\n \n     @Override\n     public void writeLong(long x) {\n-        writeIntBytes(8, x);\n+        reserveSpace(8);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 56);\n+        elems[offset + 1] = (byte) (x >> 48);\n+        elems[offset + 2] = (byte) (x >> 40);\n+        elems[offset + 3] = (byte) (x >> 32);\n+        elems[offset + 4] = (byte) (x >> 24);\n+        elems[offset + 5] = (byte) (x >> 16);\n+        elems[offset + 6] = (byte) (x >> 8);\n+        elems[offset + 7] = (byte)  x;\n+        this.offset = offset + 8;\n     }", "source_url": "https://github.com/openjdk/riscv-port/commit/b711c41d442fc369a84745c0203db638e0b7e671", "code_v0_no_empty_lines": "writeU1/U2/Int/Long方法都调用通用的writeIntBytes方法，该方法包含循环和条件判断，导致额外的函数调用开销和分支预测开销。", "code_v1_no_empty_lines": "-    public void writeU1(int x) {\n-        writeIntBytes(1, x);\n+    public void writeU1(int x) {\n+        reserveSpace(1);\n+        elems[offset++] = (byte) x;\n     }\n \n     @Override\n     public void writeU2(int x) {\n-        writeIntBytes(2, x);\n+        reserveSpace(2);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 8);\n+        elems[offset + 1] = (byte) x;\n+        this.offset = offset + 2;\n     }\n \n     @Override\n     public void writeInt(int x) {\n-        writeIntBytes(4, x);\n+        reserveSpace(4);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 24);\n+        elems[offset + 1] = (byte) (x >> 16);\n+        elems[offset + 2] = (byte) (x >> 8);\n+        elems[offset + 3] = (byte)  x;\n+        this.offset = offset + 4;\n     }\n \n     @Override\n     public void writeLong(long x) {\n-        writeIntBytes(8, x);\n+        reserveSpace(8);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 56);\n+        elems[offset + 1] = (byte) (x >> 48);\n+        elems[offset + 2] = (byte) (x >> 40);\n+        elems[offset + 3] = (byte) (x >> 32);\n+        elems[offset + 4] = (byte) (x >> 24);\n+        elems[offset + 5] = (byte) (x >> 16);\n+        elems[offset + 6] = (byte) (x >> 8);\n+        elems[offset + 7] = (byte)  x;\n+        this.offset = offset + 8;\n     }", "target": "-    public void writeU1(int x) {\n-        writeIntBytes(1, x);\n+    public void writeU1(int x) {\n+        reserveSpace(1);\n+        elems[offset++] = (byte) x;\n     }\n \n     @Override\n     public void writeU2(int x) {\n-        writeIntBytes(2, x);\n+        reserveSpace(2);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 8);\n+        elems[offset + 1] = (byte) x;\n+        this.offset = offset + 2;\n     }\n \n     @Override\n     public void writeInt(int x) {\n-        writeIntBytes(4, x);\n+        reserveSpace(4);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 24);\n+        elems[offset + 1] = (byte) (x >> 16);\n+        elems[offset + 2] = (byte) (x >> 8);\n+        elems[offset + 3] = (byte)  x;\n+        this.offset = offset + 4;\n     }\n \n     @Override\n     public void writeLong(long x) {\n-        writeIntBytes(8, x);\n+        reserveSpace(8);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 56);\n+        elems[offset + 1] = (byte) (x >> 48);\n+        elems[offset + 2] = (byte) (x >> 40);\n+        elems[offset + 3] = (byte) (x >> 32);\n+        elems[offset + 4] = (byte) (x >> 24);\n+        elems[offset + 5] = (byte) (x >> 16);\n+        elems[offset + 6] = (byte) (x >> 8);\n+        elems[offset + 7] = (byte)  x;\n+        this.offset = offset + 8;\n     }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：writeU1/U2/Int/Long方法都调用通用的writeIntBytes方法，该方法包含循环和条件判断，导致额外的函数调用开销和分支预测开销。优化后：将writeIntBytes的逻辑内联到各个具体方法中，直接进行字节操作，消除了函数调用开销，并简化了reserveSpace方法的实现（将扩容逻辑提取到单独的grow方法）。优化思路：通过内联优化减少函数调用开销，直接操作字节数组提高性能，同时重构reserveSpace方法使其更清晰。"}
{"id": 792, "source": "riscv-dataset-excel", "optimization_type": "并发竞态条件修复", "optimization_description": "优化前：使用AtomicReference存储pending subscription，当多个线程同时调用subscribe时，后一个会覆盖前一个，导致前一个subscription被丢弃，可能触发CleanupTrigger清理连接池中的连接，造成连接意外关闭。优化后：改用ConcurrentLinkedQueue存储pending subscriptions，确保所有subscription都能被正确处理；在CleanupTrigger中添加dropped标志和dropSubscription方法，防止清理操作在连接已不再使用时被触发。思路：修复HTTP/1.1连接池中CleanupTrigger可能在新exchange开始后被触发的竞态条件，避免连接被错误清理。", "original_code": "使用AtomicReference存储pending subscription，当多个线程同时调用subscribe时，后一个会覆盖前一个，导致前一个subscription被丢弃，可能触发CleanupTrigger清理连接池中的连接，造成连接意外关闭。", "optimized_code": "- AtomicReference<ReadSubscription> pendingSubscription = new AtomicReference<>();\n+ ConcurrentLinkedQueue<ReadSubscription> pendingSubscriptions = new ConcurrentLinkedQueue<>();\n- ReadSubscription previous = pendingSubscription.getAndSet(target);\n+ ReadSubscription previous;\n+ while ((previous = pendingSubscriptions.poll()) != null) {\n+ void dropSubscription() {\n+     dropped = true;\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/723588a4e78d25f0ef3c4cdaeb377aedc3a352d4", "code_v0_no_empty_lines": "使用AtomicReference存储pending subscription，当多个线程同时调用subscribe时，后一个会覆盖前一个，导致前一个subscription被丢弃，可能触发CleanupTrigger清理连接池中的连接，造成连接意外关闭。", "code_v1_no_empty_lines": "- AtomicReference<ReadSubscription> pendingSubscription = new AtomicReference<>();\n+ ConcurrentLinkedQueue<ReadSubscription> pendingSubscriptions = new ConcurrentLinkedQueue<>();\n- ReadSubscription previous = pendingSubscription.getAndSet(target);\n+ ReadSubscription previous;\n+ while ((previous = pendingSubscriptions.poll()) != null) {\n+ void dropSubscription() {\n+     dropped = true;\n+ }", "target": "- AtomicReference<ReadSubscription> pendingSubscription = new AtomicReference<>();\n+ ConcurrentLinkedQueue<ReadSubscription> pendingSubscriptions = new ConcurrentLinkedQueue<>();\n- ReadSubscription previous = pendingSubscription.getAndSet(target);\n+ ReadSubscription previous;\n+ while ((previous = pendingSubscriptions.poll()) != null) {\n+ void dropSubscription() {\n+     dropped = true;\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用AtomicReference存储pending subscription，当多个线程同时调用subscribe时，后一个会覆盖前一个，导致前一个subscription被丢弃，可能触发CleanupTrigger清理连接池中的连接，造成连接意外关闭。优化后：改用ConcurrentLinkedQueue存储pending subscriptions，确保所有subscription都能被正确处理；在CleanupTrigger中添加dropped标志和dropSubscription方法，防止清理操作在连接已不再使用时被触发。思路：修复HTTP/1.1连接池中CleanupTrigger可能在新exchange开始后被触发的竞态条件，避免连接被错误清理。"}
{"id": 793, "source": "riscv-dataset-excel", "optimization_type": "编译警告优化", "optimization_description": "优化前：GCC编译警告配置较为宽泛，使用通用的-unused参数禁用所有未使用警告，可能导致潜在代码问题被忽略。优化后：采用更细粒度的未使用警告控制，启用-Wunused-const-variable=1、-Wunused-result等具体警告，同时移除通用的-unused禁用，使编译器能更精确地检测未使用的常量变量、函数返回值等问题。优化思路：通过细化警告配置，提高代码质量检查的精确度，帮助开发者发现更多潜在问题，同时避免过度警告干扰。", "original_code": "GCC编译警告配置较为宽泛，使用通用的-unused参数禁用所有未使用警告，可能导致潜在代码问题被忽略。", "optimized_code": "- DISABLED_WARNINGS=\"unused-parameter unused\"\n+ DISABLED_WARNINGS=\"unused-parameter\"\n- WARNINGS_ENABLE_ADDITIONAL=\"-Wpointer-arith -Wsign-compare \\\n          -Wunused-function -Wundef -Wunused-value -Wreturn-type \\\n          -Wtrampolines\"\n+ WARNINGS_ENABLE_ADDITIONAL=\"-Wpointer-arith -Wreturn-type -Wsign-compare \\\n          -Wtrampolines -Wundef -Wunused-const-variable=1 -Wunused-function \\\n          -Wunused-result -Wunused-value\"", "source_url": "https://github.com/openjdk/riscv-port/commit/362f9ce077baa900ed81a0473ec0187efde132ef", "code_v0_no_empty_lines": "GCC编译警告配置较为宽泛，使用通用的-unused参数禁用所有未使用警告，可能导致潜在代码问题被忽略。", "code_v1_no_empty_lines": "- DISABLED_WARNINGS=\"unused-parameter unused\"\n+ DISABLED_WARNINGS=\"unused-parameter\"\n- WARNINGS_ENABLE_ADDITIONAL=\"-Wpointer-arith -Wsign-compare \\\n          -Wunused-function -Wundef -Wunused-value -Wreturn-type \\\n          -Wtrampolines\"\n+ WARNINGS_ENABLE_ADDITIONAL=\"-Wpointer-arith -Wreturn-type -Wsign-compare \\\n          -Wtrampolines -Wundef -Wunused-const-variable=1 -Wunused-function \\\n          -Wunused-result -Wunused-value\"", "target": "- DISABLED_WARNINGS=\"unused-parameter unused\"\n+ DISABLED_WARNINGS=\"unused-parameter\"\n- WARNINGS_ENABLE_ADDITIONAL=\"-Wpointer-arith -Wsign-compare \\\n          -Wunused-function -Wundef -Wunused-value -Wreturn-type \\\n          -Wtrampolines\"\n+ WARNINGS_ENABLE_ADDITIONAL=\"-Wpointer-arith -Wreturn-type -Wsign-compare \\\n          -Wtrampolines -Wundef -Wunused-const-variable=1 -Wunused-function \\\n          -Wunused-result -Wunused-value\"", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：GCC编译警告配置较为宽泛，使用通用的-unused参数禁用所有未使用警告，可能导致潜在代码问题被忽略。优化后：采用更细粒度的未使用警告控制，启用-Wunused-const-variable=1、-Wunused-result等具体警告，同时移除通用的-unused禁用，使编译器能更精确地检测未使用的常量变量、函数返回值等问题。优化思路：通过细化警告配置，提高代码质量检查的精确度，帮助开发者发现更多潜在问题，同时避免过度警告干扰。"}
{"id": 794, "source": "riscv-dataset-excel", "optimization_type": "内存优化+性能优化", "optimization_description": "优化前：使用泛型抽象类PrimitiveEntry<T>存储基本类型常量，导致装箱开销（Integer、Float等包装对象）和额外的类层次结构。优化后：移除PrimitiveEntry抽象类，让IntegerEntryImpl、FloatEntryImpl等直接继承AbstractPoolEntry，直接存储原始类型值（int、float等）。优化思路：消除装箱/拆箱开销，减少内存分配和对象头开销，提高常量池查找和访问性能，同时简化类结构。", "original_code": "使用泛型抽象类PrimitiveEntry<T>存储基本类型常量，导致装箱开销（Integer、Float等包装对象）和额外的类层次结构。", "optimized_code": "- abstract static sealed class PrimitiveEntry<T extends ConstantDesc>\n            extends AbstractPoolEntry {\n        protected final T val;\n\n        public PrimitiveEntry(ConstantPool constantPool, int tag, int index, T val) {\n            super(constantPool, tag, index, hash1(tag, val.hashCode()));\n            this.val = val;\n        }\n\n        public T value() {\n            return val;\n        }\n\n        public ConstantDesc constantValue() {\n            return value();\n        }\n\n        @Override\n        public String toString() {\n            return \"\" + tag() + value();\n        }\n    }\n\n    public static final class IntegerEntryImpl extends PrimitiveEntry<Integer>\n            implements IntegerEntry {\n\n        IntegerEntryImpl(ConstantPool cpm, int index, int i) {\n            super(cpm, ClassFile.TAG_INTEGER, index, i);\n        }\n\n        @Override\n        public int intValue() {\n            return value();\n        }\n    }\n\n+    public static final class IntegerEntryImpl extends AbstractPoolEntry implements IntegerEntry {\n+\n+        private final int val;\n+\n+        IntegerEntryImpl(ConstantPool cpm, int index, int i) {\n+            super(cpm, ClassFile.TAG_INTEGER, index, hash1(ClassFile.TAG_INTEGER, Integer.hashCode(i)));\n+            val = i;\n+        }\n+\n+        @Override\n+        public int intValue() {\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n+        }\n+    }", "source_url": "https://github.com/openjdk/riscv-port/commit/eff6d9cd23f9da8720a44ad628aa0a3e6f58facf", "code_v0_no_empty_lines": "使用泛型抽象类PrimitiveEntry<T>存储基本类型常量，导致装箱开销（Integer、Float等包装对象）和额外的类层次结构。", "code_v1_no_empty_lines": "- abstract static sealed class PrimitiveEntry<T extends ConstantDesc>\n            extends AbstractPoolEntry {\n        protected final T val;\n\n        public PrimitiveEntry(ConstantPool constantPool, int tag, int index, T val) {\n            super(constantPool, tag, index, hash1(tag, val.hashCode()));\n            this.val = val;\n        }\n\n        public T value() {\n            return val;\n        }\n\n        public ConstantDesc constantValue() {\n            return value();\n        }\n\n        @Override\n        public String toString() {\n            return \"\" + tag() + value();\n        }\n    }\n\n    public static final class IntegerEntryImpl extends PrimitiveEntry<Integer>\n            implements IntegerEntry {\n\n        IntegerEntryImpl(ConstantPool cpm, int index, int i) {\n            super(cpm, ClassFile.TAG_INTEGER, index, i);\n        }\n\n        @Override\n        public int intValue() {\n            return value();\n        }\n    }\n\n+    public static final class IntegerEntryImpl extends AbstractPoolEntry implements IntegerEntry {\n+\n+        private final int val;\n+\n+        IntegerEntryImpl(ConstantPool cpm, int index, int i) {\n+            super(cpm, ClassFile.TAG_INTEGER, index, hash1(ClassFile.TAG_INTEGER, Integer.hashCode(i)));\n+            val = i;\n+        }\n+\n+        @Override\n+        public int intValue() {\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n+        }\n+    }", "target": "- abstract static sealed class PrimitiveEntry<T extends ConstantDesc>\n            extends AbstractPoolEntry {\n        protected final T val;\n\n        public PrimitiveEntry(ConstantPool constantPool, int tag, int index, T val) {\n            super(constantPool, tag, index, hash1(tag, val.hashCode()));\n            this.val = val;\n        }\n\n        public T value() {\n            return val;\n        }\n\n        public ConstantDesc constantValue() {\n            return value();\n        }\n\n        @Override\n        public String toString() {\n            return \"\" + tag() + value();\n        }\n    }\n\n    public static final class IntegerEntryImpl extends PrimitiveEntry<Integer>\n            implements IntegerEntry {\n\n        IntegerEntryImpl(ConstantPool cpm, int index, int i) {\n            super(cpm, ClassFile.TAG_INTEGER, index, i);\n        }\n\n        @Override\n        public int intValue() {\n            return value();\n        }\n    }\n\n+    public static final class IntegerEntryImpl extends AbstractPoolEntry implements IntegerEntry {\n+\n+        private final int val;\n+\n+        IntegerEntryImpl(ConstantPool cpm, int index, int i) {\n+            super(cpm, ClassFile.TAG_INTEGER, index, hash1(ClassFile.TAG_INTEGER, Integer.hashCode(i)));\n+            val = i;\n+        }\n+\n+        @Override\n+        public int intValue() {\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n+        }\n+    }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用泛型抽象类PrimitiveEntry<T>存储基本类型常量，导致装箱开销（Integer、Float等包装对象）和额外的类层次结构。优化后：移除PrimitiveEntry抽象类，让IntegerEntryImpl、FloatEntryImpl等直接继承AbstractPoolEntry，直接存储原始类型值（int、float等）。优化思路：消除装箱/拆箱开销，减少内存分配和对象头开销，提高常量池查找和访问性能，同时简化类结构。"}
{"id": 795, "source": "riscv-dataset-excel", "optimization_type": "诊断优化", "optimization_description": "优化前：GCLocker在阻塞线程时缺乏详细的诊断信息，难以分析性能瓶颈和线程等待时间。优化后：新增GCLockerTimingDebugLogger类，在stall_until_clear()和jni_lock()方法中添加计时日志记录，精确测量线程被阻塞的时间并输出到GC日志。优化思路：通过添加细粒度的计时和日志功能，改善GCLocker停滞的诊断能力，帮助开发者识别和优化因JNI临界区导致的GC延迟问题。", "original_code": "GCLocker在阻塞线程时缺乏详细的诊断信息，难以分析性能瓶颈和线程等待时间。", "optimized_code": "+// GCLockerTimingDebugLogger tracks specific timing information for GC lock waits.\n+class GCLockerTimingDebugLogger : public StackObj {\n+  const char* _log_message;\n+  Ticks _start;\n+\n+public:\n+  GCLockerTimingDebugLogger(const char* log_message) : _log_message(log_message) {\n+    assert(_log_message != nullptr, \"GC locker debug message must be set.\");\n+    _start = Ticks::now();\n+  }\n+\n+  ~GCLockerTimingDebugLogger() {\n+    Log(gc, jni) log;\n+    if (log.is_debug()) {\n+      ResourceMark rm; // JavaThread::name() allocates to convert to UTF8\n+      const Tickspan elapsed_time = Ticks::now() - _start;\n+      log.debug(\"%s Resumed after \" UINT64_FORMAT \"ms. Thread \\\"%s\\\".\", _log_message, elapsed_time.milliseconds(), Thread::current()->name());\n+    }\n+  }\n+};\n\n void GCLocker::stall_until_clear() {\n   MonitorLocker ml(JNICritical_lock);\n   if (needs_gc()) {\n     GCLockerTracer::inc_stall_count();\n     log_debug_jni(\"Allocation failed. Thread stalled by JNI critical section.\");\n+    GCLockerTimingDebugLogger logger(\"Thread stalled by JNI critical section.\");\n     // Wait for _needs_gc to be cleared\n     while (needs_gc()) {\n       ml.wait();\n     }\n   }\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/284c3cde5e1b7115fb17c51f3ed17c1be95845bc", "code_v0_no_empty_lines": "GCLocker在阻塞线程时缺乏详细的诊断信息，难以分析性能瓶颈和线程等待时间。", "code_v1_no_empty_lines": "+// GCLockerTimingDebugLogger tracks specific timing information for GC lock waits.\n+class GCLockerTimingDebugLogger : public StackObj {\n+  const char* _log_message;\n+  Ticks _start;\n+\n+public:\n+  GCLockerTimingDebugLogger(const char* log_message) : _log_message(log_message) {\n+    assert(_log_message != nullptr, \"GC locker debug message must be set.\");\n+    _start = Ticks::now();\n+  }\n+\n+  ~GCLockerTimingDebugLogger() {\n+    Log(gc, jni) log;\n+    if (log.is_debug()) {\n+      ResourceMark rm; // JavaThread::name() allocates to convert to UTF8\n+      const Tickspan elapsed_time = Ticks::now() - _start;\n+      log.debug(\"%s Resumed after \" UINT64_FORMAT \"ms. Thread \\\"%s\\\".\", _log_message, elapsed_time.milliseconds(), Thread::current()->name());\n+    }\n+  }\n+};\n\n void GCLocker::stall_until_clear() {\n   MonitorLocker ml(JNICritical_lock);\n   if (needs_gc()) {\n     GCLockerTracer::inc_stall_count();\n     log_debug_jni(\"Allocation failed. Thread stalled by JNI critical section.\");\n+    GCLockerTimingDebugLogger logger(\"Thread stalled by JNI critical section.\");\n     // Wait for _needs_gc to be cleared\n     while (needs_gc()) {\n       ml.wait();\n     }\n   }\n }", "target": "+// GCLockerTimingDebugLogger tracks specific timing information for GC lock waits.\n+class GCLockerTimingDebugLogger : public StackObj {\n+  const char* _log_message;\n+  Ticks _start;\n+\n+public:\n+  GCLockerTimingDebugLogger(const char* log_message) : _log_message(log_message) {\n+    assert(_log_message != nullptr, \"GC locker debug message must be set.\");\n+    _start = Ticks::now();\n+  }\n+\n+  ~GCLockerTimingDebugLogger() {\n+    Log(gc, jni) log;\n+    if (log.is_debug()) {\n+      ResourceMark rm; // JavaThread::name() allocates to convert to UTF8\n+      const Tickspan elapsed_time = Ticks::now() - _start;\n+      log.debug(\"%s Resumed after \" UINT64_FORMAT \"ms. Thread \\\"%s\\\".\", _log_message, elapsed_time.milliseconds(), Thread::current()->name());\n+    }\n+  }\n+};\n\n void GCLocker::stall_until_clear() {\n   MonitorLocker ml(JNICritical_lock);\n   if (needs_gc()) {\n     GCLockerTracer::inc_stall_count();\n     log_debug_jni(\"Allocation failed. Thread stalled by JNI critical section.\");\n+    GCLockerTimingDebugLogger logger(\"Thread stalled by JNI critical section.\");\n     // Wait for _needs_gc to be cleared\n     while (needs_gc()) {\n       ml.wait();\n     }\n   }\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：GCLocker在阻塞线程时缺乏详细的诊断信息，难以分析性能瓶颈和线程等待时间。优化后：新增GCLockerTimingDebugLogger类，在stall_until_clear()和jni_lock()方法中添加计时日志记录，精确测量线程被阻塞的时间并输出到GC日志。优化思路：通过添加细粒度的计时和日志功能，改善GCLocker停滞的诊断能力，帮助开发者识别和优化因JNI临界区导致的GC延迟问题。"}
{"id": 796, "source": "riscv-dataset-excel", "optimization_type": "SIMD向量化优化", "optimization_description": "优化前：Base64解码使用标量指令逐字节处理，效率较低。优化后：为RISC-V架构实现Base64解码的向量化内在函数，利用RISC-V向量扩展指令集（RVV）并行处理多个字节。关键修改包括：1. 在assembler_riscv.hpp中添加vlseg4e8_v和vsseg3e8_v向量分段加载/存储指令支持；2. 在stubGenerator_riscv.cpp中实现base64_vector_decode_round函数，使用向量寄存器并行加载4个输入字节，通过查表转换、位运算组合成3个输出字节，并批量存储。优化思路：利用SIMD并行性，将原本需要多次循环的标量操作转换为单次向量操作，显著提升Base64解码吞吐量。", "original_code": "Base64解码使用标量指令逐字节处理，效率较低。", "optimized_code": "+  INSN(vlseg4e8_v, 0b0000111, 0b000, 0b00000, 0b00, 0b0, g4);\n+  INSN(vsseg3e8_v, 0b0100111, 0b000, 0b00000, 0b00, 0b0, g3);\n+  void base64_vector_decode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst, Register failedIdx, Register minusOne,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3, VectorRegister inputV4,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3,\n+                    Assembler::LMUL lmul) {\n+    // set vector register type/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul, Assembler::ma, Assembler::ta);\n+\n+    // segmented load src into v registers: mem(src) => vr(4)\n+    __ vlseg4e8_v(inputV1, src);\n+\n+    // src = src + register_group_len_bytes * 4\n+    __ add(src, src, stepSrc);\n+\n+    // decoding\n+    //   1. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(idxV1, codec, inputV1);\n+    __ vluxei8_v(idxV2, codec, inputV2);\n+    __ vluxei8_v(idxV3, codec, inputV3);\n+    __ vluxei8_v(idxV4, codec, inputV4);\n+\n+    //   2. check wrong data\n+    __ vor_vv(outputV1, idxV1, idxV2);\n+    __ vor_vv(outputV2, idxV3, idxV4);\n+    __ vor_vv(outputV1, outputV1, outputV2);\n+    __ vmseq_vi(v0, outputV1, -1);\n+    __ vfirst_m(failedIdx, v0);\n+    Label NoFailure;\n+    __ beq(failedIdx, minusOne, NoFailure);\n+    __ vsetvli(x0, failedIdx, Assembler::e8, lmul, Assembler::mu, Assembler::tu);\n+    __ slli(stepDst, failedIdx, 1);\n+    __ add(stepDst, failedIdx, stepDst);\n+    __ BIND(NoFailure);\n+\n+    //   3. compute the decoded data: vr(4) => vr(3)\n+    __ vsll_vi(idxV1, idxV1, 2);\n+    __ vsrl_vi(outputV1, idxV2, 4);\n+    __ vor_vv(outputV1, outputV1, idxV1);\n+\n+    __ vsll_vi(idxV2, idxV2, 4);\n+    __ vsrl_vi(outputV2, idxV3, 2);\n+    __ vor_vv(outputV2, outputV2, idxV2);\n+\n+    __ vsll_vi(idxV3, idxV3, 6);\n+    __ vor_vv(outputV3, idxV4, idxV3);\n+\n+    // segmented store encoded data in v registers back to dst: vr(3) => mem(dst)\n+    __ vsseg3e8_v(outputV1, dst);\n+\n+    // dst = dst + register_group_len_bytes * 3\n+    __ add(dst, dst, stepDst);\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/44d3a68d8a73c119b64772687d74e5ce25926f4f", "code_v0_no_empty_lines": "Base64解码使用标量指令逐字节处理，效率较低。", "code_v1_no_empty_lines": "+  INSN(vlseg4e8_v, 0b0000111, 0b000, 0b00000, 0b00, 0b0, g4);\n+  INSN(vsseg3e8_v, 0b0100111, 0b000, 0b00000, 0b00, 0b0, g3);\n+  void base64_vector_decode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst, Register failedIdx, Register minusOne,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3, VectorRegister inputV4,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3,\n+                    Assembler::LMUL lmul) {\n+    // set vector register type/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul, Assembler::ma, Assembler::ta);\n+\n+    // segmented load src into v registers: mem(src) => vr(4)\n+    __ vlseg4e8_v(inputV1, src);\n+\n+    // src = src + register_group_len_bytes * 4\n+    __ add(src, src, stepSrc);\n+\n+    // decoding\n+    //   1. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(idxV1, codec, inputV1);\n+    __ vluxei8_v(idxV2, codec, inputV2);\n+    __ vluxei8_v(idxV3, codec, inputV3);\n+    __ vluxei8_v(idxV4, codec, inputV4);\n+\n+    //   2. check wrong data\n+    __ vor_vv(outputV1, idxV1, idxV2);\n+    __ vor_vv(outputV2, idxV3, idxV4);\n+    __ vor_vv(outputV1, outputV1, outputV2);\n+    __ vmseq_vi(v0, outputV1, -1);\n+    __ vfirst_m(failedIdx, v0);\n+    Label NoFailure;\n+    __ beq(failedIdx, minusOne, NoFailure);\n+    __ vsetvli(x0, failedIdx, Assembler::e8, lmul, Assembler::mu, Assembler::tu);\n+    __ slli(stepDst, failedIdx, 1);\n+    __ add(stepDst, failedIdx, stepDst);\n+    __ BIND(NoFailure);\n+\n+    //   3. compute the decoded data: vr(4) => vr(3)\n+    __ vsll_vi(idxV1, idxV1, 2);\n+    __ vsrl_vi(outputV1, idxV2, 4);\n+    __ vor_vv(outputV1, outputV1, idxV1);\n+\n+    __ vsll_vi(idxV2, idxV2, 4);\n+    __ vsrl_vi(outputV2, idxV3, 2);\n+    __ vor_vv(outputV2, outputV2, idxV2);\n+\n+    __ vsll_vi(idxV3, idxV3, 6);\n+    __ vor_vv(outputV3, idxV4, idxV3);\n+\n+    // segmented store encoded data in v registers back to dst: vr(3) => mem(dst)\n+    __ vsseg3e8_v(outputV1, dst);\n+\n+    // dst = dst + register_group_len_bytes * 3\n+    __ add(dst, dst, stepDst);\n+  }", "target": "+  INSN(vlseg4e8_v, 0b0000111, 0b000, 0b00000, 0b00, 0b0, g4);\n+  INSN(vsseg3e8_v, 0b0100111, 0b000, 0b00000, 0b00, 0b0, g3);\n+  void base64_vector_decode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst, Register failedIdx, Register minusOne,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3, VectorRegister inputV4,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3,\n+                    Assembler::LMUL lmul) {\n+    // set vector register type/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul, Assembler::ma, Assembler::ta);\n+\n+    // segmented load src into v registers: mem(src) => vr(4)\n+    __ vlseg4e8_v(inputV1, src);\n+\n+    // src = src + register_group_len_bytes * 4\n+    __ add(src, src, stepSrc);\n+\n+    // decoding\n+    //   1. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(idxV1, codec, inputV1);\n+    __ vluxei8_v(idxV2, codec, inputV2);\n+    __ vluxei8_v(idxV3, codec, inputV3);\n+    __ vluxei8_v(idxV4, codec, inputV4);\n+\n+    //   2. check wrong data\n+    __ vor_vv(outputV1, idxV1, idxV2);\n+    __ vor_vv(outputV2, idxV3, idxV4);\n+    __ vor_vv(outputV1, outputV1, outputV2);\n+    __ vmseq_vi(v0, outputV1, -1);\n+    __ vfirst_m(failedIdx, v0);\n+    Label NoFailure;\n+    __ beq(failedIdx, minusOne, NoFailure);\n+    __ vsetvli(x0, failedIdx, Assembler::e8, lmul, Assembler::mu, Assembler::tu);\n+    __ slli(stepDst, failedIdx, 1);\n+    __ add(stepDst, failedIdx, stepDst);\n+    __ BIND(NoFailure);\n+\n+    //   3. compute the decoded data: vr(4) => vr(3)\n+    __ vsll_vi(idxV1, idxV1, 2);\n+    __ vsrl_vi(outputV1, idxV2, 4);\n+    __ vor_vv(outputV1, outputV1, idxV1);\n+\n+    __ vsll_vi(idxV2, idxV2, 4);\n+    __ vsrl_vi(outputV2, idxV3, 2);\n+    __ vor_vv(outputV2, outputV2, idxV2);\n+\n+    __ vsll_vi(idxV3, idxV3, 6);\n+    __ vor_vv(outputV3, idxV4, idxV3);\n+\n+    // segmented store encoded data in v registers back to dst: vr(3) => mem(dst)\n+    __ vsseg3e8_v(outputV1, dst);\n+\n+    // dst = dst + register_group_len_bytes * 3\n+    __ add(dst, dst, stepDst);\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Base64解码使用标量指令逐字节处理，效率较低。优化后：为RISC-V架构实现Base64解码的向量化内在函数，利用RISC-V向量扩展指令集（RVV）并行处理多个字节。关键修改包括：1. 在assembler_riscv.hpp中添加vlseg4e8_v和vsseg3e8_v向量分段加载/存储指令支持；2. 在stubGenerator_riscv.cpp中实现base64_vector_decode_round函数，使用向量寄存器并行加载4个输入字节，通过查表转换、位运算组合成3个输出字节，并批量存储。优化思路：利用SIMD并行性，将原本需要多次循环的标量操作转换为单次向量操作，显著提升Base64解码吞吐量。"}
{"id": 797, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前：在RISC-V平台上，nmethod屏障中总是嵌入人工数据依赖（通过srli和orr指令）来确保guard加载和epoch加载的顺序，这会产生不必要的开销，尤其是在Ztso内存模型下。优化后：通过条件判断（if (!UseZtso)）仅在非Ztso内存模型时嵌入数据依赖，在Ztso模型下跳过这些指令，避免了额外的指令开销和潜在的性能瓶颈。优化思路：利用Ztso内存模型提供的强内存顺序保证，无需额外同步指令，从而减少指令数和提高执行效率。", "original_code": "在RISC-V平台上，nmethod屏障中总是嵌入人工数据依赖（通过srli和orr指令）来确保guard加载和epoch加载的顺序，这会产生不必要的开销，尤其是在Ztso内存模型下。", "optimized_code": "__ la(t1, ExternalAddress((address)&_patching_epoch));\n-        // Embed an artificial data dependency to order the guard load\n-        // before the epoch load.\n-        __ srli(ra, t0, 32);\n-        __ orr(t1, t1, ra);\n+        if (!UseZtso) {\n+          // Embed a synthetic data dependency between the load of the guard and\n+          // the load of the epoch. This guarantees that these loads occur in\n+          // order, while allowing other independent instructions to be reordered.\n+          // Note: This may be slower than using a membar(load|load) (fence r,r).\n+          // Because processors will not start the second load until the first comes back.\n+          // This means you can’t overlap the two loads,\n+          // which is stronger than needed for ordering (stronger than TSO).\n+          __ srli(ra, t0, 32);\n+          __ orr(t1, t1, ra);\n+        }", "source_url": "https://github.com/openjdk/riscv-port/commit/aefdbdc7e54ae92b5c2113504ce17abf00681e62", "code_v0_no_empty_lines": "在RISC-V平台上，nmethod屏障中总是嵌入人工数据依赖（通过srli和orr指令）来确保guard加载和epoch加载的顺序，这会产生不必要的开销，尤其是在Ztso内存模型下。", "code_v1_no_empty_lines": "__ la(t1, ExternalAddress((address)&_patching_epoch));\n-        // Embed an artificial data dependency to order the guard load\n-        // before the epoch load.\n-        __ srli(ra, t0, 32);\n-        __ orr(t1, t1, ra);\n+        if (!UseZtso) {\n+          // Embed a synthetic data dependency between the load of the guard and\n+          // the load of the epoch. This guarantees that these loads occur in\n+          // order, while allowing other independent instructions to be reordered.\n+          // Note: This may be slower than using a membar(load|load) (fence r,r).\n+          // Because processors will not start the second load until the first comes back.\n+          // This means you can’t overlap the two loads,\n+          // which is stronger than needed for ordering (stronger than TSO).\n+          __ srli(ra, t0, 32);\n+          __ orr(t1, t1, ra);\n+        }", "target": "__ la(t1, ExternalAddress((address)&_patching_epoch));\n-        // Embed an artificial data dependency to order the guard load\n-        // before the epoch load.\n-        __ srli(ra, t0, 32);\n-        __ orr(t1, t1, ra);\n+        if (!UseZtso) {\n+          // Embed a synthetic data dependency between the load of the guard and\n+          // the load of the epoch. This guarantees that these loads occur in\n+          // order, while allowing other independent instructions to be reordered.\n+          // Note: This may be slower than using a membar(load|load) (fence r,r).\n+          // Because processors will not start the second load until the first comes back.\n+          // This means you can’t overlap the two loads,\n+          // which is stronger than needed for ordering (stronger than TSO).\n+          __ srli(ra, t0, 32);\n+          __ orr(t1, t1, ra);\n+        }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在RISC-V平台上，nmethod屏障中总是嵌入人工数据依赖（通过srli和orr指令）来确保guard加载和epoch加载的顺序，这会产生不必要的开销，尤其是在Ztso内存模型下。优化后：通过条件判断（if (!UseZtso)）仅在非Ztso内存模型时嵌入数据依赖，在Ztso模型下跳过这些指令，避免了额外的指令开销和潜在的性能瓶颈。优化思路：利用Ztso内存模型提供的强内存顺序保证，无需额外同步指令，从而减少指令数和提高执行效率。"}
{"id": 798, "source": "riscv-dataset-excel", "optimization_type": "内存碎片优化+算法重构", "optimization_description": "优化前：SplitInfo::record()方法基于源区域索引、部分对象大小和目标地址计算分割信息，逻辑复杂且容易产生碎片。优化后：重构为基于分割区域索引、分割点和前导存活字数计算，简化了分割点确定逻辑，减少了内存碎片。思路：通过重新设计分割信息记录方式，使Full GC期间的内存压缩更高效，改善内存碎片问题。", "original_code": "SplitInfo::record()方法基于源区域索引、部分对象大小和目标地址计算分割信息，逻辑复杂且容易产生碎片。", "optimized_code": "- void SplitInfo::record(size_t src_region_idx, size_t partial_obj_size,\n-                        HeapWord* destination)\n+ void SplitInfo::record(size_t split_region_idx, HeapWord* split_point, size_t preceding_live_words)", "source_url": "https://github.com/openjdk/riscv-port/commit/1ff5f8d65cf6153e517ee7a242d10536eee0d637", "code_v0_no_empty_lines": "SplitInfo::record()方法基于源区域索引、部分对象大小和目标地址计算分割信息，逻辑复杂且容易产生碎片。", "code_v1_no_empty_lines": "- void SplitInfo::record(size_t src_region_idx, size_t partial_obj_size,\n-                        HeapWord* destination)\n+ void SplitInfo::record(size_t split_region_idx, HeapWord* split_point, size_t preceding_live_words)", "target": "- void SplitInfo::record(size_t src_region_idx, size_t partial_obj_size,\n-                        HeapWord* destination)\n+ void SplitInfo::record(size_t split_region_idx, HeapWord* split_point, size_t preceding_live_words)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SplitInfo::record()方法基于源区域索引、部分对象大小和目标地址计算分割信息，逻辑复杂且容易产生碎片。优化后：重构为基于分割区域索引、分割点和前导存活字数计算，简化了分割点确定逻辑，减少了内存碎片。思路：通过重新设计分割信息记录方式，使Full GC期间的内存压缩更高效，改善内存碎片问题。"}
{"id": 799, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+接口简化", "optimization_description": "优化前：deallocate方法需要调用者显式传递is_class参数来判断内存块是否属于类空间，这增加了调用者的负担且容易出错。优化后：通过新增Metaspace::is_in_class_space()函数，根据指针地址自动判断内存块所属空间，简化了接口并减少了参数传递。优化思路：将空间判断逻辑内聚到Metaspace内部，通过记录类空间的地址范围实现快速指针检查，提高了代码的健壮性和可维护性。", "original_code": "deallocate方法需要调用者显式传递is_class参数来判断内存块是否属于类空间，这增加了调用者的负担且容易出错。", "optimized_code": "-void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {\n+void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size) {\n   MutexLocker fcl(lock(), Mutex::_no_safepoint_check_flag);\n-  if (Metaspace::using_class_space() && is_class) {\n+  const bool is_class = Metaspace::using_class_space() && Metaspace::is_in_class_space(ptr);\n+  if (is_class) {\n     class_space_arena()->deallocate(ptr, word_size);\n   } else {\n     non_class_space_arena()->deallocate(ptr, word_size);\n   }\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/daf26178be07bfe4a46592bcde092ce297a092bb", "code_v0_no_empty_lines": "deallocate方法需要调用者显式传递is_class参数来判断内存块是否属于类空间，这增加了调用者的负担且容易出错。", "code_v1_no_empty_lines": "-void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {\n+void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size) {\n   MutexLocker fcl(lock(), Mutex::_no_safepoint_check_flag);\n-  if (Metaspace::using_class_space() && is_class) {\n+  const bool is_class = Metaspace::using_class_space() && Metaspace::is_in_class_space(ptr);\n+  if (is_class) {\n     class_space_arena()->deallocate(ptr, word_size);\n   } else {\n     non_class_space_arena()->deallocate(ptr, word_size);\n   }\n }", "target": "-void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {\n+void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size) {\n   MutexLocker fcl(lock(), Mutex::_no_safepoint_check_flag);\n-  if (Metaspace::using_class_space() && is_class) {\n+  const bool is_class = Metaspace::using_class_space() && Metaspace::is_in_class_space(ptr);\n+  if (is_class) {\n     class_space_arena()->deallocate(ptr, word_size);\n   } else {\n     non_class_space_arena()->deallocate(ptr, word_size);\n   }\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：deallocate方法需要调用者显式传递is_class参数来判断内存块是否属于类空间，这增加了调用者的负担且容易出错。优化后：通过新增Metaspace::is_in_class_space()函数，根据指针地址自动判断内存块所属空间，简化了接口并减少了参数传递。优化思路：将空间判断逻辑内聚到Metaspace内部，通过记录类空间的地址范围实现快速指针检查，提高了代码的健壮性和可维护性。"}
{"id": 800, "source": "riscv-dataset-excel", "optimization_type": "数值溢出优化+算法简化", "optimization_description": "优化前：triggerTime方法使用复杂逻辑处理延迟溢出问题，通过overflowFree方法检查队列头部任务延迟，当延迟值接近Long.MAX_VALUE时进行特殊处理，防止compareTo方法溢出。这增加了方法调用开销和代码复杂度。优化后：引入MAX_NANOS常量（约146年），直接使用Math.min(delay, MAX_NANOS)限制最大延迟值，完全移除了overflowFree方法和相关检查逻辑。优化思路：通过设置合理的最大延迟边界，简化了数值溢出处理，减少了方法调用和条件判断，提高了ScheduledThreadPoolExecutor处理极端长延迟任务的性能。", "original_code": "triggerTime方法使用复杂逻辑处理延迟溢出问题，通过overflowFree方法检查队列头部任务延迟，当延迟值接近Long.MAX_VALUE时进行特殊处理，防止compareTo方法溢出。这增加了方法调用开销和代码复杂度。", "optimized_code": "-        return System.nanoTime() +\n            ((delay < (Long.MAX_VALUE >> 1)) ? delay : overflowFree(delay));\n-    }\n-\n-    /**\n-     * Constrains the values of all delays in the queue to be within\n-     * Long.MAX_VALUE of each other, to avoid overflow in compareTo.\n-     * This may occur if a task is eligible to be dequeued, but has\n-     * not yet been, while some other task is added with a delay of\n-     * Long.MAX_VALUE.\n-     */\n-    private long overflowFree(long delay) {\n-        Delayed head = (Delayed) super.getQueue().peek();\n-        if (head != null) {\n-            long headDelay = head.getDelay(NANOSECONDS);\n-            if (headDelay < 0 && (delay - headDelay < 0))\n-                delay = Long.MAX_VALUE + headDelay;\n-        }\n-        return delay;\n+        return System.nanoTime() + Math.min(delay, MAX_NANOS);", "source_url": "https://github.com/openjdk/riscv-port/commit/414d23cb8f3c2765ac6ba2da930f2cfe7a9ad419", "code_v0_no_empty_lines": "triggerTime方法使用复杂逻辑处理延迟溢出问题，通过overflowFree方法检查队列头部任务延迟，当延迟值接近Long.MAX_VALUE时进行特殊处理，防止compareTo方法溢出。这增加了方法调用开销和代码复杂度。", "code_v1_no_empty_lines": "-        return System.nanoTime() +\n            ((delay < (Long.MAX_VALUE >> 1)) ? delay : overflowFree(delay));\n-    }\n-\n-    /**\n-     * Constrains the values of all delays in the queue to be within\n-     * Long.MAX_VALUE of each other, to avoid overflow in compareTo.\n-     * This may occur if a task is eligible to be dequeued, but has\n-     * not yet been, while some other task is added with a delay of\n-     * Long.MAX_VALUE.\n-     */\n-    private long overflowFree(long delay) {\n-        Delayed head = (Delayed) super.getQueue().peek();\n-        if (head != null) {\n-            long headDelay = head.getDelay(NANOSECONDS);\n-            if (headDelay < 0 && (delay - headDelay < 0))\n-                delay = Long.MAX_VALUE + headDelay;\n-        }\n-        return delay;\n+        return System.nanoTime() + Math.min(delay, MAX_NANOS);", "target": "-        return System.nanoTime() +\n            ((delay < (Long.MAX_VALUE >> 1)) ? delay : overflowFree(delay));\n-    }\n-\n-    /**\n-     * Constrains the values of all delays in the queue to be within\n-     * Long.MAX_VALUE of each other, to avoid overflow in compareTo.\n-     * This may occur if a task is eligible to be dequeued, but has\n-     * not yet been, while some other task is added with a delay of\n-     * Long.MAX_VALUE.\n-     */\n-    private long overflowFree(long delay) {\n-        Delayed head = (Delayed) super.getQueue().peek();\n-        if (head != null) {\n-            long headDelay = head.getDelay(NANOSECONDS);\n-            if (headDelay < 0 && (delay - headDelay < 0))\n-                delay = Long.MAX_VALUE + headDelay;\n-        }\n-        return delay;\n+        return System.nanoTime() + Math.min(delay, MAX_NANOS);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：triggerTime方法使用复杂逻辑处理延迟溢出问题，通过overflowFree方法检查队列头部任务延迟，当延迟值接近Long.MAX_VALUE时进行特殊处理，防止compareTo方法溢出。这增加了方法调用开销和代码复杂度。优化后：引入MAX_NANOS常量（约146年），直接使用Math.min(delay, MAX_NANOS)限制最大延迟值，完全移除了overflowFree方法和相关检查逻辑。优化思路：通过设置合理的最大延迟边界，简化了数值溢出处理，减少了方法调用和条件判断，提高了ScheduledThreadPoolExecutor处理极端长延迟任务的性能。"}
{"id": 801, "source": "riscv-dataset-excel", "optimization_type": "构建系统优化", "optimization_description": "优化前：API摘要生成逻辑分散在多个位置，条件判断和变量定义顺序不合理，导致构建时重复计算和依赖关系混乱。特别是当CREATE_API_DIGEST为true时，需要手动管理额外的classpath依赖。\n\n优化后：1. 重构了JavaCompilation.gmk中的变量定义顺序，将API相关变量定义提前，确保在条件判断前可用；2. 将API摘要生成相关的标志和依赖定义集中到条件判断内部，逻辑更清晰；3. 引入了$1_AUGMENTED_CLASSPATH变量，自动处理CREATE_API_DIGEST为true时的额外classpath需求；4. 在BuildMicrobenchmark.gmk中启用CREATE_API_DIGEST选项，利用新的优化逻辑。\n\n优化思路：通过重构构建脚本，减少重复计算，优化依赖管理，特别是针对微基准测试的构建过程。将API摘要生成的相关配置集中管理，避免条件判断时的重复定义，同时通过AUGMENTED_CLASSPATH机制自动处理编译时的类路径需求，从而显著提升微基准测试的构建速度。", "original_code": "API摘要生成逻辑分散在多个位置，条件判断和变量定义顺序不合理，导致构建时重复计算和依赖关系混乱。特别是当CREATE_API_DIGEST为true时，需要手动管理额外的classpath依赖。", "optimized_code": "1. 在JavaCompilation.gmk中重构了API摘要生成逻辑：\n   - 将$1_API_TARGET和$1_API_INTERNAL的定义提前到条件判断之前\n   - 将$1_API_DIGEST_FLAGS和$1_EXTRA_DEPS的定义移到条件判断内部\n   - 修改了$1_API_DIGEST_FLAGS的定义，移除了-classpath参数\n   - 新增了$1_AUGMENTED_CLASSPATH变量，在CREATE_API_DIGEST为true时包含额外路径\n   - 将-cp参数从使用$1_CLASSPATH改为使用$1_AUGMENTED_CLASSPATH\n\n2. 在BuildMicrobenchmark.gmk中：\n   +    CREATE_API_DIGEST := true,", "source_url": "https://github.com/openjdk/riscv-port/commit/b704bfa205bbd8c56f128ce5d727d40c8a3ec613", "code_v0_no_empty_lines": "API摘要生成逻辑分散在多个位置，条件判断和变量定义顺序不合理，导致构建时重复计算和依赖关系混乱。特别是当CREATE_API_DIGEST为true时，需要手动管理额外的classpath依赖。", "code_v1_no_empty_lines": "1. 在JavaCompilation.gmk中重构了API摘要生成逻辑：\n   - 将$1_API_TARGET和$1_API_INTERNAL的定义提前到条件判断之前\n   - 将$1_API_DIGEST_FLAGS和$1_EXTRA_DEPS的定义移到条件判断内部\n   - 修改了$1_API_DIGEST_FLAGS的定义，移除了-classpath参数\n   - 新增了$1_AUGMENTED_CLASSPATH变量，在CREATE_API_DIGEST为true时包含额外路径\n   - 将-cp参数从使用$1_CLASSPATH改为使用$1_AUGMENTED_CLASSPATH\n\n2. 在BuildMicrobenchmark.gmk中：\n   +    CREATE_API_DIGEST := true,", "target": "1. 在JavaCompilation.gmk中重构了API摘要生成逻辑：\n   - 将$1_API_TARGET和$1_API_INTERNAL的定义提前到条件判断之前\n   - 将$1_API_DIGEST_FLAGS和$1_EXTRA_DEPS的定义移到条件判断内部\n   - 修改了$1_API_DIGEST_FLAGS的定义，移除了-classpath参数\n   - 新增了$1_AUGMENTED_CLASSPATH变量，在CREATE_API_DIGEST为true时包含额外路径\n   - 将-cp参数从使用$1_CLASSPATH改为使用$1_AUGMENTED_CLASSPATH\n\n2. 在BuildMicrobenchmark.gmk中：\n   +    CREATE_API_DIGEST := true,", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：API摘要生成逻辑分散在多个位置，条件判断和变量定义顺序不合理，导致构建时重复计算和依赖关系混乱。特别是当CREATE_API_DIGEST为true时，需要手动管理额外的classpath依赖。\n\n优化后：1. 重构了JavaCompilation.gmk中的变量定义顺序，将API相关变量定义提前，确保在条件判断前可用；2. 将API摘要生成相关的标志和依赖定义集中到条件判断内部，逻辑更清晰；3. 引入了$1_AUGMENTED_CLASSPATH变量，自动处理CREATE_API_DIGEST为true时的额外classpath需求；4. 在BuildMicrobenchmark.gmk中启用CREATE_API_DIGEST选项，利用新的优化逻辑。\n\n优化思路：通过重构构建脚本，减少重复计算，优化依赖管理，特别是针对微基准测试的构建过程。将API摘要生成的相关配置集中管理，避免条件判断时的重复定义，同时通过AUGMENTED_CLASSPATH机制自动处理编译时的类路径需求，从而显著提升微基准测试的构建速度。"}
{"id": 802, "source": "riscv-dataset-excel", "optimization_type": "常量池优化+方法调用优化", "optimization_description": "优化前：使用ClassDesc.ofDescriptor()和MethodTypeDesc.of()方法创建常量描述符，这些方法在每次调用时都会进行验证和可能的缓存查找，存在重复验证开销。优化后：改用ReferenceClassDescImpl.ofValidated()和MethodTypeDescImpl.ofValidated()方法，这些方法假设输入已经是验证过的描述符字符串，避免了重复验证开销。同时，在MethodType.methodType()调用中添加了true参数，表示信任参数类型已擦除，进一步减少验证。优化思路：通过使用已验证的工厂方法替代通用工厂方法，减少运行时验证开销，提高StringConcatFactory在构建MethodType和MethodTypeDesc时的性能。", "original_code": "使用ClassDesc.ofDescriptor()和MethodTypeDesc.of()方法创建常量描述符，这些方法在每次调用时都会进行验证和可能的缓存查找，存在重复验证开销。", "optimized_code": "- static final ClassDesc CD_StringConcatHelper = ClassDesc.ofDescriptor(\"Ljava/lang/StringConcatHelper;\");\n+ static final ClassDesc CD_StringConcatHelper = ReferenceClassDescImpl.ofValidated(\"Ljava/lang/StringConcatHelper;\");\n- static final MethodTypeDesc MTD_byte_char = MethodTypeDesc.of(CD_byte, CD_char);\n+ static final MethodTypeDesc MTD_byte_char = MethodTypeDescImpl.ofValidated(CD_byte, CD_char);\n- return changed ? MethodType.methodType(args.returnType(), paramTypes) : args;\n+ return changed ? MethodType.methodType(args.returnType(), paramTypes, true) : args;\n- return MethodTypeDesc.of(CD_int, paramTypes);\n+ return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);", "source_url": "https://github.com/openjdk/riscv-port/commit/5ecbecfbcac681e9e6750be37ca4bc2591db21e6", "code_v0_no_empty_lines": "使用ClassDesc.ofDescriptor()和MethodTypeDesc.of()方法创建常量描述符，这些方法在每次调用时都会进行验证和可能的缓存查找，存在重复验证开销。", "code_v1_no_empty_lines": "- static final ClassDesc CD_StringConcatHelper = ClassDesc.ofDescriptor(\"Ljava/lang/StringConcatHelper;\");\n+ static final ClassDesc CD_StringConcatHelper = ReferenceClassDescImpl.ofValidated(\"Ljava/lang/StringConcatHelper;\");\n- static final MethodTypeDesc MTD_byte_char = MethodTypeDesc.of(CD_byte, CD_char);\n+ static final MethodTypeDesc MTD_byte_char = MethodTypeDescImpl.ofValidated(CD_byte, CD_char);\n- return changed ? MethodType.methodType(args.returnType(), paramTypes) : args;\n+ return changed ? MethodType.methodType(args.returnType(), paramTypes, true) : args;\n- return MethodTypeDesc.of(CD_int, paramTypes);\n+ return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);", "target": "- static final ClassDesc CD_StringConcatHelper = ClassDesc.ofDescriptor(\"Ljava/lang/StringConcatHelper;\");\n+ static final ClassDesc CD_StringConcatHelper = ReferenceClassDescImpl.ofValidated(\"Ljava/lang/StringConcatHelper;\");\n- static final MethodTypeDesc MTD_byte_char = MethodTypeDesc.of(CD_byte, CD_char);\n+ static final MethodTypeDesc MTD_byte_char = MethodTypeDescImpl.ofValidated(CD_byte, CD_char);\n- return changed ? MethodType.methodType(args.returnType(), paramTypes) : args;\n+ return changed ? MethodType.methodType(args.returnType(), paramTypes, true) : args;\n- return MethodTypeDesc.of(CD_int, paramTypes);\n+ return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用ClassDesc.ofDescriptor()和MethodTypeDesc.of()方法创建常量描述符，这些方法在每次调用时都会进行验证和可能的缓存查找，存在重复验证开销。优化后：改用ReferenceClassDescImpl.ofValidated()和MethodTypeDescImpl.ofValidated()方法，这些方法假设输入已经是验证过的描述符字符串，避免了重复验证开销。同时，在MethodType.methodType()调用中添加了true参数，表示信任参数类型已擦除，进一步减少验证。优化思路：通过使用已验证的工厂方法替代通用工厂方法，减少运行时验证开销，提高StringConcatFactory在构建MethodType和MethodTypeDesc时的性能。"}
{"id": 803, "source": "riscv-dataset-excel", "optimization_type": "代码清理/冗余代码移除", "optimization_description": "优化前：place_outside_loop()函数中的条件检查包含冗余分支，专门处理NeverBranch节点的情况。优化后：由于之前的提交（8335709）已解决NeverBranch节点的循环归属问题，移除了冗余的条件分支。思路：清理因之前优化而变得多余的代码，简化逻辑，减少不必要的条件判断。", "original_code": "place_outside_loop()函数中的条件检查包含冗余分支，专门处理NeverBranch节点的情况。", "optimized_code": "-    if (loop->is_member(get_loop(dom)) ||\n-        // NeverBranch nodes are not assigned to the loop when constructed\n-        (dom->is_NeverBranch() && loop->is_member(get_loop(dom->in(0))))) {\n+    if (loop->is_member(get_loop(dom))) {", "source_url": "https://github.com/openjdk/riscv-port/commit/ce83f6af64efd673b83c945765f68e8a3bf89774", "code_v0_no_empty_lines": "place_outside_loop()函数中的条件检查包含冗余分支，专门处理NeverBranch节点的情况。", "code_v1_no_empty_lines": "-    if (loop->is_member(get_loop(dom)) ||\n-        // NeverBranch nodes are not assigned to the loop when constructed\n-        (dom->is_NeverBranch() && loop->is_member(get_loop(dom->in(0))))) {\n+    if (loop->is_member(get_loop(dom))) {", "target": "-    if (loop->is_member(get_loop(dom)) ||\n-        // NeverBranch nodes are not assigned to the loop when constructed\n-        (dom->is_NeverBranch() && loop->is_member(get_loop(dom->in(0))))) {\n+    if (loop->is_member(get_loop(dom))) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：place_outside_loop()函数中的条件检查包含冗余分支，专门处理NeverBranch节点的情况。优化后：由于之前的提交（8335709）已解决NeverBranch节点的循环归属问题，移除了冗余的条件分支。思路：清理因之前优化而变得多余的代码，简化逻辑，减少不必要的条件判断。"}
{"id": 804, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码结构优化", "optimization_description": "优化前：使用switch表达式处理Option类型，在类文件API的引导阶段（bootstrap）会产生额外的类加载开销。优化后：将switch表达式改为instanceof链式检查，避免在引导阶段加载所有Option实现类，减少启动时的类加载开销。优化思路：通过避免引导阶段的switch表达式，减少类加载和初始化开销，提升启动性能。", "original_code": "使用switch表达式处理Option类型，在类文件API的引导阶段（bootstrap）会产生额外的类加载开销。", "optimized_code": "- switch (o) {\n-     case StackMapsOption oo -> smo = oo;\n-     case DebugElementsOption oo -> deo = oo;\n-     case LineNumbersOption oo -> lno = oo;\n-     case AttributesProcessingOption oo -> apo = oo;\n-     case ConstantPoolSharingOption oo -> cpso = oo;\n-     case ShortJumpsOption oo -> sjo = oo;\n-     case DeadCodeOption oo -> dco = oo;\n-     case DeadLabelsOption oo -> dlo = oo;\n-     case ClassHierarchyResolverOption oo -> chro = oo;\n-     case AttributeMapperOption oo -> amo = oo;\n- }\n+ if (o instanceof StackMapsOption oo) {\n+     smo = oo;\n+ } else if (o instanceof DebugElementsOption oo) {\n+     deo = oo;\n+ } else if (o instanceof LineNumbersOption oo) {\n+     lno = oo;\n+ } else if (o instanceof AttributesProcessingOption oo) {\n+     apo = oo;\n+ } else if (o instanceof ConstantPoolSharingOption oo) {\n+     cpso = oo;\n+ } else if (o instanceof ShortJumpsOption oo) {\n+     sjo = oo;\n+ } else if (o instanceof DeadCodeOption oo) {\n+     dco = oo;\n+ } else if (o instanceof DeadLabelsOption oo) {\n+     dlo = oo;\n+ } else if (o instanceof ClassHierarchyResolverOption oo) {\n+     chro = oo;\n+ } else if (o instanceof AttributeMapperOption oo) {\n+     amo = oo;\n+ } else { // null or unknown Option type\n+     throw new IllegalArgumentException(\"Invalid option: \" + o);\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/e63418ee017def80689c88671e5d124b2d453fda", "code_v0_no_empty_lines": "使用switch表达式处理Option类型，在类文件API的引导阶段（bootstrap）会产生额外的类加载开销。", "code_v1_no_empty_lines": "- switch (o) {\n-     case StackMapsOption oo -> smo = oo;\n-     case DebugElementsOption oo -> deo = oo;\n-     case LineNumbersOption oo -> lno = oo;\n-     case AttributesProcessingOption oo -> apo = oo;\n-     case ConstantPoolSharingOption oo -> cpso = oo;\n-     case ShortJumpsOption oo -> sjo = oo;\n-     case DeadCodeOption oo -> dco = oo;\n-     case DeadLabelsOption oo -> dlo = oo;\n-     case ClassHierarchyResolverOption oo -> chro = oo;\n-     case AttributeMapperOption oo -> amo = oo;\n- }\n+ if (o instanceof StackMapsOption oo) {\n+     smo = oo;\n+ } else if (o instanceof DebugElementsOption oo) {\n+     deo = oo;\n+ } else if (o instanceof LineNumbersOption oo) {\n+     lno = oo;\n+ } else if (o instanceof AttributesProcessingOption oo) {\n+     apo = oo;\n+ } else if (o instanceof ConstantPoolSharingOption oo) {\n+     cpso = oo;\n+ } else if (o instanceof ShortJumpsOption oo) {\n+     sjo = oo;\n+ } else if (o instanceof DeadCodeOption oo) {\n+     dco = oo;\n+ } else if (o instanceof DeadLabelsOption oo) {\n+     dlo = oo;\n+ } else if (o instanceof ClassHierarchyResolverOption oo) {\n+     chro = oo;\n+ } else if (o instanceof AttributeMapperOption oo) {\n+     amo = oo;\n+ } else { // null or unknown Option type\n+     throw new IllegalArgumentException(\"Invalid option: \" + o);\n+ }", "target": "- switch (o) {\n-     case StackMapsOption oo -> smo = oo;\n-     case DebugElementsOption oo -> deo = oo;\n-     case LineNumbersOption oo -> lno = oo;\n-     case AttributesProcessingOption oo -> apo = oo;\n-     case ConstantPoolSharingOption oo -> cpso = oo;\n-     case ShortJumpsOption oo -> sjo = oo;\n-     case DeadCodeOption oo -> dco = oo;\n-     case DeadLabelsOption oo -> dlo = oo;\n-     case ClassHierarchyResolverOption oo -> chro = oo;\n-     case AttributeMapperOption oo -> amo = oo;\n- }\n+ if (o instanceof StackMapsOption oo) {\n+     smo = oo;\n+ } else if (o instanceof DebugElementsOption oo) {\n+     deo = oo;\n+ } else if (o instanceof LineNumbersOption oo) {\n+     lno = oo;\n+ } else if (o instanceof AttributesProcessingOption oo) {\n+     apo = oo;\n+ } else if (o instanceof ConstantPoolSharingOption oo) {\n+     cpso = oo;\n+ } else if (o instanceof ShortJumpsOption oo) {\n+     sjo = oo;\n+ } else if (o instanceof DeadCodeOption oo) {\n+     dco = oo;\n+ } else if (o instanceof DeadLabelsOption oo) {\n+     dlo = oo;\n+ } else if (o instanceof ClassHierarchyResolverOption oo) {\n+     chro = oo;\n+ } else if (o instanceof AttributeMapperOption oo) {\n+     amo = oo;\n+ } else { // null or unknown Option type\n+     throw new IllegalArgumentException(\"Invalid option: \" + o);\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用switch表达式处理Option类型，在类文件API的引导阶段（bootstrap）会产生额外的类加载开销。优化后：将switch表达式改为instanceof链式检查，避免在引导阶段加载所有Option实现类，减少启动时的类加载开销。优化思路：通过避免引导阶段的switch表达式，减少类加载和初始化开销，提升启动性能。"}
{"id": 805, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+内存优化", "optimization_description": "优化前：typeSwitch方法总是传递BiPredicate和List参数，即使某些调用场景不需要这些参数，导致不必要的参数传递和内存分配开销。优化后：通过needsExtraInfo方法动态判断是否需要额外参数，将typeSwitch拆分为两个版本——MT_TYPE_SWITCH（基本版本）和MT_TYPE_SWITCH_EXTRA（带额外参数版本）。优化思路：避免为不需要额外参数的switch场景传递EnumDescs和额外类参数，减少方法调用开销和内存分配，提高switch代码生成效率。", "original_code": "typeSwitch方法总是传递BiPredicate和List参数，即使某些调用场景不需要这些参数，导致不必要的参数传递和内存分配开销。", "optimized_code": "-    private static final MethodType TYPES_SWITCH_TYPE = MethodType.methodType(int.class,\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH_EXTRA = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int,\n+            CD_BiPredicate,\n+            ConstantDescs.CD_List);\n+    private static final MethodType MT_TYPE_SWITCH_EXTRA = MethodType.methodType(int.class,\n             Object.class,\n             int.class,\n             BiPredicate.class,\n             List.class);\n-\n-    private static final MethodTypeDesc TYPES_SWITCH_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(Ljava/lang/Object;ILjava/util/function/BiPredicate;Ljava/util/List;)I\");\n+    private static final MethodType MT_TYPE_SWITCH = MethodType.methodType(int.class,\n+            Object.class,\n+            int.class);", "source_url": "https://github.com/openjdk/riscv-port/commit/3f00da84b3e6fb001e7d56acb198292b28d40c8b", "code_v0_no_empty_lines": "typeSwitch方法总是传递BiPredicate和List参数，即使某些调用场景不需要这些参数，导致不必要的参数传递和内存分配开销。", "code_v1_no_empty_lines": "-    private static final MethodType TYPES_SWITCH_TYPE = MethodType.methodType(int.class,\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH_EXTRA = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int,\n+            CD_BiPredicate,\n+            ConstantDescs.CD_List);\n+    private static final MethodType MT_TYPE_SWITCH_EXTRA = MethodType.methodType(int.class,\n             Object.class,\n             int.class,\n             BiPredicate.class,\n             List.class);\n-\n-    private static final MethodTypeDesc TYPES_SWITCH_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(Ljava/lang/Object;ILjava/util/function/BiPredicate;Ljava/util/List;)I\");\n+    private static final MethodType MT_TYPE_SWITCH = MethodType.methodType(int.class,\n+            Object.class,\n+            int.class);", "target": "-    private static final MethodType TYPES_SWITCH_TYPE = MethodType.methodType(int.class,\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH_EXTRA = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int,\n+            CD_BiPredicate,\n+            ConstantDescs.CD_List);\n+    private static final MethodType MT_TYPE_SWITCH_EXTRA = MethodType.methodType(int.class,\n             Object.class,\n             int.class,\n             BiPredicate.class,\n             List.class);\n-\n-    private static final MethodTypeDesc TYPES_SWITCH_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(Ljava/lang/Object;ILjava/util/function/BiPredicate;Ljava/util/List;)I\");\n+    private static final MethodType MT_TYPE_SWITCH = MethodType.methodType(int.class,\n+            Object.class,\n+            int.class);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：typeSwitch方法总是传递BiPredicate和List参数，即使某些调用场景不需要这些参数，导致不必要的参数传递和内存分配开销。优化后：通过needsExtraInfo方法动态判断是否需要额外参数，将typeSwitch拆分为两个版本——MT_TYPE_SWITCH（基本版本）和MT_TYPE_SWITCH_EXTRA（带额外参数版本）。优化思路：避免为不需要额外参数的switch场景传递EnumDescs和额外类参数，减少方法调用开销和内存分配，提高switch代码生成效率。"}
{"id": 806, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（标量替换增强）", "optimization_description": "优化前：Node::dominates函数返回布尔值，在遇到死代码时保守返回false，可能导致标量替换机会被错过。优化后：引入DomResult枚举（Dominate/NotDominate/EncounteredDeadCode），区分明确支配关系、明确不支配关系和死代码情况。思路：通过更精确的支配关系判断，在IGVN（增量全局值编号）阶段能识别更多标量替换机会，特别是处理GC屏障时，增强C2编译器的标量替换优化能力。", "original_code": "Node::dominates函数返回布尔值，在遇到死代码时保守返回false，可能导致标量替换机会被错过。", "optimized_code": "-bool MemNode::all_controls_dominate(Node* dom, Node* sub) {\n+Node::DomResult MemNode::maybe_all_controls_dominate(Node* dom, Node* sub) {\n   if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top())\n-    return false; // Conservative answer for dead code\n+    return DomResult::EncounteredDeadCode; // Conservative answer for dead code\n   ...\n-    return only_dominating_controls;\n+    return only_dominating_controls ? DomResult::Dominate : DomResult::NotDominate;\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/965dd1acd0ce5b225d85e2c55cc097856e0e9f3c", "code_v0_no_empty_lines": "Node::dominates函数返回布尔值，在遇到死代码时保守返回false，可能导致标量替换机会被错过。", "code_v1_no_empty_lines": "-bool MemNode::all_controls_dominate(Node* dom, Node* sub) {\n+Node::DomResult MemNode::maybe_all_controls_dominate(Node* dom, Node* sub) {\n   if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top())\n-    return false; // Conservative answer for dead code\n+    return DomResult::EncounteredDeadCode; // Conservative answer for dead code\n   ...\n-    return only_dominating_controls;\n+    return only_dominating_controls ? DomResult::Dominate : DomResult::NotDominate;\n }", "target": "-bool MemNode::all_controls_dominate(Node* dom, Node* sub) {\n+Node::DomResult MemNode::maybe_all_controls_dominate(Node* dom, Node* sub) {\n   if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top())\n-    return false; // Conservative answer for dead code\n+    return DomResult::EncounteredDeadCode; // Conservative answer for dead code\n   ...\n-    return only_dominating_controls;\n+    return only_dominating_controls ? DomResult::Dominate : DomResult::NotDominate;\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Node::dominates函数返回布尔值，在遇到死代码时保守返回false，可能导致标量替换机会被错过。优化后：引入DomResult枚举（Dominate/NotDominate/EncounteredDeadCode），区分明确支配关系、明确不支配关系和死代码情况。思路：通过更精确的支配关系判断，在IGVN（增量全局值编号）阶段能识别更多标量替换机会，特别是处理GC屏障时，增强C2编译器的标量替换优化能力。"}
{"id": 807, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+虚拟线程优化", "optimization_description": "优化前：虚拟线程在获取JFR字符串池监视器时可能发生挂起，导致性能下降和潜在的死锁风险。优化后：在获取监视器前显式固定虚拟线程，确保虚拟线程在关键操作期间保持运行状态。优化思路：通过添加pinVirtualThread字段和相应的逻辑判断，在虚拟线程需要访问JFR字符串池时进行固定，避免因挂起导致的性能问题和并发问题。", "original_code": "虚拟线程在获取JFR字符串池监视器时可能发生挂起，导致性能下降和潜在的死锁风险。", "optimized_code": "static jobject create_new_event_writer(JfrBuffer* buffer, JfrThreadLocal* tl, TRAPS) {\n  ...\n  static const char signature[] = \"(JJJZZ)V\";\n  ...\n  args.push_int((jint)JNI_TRUE); // valid\n  args.push_int(tl->is_excluded() ? (jint)JNI_TRUE : (jint)JNI_FALSE); // excluded\n  ...\n}\n\n改为：\n\nstatic jobject create_new_event_writer(JfrBuffer* buffer, JfrThreadLocal* tl, TRAPS) {\n  ...\n  static const char signature[] = \"(JJJZZZ)V\";\n  ...\n  args.push_int((jint)JNI_TRUE); // valid\n  args.push_int(pin_virtual(THREAD) ? (jint)JNI_TRUE : (jint)JNI_FALSE);\n  args.push_int(tl->is_excluded() ? (jint)JNI_TRUE : (jint)JNI_FALSE); // excluded\n  ...\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/69bd227e6c497eb82c46ab85125610c0b44dc04e", "code_v0_no_empty_lines": "虚拟线程在获取JFR字符串池监视器时可能发生挂起，导致性能下降和潜在的死锁风险。", "code_v1_no_empty_lines": "static jobject create_new_event_writer(JfrBuffer* buffer, JfrThreadLocal* tl, TRAPS) {\n  ...\n  static const char signature[] = \"(JJJZZ)V\";\n  ...\n  args.push_int((jint)JNI_TRUE); // valid\n  args.push_int(tl->is_excluded() ? (jint)JNI_TRUE : (jint)JNI_FALSE); // excluded\n  ...\n}\n\n改为：\n\nstatic jobject create_new_event_writer(JfrBuffer* buffer, JfrThreadLocal* tl, TRAPS) {\n  ...\n  static const char signature[] = \"(JJJZZZ)V\";\n  ...\n  args.push_int((jint)JNI_TRUE); // valid\n  args.push_int(pin_virtual(THREAD) ? (jint)JNI_TRUE : (jint)JNI_FALSE);\n  args.push_int(tl->is_excluded() ? (jint)JNI_TRUE : (jint)JNI_FALSE); // excluded\n  ...\n}", "target": "static jobject create_new_event_writer(JfrBuffer* buffer, JfrThreadLocal* tl, TRAPS) {\n  ...\n  static const char signature[] = \"(JJJZZ)V\";\n  ...\n  args.push_int((jint)JNI_TRUE); // valid\n  args.push_int(tl->is_excluded() ? (jint)JNI_TRUE : (jint)JNI_FALSE); // excluded\n  ...\n}\n\n改为：\n\nstatic jobject create_new_event_writer(JfrBuffer* buffer, JfrThreadLocal* tl, TRAPS) {\n  ...\n  static const char signature[] = \"(JJJZZZ)V\";\n  ...\n  args.push_int((jint)JNI_TRUE); // valid\n  args.push_int(pin_virtual(THREAD) ? (jint)JNI_TRUE : (jint)JNI_FALSE);\n  args.push_int(tl->is_excluded() ? (jint)JNI_TRUE : (jint)JNI_FALSE); // excluded\n  ...\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：虚拟线程在获取JFR字符串池监视器时可能发生挂起，导致性能下降和潜在的死锁风险。优化后：在获取监视器前显式固定虚拟线程，确保虚拟线程在关键操作期间保持运行状态。优化思路：通过添加pinVirtualThread字段和相应的逻辑判断，在虚拟线程需要访问JFR字符串池时进行固定，避免因挂起导致的性能问题和并发问题。"}
{"id": 808, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+内联优化", "optimization_description": "优化前：Continuation.pin()和Continuation.unpin()方法通过常规Java方法调用，存在方法调用开销。优化后：将这两个方法声明为编译器内联函数，在C2编译器（HotSpot JVM的优化编译器）中实现内联处理，直接生成高效的机器码，避免了方法调用的开销，提高了虚拟线程和协程操作的性能。", "original_code": "Continuation.pin()和Continuation.unpin()方法通过常规Java方法调用，存在方法调用开销。", "optimized_code": "case vmIntrinsics::_Continuation_pin:          return inline_native_Continuation_pinning(false);\ncase vmIntrinsics::_Continuation_unpin:        return inline_native_Continuation_pinning(true);", "source_url": "https://github.com/openjdk/riscv-port/commit/fead3cf54130e3ab10f94a94dfbd382e4cb1e597", "code_v0_no_empty_lines": "Continuation.pin()和Continuation.unpin()方法通过常规Java方法调用，存在方法调用开销。", "code_v1_no_empty_lines": "case vmIntrinsics::_Continuation_pin:          return inline_native_Continuation_pinning(false);\ncase vmIntrinsics::_Continuation_unpin:        return inline_native_Continuation_pinning(true);", "target": "case vmIntrinsics::_Continuation_pin:          return inline_native_Continuation_pinning(false);\ncase vmIntrinsics::_Continuation_unpin:        return inline_native_Continuation_pinning(true);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Continuation.pin()和Continuation.unpin()方法通过常规Java方法调用，存在方法调用开销。优化后：将这两个方法声明为编译器内联函数，在C2编译器（HotSpot JVM的优化编译器）中实现内联处理，直接生成高效的机器码，避免了方法调用的开销，提高了虚拟线程和协程操作的性能。"}
{"id": 809, "source": "riscv-dataset-excel", "optimization_type": "代码重构+内存管理优化", "optimization_description": "优化前：软引用处理逻辑分散在驱动循环函数中，通过参数传递清理状态。优化后：将软引用处理逻辑移出驱动循环，通过ZGenerationOld对象的状态管理，新增uses_clear_all_soft_reference_policy()方法查询策略。优化思路：解耦软引用处理逻辑与GC驱动循环，提高代码模块化，使内存管理策略更清晰独立。", "original_code": "软引用处理逻辑分散在驱动循环函数中，通过参数传递清理状态。", "optimized_code": "- const bool clear_soft_refs = should_clear_soft_references(request.cause());\n+ const bool clear_all = should_clear_all_soft_references(request.cause());\n- void handle_alloc_stalls(bool cleared_soft_refs) const;\n+ void handle_alloc_stalls() const;\n+ bool uses_clear_all_soft_reference_policy() const;", "source_url": "https://github.com/openjdk/riscv-port/commit/9cbf685b0b1ade5e6ddebfeec225b2efb5cf4cfc", "code_v0_no_empty_lines": "软引用处理逻辑分散在驱动循环函数中，通过参数传递清理状态。", "code_v1_no_empty_lines": "- const bool clear_soft_refs = should_clear_soft_references(request.cause());\n+ const bool clear_all = should_clear_all_soft_references(request.cause());\n- void handle_alloc_stalls(bool cleared_soft_refs) const;\n+ void handle_alloc_stalls() const;\n+ bool uses_clear_all_soft_reference_policy() const;", "target": "- const bool clear_soft_refs = should_clear_soft_references(request.cause());\n+ const bool clear_all = should_clear_all_soft_references(request.cause());\n- void handle_alloc_stalls(bool cleared_soft_refs) const;\n+ void handle_alloc_stalls() const;\n+ bool uses_clear_all_soft_reference_policy() const;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：软引用处理逻辑分散在驱动循环函数中，通过参数传递清理状态。优化后：将软引用处理逻辑移出驱动循环，通过ZGenerationOld对象的状态管理，新增uses_clear_all_soft_reference_policy()方法查询策略。优化思路：解耦软引用处理逻辑与GC驱动循环，提高代码模块化，使内存管理策略更清晰独立。"}
{"id": 810, "source": "riscv-dataset-excel", "optimization_type": "性能优化+代码简化", "optimization_description": "性能提升：优化前使用java_lang_Class::is_instance(obj)函数调用检查对象是否为Class实例，涉及虚函数调用和类型检查开销。优化后直接比较obj_klass与预定义的vmClasses::Class_klass()，减少函数调用开销，简化代码路径。思路：在断言和验证代码中，避免不必要的运行时检查，利用已知的类元数据直接比较，提高性能。", "original_code": "// No original code extracted from description\n", "optimized_code": "- if (Universe::is_fully_initialized() && java_lang_Class::is_instance(obj)) {\n+ if (Universe::is_fully_initialized() && (obj_klass == vmClasses::Class_klass())) {\n- if (java_lang_Class::is_instance(obj)) {\n+ if (obj_klass == vmClasses::Class_klass()) {", "source_url": "https://github.com/openjdk/riscv-port/commit/e297e8817f486e4af850c97fcff859c3e9a9e21c", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- if (Universe::is_fully_initialized() && java_lang_Class::is_instance(obj)) {\n+ if (Universe::is_fully_initialized() && (obj_klass == vmClasses::Class_klass())) {\n- if (java_lang_Class::is_instance(obj)) {\n+ if (obj_klass == vmClasses::Class_klass()) {", "target": "- if (Universe::is_fully_initialized() && java_lang_Class::is_instance(obj)) {\n+ if (Universe::is_fully_initialized() && (obj_klass == vmClasses::Class_klass())) {\n- if (java_lang_Class::is_instance(obj)) {\n+ if (obj_klass == vmClasses::Class_klass()) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升：优化前使用java_lang_Class::is_instance(obj)函数调用检查对象是否为Class实例，涉及虚函数调用和类型检查开销。优化后直接比较obj_klass与预定义的vmClasses::Class_klass()，减少函数调用开销，简化代码路径。思路：在断言和验证代码中，避免不必要的运行时检查，利用已知的类元数据直接比较，提高性能。"}
{"id": 811, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+内存布局优化", "optimization_description": "优化前：Exchanger使用基于碰撞检测和版本号（bound字段）的算法来管理竞技场大小，在虚拟线程场景下存在性能瓶颈。优化后：改为基于随机采样的算法，每个线程使用XorShift生成随机索引，通过misses变量直接编码竞技场增长（第三次碰撞时）和收缩（第二次spinout时）规则，减少内存争用和虚假共享。思路：通过更均匀的随机分布减少热点，优化虚拟线程下的并发性能，同时通过@Contended填充Slot对象避免缓存行共享。", "original_code": "Exchanger使用基于碰撞检测和版本号（bound字段）的算法来管理竞技场大小，在虚拟线程场景下存在性能瓶颈。", "optimized_code": "- 旧算法：基于碰撞检测和版本号控制竞技场大小\n+ 新算法：基于随机采样控制竞技场大小，使用XorShift生成随机索引，通过misses变量直接编码增长/收缩规则", "source_url": "https://github.com/openjdk/riscv-port/commit/ab8071d28027ecbf5e8984c30b35fa1c2d934de7", "code_v0_no_empty_lines": "Exchanger使用基于碰撞检测和版本号（bound字段）的算法来管理竞技场大小，在虚拟线程场景下存在性能瓶颈。", "code_v1_no_empty_lines": "- 旧算法：基于碰撞检测和版本号控制竞技场大小\n+ 新算法：基于随机采样控制竞技场大小，使用XorShift生成随机索引，通过misses变量直接编码增长/收缩规则", "target": "- 旧算法：基于碰撞检测和版本号控制竞技场大小\n+ 新算法：基于随机采样控制竞技场大小，使用XorShift生成随机索引，通过misses变量直接编码增长/收缩规则", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Exchanger使用基于碰撞检测和版本号（bound字段）的算法来管理竞技场大小，在虚拟线程场景下存在性能瓶颈。优化后：改为基于随机采样的算法，每个线程使用XorShift生成随机索引，通过misses变量直接编码竞技场增长（第三次碰撞时）和收缩（第二次spinout时）规则，减少内存争用和虚假共享。思路：通过更均匀的随机分布减少热点，优化虚拟线程下的并发性能，同时通过@Contended填充Slot对象避免缓存行共享。"}
{"id": 812, "source": "riscv-dataset-excel", "optimization_type": "启动性能优化+内存访问优化", "optimization_description": "优化前：VarHandle内存访问需要复杂的组合器链（combinator chains）来计算偏移量，增加了启动时的开销。优化后：通过简化组合器链，将布局（MemoryLayout）和基础偏移（base）作为参数直接传递，减少了运行时计算。关键修改包括：1) 扩展VarForm参数列表以包含MemoryLayout和两个long参数；2) 重构checkReadOnly为checkSegment以验证布局；3) 修改所有访问方法（get/set/getVolatile等）签名以接收布局和偏移参数。这减少了启动时的组合器链构建开销，提高了内存访问var handles的初始化速度。", "original_code": "VarHandle内存访问需要复杂的组合器链（combinator chains）来计算偏移量，增加了启动时的开销。", "optimized_code": "static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, long.class);\n+static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n\nstatic $type$ get(VarHandle ob, Object obb, long base) {\n+static $type$ get(VarHandle ob, Object obb, Object encl, long base, long offset) {\n    VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n    AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+    AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);", "source_url": "https://github.com/openjdk/riscv-port/commit/0e8fe3550b628c6617ac7593d7e17ef7d9bc0869", "code_v0_no_empty_lines": "VarHandle内存访问需要复杂的组合器链（combinator chains）来计算偏移量，增加了启动时的开销。", "code_v1_no_empty_lines": "static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, long.class);\n+static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n\nstatic $type$ get(VarHandle ob, Object obb, long base) {\n+static $type$ get(VarHandle ob, Object obb, Object encl, long base, long offset) {\n    VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n    AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+    AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);", "target": "static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, long.class);\n+static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n\nstatic $type$ get(VarHandle ob, Object obb, long base) {\n+static $type$ get(VarHandle ob, Object obb, Object encl, long base, long offset) {\n    VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n    AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+    AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：VarHandle内存访问需要复杂的组合器链（combinator chains）来计算偏移量，增加了启动时的开销。优化后：通过简化组合器链，将布局（MemoryLayout）和基础偏移（base）作为参数直接传递，减少了运行时计算。关键修改包括：1) 扩展VarForm参数列表以包含MemoryLayout和两个long参数；2) 重构checkReadOnly为checkSegment以验证布局；3) 修改所有访问方法（get/set/getVolatile等）签名以接收布局和偏移参数。这减少了启动时的组合器链构建开销，提高了内存访问var handles的初始化速度。"}
{"id": 813, "source": "riscv-dataset-excel", "optimization_type": "性能优化+内存优化", "optimization_description": "优化前：通过Wrapper.forPrimitiveType()方法查找基本类型描述符，涉及方法调用和对象创建开销。优化后：直接调用ConstantUtils.forPrimitiveType()静态方法，利用预缓存的PrimitiveClassDescImpl常量（如CD_int、CD_long等），避免重复创建PrimitiveClassDescImpl对象。优化思路：通过静态导入和常量缓存消除方法调用开销，减少对象分配，提升ClassFile API中MethodTypeDesc#ofDescriptor方法的性能。", "original_code": "通过Wrapper.forPrimitiveType()方法查找基本类型描述符，涉及方法调用和对象创建开销。", "optimized_code": "static ClassDesc ofDescriptor(String descriptor) {\n    // implicit null-check\n    return (descriptor.length() == 1)\n           ? Wrapper.forPrimitiveType(descriptor.charAt(0)).basicClassDescriptor()\n           : ReferenceClassDescImpl.of(descriptor);\n}\n\n改为：\n\nstatic ClassDesc ofDescriptor(String descriptor) {\n    // implicit null-check\n    return (descriptor.length() == 1)\n           ? forPrimitiveType(descriptor, 0)\n           : ReferenceClassDescImpl.of(descriptor);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/3aeb6733f958bc2b0132494b8ac51a4cfa6b98de", "code_v0_no_empty_lines": "通过Wrapper.forPrimitiveType()方法查找基本类型描述符，涉及方法调用和对象创建开销。", "code_v1_no_empty_lines": "static ClassDesc ofDescriptor(String descriptor) {\n    // implicit null-check\n    return (descriptor.length() == 1)\n           ? Wrapper.forPrimitiveType(descriptor.charAt(0)).basicClassDescriptor()\n           : ReferenceClassDescImpl.of(descriptor);\n}\n\n改为：\n\nstatic ClassDesc ofDescriptor(String descriptor) {\n    // implicit null-check\n    return (descriptor.length() == 1)\n           ? forPrimitiveType(descriptor, 0)\n           : ReferenceClassDescImpl.of(descriptor);\n}", "target": "static ClassDesc ofDescriptor(String descriptor) {\n    // implicit null-check\n    return (descriptor.length() == 1)\n           ? Wrapper.forPrimitiveType(descriptor.charAt(0)).basicClassDescriptor()\n           : ReferenceClassDescImpl.of(descriptor);\n}\n\n改为：\n\nstatic ClassDesc ofDescriptor(String descriptor) {\n    // implicit null-check\n    return (descriptor.length() == 1)\n           ? forPrimitiveType(descriptor, 0)\n           : ReferenceClassDescImpl.of(descriptor);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：通过Wrapper.forPrimitiveType()方法查找基本类型描述符，涉及方法调用和对象创建开销。优化后：直接调用ConstantUtils.forPrimitiveType()静态方法，利用预缓存的PrimitiveClassDescImpl常量（如CD_int、CD_long等），避免重复创建PrimitiveClassDescImpl对象。优化思路：通过静态导入和常量缓存消除方法调用开销，减少对象分配，提升ClassFile API中MethodTypeDesc#ofDescriptor方法的性能。"}
{"id": 814, "source": "riscv-dataset-excel", "optimization_type": "锁优化+内存布局优化", "optimization_description": "优化前：RISC-V架构的轻量级锁实现不支持新的Object-to-ObjectMonitor映射机制（UseObjectMonitorTable），当启用该功能时只能走慢速路径。优化后：1. 修改fast_lock_lightweight和fast_unlock_lightweight函数签名，增加box参数用于缓存ObjectMonitor指针；2. 实现OMCache查找机制，通过缓存表快速定位ObjectMonitor，避免每次锁操作都走慢速路径；3. 统一处理带缓存和不带缓存的两种情况，使用条件编译和标签跳转。优化思路：为RISC-V架构适配新的对象监视器映射方案，通过缓存机制减少锁操作开销，提升并发性能。", "original_code": "RISC-V架构的轻量级锁实现不支持新的Object-to-ObjectMonitor映射机制（UseObjectMonitorTable），当启用该功能时只能走慢速路径。", "optimized_code": "-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register tmp1, Register tmp2, Register tmp3) {\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box,\n+                                              Register tmp1, Register tmp2, Register tmp3) {\n-    assert_different_registers(obj, tmp1, tmp2, tmp3, flag, t0);\n+    assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n+  if (UseObjectMonitorTable) {\n+    // Clear cache in case fast locking succeeds.\n+    sd(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n-    const Register tmp3_t = tmp3;\n+    const Register tmp3_t = tmp3;\n+  if (!UseObjectMonitorTable) {\n+    // mark contains the tagged ObjectMonitor*.\n+    const Register tmp1_tagged_monitor = tmp1_mark;\n+    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register tmp2_owner_addr = tmp2;\n+    const Register tmp3_owner = tmp3;\n+    // Compute owner address.\n+    la(tmp2_owner_addr, Address(tmp1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+    // CAS owner (null => current thread).\n+    cmpxchg(/*addr*/ tmp2_owner_addr, /*expected*/ zr, /*new*/ xthread, Assembler::int64,\n+            /*acquire*/ Assembler::aq, /*release*/ Assembler::relaxed, /*result*/ tmp3_owner);\n+    beqz(tmp3_owner, locked);\n+    // Check if recursive.\n+    bne(tmp3_owner, xthread, slow_path);\n+    // Recursive.\n+    increment(Address(tmp1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1, tmp2, tmp3);\n+  } else {\n+    // OMCache lookup not supported yet. Take the slowpath.\n+    j(slow_path);\n+  }\n+  } else {\n+    Label monitor_found;\n+    // Load cache address\n+    la(tmp3_t, Address(xthread, JavaThread::om_cache_oops_offset()));\n+    const int num_unrolled = 2;\n+    for (int i = 0; i < num_unrolled; i++) {\n+      ld(tmp1, Address(tmp3_t));\n+      beq(obj, tmp1, monitor_found);\n+      add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+    }\n+    Label loop;\n+    // Search for obj in cache.\n+    bind(loop);\n+    // Check for match.\n+    ld(tmp1, Address(tmp3_t));\n+    beq(obj, tmp1, monitor_found);\n+    // Search until null encountered, guaranteed _null_sentinel at end.\n+    add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+    bnez(tmp1, loop);\n+    // Cache Miss. Take the slowpath.\n+    j(slow_path);\n+    bind(monitor_found);\n+    ld(tmp1_monitor, Address(tmp3_t, OMCache::oop_to_monitor_difference()));\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/c4cf1e93bb22bf7c65ce1943fff91f74839434df", "code_v0_no_empty_lines": "RISC-V架构的轻量级锁实现不支持新的Object-to-ObjectMonitor映射机制（UseObjectMonitorTable），当启用该功能时只能走慢速路径。", "code_v1_no_empty_lines": "-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register tmp1, Register tmp2, Register tmp3) {\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box,\n+                                              Register tmp1, Register tmp2, Register tmp3) {\n-    assert_different_registers(obj, tmp1, tmp2, tmp3, flag, t0);\n+    assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n+  if (UseObjectMonitorTable) {\n+    // Clear cache in case fast locking succeeds.\n+    sd(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n-    const Register tmp3_t = tmp3;\n+    const Register tmp3_t = tmp3;\n+  if (!UseObjectMonitorTable) {\n+    // mark contains the tagged ObjectMonitor*.\n+    const Register tmp1_tagged_monitor = tmp1_mark;\n+    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register tmp2_owner_addr = tmp2;\n+    const Register tmp3_owner = tmp3;\n+    // Compute owner address.\n+    la(tmp2_owner_addr, Address(tmp1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+    // CAS owner (null => current thread).\n+    cmpxchg(/*addr*/ tmp2_owner_addr, /*expected*/ zr, /*new*/ xthread, Assembler::int64,\n+            /*acquire*/ Assembler::aq, /*release*/ Assembler::relaxed, /*result*/ tmp3_owner);\n+    beqz(tmp3_owner, locked);\n+    // Check if recursive.\n+    bne(tmp3_owner, xthread, slow_path);\n+    // Recursive.\n+    increment(Address(tmp1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1, tmp2, tmp3);\n+  } else {\n+    // OMCache lookup not supported yet. Take the slowpath.\n+    j(slow_path);\n+  }\n+  } else {\n+    Label monitor_found;\n+    // Load cache address\n+    la(tmp3_t, Address(xthread, JavaThread::om_cache_oops_offset()));\n+    const int num_unrolled = 2;\n+    for (int i = 0; i < num_unrolled; i++) {\n+      ld(tmp1, Address(tmp3_t));\n+      beq(obj, tmp1, monitor_found);\n+      add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+    }\n+    Label loop;\n+    // Search for obj in cache.\n+    bind(loop);\n+    // Check for match.\n+    ld(tmp1, Address(tmp3_t));\n+    beq(obj, tmp1, monitor_found);\n+    // Search until null encountered, guaranteed _null_sentinel at end.\n+    add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+    bnez(tmp1, loop);\n+    // Cache Miss. Take the slowpath.\n+    j(slow_path);\n+    bind(monitor_found);\n+    ld(tmp1_monitor, Address(tmp3_t, OMCache::oop_to_monitor_difference()));\n+  }", "target": "-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register tmp1, Register tmp2, Register tmp3) {\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box,\n+                                              Register tmp1, Register tmp2, Register tmp3) {\n-    assert_different_registers(obj, tmp1, tmp2, tmp3, flag, t0);\n+    assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n+  if (UseObjectMonitorTable) {\n+    // Clear cache in case fast locking succeeds.\n+    sd(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n-    const Register tmp3_t = tmp3;\n+    const Register tmp3_t = tmp3;\n+  if (!UseObjectMonitorTable) {\n+    // mark contains the tagged ObjectMonitor*.\n+    const Register tmp1_tagged_monitor = tmp1_mark;\n+    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register tmp2_owner_addr = tmp2;\n+    const Register tmp3_owner = tmp3;\n+    // Compute owner address.\n+    la(tmp2_owner_addr, Address(tmp1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+    // CAS owner (null => current thread).\n+    cmpxchg(/*addr*/ tmp2_owner_addr, /*expected*/ zr, /*new*/ xthread, Assembler::int64,\n+            /*acquire*/ Assembler::aq, /*release*/ Assembler::relaxed, /*result*/ tmp3_owner);\n+    beqz(tmp3_owner, locked);\n+    // Check if recursive.\n+    bne(tmp3_owner, xthread, slow_path);\n+    // Recursive.\n+    increment(Address(tmp1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1, tmp2, tmp3);\n+  } else {\n+    // OMCache lookup not supported yet. Take the slowpath.\n+    j(slow_path);\n+  }\n+  } else {\n+    Label monitor_found;\n+    // Load cache address\n+    la(tmp3_t, Address(xthread, JavaThread::om_cache_oops_offset()));\n+    const int num_unrolled = 2;\n+    for (int i = 0; i < num_unrolled; i++) {\n+      ld(tmp1, Address(tmp3_t));\n+      beq(obj, tmp1, monitor_found);\n+      add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+    }\n+    Label loop;\n+    // Search for obj in cache.\n+    bind(loop);\n+    // Check for match.\n+    ld(tmp1, Address(tmp3_t));\n+    beq(obj, tmp1, monitor_found);\n+    // Search until null encountered, guaranteed _null_sentinel at end.\n+    add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+    bnez(tmp1, loop);\n+    // Cache Miss. Take the slowpath.\n+    j(slow_path);\n+    bind(monitor_found);\n+    ld(tmp1_monitor, Address(tmp3_t, OMCache::oop_to_monitor_difference()));\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V架构的轻量级锁实现不支持新的Object-to-ObjectMonitor映射机制（UseObjectMonitorTable），当启用该功能时只能走慢速路径。优化后：1. 修改fast_lock_lightweight和fast_unlock_lightweight函数签名，增加box参数用于缓存ObjectMonitor指针；2. 实现OMCache查找机制，通过缓存表快速定位ObjectMonitor，避免每次锁操作都走慢速路径；3. 统一处理带缓存和不带缓存的两种情况，使用条件编译和标签跳转。优化思路：为RISC-V架构适配新的对象监视器映射方案，通过缓存机制减少锁操作开销，提升并发性能。"}
{"id": 815, "source": "riscv-dataset-excel", "optimization_type": "内存布局优化", "optimization_description": "优化前：CDS归档堆的最小GC区域对齐要求为1MB，仅考虑G1收集器。优化后：将最小对齐要求降低至256KB，同时兼容G1（最小1MB）和Shenandoah（最小256KB）收集器。优化思路：通过降低对齐约束，减少内存浪费，提高CDS归档堆的内存利用率，特别是在使用Shenandoah收集器时能显著节省内存空间。", "original_code": "CDS归档堆的最小GC区域对齐要求为1MB，仅考虑G1收集器。", "optimized_code": "- static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n+ static constexpr int MIN_GC_REGION_ALIGNMENT = 256 * K;", "source_url": "https://github.com/openjdk/riscv-port/commit/598169756c903bb1f77e35ea32717043bc166e3c", "code_v0_no_empty_lines": "CDS归档堆的最小GC区域对齐要求为1MB，仅考虑G1收集器。", "code_v1_no_empty_lines": "- static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n+ static constexpr int MIN_GC_REGION_ALIGNMENT = 256 * K;", "target": "- static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n+ static constexpr int MIN_GC_REGION_ALIGNMENT = 256 * K;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CDS归档堆的最小GC区域对齐要求为1MB，仅考虑G1收集器。优化后：将最小对齐要求降低至256KB，同时兼容G1（最小1MB）和Shenandoah（最小256KB）收集器。优化思路：通过降低对齐约束，减少内存浪费，提高CDS归档堆的内存利用率，特别是在使用Shenandoah收集器时能显著节省内存空间。"}
{"id": 816, "source": "riscv-dataset-excel", "optimization_type": "代码重构+性能优化", "optimization_description": "优化前：AnnotationImpl及其相关记录类实现Util.Writable接口，包含writeTo方法用于序列化，OfConstantImpl接口作为中间层提供默认实现。优化后：移除所有Util.Writable接口实现，删除writeTo方法，简化OfConstant接口定义（移除permits子句），将序列化逻辑集中到AnnotationReader中。优化思路：通过移除冗余的序列化代码，减少类文件大小和内存占用，提高代码可维护性，同时可能提升运行时性能（减少方法调用和代码膨胀）。", "original_code": "AnnotationImpl及其相关记录类实现Util.Writable接口，包含writeTo方法用于序列化，OfConstantImpl接口作为中间层提供默认实现。", "optimized_code": "- public record AnnotationImpl(Utf8Entry className, List<AnnotationElement> elements)\n        implements Annotation, Util.Writable {\n+ public record AnnotationImpl(Utf8Entry className, List<AnnotationElement> elements)\n        implements Annotation {\n- public sealed interface OfConstantImpl extends AnnotationValue.OfConstant, Util.Writable {\n-     @Override\n-     default void writeTo(BufWriterImpl buf) {\n-         buf.writeU1(tag());\n-         buf.writeIndex(constant());\n-     }\n- }", "source_url": "https://github.com/openjdk/riscv-port/commit/1ebf2cf639300728ffc024784f5dc1704317b0b3", "code_v0_no_empty_lines": "AnnotationImpl及其相关记录类实现Util.Writable接口，包含writeTo方法用于序列化，OfConstantImpl接口作为中间层提供默认实现。", "code_v1_no_empty_lines": "- public record AnnotationImpl(Utf8Entry className, List<AnnotationElement> elements)\n        implements Annotation, Util.Writable {\n+ public record AnnotationImpl(Utf8Entry className, List<AnnotationElement> elements)\n        implements Annotation {\n- public sealed interface OfConstantImpl extends AnnotationValue.OfConstant, Util.Writable {\n-     @Override\n-     default void writeTo(BufWriterImpl buf) {\n-         buf.writeU1(tag());\n-         buf.writeIndex(constant());\n-     }\n- }", "target": "- public record AnnotationImpl(Utf8Entry className, List<AnnotationElement> elements)\n        implements Annotation, Util.Writable {\n+ public record AnnotationImpl(Utf8Entry className, List<AnnotationElement> elements)\n        implements Annotation {\n- public sealed interface OfConstantImpl extends AnnotationValue.OfConstant, Util.Writable {\n-     @Override\n-     default void writeTo(BufWriterImpl buf) {\n-         buf.writeU1(tag());\n-         buf.writeIndex(constant());\n-     }\n- }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AnnotationImpl及其相关记录类实现Util.Writable接口，包含writeTo方法用于序列化，OfConstantImpl接口作为中间层提供默认实现。优化后：移除所有Util.Writable接口实现，删除writeTo方法，简化OfConstant接口定义（移除permits子句），将序列化逻辑集中到AnnotationReader中。优化思路：通过移除冗余的序列化代码，减少类文件大小和内存占用，提高代码可维护性，同时可能提升运行时性能（减少方法调用和代码膨胀）。"}
{"id": 817, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+断言逻辑优化", "optimization_description": "优化前：ShenandoahHeap::is_in()方法同时检查内存地址是否在堆保留区域和活动区域，导致断言逻辑不够精确。优化后：将检查拆分为两个独立步骤：1) 使用is_in_reserved()检查地址是否在堆保留区域内；2) 使用is_in()专门检查地址是否在活动区域。优化思路：分离关注点，使断言逻辑更清晰准确，避免在调试和验证时产生误导信息，提高垃圾回收器的可靠性和可维护性。", "original_code": "ShenandoahHeap::is_in()方法同时检查内存地址是否在堆保留区域和活动区域，导致断言逻辑不够精确。", "optimized_code": "- if (!heap->is_in(obj)) {\n+ if (!heap->is_in_reserved(obj)) {\n- if (obj != nullptr && !heap->is_in(obj)) {\n+ if (obj != nullptr && !heap->is_in_reserved(obj)) {\n+ if (!heap->is_in(obj)) {\n+   print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                 \"Object should be in active region area\",\n+                 file, line);\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/b9d49dcef22ab81a087d890bbac0329a5244a2ef", "code_v0_no_empty_lines": "ShenandoahHeap::is_in()方法同时检查内存地址是否在堆保留区域和活动区域，导致断言逻辑不够精确。", "code_v1_no_empty_lines": "- if (!heap->is_in(obj)) {\n+ if (!heap->is_in_reserved(obj)) {\n- if (obj != nullptr && !heap->is_in(obj)) {\n+ if (obj != nullptr && !heap->is_in_reserved(obj)) {\n+ if (!heap->is_in(obj)) {\n+   print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                 \"Object should be in active region area\",\n+                 file, line);\n+ }", "target": "- if (!heap->is_in(obj)) {\n+ if (!heap->is_in_reserved(obj)) {\n- if (obj != nullptr && !heap->is_in(obj)) {\n+ if (obj != nullptr && !heap->is_in_reserved(obj)) {\n+ if (!heap->is_in(obj)) {\n+   print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                 \"Object should be in active region area\",\n+                 file, line);\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ShenandoahHeap::is_in()方法同时检查内存地址是否在堆保留区域和活动区域，导致断言逻辑不够精确。优化后：将检查拆分为两个独立步骤：1) 使用is_in_reserved()检查地址是否在堆保留区域内；2) 使用is_in()专门检查地址是否在活动区域。优化思路：分离关注点，使断言逻辑更清晰准确，避免在调试和验证时产生误导信息，提高垃圾回收器的可靠性和可维护性。"}
{"id": 818, "source": "riscv-dataset-excel", "optimization_type": "功能扩展+内存管理优化", "optimization_description": "优化前：Shenandoah垃圾收集器不支持CDS（Class Data Sharing）的归档堆对象功能，无法利用CDS的启动性能优势。优化后：通过添加allocate_loaded_archive_space()和complete_loaded_archive_space()方法，使Shenandoah能够分配和管理CDS归档堆对象的内存空间，包括处理大对象分配时的区域状态转换（从巨型区域转为常规区域）。优化思路：扩展Shenandoah的内存管理功能以兼容CDS归档堆，通过特殊的内存分配路径和区域状态调整，确保归档对象在堆中的正确布局，同时保持GC不变性，从而提升JVM启动性能。", "original_code": "Shenandoah垃圾收集器不支持CDS（Class Data Sharing）的归档堆对象功能，无法利用CDS的启动性能优势。", "optimized_code": "--- a/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp\n+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp\n@@ -2482,3 +2483,80 @@ bool ShenandoahHeap::requires_barriers(stackChunkOop obj) const {\n \n   return false;\n }\n+\n+HeapWord* ShenandoahHeap::allocate_loaded_archive_space(size_t size) {\n+#if INCLUDE_CDS_JAVA_HEAP\n+  // CDS wants a continuous memory range to load a bunch of objects.\n+  // This effectively bypasses normal allocation paths, and requires\n+  // a bit of massaging to unbreak GC invariants.\n+\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);\n+\n+  // Easy case: a single regular region, no further adjustments needed.\n+  if (!ShenandoahHeapRegion::requires_humongous(size)) {\n+    return allocate_memory(req);\n+  }\n+\n+  // Hard case: the requested size would cause a humongous allocation.\n+  // We need to make sure it looks like regular allocation to the rest of GC.\n+\n+  // CDS code would guarantee no objects straddle multiple regions, as long as\n+  // regions are as large as MIN_GC_REGION_ALIGNMENT. It is impractical at this\n+  // point to deal with case when Shenandoah runs with smaller regions.\n+  // TODO: This check can be dropped once MIN_GC_REGION_ALIGNMENT agrees more with Shenandoah.\n+  if (ShenandoahHeapRegion::region_size_bytes() < ArchiveHeapWriter::MIN_GC_REGION_ALIGNMENT) {\n+    return nullptr;\n+  }\n+\n+  HeapWord* mem = allocate_memory(req);\n+  size_t start_idx = heap_region_index_containing(mem);\n+  size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n+\n+  // Flip humongous -> regular.\n+  {\n+    ShenandoahHeapLocker locker(lock(), false);\n+    for (size_t c = start_idx; c < start_idx + num_regions; c++) {\n+      get_region(c)->make_regular_bypass();\n+    }\n+  }\n+\n+  return mem;\n+#else\n+  assert(false, \"Archive heap loader should not be available, should not be here\");\n+  return nullptr;\n+#endif // INCLUDE_CDS_JAVA_HEAP\n+}\n+\n+void ShenandoahHeap::complete_loaded_archive_space(MemRegion archive_space) {\n+  // Nothing to do here, except checking that heap looks fine.\n+#ifdef ASSERT\n+  HeapWord* start = archive_space.start();\n+  HeapWord* end = archive_space.end();\n+\n+  // No unclaimed space between the objects.\n+  // Objects are properly allocated in correct regions.\n+  HeapWord* cur = start;\n+  while (cur < end) {\n+    oop oop = cast_to_oop(cur);\n+    shenandoah_assert_in_correct_region(nullptr, oop);\n+    cur += oop->size();\n+  }\n+\n+  // No unclaimed tail at the end of archive space.\n+  assert(cur == end,", "source_url": "https://github.com/openjdk/riscv-port/commit/d86e99c3ca94ee8705e44fe2830edd3ceb0a7f64", "code_v0_no_empty_lines": "Shenandoah垃圾收集器不支持CDS（Class Data Sharing）的归档堆对象功能，无法利用CDS的启动性能优势。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp\n+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp\n@@ -2482,3 +2483,80 @@ bool ShenandoahHeap::requires_barriers(stackChunkOop obj) const {\n \n   return false;\n }\n+\n+HeapWord* ShenandoahHeap::allocate_loaded_archive_space(size_t size) {\n+#if INCLUDE_CDS_JAVA_HEAP\n+  // CDS wants a continuous memory range to load a bunch of objects.\n+  // This effectively bypasses normal allocation paths, and requires\n+  // a bit of massaging to unbreak GC invariants.\n+\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);\n+\n+  // Easy case: a single regular region, no further adjustments needed.\n+  if (!ShenandoahHeapRegion::requires_humongous(size)) {\n+    return allocate_memory(req);\n+  }\n+\n+  // Hard case: the requested size would cause a humongous allocation.\n+  // We need to make sure it looks like regular allocation to the rest of GC.\n+\n+  // CDS code would guarantee no objects straddle multiple regions, as long as\n+  // regions are as large as MIN_GC_REGION_ALIGNMENT. It is impractical at this\n+  // point to deal with case when Shenandoah runs with smaller regions.\n+  // TODO: This check can be dropped once MIN_GC_REGION_ALIGNMENT agrees more with Shenandoah.\n+  if (ShenandoahHeapRegion::region_size_bytes() < ArchiveHeapWriter::MIN_GC_REGION_ALIGNMENT) {\n+    return nullptr;\n+  }\n+\n+  HeapWord* mem = allocate_memory(req);\n+  size_t start_idx = heap_region_index_containing(mem);\n+  size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n+\n+  // Flip humongous -> regular.\n+  {\n+    ShenandoahHeapLocker locker(lock(), false);\n+    for (size_t c = start_idx; c < start_idx + num_regions; c++) {\n+      get_region(c)->make_regular_bypass();\n+    }\n+  }\n+\n+  return mem;\n+#else\n+  assert(false, \"Archive heap loader should not be available, should not be here\");\n+  return nullptr;\n+#endif // INCLUDE_CDS_JAVA_HEAP\n+}\n+\n+void ShenandoahHeap::complete_loaded_archive_space(MemRegion archive_space) {\n+  // Nothing to do here, except checking that heap looks fine.\n+#ifdef ASSERT\n+  HeapWord* start = archive_space.start();\n+  HeapWord* end = archive_space.end();\n+\n+  // No unclaimed space between the objects.\n+  // Objects are properly allocated in correct regions.\n+  HeapWord* cur = start;\n+  while (cur < end) {\n+    oop oop = cast_to_oop(cur);\n+    shenandoah_assert_in_correct_region(nullptr, oop);\n+    cur += oop->size();\n+  }\n+\n+  // No unclaimed tail at the end of archive space.\n+  assert(cur == end,", "target": "--- a/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp\n+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp\n@@ -2482,3 +2483,80 @@ bool ShenandoahHeap::requires_barriers(stackChunkOop obj) const {\n \n   return false;\n }\n+\n+HeapWord* ShenandoahHeap::allocate_loaded_archive_space(size_t size) {\n+#if INCLUDE_CDS_JAVA_HEAP\n+  // CDS wants a continuous memory range to load a bunch of objects.\n+  // This effectively bypasses normal allocation paths, and requires\n+  // a bit of massaging to unbreak GC invariants.\n+\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);\n+\n+  // Easy case: a single regular region, no further adjustments needed.\n+  if (!ShenandoahHeapRegion::requires_humongous(size)) {\n+    return allocate_memory(req);\n+  }\n+\n+  // Hard case: the requested size would cause a humongous allocation.\n+  // We need to make sure it looks like regular allocation to the rest of GC.\n+\n+  // CDS code would guarantee no objects straddle multiple regions, as long as\n+  // regions are as large as MIN_GC_REGION_ALIGNMENT. It is impractical at this\n+  // point to deal with case when Shenandoah runs with smaller regions.\n+  // TODO: This check can be dropped once MIN_GC_REGION_ALIGNMENT agrees more with Shenandoah.\n+  if (ShenandoahHeapRegion::region_size_bytes() < ArchiveHeapWriter::MIN_GC_REGION_ALIGNMENT) {\n+    return nullptr;\n+  }\n+\n+  HeapWord* mem = allocate_memory(req);\n+  size_t start_idx = heap_region_index_containing(mem);\n+  size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n+\n+  // Flip humongous -> regular.\n+  {\n+    ShenandoahHeapLocker locker(lock(), false);\n+    for (size_t c = start_idx; c < start_idx + num_regions; c++) {\n+      get_region(c)->make_regular_bypass();\n+    }\n+  }\n+\n+  return mem;\n+#else\n+  assert(false, \"Archive heap loader should not be available, should not be here\");\n+  return nullptr;\n+#endif // INCLUDE_CDS_JAVA_HEAP\n+}\n+\n+void ShenandoahHeap::complete_loaded_archive_space(MemRegion archive_space) {\n+  // Nothing to do here, except checking that heap looks fine.\n+#ifdef ASSERT\n+  HeapWord* start = archive_space.start();\n+  HeapWord* end = archive_space.end();\n+\n+  // No unclaimed space between the objects.\n+  // Objects are properly allocated in correct regions.\n+  HeapWord* cur = start;\n+  while (cur < end) {\n+    oop oop = cast_to_oop(cur);\n+    shenandoah_assert_in_correct_region(nullptr, oop);\n+    cur += oop->size();\n+  }\n+\n+  // No unclaimed tail at the end of archive space.\n+  assert(cur == end,", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Shenandoah垃圾收集器不支持CDS（Class Data Sharing）的归档堆对象功能，无法利用CDS的启动性能优势。优化后：通过添加allocate_loaded_archive_space()和complete_loaded_archive_space()方法，使Shenandoah能够分配和管理CDS归档堆对象的内存空间，包括处理大对象分配时的区域状态转换（从巨型区域转为常规区域）。优化思路：扩展Shenandoah的内存管理功能以兼容CDS归档堆，通过特殊的内存分配路径和区域状态调整，确保归档对象在堆中的正确布局，同时保持GC不变性，从而提升JVM启动性能。"}
{"id": 819, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：BITARRAYMASK、BYTEPOWER、BYTEMASK三个字段为实例字段，每个MergeCollation对象都会创建独立的副本。优化后：将这些字段改为静态常量，所有MergeCollation实例共享同一份内存。优化思路：这些字段是常量值（0x1、3、7），不依赖于任何实例状态，改为static final可减少每个对象的内存开销，提高内存使用效率。", "original_code": "BITARRAYMASK、BYTEPOWER、BYTEMASK三个字段为实例字段，每个MergeCollation对象都会创建独立的副本。", "optimized_code": "-    private final byte BITARRAYMASK = (byte)0x1;\n-    private final int  BYTEPOWER = 3;\n-    private final int  BYTEMASK = (1 << BYTEPOWER) - 1;\n+    private static final byte BITARRAYMASK = (byte)0x1;\n+    private static final int BYTEPOWER = 3;\n+    private static final int BYTEMASK = (1 << BYTEPOWER) - 1;", "source_url": "https://github.com/openjdk/riscv-port/commit/60c9b5cd9f18830f0fb1aea6cb3dc43af3908cc5", "code_v0_no_empty_lines": "BITARRAYMASK、BYTEPOWER、BYTEMASK三个字段为实例字段，每个MergeCollation对象都会创建独立的副本。", "code_v1_no_empty_lines": "-    private final byte BITARRAYMASK = (byte)0x1;\n-    private final int  BYTEPOWER = 3;\n-    private final int  BYTEMASK = (1 << BYTEPOWER) - 1;\n+    private static final byte BITARRAYMASK = (byte)0x1;\n+    private static final int BYTEPOWER = 3;\n+    private static final int BYTEMASK = (1 << BYTEPOWER) - 1;", "target": "-    private final byte BITARRAYMASK = (byte)0x1;\n-    private final int  BYTEPOWER = 3;\n-    private final int  BYTEMASK = (1 << BYTEPOWER) - 1;\n+    private static final byte BITARRAYMASK = (byte)0x1;\n+    private static final int BYTEPOWER = 3;\n+    private static final int BYTEMASK = (1 << BYTEPOWER) - 1;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：BITARRAYMASK、BYTEPOWER、BYTEMASK三个字段为实例字段，每个MergeCollation对象都会创建独立的副本。优化后：将这些字段改为静态常量，所有MergeCollation实例共享同一份内存。优化思路：这些字段是常量值（0x1、3、7），不依赖于任何实例状态，改为static final可减少每个对象的内存开销，提高内存使用效率。"}
{"id": 820, "source": "riscv-dataset-excel", "optimization_type": "字符串拼接性能优化", "optimization_description": "优化前：字符串拼接可能依赖动态生成字节码或通用方法调用，存在运行时开销和内存分配。优化后：引入基于隐藏类的字符串拼接策略，通过预计算常量字符串长度和编码器，生成特化的拼接类（如Concat1），减少运行时计算和内存分配。优化思路：利用隐藏类机制生成高效拼接代码，避免通用路径开销，提升字符串拼接性能。", "original_code": "字符串拼接可能依赖动态生成字节码或通用方法调用，存在运行时开销和内存分配。", "optimized_code": "static abstract class StringConcatBase {\n    @Stable\n    final String[] constants;\n    final int      length;\n    final byte     coder;\n\n    StringConcatBase(String[] constants) {\n        int  length = 0;\n        byte coder  = String.LATIN1;\n        for (String c : constants) {\n            length += c.length();\n            coder  |= c.coder();\n        }\n        this.constants = constants;\n        this.length    = length;\n        this.coder     = coder;\n    }\n}\n\nstatic final class Concat1 extends StringConcatBase {\n    Concat1(String[] constants) {\n        super(constants);\n    }\n\n    @ForceInline\n    String concat0(String value) {\n        int length = stringSize(this.length, value);\n        byte coder = (byte) (this.coder | value.coder());\n        byte[] buf = newArray(length << coder);\n        String prefix = constants[0];\n        prefix.getBytes(buf, 0, coder);\n        value.getBytes(buf, prefix.length(), coder);\n        constants[1].getBytes(buf, prefix.length() + value.length(), coder);\n        return new String(buf, coder);\n    }\n\n    @ForceInline\n    String concat(boolean value) {\n        int length = stringSize(this.length, value);\n        String suffix = constants[1];\n        length -= suffix.length();\n        byte[] buf = newArrayWithSuffix(suffix, length, coder);\n        prepend(length, coder, buf, value, constants[0]);\n        return new String(buf, coder);\n    }\n\n    // ... 其他concat方法类似", "source_url": "https://github.com/openjdk/riscv-port/commit/5022109b2a33a8cf2608eb829098b27641b731a4", "code_v0_no_empty_lines": "字符串拼接可能依赖动态生成字节码或通用方法调用，存在运行时开销和内存分配。", "code_v1_no_empty_lines": "static abstract class StringConcatBase {\n    @Stable\n    final String[] constants;\n    final int      length;\n    final byte     coder;\n\n    StringConcatBase(String[] constants) {\n        int  length = 0;\n        byte coder  = String.LATIN1;\n        for (String c : constants) {\n            length += c.length();\n            coder  |= c.coder();\n        }\n        this.constants = constants;\n        this.length    = length;\n        this.coder     = coder;\n    }\n}\n\nstatic final class Concat1 extends StringConcatBase {\n    Concat1(String[] constants) {\n        super(constants);\n    }\n\n    @ForceInline\n    String concat0(String value) {\n        int length = stringSize(this.length, value);\n        byte coder = (byte) (this.coder | value.coder());\n        byte[] buf = newArray(length << coder);\n        String prefix = constants[0];\n        prefix.getBytes(buf, 0, coder);\n        value.getBytes(buf, prefix.length(), coder);\n        constants[1].getBytes(buf, prefix.length() + value.length(), coder);\n        return new String(buf, coder);\n    }\n\n    @ForceInline\n    String concat(boolean value) {\n        int length = stringSize(this.length, value);\n        String suffix = constants[1];\n        length -= suffix.length();\n        byte[] buf = newArrayWithSuffix(suffix, length, coder);\n        prepend(length, coder, buf, value, constants[0]);\n        return new String(buf, coder);\n    }\n\n    // ... 其他concat方法类似", "target": "static abstract class StringConcatBase {\n    @Stable\n    final String[] constants;\n    final int      length;\n    final byte     coder;\n\n    StringConcatBase(String[] constants) {\n        int  length = 0;\n        byte coder  = String.LATIN1;\n        for (String c : constants) {\n            length += c.length();\n            coder  |= c.coder();\n        }\n        this.constants = constants;\n        this.length    = length;\n        this.coder     = coder;\n    }\n}\n\nstatic final class Concat1 extends StringConcatBase {\n    Concat1(String[] constants) {\n        super(constants);\n    }\n\n    @ForceInline\n    String concat0(String value) {\n        int length = stringSize(this.length, value);\n        byte coder = (byte) (this.coder | value.coder());\n        byte[] buf = newArray(length << coder);\n        String prefix = constants[0];\n        prefix.getBytes(buf, 0, coder);\n        value.getBytes(buf, prefix.length(), coder);\n        constants[1].getBytes(buf, prefix.length() + value.length(), coder);\n        return new String(buf, coder);\n    }\n\n    @ForceInline\n    String concat(boolean value) {\n        int length = stringSize(this.length, value);\n        String suffix = constants[1];\n        length -= suffix.length();\n        byte[] buf = newArrayWithSuffix(suffix, length, coder);\n        prepend(length, coder, buf, value, constants[0]);\n        return new String(buf, coder);\n    }\n\n    // ... 其他concat方法类似", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：字符串拼接可能依赖动态生成字节码或通用方法调用，存在运行时开销和内存分配。优化后：引入基于隐藏类的字符串拼接策略，通过预计算常量字符串长度和编码器，生成特化的拼接类（如Concat1），减少运行时计算和内存分配。优化思路：利用隐藏类机制生成高效拼接代码，避免通用路径开销，提升字符串拼接性能。"}
{"id": 821, "source": "riscv-dataset-excel", "optimization_type": "同步机制优化+内存优化", "optimization_description": "优化前：对象与ObjectMonitor的映射采用传统方式，同步操作可能涉及重量级锁开销。优化后：引入新的ObjectMonitor映射机制（UseObjectMonitorTable），通过轻量级同步器（lightweightSynchronizer）减少锁膨胀，优化内存布局和缓存管理。思路：重构同步器架构，分离轻量级和重量级锁路径，减少不必要的对象监视器分配，提升多线程场景下的性能。", "original_code": "对象与ObjectMonitor的映射采用传统方式，同步操作可能涉及重量级锁开销。", "optimized_code": "- void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register t1,\n+ void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register t1,\n   Register t2, Register t3) {\n   assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-  assert_different_registers(obj, t1, t2, t3);\n+  assert_different_registers(obj, box, t1, t2, t3);\n   ...\n+  if (UseObjectMonitorTable) {\n+    // Clear cache in case fast locking succeeds.\n+    str(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/bd4160cea8b6b0fcf0507199ed76a12f5d0aaba9", "code_v0_no_empty_lines": "对象与ObjectMonitor的映射采用传统方式，同步操作可能涉及重量级锁开销。", "code_v1_no_empty_lines": "- void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register t1,\n+ void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register t1,\n   Register t2, Register t3) {\n   assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-  assert_different_registers(obj, t1, t2, t3);\n+  assert_different_registers(obj, box, t1, t2, t3);\n   ...\n+  if (UseObjectMonitorTable) {\n+    // Clear cache in case fast locking succeeds.\n+    str(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }", "target": "- void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register t1,\n+ void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register t1,\n   Register t2, Register t3) {\n   assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-  assert_different_registers(obj, t1, t2, t3);\n+  assert_different_registers(obj, box, t1, t2, t3);\n   ...\n+  if (UseObjectMonitorTable) {\n+    // Clear cache in case fast locking succeeds.\n+    str(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对象与ObjectMonitor的映射采用传统方式，同步操作可能涉及重量级锁开销。优化后：引入新的ObjectMonitor映射机制（UseObjectMonitorTable），通过轻量级同步器（lightweightSynchronizer）减少锁膨胀，优化内存布局和缓存管理。思路：重构同步器架构，分离轻量级和重量级锁路径，减少不必要的对象监视器分配，提升多线程场景下的性能。"}
{"id": 822, "source": "riscv-dataset-excel", "optimization_type": "内存优化+数据结构优化", "optimization_description": "优化前：每个年轻代区域（eden/survivor）都有独立的G1CardSet实例来管理卡表，导致内存碎片和额外开销。优化后：为所有年轻代区域共享一个G1CardSet实例（_young_regions_cardset），通过install_group_cardset()将区域关联到共享卡集。优化思路：减少内存占用（避免每个区域独立卡集的开销），提高内存局部性，简化年轻代区域管理，同时调整扫描器工作分配策略（GroupBucketClaimSize）以优化并行扫描性能。", "original_code": "每个年轻代区域（eden/survivor）都有独立的G1CardSet实例来管理卡表，导致内存碎片和额外开销。", "optimized_code": "diff --git a/src/hotspot/share/gc/g1/g1CollectedHeap.cpp b/src/hotspot/share/gc/g1/g1CollectedHeap.cpp\nindex aa99fbecbee..fd73b725a12 100644\n--- a/src/hotspot/share/gc/g1/g1CollectedHeap.cpp\n+++ b/src/hotspot/share/gc/g1/g1CollectedHeap.cpp\n@@ -1159,6 +1159,8 @@ G1CollectedHeap::G1CollectedHeap() :\n   _rem_set(nullptr),\n   _card_set_config(),\n   _card_set_freelist_pool(G1CardSetConfiguration::num_mem_object_types()),\n+  _young_regions_cardset_mm(card_set_config(), card_set_freelist_pool()),\n+  _young_regions_cardset(card_set_config(), &_young_regions_cardset_mm),\n   _cm(nullptr),\n   _cm_thread(nullptr),\n   _cr(nullptr),\n@@ -2693,6 +2695,7 @@ bool G1CollectedHeap::is_old_gc_alloc_region(G1HeapRegion* hr) {\n void G1CollectedHeap::set_region_short_lived_locked(G1HeapRegion* hr) {\n   _eden.add(hr);\n   _policy->set_region_eden(hr);\n+  hr->install_group_cardset(young_regions_cardset());\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/f536f5ab68235d27e9708674f707bcbff7840730", "code_v0_no_empty_lines": "每个年轻代区域（eden/survivor）都有独立的G1CardSet实例来管理卡表，导致内存碎片和额外开销。", "code_v1_no_empty_lines": "diff --git a/src/hotspot/share/gc/g1/g1CollectedHeap.cpp b/src/hotspot/share/gc/g1/g1CollectedHeap.cpp\nindex aa99fbecbee..fd73b725a12 100644\n--- a/src/hotspot/share/gc/g1/g1CollectedHeap.cpp\n+++ b/src/hotspot/share/gc/g1/g1CollectedHeap.cpp\n@@ -1159,6 +1159,8 @@ G1CollectedHeap::G1CollectedHeap() :\n   _rem_set(nullptr),\n   _card_set_config(),\n   _card_set_freelist_pool(G1CardSetConfiguration::num_mem_object_types()),\n+  _young_regions_cardset_mm(card_set_config(), card_set_freelist_pool()),\n+  _young_regions_cardset(card_set_config(), &_young_regions_cardset_mm),\n   _cm(nullptr),\n   _cm_thread(nullptr),\n   _cr(nullptr),\n@@ -2693,6 +2695,7 @@ bool G1CollectedHeap::is_old_gc_alloc_region(G1HeapRegion* hr) {\n void G1CollectedHeap::set_region_short_lived_locked(G1HeapRegion* hr) {\n   _eden.add(hr);\n   _policy->set_region_eden(hr);\n+  hr->install_group_cardset(young_regions_cardset());\n }", "target": "diff --git a/src/hotspot/share/gc/g1/g1CollectedHeap.cpp b/src/hotspot/share/gc/g1/g1CollectedHeap.cpp\nindex aa99fbecbee..fd73b725a12 100644\n--- a/src/hotspot/share/gc/g1/g1CollectedHeap.cpp\n+++ b/src/hotspot/share/gc/g1/g1CollectedHeap.cpp\n@@ -1159,6 +1159,8 @@ G1CollectedHeap::G1CollectedHeap() :\n   _rem_set(nullptr),\n   _card_set_config(),\n   _card_set_freelist_pool(G1CardSetConfiguration::num_mem_object_types()),\n+  _young_regions_cardset_mm(card_set_config(), card_set_freelist_pool()),\n+  _young_regions_cardset(card_set_config(), &_young_regions_cardset_mm),\n   _cm(nullptr),\n   _cm_thread(nullptr),\n   _cr(nullptr),\n@@ -2693,6 +2695,7 @@ bool G1CollectedHeap::is_old_gc_alloc_region(G1HeapRegion* hr) {\n void G1CollectedHeap::set_region_short_lived_locked(G1HeapRegion* hr) {\n   _eden.add(hr);\n   _policy->set_region_eden(hr);\n+  hr->install_group_cardset(young_regions_cardset());\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每个年轻代区域（eden/survivor）都有独立的G1CardSet实例来管理卡表，导致内存碎片和额外开销。优化后：为所有年轻代区域共享一个G1CardSet实例（_young_regions_cardset），通过install_group_cardset()将区域关联到共享卡集。优化思路：减少内存占用（避免每个区域独立卡集的开销），提高内存局部性，简化年轻代区域管理，同时调整扫描器工作分配策略（GroupBucketClaimSize）以优化并行扫描性能。"}
{"id": 823, "source": "riscv-dataset-excel", "optimization_type": "代码清理/无用代码移除", "optimization_description": "优化前：ParallelCompactData类中存在一个未使用的重载函数clear_range(HeapWord*, HeapWord*)，该函数只是调用另一个clear_range版本进行地址到区域索引的转换。优化后：移除了这个未使用的函数重载，简化了代码结构，减少了编译后的二进制大小，并消除了潜在的维护负担。优化思路：通过代码审查发现该函数未被任何地方调用，属于无用代码，直接删除以提高代码清晰度和可维护性。", "original_code": "ParallelCompactData类中存在一个未使用的重载函数clear_range(HeapWord*, HeapWord*)，该函数只是调用另一个clear_range版本进行地址到区域索引的转换。", "optimized_code": "-  void clear_range(HeapWord* beg, HeapWord* end) {\n-    clear_range(addr_to_region_idx(beg), addr_to_region_idx(end));\n-  }", "source_url": "https://github.com/openjdk/riscv-port/commit/0e3903f2eb854715acee92cfc5ee2d4a2e800f61", "code_v0_no_empty_lines": "ParallelCompactData类中存在一个未使用的重载函数clear_range(HeapWord*, HeapWord*)，该函数只是调用另一个clear_range版本进行地址到区域索引的转换。", "code_v1_no_empty_lines": "-  void clear_range(HeapWord* beg, HeapWord* end) {\n-    clear_range(addr_to_region_idx(beg), addr_to_region_idx(end));\n-  }", "target": "-  void clear_range(HeapWord* beg, HeapWord* end) {\n-    clear_range(addr_to_region_idx(beg), addr_to_region_idx(end));\n-  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ParallelCompactData类中存在一个未使用的重载函数clear_range(HeapWord*, HeapWord*)，该函数只是调用另一个clear_range版本进行地址到区域索引的转换。优化后：移除了这个未使用的函数重载，简化了代码结构，减少了编译后的二进制大小，并消除了潜在的维护负担。优化思路：通过代码审查发现该函数未被任何地方调用，属于无用代码，直接删除以提高代码清晰度和可维护性。"}
{"id": 824, "source": "riscv-dataset-excel", "optimization_type": "内存优化+对象池优化", "optimization_description": "优化前：每次创建空数组或清空数组时都分配新的Object[0]实例，导致内存分配开销和GC压力。优化后：引入静态常量EMPTY_ELEMENTDATA作为共享的空数组，在构造函数、clear()、remove()、反序列化等场景中重用该常量。优化思路：通过对象池模式减少零长度数组的重复分配，降低内存分配开销和GC频率，提升性能。", "original_code": "每次创建空数组或清空数组时都分配新的Object[0]实例，导致内存分配开销和GC压力。", "optimized_code": "+ private static final Object[] EMPTY_ELEMENTDATA = {};\n- setArray(new Object[0]);\n+ setArray(EMPTY_ELEMENTDATA);\n+ else if (c.isEmpty())\n+     es = EMPTY_ELEMENTDATA;\n+ if (toCopyIn.length == 0)\n+     setArray(EMPTY_ELEMENTDATA);\n+ else if (len == 1)\n+     newElements = EMPTY_ELEMENTDATA;\n+ if (len == 1) {\n+     // one element exists and that element should be removed\n+     setArray(EMPTY_ELEMENTDATA);\n+     return true;\n+ }\n- Object[] es = new Object[len];\n+ Object[] es = (len == 0 ? EMPTY_ELEMENTDATA : new Object[len]);", "source_url": "https://github.com/openjdk/riscv-port/commit/a5d948fb9841f654cccc9567c60e8d28e7d719ae", "code_v0_no_empty_lines": "每次创建空数组或清空数组时都分配新的Object[0]实例，导致内存分配开销和GC压力。", "code_v1_no_empty_lines": "+ private static final Object[] EMPTY_ELEMENTDATA = {};\n- setArray(new Object[0]);\n+ setArray(EMPTY_ELEMENTDATA);\n+ else if (c.isEmpty())\n+     es = EMPTY_ELEMENTDATA;\n+ if (toCopyIn.length == 0)\n+     setArray(EMPTY_ELEMENTDATA);\n+ else if (len == 1)\n+     newElements = EMPTY_ELEMENTDATA;\n+ if (len == 1) {\n+     // one element exists and that element should be removed\n+     setArray(EMPTY_ELEMENTDATA);\n+     return true;\n+ }\n- Object[] es = new Object[len];\n+ Object[] es = (len == 0 ? EMPTY_ELEMENTDATA : new Object[len]);", "target": "+ private static final Object[] EMPTY_ELEMENTDATA = {};\n- setArray(new Object[0]);\n+ setArray(EMPTY_ELEMENTDATA);\n+ else if (c.isEmpty())\n+     es = EMPTY_ELEMENTDATA;\n+ if (toCopyIn.length == 0)\n+     setArray(EMPTY_ELEMENTDATA);\n+ else if (len == 1)\n+     newElements = EMPTY_ELEMENTDATA;\n+ if (len == 1) {\n+     // one element exists and that element should be removed\n+     setArray(EMPTY_ELEMENTDATA);\n+     return true;\n+ }\n- Object[] es = new Object[len];\n+ Object[] es = (len == 0 ? EMPTY_ELEMENTDATA : new Object[len]);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次创建空数组或清空数组时都分配新的Object[0]实例，导致内存分配开销和GC压力。优化后：引入静态常量EMPTY_ELEMENTDATA作为共享的空数组，在构造函数、clear()、remove()、反序列化等场景中重用该常量。优化思路：通过对象池模式减少零长度数组的重复分配，降低内存分配开销和GC频率，提升性能。"}
{"id": 825, "source": "riscv-dataset-excel", "optimization_type": "代码清理/语法优化", "optimization_description": "优化前：宏定义末尾有多余的分号，在宏展开时可能产生空语句或语法警告。优化后：移除宏定义末尾的分号，使宏展开更干净，避免潜在的空语句和编译器警告。优化思路：清理代码中的冗余语法元素，提高代码质量，减少编译时警告，对运行时性能无直接影响但改善代码可维护性。", "original_code": "宏定义末尾有多余的分号，在宏展开时可能产生空语句或语法警告。", "optimized_code": "-  assert_is_aligned((p), metaspace::AllocationAlignmentByteSize);\n+  assert_is_aligned((p), metaspace::AllocationAlignmentByteSize)\n-  #define UL(level, message)        log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS);\n+  #define UL(level, message)        log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS)\n-  #define UL2(level, message, ...)  log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS, __VA_ARGS__);\n+  #define UL2(level, message, ...)  log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS, __VA_ARGS__)", "source_url": "https://github.com/openjdk/riscv-port/commit/877fd5a768647790d0a43aaca247043bae70d708", "code_v0_no_empty_lines": "宏定义末尾有多余的分号，在宏展开时可能产生空语句或语法警告。", "code_v1_no_empty_lines": "-  assert_is_aligned((p), metaspace::AllocationAlignmentByteSize);\n+  assert_is_aligned((p), metaspace::AllocationAlignmentByteSize)\n-  #define UL(level, message)        log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS);\n+  #define UL(level, message)        log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS)\n-  #define UL2(level, message, ...)  log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS, __VA_ARGS__);\n+  #define UL2(level, message, ...)  log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS, __VA_ARGS__)", "target": "-  assert_is_aligned((p), metaspace::AllocationAlignmentByteSize);\n+  assert_is_aligned((p), metaspace::AllocationAlignmentByteSize)\n-  #define UL(level, message)        log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS);\n+  #define UL(level, message)        log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS)\n-  #define UL2(level, message, ...)  log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS, __VA_ARGS__);\n+  #define UL2(level, message, ...)  log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS, __VA_ARGS__)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：宏定义末尾有多余的分号，在宏展开时可能产生空语句或语法警告。优化后：移除宏定义末尾的分号，使宏展开更干净，避免潜在的空语句和编译器警告。优化思路：清理代码中的冗余语法元素，提高代码质量，减少编译时警告，对运行时性能无直接影响但改善代码可维护性。"}
{"id": 826, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：在Linux系统启用透明大页（THP）时，Shenandoah GC的辅助位图分配和堆预触操作会强制使用标准页大小（4KB），以避免短期内存分配污染THP区域。优化后：移除了这些针对THP的特殊处理，允许使用大页进行内存分配和预触操作。优化思路：基于JDK-8315923的改进，现在系统能够更智能地管理THP，不再需要人工干预页大小选择，从而减少代码复杂性并可能提升内存访问性能。", "original_code": "在Linux系统启用透明大页（THP）时，Shenandoah GC的辅助位图分配和堆预触操作会强制使用标准页大小（4KB），以避免短期内存分配污染THP区域。", "optimized_code": "-#ifdef LINUX\n-  // In THP \"advise\" mode, we refrain from advising the system to use large pages\n-  // since we know these commits will be short lived, and there is no reason to trash\n-  // the THP area with this bitmap.\n-  if (UseTransparentHugePages) {\n-    aux_bitmap_page_size = os::vm_page_size();\n-  }\n-#endif\n \n-#ifdef LINUX\n-    // UseTransparentHugePages would madvise that backing memory can be coalesced into huge\n-    // pages. But, the kernel needs to know that every small page is used, in order to coalesce\n-    // them into huge one. Therefore, we need to pretouch with smaller pages.\n-    if (UseTransparentHugePages) {\n-      _pretouch_heap_page_size = (size_t)os::vm_page_size();\n-      _pretouch_bitmap_page_size = (size_t)os::vm_page_size();\n-    }\n-#endif", "source_url": "https://github.com/openjdk/riscv-port/commit/84c3065e8004122f3455a8c28c8719b2c8111c17", "code_v0_no_empty_lines": "在Linux系统启用透明大页（THP）时，Shenandoah GC的辅助位图分配和堆预触操作会强制使用标准页大小（4KB），以避免短期内存分配污染THP区域。", "code_v1_no_empty_lines": "-#ifdef LINUX\n-  // In THP \"advise\" mode, we refrain from advising the system to use large pages\n-  // since we know these commits will be short lived, and there is no reason to trash\n-  // the THP area with this bitmap.\n-  if (UseTransparentHugePages) {\n-    aux_bitmap_page_size = os::vm_page_size();\n-  }\n-#endif\n \n-#ifdef LINUX\n-    // UseTransparentHugePages would madvise that backing memory can be coalesced into huge\n-    // pages. But, the kernel needs to know that every small page is used, in order to coalesce\n-    // them into huge one. Therefore, we need to pretouch with smaller pages.\n-    if (UseTransparentHugePages) {\n-      _pretouch_heap_page_size = (size_t)os::vm_page_size();\n-      _pretouch_bitmap_page_size = (size_t)os::vm_page_size();\n-    }\n-#endif", "target": "-#ifdef LINUX\n-  // In THP \"advise\" mode, we refrain from advising the system to use large pages\n-  // since we know these commits will be short lived, and there is no reason to trash\n-  // the THP area with this bitmap.\n-  if (UseTransparentHugePages) {\n-    aux_bitmap_page_size = os::vm_page_size();\n-  }\n-#endif\n \n-#ifdef LINUX\n-    // UseTransparentHugePages would madvise that backing memory can be coalesced into huge\n-    // pages. But, the kernel needs to know that every small page is used, in order to coalesce\n-    // them into huge one. Therefore, we need to pretouch with smaller pages.\n-    if (UseTransparentHugePages) {\n-      _pretouch_heap_page_size = (size_t)os::vm_page_size();\n-      _pretouch_bitmap_page_size = (size_t)os::vm_page_size();\n-    }\n-#endif", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在Linux系统启用透明大页（THP）时，Shenandoah GC的辅助位图分配和堆预触操作会强制使用标准页大小（4KB），以避免短期内存分配污染THP区域。优化后：移除了这些针对THP的特殊处理，允许使用大页进行内存分配和预触操作。优化思路：基于JDK-8315923的改进，现在系统能够更智能地管理THP，不再需要人工干预页大小选择，从而减少代码复杂性并可能提升内存访问性能。"}
{"id": 827, "source": "riscv-dataset-excel", "optimization_type": "线程调度优化+超时处理优化", "optimization_description": "优化前：当DatagramChannel没有设置超时时间时，代码将nanos设置为Long.MAX_VALUE，然后使用park(Net.POLLIN, remainingNanos)进行定时等待，即使没有超时限制也会进行不必要的超时计算和检查。优化后：移除了nanos = Long.MAX_VALUE的赋值，改为当nanos>0时计算剩余时间并进行超时检查，当nanos<=0时直接调用无超时参数的park(Net.POLLIN)方法。优化思路：避免在没有超时设置的情况下进行不必要的超时计算和检查，减少系统调用开销，提高无超时场景下的接收性能。", "original_code": "当DatagramChannel没有设置超时时间时，代码将nanos设置为Long.MAX_VALUE，然后使用park(Net.POLLIN, remainingNanos)进行定时等待，即使没有超时限制也会进行不必要的超时计算和检查。", "optimized_code": "-                nanos = Long.MAX_VALUE;\n+                long remainingNanos = (nanos > 0)\n+                        ? nanos - (System.nanoTime() - startNanos)\n+                        : 0;\n-                long remainingNanos = nanos - (System.nanoTime() - startNanos);\n-                if (remainingNanos <= 0) {\n-                    throw new SocketTimeoutException(\"Receive timed out\");\n-                }\n-                park(Net.POLLIN, remainingNanos);\n+                if (nanos > 0) {\n+                    long remainingNanos = nanos - (System.nanoTime() - startNanos);\n+                    if (remainingNanos <= 0) {\n+                        throw new SocketTimeoutException(\"Receive timed out\");\n+                    }\n+                    park(Net.POLLIN, remainingNanos);\n+                } else {\n+                    park(Net.POLLIN);\n+                }", "source_url": "https://github.com/openjdk/riscv-port/commit/58b957054437edee7d0abc365133985ac30a6af4", "code_v0_no_empty_lines": "当DatagramChannel没有设置超时时间时，代码将nanos设置为Long.MAX_VALUE，然后使用park(Net.POLLIN, remainingNanos)进行定时等待，即使没有超时限制也会进行不必要的超时计算和检查。", "code_v1_no_empty_lines": "-                nanos = Long.MAX_VALUE;\n+                long remainingNanos = (nanos > 0)\n+                        ? nanos - (System.nanoTime() - startNanos)\n+                        : 0;\n-                long remainingNanos = nanos - (System.nanoTime() - startNanos);\n-                if (remainingNanos <= 0) {\n-                    throw new SocketTimeoutException(\"Receive timed out\");\n-                }\n-                park(Net.POLLIN, remainingNanos);\n+                if (nanos > 0) {\n+                    long remainingNanos = nanos - (System.nanoTime() - startNanos);\n+                    if (remainingNanos <= 0) {\n+                        throw new SocketTimeoutException(\"Receive timed out\");\n+                    }\n+                    park(Net.POLLIN, remainingNanos);\n+                } else {\n+                    park(Net.POLLIN);\n+                }", "target": "-                nanos = Long.MAX_VALUE;\n+                long remainingNanos = (nanos > 0)\n+                        ? nanos - (System.nanoTime() - startNanos)\n+                        : 0;\n-                long remainingNanos = nanos - (System.nanoTime() - startNanos);\n-                if (remainingNanos <= 0) {\n-                    throw new SocketTimeoutException(\"Receive timed out\");\n-                }\n-                park(Net.POLLIN, remainingNanos);\n+                if (nanos > 0) {\n+                    long remainingNanos = nanos - (System.nanoTime() - startNanos);\n+                    if (remainingNanos <= 0) {\n+                        throw new SocketTimeoutException(\"Receive timed out\");\n+                    }\n+                    park(Net.POLLIN, remainingNanos);\n+                } else {\n+                    park(Net.POLLIN);\n+                }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当DatagramChannel没有设置超时时间时，代码将nanos设置为Long.MAX_VALUE，然后使用park(Net.POLLIN, remainingNanos)进行定时等待，即使没有超时限制也会进行不必要的超时计算和检查。优化后：移除了nanos = Long.MAX_VALUE的赋值，改为当nanos>0时计算剩余时间并进行超时检查，当nanos<=0时直接调用无超时参数的park(Net.POLLIN)方法。优化思路：避免在没有超时设置的情况下进行不必要的超时计算和检查，减少系统调用开销，提高无超时场景下的接收性能。"}
{"id": 828, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：SuperWord向量化算法在处理MulAddS2I（乘加）操作时，输入排列检查存在缺陷，循环从i=1开始，导致无法正确验证第一个元素，可能错误地阻止向量化。优化后：将循环起始索引从1改为0，确保完整检查所有输入元素，修复了向量化条件，使编译器能正确识别并应用MulAddS2I向量化，提升循环性能。", "original_code": "SuperWord向量化算法在处理MulAddS2I（乘加）操作时，输入排列检查存在缺陷，循环从i=1开始，导致无法正确验证第一个元素，可能错误地阻止向量化。", "optimized_code": "-  for (uint i = 1; i < pack->size(); i++) {\n+  for (uint i = 0; i < pack->size(); i++) {", "source_url": "https://github.com/openjdk/riscv-port/commit/c27a8c8c8b867e6812b905f6154762802a498dbd", "code_v0_no_empty_lines": "SuperWord向量化算法在处理MulAddS2I（乘加）操作时，输入排列检查存在缺陷，循环从i=1开始，导致无法正确验证第一个元素，可能错误地阻止向量化。", "code_v1_no_empty_lines": "-  for (uint i = 1; i < pack->size(); i++) {\n+  for (uint i = 0; i < pack->size(); i++) {", "target": "-  for (uint i = 1; i < pack->size(); i++) {\n+  for (uint i = 0; i < pack->size(); i++) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：SuperWord向量化算法在处理MulAddS2I（乘加）操作时，输入排列检查存在缺陷，循环从i=1开始，导致无法正确验证第一个元素，可能错误地阻止向量化。优化后：将循环起始索引从1改为0，确保完整检查所有输入元素，修复了向量化条件，使编译器能正确识别并应用MulAddS2I向量化，提升循环性能。"}
{"id": 829, "source": "riscv-dataset-excel", "optimization_type": "代码清理与简化", "optimization_description": "优化前：在 can_pack_into_pair 函数中，对于类型转换操作需要调用 longer_type_for_conversion 函数检查转换后的类型是否支持向量化，增加了复杂性和维护成本。\n优化后：移除了 longer_type_for_conversion 函数及其调用，简化了向量化打包判断逻辑，现在只检查原始类型的向量化支持情况。\n优化思路：清理冗余代码，简化 SuperWord 向量化优化器的实现，减少维护负担，同时保持原有功能正确性。", "original_code": "在 can_pack_into_pair 函数中，对于类型转换操作需要调用 longer_type_for_conversion 函数检查转换后的类型是否支持向量化，增加了复杂性和维护成本。", "optimized_code": "-  BasicType longer_bt = longer_type_for_conversion(s1);\n-  if (Matcher::max_vector_size_auto_vectorization(bt1) < 2 ||\n-      (longer_bt != T_ILLEGAL && Matcher::max_vector_size_auto_vectorization(longer_bt) < 2)) {\n+  if (Matcher::max_vector_size_auto_vectorization(bt1) < 2) {\n\n-// 完整函数 longer_type_for_conversion 被删除（25行代码）", "source_url": "https://github.com/openjdk/riscv-port/commit/73ddb7deab26c526337ec6e7cd5f528f698a552c", "code_v0_no_empty_lines": "在 can_pack_into_pair 函数中，对于类型转换操作需要调用 longer_type_for_conversion 函数检查转换后的类型是否支持向量化，增加了复杂性和维护成本。", "code_v1_no_empty_lines": "-  BasicType longer_bt = longer_type_for_conversion(s1);\n-  if (Matcher::max_vector_size_auto_vectorization(bt1) < 2 ||\n-      (longer_bt != T_ILLEGAL && Matcher::max_vector_size_auto_vectorization(longer_bt) < 2)) {\n+  if (Matcher::max_vector_size_auto_vectorization(bt1) < 2) {\n\n-// 完整函数 longer_type_for_conversion 被删除（25行代码）", "target": "-  BasicType longer_bt = longer_type_for_conversion(s1);\n-  if (Matcher::max_vector_size_auto_vectorization(bt1) < 2 ||\n-      (longer_bt != T_ILLEGAL && Matcher::max_vector_size_auto_vectorization(longer_bt) < 2)) {\n+  if (Matcher::max_vector_size_auto_vectorization(bt1) < 2) {\n\n-// 完整函数 longer_type_for_conversion 被删除（25行代码）", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在 can_pack_into_pair 函数中，对于类型转换操作需要调用 longer_type_for_conversion 函数检查转换后的类型是否支持向量化，增加了复杂性和维护成本。\n优化后：移除了 longer_type_for_conversion 函数及其调用，简化了向量化打包判断逻辑，现在只检查原始类型的向量化支持情况。\n优化思路：清理冗余代码，简化 SuperWord 向量化优化器的实现，减少维护负担，同时保持原有功能正确性。"}
{"id": 830, "source": "riscv-dataset-excel", "optimization_type": "内存顺序优化", "optimization_description": "优化前：G1垃圾收集器中的疏散统计操作使用默认的原子操作，具有完整的内存顺序约束（memory_order_seq_cst），这会导致不必要的内存屏障开销。优化后：将原子操作的内存顺序改为memory_order_relaxed，这些统计计数器仅用于性能监控，不需要严格的顺序保证。优化思路：通过放松内存顺序约束，减少内存屏障指令，降低并发操作的开销，提升G1垃圾收集器的性能。", "original_code": "G1垃圾收集器中的疏散统计操作使用默认的原子操作，具有完整的内存顺序约束（memory_order_seq_cst），这会导致不必要的内存屏障开销。", "optimized_code": "-  Atomic::add(&_direct_allocated, value);\n+  Atomic::add(&_direct_allocated, value, memory_order_relaxed);\n-  Atomic::inc(&_regions_filled);\n+  Atomic::inc(&_regions_filled, memory_order_relaxed);", "source_url": "https://github.com/openjdk/riscv-port/commit/2ca136a7adb6defaea3b7a69d30e6c36bda66e6a", "code_v0_no_empty_lines": "G1垃圾收集器中的疏散统计操作使用默认的原子操作，具有完整的内存顺序约束（memory_order_seq_cst），这会导致不必要的内存屏障开销。", "code_v1_no_empty_lines": "-  Atomic::add(&_direct_allocated, value);\n+  Atomic::add(&_direct_allocated, value, memory_order_relaxed);\n-  Atomic::inc(&_regions_filled);\n+  Atomic::inc(&_regions_filled, memory_order_relaxed);", "target": "-  Atomic::add(&_direct_allocated, value);\n+  Atomic::add(&_direct_allocated, value, memory_order_relaxed);\n-  Atomic::inc(&_regions_filled);\n+  Atomic::inc(&_regions_filled, memory_order_relaxed);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：G1垃圾收集器中的疏散统计操作使用默认的原子操作，具有完整的内存顺序约束（memory_order_seq_cst），这会导致不必要的内存屏障开销。优化后：将原子操作的内存顺序改为memory_order_relaxed，这些统计计数器仅用于性能监控，不需要严格的顺序保证。优化思路：通过放松内存顺序约束，减少内存屏障指令，降低并发操作的开销，提升G1垃圾收集器的性能。"}
{"id": 831, "source": "riscv-dataset-excel", "optimization_type": "内存泄漏修复", "optimization_description": "优化前：析构函数中只调用了每个Arena元素的析构函数，但没有释放存储Arena指针的堆数组_arenas，导致内存泄漏。优化后：在析构函数中添加了FREE_C_HEAP_ARRAY调用，正确释放了堆分配的_arenas数组，消除了内存泄漏。", "original_code": "析构函数中只调用了每个Arena元素的析构函数，但没有释放存储Arena指针的堆数组_arenas，导致内存泄漏。", "optimized_code": "+  FREE_C_HEAP_ARRAY(Arena*, _arenas);", "source_url": "https://github.com/openjdk/riscv-port/commit/e70c9bccaae375be1ee6812dabc9fbaff01a6ab0", "code_v0_no_empty_lines": "析构函数中只调用了每个Arena元素的析构函数，但没有释放存储Arena指针的堆数组_arenas，导致内存泄漏。", "code_v1_no_empty_lines": "+  FREE_C_HEAP_ARRAY(Arena*, _arenas);", "target": "+  FREE_C_HEAP_ARRAY(Arena*, _arenas);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：析构函数中只调用了每个Arena元素的析构函数，但没有释放存储Arena指针的堆数组_arenas，导致内存泄漏。优化后：在析构函数中添加了FREE_C_HEAP_ARRAY调用，正确释放了堆分配的_arenas数组，消除了内存泄漏。"}
{"id": 832, "source": "riscv-dataset-excel", "optimization_type": "调试/日志优化", "optimization_description": "优化前：多个GC阶段使用相同的handshake闭包标签，调试时难以区分不同阶段的线程同步点。优化后：为rendezvous_threads()方法添加名称参数，允许调用方传入具体阶段名称（如\"Shenandoah Concurrent Weak Roots\"、\"Shenandoah Class Unloading\"），同时简化了其他闭包标签。优化思路：通过改进handshake闭包的标签命名，增强GC调试和日志的可读性，便于性能分析和问题诊断。", "original_code": "多个GC阶段使用相同的handshake闭包标签，调试时难以区分不同阶段的线程同步点。", "optimized_code": "-    HandshakeClosure(\"Shenandoah Flush SATB Handshake\"),\n+    HandshakeClosure(\"Shenandoah Flush SATB\"),\n-  inline ShenandoahRendezvousClosure() : HandshakeClosure(\"ShenandoahRendezvous\") {}\n+  inline ShenandoahRendezvousClosure(const char* name) : HandshakeClosure(name) {}\n-void ShenandoahHeap::rendezvous_threads() {\n-  ShenandoahRendezvousClosure cl;\n+void ShenandoahHeap::rendezvous_threads(const char* name) {\n+  ShenandoahRendezvousClosure cl(name);", "source_url": "https://github.com/openjdk/riscv-port/commit/ba69ed7c58fcf99ed18dfd8840125ddcac9460bb", "code_v0_no_empty_lines": "多个GC阶段使用相同的handshake闭包标签，调试时难以区分不同阶段的线程同步点。", "code_v1_no_empty_lines": "-    HandshakeClosure(\"Shenandoah Flush SATB Handshake\"),\n+    HandshakeClosure(\"Shenandoah Flush SATB\"),\n-  inline ShenandoahRendezvousClosure() : HandshakeClosure(\"ShenandoahRendezvous\") {}\n+  inline ShenandoahRendezvousClosure(const char* name) : HandshakeClosure(name) {}\n-void ShenandoahHeap::rendezvous_threads() {\n-  ShenandoahRendezvousClosure cl;\n+void ShenandoahHeap::rendezvous_threads(const char* name) {\n+  ShenandoahRendezvousClosure cl(name);", "target": "-    HandshakeClosure(\"Shenandoah Flush SATB Handshake\"),\n+    HandshakeClosure(\"Shenandoah Flush SATB\"),\n-  inline ShenandoahRendezvousClosure() : HandshakeClosure(\"ShenandoahRendezvous\") {}\n+  inline ShenandoahRendezvousClosure(const char* name) : HandshakeClosure(name) {}\n-void ShenandoahHeap::rendezvous_threads() {\n-  ShenandoahRendezvousClosure cl;\n+void ShenandoahHeap::rendezvous_threads(const char* name) {\n+  ShenandoahRendezvousClosure cl(name);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多个GC阶段使用相同的handshake闭包标签，调试时难以区分不同阶段的线程同步点。优化后：为rendezvous_threads()方法添加名称参数，允许调用方传入具体阶段名称（如\"Shenandoah Concurrent Weak Roots\"、\"Shenandoah Class Unloading\"），同时简化了其他闭包标签。优化思路：通过改进handshake闭包的标签命名，增强GC调试和日志的可读性，便于性能分析和问题诊断。"}
{"id": 833, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：PNGImageWriter在处理图像时，对每一行都调用image.getData(rect)创建新的Raster副本，导致大量内存分配和复制开销。优化后：通过条件判断，对于BufferedImage直接使用其Raster，对于单块平铺图像直接使用Tile，避免不必要的内存复制。优化思路：减少内存分配和复制操作，通过重用现有Raster对象来降低内存使用量。", "original_code": "PNGImageWriter在处理图像时，对每一行都调用image.getData(rect)创建新的Raster副本，导致大量内存分配和复制开销。", "optimized_code": "if (image instanceof BufferedImage bi) {\n    // Use the raster directly (no copy).\n    ras = bi.getRaster();\n} else if (image.getNumXTiles() == 1 && image.getNumYTiles() == 1 &&\n           image.getTileWidth() == width && image.getTileHeight() == height) {\n    // Use the single tile directly (no copy).\n    ras = image.getTile(image.getMinTileX(), image.getMinTileY());\n} else {\n    // Make a copy of the raster data.\n    Rectangle rect = new Rectangle(minX, row, width, 1);\n    ras = image.getData(rect);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/89a15f1414f89d2dd32eac791e9155fcb4207e56", "code_v0_no_empty_lines": "PNGImageWriter在处理图像时，对每一行都调用image.getData(rect)创建新的Raster副本，导致大量内存分配和复制开销。", "code_v1_no_empty_lines": "if (image instanceof BufferedImage bi) {\n    // Use the raster directly (no copy).\n    ras = bi.getRaster();\n} else if (image.getNumXTiles() == 1 && image.getNumYTiles() == 1 &&\n           image.getTileWidth() == width && image.getTileHeight() == height) {\n    // Use the single tile directly (no copy).\n    ras = image.getTile(image.getMinTileX(), image.getMinTileY());\n} else {\n    // Make a copy of the raster data.\n    Rectangle rect = new Rectangle(minX, row, width, 1);\n    ras = image.getData(rect);\n}", "target": "if (image instanceof BufferedImage bi) {\n    // Use the raster directly (no copy).\n    ras = bi.getRaster();\n} else if (image.getNumXTiles() == 1 && image.getNumYTiles() == 1 &&\n           image.getTileWidth() == width && image.getTileHeight() == height) {\n    // Use the single tile directly (no copy).\n    ras = image.getTile(image.getMinTileX(), image.getMinTileY());\n} else {\n    // Make a copy of the raster data.\n    Rectangle rect = new Rectangle(minX, row, width, 1);\n    ras = image.getData(rect);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PNGImageWriter在处理图像时，对每一行都调用image.getData(rect)创建新的Raster副本，导致大量内存分配和复制开销。优化后：通过条件判断，对于BufferedImage直接使用其Raster，对于单块平铺图像直接使用Tile，避免不必要的内存复制。优化思路：减少内存分配和复制操作，通过重用现有Raster对象来降低内存使用量。"}
{"id": 834, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+NMT集成", "optimization_description": "优化前：ZUtils::alloc_aligned函数使用平台特定的内存分配函数（posix_memalign/_aligned_malloc），这些分配未报告给NMT（Native Memory Tracking），导致内存跟踪不准确。优化后：删除平台特定实现，统一使用os::malloc进行分配并指定mtGC标签，确保内存分配被NMT正确跟踪。优化思路：通过使用标准内存分配接口并添加内存类型标签，解决NMT跟踪缺失问题，同时保持对齐分配功能。", "original_code": "ZUtils::alloc_aligned函数使用平台特定的内存分配函数（posix_memalign/_aligned_malloc），这些分配未报告给NMT（Native Memory Tracking），导致内存跟踪不准确。", "optimized_code": "inline uintptr_t ZUtils::alloc_aligned_unfreeable(size_t alignment, size_t size) {\n  const size_t padded_size = size + (alignment - 1);\n  void* const addr = os::malloc(padded_size, mtGC);\n  void* const aligned_addr = align_up(addr, alignment);\n\n  memset(aligned_addr, 0, size);\n\n  // Since free expects pointers returned by malloc, aligned_addr cannot be\n  // freed since it is most likely not the same as addr after alignment.\n  return (uintptr_t)aligned_addr;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/a6c0630737bbf2f2e6c64863ff9b43c50c4742b6", "code_v0_no_empty_lines": "ZUtils::alloc_aligned函数使用平台特定的内存分配函数（posix_memalign/_aligned_malloc），这些分配未报告给NMT（Native Memory Tracking），导致内存跟踪不准确。", "code_v1_no_empty_lines": "inline uintptr_t ZUtils::alloc_aligned_unfreeable(size_t alignment, size_t size) {\n  const size_t padded_size = size + (alignment - 1);\n  void* const addr = os::malloc(padded_size, mtGC);\n  void* const aligned_addr = align_up(addr, alignment);\n\n  memset(aligned_addr, 0, size);\n\n  // Since free expects pointers returned by malloc, aligned_addr cannot be\n  // freed since it is most likely not the same as addr after alignment.\n  return (uintptr_t)aligned_addr;\n}", "target": "inline uintptr_t ZUtils::alloc_aligned_unfreeable(size_t alignment, size_t size) {\n  const size_t padded_size = size + (alignment - 1);\n  void* const addr = os::malloc(padded_size, mtGC);\n  void* const aligned_addr = align_up(addr, alignment);\n\n  memset(aligned_addr, 0, size);\n\n  // Since free expects pointers returned by malloc, aligned_addr cannot be\n  // freed since it is most likely not the same as addr after alignment.\n  return (uintptr_t)aligned_addr;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ZUtils::alloc_aligned函数使用平台特定的内存分配函数（posix_memalign/_aligned_malloc），这些分配未报告给NMT（Native Memory Tracking），导致内存跟踪不准确。优化后：删除平台特定实现，统一使用os::malloc进行分配并指定mtGC标签，确保内存分配被NMT正确跟踪。优化思路：通过使用标准内存分配接口并添加内存类型标签，解决NMT跟踪缺失问题，同时保持对齐分配功能。"}
{"id": 835, "source": "riscv-dataset-excel", "optimization_type": "SIMD向量化优化", "optimization_description": "优化前：Base64编码使用纯标量指令逐字节处理，效率较低。优化后：利用RISC-V向量扩展（RVV）实现SIMD向量化编码，通过vlseg3e8_v指令一次加载3个向量寄存器组的数据，使用向量移位和逻辑运算并行计算4个索引，通过vluxei8_v指令并行查表，最后用vsseg4e8_v指令批量存储4个向量寄存器组的编码结果。优化思路：将Base64编码算法向量化，利用RVV指令的并行处理能力，显著提升大数据量编码性能，支持m1和m2两种向量长度模式，并保留标量版本作为后备。", "original_code": "Base64编码使用纯标量指令逐字节处理，效率较低。", "optimized_code": "+  void base64_vector_encode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3, VectorRegister outputV4,\n+                    Assembler::LMUL lmul) {\n+    // set vector register type/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul);\n+\n+    // segmented load src into v registers: mem(src) => vr(3)\n+    __ vlseg3e8_v(inputV1, src);\n+\n+    // src = src + register_group_len_bytes * 3\n+    __ add(src, src, stepSrc);\n+\n+    // encoding\n+    //   1. compute index into lookup table: vr(3) => vr(4)\n+    __ vsrl_vi(idxV1, inputV1, 2);\n+\n+    __ vsrl_vi(idxV2, inputV2, 2);\n+    __ vsll_vi(inputV1, inputV1, 6);\n+    __ vor_vv(idxV2, idxV2, inputV1);\n+    __ vsrl_vi(idxV2, idxV2, 2);\n+\n+    __ vsrl_vi(idxV3, inputV3, 4);\n+    __ vsll_vi(inputV2, inputV2, 4);\n+    __ vor_vv(idxV3, inputV2, idxV3);\n+    __ vsrl_vi(idxV3, idxV3, 2);\n+\n+    __ vsll_vi(idxV4, inputV3, 2);\n+    __ vsrl_vi(idxV4, idxV4, 2);\n+\n+    //   2. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(outputV1, codec, idxV1);\n+    __ vluxei8_v(outputV2, codec, idxV2);\n+    __ vluxei8_v(outputV3, codec, idxV3);\n+    __ vluxei8_v(outputV4, codec, idxV4);\n+\n+    // segmented store encoded data in v registers back to dst: vr(4) => mem(dst)\n+    __ vsseg4e8_v(outputV1, dst);\n+\n+    // dst = dst + register_group_len_bytes * 4\n+    __ add(dst, dst, stepDst);\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/c37e8638c98cb4516569304e9a0ab477affb0641", "code_v0_no_empty_lines": "Base64编码使用纯标量指令逐字节处理，效率较低。", "code_v1_no_empty_lines": "+  void base64_vector_encode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3, VectorRegister outputV4,\n+                    Assembler::LMUL lmul) {\n+    // set vector register type/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul);\n+\n+    // segmented load src into v registers: mem(src) => vr(3)\n+    __ vlseg3e8_v(inputV1, src);\n+\n+    // src = src + register_group_len_bytes * 3\n+    __ add(src, src, stepSrc);\n+\n+    // encoding\n+    //   1. compute index into lookup table: vr(3) => vr(4)\n+    __ vsrl_vi(idxV1, inputV1, 2);\n+\n+    __ vsrl_vi(idxV2, inputV2, 2);\n+    __ vsll_vi(inputV1, inputV1, 6);\n+    __ vor_vv(idxV2, idxV2, inputV1);\n+    __ vsrl_vi(idxV2, idxV2, 2);\n+\n+    __ vsrl_vi(idxV3, inputV3, 4);\n+    __ vsll_vi(inputV2, inputV2, 4);\n+    __ vor_vv(idxV3, inputV2, idxV3);\n+    __ vsrl_vi(idxV3, idxV3, 2);\n+\n+    __ vsll_vi(idxV4, inputV3, 2);\n+    __ vsrl_vi(idxV4, idxV4, 2);\n+\n+    //   2. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(outputV1, codec, idxV1);\n+    __ vluxei8_v(outputV2, codec, idxV2);\n+    __ vluxei8_v(outputV3, codec, idxV3);\n+    __ vluxei8_v(outputV4, codec, idxV4);\n+\n+    // segmented store encoded data in v registers back to dst: vr(4) => mem(dst)\n+    __ vsseg4e8_v(outputV1, dst);\n+\n+    // dst = dst + register_group_len_bytes * 4\n+    __ add(dst, dst, stepDst);\n+  }", "target": "+  void base64_vector_encode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3, VectorRegister outputV4,\n+                    Assembler::LMUL lmul) {\n+    // set vector register type/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul);\n+\n+    // segmented load src into v registers: mem(src) => vr(3)\n+    __ vlseg3e8_v(inputV1, src);\n+\n+    // src = src + register_group_len_bytes * 3\n+    __ add(src, src, stepSrc);\n+\n+    // encoding\n+    //   1. compute index into lookup table: vr(3) => vr(4)\n+    __ vsrl_vi(idxV1, inputV1, 2);\n+\n+    __ vsrl_vi(idxV2, inputV2, 2);\n+    __ vsll_vi(inputV1, inputV1, 6);\n+    __ vor_vv(idxV2, idxV2, inputV1);\n+    __ vsrl_vi(idxV2, idxV2, 2);\n+\n+    __ vsrl_vi(idxV3, inputV3, 4);\n+    __ vsll_vi(inputV2, inputV2, 4);\n+    __ vor_vv(idxV3, inputV2, idxV3);\n+    __ vsrl_vi(idxV3, idxV3, 2);\n+\n+    __ vsll_vi(idxV4, inputV3, 2);\n+    __ vsrl_vi(idxV4, idxV4, 2);\n+\n+    //   2. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(outputV1, codec, idxV1);\n+    __ vluxei8_v(outputV2, codec, idxV2);\n+    __ vluxei8_v(outputV3, codec, idxV3);\n+    __ vluxei8_v(outputV4, codec, idxV4);\n+\n+    // segmented store encoded data in v registers back to dst: vr(4) => mem(dst)\n+    __ vsseg4e8_v(outputV1, dst);\n+\n+    // dst = dst + register_group_len_bytes * 4\n+    __ add(dst, dst, stepDst);\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Base64编码使用纯标量指令逐字节处理，效率较低。优化后：利用RISC-V向量扩展（RVV）实现SIMD向量化编码，通过vlseg3e8_v指令一次加载3个向量寄存器组的数据，使用向量移位和逻辑运算并行计算4个索引，通过vluxei8_v指令并行查表，最后用vsseg4e8_v指令批量存储4个向量寄存器组的编码结果。优化思路：将Base64编码算法向量化，利用RVV指令的并行处理能力，显著提升大数据量编码性能，支持m1和m2两种向量长度模式，并保留标量版本作为后备。"}
{"id": 836, "source": "riscv-dataset-excel", "optimization_type": "内存屏障优化", "optimization_description": "优化前：在JNI调用期间的安全点轮询中使用acquire内存屏障，确保线程本地轮询字加载与全局安全点状态标志加载的顺序性，避免竞态条件。优化后：移除acquire内存屏障，因为Java线程在安全点轮询后总是会自行解除武装，无需额外的内存排序保证。优化思路：通过分析AArch64架构下JNI调用期间的安全点轮询行为，发现acquire屏障是冗余的，移除后可以减少内存屏障开销，提升JNI调用性能。", "original_code": "在JNI调用期间的安全点轮询中使用acquire内存屏障，确保线程本地轮询字加载与全局安全点状态标志加载的顺序性，避免竞态条件。", "optimized_code": "-    __ safepoint_poll(safepoint_in_progress, true /* at_return */, true /* acquire */, false /* in_nmethod */);\n+    __ safepoint_poll(safepoint_in_progress, true /* at_return */, false /* acquire */, false /* in_nmethod */);", "source_url": "https://github.com/openjdk/riscv-port/commit/358d77dafbe0e35d5b20340fccddc0fb8f3db82a", "code_v0_no_empty_lines": "在JNI调用期间的安全点轮询中使用acquire内存屏障，确保线程本地轮询字加载与全局安全点状态标志加载的顺序性，避免竞态条件。", "code_v1_no_empty_lines": "-    __ safepoint_poll(safepoint_in_progress, true /* at_return */, true /* acquire */, false /* in_nmethod */);\n+    __ safepoint_poll(safepoint_in_progress, true /* at_return */, false /* acquire */, false /* in_nmethod */);", "target": "-    __ safepoint_poll(safepoint_in_progress, true /* at_return */, true /* acquire */, false /* in_nmethod */);\n+    __ safepoint_poll(safepoint_in_progress, true /* at_return */, false /* acquire */, false /* in_nmethod */);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在JNI调用期间的安全点轮询中使用acquire内存屏障，确保线程本地轮询字加载与全局安全点状态标志加载的顺序性，避免竞态条件。优化后：移除acquire内存屏障，因为Java线程在安全点轮询后总是会自行解除武装，无需额外的内存排序保证。优化思路：通过分析AArch64架构下JNI调用期间的安全点轮询行为，发现acquire屏障是冗余的，移除后可以减少内存屏障开销，提升JNI调用性能。"}
{"id": 837, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+并行处理优化", "optimization_description": "优化前：使用简单的任务对象（PartialArrayScanTask）表示大数组分块处理，每个任务只包含源数组引用，处理时需要重新计算分块信息，存在重复计算和状态管理开销。\n优化后：引入PartialArrayState对象封装完整的处理状态（源数组、目标数组、起始索引、长度等），通过PartialArrayStateAllocator进行分配和释放管理，实现状态复用和更精确的内存控制。\n优化思路：将大数组分块处理的状态从临时计算改为预分配和复用，减少重复计算开销，改善内存局部性，通过状态对象封装使并行任务调度更高效，同时新增的分配器机制允许更好的内存管理和资源回收。", "original_code": "使用简单的任务对象（PartialArrayScanTask）表示大数组分块处理，每个任务只包含源数组引用，处理时需要重新计算分块信息，存在重复计算和状态管理开销。", "optimized_code": "- _partial_objarray_chunk_size(ParGCArrayScanChunk),\n+ _partial_array_state_allocator(pas_allocator),\n- _partial_array_stepper(num_workers),\n+ _partial_array_stepper(num_workers, ParGCArrayScanChunk),\n- void G1ParScanThreadState::do_partial_array(PartialArrayScanTask task) {\n+ void G1ParScanThreadState::do_partial_array(PartialArrayState* state) {\n- PartialArrayTaskStepper::Step step = _partial_array_stepper.next(objArrayOop(from_obj), to_array, _partial_objarray_chunk_size);\n+ PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n- push_on_queue(ScannerTask(PartialArrayScanTask(from_obj)));\n+ push_on_queue(ScannerTask(state));\n+ _partial_array_state_allocator->release(_worker_id, state);", "source_url": "https://github.com/openjdk/riscv-port/commit/6a3d045221c338fefec9bd59245324eae60b156b", "code_v0_no_empty_lines": "使用简单的任务对象（PartialArrayScanTask）表示大数组分块处理，每个任务只包含源数组引用，处理时需要重新计算分块信息，存在重复计算和状态管理开销。", "code_v1_no_empty_lines": "- _partial_objarray_chunk_size(ParGCArrayScanChunk),\n+ _partial_array_state_allocator(pas_allocator),\n- _partial_array_stepper(num_workers),\n+ _partial_array_stepper(num_workers, ParGCArrayScanChunk),\n- void G1ParScanThreadState::do_partial_array(PartialArrayScanTask task) {\n+ void G1ParScanThreadState::do_partial_array(PartialArrayState* state) {\n- PartialArrayTaskStepper::Step step = _partial_array_stepper.next(objArrayOop(from_obj), to_array, _partial_objarray_chunk_size);\n+ PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n- push_on_queue(ScannerTask(PartialArrayScanTask(from_obj)));\n+ push_on_queue(ScannerTask(state));\n+ _partial_array_state_allocator->release(_worker_id, state);", "target": "- _partial_objarray_chunk_size(ParGCArrayScanChunk),\n+ _partial_array_state_allocator(pas_allocator),\n- _partial_array_stepper(num_workers),\n+ _partial_array_stepper(num_workers, ParGCArrayScanChunk),\n- void G1ParScanThreadState::do_partial_array(PartialArrayScanTask task) {\n+ void G1ParScanThreadState::do_partial_array(PartialArrayState* state) {\n- PartialArrayTaskStepper::Step step = _partial_array_stepper.next(objArrayOop(from_obj), to_array, _partial_objarray_chunk_size);\n+ PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n- push_on_queue(ScannerTask(PartialArrayScanTask(from_obj)));\n+ push_on_queue(ScannerTask(state));\n+ _partial_array_state_allocator->release(_worker_id, state);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用简单的任务对象（PartialArrayScanTask）表示大数组分块处理，每个任务只包含源数组引用，处理时需要重新计算分块信息，存在重复计算和状态管理开销。\n优化后：引入PartialArrayState对象封装完整的处理状态（源数组、目标数组、起始索引、长度等），通过PartialArrayStateAllocator进行分配和释放管理，实现状态复用和更精确的内存控制。\n优化思路：将大数组分块处理的状态从临时计算改为预分配和复用，减少重复计算开销，改善内存局部性，通过状态对象封装使并行任务调度更高效，同时新增的分配器机制允许更好的内存管理和资源回收。"}
{"id": 838, "source": "riscv-dataset-excel", "optimization_type": "内存泄漏修复", "optimization_description": "优化前：1. 在JFR记录器未记录任何事件时，缺少对引导类加载器的序列化处理，导致内存泄漏；2. flush_storage返回0时提前返回，可能跳过后续必要的清理操作。优化后：1. 在初始类型集处理时，显式检查并序列化引导类加载器，确保资源正确释放；2. 简化flush逻辑，始终执行flush_storage并更新total_elements，避免因提前返回导致的资源泄漏。优化思路：修复JFR记录器在特定场景下的内存泄漏问题，确保即使没有记录事件也能正确清理所有资源。", "original_code": "1. 在JFR记录器未记录任何事件时，缺少对引导类加载器的序列化处理，导致内存泄漏；2. flush_storage返回0时提前返回，可能跳过后续必要的清理操作。", "optimized_code": "1. jfrTypeSet.cpp中添加条件检查逻辑：\n+  if (is_initial_typeset_for_chunk()) {\n+    CldPtr bootloader = get_cld(Universe::boolArrayKlass());\n+    assert(bootloader != nullptr, \"invariant\");\n+    if (IS_NOT_SERIALIZED(bootloader)) {\n+      write__cld(_writer, bootloader);\n+      assert(IS_SERIALIZED(bootloader), \"invariant\");\n+      cldw.add(1);\n+    }\n+  }\n\n2. jfrRecorderService.cpp中简化flush逻辑：\n-  const size_t storage_elements = flush_storage(_storage, _chunkwriter);\n-  if (0 == storage_elements) {\n-    return total_elements;\n-  }\n-  total_elements += storage_elements;\n+  total_elements = flush_storage(_storage, _chunkwriter);", "source_url": "https://github.com/openjdk/riscv-port/commit/6a9a867d645b8fe86f4ca2b04a43bf5aa8f9d487", "code_v0_no_empty_lines": "1. 在JFR记录器未记录任何事件时，缺少对引导类加载器的序列化处理，导致内存泄漏；2. flush_storage返回0时提前返回，可能跳过后续必要的清理操作。", "code_v1_no_empty_lines": "1. jfrTypeSet.cpp中添加条件检查逻辑：\n+  if (is_initial_typeset_for_chunk()) {\n+    CldPtr bootloader = get_cld(Universe::boolArrayKlass());\n+    assert(bootloader != nullptr, \"invariant\");\n+    if (IS_NOT_SERIALIZED(bootloader)) {\n+      write__cld(_writer, bootloader);\n+      assert(IS_SERIALIZED(bootloader), \"invariant\");\n+      cldw.add(1);\n+    }\n+  }\n\n2. jfrRecorderService.cpp中简化flush逻辑：\n-  const size_t storage_elements = flush_storage(_storage, _chunkwriter);\n-  if (0 == storage_elements) {\n-    return total_elements;\n-  }\n-  total_elements += storage_elements;\n+  total_elements = flush_storage(_storage, _chunkwriter);", "target": "1. jfrTypeSet.cpp中添加条件检查逻辑：\n+  if (is_initial_typeset_for_chunk()) {\n+    CldPtr bootloader = get_cld(Universe::boolArrayKlass());\n+    assert(bootloader != nullptr, \"invariant\");\n+    if (IS_NOT_SERIALIZED(bootloader)) {\n+      write__cld(_writer, bootloader);\n+      assert(IS_SERIALIZED(bootloader), \"invariant\");\n+      cldw.add(1);\n+    }\n+  }\n\n2. jfrRecorderService.cpp中简化flush逻辑：\n-  const size_t storage_elements = flush_storage(_storage, _chunkwriter);\n-  if (0 == storage_elements) {\n-    return total_elements;\n-  }\n-  total_elements += storage_elements;\n+  total_elements = flush_storage(_storage, _chunkwriter);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 在JFR记录器未记录任何事件时，缺少对引导类加载器的序列化处理，导致内存泄漏；2. flush_storage返回0时提前返回，可能跳过后续必要的清理操作。优化后：1. 在初始类型集处理时，显式检查并序列化引导类加载器，确保资源正确释放；2. 简化flush逻辑，始终执行flush_storage并更新total_elements，避免因提前返回导致的资源泄漏。优化思路：修复JFR记录器在特定场景下的内存泄漏问题，确保即使没有记录事件也能正确清理所有资源。"}
{"id": 839, "source": "riscv-dataset-excel", "optimization_type": "调试增强", "optimization_description": "优化前：断言信息仅包含尝试次数，调试时难以定位具体失败原因。优化后：在Windows平台的map_or_reserve_memory_aligned函数中，为内存重映射失败的断言添加了详细参数信息（大小、对齐方式、文件描述符），便于开发者在断言触发时快速诊断问题。思路：通过增强错误信息的详细程度，减少调试时间，间接提升开发效率。", "original_code": "断言信息仅包含尝试次数，调试时难以定位具体失败原因。", "optimized_code": "+ assert(aligned_base != nullptr, \"Did not manage to re-map after %d attempts (size %zu, alignment %zu, file descriptor %d)\", max_attempts, size, alignment, file_desc);", "source_url": "https://github.com/openjdk/riscv-port/commit/00aac4097abd3c5e6144734cfd44228bc31892fb", "code_v0_no_empty_lines": "断言信息仅包含尝试次数，调试时难以定位具体失败原因。", "code_v1_no_empty_lines": "+ assert(aligned_base != nullptr, \"Did not manage to re-map after %d attempts (size %zu, alignment %zu, file descriptor %d)\", max_attempts, size, alignment, file_desc);", "target": "+ assert(aligned_base != nullptr, \"Did not manage to re-map after %d attempts (size %zu, alignment %zu, file descriptor %d)\", max_attempts, size, alignment, file_desc);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：断言信息仅包含尝试次数，调试时难以定位具体失败原因。优化后：在Windows平台的map_or_reserve_memory_aligned函数中，为内存重映射失败的断言添加了详细参数信息（大小、对齐方式、文件描述符），便于开发者在断言触发时快速诊断问题。思路：通过增强错误信息的详细程度，减少调试时间，间接提升开发效率。"}
{"id": 840, "source": "riscv-dataset-excel", "optimization_type": "代码重构与可维护性优化", "optimization_description": "优化前：ZGC代码中地址验证和对象验证逻辑分散且重复，使用lambda表达式和直接调用to_zaddress/to_oop函数进行验证，代码结构不够清晰。优化后：1) 提取通用验证函数check_is_valid_zaddress和assert_is_oop/assert_is_oop_or_null，消除重复代码；2) 将验证逻辑与转换逻辑分离，to_zaddress和to_oop函数专注于转换，验证通过独立函数完成；3) 用函数指针替代lambda，简化代码。优化思路：通过重构提高代码可读性、可维护性和一致性，减少重复验证逻辑，使代码结构更清晰，便于后续维护和调试。", "original_code": "ZGC代码中地址验证和对象验证逻辑分散且重复，使用lambda表达式和直接调用to_zaddress/to_oop函数进行验证，代码结构不够清晰。", "optimized_code": "- check_oop_function = [](oopDesc* obj) {\n-   (void)to_zaddress(obj);\n- };\n+ check_oop_function = &check_is_valid_zaddress;\n\n-inline zaddress to_zaddress(uintptr_t value) {\n-  const zaddress addr = zaddress(value);\n-  assert_is_valid(addr);\n-  DEBUG_ONLY(dereferenceable_test(addr));\n-  return addr;\n-}\n\n+inline void check_is_valid_zaddress(zaddress addr) {\n+  assert_is_valid(addr);\n+  DEBUG_ONLY(dereferenceable_test(addr));\n+}\n\n+inline void assert_is_oop_or_null(zaddress addr) {\n+  const oop obj = cast_to_oop(addr);\n+  assert(!ZVerifyOops || oopDesc::is_oop_or_null(obj), \"Broken oop: \" PTR_FORMAT \" [\" PTR_FORMAT \" \" PTR_FORMAT \" \" PTR_FORMAT \" \" PTR_FORMAT \"]\",\n+         p2i(obj),\n+         *(uintptr_t*)(untype(addr) + 0x00),\n+         *(uintptr_t*)(untype(addr) + 0x08),\n+         *(uintptr_t*)(untype(addr) + 0x10),\n+         *(uintptr_t*)(untype(addr) + 0x18));\n+}\n\n+inline void assert_is_oop(zaddress addr) {\n+  assert(!is_null(addr), \"Should not be null\");\n+  assert_is_oop_or_null(addr);\n+}\n\n-inline oop to_oop(zaddress addr) {\n-  const oop obj = cast_to_oop(addr);\n-  assert(!ZVerifyOops || oopDesc::is_oop_or_null(obj), \"Broken oop: \" PTR_FORMAT \" [\" PTR_FORMAT \" \" PTR_FORMAT \" \" PTR_FORMAT \" \" PTR_FORMAT \"]\",\n-         p2i(obj),\n-         *(uintptr_t*)(untype(addr) + 0x00),\n-         *(uintptr_t*)(untype(addr) + 0x08),\n-         *(uintptr_t*)(untype(addr) + 0x10),\n-         *(uintptr_t*)(untype(addr) + 0x18));\n-  return obj;\n-}\n\n+inline oop to_oop(zaddress addr) {\n+  assert_is_oop_or_null(addr);\n+  return cast_to_oop(addr);\n+}\n\n-assert(!ZVerifyOops || oopDesc::is_oop(to_oop(addr), false), \"must be oop\");\n+assert_is_oop(addr);\n\n-assert_is_valid(to_zaddress(obj));\n+check_is_valid_zaddress(obj);", "source_url": "https://github.com/openjdk/riscv-port/commit/f74109bd178c92a9dff1ca6fce03b25f51a0384f", "code_v0_no_empty_lines": "ZGC代码中地址验证和对象验证逻辑分散且重复，使用lambda表达式和直接调用to_zaddress/to_oop函数进行验证，代码结构不够清晰。", "code_v1_no_empty_lines": "- check_oop_function = [](oopDesc* obj) {\n-   (void)to_zaddress(obj);\n- };\n+ check_oop_function = &check_is_valid_zaddress;\n\n-inline zaddress to_zaddress(uintptr_t value) {\n-  const zaddress addr = zaddress(value);\n-  assert_is_valid(addr);\n-  DEBUG_ONLY(dereferenceable_test(addr));\n-  return addr;\n-}\n\n+inline void check_is_valid_zaddress(zaddress addr) {\n+  assert_is_valid(addr);\n+  DEBUG_ONLY(dereferenceable_test(addr));\n+}\n\n+inline void assert_is_oop_or_null(zaddress addr) {\n+  const oop obj = cast_to_oop(addr);\n+  assert(!ZVerifyOops || oopDesc::is_oop_or_null(obj), \"Broken oop: \" PTR_FORMAT \" [\" PTR_FORMAT \" \" PTR_FORMAT \" \" PTR_FORMAT \" \" PTR_FORMAT \"]\",\n+         p2i(obj),\n+         *(uintptr_t*)(untype(addr) + 0x00),\n+         *(uintptr_t*)(untype(addr) + 0x08),\n+         *(uintptr_t*)(untype(addr) + 0x10),\n+         *(uintptr_t*)(untype(addr) + 0x18));\n+}\n\n+inline void assert_is_oop(zaddress addr) {\n+  assert(!is_null(addr), \"Should not be null\");\n+  assert_is_oop_or_null(addr);\n+}\n\n-inline oop to_oop(zaddress addr) {\n-  const oop obj = cast_to_oop(addr);\n-  assert(!ZVerifyOops || oopDesc::is_oop_or_null(obj), \"Broken oop: \" PTR_FORMAT \" [\" PTR_FORMAT \" \" PTR_FORMAT \" \" PTR_FORMAT \" \" PTR_FORMAT \"]\",\n-         p2i(obj),\n-         *(uintptr_t*)(untype(addr) + 0x00),\n-         *(uintptr_t*)(untype(addr) + 0x08),\n-         *(uintptr_t*)(untype(addr) + 0x10),\n-         *(uintptr_t*)(untype(addr) + 0x18));\n-  return obj;\n-}\n\n+inline oop to_oop(zaddress addr) {\n+  assert_is_oop_or_null(addr);\n+  return cast_to_oop(addr);\n+}\n\n-assert(!ZVerifyOops || oopDesc::is_oop(to_oop(addr), false), \"must be oop\");\n+assert_is_oop(addr);\n\n-assert_is_valid(to_zaddress(obj));\n+check_is_valid_zaddress(obj);", "target": "- check_oop_function = [](oopDesc* obj) {\n-   (void)to_zaddress(obj);\n- };\n+ check_oop_function = &check_is_valid_zaddress;\n\n-inline zaddress to_zaddress(uintptr_t value) {\n-  const zaddress addr = zaddress(value);\n-  assert_is_valid(addr);\n-  DEBUG_ONLY(dereferenceable_test(addr));\n-  return addr;\n-}\n\n+inline void check_is_valid_zaddress(zaddress addr) {\n+  assert_is_valid(addr);\n+  DEBUG_ONLY(dereferenceable_test(addr));\n+}\n\n+inline void assert_is_oop_or_null(zaddress addr) {\n+  const oop obj = cast_to_oop(addr);\n+  assert(!ZVerifyOops || oopDesc::is_oop_or_null(obj), \"Broken oop: \" PTR_FORMAT \" [\" PTR_FORMAT \" \" PTR_FORMAT \" \" PTR_FORMAT \" \" PTR_FORMAT \"]\",\n+         p2i(obj),\n+         *(uintptr_t*)(untype(addr) + 0x00),\n+         *(uintptr_t*)(untype(addr) + 0x08),\n+         *(uintptr_t*)(untype(addr) + 0x10),\n+         *(uintptr_t*)(untype(addr) + 0x18));\n+}\n\n+inline void assert_is_oop(zaddress addr) {\n+  assert(!is_null(addr), \"Should not be null\");\n+  assert_is_oop_or_null(addr);\n+}\n\n-inline oop to_oop(zaddress addr) {\n-  const oop obj = cast_to_oop(addr);\n-  assert(!ZVerifyOops || oopDesc::is_oop_or_null(obj), \"Broken oop: \" PTR_FORMAT \" [\" PTR_FORMAT \" \" PTR_FORMAT \" \" PTR_FORMAT \" \" PTR_FORMAT \"]\",\n-         p2i(obj),\n-         *(uintptr_t*)(untype(addr) + 0x00),\n-         *(uintptr_t*)(untype(addr) + 0x08),\n-         *(uintptr_t*)(untype(addr) + 0x10),\n-         *(uintptr_t*)(untype(addr) + 0x18));\n-  return obj;\n-}\n\n+inline oop to_oop(zaddress addr) {\n+  assert_is_oop_or_null(addr);\n+  return cast_to_oop(addr);\n+}\n\n-assert(!ZVerifyOops || oopDesc::is_oop(to_oop(addr), false), \"must be oop\");\n+assert_is_oop(addr);\n\n-assert_is_valid(to_zaddress(obj));\n+check_is_valid_zaddress(obj);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ZGC代码中地址验证和对象验证逻辑分散且重复，使用lambda表达式和直接调用to_zaddress/to_oop函数进行验证，代码结构不够清晰。优化后：1) 提取通用验证函数check_is_valid_zaddress和assert_is_oop/assert_is_oop_or_null，消除重复代码；2) 将验证逻辑与转换逻辑分离，to_zaddress和to_oop函数专注于转换，验证通过独立函数完成；3) 用函数指针替代lambda，简化代码。优化思路：通过重构提高代码可读性、可维护性和一致性，减少重复验证逻辑，使代码结构更清晰，便于后续维护和调试。"}
{"id": 841, "source": "riscv-dataset-excel", "optimization_type": "内存泄漏修复", "optimization_description": "优化前：当flush_storage返回0时，代码直接返回total_elements，跳过了后续的字符串池刷新逻辑，导致字符串池资源未正确释放，造成内存泄漏。优化后：无论flush_storage返回多少元素，都继续执行字符串池的刷新逻辑，确保资源正确释放。思路：修复条件逻辑错误，确保所有必要的清理操作都能被执行。", "original_code": "当flush_storage返回0时，代码直接返回total_elements，跳过了后续的字符串池刷新逻辑，导致字符串池资源未正确释放，造成内存泄漏。", "optimized_code": "-  const size_t storage_elements = flush_storage(_storage, _chunkwriter);\n-  if (0 == storage_elements) {\n-    return total_elements;\n-  }\n-  total_elements += storage_elements;\n+  total_elements += flush_storage(_storage, _chunkwriter);", "source_url": "https://github.com/openjdk/riscv-port/commit/ef909bdf7f08dfd67bac2665aa85f86c0e303db9", "code_v0_no_empty_lines": "当flush_storage返回0时，代码直接返回total_elements，跳过了后续的字符串池刷新逻辑，导致字符串池资源未正确释放，造成内存泄漏。", "code_v1_no_empty_lines": "-  const size_t storage_elements = flush_storage(_storage, _chunkwriter);\n-  if (0 == storage_elements) {\n-    return total_elements;\n-  }\n-  total_elements += storage_elements;\n+  total_elements += flush_storage(_storage, _chunkwriter);", "target": "-  const size_t storage_elements = flush_storage(_storage, _chunkwriter);\n-  if (0 == storage_elements) {\n-    return total_elements;\n-  }\n-  total_elements += storage_elements;\n+  total_elements += flush_storage(_storage, _chunkwriter);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：当flush_storage返回0时，代码直接返回total_elements，跳过了后续的字符串池刷新逻辑，导致字符串池资源未正确释放，造成内存泄漏。优化后：无论flush_storage返回多少元素，都继续执行字符串池的刷新逻辑，确保资源正确释放。思路：修复条件逻辑错误，确保所有必要的清理操作都能被执行。"}
{"id": 842, "source": "riscv-dataset-excel", "optimization_type": "调用约定优化", "optimization_description": "优化前：RISC-V架构中，栈指针寄存器sp（x2）在C调用约定中被标记为SOE（Save-On-Entry），意味着函数调用时需要保存该寄存器，增加了调用开销。优化后：将sp的调用约定从SOE改为NS（Not Saved），允许编译器在函数调用中不保存栈指针寄存器。优化思路：根据RISC-V ABI规范，栈指针寄存器在函数调用中由调用者负责维护，被调用函数无需保存，此修改消除了不必要的寄存器保存/恢复操作，减少了函数调用开销，提升了C2编译器的代码生成效率。", "original_code": "RISC-V架构中，栈指针寄存器sp（x2）在C调用约定中被标记为SOE（Save-On-Entry），意味着函数调用时需要保存该寄存器，增加了调用开销。", "optimized_code": "-reg_def R2      ( NS,  SOE, Op_RegI, 2,  x2->as_VMReg()         ); // sp\n-reg_def R2_H    ( NS,  SOE, Op_RegI, 2,  x2->as_VMReg()->next() );\n+reg_def R2      ( NS,  NS,  Op_RegI, 2,  x2->as_VMReg()         ); // sp\n+reg_def R2_H    ( NS,  NS,  Op_RegI, 2,  x2->as_VMReg()->next() );", "source_url": "https://github.com/openjdk/riscv-port/commit/53db937dd0766695906dc20c1dbbd3228c02fe1e", "code_v0_no_empty_lines": "RISC-V架构中，栈指针寄存器sp（x2）在C调用约定中被标记为SOE（Save-On-Entry），意味着函数调用时需要保存该寄存器，增加了调用开销。", "code_v1_no_empty_lines": "-reg_def R2      ( NS,  SOE, Op_RegI, 2,  x2->as_VMReg()         ); // sp\n-reg_def R2_H    ( NS,  SOE, Op_RegI, 2,  x2->as_VMReg()->next() );\n+reg_def R2      ( NS,  NS,  Op_RegI, 2,  x2->as_VMReg()         ); // sp\n+reg_def R2_H    ( NS,  NS,  Op_RegI, 2,  x2->as_VMReg()->next() );", "target": "-reg_def R2      ( NS,  SOE, Op_RegI, 2,  x2->as_VMReg()         ); // sp\n-reg_def R2_H    ( NS,  SOE, Op_RegI, 2,  x2->as_VMReg()->next() );\n+reg_def R2      ( NS,  NS,  Op_RegI, 2,  x2->as_VMReg()         ); // sp\n+reg_def R2_H    ( NS,  NS,  Op_RegI, 2,  x2->as_VMReg()->next() );", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：RISC-V架构中，栈指针寄存器sp（x2）在C调用约定中被标记为SOE（Save-On-Entry），意味着函数调用时需要保存该寄存器，增加了调用开销。优化后：将sp的调用约定从SOE改为NS（Not Saved），允许编译器在函数调用中不保存栈指针寄存器。优化思路：根据RISC-V ABI规范，栈指针寄存器在函数调用中由调用者负责维护，被调用函数无需保存，此修改消除了不必要的寄存器保存/恢复操作，减少了函数调用开销，提升了C2编译器的代码生成效率。"}
{"id": 843, "source": "riscv-dataset-excel", "optimization_type": "代码重构+性能优化", "optimization_description": "优化前：uncommon_trap stub位于SharedRuntime中，与运行时系统耦合较紧，代码复用性差。优化后：将uncommon_trap stub重定位到OptoRuntime，使其更贴近JIT编译优化层，减少跨模块调用开销，提高代码组织清晰度。思路：通过重构将特定于编译优化的功能从通用运行时分离，提升模块化程度和性能。", "original_code": "uncommon_trap stub位于SharedRuntime中，与运行时系统耦合较紧，代码复用性差。", "optimized_code": "- 从SharedRuntime移除uncommon_trap_stub相关代码\n+ 在OptoRuntime中为各CPU架构添加uncommon_trap_blob生成函数", "source_url": "https://github.com/openjdk/riscv-port/commit/ab509f1b98329b1624a3111e226b640ee76f5969", "code_v0_no_empty_lines": "uncommon_trap stub位于SharedRuntime中，与运行时系统耦合较紧，代码复用性差。", "code_v1_no_empty_lines": "- 从SharedRuntime移除uncommon_trap_stub相关代码\n+ 在OptoRuntime中为各CPU架构添加uncommon_trap_blob生成函数", "target": "- 从SharedRuntime移除uncommon_trap_stub相关代码\n+ 在OptoRuntime中为各CPU架构添加uncommon_trap_blob生成函数", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：uncommon_trap stub位于SharedRuntime中，与运行时系统耦合较紧，代码复用性差。优化后：将uncommon_trap stub重定位到OptoRuntime，使其更贴近JIT编译优化层，减少跨模块调用开销，提高代码组织清晰度。思路：通过重构将特定于编译优化的功能从通用运行时分离，提升模块化程度和性能。"}
{"id": 844, "source": "riscv-dataset-excel", "optimization_type": "算法优化+性能优化", "optimization_description": "优化前：BigInteger.sqrt()和sqrtAndRemainder()使用基于Hacker's Delight的算法，通过牛顿迭代法计算平方根，对于大整数性能较差，时间复杂度较高。sqrtAndRemainder()先计算平方根再计算余数，存在重复计算。\n\n优化后：实现了新的sqrtRem()方法，采用渐进式更快的算法（如Karatsuba风格的递归分治算法），一次性计算平方根和余数，避免重复计算。新增shiftAdd()和shiftAddDisjoint()方法优化大整数运算，添加了新的构造函数和辅助方法。\n\n优化思路：将平方根算法从O(n²)复杂度改进为渐进式更快的算法（如O(n^1.585)），通过合并sqrt和remainder计算减少操作次数，添加专门的位移加法操作优化大整数处理，显著提升大整数平方根计算的性能。", "original_code": "BigInteger.sqrt()和sqrtAndRemainder()使用基于Hacker's Delight的算法，通过牛顿迭代法计算平方根，对于大整数性能较差，时间复杂度较高。sqrtAndRemainder()先计算平方根再计算余数，存在重复计算。", "optimized_code": "@@ -1793,93 +1866,169 @@ private boolean unsignedLongCompare(long one, long two) {\n     }\n \n     /**\n-     * Calculate the integer square root {@code floor(sqrt(this))} where\n-     * {@code sqrt(.)} denotes the mathematical square root. The contents of\n-     * {@code this} are <b>not</b> changed. The value of {@code this} is assumed\n-     * to be non-negative.\n+     * Calculate the integer square root {@code floor(sqrt(this))} and the remainder\n+     * if needed, where {@code sqrt(.)} denotes the mathematical square root.\n+     * The contents of {@code this} are <em>not</em> changed.\n+     * The value of {@code this} is assumed to be non-negative.\n      *\n-     * @implNote The implementation is based on the material in Henry S. Warren,\n-     * Jr., <i>Hacker's Delight (2nd ed.)</i> (Addison Wesley, 2013), 279-282.\n-     *\n-     * @throws ArithmeticException if the value returned by {@code bitLength()}\n-     * overflows the range of {@code int}.\n-     * @return the integer square root of {@code this}\n-     * @since 9\n+     * @return the integer square root of {@code this} and the remainder if needed\n      */\n-    MutableBigInteger sqrt() {\n+    MutableBigInteger[] sqrtRem(boolean needRemainder) {\n         // Special cases.\n-        if (this.isZero()) {\n-            return new MutableBigInteger(0);\n-        } else if (this.value.length == 1\n-                && (this.value[0] & LONG_MASK) < 4) { // result is unity\n-            return ONE;\n-        }\n-\n-        if (bitLength() <= 63) {\n-            // Initial estimate is the square root of the positive long value.\n-            long v = new BigInteger(this.value, 1).longValueExact();\n-            long xk = (long)Math.floor(Math.sqrt(v));\n-\n-            // Refine the estimate.\n-            do {\n-                long xk1 = (xk + v/xk)/2;\n-\n-                // Terminate when non-de", "source_url": "https://github.com/openjdk/riscv-port/commit/367e0a65561f95aad61b40930d5f46843fee3444", "code_v0_no_empty_lines": "BigInteger.sqrt()和sqrtAndRemainder()使用基于Hacker's Delight的算法，通过牛顿迭代法计算平方根，对于大整数性能较差，时间复杂度较高。sqrtAndRemainder()先计算平方根再计算余数，存在重复计算。", "code_v1_no_empty_lines": "@@ -1793,93 +1866,169 @@ private boolean unsignedLongCompare(long one, long two) {\n     }\n \n     /**\n-     * Calculate the integer square root {@code floor(sqrt(this))} where\n-     * {@code sqrt(.)} denotes the mathematical square root. The contents of\n-     * {@code this} are <b>not</b> changed. The value of {@code this} is assumed\n-     * to be non-negative.\n+     * Calculate the integer square root {@code floor(sqrt(this))} and the remainder\n+     * if needed, where {@code sqrt(.)} denotes the mathematical square root.\n+     * The contents of {@code this} are <em>not</em> changed.\n+     * The value of {@code this} is assumed to be non-negative.\n      *\n-     * @implNote The implementation is based on the material in Henry S. Warren,\n-     * Jr., <i>Hacker's Delight (2nd ed.)</i> (Addison Wesley, 2013), 279-282.\n-     *\n-     * @throws ArithmeticException if the value returned by {@code bitLength()}\n-     * overflows the range of {@code int}.\n-     * @return the integer square root of {@code this}\n-     * @since 9\n+     * @return the integer square root of {@code this} and the remainder if needed\n      */\n-    MutableBigInteger sqrt() {\n+    MutableBigInteger[] sqrtRem(boolean needRemainder) {\n         // Special cases.\n-        if (this.isZero()) {\n-            return new MutableBigInteger(0);\n-        } else if (this.value.length == 1\n-                && (this.value[0] & LONG_MASK) < 4) { // result is unity\n-            return ONE;\n-        }\n-\n-        if (bitLength() <= 63) {\n-            // Initial estimate is the square root of the positive long value.\n-            long v = new BigInteger(this.value, 1).longValueExact();\n-            long xk = (long)Math.floor(Math.sqrt(v));\n-\n-            // Refine the estimate.\n-            do {\n-                long xk1 = (xk + v/xk)/2;\n-\n-                // Terminate when non-de", "target": "@@ -1793,93 +1866,169 @@ private boolean unsignedLongCompare(long one, long two) {\n     }\n \n     /**\n-     * Calculate the integer square root {@code floor(sqrt(this))} where\n-     * {@code sqrt(.)} denotes the mathematical square root. The contents of\n-     * {@code this} are <b>not</b> changed. The value of {@code this} is assumed\n-     * to be non-negative.\n+     * Calculate the integer square root {@code floor(sqrt(this))} and the remainder\n+     * if needed, where {@code sqrt(.)} denotes the mathematical square root.\n+     * The contents of {@code this} are <em>not</em> changed.\n+     * The value of {@code this} is assumed to be non-negative.\n      *\n-     * @implNote The implementation is based on the material in Henry S. Warren,\n-     * Jr., <i>Hacker's Delight (2nd ed.)</i> (Addison Wesley, 2013), 279-282.\n-     *\n-     * @throws ArithmeticException if the value returned by {@code bitLength()}\n-     * overflows the range of {@code int}.\n-     * @return the integer square root of {@code this}\n-     * @since 9\n+     * @return the integer square root of {@code this} and the remainder if needed\n      */\n-    MutableBigInteger sqrt() {\n+    MutableBigInteger[] sqrtRem(boolean needRemainder) {\n         // Special cases.\n-        if (this.isZero()) {\n-            return new MutableBigInteger(0);\n-        } else if (this.value.length == 1\n-                && (this.value[0] & LONG_MASK) < 4) { // result is unity\n-            return ONE;\n-        }\n-\n-        if (bitLength() <= 63) {\n-            // Initial estimate is the square root of the positive long value.\n-            long v = new BigInteger(this.value, 1).longValueExact();\n-            long xk = (long)Math.floor(Math.sqrt(v));\n-\n-            // Refine the estimate.\n-            do {\n-                long xk1 = (xk + v/xk)/2;\n-\n-                // Terminate when non-de", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：BigInteger.sqrt()和sqrtAndRemainder()使用基于Hacker's Delight的算法，通过牛顿迭代法计算平方根，对于大整数性能较差，时间复杂度较高。sqrtAndRemainder()先计算平方根再计算余数，存在重复计算。\n\n优化后：实现了新的sqrtRem()方法，采用渐进式更快的算法（如Karatsuba风格的递归分治算法），一次性计算平方根和余数，避免重复计算。新增shiftAdd()和shiftAddDisjoint()方法优化大整数运算，添加了新的构造函数和辅助方法。\n\n优化思路：将平方根算法从O(n²)复杂度改进为渐进式更快的算法（如O(n^1.585)），通过合并sqrt和remainder计算减少操作次数，添加专门的位移加法操作优化大整数处理，显著提升大整数平方根计算的性能。"}
{"id": 845, "source": "riscv-dataset-excel", "optimization_type": "代码清理+一致性修复", "optimization_description": "优化前：HeapByteBuffer等缓冲区类实现了自定义hashCode方法，使用ArraysSupport.hashCode计算哈希值。优化后：移除了这些自定义hashCode实现，让缓冲区继承父类Buffer的默认hashCode实现（基于对象标识）。思路：修复ByteBuffer哈希码不一致问题（Bug 8337716），确保所有ByteBuffer子类（包括HeapByteBuffer和MappedByteBuffer）使用相同的哈希码计算逻辑，保持equals和hashCode契约的一致性。", "original_code": "HeapByteBuffer等缓冲区类实现了自定义hashCode方法，使用ArraysSupport.hashCode计算哈希值。", "optimized_code": "-    public int hashCode() {\n-        return ArraysSupport.hashCode(hb, ix(position()), remaining(), 1);\n-    }", "source_url": "https://github.com/openjdk/riscv-port/commit/8bd3cd51562ff9e76fa0e3d49d38e6e19210f878", "code_v0_no_empty_lines": "HeapByteBuffer等缓冲区类实现了自定义hashCode方法，使用ArraysSupport.hashCode计算哈希值。", "code_v1_no_empty_lines": "-    public int hashCode() {\n-        return ArraysSupport.hashCode(hb, ix(position()), remaining(), 1);\n-    }", "target": "-    public int hashCode() {\n-        return ArraysSupport.hashCode(hb, ix(position()), remaining(), 1);\n-    }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：HeapByteBuffer等缓冲区类实现了自定义hashCode方法，使用ArraysSupport.hashCode计算哈希值。优化后：移除了这些自定义hashCode实现，让缓冲区继承父类Buffer的默认hashCode实现（基于对象标识）。思路：修复ByteBuffer哈希码不一致问题（Bug 8337716），确保所有ByteBuffer子类（包括HeapByteBuffer和MappedByteBuffer）使用相同的哈希码计算逻辑，保持equals和hashCode契约的一致性。"}
{"id": 846, "source": "riscv-dataset-excel", "optimization_type": "向量化优化", "optimization_description": "优化前：x86_64平台上的向量API仅支持有序浮点归约操作，要求保持浮点运算的精确顺序，限制了编译器优化空间。优化后：新增无序浮点归约支持（unordered reduction），允许编译器重新排列浮点加法和乘法操作的顺序，从而更好地利用SIMD指令并行性。优化思路：通过添加unordered_reduce_operation_128/256、unordered_reduce_fp等新函数，为浮点向量归约操作提供无序计算路径，编译器可以根据目标架构特性选择最优的指令调度策略，提升向量化代码性能。", "original_code": "x86_64平台上的向量API仅支持有序浮点归约操作，要求保持浮点运算的精确顺序，限制了编译器优化空间。", "optimized_code": "+void C2_MacroAssembler::unordered_reduce_operation_128(BasicType typ, int opcode, XMMRegister dst, XMMRegister src) {\n+  switch (opcode) {\n+    case Op_AddReductionVF: addps(dst, src); break;\n+    case Op_AddReductionVD: addpd(dst, src); break;\n+    case Op_MulReductionVF: mulps(dst, src); break;\n+    case Op_MulReductionVD: mulpd(dst, src); break;\n+    default:                assert(false, \"%s\", NodeClassNames[opcode]);\n+  }\n+}\n\n+void C2_MacroAssembler::unordered_reduce_operation_256(BasicType typ, int opcode, XMMRegister dst,  XMMRegister src1, XMMRegister src2) {\n+  int vector_len = Assembler::AVX_256bit;\n+\n+  switch (opcode) {\n+    case Op_AddReductionVF: vaddps(dst, src1, src2, vector_len); break;\n+    case Op_AddReductionVD: vaddpd(dst, src1, src2, vector_len); break;\n+    case Op_MulReductionVF: vmulps(dst, src1, src2, vector_len); break;\n+    case Op_MulReductionVD: vmulpd(dst, src1, src2, vector_len); break;\n+    default:                assert(false, \"%s\", NodeClassNames[opcode]);\n+  }\n+}\n\n+void C2_MacroAssembler::unordered_reduce_fp(int opcode, int vlen,\n+                                            XMMRegister dst, XMMRegister src,\n+                                            XMMRegister vtmp1, XMMRegister vtmp2) {\n+  switch (opcode) {\n+    case Op_AddReductionVF:\n+    case Op_MulReductionVF:\n+      unorderedReduceF(opcode, vlen, dst, src, vtmp1, vtmp2);\n+      break;\n+\n+    case Op_AddReductionVD:\n+    case Op_MulReductionVD:\n+      unorderedReduceD(opcode, vlen, dst, src, vtmp1, vtmp2);\n+      break;\n+\n+    default: assert(false, \"%s\", NodeClassNames[opcode]);\n+  }\n+}", "source_url": "https://github.com/openjdk/riscv-port/commit/dc35f3e8a84c8f622a4cabb8aee0f96de2e2ea30", "code_v0_no_empty_lines": "x86_64平台上的向量API仅支持有序浮点归约操作，要求保持浮点运算的精确顺序，限制了编译器优化空间。", "code_v1_no_empty_lines": "+void C2_MacroAssembler::unordered_reduce_operation_128(BasicType typ, int opcode, XMMRegister dst, XMMRegister src) {\n+  switch (opcode) {\n+    case Op_AddReductionVF: addps(dst, src); break;\n+    case Op_AddReductionVD: addpd(dst, src); break;\n+    case Op_MulReductionVF: mulps(dst, src); break;\n+    case Op_MulReductionVD: mulpd(dst, src); break;\n+    default:                assert(false, \"%s\", NodeClassNames[opcode]);\n+  }\n+}\n\n+void C2_MacroAssembler::unordered_reduce_operation_256(BasicType typ, int opcode, XMMRegister dst,  XMMRegister src1, XMMRegister src2) {\n+  int vector_len = Assembler::AVX_256bit;\n+\n+  switch (opcode) {\n+    case Op_AddReductionVF: vaddps(dst, src1, src2, vector_len); break;\n+    case Op_AddReductionVD: vaddpd(dst, src1, src2, vector_len); break;\n+    case Op_MulReductionVF: vmulps(dst, src1, src2, vector_len); break;\n+    case Op_MulReductionVD: vmulpd(dst, src1, src2, vector_len); break;\n+    default:                assert(false, \"%s\", NodeClassNames[opcode]);\n+  }\n+}\n\n+void C2_MacroAssembler::unordered_reduce_fp(int opcode, int vlen,\n+                                            XMMRegister dst, XMMRegister src,\n+                                            XMMRegister vtmp1, XMMRegister vtmp2) {\n+  switch (opcode) {\n+    case Op_AddReductionVF:\n+    case Op_MulReductionVF:\n+      unorderedReduceF(opcode, vlen, dst, src, vtmp1, vtmp2);\n+      break;\n+\n+    case Op_AddReductionVD:\n+    case Op_MulReductionVD:\n+      unorderedReduceD(opcode, vlen, dst, src, vtmp1, vtmp2);\n+      break;\n+\n+    default: assert(false, \"%s\", NodeClassNames[opcode]);\n+  }\n+}", "target": "+void C2_MacroAssembler::unordered_reduce_operation_128(BasicType typ, int opcode, XMMRegister dst, XMMRegister src) {\n+  switch (opcode) {\n+    case Op_AddReductionVF: addps(dst, src); break;\n+    case Op_AddReductionVD: addpd(dst, src); break;\n+    case Op_MulReductionVF: mulps(dst, src); break;\n+    case Op_MulReductionVD: mulpd(dst, src); break;\n+    default:                assert(false, \"%s\", NodeClassNames[opcode]);\n+  }\n+}\n\n+void C2_MacroAssembler::unordered_reduce_operation_256(BasicType typ, int opcode, XMMRegister dst,  XMMRegister src1, XMMRegister src2) {\n+  int vector_len = Assembler::AVX_256bit;\n+\n+  switch (opcode) {\n+    case Op_AddReductionVF: vaddps(dst, src1, src2, vector_len); break;\n+    case Op_AddReductionVD: vaddpd(dst, src1, src2, vector_len); break;\n+    case Op_MulReductionVF: vmulps(dst, src1, src2, vector_len); break;\n+    case Op_MulReductionVD: vmulpd(dst, src1, src2, vector_len); break;\n+    default:                assert(false, \"%s\", NodeClassNames[opcode]);\n+  }\n+}\n\n+void C2_MacroAssembler::unordered_reduce_fp(int opcode, int vlen,\n+                                            XMMRegister dst, XMMRegister src,\n+                                            XMMRegister vtmp1, XMMRegister vtmp2) {\n+  switch (opcode) {\n+    case Op_AddReductionVF:\n+    case Op_MulReductionVF:\n+      unorderedReduceF(opcode, vlen, dst, src, vtmp1, vtmp2);\n+      break;\n+\n+    case Op_AddReductionVD:\n+    case Op_MulReductionVD:\n+      unorderedReduceD(opcode, vlen, dst, src, vtmp1, vtmp2);\n+      break;\n+\n+    default: assert(false, \"%s\", NodeClassNames[opcode]);\n+  }\n+}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：x86_64平台上的向量API仅支持有序浮点归约操作，要求保持浮点运算的精确顺序，限制了编译器优化空间。优化后：新增无序浮点归约支持（unordered reduction），允许编译器重新排列浮点加法和乘法操作的顺序，从而更好地利用SIMD指令并行性。优化思路：通过添加unordered_reduce_operation_128/256、unordered_reduce_fp等新函数，为浮点向量归约操作提供无序计算路径，编译器可以根据目标架构特性选择最优的指令调度策略，提升向量化代码性能。"}
{"id": 847, "source": "riscv-dataset-excel", "optimization_type": "原子操作优化", "optimization_description": "优化前：在FreeListAllocator析构函数和pending_count()方法中，对局部变量pending_list._head和_pending_lists[index].count()使用了不必要的Atomic::load原子操作，增加了内存屏障开销。优化后：移除了这些多余的原子操作，因为pending_list是局部变量，其_head成员在单线程上下文中访问是安全的；同时修复了count()方法调用后的多余分号。优化思路：识别并消除不必要的原子内存操作，减少内存屏障开销，提升GC性能。", "original_code": "在FreeListAllocator析构函数和pending_count()方法中，对局部变量pending_list._head和_pending_lists[index].count()使用了不必要的Atomic::load原子操作，增加了内存屏障开销。", "optimized_code": "-  delete_list(Atomic::load(&pending_list._head));\n+  delete_list(pending_list._head);\n-  return _pending_lists[index].count();;\n+  return _pending_lists[index].count();", "source_url": "https://github.com/openjdk/riscv-port/commit/6c3ba5a6c47d29908ddaf58582ee8d26bb8779f9", "code_v0_no_empty_lines": "在FreeListAllocator析构函数和pending_count()方法中，对局部变量pending_list._head和_pending_lists[index].count()使用了不必要的Atomic::load原子操作，增加了内存屏障开销。", "code_v1_no_empty_lines": "-  delete_list(Atomic::load(&pending_list._head));\n+  delete_list(pending_list._head);\n-  return _pending_lists[index].count();;\n+  return _pending_lists[index].count();", "target": "-  delete_list(Atomic::load(&pending_list._head));\n+  delete_list(pending_list._head);\n-  return _pending_lists[index].count();;\n+  return _pending_lists[index].count();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在FreeListAllocator析构函数和pending_count()方法中，对局部变量pending_list._head和_pending_lists[index].count()使用了不必要的Atomic::load原子操作，增加了内存屏障开销。优化后：移除了这些多余的原子操作，因为pending_list是局部变量，其_head成员在单线程上下文中访问是安全的；同时修复了count()方法调用后的多余分号。优化思路：识别并消除不必要的原子内存操作，减少内存屏障开销，提升GC性能。"}
{"id": 848, "source": "riscv-dataset-excel", "optimization_type": "编译器中间表示优化", "optimization_description": "优化前：在CMoveNode::Ideal函数中，先执行常量规范化（将常量移到右侧输入），然后尝试识别Min/Max模式。这种顺序会导致某些Min/Max模式无法被识别，因为常量规范化可能破坏BoolTest的规范形式。优化后：调整执行顺序，先调用Ideal_minmax识别Min/Max模式，再进行常量规范化。优化思路：确保在常量规范化破坏模式识别条件之前，优先识别并优化条件移动为Min/Max节点，从而提高编译器对if表达式的优化效果，减少条件分支，提升性能。", "original_code": "在CMoveNode::Ideal函数中，先执行常量规范化（将常量移到右侧输入），然后尝试识别Min/Max模式。这种顺序会导致某些Min/Max模式无法被识别，因为常量规范化可能破坏BoolTest的规范形式。", "optimized_code": "@@ -91,17 +91,20 @@ Node *CMoveNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n       phase->type(in(IfTrue))    == Type::TOP) {\n     return nullptr;\n   }\n-  // Canonicalize the node by moving constants to the right input.\n-  if (in(Condition)->is_Bool() && phase->type(in(IfFalse))->singleton() && !phase->type(in(IfTrue))->singleton()) {\n-    BoolNode* b = in(Condition)->as_Bool()->negate(phase);\n-    return make(in(Control), phase->transform(b), in(IfTrue), in(IfFalse), _type);\n-  }\n \n+  // Check for Min/Max patterns. This is called before constants are pushed to the right input, as that transform can\n+  // make BoolTests non-canonical.\n   Node* minmax = Ideal_minmax(phase, this);\n   if (minmax != nullptr) {\n     return minmax;\n   }\n \n+  // Canonicalize the node by moving constants to the right input.\n+  if (in(Condition)->is_Bool() && phase->type(in(IfFalse))->singleton() && !phase->type(in(IfTrue))->singleton()) {\n+    BoolNode* b = in(Condition)->as_Bool()->negate(phase);\n+    return make(in(Control), phase->transform(b), in(IfTrue), in(IfFalse), _type);\n+  }\n+\n   return nullptr;\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/f2ba2ebbcaba2784b24e7fe94c235ca652f7c9a2", "code_v0_no_empty_lines": "在CMoveNode::Ideal函数中，先执行常量规范化（将常量移到右侧输入），然后尝试识别Min/Max模式。这种顺序会导致某些Min/Max模式无法被识别，因为常量规范化可能破坏BoolTest的规范形式。", "code_v1_no_empty_lines": "@@ -91,17 +91,20 @@ Node *CMoveNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n       phase->type(in(IfTrue))    == Type::TOP) {\n     return nullptr;\n   }\n-  // Canonicalize the node by moving constants to the right input.\n-  if (in(Condition)->is_Bool() && phase->type(in(IfFalse))->singleton() && !phase->type(in(IfTrue))->singleton()) {\n-    BoolNode* b = in(Condition)->as_Bool()->negate(phase);\n-    return make(in(Control), phase->transform(b), in(IfTrue), in(IfFalse), _type);\n-  }\n \n+  // Check for Min/Max patterns. This is called before constants are pushed to the right input, as that transform can\n+  // make BoolTests non-canonical.\n   Node* minmax = Ideal_minmax(phase, this);\n   if (minmax != nullptr) {\n     return minmax;\n   }\n \n+  // Canonicalize the node by moving constants to the right input.\n+  if (in(Condition)->is_Bool() && phase->type(in(IfFalse))->singleton() && !phase->type(in(IfTrue))->singleton()) {\n+    BoolNode* b = in(Condition)->as_Bool()->negate(phase);\n+    return make(in(Control), phase->transform(b), in(IfTrue), in(IfFalse), _type);\n+  }\n+\n   return nullptr;\n }", "target": "@@ -91,17 +91,20 @@ Node *CMoveNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n       phase->type(in(IfTrue))    == Type::TOP) {\n     return nullptr;\n   }\n-  // Canonicalize the node by moving constants to the right input.\n-  if (in(Condition)->is_Bool() && phase->type(in(IfFalse))->singleton() && !phase->type(in(IfTrue))->singleton()) {\n-    BoolNode* b = in(Condition)->as_Bool()->negate(phase);\n-    return make(in(Control), phase->transform(b), in(IfTrue), in(IfFalse), _type);\n-  }\n \n+  // Check for Min/Max patterns. This is called before constants are pushed to the right input, as that transform can\n+  // make BoolTests non-canonical.\n   Node* minmax = Ideal_minmax(phase, this);\n   if (minmax != nullptr) {\n     return minmax;\n   }\n \n+  // Canonicalize the node by moving constants to the right input.\n+  if (in(Condition)->is_Bool() && phase->type(in(IfFalse))->singleton() && !phase->type(in(IfTrue))->singleton()) {\n+    BoolNode* b = in(Condition)->as_Bool()->negate(phase);\n+    return make(in(Control), phase->transform(b), in(IfTrue), in(IfFalse), _type);\n+  }\n+\n   return nullptr;\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在CMoveNode::Ideal函数中，先执行常量规范化（将常量移到右侧输入），然后尝试识别Min/Max模式。这种顺序会导致某些Min/Max模式无法被识别，因为常量规范化可能破坏BoolTest的规范形式。优化后：调整执行顺序，先调用Ideal_minmax识别Min/Max模式，再进行常量规范化。优化思路：确保在常量规范化破坏模式识别条件之前，优先识别并优化条件移动为Min/Max节点，从而提高编译器对if表达式的优化效果，减少条件分支，提升性能。"}
{"id": 849, "source": "riscv-dataset-excel", "optimization_type": "递归深度限制优化", "optimization_description": "优化前：在C2编译器的逃逸分析阶段，split_memory_phi和find_inst_mem函数相互递归调用时没有深度限制，可能导致栈溢出。优化后：1. 为find_inst_mem函数添加递归深度参数rec_depth；2. 定义递归深度限制FIND_INST_MEM_RECURSION_DEPTH_LIMIT=1000；3. 当递归深度超过限制时，记录编译失败并返回nullptr，避免栈溢出。优化思路：通过限制递归深度来防止无限递归，确保编译器在复杂内存Phi节点拆分场景下的稳定性。", "original_code": "在C2编译器的逃逸分析阶段，split_memory_phi和find_inst_mem函数相互递归调用时没有深度限制，可能导致栈溢出。", "optimized_code": "Node* ConnectionGraph::find_inst_mem(Node *orig_mem, int alias_idx, GrowableArray<PhiNode *>  &orig_phis, uint rec_depth) {\n+  if (rec_depth > FIND_INST_MEM_RECURSION_DEPTH_LIMIT) {\n+    _compile->record_failure(_invocation > 0 ? C2Compiler::retry_no_iterative_escape_analysis() : C2Compiler::retry_no_escape_analysis());\n+    return nullptr;\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/fdb4350fcecef1915cdbc27ece24153a1b6c884d", "code_v0_no_empty_lines": "在C2编译器的逃逸分析阶段，split_memory_phi和find_inst_mem函数相互递归调用时没有深度限制，可能导致栈溢出。", "code_v1_no_empty_lines": "Node* ConnectionGraph::find_inst_mem(Node *orig_mem, int alias_idx, GrowableArray<PhiNode *>  &orig_phis, uint rec_depth) {\n+  if (rec_depth > FIND_INST_MEM_RECURSION_DEPTH_LIMIT) {\n+    _compile->record_failure(_invocation > 0 ? C2Compiler::retry_no_iterative_escape_analysis() : C2Compiler::retry_no_escape_analysis());\n+    return nullptr;\n+  }", "target": "Node* ConnectionGraph::find_inst_mem(Node *orig_mem, int alias_idx, GrowableArray<PhiNode *>  &orig_phis, uint rec_depth) {\n+  if (rec_depth > FIND_INST_MEM_RECURSION_DEPTH_LIMIT) {\n+    _compile->record_failure(_invocation > 0 ? C2Compiler::retry_no_iterative_escape_analysis() : C2Compiler::retry_no_escape_analysis());\n+    return nullptr;\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在C2编译器的逃逸分析阶段，split_memory_phi和find_inst_mem函数相互递归调用时没有深度限制，可能导致栈溢出。优化后：1. 为find_inst_mem函数添加递归深度参数rec_depth；2. 定义递归深度限制FIND_INST_MEM_RECURSION_DEPTH_LIMIT=1000；3. 当递归深度超过限制时，记录编译失败并返回nullptr，避免栈溢出。优化思路：通过限制递归深度来防止无限递归，确保编译器在复杂内存Phi节点拆分场景下的稳定性。"}
{"id": 850, "source": "riscv-dataset-excel", "optimization_type": "内存优化+信号处理安全优化", "optimization_description": "优化前：JVMFlag::printFlags函数在信号处理期间使用NEW_C_HEAP_ARRAY_RETURN_NULL动态分配内存数组进行排序，存在内存分配失败风险且可能触发信号处理中的不安全操作。优化后：使用栈分配的BitMap（iteratorArray）替代堆内存分配，通过位图标记已访问标志，实现无内存分配的选择排序算法。优化思路：消除信号处理期间的内存分配，提高代码在异常情况下的可靠性，同时通过constexpr优化相关计算函数（calc_size_in_words、max_size_in_bits等）提升编译时计算效率。", "original_code": "JVMFlag::printFlags函数在信号处理期间使用NEW_C_HEAP_ARRAY_RETURN_NULL动态分配内存数组进行排序，存在内存分配失败风险且可能触发信号处理中的不安全操作。", "optimized_code": "- JVMFlag** array = NEW_C_HEAP_ARRAY_RETURN_NULL(JVMFlag*, length, mtArguments);\n+ BitMap::bm_word_t iteratorArray[BitMap::calc_size_in_words(length)];\n+ BitMapView iteratorMarkers(iteratorArray, length);\n+ iteratorMarkers.clear_range(0, length);", "source_url": "https://github.com/openjdk/riscv-port/commit/a91f9ba84906dae10b050e15307ba0f0f05af3e4", "code_v0_no_empty_lines": "JVMFlag::printFlags函数在信号处理期间使用NEW_C_HEAP_ARRAY_RETURN_NULL动态分配内存数组进行排序，存在内存分配失败风险且可能触发信号处理中的不安全操作。", "code_v1_no_empty_lines": "- JVMFlag** array = NEW_C_HEAP_ARRAY_RETURN_NULL(JVMFlag*, length, mtArguments);\n+ BitMap::bm_word_t iteratorArray[BitMap::calc_size_in_words(length)];\n+ BitMapView iteratorMarkers(iteratorArray, length);\n+ iteratorMarkers.clear_range(0, length);", "target": "- JVMFlag** array = NEW_C_HEAP_ARRAY_RETURN_NULL(JVMFlag*, length, mtArguments);\n+ BitMap::bm_word_t iteratorArray[BitMap::calc_size_in_words(length)];\n+ BitMapView iteratorMarkers(iteratorArray, length);\n+ iteratorMarkers.clear_range(0, length);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：JVMFlag::printFlags函数在信号处理期间使用NEW_C_HEAP_ARRAY_RETURN_NULL动态分配内存数组进行排序，存在内存分配失败风险且可能触发信号处理中的不安全操作。优化后：使用栈分配的BitMap（iteratorArray）替代堆内存分配，通过位图标记已访问标志，实现无内存分配的选择排序算法。优化思路：消除信号处理期间的内存分配，提高代码在异常情况下的可靠性，同时通过constexpr优化相关计算函数（calc_size_in_words、max_size_in_bits等）提升编译时计算效率。"}
{"id": 851, "source": "riscv-dataset-excel", "optimization_type": "内存布局优化", "optimization_description": "优化前：多个C2编译器类的成员变量声明顺序与构造函数初始化列表顺序不一致，可能导致内存布局不紧凑和潜在的性能开销。优化后：统一调整了C2Access、VectorSet、CallJavaNode、ArrayPointer等类的成员变量声明顺序，使其与构造函数初始化列表顺序完全一致。优化思路：通过消除声明与初始化顺序的不匹配，改善内存布局，减少填充字节，提升缓存局部性，从而提高C2编译器运行时的性能。", "original_code": "多个C2编译器类的成员变量声明顺序与构造函数初始化列表顺序不一致，可能导致内存布局不紧凑和潜在的性能开销。", "optimized_code": "--- a/src/hotspot/share/gc/shared/c2/barrierSetC2.hpp\n+++ b/src/hotspot/share/gc/shared/c2/barrierSetC2.hpp\n@@ -102,10 +102,10 @@ class C2AccessValuePtr: public C2AccessValue {\n class C2Access: public StackObj {\n protected:\n   DecoratorSet      _decorators;\n-  BasicType         _type;\n   Node*             _base;\n   C2AccessValuePtr& _addr;\n   Node*             _raw_access;\n+  BasicType         _type;\n   uint8_t           _barrier_data;\n \n   void fixup_decorators();\n@@ -114,10 +114,10 @@ class C2Access: public StackObj {\n   C2Access(DecoratorSet decorators,\n            BasicType type, Node* base, C2AccessValuePtr& addr) :\n     _decorators(decorators),\n-    _type(type),\n     _base(base),\n     _addr(addr),\n     _raw_access(nullptr),\n+    _type(type),\n     _barrier_data(0)\n   {}", "source_url": "https://github.com/openjdk/riscv-port/commit/1cb27f7e2355ccb911bb274fc004e5bc57fd5dc9", "code_v0_no_empty_lines": "多个C2编译器类的成员变量声明顺序与构造函数初始化列表顺序不一致，可能导致内存布局不紧凑和潜在的性能开销。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/gc/shared/c2/barrierSetC2.hpp\n+++ b/src/hotspot/share/gc/shared/c2/barrierSetC2.hpp\n@@ -102,10 +102,10 @@ class C2AccessValuePtr: public C2AccessValue {\n class C2Access: public StackObj {\n protected:\n   DecoratorSet      _decorators;\n-  BasicType         _type;\n   Node*             _base;\n   C2AccessValuePtr& _addr;\n   Node*             _raw_access;\n+  BasicType         _type;\n   uint8_t           _barrier_data;\n \n   void fixup_decorators();\n@@ -114,10 +114,10 @@ class C2Access: public StackObj {\n   C2Access(DecoratorSet decorators,\n            BasicType type, Node* base, C2AccessValuePtr& addr) :\n     _decorators(decorators),\n-    _type(type),\n     _base(base),\n     _addr(addr),\n     _raw_access(nullptr),\n+    _type(type),\n     _barrier_data(0)\n   {}", "target": "--- a/src/hotspot/share/gc/shared/c2/barrierSetC2.hpp\n+++ b/src/hotspot/share/gc/shared/c2/barrierSetC2.hpp\n@@ -102,10 +102,10 @@ class C2AccessValuePtr: public C2AccessValue {\n class C2Access: public StackObj {\n protected:\n   DecoratorSet      _decorators;\n-  BasicType         _type;\n   Node*             _base;\n   C2AccessValuePtr& _addr;\n   Node*             _raw_access;\n+  BasicType         _type;\n   uint8_t           _barrier_data;\n \n   void fixup_decorators();\n@@ -114,10 +114,10 @@ class C2Access: public StackObj {\n   C2Access(DecoratorSet decorators,\n            BasicType type, Node* base, C2AccessValuePtr& addr) :\n     _decorators(decorators),\n-    _type(type),\n     _base(base),\n     _addr(addr),\n     _raw_access(nullptr),\n+    _type(type),\n     _barrier_data(0)\n   {}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：多个C2编译器类的成员变量声明顺序与构造函数初始化列表顺序不一致，可能导致内存布局不紧凑和潜在的性能开销。优化后：统一调整了C2Access、VectorSet、CallJavaNode、ArrayPointer等类的成员变量声明顺序，使其与构造函数初始化列表顺序完全一致。优化思路：通过消除声明与初始化顺序的不匹配，改善内存布局，减少填充字节，提升缓存局部性，从而提高C2编译器运行时的性能。"}
{"id": 852, "source": "riscv-dataset-excel", "optimization_type": "代码重构+内存优化", "optimization_description": "优化前：存在两个功能相似的闭包类PCMarkAndPushClosure和PCIterateMarkAndPushClosure，分别继承自OopClosure和ClaimMetadataVisitingOopIterateClosure，导致代码重复和维护开销。优化后：合并两个闭包类，统一使用继承自ClaimMetadataVisitingOopIterateClosure的PCMarkAndPushClosure，简化了类层次结构，减少了代码重复，并移除了不必要的闭包对象创建开销。优化思路：通过重构消除冗余代码，提高代码可维护性，同时减少内存分配和初始化开销。", "original_code": "存在两个功能相似的闭包类PCMarkAndPushClosure和PCIterateMarkAndPushClosure，分别继承自OopClosure和ClaimMetadataVisitingOopIterateClosure，导致代码重复和维护开销。", "optimized_code": "-class PCMarkAndPushClosure: public OopClosure {\n-private:\n-  ParCompactionManager* _compaction_manager;\n-public:\n-  PCMarkAndPushClosure(ParCompactionManager* cm) : _compaction_manager(cm) { }\n-\n-  template <typename T> void do_oop_work(T* p)      { _compaction_manager->mark_and_push(p); }\n-  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n-};\n-\n-class PCIterateMarkAndPushClosure: public ClaimMetadataVisitingOopIterateClosure {\n-private:\n-  ParCompactionManager* _compaction_manager;\n-public:\n-  PCIterateMarkAndPushClosure(ParCompactionManager* cm, ReferenceProcessor* rp) :\n-    ClaimMetadataVisitingOopIterateClosure(ClassLoaderData::_claim_stw_fullgc_mark, rp),\n-    _compaction_manager(cm) { }\n-\n-  template <typename T> void do_oop_work(T* p)      { _compaction_manager->mark_and_push(p); }\n-  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n-};\n+class PCMarkAndPushClosure: public ClaimMetadataVisitingOopIterateClosure {\n+  ParCompactionManager* _compaction_manager;\n+\n+  template <typename T> void do_oop_work(T* p);\n+public:\n+  PCMarkAndPushClosure(ParCompactionManager* cm, ReferenceProcessor* rp) :\n+    ClaimMetadataVisitingOopIterateClosure(ClassLoaderData::_claim_stw_fullgc_mark, rp),\n+    _compaction_manager(cm) { }\n+\n+  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n+};", "source_url": "https://github.com/openjdk/riscv-port/commit/79bdd811876d75974536aac088bae1719387c97f", "code_v0_no_empty_lines": "存在两个功能相似的闭包类PCMarkAndPushClosure和PCIterateMarkAndPushClosure，分别继承自OopClosure和ClaimMetadataVisitingOopIterateClosure，导致代码重复和维护开销。", "code_v1_no_empty_lines": "-class PCMarkAndPushClosure: public OopClosure {\n-private:\n-  ParCompactionManager* _compaction_manager;\n-public:\n-  PCMarkAndPushClosure(ParCompactionManager* cm) : _compaction_manager(cm) { }\n-\n-  template <typename T> void do_oop_work(T* p)      { _compaction_manager->mark_and_push(p); }\n-  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n-};\n-\n-class PCIterateMarkAndPushClosure: public ClaimMetadataVisitingOopIterateClosure {\n-private:\n-  ParCompactionManager* _compaction_manager;\n-public:\n-  PCIterateMarkAndPushClosure(ParCompactionManager* cm, ReferenceProcessor* rp) :\n-    ClaimMetadataVisitingOopIterateClosure(ClassLoaderData::_claim_stw_fullgc_mark, rp),\n-    _compaction_manager(cm) { }\n-\n-  template <typename T> void do_oop_work(T* p)      { _compaction_manager->mark_and_push(p); }\n-  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n-};\n+class PCMarkAndPushClosure: public ClaimMetadataVisitingOopIterateClosure {\n+  ParCompactionManager* _compaction_manager;\n+\n+  template <typename T> void do_oop_work(T* p);\n+public:\n+  PCMarkAndPushClosure(ParCompactionManager* cm, ReferenceProcessor* rp) :\n+    ClaimMetadataVisitingOopIterateClosure(ClassLoaderData::_claim_stw_fullgc_mark, rp),\n+    _compaction_manager(cm) { }\n+\n+  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n+};", "target": "-class PCMarkAndPushClosure: public OopClosure {\n-private:\n-  ParCompactionManager* _compaction_manager;\n-public:\n-  PCMarkAndPushClosure(ParCompactionManager* cm) : _compaction_manager(cm) { }\n-\n-  template <typename T> void do_oop_work(T* p)      { _compaction_manager->mark_and_push(p); }\n-  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n-};\n-\n-class PCIterateMarkAndPushClosure: public ClaimMetadataVisitingOopIterateClosure {\n-private:\n-  ParCompactionManager* _compaction_manager;\n-public:\n-  PCIterateMarkAndPushClosure(ParCompactionManager* cm, ReferenceProcessor* rp) :\n-    ClaimMetadataVisitingOopIterateClosure(ClassLoaderData::_claim_stw_fullgc_mark, rp),\n-    _compaction_manager(cm) { }\n-\n-  template <typename T> void do_oop_work(T* p)      { _compaction_manager->mark_and_push(p); }\n-  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n-};\n+class PCMarkAndPushClosure: public ClaimMetadataVisitingOopIterateClosure {\n+  ParCompactionManager* _compaction_manager;\n+\n+  template <typename T> void do_oop_work(T* p);\n+public:\n+  PCMarkAndPushClosure(ParCompactionManager* cm, ReferenceProcessor* rp) :\n+    ClaimMetadataVisitingOopIterateClosure(ClassLoaderData::_claim_stw_fullgc_mark, rp),\n+    _compaction_manager(cm) { }\n+\n+  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n+};", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：存在两个功能相似的闭包类PCMarkAndPushClosure和PCIterateMarkAndPushClosure，分别继承自OopClosure和ClaimMetadataVisitingOopIterateClosure，导致代码重复和维护开销。优化后：合并两个闭包类，统一使用继承自ClaimMetadataVisitingOopIterateClosure的PCMarkAndPushClosure，简化了类层次结构，减少了代码重复，并移除了不必要的闭包对象创建开销。优化思路：通过重构消除冗余代码，提高代码可维护性，同时减少内存分配和初始化开销。"}
{"id": 853, "source": "riscv-dataset-excel", "optimization_type": "内存优化+字符串处理优化", "optimization_description": "优化前：LocalDateTime.toString()调用date.toString()和time.toString()，每个toString()创建独立的StringBuilder和字符串对象，导致多次内存分配和字符串拼接开销。优化后：引入formatTo()方法，在LocalDateTime.toString()中创建单个StringBuilder，通过formatTo()方法直接写入，避免中间字符串创建。优化思路：减少内存分配次数，通过预分配StringBuilder容量避免扩容，消除字符串拼接的中间对象，提升toString()性能。", "original_code": "LocalDateTime.toString()调用date.toString()和time.toString()，每个toString()创建独立的StringBuilder和字符串对象，导致多次内存分配和字符串拼接开销。", "optimized_code": "LocalDate.java:\n-    public String toString() {\n+    public String toString() {\n+        var buf = new StringBuilder(10);\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    void formatTo(StringBuilder buf) {\n         int yearValue = year;\n         int monthValue = month;\n         int dayValue = day;\n         int absYear = Math.abs(yearValue);\n-        StringBuilder buf = new StringBuilder(10);\n\nLocalDateTime.java:\n-        return date.toString() + 'T' + time.toString();\n+        var buf = new StringBuilder(29);\n+        date.formatTo(buf);\n+        buf.append('T');\n+        time.formatTo(buf);\n+        return buf.toString();\n\nLocalTime.java:\n-        StringBuilder buf = new StringBuilder(18);\n+        var buf = new StringBuilder(18);\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    void formatTo(StringBuilder buf) {", "source_url": "https://github.com/openjdk/riscv-port/commit/5ff7c57f9ff5428ef3d2aedd7e860bb1e8ff29ea", "code_v0_no_empty_lines": "LocalDateTime.toString()调用date.toString()和time.toString()，每个toString()创建独立的StringBuilder和字符串对象，导致多次内存分配和字符串拼接开销。", "code_v1_no_empty_lines": "LocalDate.java:\n-    public String toString() {\n+    public String toString() {\n+        var buf = new StringBuilder(10);\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    void formatTo(StringBuilder buf) {\n         int yearValue = year;\n         int monthValue = month;\n         int dayValue = day;\n         int absYear = Math.abs(yearValue);\n-        StringBuilder buf = new StringBuilder(10);\n\nLocalDateTime.java:\n-        return date.toString() + 'T' + time.toString();\n+        var buf = new StringBuilder(29);\n+        date.formatTo(buf);\n+        buf.append('T');\n+        time.formatTo(buf);\n+        return buf.toString();\n\nLocalTime.java:\n-        StringBuilder buf = new StringBuilder(18);\n+        var buf = new StringBuilder(18);\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    void formatTo(StringBuilder buf) {", "target": "LocalDate.java:\n-    public String toString() {\n+    public String toString() {\n+        var buf = new StringBuilder(10);\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    void formatTo(StringBuilder buf) {\n         int yearValue = year;\n         int monthValue = month;\n         int dayValue = day;\n         int absYear = Math.abs(yearValue);\n-        StringBuilder buf = new StringBuilder(10);\n\nLocalDateTime.java:\n-        return date.toString() + 'T' + time.toString();\n+        var buf = new StringBuilder(29);\n+        date.formatTo(buf);\n+        buf.append('T');\n+        time.formatTo(buf);\n+        return buf.toString();\n\nLocalTime.java:\n-        StringBuilder buf = new StringBuilder(18);\n+        var buf = new StringBuilder(18);\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    void formatTo(StringBuilder buf) {", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：LocalDateTime.toString()调用date.toString()和time.toString()，每个toString()创建独立的StringBuilder和字符串对象，导致多次内存分配和字符串拼接开销。优化后：引入formatTo()方法，在LocalDateTime.toString()中创建单个StringBuilder，通过formatTo()方法直接写入，避免中间字符串创建。优化思路：减少内存分配次数，通过预分配StringBuilder容量避免扩容，消除字符串拼接的中间对象，提升toString()性能。"}
{"id": 854, "source": "riscv-dataset-excel", "optimization_type": "代码去重与性能优化", "optimization_description": "优化前：Integer和Long类中各自实现了stringSize方法用于计算整数转换为字符串后的长度，代码存在重复。优化后：创建新的DecimalDigits工具类，将stringSize方法统一实现，并在多个调用点（Integer、Long、AbstractStringBuilder、StringConcatHelper等）替换为调用该统一方法。优化思路：通过代码去重减少维护成本，统一实现可能带来更好的JIT优化机会，同时删除重复代码减少了约95行代码。", "original_code": "Integer和Long类中各自实现了stringSize方法用于计算整数转换为字符串后的长度，代码存在重复。", "optimized_code": "新增文件: jdk/internal/util/DecimalDigits.java\n- 在Integer.java中: int size = stringSize(i);\n+ 在Integer.java中: int size = DecimalDigits.stringSize(i);\n- 在Long.java中: int size = stringSize(i);\n+ 在Long.java中: int size = DecimalDigits.stringSize(i);\n- 在AbstractStringBuilder.java中: int spaceNeeded = count + Integer.stringSize(i);\n+ 在AbstractStringBuilder.java中: int spaceNeeded = count + DecimalDigits.stringSize(i);\n- 在StringConcatHelper.java中: return checkOverflow(lengthCoder + Integer.stringSize(value));\n+ 在StringConcatHelper.java中: return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));", "source_url": "https://github.com/openjdk/riscv-port/commit/7f11935461a6ff1ef0fac800fb4264a519e21061", "code_v0_no_empty_lines": "Integer和Long类中各自实现了stringSize方法用于计算整数转换为字符串后的长度，代码存在重复。", "code_v1_no_empty_lines": "新增文件: jdk/internal/util/DecimalDigits.java\n- 在Integer.java中: int size = stringSize(i);\n+ 在Integer.java中: int size = DecimalDigits.stringSize(i);\n- 在Long.java中: int size = stringSize(i);\n+ 在Long.java中: int size = DecimalDigits.stringSize(i);\n- 在AbstractStringBuilder.java中: int spaceNeeded = count + Integer.stringSize(i);\n+ 在AbstractStringBuilder.java中: int spaceNeeded = count + DecimalDigits.stringSize(i);\n- 在StringConcatHelper.java中: return checkOverflow(lengthCoder + Integer.stringSize(value));\n+ 在StringConcatHelper.java中: return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));", "target": "新增文件: jdk/internal/util/DecimalDigits.java\n- 在Integer.java中: int size = stringSize(i);\n+ 在Integer.java中: int size = DecimalDigits.stringSize(i);\n- 在Long.java中: int size = stringSize(i);\n+ 在Long.java中: int size = DecimalDigits.stringSize(i);\n- 在AbstractStringBuilder.java中: int spaceNeeded = count + Integer.stringSize(i);\n+ 在AbstractStringBuilder.java中: int spaceNeeded = count + DecimalDigits.stringSize(i);\n- 在StringConcatHelper.java中: return checkOverflow(lengthCoder + Integer.stringSize(value));\n+ 在StringConcatHelper.java中: return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Integer和Long类中各自实现了stringSize方法用于计算整数转换为字符串后的长度，代码存在重复。优化后：创建新的DecimalDigits工具类，将stringSize方法统一实现，并在多个调用点（Integer、Long、AbstractStringBuilder、StringConcatHelper等）替换为调用该统一方法。优化思路：通过代码去重减少维护成本，统一实现可能带来更好的JIT优化机会，同时删除重复代码减少了约95行代码。"}
{"id": 855, "source": "riscv-dataset-excel", "optimization_type": "指令优化+寄存器优化", "optimization_description": "优化前：将long类型转换为指针类型（CastX2P）时，需要额外的寄存器拷贝操作，增加了指令开销。优化后：通过新增iRegL2P操作数类，允许long寄存器直接作为指针操作数使用，消除了不必要的寄存器拷贝。优化思路：在AArch64架构中，指针和long类型都使用64位寄存器，可以直接复用，通过修改指令匹配规则和操作数类定义，让编译器在生成代码时避免冗余的mov指令。", "original_code": "将long类型转换为指针类型（CastX2P）时，需要额外的寄存器拷贝操作，增加了指令开销。", "optimized_code": "operand iRegL2P(iRegL reg) %{\n  op_cost(0);\n  match(CastX2P reg);\n  format %{ \"l2p($reg)\" %};\n  interface(REG_INTER)\n%}\n\ninstruct addP_reg_reg(iRegPNoSp dst, iRegPorL2P src1, iRegL src2) %{\n  match(Set dst (AddP src1 src2));\n  ins_cost(INSN_COST);\n  format %{ \"add  $dst, $src1, $src2\" %};\n  ins_encode %{\n    __ add(as_Register($dst$$reg),\n           as_Register($src1$$reg),\n           as_Register($src2$$reg));\n  %};\n  ins_pipe(ialu_reg_reg);\n%}", "source_url": "https://github.com/openjdk/riscv-port/commit/d10afa26e5c59475e49b353ed34e8e85d0615d92", "code_v0_no_empty_lines": "将long类型转换为指针类型（CastX2P）时，需要额外的寄存器拷贝操作，增加了指令开销。", "code_v1_no_empty_lines": "operand iRegL2P(iRegL reg) %{\n  op_cost(0);\n  match(CastX2P reg);\n  format %{ \"l2p($reg)\" %};\n  interface(REG_INTER)\n%}\n\ninstruct addP_reg_reg(iRegPNoSp dst, iRegPorL2P src1, iRegL src2) %{\n  match(Set dst (AddP src1 src2));\n  ins_cost(INSN_COST);\n  format %{ \"add  $dst, $src1, $src2\" %};\n  ins_encode %{\n    __ add(as_Register($dst$$reg),\n           as_Register($src1$$reg),\n           as_Register($src2$$reg));\n  %};\n  ins_pipe(ialu_reg_reg);\n%}", "target": "operand iRegL2P(iRegL reg) %{\n  op_cost(0);\n  match(CastX2P reg);\n  format %{ \"l2p($reg)\" %};\n  interface(REG_INTER)\n%}\n\ninstruct addP_reg_reg(iRegPNoSp dst, iRegPorL2P src1, iRegL src2) %{\n  match(Set dst (AddP src1 src2));\n  ins_cost(INSN_COST);\n  format %{ \"add  $dst, $src1, $src2\" %};\n  ins_encode %{\n    __ add(as_Register($dst$$reg),\n           as_Register($src1$$reg),\n           as_Register($src2$$reg));\n  %};\n  ins_pipe(ialu_reg_reg);\n%}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：将long类型转换为指针类型（CastX2P）时，需要额外的寄存器拷贝操作，增加了指令开销。优化后：通过新增iRegL2P操作数类，允许long寄存器直接作为指针操作数使用，消除了不必要的寄存器拷贝。优化思路：在AArch64架构中，指针和long类型都使用64位寄存器，可以直接复用，通过修改指令匹配规则和操作数类定义，让编译器在生成代码时避免冗余的mov指令。"}
{"id": 856, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+控制流优化", "optimization_description": "优化前：CastII节点在创建时可能缺少控制依赖（control dependency），特别是在PhaseIdealLoop::add_template_assertion_predicate()中创建的CastII节点。这可能导致编译器在优化过程中无法正确处理控制流依赖关系。\n\n优化后：1. 移除了CastIINode的无控制参数构造函数，强制所有CastII节点必须指定控制节点。2. 在所有CastII相关节点（CastLL、CastFF、CastDD、CastVV、CheckCastPP）的构造函数中添加了assert(ctrl != nullptr)检查。3. 修复了loopPredicate.cpp和loopTransform.cpp中创建CastII节点时缺少控制参数的问题。4. 在loopopts.cpp的clone方法中为CastII节点显式设置控制依赖。5. 优化了vectorIntrinsics.cpp中的类型转换，将ConvL2INode和CastIINode合并为单个操作。\n\n优化思路：确保所有CastII节点都有正确的控制依赖，这是编译器中间表示（IR）正确性的基本要求。缺少控制依赖可能导致编译器在后续优化阶段（如死代码消除、循环优化）产生错误结果。通过强制指定控制节点并添加断言检查，提高了编译器的健壮性和优化正确性。", "original_code": "CastII节点在创建时可能缺少控制依赖（control dependency），特别是在PhaseIdealLoop::add_template_assertion_predicate()中创建的CastII节点。这可能导致编译器在优化过程中无法正确处理控制流依赖关系。", "optimized_code": "1. CastIINode构造函数修改：\n- CastIINode(Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n+ CastIINode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n\n2. loopPredicate.cpp中CastIINode创建：\n- max_value = new CastIINode(max_value, type_iv);\n+ max_value = new CastIINode(new_proj, max_value, type_iv);\n\n3. loopTransform.cpp中CastIINode创建：\n- max_value = new CastIINode(max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());\n+ max_value = new CastIINode(loop_entry, max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());", "source_url": "https://github.com/openjdk/riscv-port/commit/f61a50598958e928e9a4d81130b077cd6eaf876a", "code_v0_no_empty_lines": "CastII节点在创建时可能缺少控制依赖（control dependency），特别是在PhaseIdealLoop::add_template_assertion_predicate()中创建的CastII节点。这可能导致编译器在优化过程中无法正确处理控制流依赖关系。", "code_v1_no_empty_lines": "1. CastIINode构造函数修改：\n- CastIINode(Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n+ CastIINode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n\n2. loopPredicate.cpp中CastIINode创建：\n- max_value = new CastIINode(max_value, type_iv);\n+ max_value = new CastIINode(new_proj, max_value, type_iv);\n\n3. loopTransform.cpp中CastIINode创建：\n- max_value = new CastIINode(max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());\n+ max_value = new CastIINode(loop_entry, max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());", "target": "1. CastIINode构造函数修改：\n- CastIINode(Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n+ CastIINode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n\n2. loopPredicate.cpp中CastIINode创建：\n- max_value = new CastIINode(max_value, type_iv);\n+ max_value = new CastIINode(new_proj, max_value, type_iv);\n\n3. loopTransform.cpp中CastIINode创建：\n- max_value = new CastIINode(max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());\n+ max_value = new CastIINode(loop_entry, max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CastII节点在创建时可能缺少控制依赖（control dependency），特别是在PhaseIdealLoop::add_template_assertion_predicate()中创建的CastII节点。这可能导致编译器在优化过程中无法正确处理控制流依赖关系。\n\n优化后：1. 移除了CastIINode的无控制参数构造函数，强制所有CastII节点必须指定控制节点。2. 在所有CastII相关节点（CastLL、CastFF、CastDD、CastVV、CheckCastPP）的构造函数中添加了assert(ctrl != nullptr)检查。3. 修复了loopPredicate.cpp和loopTransform.cpp中创建CastII节点时缺少控制参数的问题。4. 在loopopts.cpp的clone方法中为CastII节点显式设置控制依赖。5. 优化了vectorIntrinsics.cpp中的类型转换，将ConvL2INode和CastIINode合并为单个操作。\n\n优化思路：确保所有CastII节点都有正确的控制依赖，这是编译器中间表示（IR）正确性的基本要求。缺少控制依赖可能导致编译器在后续优化阶段（如死代码消除、循环优化）产生错误结果。通过强制指定控制节点并添加断言检查，提高了编译器的健壮性和优化正确性。"}
{"id": 857, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（范围检查消除）", "optimization_description": "优化前：在C2编译器进行范围检查消除（Range Check Elimination）时，当循环步长绝对值为1（abs(stride) == 1）且主循环变为空循环时，数组访问可能被移出循环并使用最终迭代的索引值，这可能导致索引超出范围检查的CastII范围，触发断言失败（assert(!had_error) failed: bad dominance）。\n\n优化后：添加了对abs(stride) == 1情况的特殊处理，在范围检查消除过程中为最终迭代值添加断言谓词（Assertion Predicate）。具体修改包括：1) 引入abs_stride_is_one标志；2) 创建final_iv_placeholder作为占位符节点；3) 在适当位置添加断言谓词来验证最终迭代值的范围；4) 在循环边界更新后用实际计算的final_iv替换占位符。\n\n优化思路：通过添加额外的断言谓词来捕获步长为±1时空循环的特殊情况，确保即使数组访问被移出循环，索引值仍在有效的范围检查范围内，从而避免编译器断言失败并保持正确性。", "original_code": "在C2编译器进行范围检查消除（Range Check Elimination）时，当循环步长绝对值为1（abs(stride) == 1）且主循环变为空循环时，数组访问可能被移出循环并使用最终迭代的索引值，这可能导致索引超出范围检查的CastII范围，触发断言失败（assert(!had_error) failed: bad dominance）。", "optimized_code": "@@ -2871,6 +2871,7 @@ void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n   // Must know if its a count-up or count-down loop\n \n   int stride_con = cl->stride_con();\n+  bool abs_stride_is_one = stride_con == 1 || stride_con == -1;\n   Node* zero = _igvn.longcon(0);\n   Node* one  = _igvn.longcon(1);\n   // Use symmetrical int range [-max_jint,max_jint]\n@@ -2882,6 +2883,15 @@ void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n   Node* loop_entry = cl->skip_strip_mined()->in(LoopNode::EntryControl);\n   assert(loop_entry->is_Proj() && loop_entry->in(0)->is_If(), \"if projection only\");\n \n+  // if abs(stride) == 1, an Assertion Predicate for the final iv value is added. We don't know the final iv value until\n+  // we're done with range check elimination so use a place holder.\n+  Node* final_iv_placeholder = nullptr;\n+  if (abs_stride_is_one) {\n+    final_iv_placeholder = new Node(1);\n+    _igvn.set_type(final_iv_placeholder, TypeInt::INT);\n+    final_iv_placeholder->init_req(0, loop_entry);\n+  }\n+\n   // Check loop body for tests of trip-counter plus loop-invariant vs loop-variant.\n   for (uint i = 0; i < loop->_body.size(); i++) {\n     Node *iff = loop->_body[i];\n@@ -2985,6 +2995,20 @@ void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n           Node* opaque_init = new OpaqueLoopInitNode(C, init);\n           register_new_node(opaque_init, loop_entry);\n \n+          if (abs_stride_is_one) {\n+            // If the main loop becomes empty and the array access for this range check is sunk out of the loop, the index\n+            // for the array access will be set to the index value of the final iteration which could be out of loop.\n+            // Add an Assertion Predicate for that corner case. The final iv is computed from LoopLimit which is the\n+            // LoopNode::limit() only if abs(stride) == 1 otherwise the computation depends on LoopNode::init_trip() as\n+            // well. When LoopLimit only depends on LoopNode::limit(), there are cases where the zero trip guard for the\n+            // main loop doesn't constant fold after range check elimination but, the array access for the final\n+            // iteration of the main loop is out of bound and the index for that access is out of range for the range\n+            // check CastII.\n+            loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n+                                                                         int_limit, stride_con, final_iv_placeholder, false);\n+            assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n+          }\n+\n           // Initialized Assertion Predicate for the value of the initial main-loop.\n           loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n                                                                        int_limit, stride_con, init, false);\n@@ -3116,11 +3140,14 @@ void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n   register_new_node(main_limit, pre_ctrl);\n   // Hack the now-private loop bounds\n   _igvn.replace_input_of(main_cmp, 2, main_limit);\n+  if (abs_stride_is_one) {\n+    Node* final_iv = new SubINode(main_limit, cl->stride());\n+    register_new_node(final_iv, loop_entry);\n+    _igvn.replace_node(final_iv_placeholder, final_iv);\n+  }\n   // The OpaqueNode is unshared by design\n   assert(opqzm->outcnt() == 1, \"cannot hack shared node\");\n   _igvn.replace_input_of(opqzm, 1, main_limit);\n-\n-  return;\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/3baff2af6a30cc6cb2e0d4391db1cf7e61c33f64", "code_v0_no_empty_lines": "在C2编译器进行范围检查消除（Range Check Elimination）时，当循环步长绝对值为1（abs(stride) == 1）且主循环变为空循环时，数组访问可能被移出循环并使用最终迭代的索引值，这可能导致索引超出范围检查的CastII范围，触发断言失败（assert(!had_error) failed: bad dominance）。", "code_v1_no_empty_lines": "@@ -2871,6 +2871,7 @@ void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n   // Must know if its a count-up or count-down loop\n \n   int stride_con = cl->stride_con();\n+  bool abs_stride_is_one = stride_con == 1 || stride_con == -1;\n   Node* zero = _igvn.longcon(0);\n   Node* one  = _igvn.longcon(1);\n   // Use symmetrical int range [-max_jint,max_jint]\n@@ -2882,6 +2883,15 @@ void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n   Node* loop_entry = cl->skip_strip_mined()->in(LoopNode::EntryControl);\n   assert(loop_entry->is_Proj() && loop_entry->in(0)->is_If(), \"if projection only\");\n \n+  // if abs(stride) == 1, an Assertion Predicate for the final iv value is added. We don't know the final iv value until\n+  // we're done with range check elimination so use a place holder.\n+  Node* final_iv_placeholder = nullptr;\n+  if (abs_stride_is_one) {\n+    final_iv_placeholder = new Node(1);\n+    _igvn.set_type(final_iv_placeholder, TypeInt::INT);\n+    final_iv_placeholder->init_req(0, loop_entry);\n+  }\n+\n   // Check loop body for tests of trip-counter plus loop-invariant vs loop-variant.\n   for (uint i = 0; i < loop->_body.size(); i++) {\n     Node *iff = loop->_body[i];\n@@ -2985,6 +2995,20 @@ void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n           Node* opaque_init = new OpaqueLoopInitNode(C, init);\n           register_new_node(opaque_init, loop_entry);\n \n+          if (abs_stride_is_one) {\n+            // If the main loop becomes empty and the array access for this range check is sunk out of the loop, the index\n+            // for the array access will be set to the index value of the final iteration which could be out of loop.\n+            // Add an Assertion Predicate for that corner case. The final iv is computed from LoopLimit which is the\n+            // LoopNode::limit() only if abs(stride) == 1 otherwise the computation depends on LoopNode::init_trip() as\n+            // well. When LoopLimit only depends on LoopNode::limit(), there are cases where the zero trip guard for the\n+            // main loop doesn't constant fold after range check elimination but, the array access for the final\n+            // iteration of the main loop is out of bound and the index for that access is out of range for the range\n+            // check CastII.\n+            loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n+                                                                         int_limit, stride_con, final_iv_placeholder, false);\n+            assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n+          }\n+\n           // Initialized Assertion Predicate for the value of the initial main-loop.\n           loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n                                                                        int_limit, stride_con, init, false);\n@@ -3116,11 +3140,14 @@ void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n   register_new_node(main_limit, pre_ctrl);\n   // Hack the now-private loop bounds\n   _igvn.replace_input_of(main_cmp, 2, main_limit);\n+  if (abs_stride_is_one) {\n+    Node* final_iv = new SubINode(main_limit, cl->stride());\n+    register_new_node(final_iv, loop_entry);\n+    _igvn.replace_node(final_iv_placeholder, final_iv);\n+  }\n   // The OpaqueNode is unshared by design\n   assert(opqzm->outcnt() == 1, \"cannot hack shared node\");\n   _igvn.replace_input_of(opqzm, 1, main_limit);\n-\n-  return;\n }", "target": "@@ -2871,6 +2871,7 @@ void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n   // Must know if its a count-up or count-down loop\n \n   int stride_con = cl->stride_con();\n+  bool abs_stride_is_one = stride_con == 1 || stride_con == -1;\n   Node* zero = _igvn.longcon(0);\n   Node* one  = _igvn.longcon(1);\n   // Use symmetrical int range [-max_jint,max_jint]\n@@ -2882,6 +2883,15 @@ void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n   Node* loop_entry = cl->skip_strip_mined()->in(LoopNode::EntryControl);\n   assert(loop_entry->is_Proj() && loop_entry->in(0)->is_If(), \"if projection only\");\n \n+  // if abs(stride) == 1, an Assertion Predicate for the final iv value is added. We don't know the final iv value until\n+  // we're done with range check elimination so use a place holder.\n+  Node* final_iv_placeholder = nullptr;\n+  if (abs_stride_is_one) {\n+    final_iv_placeholder = new Node(1);\n+    _igvn.set_type(final_iv_placeholder, TypeInt::INT);\n+    final_iv_placeholder->init_req(0, loop_entry);\n+  }\n+\n   // Check loop body for tests of trip-counter plus loop-invariant vs loop-variant.\n   for (uint i = 0; i < loop->_body.size(); i++) {\n     Node *iff = loop->_body[i];\n@@ -2985,6 +2995,20 @@ void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n           Node* opaque_init = new OpaqueLoopInitNode(C, init);\n           register_new_node(opaque_init, loop_entry);\n \n+          if (abs_stride_is_one) {\n+            // If the main loop becomes empty and the array access for this range check is sunk out of the loop, the index\n+            // for the array access will be set to the index value of the final iteration which could be out of loop.\n+            // Add an Assertion Predicate for that corner case. The final iv is computed from LoopLimit which is the\n+            // LoopNode::limit() only if abs(stride) == 1 otherwise the computation depends on LoopNode::init_trip() as\n+            // well. When LoopLimit only depends on LoopNode::limit(), there are cases where the zero trip guard for the\n+            // main loop doesn't constant fold after range check elimination but, the array access for the final\n+            // iteration of the main loop is out of bound and the index for that access is out of range for the range\n+            // check CastII.\n+            loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n+                                                                         int_limit, stride_con, final_iv_placeholder, false);\n+            assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n+          }\n+\n           // Initialized Assertion Predicate for the value of the initial main-loop.\n           loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n                                                                        int_limit, stride_con, init, false);\n@@ -3116,11 +3140,14 @@ void PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n   register_new_node(main_limit, pre_ctrl);\n   // Hack the now-private loop bounds\n   _igvn.replace_input_of(main_cmp, 2, main_limit);\n+  if (abs_stride_is_one) {\n+    Node* final_iv = new SubINode(main_limit, cl->stride());\n+    register_new_node(final_iv, loop_entry);\n+    _igvn.replace_node(final_iv_placeholder, final_iv);\n+  }\n   // The OpaqueNode is unshared by design\n   assert(opqzm->outcnt() == 1, \"cannot hack shared node\");\n   _igvn.replace_input_of(opqzm, 1, main_limit);\n-\n-  return;\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在C2编译器进行范围检查消除（Range Check Elimination）时，当循环步长绝对值为1（abs(stride) == 1）且主循环变为空循环时，数组访问可能被移出循环并使用最终迭代的索引值，这可能导致索引超出范围检查的CastII范围，触发断言失败（assert(!had_error) failed: bad dominance）。\n\n优化后：添加了对abs(stride) == 1情况的特殊处理，在范围检查消除过程中为最终迭代值添加断言谓词（Assertion Predicate）。具体修改包括：1) 引入abs_stride_is_one标志；2) 创建final_iv_placeholder作为占位符节点；3) 在适当位置添加断言谓词来验证最终迭代值的范围；4) 在循环边界更新后用实际计算的final_iv替换占位符。\n\n优化思路：通过添加额外的断言谓词来捕获步长为±1时空循环的特殊情况，确保即使数组访问被移出循环，索引值仍在有效的范围检查范围内，从而避免编译器断言失败并保持正确性。"}
{"id": 858, "source": "riscv-dataset-excel", "optimization_type": "并行性能优化", "optimization_description": "优化前：ShenandoahParallelRegionStride使用固定值1024，当活跃工作线程数变化时，并行区域迭代的任务分配可能不均衡，导致某些线程负载过重而其他线程空闲。\n\n优化后：将ShenandoahParallelRegionStride默认值改为0，当stride=0且活跃工作线程>1时，自动根据区域数量和工作线程数动态计算stride值。采用公式(n_regions + active_workers - 1) / active_workers确保工作负载均匀分配，同时设置4096的阈值避免对小任务过度分割。\n\n优化思路：通过动态任务分配策略，根据实际工作线程数和堆区域数量自动调整并行粒度，提高多核CPU利用率，减少线程间负载不均衡带来的性能损失，特别是在不同硬件配置和工作负载下获得更好的并行性能。", "original_code": "ShenandoahParallelRegionStride使用固定值1024，当活跃工作线程数变化时，并行区域迭代的任务分配可能不均衡，导致某些线程负载过重而其他线程空闲。", "optimized_code": "1. ShenandoahParallelHeapRegionTask构造函数增加stride参数：\n- ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk) :\n+ ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk, size_t stride) :\n\n2. parallel_heap_region_iterate函数中动态计算stride：\n- if (num_regions() > ShenandoahParallelRegionStride) {\n-   ShenandoahParallelHeapRegionTask task(blk);\n+ const uint active_workers = workers()->active_workers();\n+ const size_t n_regions = num_regions();\n+ size_t stride = ShenandoahParallelRegionStride;\n+ if (stride == 0 && active_workers > 1) {\n+   constexpr size_t threshold = 4096;\n+   stride = n_regions <= threshold ?\n+           threshold :\n+           (n_regions + active_workers - 1) / active_workers;\n+ }\n+ if (n_regions > stride && active_workers > 1) {\n+   ShenandoahParallelHeapRegionTask task(blk, stride);\n\n3. 全局变量默认值修改：\n- product(uintx, ShenandoahParallelRegionStride, 1024, EXPERIMENTAL,\n+ product(uintx, ShenandoahParallelRegionStride, 0, EXPERIMENTAL,", "source_url": "https://github.com/openjdk/riscv-port/commit/e74edbaea9f09169f597a470f647f3b7d10cc71b", "code_v0_no_empty_lines": "ShenandoahParallelRegionStride使用固定值1024，当活跃工作线程数变化时，并行区域迭代的任务分配可能不均衡，导致某些线程负载过重而其他线程空闲。", "code_v1_no_empty_lines": "1. ShenandoahParallelHeapRegionTask构造函数增加stride参数：\n- ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk) :\n+ ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk, size_t stride) :\n\n2. parallel_heap_region_iterate函数中动态计算stride：\n- if (num_regions() > ShenandoahParallelRegionStride) {\n-   ShenandoahParallelHeapRegionTask task(blk);\n+ const uint active_workers = workers()->active_workers();\n+ const size_t n_regions = num_regions();\n+ size_t stride = ShenandoahParallelRegionStride;\n+ if (stride == 0 && active_workers > 1) {\n+   constexpr size_t threshold = 4096;\n+   stride = n_regions <= threshold ?\n+           threshold :\n+           (n_regions + active_workers - 1) / active_workers;\n+ }\n+ if (n_regions > stride && active_workers > 1) {\n+   ShenandoahParallelHeapRegionTask task(blk, stride);\n\n3. 全局变量默认值修改：\n- product(uintx, ShenandoahParallelRegionStride, 1024, EXPERIMENTAL,\n+ product(uintx, ShenandoahParallelRegionStride, 0, EXPERIMENTAL,", "target": "1. ShenandoahParallelHeapRegionTask构造函数增加stride参数：\n- ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk) :\n+ ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk, size_t stride) :\n\n2. parallel_heap_region_iterate函数中动态计算stride：\n- if (num_regions() > ShenandoahParallelRegionStride) {\n-   ShenandoahParallelHeapRegionTask task(blk);\n+ const uint active_workers = workers()->active_workers();\n+ const size_t n_regions = num_regions();\n+ size_t stride = ShenandoahParallelRegionStride;\n+ if (stride == 0 && active_workers > 1) {\n+   constexpr size_t threshold = 4096;\n+   stride = n_regions <= threshold ?\n+           threshold :\n+           (n_regions + active_workers - 1) / active_workers;\n+ }\n+ if (n_regions > stride && active_workers > 1) {\n+   ShenandoahParallelHeapRegionTask task(blk, stride);\n\n3. 全局变量默认值修改：\n- product(uintx, ShenandoahParallelRegionStride, 1024, EXPERIMENTAL,\n+ product(uintx, ShenandoahParallelRegionStride, 0, EXPERIMENTAL,", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：ShenandoahParallelRegionStride使用固定值1024，当活跃工作线程数变化时，并行区域迭代的任务分配可能不均衡，导致某些线程负载过重而其他线程空闲。\n\n优化后：将ShenandoahParallelRegionStride默认值改为0，当stride=0且活跃工作线程>1时，自动根据区域数量和工作线程数动态计算stride值。采用公式(n_regions + active_workers - 1) / active_workers确保工作负载均匀分配，同时设置4096的阈值避免对小任务过度分割。\n\n优化思路：通过动态任务分配策略，根据实际工作线程数和堆区域数量自动调整并行粒度，提高多核CPU利用率，减少线程间负载不均衡带来的性能损失，特别是在不同硬件配置和工作负载下获得更好的并行性能。"}
{"id": 859, "source": "riscv-dataset-excel", "optimization_type": "字符串处理优化", "optimization_description": "优化前：LocalTime.toString()在处理纳秒部分时，通过Integer.toString()生成字符串并调用substring(1)来去除前导零，涉及字符串拼接和子串操作，效率较低。优化后：1. 使用DecimalDigits.stringSize()计算数字位数，通过StringBuilder.repeat()直接生成前导零，避免字符串转换。2. 直接计算数字值并追加，减少中间字符串对象创建。优化思路：减少临时字符串对象分配，利用StringBuilder.repeat()高效生成重复字符，提升字符串构建性能。", "original_code": "LocalTime.toString()在处理纳秒部分时，通过Integer.toString()生成字符串并调用substring(1)来去除前导零，涉及字符串拼接和子串操作，效率较低。", "optimized_code": "-                if (nanoValue % 1000_000 == 0) {\n-                    buf.append(Integer.toString((nanoValue / 1000_000) + 1000).substring(1));\n-                } else if (nanoValue % 1000 == 0) {\n-                    buf.append(Integer.toString((nanoValue / 1000) + 1000_000).substring(1));\n-                } else {\n-                    buf.append(Integer.toString((nanoValue) + 1000_000_000).substring(1));\n-                }\n+                int zeros = 9 - DecimalDigits.stringSize(nanoValue);\n+                if (zeros > 0) {\n+                    buf.repeat('0', zeros);\n+                }\n+                int digits;\n+                if (nanoValue % 1_000_000 == 0) {\n+                    digits = nanoValue / 1_000_000;\n+                } else if (nanoValue % 1000 == 0) {\n+                    digits = nanoValue / 1000;\n+                } else {\n+                    digits = nanoValue;\n+                }\n+                buf.append(digits);", "source_url": "https://github.com/openjdk/riscv-port/commit/0898ab7f7496689e5de52a5dc4530ca21def1fca", "code_v0_no_empty_lines": "LocalTime.toString()在处理纳秒部分时，通过Integer.toString()生成字符串并调用substring(1)来去除前导零，涉及字符串拼接和子串操作，效率较低。", "code_v1_no_empty_lines": "-                if (nanoValue % 1000_000 == 0) {\n-                    buf.append(Integer.toString((nanoValue / 1000_000) + 1000).substring(1));\n-                } else if (nanoValue % 1000 == 0) {\n-                    buf.append(Integer.toString((nanoValue / 1000) + 1000_000).substring(1));\n-                } else {\n-                    buf.append(Integer.toString((nanoValue) + 1000_000_000).substring(1));\n-                }\n+                int zeros = 9 - DecimalDigits.stringSize(nanoValue);\n+                if (zeros > 0) {\n+                    buf.repeat('0', zeros);\n+                }\n+                int digits;\n+                if (nanoValue % 1_000_000 == 0) {\n+                    digits = nanoValue / 1_000_000;\n+                } else if (nanoValue % 1000 == 0) {\n+                    digits = nanoValue / 1000;\n+                } else {\n+                    digits = nanoValue;\n+                }\n+                buf.append(digits);", "target": "-                if (nanoValue % 1000_000 == 0) {\n-                    buf.append(Integer.toString((nanoValue / 1000_000) + 1000).substring(1));\n-                } else if (nanoValue % 1000 == 0) {\n-                    buf.append(Integer.toString((nanoValue / 1000) + 1000_000).substring(1));\n-                } else {\n-                    buf.append(Integer.toString((nanoValue) + 1000_000_000).substring(1));\n-                }\n+                int zeros = 9 - DecimalDigits.stringSize(nanoValue);\n+                if (zeros > 0) {\n+                    buf.repeat('0', zeros);\n+                }\n+                int digits;\n+                if (nanoValue % 1_000_000 == 0) {\n+                    digits = nanoValue / 1_000_000;\n+                } else if (nanoValue % 1000 == 0) {\n+                    digits = nanoValue / 1000;\n+                } else {\n+                    digits = nanoValue;\n+                }\n+                buf.append(digits);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：LocalTime.toString()在处理纳秒部分时，通过Integer.toString()生成字符串并调用substring(1)来去除前导零，涉及字符串拼接和子串操作，效率较低。优化后：1. 使用DecimalDigits.stringSize()计算数字位数，通过StringBuilder.repeat()直接生成前导零，避免字符串转换。2. 直接计算数字值并追加，减少中间字符串对象创建。优化思路：减少临时字符串对象分配，利用StringBuilder.repeat()高效生成重复字符，提升字符串构建性能。"}
{"id": 860, "source": "riscv-dataset-excel", "optimization_type": "代码清理与内存优化", "optimization_description": "优化前：Direct-X-Buffer模板中为所有读写类型缓存了UNALIGNED字段，但该字段仅在字节缓冲区中使用，导致其他类型缓冲区存在未使用的静态字段开销。优化后：将UNALIGNED字段从通用模板位置移除，仅在字节缓冲区部分声明，消除了其他类型缓冲区的冗余内存占用和类加载开销。优化思路：通过分析字段使用范围，将仅限特定类型使用的字段移至对应条件编译块中，减少无用静态字段的内存分配和初始化成本。", "original_code": "Direct-X-Buffer模板中为所有读写类型缓存了UNALIGNED字段，但该字段仅在字节缓冲区中使用，导致其他类型缓冲区存在未使用的静态字段开销。", "optimized_code": "-    // Cached unaligned-access capability\n-    protected static final boolean UNALIGNED = Bits.unaligned();\n-\n-    // Base address, used in all indexing calculations\n-    // NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress\n-    //    protected long address;\n+    // Cached unaligned-access capability\n+    static final boolean UNALIGNED = Bits.unaligned();", "source_url": "https://github.com/openjdk/riscv-port/commit/e716f5ed53c20f4235787e2d6927a16ebcf67b8f", "code_v0_no_empty_lines": "Direct-X-Buffer模板中为所有读写类型缓存了UNALIGNED字段，但该字段仅在字节缓冲区中使用，导致其他类型缓冲区存在未使用的静态字段开销。", "code_v1_no_empty_lines": "-    // Cached unaligned-access capability\n-    protected static final boolean UNALIGNED = Bits.unaligned();\n-\n-    // Base address, used in all indexing calculations\n-    // NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress\n-    //    protected long address;\n+    // Cached unaligned-access capability\n+    static final boolean UNALIGNED = Bits.unaligned();", "target": "-    // Cached unaligned-access capability\n-    protected static final boolean UNALIGNED = Bits.unaligned();\n-\n-    // Base address, used in all indexing calculations\n-    // NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress\n-    //    protected long address;\n+    // Cached unaligned-access capability\n+    static final boolean UNALIGNED = Bits.unaligned();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Direct-X-Buffer模板中为所有读写类型缓存了UNALIGNED字段，但该字段仅在字节缓冲区中使用，导致其他类型缓冲区存在未使用的静态字段开销。优化后：将UNALIGNED字段从通用模板位置移除，仅在字节缓冲区部分声明，消除了其他类型缓冲区的冗余内存占用和类加载开销。优化思路：通过分析字段使用范围，将仅限特定类型使用的字段移至对应条件编译块中，减少无用静态字段的内存分配和初始化成本。"}
{"id": 861, "source": "riscv-dataset-excel", "optimization_type": "条件优化+性能调优", "optimization_description": "优化前：仅根据UseRVV标志启用ChaCha20指令集优化。优化后：增加MaxVectorSize >= 32的条件检查，避免在向量大小为16时启用优化（实测会导致性能下降）。优化思路：通过硬件性能测试发现向量大小16时存在性能回归，因此添加额外条件限制，确保只在向量大小足够（>=32）时才启用该优化，避免性能损失。", "original_code": "仅根据UseRVV标志启用ChaCha20指令集优化。", "optimized_code": "-  if (UseRVV) {\n+  if (UseRVV && MaxVectorSize >= 32) {\n+    // performance tests on hardwares (MaxVectorSize == 16, 32) show that\n+    // it brings regression when MaxVectorSize == 16.", "source_url": "https://github.com/openjdk/riscv-port/commit/9d8791864ec48f3321707d7f7805cd3618fc3b51", "code_v0_no_empty_lines": "仅根据UseRVV标志启用ChaCha20指令集优化。", "code_v1_no_empty_lines": "-  if (UseRVV) {\n+  if (UseRVV && MaxVectorSize >= 32) {\n+    // performance tests on hardwares (MaxVectorSize == 16, 32) show that\n+    // it brings regression when MaxVectorSize == 16.", "target": "-  if (UseRVV) {\n+  if (UseRVV && MaxVectorSize >= 32) {\n+    // performance tests on hardwares (MaxVectorSize == 16, 32) show that\n+    // it brings regression when MaxVectorSize == 16.", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：仅根据UseRVV标志启用ChaCha20指令集优化。优化后：增加MaxVectorSize >= 32的条件检查，避免在向量大小为16时启用优化（实测会导致性能下降）。优化思路：通过硬件性能测试发现向量大小16时存在性能回归，因此添加额外条件限制，确保只在向量大小足够（>=32）时才启用该优化，避免性能损失。"}
{"id": 862, "source": "riscv-dataset-excel", "optimization_type": "内存布局优化", "optimization_description": "优化前：类成员变量声明顺序与初始化列表顺序不一致，可能导致内存布局不紧凑，增加填充字节。优化后：调整多个类（Instruction、Intrinsic、LIR_Address、LIR_OpTypeCheck、LIR_Op2）的成员变量声明顺序，使其与初始化列表顺序严格对齐。优化思路：通过重新排列类布局，减少内存填充，改善缓存局部性，提升C1编译器运行时性能。", "original_code": "类成员变量声明顺序与初始化列表顺序不一致，可能导致内存布局不紧凑，增加填充字节。", "optimized_code": "--- a/src/hotspot/share/c1/c1_Instruction.hpp\n+++ b/src/hotspot/share/c1/c1_Instruction.hpp\n@@ -281,11 +281,11 @@ class Instruction: public CompilationResourceObj {\n   int          _use_count;\n   int          _pin_state;\n+  unsigned int _flags;\n   ValueType*   _type;\n   Instruction* _next;\n   Instruction* _subst;\n   LIR_Opr      _operand;\n-  unsigned int _flags;\n--- a/src/hotspot/share/c1/c1_LIR.hpp\n+++ b/src/hotspot/share/c1/c1_LIR.hpp\n@@ -528,44 +528,44 @@ class LIR_Address: public LIR_OprPtr {\n   LIR_Opr   _base;\n   LIR_Opr   _index;\n-  Scale     _scale;\n   intx      _disp;\n+  Scale     _scale;\n   BasicType _type;", "source_url": "https://github.com/openjdk/riscv-port/commit/24f67d0254c08a668d24f28ec0fa768ef10feed5", "code_v0_no_empty_lines": "类成员变量声明顺序与初始化列表顺序不一致，可能导致内存布局不紧凑，增加填充字节。", "code_v1_no_empty_lines": "--- a/src/hotspot/share/c1/c1_Instruction.hpp\n+++ b/src/hotspot/share/c1/c1_Instruction.hpp\n@@ -281,11 +281,11 @@ class Instruction: public CompilationResourceObj {\n   int          _use_count;\n   int          _pin_state;\n+  unsigned int _flags;\n   ValueType*   _type;\n   Instruction* _next;\n   Instruction* _subst;\n   LIR_Opr      _operand;\n-  unsigned int _flags;\n--- a/src/hotspot/share/c1/c1_LIR.hpp\n+++ b/src/hotspot/share/c1/c1_LIR.hpp\n@@ -528,44 +528,44 @@ class LIR_Address: public LIR_OprPtr {\n   LIR_Opr   _base;\n   LIR_Opr   _index;\n-  Scale     _scale;\n   intx      _disp;\n+  Scale     _scale;\n   BasicType _type;", "target": "--- a/src/hotspot/share/c1/c1_Instruction.hpp\n+++ b/src/hotspot/share/c1/c1_Instruction.hpp\n@@ -281,11 +281,11 @@ class Instruction: public CompilationResourceObj {\n   int          _use_count;\n   int          _pin_state;\n+  unsigned int _flags;\n   ValueType*   _type;\n   Instruction* _next;\n   Instruction* _subst;\n   LIR_Opr      _operand;\n-  unsigned int _flags;\n--- a/src/hotspot/share/c1/c1_LIR.hpp\n+++ b/src/hotspot/share/c1/c1_LIR.hpp\n@@ -528,44 +528,44 @@ class LIR_Address: public LIR_OprPtr {\n   LIR_Opr   _base;\n   LIR_Opr   _index;\n-  Scale     _scale;\n   intx      _disp;\n+  Scale     _scale;\n   BasicType _type;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：类成员变量声明顺序与初始化列表顺序不一致，可能导致内存布局不紧凑，增加填充字节。优化后：调整多个类（Instruction、Intrinsic、LIR_Address、LIR_OpTypeCheck、LIR_Op2）的成员变量声明顺序，使其与初始化列表顺序严格对齐。优化思路：通过重新排列类布局，减少内存填充，改善缓存局部性，提升C1编译器运行时性能。"}
{"id": 863, "source": "riscv-dataset-excel", "optimization_type": "代码重构+可读性优化", "optimization_description": "优化前：使用传统的if-else链进行类型检查和分支处理，代码冗长且可读性差，包含重复的类型检查逻辑。优化后：使用Java的模式匹配switch表达式重构代码，将多个instanceof检查合并为简洁的case分支，提高了代码的可读性和维护性。优化思路：利用Java语言新特性（模式匹配switch）简化复杂的类型检查逻辑，减少代码行数（从143行减少到118行），使代码结构更清晰，同时保持相同的功能逻辑。", "original_code": "使用传统的if-else链进行类型检查和分支处理，代码冗长且可读性差，包含重复的类型检查逻辑。", "optimized_code": "- if (number instanceof Long || number instanceof Integer\n                || number instanceof Short || number instanceof Byte\n                || number instanceof AtomicInteger\n                || number instanceof AtomicLong\n                || (number instanceof BigInteger\n                && ((BigInteger) number).bitLength() < 64)) {\n            return format(((Number) number).longValue(), toAppendTo,\n                    fieldPosition);\n        } else if (number instanceof BigDecimal) {\n            return format((BigDecimal) number, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n        } else if (number instanceof BigInteger) {\n            return format((BigInteger) number, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n        } else if (number instanceof Number) {\n            return format(((Number) number).doubleValue(), toAppendTo, fieldPosition);\n        } else {\n            throw new IllegalArgumentException(\"Cannot format \"\n                    + number.getClass().getName() + \" as a number\");\n        }\n+        return switch (number) {\n+            case Long l -> format(l.longValue(), toAppendTo, fieldPosition);\n+            case Integer i -> format(i.longValue(), toAppendTo, fieldPosition);\n+            case Short s -> format(s.longValue(), toAppendTo, fieldPosition);\n+            case Byte b -> format(b.longValue(), toAppendTo, fieldPosition);\n+            case AtomicInteger ai -> format(ai.longValue(), toAppendTo, fieldPosition);\n+            case AtomicLong al -> format(al.longValue(), toAppendTo, fieldPosition);\n+            case BigInteger bi when bi.bitLength() < 64 -> format(bi.longValue(), toAppendTo, fieldPosition);\n+            case BigDecimal bd -> format(bd, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n+            case BigInteger bi -> format(bi, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n+            case Number n -> format(n.doubleValue(), toAppendTo, fieldPosition);\n+            case null -> throw new IllegalArgumentException(\"Cannot format null as a number\");\n+            default -> throw new IllegalArgumentException(\n+                    String.format(\"Cannot format %s as a number\", number.getClass().getName()));\n+        };", "source_url": "https://github.com/openjdk/riscv-port/commit/5a8861a3a1b436ce7414176c095c58c9a1e038d6", "code_v0_no_empty_lines": "使用传统的if-else链进行类型检查和分支处理，代码冗长且可读性差，包含重复的类型检查逻辑。", "code_v1_no_empty_lines": "- if (number instanceof Long || number instanceof Integer\n                || number instanceof Short || number instanceof Byte\n                || number instanceof AtomicInteger\n                || number instanceof AtomicLong\n                || (number instanceof BigInteger\n                && ((BigInteger) number).bitLength() < 64)) {\n            return format(((Number) number).longValue(), toAppendTo,\n                    fieldPosition);\n        } else if (number instanceof BigDecimal) {\n            return format((BigDecimal) number, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n        } else if (number instanceof BigInteger) {\n            return format((BigInteger) number, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n        } else if (number instanceof Number) {\n            return format(((Number) number).doubleValue(), toAppendTo, fieldPosition);\n        } else {\n            throw new IllegalArgumentException(\"Cannot format \"\n                    + number.getClass().getName() + \" as a number\");\n        }\n+        return switch (number) {\n+            case Long l -> format(l.longValue(), toAppendTo, fieldPosition);\n+            case Integer i -> format(i.longValue(), toAppendTo, fieldPosition);\n+            case Short s -> format(s.longValue(), toAppendTo, fieldPosition);\n+            case Byte b -> format(b.longValue(), toAppendTo, fieldPosition);\n+            case AtomicInteger ai -> format(ai.longValue(), toAppendTo, fieldPosition);\n+            case AtomicLong al -> format(al.longValue(), toAppendTo, fieldPosition);\n+            case BigInteger bi when bi.bitLength() < 64 -> format(bi.longValue(), toAppendTo, fieldPosition);\n+            case BigDecimal bd -> format(bd, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n+            case BigInteger bi -> format(bi, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n+            case Number n -> format(n.doubleValue(), toAppendTo, fieldPosition);\n+            case null -> throw new IllegalArgumentException(\"Cannot format null as a number\");\n+            default -> throw new IllegalArgumentException(\n+                    String.format(\"Cannot format %s as a number\", number.getClass().getName()));\n+        };", "target": "- if (number instanceof Long || number instanceof Integer\n                || number instanceof Short || number instanceof Byte\n                || number instanceof AtomicInteger\n                || number instanceof AtomicLong\n                || (number instanceof BigInteger\n                && ((BigInteger) number).bitLength() < 64)) {\n            return format(((Number) number).longValue(), toAppendTo,\n                    fieldPosition);\n        } else if (number instanceof BigDecimal) {\n            return format((BigDecimal) number, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n        } else if (number instanceof BigInteger) {\n            return format((BigInteger) number, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n        } else if (number instanceof Number) {\n            return format(((Number) number).doubleValue(), toAppendTo, fieldPosition);\n        } else {\n            throw new IllegalArgumentException(\"Cannot format \"\n                    + number.getClass().getName() + \" as a number\");\n        }\n+        return switch (number) {\n+            case Long l -> format(l.longValue(), toAppendTo, fieldPosition);\n+            case Integer i -> format(i.longValue(), toAppendTo, fieldPosition);\n+            case Short s -> format(s.longValue(), toAppendTo, fieldPosition);\n+            case Byte b -> format(b.longValue(), toAppendTo, fieldPosition);\n+            case AtomicInteger ai -> format(ai.longValue(), toAppendTo, fieldPosition);\n+            case AtomicLong al -> format(al.longValue(), toAppendTo, fieldPosition);\n+            case BigInteger bi when bi.bitLength() < 64 -> format(bi.longValue(), toAppendTo, fieldPosition);\n+            case BigDecimal bd -> format(bd, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n+            case BigInteger bi -> format(bi, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n+            case Number n -> format(n.doubleValue(), toAppendTo, fieldPosition);\n+            case null -> throw new IllegalArgumentException(\"Cannot format null as a number\");\n+            default -> throw new IllegalArgumentException(\n+                    String.format(\"Cannot format %s as a number\", number.getClass().getName()));\n+        };", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用传统的if-else链进行类型检查和分支处理，代码冗长且可读性差，包含重复的类型检查逻辑。优化后：使用Java的模式匹配switch表达式重构代码，将多个instanceof检查合并为简洁的case分支，提高了代码的可读性和维护性。优化思路：利用Java语言新特性（模式匹配switch）简化复杂的类型检查逻辑，减少代码行数（从143行减少到118行），使代码结构更清晰，同时保持相同的功能逻辑。"}
{"id": 864, "source": "riscv-dataset-excel", "optimization_type": "字符串拼接性能优化", "optimization_description": "优化前：String.concat()调用simpleConcat方法，该方法通过mix()函数计算长度和编码器，然后调用prepend()反向填充字节数组，涉及多个函数调用和复杂计算。优化后：引入doConcat()方法直接计算编码器和长度，使用getBytes()直接复制字节数据，简化了计算流程并减少函数调用。优化思路：针对两个非空字符串的简单拼接场景，消除中间计算步骤，直接操作字节数组，提高性能并减少内存分配开销。", "original_code": "String.concat()调用simpleConcat方法，该方法通过mix()函数计算长度和编码器，然后调用prepend()反向填充字节数组，涉及多个函数调用和复杂计算。", "optimized_code": "-        // start \"mixing\" in length and coder or arguments, order is not\n-        // important\n-        long indexCoder = mix(initialCoder(), s1);\n-        indexCoder = mix(indexCoder, s2);\n-        byte[] buf = newArray(indexCoder);\n-        // prepend each argument in reverse order, since we prepending\n-        // from the end of the byte array\n-        indexCoder = prepend(indexCoder, buf, s2, s1);\n-        return newString(buf, indexCoder);\n+        return doConcat(s1, s2);\n+    }\n+\n+    /**\n+     * Perform a simple concatenation between two non-empty strings.\n+     *\n+     * @param s1         first argument\n+     * @param s2         second argument\n+     * @return String    resulting string\n+     */\n+    @ForceInline\n+    static String doConcat(String s1, String s2) {\n+        byte coder = (byte) (s1.coder() | s2.coder());\n+        int newLength = (s1.length() + s2.length()) << coder;\n+        byte[] buf = newArray(newLength);\n+        s1.getBytes(buf, 0, coder);\n+        s2.getBytes(buf, s1.length(), coder);\n+        return new String(buf, coder);", "source_url": "https://github.com/openjdk/riscv-port/commit/476d2ae69d6f67fdf9e2a9353f224141318690f2", "code_v0_no_empty_lines": "String.concat()调用simpleConcat方法，该方法通过mix()函数计算长度和编码器，然后调用prepend()反向填充字节数组，涉及多个函数调用和复杂计算。", "code_v1_no_empty_lines": "-        // start \"mixing\" in length and coder or arguments, order is not\n-        // important\n-        long indexCoder = mix(initialCoder(), s1);\n-        indexCoder = mix(indexCoder, s2);\n-        byte[] buf = newArray(indexCoder);\n-        // prepend each argument in reverse order, since we prepending\n-        // from the end of the byte array\n-        indexCoder = prepend(indexCoder, buf, s2, s1);\n-        return newString(buf, indexCoder);\n+        return doConcat(s1, s2);\n+    }\n+\n+    /**\n+     * Perform a simple concatenation between two non-empty strings.\n+     *\n+     * @param s1         first argument\n+     * @param s2         second argument\n+     * @return String    resulting string\n+     */\n+    @ForceInline\n+    static String doConcat(String s1, String s2) {\n+        byte coder = (byte) (s1.coder() | s2.coder());\n+        int newLength = (s1.length() + s2.length()) << coder;\n+        byte[] buf = newArray(newLength);\n+        s1.getBytes(buf, 0, coder);\n+        s2.getBytes(buf, s1.length(), coder);\n+        return new String(buf, coder);", "target": "-        // start \"mixing\" in length and coder or arguments, order is not\n-        // important\n-        long indexCoder = mix(initialCoder(), s1);\n-        indexCoder = mix(indexCoder, s2);\n-        byte[] buf = newArray(indexCoder);\n-        // prepend each argument in reverse order, since we prepending\n-        // from the end of the byte array\n-        indexCoder = prepend(indexCoder, buf, s2, s1);\n-        return newString(buf, indexCoder);\n+        return doConcat(s1, s2);\n+    }\n+\n+    /**\n+     * Perform a simple concatenation between two non-empty strings.\n+     *\n+     * @param s1         first argument\n+     * @param s2         second argument\n+     * @return String    resulting string\n+     */\n+    @ForceInline\n+    static String doConcat(String s1, String s2) {\n+        byte coder = (byte) (s1.coder() | s2.coder());\n+        int newLength = (s1.length() + s2.length()) << coder;\n+        byte[] buf = newArray(newLength);\n+        s1.getBytes(buf, 0, coder);\n+        s2.getBytes(buf, s1.length(), coder);\n+        return new String(buf, coder);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：String.concat()调用simpleConcat方法，该方法通过mix()函数计算长度和编码器，然后调用prepend()反向填充字节数组，涉及多个函数调用和复杂计算。优化后：引入doConcat()方法直接计算编码器和长度，使用getBytes()直接复制字节数据，简化了计算流程并减少函数调用。优化思路：针对两个非空字符串的简单拼接场景，消除中间计算步骤，直接操作字节数组，提高性能并减少内存分配开销。"}
{"id": 865, "source": "riscv-dataset-excel", "optimization_type": "字符串构建优化", "optimization_description": "优化前：对于年份小于1000的情况，通过数学运算和字符串删除操作来格式化年份（例如：yearValue-10000然后删除第二个字符）。优化后：直接使用StringBuilder.repeat方法添加前导零，并直接追加年份绝对值。优化思路：利用StringBuilder.repeat方法简化代码逻辑，减少字符串操作次数，提高字符串构建效率。", "original_code": "对于年份小于1000的情况，通过数学运算和字符串删除操作来格式化年份（例如：yearValue-10000然后删除第二个字符）。", "optimized_code": "-                buf.append(yearValue - 10000).deleteCharAt(1);\n-            } else {\n-                buf.append(yearValue + 10000).deleteCharAt(0);\n+                buf.append('-');\n             }\n+            buf.repeat('0', absYear < 10 ? 3 : absYear < 100 ? 2 : 1);\n+            buf.append(absYear);", "source_url": "https://github.com/openjdk/riscv-port/commit/491b9f5efc01fa36fb3c174e130b46bc69c8d707", "code_v0_no_empty_lines": "对于年份小于1000的情况，通过数学运算和字符串删除操作来格式化年份（例如：yearValue-10000然后删除第二个字符）。", "code_v1_no_empty_lines": "-                buf.append(yearValue - 10000).deleteCharAt(1);\n-            } else {\n-                buf.append(yearValue + 10000).deleteCharAt(0);\n+                buf.append('-');\n             }\n+            buf.repeat('0', absYear < 10 ? 3 : absYear < 100 ? 2 : 1);\n+            buf.append(absYear);", "target": "-                buf.append(yearValue - 10000).deleteCharAt(1);\n-            } else {\n-                buf.append(yearValue + 10000).deleteCharAt(0);\n+                buf.append('-');\n             }\n+            buf.repeat('0', absYear < 10 ? 3 : absYear < 100 ? 2 : 1);\n+            buf.append(absYear);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：对于年份小于1000的情况，通过数学运算和字符串删除操作来格式化年份（例如：yearValue-10000然后删除第二个字符）。优化后：直接使用StringBuilder.repeat方法添加前导零，并直接追加年份绝对值。优化思路：利用StringBuilder.repeat方法简化代码逻辑，减少字符串操作次数，提高字符串构建效率。"}
{"id": 866, "source": "riscv-dataset-excel", "optimization_type": "字符串构建优化", "optimization_description": "优化前：使用for循环多次调用StringBuilder.append()方法添加重复字符，每次调用都有方法调用开销和边界检查。优化后：使用StringBuilder.repeat()方法一次性添加多个重复字符，减少方法调用次数和循环开销。优化思路：利用JDK内置的StringBuilder.repeat()方法替代手动循环，提高字符串构建性能，特别是在需要添加多个相同字符的场景中。", "original_code": "使用for循环多次调用StringBuilder.append()方法添加重复字符，每次调用都有方法调用开销和边界检查。", "optimized_code": "-            for (int i = 0; i < minWidth - size; i++) {\n-                buf.append(zeroDigit);\n+            int zeros = minWidth - size;\n+            if (zeros > 0) {\n+                buf.repeat(zeroDigit, zeros);\n             }\n\n-                    for (int i = 0; i < width; i++) {\n-                        buf.append(zero);\n-                    }\n+                    buf.repeat(zero, width);\n\n-                for (int i = 9 - stringSize; i > 0; i--) {\n-                    buf.append(zero);\n+                int zeros = 9 - stringSize;\n+                if (zeros > 0) {\n+                    buf.repeat(zero, zeros);\n                 }\n\n-                    for (int i = 0; i < minWidth; i++) {\n-                        buf.append(decimalStyle.getZeroDigit());\n-                    }\n+                    buf.repeat(decimalStyle.getZeroDigit(), minWidth);", "source_url": "https://github.com/openjdk/riscv-port/commit/e3acf4c627c3c75f9a2ef29647daa6f4746fdc62", "code_v0_no_empty_lines": "使用for循环多次调用StringBuilder.append()方法添加重复字符，每次调用都有方法调用开销和边界检查。", "code_v1_no_empty_lines": "-            for (int i = 0; i < minWidth - size; i++) {\n-                buf.append(zeroDigit);\n+            int zeros = minWidth - size;\n+            if (zeros > 0) {\n+                buf.repeat(zeroDigit, zeros);\n             }\n\n-                    for (int i = 0; i < width; i++) {\n-                        buf.append(zero);\n-                    }\n+                    buf.repeat(zero, width);\n\n-                for (int i = 9 - stringSize; i > 0; i--) {\n-                    buf.append(zero);\n+                int zeros = 9 - stringSize;\n+                if (zeros > 0) {\n+                    buf.repeat(zero, zeros);\n                 }\n\n-                    for (int i = 0; i < minWidth; i++) {\n-                        buf.append(decimalStyle.getZeroDigit());\n-                    }\n+                    buf.repeat(decimalStyle.getZeroDigit(), minWidth);", "target": "-            for (int i = 0; i < minWidth - size; i++) {\n-                buf.append(zeroDigit);\n+            int zeros = minWidth - size;\n+            if (zeros > 0) {\n+                buf.repeat(zeroDigit, zeros);\n             }\n\n-                    for (int i = 0; i < width; i++) {\n-                        buf.append(zero);\n-                    }\n+                    buf.repeat(zero, width);\n\n-                for (int i = 9 - stringSize; i > 0; i--) {\n-                    buf.append(zero);\n+                int zeros = 9 - stringSize;\n+                if (zeros > 0) {\n+                    buf.repeat(zero, zeros);\n                 }\n\n-                    for (int i = 0; i < minWidth; i++) {\n-                        buf.append(decimalStyle.getZeroDigit());\n-                    }\n+                    buf.repeat(decimalStyle.getZeroDigit(), minWidth);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用for循环多次调用StringBuilder.append()方法添加重复字符，每次调用都有方法调用开销和边界检查。优化后：使用StringBuilder.repeat()方法一次性添加多个重复字符，减少方法调用次数和循环开销。优化思路：利用JDK内置的StringBuilder.repeat()方法替代手动循环，提高字符串构建性能，特别是在需要添加多个相同字符的场景中。"}
{"id": 867, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（C2编译器）", "optimization_description": "优化前：代码使用is_initializer()方法检查初始化方法，但该方法会同时检查静态和非静态初始化器，而实际只需要检查对象初始化器（非静态）。优化后：改用is_object_initializer()方法，直接检查对象初始化器，避免不必要的静态初始化器检查。优化思路：简化条件检查，移除冗余的静态初始化器检查，提高编译器解析效率，减少不必要的运行时开销。", "original_code": "代码使用is_initializer()方法检查初始化方法，但该方法会同时检查静态和非静态初始化器，而实际只需要检查对象初始化器（非静态）。", "optimized_code": "-  assert(initializer != nullptr &&\n-         initializer->is_initializer() &&\n-         !initializer->is_static(),\n-             \"unexpected initializer method\");\n+  assert(initializer != nullptr && initializer->is_object_initializer(),\n+         \"unexpected initializer method\");\n-  if (method()->is_initializer() &&\n+  if (method()->is_object_initializer() &&", "source_url": "https://github.com/openjdk/riscv-port/commit/5d965f36d3cd7a1a1f22bf119a98a9e9576a647f", "code_v0_no_empty_lines": "代码使用is_initializer()方法检查初始化方法，但该方法会同时检查静态和非静态初始化器，而实际只需要检查对象初始化器（非静态）。", "code_v1_no_empty_lines": "-  assert(initializer != nullptr &&\n-         initializer->is_initializer() &&\n-         !initializer->is_static(),\n-             \"unexpected initializer method\");\n+  assert(initializer != nullptr && initializer->is_object_initializer(),\n+         \"unexpected initializer method\");\n-  if (method()->is_initializer() &&\n+  if (method()->is_object_initializer() &&", "target": "-  assert(initializer != nullptr &&\n-         initializer->is_initializer() &&\n-         !initializer->is_static(),\n-             \"unexpected initializer method\");\n+  assert(initializer != nullptr && initializer->is_object_initializer(),\n+         \"unexpected initializer method\");\n-  if (method()->is_initializer() &&\n+  if (method()->is_object_initializer() &&", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：代码使用is_initializer()方法检查初始化方法，但该方法会同时检查静态和非静态初始化器，而实际只需要检查对象初始化器（非静态）。优化后：改用is_object_initializer()方法，直接检查对象初始化器，避免不必要的静态初始化器检查。优化思路：简化条件检查，移除冗余的静态初始化器检查，提高编译器解析效率，减少不必要的运行时开销。"}
{"id": 868, "source": "riscv-dataset-excel", "optimization_type": "编译器优化（逃逸分析）", "optimization_description": "优化前：逃逸分析（EA）检查方法是否为初始化器时，使用is_initializer()方法，该方法可能错误地包含类初始化器（<clinit>），导致不必要的逃逸分析检查。优化后：改用is_object_initializer()方法，仅检查对象构造函数（<init>），避免对类初始化器的误判。优化思路：通过精确区分对象构造函数和类初始化器，减少逃逸分析中的冗余检查，提升编译性能并避免潜在的错误分析。", "original_code": "逃逸分析（EA）检查方法是否为初始化器时，使用is_initializer()方法，该方法可能错误地包含类初始化器（<clinit>），导致不必要的逃逸分析检查。", "optimized_code": "-  if (callee_method->is_initializer()) {\n+  if (callee_method->is_object_initializer()) {\n-  if (caller_method->is_initializer() &&\n+  if (caller_method->is_object_initializer() &&", "source_url": "https://github.com/openjdk/riscv-port/commit/b703be9cf633796456991279d07cbde98ad7f1aa", "code_v0_no_empty_lines": "逃逸分析（EA）检查方法是否为初始化器时，使用is_initializer()方法，该方法可能错误地包含类初始化器（<clinit>），导致不必要的逃逸分析检查。", "code_v1_no_empty_lines": "-  if (callee_method->is_initializer()) {\n+  if (callee_method->is_object_initializer()) {\n-  if (caller_method->is_initializer() &&\n+  if (caller_method->is_object_initializer() &&", "target": "-  if (callee_method->is_initializer()) {\n+  if (callee_method->is_object_initializer()) {\n-  if (caller_method->is_initializer() &&\n+  if (caller_method->is_object_initializer() &&", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：逃逸分析（EA）检查方法是否为初始化器时，使用is_initializer()方法，该方法可能错误地包含类初始化器（<clinit>），导致不必要的逃逸分析检查。优化后：改用is_object_initializer()方法，仅检查对象构造函数（<init>），避免对类初始化器的误判。优化思路：通过精确区分对象构造函数和类初始化器，减少逃逸分析中的冗余检查，提升编译性能并避免潜在的错误分析。"}
{"id": 869, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：os::free_memory函数通过mmap覆盖现有映射来释放内存，对于SHM大页无法正常工作，且需要alignment_hint参数。优化后：重命名为os::disclaim_memory，使用madvise(MADV_DONTNEED)向操作系统提示内存不再需要，操作系统可在方便时回收，触摸时会自动重新获取。优化思路：简化内存释放逻辑，移除对齐提示参数依赖，统一跨平台接口，提高内存管理效率和可移植性。", "original_code": "os::free_memory函数通过mmap覆盖现有映射来释放内存，对于SHM大页无法正常工作，且需要alignment_hint参数。", "optimized_code": "-void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n+void os::pd_disclaim_memory(char *addr, size_t bytes) {\n   ::madvise(addr, bytes, MADV_DONTNEED);\n }", "source_url": "https://github.com/openjdk/riscv-port/commit/4a73ed44f1af4ea3e53b1e1a6acfca1ba6b636c3", "code_v0_no_empty_lines": "os::free_memory函数通过mmap覆盖现有映射来释放内存，对于SHM大页无法正常工作，且需要alignment_hint参数。", "code_v1_no_empty_lines": "-void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n+void os::pd_disclaim_memory(char *addr, size_t bytes) {\n   ::madvise(addr, bytes, MADV_DONTNEED);\n }", "target": "-void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n+void os::pd_disclaim_memory(char *addr, size_t bytes) {\n   ::madvise(addr, bytes, MADV_DONTNEED);\n }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：os::free_memory函数通过mmap覆盖现有映射来释放内存，对于SHM大页无法正常工作，且需要alignment_hint参数。优化后：重命名为os::disclaim_memory，使用madvise(MADV_DONTNEED)向操作系统提示内存不再需要，操作系统可在方便时回收，触摸时会自动重新获取。优化思路：简化内存释放逻辑，移除对齐提示参数依赖，统一跨平台接口，提高内存管理效率和可移植性。"}
{"id": 870, "source": "riscv-dataset-excel", "optimization_type": "断言优化", "optimization_description": "优化前：代码在并行垃圾回收的Scavenge阶段包含两个断言检查，验证promotion_manager的栈是否为空，并保留了promotion_manager指针变量。优化后：移除了这两个断言检查以及相关的promotion_manager变量声明。优化思路：这些断言在正常执行条件下总是成立，移除它们可以减少运行时开销，特别是在并行GC的高性能场景中，避免不必要的断言检查可以提高整体性能。", "original_code": "代码在并行垃圾回收的Scavenge阶段包含两个断言检查，验证promotion_manager的栈是否为空，并保留了promotion_manager指针变量。", "optimized_code": "-    // We'll use the promotion manager again later.\n-    PSPromotionManager* promotion_manager = PSPromotionManager::vm_thread_promotion_manager();\n...\n-    assert(promotion_manager->stacks_empty(),\"stacks should be empty at this point\");\n...\n-    // Verify that usage of root_closure didn't copy any objects.\n-    assert(promotion_manager->stacks_empty(),\"stacks should be empty at this point\");", "source_url": "https://github.com/openjdk/riscv-port/commit/1b83bd9225fe9ada4c3770d5cd41242f82fe144f", "code_v0_no_empty_lines": "代码在并行垃圾回收的Scavenge阶段包含两个断言检查，验证promotion_manager的栈是否为空，并保留了promotion_manager指针变量。", "code_v1_no_empty_lines": "-    // We'll use the promotion manager again later.\n-    PSPromotionManager* promotion_manager = PSPromotionManager::vm_thread_promotion_manager();\n...\n-    assert(promotion_manager->stacks_empty(),\"stacks should be empty at this point\");\n...\n-    // Verify that usage of root_closure didn't copy any objects.\n-    assert(promotion_manager->stacks_empty(),\"stacks should be empty at this point\");", "target": "-    // We'll use the promotion manager again later.\n-    PSPromotionManager* promotion_manager = PSPromotionManager::vm_thread_promotion_manager();\n...\n-    assert(promotion_manager->stacks_empty(),\"stacks should be empty at this point\");\n...\n-    // Verify that usage of root_closure didn't copy any objects.\n-    assert(promotion_manager->stacks_empty(),\"stacks should be empty at this point\");", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：代码在并行垃圾回收的Scavenge阶段包含两个断言检查，验证promotion_manager的栈是否为空，并保留了promotion_manager指针变量。优化后：移除了这两个断言检查以及相关的promotion_manager变量声明。优化思路：这些断言在正常执行条件下总是成立，移除它们可以减少运行时开销，特别是在并行GC的高性能场景中，避免不必要的断言检查可以提高整体性能。"}
{"id": 871, "source": "riscv-dataset-excel", "optimization_type": "代码优化+断言优化", "optimization_description": "优化前：在minor_collection_begin()调用后执行断言检查，并调用to_space()->clear(SpaceDecorator::Mangle)进行内存清理。优化后：将断言检查提前到函数开始处，并移除了冗余的mangle清理操作。优化思路：1) 将断言提前可以更早发现错误；2) 由于to_space在scavenge开始时应该是空的，clear操作是冗余的，移除后减少不必要的内存操作开销。", "original_code": "在minor_collection_begin()调用后执行断言检查，并调用to_space()->clear(SpaceDecorator::Mangle)进行内存清理。", "optimized_code": "-  assert(young_gen->to_space()->is_empty(),\n-         \"Attempt to scavenge with live objects in to_space\");\n-  young_gen->to_space()->clear(SpaceDecorator::Mangle);\n+  assert(young_gen->to_space()->is_empty(),\n+         \"Attempt to scavenge with live objects in to_space\");", "source_url": "https://github.com/openjdk/riscv-port/commit/7ec55df34af98e9a80381dba7f7f2127f2248f73", "code_v0_no_empty_lines": "在minor_collection_begin()调用后执行断言检查，并调用to_space()->clear(SpaceDecorator::Mangle)进行内存清理。", "code_v1_no_empty_lines": "-  assert(young_gen->to_space()->is_empty(),\n-         \"Attempt to scavenge with live objects in to_space\");\n-  young_gen->to_space()->clear(SpaceDecorator::Mangle);\n+  assert(young_gen->to_space()->is_empty(),\n+         \"Attempt to scavenge with live objects in to_space\");", "target": "-  assert(young_gen->to_space()->is_empty(),\n-         \"Attempt to scavenge with live objects in to_space\");\n-  young_gen->to_space()->clear(SpaceDecorator::Mangle);\n+  assert(young_gen->to_space()->is_empty(),\n+         \"Attempt to scavenge with live objects in to_space\");", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在minor_collection_begin()调用后执行断言检查，并调用to_space()->clear(SpaceDecorator::Mangle)进行内存清理。优化后：将断言检查提前到函数开始处，并移除了冗余的mangle清理操作。优化思路：1) 将断言提前可以更早发现错误；2) 由于to_space在scavenge开始时应该是空的，clear操作是冗余的，移除后减少不必要的内存操作开销。"}
{"id": 872, "source": "riscv-dataset-excel", "optimization_type": "SIMD向量化优化", "optimization_description": "优化前：Adler32校验和计算使用标量指令逐字节处理，效率较低。优化后：实现RISC-V向量化（SIMD）Adler32内联函数，利用vwredsumu_vs和vwmulu_vv等向量指令，支持64/32/16字节步长并行处理。优化思路：通过向量加载、向量归约求和和向量乘法，将字节级循环转换为向量操作，显著提升大数据块校验和计算性能。", "original_code": "Adler32校验和计算使用标量指令逐字节处理，效率较低。", "optimized_code": "void adler32_process_bytes(Register buff, Register s1, Register s2, VectorRegister vtable,\n    VectorRegister vzero, VectorRegister vbytes, VectorRegister vs1acc, VectorRegister vs2acc,\n    Register temp0, Register temp1, Register temp2,  Register temp3,\n    VectorRegister vtemp1, VectorRegister vtemp2, int step, Assembler::LMUL lmul) {\n    // ... 向量化Adler32计算核心逻辑 ...\n    __ vsetvli(temp0, temp3, Assembler::e8, lmul);\n    __ vle8_v(vbytes, buff);\n    __ vwredsumu_vs(vs1acc, vbytes, vzero);\n    __ vwmulu_vv(vs2acc, vtable, vbytes);\n    // ...\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/72297d22d19e34ff26bd34644dc087a1dec9527e", "code_v0_no_empty_lines": "Adler32校验和计算使用标量指令逐字节处理，效率较低。", "code_v1_no_empty_lines": "void adler32_process_bytes(Register buff, Register s1, Register s2, VectorRegister vtable,\n    VectorRegister vzero, VectorRegister vbytes, VectorRegister vs1acc, VectorRegister vs2acc,\n    Register temp0, Register temp1, Register temp2,  Register temp3,\n    VectorRegister vtemp1, VectorRegister vtemp2, int step, Assembler::LMUL lmul) {\n    // ... 向量化Adler32计算核心逻辑 ...\n    __ vsetvli(temp0, temp3, Assembler::e8, lmul);\n    __ vle8_v(vbytes, buff);\n    __ vwredsumu_vs(vs1acc, vbytes, vzero);\n    __ vwmulu_vv(vs2acc, vtable, vbytes);\n    // ...\n}", "target": "void adler32_process_bytes(Register buff, Register s1, Register s2, VectorRegister vtable,\n    VectorRegister vzero, VectorRegister vbytes, VectorRegister vs1acc, VectorRegister vs2acc,\n    Register temp0, Register temp1, Register temp2,  Register temp3,\n    VectorRegister vtemp1, VectorRegister vtemp2, int step, Assembler::LMUL lmul) {\n    // ... 向量化Adler32计算核心逻辑 ...\n    __ vsetvli(temp0, temp3, Assembler::e8, lmul);\n    __ vle8_v(vbytes, buff);\n    __ vwredsumu_vs(vs1acc, vbytes, vzero);\n    __ vwmulu_vv(vs2acc, vtable, vbytes);\n    // ...\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Adler32校验和计算使用标量指令逐字节处理，效率较低。优化后：实现RISC-V向量化（SIMD）Adler32内联函数，利用vwredsumu_vs和vwmulu_vv等向量指令，支持64/32/16字节步长并行处理。优化思路：通过向量加载、向量归约求和和向量乘法，将字节级循环转换为向量操作，显著提升大数据块校验和计算性能。"}
{"id": 873, "source": "riscv-dataset-excel", "optimization_type": "运行时性能优化+并发优化", "optimization_description": "优化前：关闭共享内存区域时，无论线程是否访问该区域，都会对所有线程执行去优化操作，导致不必要的性能开销。优化后：通过为方法添加scoped访问标记（_has_scoped_access），在关闭共享区域时，只对实际访问该区域的线程执行去优化操作。优化思路：减少不必要的线程去优化，提高并发性能，特别是在高并发场景下关闭共享内存区域时，避免对所有线程的全局影响。", "original_code": "关闭共享内存区域时，无论线程是否访问该区域，都会对所有线程执行去优化操作，导致不必要的性能开销。", "optimized_code": "+    has_scoped_access(),\n+  _has_scoped_access(method->is_scoped())\n+  bool               _has_scoped_access; // For shared scope closure\n+  bool has_scoped_access() const                 { return _has_scoped_access; }\n+  void set_has_scoped_access(bool f)             { _has_scoped_access = f; }\n+  if (callee->is_scoped()) {\n+    compilation->set_has_scoped_access(true);\n+  }\n+  bool has_scoped_access,\n+  nm->set_has_scoped_access(has_scoped_access);\n+  bool is_scoped() const {\n+     return get_Method()->is_scoped();\n+  }\n+  bool is_scoped() const;", "source_url": "https://github.com/openjdk/riscv-port/commit/7bf531324404419e7de3e83e245d351e1a4e4499", "code_v0_no_empty_lines": "关闭共享内存区域时，无论线程是否访问该区域，都会对所有线程执行去优化操作，导致不必要的性能开销。", "code_v1_no_empty_lines": "+    has_scoped_access(),\n+  _has_scoped_access(method->is_scoped())\n+  bool               _has_scoped_access; // For shared scope closure\n+  bool has_scoped_access() const                 { return _has_scoped_access; }\n+  void set_has_scoped_access(bool f)             { _has_scoped_access = f; }\n+  if (callee->is_scoped()) {\n+    compilation->set_has_scoped_access(true);\n+  }\n+  bool has_scoped_access,\n+  nm->set_has_scoped_access(has_scoped_access);\n+  bool is_scoped() const {\n+     return get_Method()->is_scoped();\n+  }\n+  bool is_scoped() const;", "target": "+    has_scoped_access(),\n+  _has_scoped_access(method->is_scoped())\n+  bool               _has_scoped_access; // For shared scope closure\n+  bool has_scoped_access() const                 { return _has_scoped_access; }\n+  void set_has_scoped_access(bool f)             { _has_scoped_access = f; }\n+  if (callee->is_scoped()) {\n+    compilation->set_has_scoped_access(true);\n+  }\n+  bool has_scoped_access,\n+  nm->set_has_scoped_access(has_scoped_access);\n+  bool is_scoped() const {\n+     return get_Method()->is_scoped();\n+  }\n+  bool is_scoped() const;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：关闭共享内存区域时，无论线程是否访问该区域，都会对所有线程执行去优化操作，导致不必要的性能开销。优化后：通过为方法添加scoped访问标记（_has_scoped_access），在关闭共享区域时，只对实际访问该区域的线程执行去优化操作。优化思路：减少不必要的线程去优化，提高并发性能，特别是在高并发场景下关闭共享内存区域时，避免对所有线程的全局影响。"}
{"id": 874, "source": "riscv-dataset-excel", "optimization_type": "API迁移+内存访问优化", "optimization_description": "优化前：直接使用jdk.internal.misc.Unsafe进行内存操作，代码可读性差且存在安全隐患。优化后：通过FFM（Foreign Function & Memory API）封装内存访问，提供类型安全的API。具体改进包括：1) 将直接内存偏移计算替换为语义化方法调用（如getGlyphXAdvance）；2) 将逐字节复制改为批量数组复制；3) 统一管理内存访问逻辑。优化思路：提升代码可维护性、类型安全性，同时保持性能，为未来内存模型演进做准备。", "original_code": "直接使用jdk.internal.misc.Unsafe进行内存操作，代码可读性差且存在安全隐患。", "optimized_code": "- StrikeCache.unsafe.getFloat(glyphPtr + StrikeCache.xAdvanceOffset);\n+ StrikeCache.getGlyphXAdvance(glyphPtr);\n- StrikeCache.unsafe.getByte(pixelDataAddress+i);\n+ System.arraycopy(bytes, 0, graybits, 0, bytes.length);", "source_url": "https://github.com/openjdk/riscv-port/commit/02be7b8ddcdb62977770cb5052e86bcada8478ba", "code_v0_no_empty_lines": "直接使用jdk.internal.misc.Unsafe进行内存操作，代码可读性差且存在安全隐患。", "code_v1_no_empty_lines": "- StrikeCache.unsafe.getFloat(glyphPtr + StrikeCache.xAdvanceOffset);\n+ StrikeCache.getGlyphXAdvance(glyphPtr);\n- StrikeCache.unsafe.getByte(pixelDataAddress+i);\n+ System.arraycopy(bytes, 0, graybits, 0, bytes.length);", "target": "- StrikeCache.unsafe.getFloat(glyphPtr + StrikeCache.xAdvanceOffset);\n+ StrikeCache.getGlyphXAdvance(glyphPtr);\n- StrikeCache.unsafe.getByte(pixelDataAddress+i);\n+ System.arraycopy(bytes, 0, graybits, 0, bytes.length);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：直接使用jdk.internal.misc.Unsafe进行内存操作，代码可读性差且存在安全隐患。优化后：通过FFM（Foreign Function & Memory API）封装内存访问，提供类型安全的API。具体改进包括：1) 将直接内存偏移计算替换为语义化方法调用（如getGlyphXAdvance）；2) 将逐字节复制改为批量数组复制；3) 统一管理内存访问逻辑。优化思路：提升代码可维护性、类型安全性，同时保持性能，为未来内存模型演进做准备。"}
{"id": 875, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "优化前：is_ctrl_folds函数仅检查ctrl是否为Proj节点及其相关属性，fold_compares函数在调用is_ctrl_folds后还需额外检查ctrl->outcnt() == 1。优化后：将ctrl->outcnt() == 1检查移至is_ctrl_folds函数内部（并添加注释说明无副作用），从而简化fold_compares中的条件判断。优化思路：通过重构代码逻辑，减少重复的条件检查，提高编译器的代码生成效率，同时保持语义不变。", "original_code": "is_ctrl_folds函数仅检查ctrl是否为Proj节点及其相关属性，fold_compares函数在调用is_ctrl_folds后还需额外检查ctrl->outcnt() == 1。", "optimized_code": "@@ -773,6 +773,7 @@ bool IfNode::is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn) {\n   return ctrl != nullptr &&\n     ctrl->is_Proj() &&\n+    ctrl->outcnt() == 1 && // No side-effects\n     ctrl->in(0) != nullptr &&\n     ctrl->in(0)->Opcode() == Op_If &&\n     ctrl->in(0)->outcnt() == 2 &&\n@@ -1346,7 +1347,7 @@ Node* IfNode::fold_compares(PhaseIterGVN* igvn) {\n \n   if (cmpi_folds(igvn)) {\n     Node* ctrl = in(0);\n-    if (is_ctrl_folds(ctrl, igvn) && ctrl->outcnt() == 1) {\n+    if (is_ctrl_folds(ctrl, igvn)) {\n       // A integer comparison immediately dominated by another integer\n       // comparison\n       ProjNode* success = nullptr;", "source_url": "https://github.com/openjdk/riscv-port/commit/553f21ae5324029eef3c934d69be40f5d4266457", "code_v0_no_empty_lines": "is_ctrl_folds函数仅检查ctrl是否为Proj节点及其相关属性，fold_compares函数在调用is_ctrl_folds后还需额外检查ctrl->outcnt() == 1。", "code_v1_no_empty_lines": "@@ -773,6 +773,7 @@ bool IfNode::is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn) {\n   return ctrl != nullptr &&\n     ctrl->is_Proj() &&\n+    ctrl->outcnt() == 1 && // No side-effects\n     ctrl->in(0) != nullptr &&\n     ctrl->in(0)->Opcode() == Op_If &&\n     ctrl->in(0)->outcnt() == 2 &&\n@@ -1346,7 +1347,7 @@ Node* IfNode::fold_compares(PhaseIterGVN* igvn) {\n \n   if (cmpi_folds(igvn)) {\n     Node* ctrl = in(0);\n-    if (is_ctrl_folds(ctrl, igvn) && ctrl->outcnt() == 1) {\n+    if (is_ctrl_folds(ctrl, igvn)) {\n       // A integer comparison immediately dominated by another integer\n       // comparison\n       ProjNode* success = nullptr;", "target": "@@ -773,6 +773,7 @@ bool IfNode::is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn) {\n   return ctrl != nullptr &&\n     ctrl->is_Proj() &&\n+    ctrl->outcnt() == 1 && // No side-effects\n     ctrl->in(0) != nullptr &&\n     ctrl->in(0)->Opcode() == Op_If &&\n     ctrl->in(0)->outcnt() == 2 &&\n@@ -1346,7 +1347,7 @@ Node* IfNode::fold_compares(PhaseIterGVN* igvn) {\n \n   if (cmpi_folds(igvn)) {\n     Node* ctrl = in(0);\n-    if (is_ctrl_folds(ctrl, igvn) && ctrl->outcnt() == 1) {\n+    if (is_ctrl_folds(ctrl, igvn)) {\n       // A integer comparison immediately dominated by another integer\n       // comparison\n       ProjNode* success = nullptr;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：is_ctrl_folds函数仅检查ctrl是否为Proj节点及其相关属性，fold_compares函数在调用is_ctrl_folds后还需额外检查ctrl->outcnt() == 1。优化后：将ctrl->outcnt() == 1检查移至is_ctrl_folds函数内部（并添加注释说明无副作用），从而简化fold_compares中的条件判断。优化思路：通过重构代码逻辑，减少重复的条件检查，提高编译器的代码生成效率，同时保持语义不变。"}
{"id": 876, "source": "riscv-dataset-excel", "optimization_type": "代码重构+内存优化", "optimization_description": "优化前：new_symbol函数直接处理字符串长度检查和截断逻辑，代码重复且可读性差。优化后：提取长度检查逻辑到独立的check_length函数，使new_symbol和new_permanent_symbol都能复用该逻辑。优化思路：通过函数重构消除代码重复，提高代码可维护性，同时确保所有符号创建路径都进行一致的长度验证，避免内存越界和符号截断问题。", "original_code": "new_symbol函数直接处理字符串长度检查和截断逻辑，代码重复且可读性差。", "optimized_code": "-Symbol* SymbolTable::new_symbol(const char* name, int len) {\n+static int check_length(const char* name, int len) {\n...\n+Symbol* SymbolTable::new_symbol(const char* name, int len) {\n+  len = check_length(name, len);\n...\n-  int len = (int)strlen(name);\n+  int len = check_length(name, (int)strlen(name));", "source_url": "https://github.com/openjdk/riscv-port/commit/c5a8c8a0b6d51c33679efb02514f7a44e93ad290", "code_v0_no_empty_lines": "new_symbol函数直接处理字符串长度检查和截断逻辑，代码重复且可读性差。", "code_v1_no_empty_lines": "-Symbol* SymbolTable::new_symbol(const char* name, int len) {\n+static int check_length(const char* name, int len) {\n...\n+Symbol* SymbolTable::new_symbol(const char* name, int len) {\n+  len = check_length(name, len);\n...\n-  int len = (int)strlen(name);\n+  int len = check_length(name, (int)strlen(name));", "target": "-Symbol* SymbolTable::new_symbol(const char* name, int len) {\n+static int check_length(const char* name, int len) {\n...\n+Symbol* SymbolTable::new_symbol(const char* name, int len) {\n+  len = check_length(name, len);\n...\n-  int len = (int)strlen(name);\n+  int len = check_length(name, (int)strlen(name));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：new_symbol函数直接处理字符串长度检查和截断逻辑，代码重复且可读性差。优化后：提取长度检查逻辑到独立的check_length函数，使new_symbol和new_permanent_symbol都能复用该逻辑。优化思路：通过函数重构消除代码重复，提高代码可维护性，同时确保所有符号创建路径都进行一致的长度验证，避免内存越界和符号截断问题。"}
{"id": 877, "source": "riscv-dataset-excel", "optimization_type": "内存安全优化+错误处理优化", "optimization_description": "优化前：仅使用简单的assert检查字符串长度是否超过Symbol最大长度限制，在release版本中可能产生内存越界访问。优化后：1. 增强assert信息便于调试；2. 在release版本中增加运行时检查，当字符串超长时发出警告并自动截断，避免内存越界；3. 在Symbol构造函数和其他相关位置添加一致性检查。优化思路：通过运行时检查和自动截断机制，提高系统的健壮性和内存安全性，防止因错误使用Symbol导致的崩溃问题。", "original_code": "仅使用简单的assert检查字符串长度是否超过Symbol最大长度限制，在release版本中可能产生内存越界访问。", "optimized_code": "Symbol* SymbolTable::new_symbol(const char* name, int len) {\n-  assert(len <= Symbol::max_length(), \"sanity\");\n+  assert(len <= Symbol::max_length(),\n+         \"String length %d exceeds the maximum Symbol length of %d\", len, Symbol::max_length());\n+  if (len > Symbol::max_length()) {\n+    warning(\"A string \\\"%.80s ... %.80s\\\" exceeds the maximum Symbol \"\n+            \"length of %d and has been truncated\", name, (name + len - 80), Symbol::max_length());\n+    len = Symbol::max_length();\n+  }", "source_url": "https://github.com/openjdk/riscv-port/commit/aea9a08bebb6555ef6f00daba24afec394dd245b", "code_v0_no_empty_lines": "仅使用简单的assert检查字符串长度是否超过Symbol最大长度限制，在release版本中可能产生内存越界访问。", "code_v1_no_empty_lines": "Symbol* SymbolTable::new_symbol(const char* name, int len) {\n-  assert(len <= Symbol::max_length(), \"sanity\");\n+  assert(len <= Symbol::max_length(),\n+         \"String length %d exceeds the maximum Symbol length of %d\", len, Symbol::max_length());\n+  if (len > Symbol::max_length()) {\n+    warning(\"A string \\\"%.80s ... %.80s\\\" exceeds the maximum Symbol \"\n+            \"length of %d and has been truncated\", name, (name + len - 80), Symbol::max_length());\n+    len = Symbol::max_length();\n+  }", "target": "Symbol* SymbolTable::new_symbol(const char* name, int len) {\n-  assert(len <= Symbol::max_length(), \"sanity\");\n+  assert(len <= Symbol::max_length(),\n+         \"String length %d exceeds the maximum Symbol length of %d\", len, Symbol::max_length());\n+  if (len > Symbol::max_length()) {\n+    warning(\"A string \\\"%.80s ... %.80s\\\" exceeds the maximum Symbol \"\n+            \"length of %d and has been truncated\", name, (name + len - 80), Symbol::max_length());\n+    len = Symbol::max_length();\n+  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：仅使用简单的assert检查字符串长度是否超过Symbol最大长度限制，在release版本中可能产生内存越界访问。优化后：1. 增强assert信息便于调试；2. 在release版本中增加运行时检查，当字符串超长时发出警告并自动截断，避免内存越界；3. 在Symbol构造函数和其他相关位置添加一致性检查。优化思路：通过运行时检查和自动截断机制，提高系统的健壮性和内存安全性，防止因错误使用Symbol导致的崩溃问题。"}
{"id": 878, "source": "riscv-dataset-excel", "optimization_type": "循环优化+数值范围优化", "optimization_description": "优化前：在调整循环对齐时，使用int类型计算新的pre-loop限制，可能导致加法溢出或减法下溢，破坏Range Check Elimination（RCE）的安全性保证。优化后：先将int转换为long类型进行计算（SubLNode/AddLNode, MinLNode/MaxLNode），确保中间结果不会溢出/下溢，最后再将结果转换回int。优化思路：通过使用更大范围的long类型避免数值溢出问题，确保循环对齐调整不会违反RCE的安全范围约束，提高循环向量化的可靠性。", "original_code": "在调整循环对齐时，使用int类型计算新的pre-loop限制，可能导致加法溢出或减法下溢，破坏Range Check Elimination（RCE）的安全性保证。", "optimized_code": "-  new_limit = new SubINode(old_limit, adjust_pre_iter);\n+  new_limit = new SubLNode(old_limit, adjust_pre_iter);\n-  new_limit = new AddINode(old_limit, adjust_pre_iter);\n+  new_limit = new AddLNode(old_limit, adjust_pre_iter);\n-    (stride > 0) ? (Node*) new MinINode(new_limit, orig_limit)\n+    (stride > 0) ? (Node*) new MinLNode(phase()->C, new_limit, orig_limit)\n-                 : (Node*) new MaxINode(new_limit, orig_limit);\n+                 : (Node*) new MaxLNode(phase()->C, new_limit, orig_limit);\n+  constrained_limit = new ConvL2INode(constrained_limit);", "source_url": "https://github.com/openjdk/riscv-port/commit/46c37686454321011541499a79c776f774ff2b57", "code_v0_no_empty_lines": "在调整循环对齐时，使用int类型计算新的pre-loop限制，可能导致加法溢出或减法下溢，破坏Range Check Elimination（RCE）的安全性保证。", "code_v1_no_empty_lines": "-  new_limit = new SubINode(old_limit, adjust_pre_iter);\n+  new_limit = new SubLNode(old_limit, adjust_pre_iter);\n-  new_limit = new AddINode(old_limit, adjust_pre_iter);\n+  new_limit = new AddLNode(old_limit, adjust_pre_iter);\n-    (stride > 0) ? (Node*) new MinINode(new_limit, orig_limit)\n+    (stride > 0) ? (Node*) new MinLNode(phase()->C, new_limit, orig_limit)\n-                 : (Node*) new MaxINode(new_limit, orig_limit);\n+                 : (Node*) new MaxLNode(phase()->C, new_limit, orig_limit);\n+  constrained_limit = new ConvL2INode(constrained_limit);", "target": "-  new_limit = new SubINode(old_limit, adjust_pre_iter);\n+  new_limit = new SubLNode(old_limit, adjust_pre_iter);\n-  new_limit = new AddINode(old_limit, adjust_pre_iter);\n+  new_limit = new AddLNode(old_limit, adjust_pre_iter);\n-    (stride > 0) ? (Node*) new MinINode(new_limit, orig_limit)\n+    (stride > 0) ? (Node*) new MinLNode(phase()->C, new_limit, orig_limit)\n-                 : (Node*) new MaxINode(new_limit, orig_limit);\n+                 : (Node*) new MaxLNode(phase()->C, new_limit, orig_limit);\n+  constrained_limit = new ConvL2INode(constrained_limit);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在调整循环对齐时，使用int类型计算新的pre-loop限制，可能导致加法溢出或减法下溢，破坏Range Check Elimination（RCE）的安全性保证。优化后：先将int转换为long类型进行计算（SubLNode/AddLNode, MinLNode/MaxLNode），确保中间结果不会溢出/下溢，最后再将结果转换回int。优化思路：通过使用更大范围的long类型避免数值溢出问题，确保循环对齐调整不会违反RCE的安全范围约束，提高循环向量化的可靠性。"}
{"id": 879, "source": "riscv-dataset-excel", "optimization_type": "数值稳定性优化+边界检查优化", "optimization_description": "优化前：1. 逆变换矩阵可能包含NaN/Infinity值，导致后续计算异常；2. 变换坐标检查仅针对绝对值过大情况，未检测无穷大和NaN。优化后：1. 在Java层获取逆变换矩阵后检查所有元素是否为有限值，发现无效矩阵时提前返回避免异常；2. 在C层扩展TX_FIXED_UNSAFE宏，增加isinf()和isnan()检查。优化思路：增强图像变换处理的数值稳定性，防止无效数学值传播导致渲染错误或崩溃。", "original_code": "1. 逆变换矩阵可能包含NaN/Infinity值，导致后续计算异常；2. 变换坐标检查仅针对绝对值过大情况，未检测无穷大和NaN。", "optimized_code": "1. Java代码添加矩阵元素检查：\n+            double[] mat = new double[6];\n+            itx.getMatrix(mat);\n+            for (double d : mat) {\n+                if (!Double.isFinite(d)) {\n+                    return;\n+                }\n+            }\n2. C宏定义扩展检查范围：\n- #define TX_FIXED_UNSAFE(v)  (fabs(v) >= (1<<30))\n+ #define TX_FIXED_UNSAFE(v)  (isinf(v) || isnan(v) || fabs(v) >= (1<<30))", "source_url": "https://github.com/openjdk/riscv-port/commit/8cc84bf71e42bb72755a9f2d8532cbdbd428c2a5", "code_v0_no_empty_lines": "1. 逆变换矩阵可能包含NaN/Infinity值，导致后续计算异常；2. 变换坐标检查仅针对绝对值过大情况，未检测无穷大和NaN。", "code_v1_no_empty_lines": "1. Java代码添加矩阵元素检查：\n+            double[] mat = new double[6];\n+            itx.getMatrix(mat);\n+            for (double d : mat) {\n+                if (!Double.isFinite(d)) {\n+                    return;\n+                }\n+            }\n2. C宏定义扩展检查范围：\n- #define TX_FIXED_UNSAFE(v)  (fabs(v) >= (1<<30))\n+ #define TX_FIXED_UNSAFE(v)  (isinf(v) || isnan(v) || fabs(v) >= (1<<30))", "target": "1. Java代码添加矩阵元素检查：\n+            double[] mat = new double[6];\n+            itx.getMatrix(mat);\n+            for (double d : mat) {\n+                if (!Double.isFinite(d)) {\n+                    return;\n+                }\n+            }\n2. C宏定义扩展检查范围：\n- #define TX_FIXED_UNSAFE(v)  (fabs(v) >= (1<<30))\n+ #define TX_FIXED_UNSAFE(v)  (isinf(v) || isnan(v) || fabs(v) >= (1<<30))", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 逆变换矩阵可能包含NaN/Infinity值，导致后续计算异常；2. 变换坐标检查仅针对绝对值过大情况，未检测无穷大和NaN。优化后：1. 在Java层获取逆变换矩阵后检查所有元素是否为有限值，发现无效矩阵时提前返回避免异常；2. 在C层扩展TX_FIXED_UNSAFE宏，增加isinf()和isnan()检查。优化思路：增强图像变换处理的数值稳定性，防止无效数学值传播导致渲染错误或崩溃。"}
{"id": 880, "source": "riscv-dataset-excel", "optimization_type": "内存访问优化+边界条件处理", "optimization_description": "优化前：1. 边界条件使用<=比较可能导致不必要的计算；2. 缓冲区大小可能不足，导致内存访问越界风险。优化后：1. 将<=改为<，避免在边界相等时的冗余计算；2. 将缓冲区大小从MASK_BUF_LEN+1增加到MASK_BUF_LEN+2，确保有足够的空间处理边界情况，防止内存访问错误。优化思路：通过调整边界条件和增加缓冲区大小，提高2D图像处理的稳定性和性能。", "original_code": "1. 边界条件使用<=比较可能导致不必要的计算；2. 缓冲区大小可能不足，导致内存访问越界风险。", "optimized_code": "- if (xmid <= (CX2)) { \n+ if (xmid < (CX2)) { \n- jfloat localaccum[MASK_BUF_LEN + 1]; \n+ jfloat localaccum[MASK_BUF_LEN + 2]; \n- ? malloc((width + 1) * sizeof(jfloat)) \n+ ? malloc((width + 2) * sizeof(jfloat)) \n- memset(pAccum, 0, (width+1) * sizeof(jfloat)); \n+ memset(pAccum, 0, (width + 2) * sizeof(jfloat));", "source_url": "https://github.com/openjdk/riscv-port/commit/e636325510e882afa703752c6d37c183d111565c", "code_v0_no_empty_lines": "1. 边界条件使用<=比较可能导致不必要的计算；2. 缓冲区大小可能不足，导致内存访问越界风险。", "code_v1_no_empty_lines": "- if (xmid <= (CX2)) { \n+ if (xmid < (CX2)) { \n- jfloat localaccum[MASK_BUF_LEN + 1]; \n+ jfloat localaccum[MASK_BUF_LEN + 2]; \n- ? malloc((width + 1) * sizeof(jfloat)) \n+ ? malloc((width + 2) * sizeof(jfloat)) \n- memset(pAccum, 0, (width+1) * sizeof(jfloat)); \n+ memset(pAccum, 0, (width + 2) * sizeof(jfloat));", "target": "- if (xmid <= (CX2)) { \n+ if (xmid < (CX2)) { \n- jfloat localaccum[MASK_BUF_LEN + 1]; \n+ jfloat localaccum[MASK_BUF_LEN + 2]; \n- ? malloc((width + 1) * sizeof(jfloat)) \n+ ? malloc((width + 2) * sizeof(jfloat)) \n- memset(pAccum, 0, (width+1) * sizeof(jfloat)); \n+ memset(pAccum, 0, (width + 2) * sizeof(jfloat));", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：1. 边界条件使用<=比较可能导致不必要的计算；2. 缓冲区大小可能不足，导致内存访问越界风险。优化后：1. 将<=改为<，避免在边界相等时的冗余计算；2. 将缓冲区大小从MASK_BUF_LEN+1增加到MASK_BUF_LEN+2，确保有足够的空间处理边界情况，防止内存访问错误。优化思路：通过调整边界条件和增加缓冲区大小，提高2D图像处理的稳定性和性能。"}
{"id": 881, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "优化前：代码在处理数组索引计算时，对于减法操作采用先取负值再调用加法的方式，需要额外的条件判断和值转换。优化后：直接根据操作码调用对应的加法或减法函数，简化了控制流，移除了不必要的条件判断。优化思路：通过直接调用相应的算术操作函数，减少分支判断，提高代码执行效率，同时通过assert语句确保操作码的正确性。", "original_code": "代码在处理数组索引计算时，对于减法操作采用先取负值再调用加法的方式，需要额外的条件判断和值转换。", "optimized_code": "-            if (value != min_jint) {\n-              if (ao->op() == Bytecodes::_isub) {\n-                value = -value;\n-              }\n+            if (ao->op() == Bytecodes::_iadd) {\n               base = java_add(base, value);\n-              last_integer = base;\n-              last_instruction = other;\n+            } else {\n+              assert(ao->op() == Bytecodes::_isub, \"unexpected bytecode\");\n+              base = java_subtract(base, value);\n             }\n+            last_integer = base;\n+            last_instruction = other;", "source_url": "https://github.com/openjdk/riscv-port/commit/5f365d44be9c1f3413c9ccde970e2745090a516a", "code_v0_no_empty_lines": "代码在处理数组索引计算时，对于减法操作采用先取负值再调用加法的方式，需要额外的条件判断和值转换。", "code_v1_no_empty_lines": "-            if (value != min_jint) {\n-              if (ao->op() == Bytecodes::_isub) {\n-                value = -value;\n-              }\n+            if (ao->op() == Bytecodes::_iadd) {\n               base = java_add(base, value);\n-              last_integer = base;\n-              last_instruction = other;\n+            } else {\n+              assert(ao->op() == Bytecodes::_isub, \"unexpected bytecode\");\n+              base = java_subtract(base, value);\n             }\n+            last_integer = base;\n+            last_instruction = other;", "target": "-            if (value != min_jint) {\n-              if (ao->op() == Bytecodes::_isub) {\n-                value = -value;\n-              }\n+            if (ao->op() == Bytecodes::_iadd) {\n               base = java_add(base, value);\n-              last_integer = base;\n-              last_instruction = other;\n+            } else {\n+              assert(ao->op() == Bytecodes::_isub, \"unexpected bytecode\");\n+              base = java_subtract(base, value);\n             }\n+            last_integer = base;\n+            last_instruction = other;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：代码在处理数组索引计算时，对于减法操作采用先取负值再调用加法的方式，需要额外的条件判断和值转换。优化后：直接根据操作码调用对应的加法或减法函数，简化了控制流，移除了不必要的条件判断。优化思路：通过直接调用相应的算术操作函数，减少分支判断，提高代码执行效率，同时通过assert语句确保操作码的正确性。"}
{"id": 882, "source": "riscv-dataset-excel", "optimization_type": "内存配置优化", "optimization_description": "优化前：Metaspace大小设置为23m，在AIX平台上运行RedefineLeakThrowable测试时出现OutOfMemoryError: Metaspace错误。优化后：将MetaspaceSize和MaxMetaspaceSize从23m增加到25m，为元数据分配更多内存空间。优化思路：通过增加Metaspace内存配额来解决测试中的内存不足问题，确保测试在AIX平台上稳定运行。", "original_code": "Metaspace大小设置为23m，在AIX平台上运行RedefineLeakThrowable测试时出现OutOfMemoryError: Metaspace错误。", "optimized_code": "- @run main/othervm/timeout=6000 -javaagent:redefineagent.jar -XX:MetaspaceSize=23m -XX:MaxMetaspaceSize=23m RedefineLeakThrowable\n+ @run main/othervm/timeout=6000 -javaagent:redefineagent.jar -XX:MetaspaceSize=25m -XX:MaxMetaspaceSize=25m RedefineLeakThrowable", "source_url": "https://github.com/openjdk/riscv-port/commit/419cc4624891e5775847f8acaf92fa8c42a9719c", "code_v0_no_empty_lines": "Metaspace大小设置为23m，在AIX平台上运行RedefineLeakThrowable测试时出现OutOfMemoryError: Metaspace错误。", "code_v1_no_empty_lines": "- @run main/othervm/timeout=6000 -javaagent:redefineagent.jar -XX:MetaspaceSize=23m -XX:MaxMetaspaceSize=23m RedefineLeakThrowable\n+ @run main/othervm/timeout=6000 -javaagent:redefineagent.jar -XX:MetaspaceSize=25m -XX:MaxMetaspaceSize=25m RedefineLeakThrowable", "target": "- @run main/othervm/timeout=6000 -javaagent:redefineagent.jar -XX:MetaspaceSize=23m -XX:MaxMetaspaceSize=23m RedefineLeakThrowable\n+ @run main/othervm/timeout=6000 -javaagent:redefineagent.jar -XX:MetaspaceSize=25m -XX:MaxMetaspaceSize=25m RedefineLeakThrowable", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：Metaspace大小设置为23m，在AIX平台上运行RedefineLeakThrowable测试时出现OutOfMemoryError: Metaspace错误。优化后：将MetaspaceSize和MaxMetaspaceSize从23m增加到25m，为元数据分配更多内存空间。优化思路：通过增加Metaspace内存配额来解决测试中的内存不足问题，确保测试在AIX平台上稳定运行。"}
{"id": 883, "source": "riscv-dataset-excel", "optimization_type": "代码质量/静态分析警告修复", "optimization_description": "优化前：代码中使用整数0作为空指针常量，触发-Wzero-as-null-pointer-constant编译器警告。优化后：将0替换为C++11标准的nullptr关键字，明确表示空指针。优化思路：提高代码可读性和类型安全性，消除静态分析警告，遵循现代C++最佳实践，但不会改变运行时性能或功能。", "original_code": "代码中使用整数0作为空指针常量，触发-Wzero-as-null-pointer-constant编译器警告。", "optimized_code": "- assert(def != 0, \"input edge required\");\n+ assert(def != nullptr, \"input edge required\");\n- if (_name != nullptr && strstr(_name, \"arraycopy\") != 0) {\n+ if (_name != nullptr && strstr(_name, \"arraycopy\") != nullptr) {\n- else if( _def == 0 ) tty->print(\"Dead \");\n+ else if( _def == nullptr ) tty->print(\"Dead \");\n- , _live(0)\n+ , _live(nullptr)\n- } else if (has_method() && method()->name() != 0 &&\n+ } else if (has_method() && method()->name() != nullptr &&\n- _blocks.map(number_of_blocks(), 0);\n+ _blocks.map(number_of_blocks(), nullptr);\n- assert( _ancestor != 0, \"\" );\n+ assert( _ancestor != nullptr, \"\" );\n- if( _ancestor->_ancestor != 0 ) {\n+ if( _ancestor->_ancestor != nullptr ) {\n- _pending_cvstates = new (C->node_arena()) GrowableArray<Node*>(C->node_arena(), init_size, 0, 0);\n+ _pending_cvstates = new (C->node_arena()) GrowableArray<Node*>(C->node_arena(), init_size, 0, nullptr);\n- lrg._def = 0;\n+ lrg._def = nullptr;", "source_url": "https://github.com/openjdk/riscv-port/commit/388fcf03c02c41bb690733e8565642c24ead56e0", "code_v0_no_empty_lines": "代码中使用整数0作为空指针常量，触发-Wzero-as-null-pointer-constant编译器警告。", "code_v1_no_empty_lines": "- assert(def != 0, \"input edge required\");\n+ assert(def != nullptr, \"input edge required\");\n- if (_name != nullptr && strstr(_name, \"arraycopy\") != 0) {\n+ if (_name != nullptr && strstr(_name, \"arraycopy\") != nullptr) {\n- else if( _def == 0 ) tty->print(\"Dead \");\n+ else if( _def == nullptr ) tty->print(\"Dead \");\n- , _live(0)\n+ , _live(nullptr)\n- } else if (has_method() && method()->name() != 0 &&\n+ } else if (has_method() && method()->name() != nullptr &&\n- _blocks.map(number_of_blocks(), 0);\n+ _blocks.map(number_of_blocks(), nullptr);\n- assert( _ancestor != 0, \"\" );\n+ assert( _ancestor != nullptr, \"\" );\n- if( _ancestor->_ancestor != 0 ) {\n+ if( _ancestor->_ancestor != nullptr ) {\n- _pending_cvstates = new (C->node_arena()) GrowableArray<Node*>(C->node_arena(), init_size, 0, 0);\n+ _pending_cvstates = new (C->node_arena()) GrowableArray<Node*>(C->node_arena(), init_size, 0, nullptr);\n- lrg._def = 0;\n+ lrg._def = nullptr;", "target": "- assert(def != 0, \"input edge required\");\n+ assert(def != nullptr, \"input edge required\");\n- if (_name != nullptr && strstr(_name, \"arraycopy\") != 0) {\n+ if (_name != nullptr && strstr(_name, \"arraycopy\") != nullptr) {\n- else if( _def == 0 ) tty->print(\"Dead \");\n+ else if( _def == nullptr ) tty->print(\"Dead \");\n- , _live(0)\n+ , _live(nullptr)\n- } else if (has_method() && method()->name() != 0 &&\n+ } else if (has_method() && method()->name() != nullptr &&\n- _blocks.map(number_of_blocks(), 0);\n+ _blocks.map(number_of_blocks(), nullptr);\n- assert( _ancestor != 0, \"\" );\n+ assert( _ancestor != nullptr, \"\" );\n- if( _ancestor->_ancestor != 0 ) {\n+ if( _ancestor->_ancestor != nullptr ) {\n- _pending_cvstates = new (C->node_arena()) GrowableArray<Node*>(C->node_arena(), init_size, 0, 0);\n+ _pending_cvstates = new (C->node_arena()) GrowableArray<Node*>(C->node_arena(), init_size, 0, nullptr);\n- lrg._def = 0;\n+ lrg._def = nullptr;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：代码中使用整数0作为空指针常量，触发-Wzero-as-null-pointer-constant编译器警告。优化后：将0替换为C++11标准的nullptr关键字，明确表示空指针。优化思路：提高代码可读性和类型安全性，消除静态分析警告，遵循现代C++最佳实践，但不会改变运行时性能或功能。"}
{"id": 884, "source": "riscv-dataset-excel", "optimization_type": "逃逸分析优化+空指针异常修复", "optimization_description": "优化前：在逃逸分析中，当对象被标量替换（scalarized）时，处理OopMap节点时未正确识别标量替换对象作为GC根，导致在-XX:-UseCompressedOops模式下可能引发空指针异常。优化后：新增contains_as_scalarized_obj函数检查标量替换对象，并在确定GC根时将其包含在内，确保标量替换对象在逃逸分析中被正确处理，避免空指针异常并提升逃逸分析优化效果。", "original_code": "在逃逸分析中，当对象被标量替换（scalarized）时，处理OopMap节点时未正确识别标量替换对象作为GC根，导致在-XX:-UseCompressedOops模式下可能引发空指针异常。", "optimized_code": "bool is_root = locarray->contains(ov) ||\n                         exparray->contains(ov) ||\n                         contains_as_owner(monarray, ov) ||\n                         contains_as_scalarized_obj(jvms, sfn, objs, ov);", "source_url": "https://github.com/openjdk/riscv-port/commit/005fb67e99370ef2bd15dae621a3924e1cf00124", "code_v0_no_empty_lines": "在逃逸分析中，当对象被标量替换（scalarized）时，处理OopMap节点时未正确识别标量替换对象作为GC根，导致在-XX:-UseCompressedOops模式下可能引发空指针异常。", "code_v1_no_empty_lines": "bool is_root = locarray->contains(ov) ||\n                         exparray->contains(ov) ||\n                         contains_as_owner(monarray, ov) ||\n                         contains_as_scalarized_obj(jvms, sfn, objs, ov);", "target": "bool is_root = locarray->contains(ov) ||\n                         exparray->contains(ov) ||\n                         contains_as_owner(monarray, ov) ||\n                         contains_as_scalarized_obj(jvms, sfn, objs, ov);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在逃逸分析中，当对象被标量替换（scalarized）时，处理OopMap节点时未正确识别标量替换对象作为GC根，导致在-XX:-UseCompressedOops模式下可能引发空指针异常。优化后：新增contains_as_scalarized_obj函数检查标量替换对象，并在确定GC根时将其包含在内，确保标量替换对象在逃逸分析中被正确处理，避免空指针异常并提升逃逸分析优化效果。"}
{"id": 885, "source": "riscv-dataset-excel", "optimization_type": "锁优化", "optimization_description": "优化前：无条件获取Compile_lock锁，即使当前线程已持有该锁，导致不必要的锁重入开销和潜在死锁风险。优化后：通过ConditionalMutexLocker和should_take_Compile_lock条件判断，仅在当前线程未持有Compile_lock时才获取锁，避免锁重入，减少锁竞争开销，提升并发性能。", "original_code": "无条件获取Compile_lock锁，即使当前线程已持有该锁，导致不必要的锁重入开销和潜在死锁风险。", "optimized_code": "-    MutexLocker locker(Compile_lock);\n+    bool should_take_Compile_lock = !Compile_lock->owned_by_self();\n+    ConditionalMutexLocker locker(Compile_lock, should_take_Compile_lock, Mutex::_safepoint_check_flag);", "source_url": "https://github.com/openjdk/riscv-port/commit/88eff4c3054b7d9d6486ff418bbecca8f0388117", "code_v0_no_empty_lines": "无条件获取Compile_lock锁，即使当前线程已持有该锁，导致不必要的锁重入开销和潜在死锁风险。", "code_v1_no_empty_lines": "-    MutexLocker locker(Compile_lock);\n+    bool should_take_Compile_lock = !Compile_lock->owned_by_self();\n+    ConditionalMutexLocker locker(Compile_lock, should_take_Compile_lock, Mutex::_safepoint_check_flag);", "target": "-    MutexLocker locker(Compile_lock);\n+    bool should_take_Compile_lock = !Compile_lock->owned_by_self();\n+    ConditionalMutexLocker locker(Compile_lock, should_take_Compile_lock, Mutex::_safepoint_check_flag);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：无条件获取Compile_lock锁，即使当前线程已持有该锁，导致不必要的锁重入开销和潜在死锁风险。优化后：通过ConditionalMutexLocker和should_take_Compile_lock条件判断，仅在当前线程未持有Compile_lock时才获取锁，避免锁重入，减少锁竞争开销，提升并发性能。"}
{"id": 886, "source": "riscv-dataset-excel", "optimization_type": "缓存优化", "optimization_description": "优化前：每次调用Method.hashCode()时都重新计算哈希值，涉及字符串哈希计算和类名查找。优化后：添加私有hash字段缓存计算结果，首次调用时计算并缓存，后续调用直接返回缓存值。思路：通过缓存避免重复计算，减少字符串操作开销，提升频繁调用场景下的性能。", "original_code": "每次调用Method.hashCode()时都重新计算哈希值，涉及字符串哈希计算和类名查找。", "optimized_code": "private int                 hash;\n...\npublic int hashCode() {\n    int hc = hash;\n    if (hc == 0) {\n        hc = hash = getDeclaringClass().getName().hashCode() ^ getName().hashCode();\n    }\n    return hc;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/8ba9bc6f1735be98dcc039244a28884b4d9620ae", "code_v0_no_empty_lines": "每次调用Method.hashCode()时都重新计算哈希值，涉及字符串哈希计算和类名查找。", "code_v1_no_empty_lines": "private int                 hash;\n...\npublic int hashCode() {\n    int hc = hash;\n    if (hc == 0) {\n        hc = hash = getDeclaringClass().getName().hashCode() ^ getName().hashCode();\n    }\n    return hc;\n}", "target": "private int                 hash;\n...\npublic int hashCode() {\n    int hc = hash;\n    if (hc == 0) {\n        hc = hash = getDeclaringClass().getName().hashCode() ^ getName().hashCode();\n    }\n    return hc;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次调用Method.hashCode()时都重新计算哈希值，涉及字符串哈希计算和类名查找。优化后：添加私有hash字段缓存计算结果，首次调用时计算并缓存，后续调用直接返回缓存值。思路：通过缓存避免重复计算，减少字符串操作开销，提升频繁调用场景下的性能。"}
{"id": 887, "source": "riscv-dataset-excel", "optimization_type": "字符串处理优化", "optimization_description": "性能提升：优化前使用String.format(\"%n\")获取换行符，涉及格式化解析和对象创建开销。优化后直接调用System.lineSeparator()，这是一个本地方法调用，直接返回系统换行符常量，避免了格式化开销和临时对象创建。思路：用直接系统调用替换通用格式化方法，减少运行时开销。", "original_code": "// No original code extracted from description\n", "optimized_code": "- public static final String NEW_LINE = String.format(\"%n\");\n+ public static final String NEW_LINE = System.lineSeparator();\n- String nl = String.format(\"%n\");\n+ String nl = System.lineSeparator();\n- private String lineSeparator = String.format(\"%n\");\n+ private String lineSeparator = System.lineSeparator();", "source_url": "https://github.com/openjdk/riscv-port/commit/4957145e6c823bfaa638a77457da5c031af978b9", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- public static final String NEW_LINE = String.format(\"%n\");\n+ public static final String NEW_LINE = System.lineSeparator();\n- String nl = String.format(\"%n\");\n+ String nl = System.lineSeparator();\n- private String lineSeparator = String.format(\"%n\");\n+ private String lineSeparator = System.lineSeparator();", "target": "- public static final String NEW_LINE = String.format(\"%n\");\n+ public static final String NEW_LINE = System.lineSeparator();\n- String nl = String.format(\"%n\");\n+ String nl = System.lineSeparator();\n- private String lineSeparator = String.format(\"%n\");\n+ private String lineSeparator = System.lineSeparator();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升：优化前使用String.format(\"%n\")获取换行符，涉及格式化解析和对象创建开销。优化后直接调用System.lineSeparator()，这是一个本地方法调用，直接返回系统换行符常量，避免了格式化开销和临时对象创建。思路：用直接系统调用替换通用格式化方法，减少运行时开销。"}
{"id": 888, "source": "riscv-dataset-excel", "optimization_type": "内存优化+启动性能优化", "optimization_description": "优化前：使用枚举类型Case（LOWERCASE/UPPERCASE）表示大小写状态，每个HexFormat实例需要存储枚举对象引用，类加载时需要初始化枚举类。优化后：改用boolean类型ucase（true表示大写，false表示小写），消除了枚举类的加载和初始化开销，减少了内存占用。优化思路：将简单的两状态枚举替换为基本类型boolean，避免枚举类的类加载、静态初始化等启动开销，提升应用启动速度。", "original_code": "使用枚举类型Case（LOWERCASE/UPPERCASE）表示大小写状态，每个HexFormat实例需要存储枚举对象引用，类加载时需要初始化枚举类。", "optimized_code": "- private final Case digitCase;\n- private enum Case {\n-     LOWERCASE,\n-     UPPERCASE\n- }\n+ private final boolean ucase;\n- private HexFormat(String delimiter, String prefix, String suffix, Case digitCase) {\n+ private HexFormat(String delimiter, String prefix, String suffix, boolean ucase) {\n- this.digitCase = digitCase;\n+ this.ucase = ucase;\n- return digitCase == Case.UPPERCASE;\n+ return ucase;\n- if (digitCase == Case.LOWERCASE) {\n+ if (!ucase) {\n- result = 31 * result + Boolean.hashCode(digitCase == Case.UPPERCASE);\n+ result = 31 * result + Boolean.hashCode(ucase);", "source_url": "https://github.com/openjdk/riscv-port/commit/84c74ad0a94f5c36529c63d846f15916259ee6a5", "code_v0_no_empty_lines": "使用枚举类型Case（LOWERCASE/UPPERCASE）表示大小写状态，每个HexFormat实例需要存储枚举对象引用，类加载时需要初始化枚举类。", "code_v1_no_empty_lines": "- private final Case digitCase;\n- private enum Case {\n-     LOWERCASE,\n-     UPPERCASE\n- }\n+ private final boolean ucase;\n- private HexFormat(String delimiter, String prefix, String suffix, Case digitCase) {\n+ private HexFormat(String delimiter, String prefix, String suffix, boolean ucase) {\n- this.digitCase = digitCase;\n+ this.ucase = ucase;\n- return digitCase == Case.UPPERCASE;\n+ return ucase;\n- if (digitCase == Case.LOWERCASE) {\n+ if (!ucase) {\n- result = 31 * result + Boolean.hashCode(digitCase == Case.UPPERCASE);\n+ result = 31 * result + Boolean.hashCode(ucase);", "target": "- private final Case digitCase;\n- private enum Case {\n-     LOWERCASE,\n-     UPPERCASE\n- }\n+ private final boolean ucase;\n- private HexFormat(String delimiter, String prefix, String suffix, Case digitCase) {\n+ private HexFormat(String delimiter, String prefix, String suffix, boolean ucase) {\n- this.digitCase = digitCase;\n+ this.ucase = ucase;\n- return digitCase == Case.UPPERCASE;\n+ return ucase;\n- if (digitCase == Case.LOWERCASE) {\n+ if (!ucase) {\n- result = 31 * result + Boolean.hashCode(digitCase == Case.UPPERCASE);\n+ result = 31 * result + Boolean.hashCode(ucase);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用枚举类型Case（LOWERCASE/UPPERCASE）表示大小写状态，每个HexFormat实例需要存储枚举对象引用，类加载时需要初始化枚举类。优化后：改用boolean类型ucase（true表示大写，false表示小写），消除了枚举类的加载和初始化开销，减少了内存占用。优化思路：将简单的两状态枚举替换为基本类型boolean，避免枚举类的类加载、静态初始化等启动开销，提升应用启动速度。"}
{"id": 889, "source": "riscv-dataset-excel", "optimization_type": "代码重构+内存分配优化", "optimization_description": "优化前：VM_ParallelGCFailedAllocation和VM_ParallelGCSystemGC两个VM操作类职责重叠，内存分配失败处理逻辑分散在多个方法中，包含复杂的death_march_check机制。优化后：重构为统一的VM_ParallelCollectForAllocation类，合并相关功能；移除death_march_check死亡行军检测机制；新增mem_allocate_work方法统一处理TLAB和非TLAB分配；简化内存分配失败处理流程，通过satisfy_failed_allocation方法集中处理。优化思路：通过代码重构消除冗余，简化内存分配失败的处理逻辑，提高代码可维护性和执行效率。", "original_code": "VM_ParallelGCFailedAllocation和VM_ParallelGCSystemGC两个VM操作类职责重叠，内存分配失败处理逻辑分散在多个方法中，包含复杂的death_march_check机制。", "optimized_code": "- VM_ParallelGCFailedAllocation op(size, gc_count);\n+ VM_ParallelCollectForAllocation op(size, is_tlab, gc_count);\n- HeapWord* ParallelScavengeHeap::failed_mem_allocate(size_t size)\n+ HeapWord* ParallelScavengeHeap::satisfy_failed_allocation(size_t size, bool is_tlab)", "source_url": "https://github.com/openjdk/riscv-port/commit/34d8562a913b8382601e4c0c31ad34a663b9ec0a", "code_v0_no_empty_lines": "VM_ParallelGCFailedAllocation和VM_ParallelGCSystemGC两个VM操作类职责重叠，内存分配失败处理逻辑分散在多个方法中，包含复杂的death_march_check机制。", "code_v1_no_empty_lines": "- VM_ParallelGCFailedAllocation op(size, gc_count);\n+ VM_ParallelCollectForAllocation op(size, is_tlab, gc_count);\n- HeapWord* ParallelScavengeHeap::failed_mem_allocate(size_t size)\n+ HeapWord* ParallelScavengeHeap::satisfy_failed_allocation(size_t size, bool is_tlab)", "target": "- VM_ParallelGCFailedAllocation op(size, gc_count);\n+ VM_ParallelCollectForAllocation op(size, is_tlab, gc_count);\n- HeapWord* ParallelScavengeHeap::failed_mem_allocate(size_t size)\n+ HeapWord* ParallelScavengeHeap::satisfy_failed_allocation(size_t size, bool is_tlab)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：VM_ParallelGCFailedAllocation和VM_ParallelGCSystemGC两个VM操作类职责重叠，内存分配失败处理逻辑分散在多个方法中，包含复杂的death_march_check机制。优化后：重构为统一的VM_ParallelCollectForAllocation类，合并相关功能；移除death_march_check死亡行军检测机制；新增mem_allocate_work方法统一处理TLAB和非TLAB分配；简化内存分配失败处理流程，通过satisfy_failed_allocation方法集中处理。优化思路：通过代码重构消除冗余，简化内存分配失败的处理逻辑，提高代码可维护性和执行效率。"}
{"id": 890, "source": "riscv-dataset-excel", "optimization_type": "类型安全优化", "optimization_description": "优化前：使用int类型变量vtable_index接收memcpy从VtableStub::_index字段复制的数据，但_index字段实际为short类型，存在类型不匹配风险。优化后：将vtable_index声明为short类型，并添加static_assert确保类型大小一致，消除类型不匹配导致的潜在内存访问错误。优化思路：确保memcpy操作的目标变量类型与源数据实际类型完全匹配，增强代码的类型安全性。", "original_code": "使用int类型变量vtable_index接收memcpy从VtableStub::_index字段复制的数据，但_index字段实际为short类型，存在类型不匹配风险。", "optimized_code": "-  int vtable_index;\n+  short vtable_index;\n+  static_assert(sizeof(VtableStub::_index) == sizeof(vtable_index), \"precondition\");", "source_url": "https://github.com/openjdk/riscv-port/commit/a96de6d8d273d75a6500e10ed06faab9955f893b", "code_v0_no_empty_lines": "使用int类型变量vtable_index接收memcpy从VtableStub::_index字段复制的数据，但_index字段实际为short类型，存在类型不匹配风险。", "code_v1_no_empty_lines": "-  int vtable_index;\n+  short vtable_index;\n+  static_assert(sizeof(VtableStub::_index) == sizeof(vtable_index), \"precondition\");", "target": "-  int vtable_index;\n+  short vtable_index;\n+  static_assert(sizeof(VtableStub::_index) == sizeof(vtable_index), \"precondition\");", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：使用int类型变量vtable_index接收memcpy从VtableStub::_index字段复制的数据，但_index字段实际为short类型，存在类型不匹配风险。优化后：将vtable_index声明为short类型，并添加static_assert确保类型大小一致，消除类型不匹配导致的潜在内存访问错误。优化思路：确保memcpy操作的目标变量类型与源数据实际类型完全匹配，增强代码的类型安全性。"}
{"id": 891, "source": "riscv-dataset-excel", "optimization_type": "代码生成优化+性能优化", "optimization_description": "优化前：在RISC-V架构中，调用远距离目标时使用trampoline（跳板）机制，这会增加额外的间接跳转开销和代码大小。优化后：改用load指令直接加载目标地址进行调用，减少了间接跳转，提高了调用性能并减少了代码膨胀。优化思路：利用RISC-V的PC相对寻址能力，通过直接加载目标地址来避免trampoline的开销，这在目标地址在可寻址范围内时更高效。", "original_code": "在RISC-V架构中，调用远距离目标时使用trampoline（跳板）机制，这会增加额外的间接跳转开销和代码大小。", "optimized_code": "- address call = __ trampoline_call(resolve);\n+ address call = __ reloc_call(resolve);", "source_url": "https://github.com/openjdk/riscv-port/commit/5c612c230b0a852aed5fd36e58b82ebf2e1838af", "code_v0_no_empty_lines": "在RISC-V架构中，调用远距离目标时使用trampoline（跳板）机制，这会增加额外的间接跳转开销和代码大小。", "code_v1_no_empty_lines": "- address call = __ trampoline_call(resolve);\n+ address call = __ reloc_call(resolve);", "target": "- address call = __ trampoline_call(resolve);\n+ address call = __ reloc_call(resolve);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在RISC-V架构中，调用远距离目标时使用trampoline（跳板）机制，这会增加额外的间接跳转开销和代码大小。优化后：改用load指令直接加载目标地址进行调用，减少了间接跳转，提高了调用性能并减少了代码膨胀。优化思路：利用RISC-V的PC相对寻址能力，通过直接加载目标地址来避免trampoline的开销，这在目标地址在可寻址范围内时更高效。"}
{"id": 892, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化+锁优化", "optimization_description": "优化前：每次发现垃圾区域时立即获取堆锁进行回收，每次回收后调用SpinPause()让出锁，导致频繁的锁获取/释放开销，并发性能差。优化后：1. 先扫描所有区域，将垃圾区域收集到_trash_regions数组中；2. 采用批量处理方式，每次获取锁后处理多个垃圾区域（最多30微秒）；3. 使用os::naked_yield()主动让出CPU，减少锁竞争。优化思路：减少锁操作频率，将多次细粒度锁合并为批量处理，降低并发清理时的锁竞争开销，提高垃圾回收器与应用程序线程的并发性能。", "original_code": "每次发现垃圾区域时立即获取堆锁进行回收，每次回收后调用SpinPause()让出锁，导致频繁的锁获取/释放开销，并发性能差。", "optimized_code": "-  for (size_t i = 0; i < _heap->num_regions(); i++) {\n    ShenandoahHeapRegion* r = _heap->get_region(i);\n    if (r->is_trash()) {\n      ShenandoahHeapLocker locker(_heap->lock());\n      try_recycle_trashed(r);\n    }\n    SpinPause(); // allow allocators to take the lock\n  }\n+  size_t count = 0;\n  for (size_t i = 0; i < _heap->num_regions(); i++) {\n    ShenandoahHeapRegion* r = _heap->get_region(i);\n    if (r->is_trash()) {\n      _trash_regions[count++] = r;\n    }\n  }\n\n  // Relinquish the lock after this much time passed.\n  static constexpr jlong deadline_ns = 30000; // 30 us\n  size_t idx = 0;\n  while (idx < count) {\n    os::naked_yield(); // Yield to allow allocators to take the lock\n    ShenandoahHeapLocker locker(_heap->lock());\n    const jlong deadline = os::javaTimeNanos() + deadline_ns;\n    while (idx < count && os::javaTimeNanos() < deadline) {\n      try_recycle_trashed(_trash_regions[idx++]);\n    }\n  }", "source_url": "https://github.com/openjdk/riscv-port/commit/b32e4a68bca588d908bd81a398eb3171a6876dc5", "code_v0_no_empty_lines": "每次发现垃圾区域时立即获取堆锁进行回收，每次回收后调用SpinPause()让出锁，导致频繁的锁获取/释放开销，并发性能差。", "code_v1_no_empty_lines": "-  for (size_t i = 0; i < _heap->num_regions(); i++) {\n    ShenandoahHeapRegion* r = _heap->get_region(i);\n    if (r->is_trash()) {\n      ShenandoahHeapLocker locker(_heap->lock());\n      try_recycle_trashed(r);\n    }\n    SpinPause(); // allow allocators to take the lock\n  }\n+  size_t count = 0;\n  for (size_t i = 0; i < _heap->num_regions(); i++) {\n    ShenandoahHeapRegion* r = _heap->get_region(i);\n    if (r->is_trash()) {\n      _trash_regions[count++] = r;\n    }\n  }\n\n  // Relinquish the lock after this much time passed.\n  static constexpr jlong deadline_ns = 30000; // 30 us\n  size_t idx = 0;\n  while (idx < count) {\n    os::naked_yield(); // Yield to allow allocators to take the lock\n    ShenandoahHeapLocker locker(_heap->lock());\n    const jlong deadline = os::javaTimeNanos() + deadline_ns;\n    while (idx < count && os::javaTimeNanos() < deadline) {\n      try_recycle_trashed(_trash_regions[idx++]);\n    }\n  }", "target": "-  for (size_t i = 0; i < _heap->num_regions(); i++) {\n    ShenandoahHeapRegion* r = _heap->get_region(i);\n    if (r->is_trash()) {\n      ShenandoahHeapLocker locker(_heap->lock());\n      try_recycle_trashed(r);\n    }\n    SpinPause(); // allow allocators to take the lock\n  }\n+  size_t count = 0;\n  for (size_t i = 0; i < _heap->num_regions(); i++) {\n    ShenandoahHeapRegion* r = _heap->get_region(i);\n    if (r->is_trash()) {\n      _trash_regions[count++] = r;\n    }\n  }\n\n  // Relinquish the lock after this much time passed.\n  static constexpr jlong deadline_ns = 30000; // 30 us\n  size_t idx = 0;\n  while (idx < count) {\n    os::naked_yield(); // Yield to allow allocators to take the lock\n    ShenandoahHeapLocker locker(_heap->lock());\n    const jlong deadline = os::javaTimeNanos() + deadline_ns;\n    while (idx < count && os::javaTimeNanos() < deadline) {\n      try_recycle_trashed(_trash_regions[idx++]);\n    }\n  }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：每次发现垃圾区域时立即获取堆锁进行回收，每次回收后调用SpinPause()让出锁，导致频繁的锁获取/释放开销，并发性能差。优化后：1. 先扫描所有区域，将垃圾区域收集到_trash_regions数组中；2. 采用批量处理方式，每次获取锁后处理多个垃圾区域（最多30微秒）；3. 使用os::naked_yield()主动让出CPU，减少锁竞争。优化思路：减少锁操作频率，将多次细粒度锁合并为批量处理，降低并发清理时的锁竞争开销，提高垃圾回收器与应用程序线程的并发性能。"}
{"id": 893, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化+OOM处理优化", "optimization_description": "优化前：内存分配失败时，重试条件过于宽松（get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count()），可能导致无限重试或过早放弃。优化后：1) 简化重试条件为仅当未发生Full GC时重试（original_count == shenandoah_policy()->full_gc_count()）；2) 分配成功后主动标记GC进度（notify_gc_progress()）；3) 在DegeneratedGC中移除冗余的notify_gc_no_progress()调用。优化思路：明确OOM处理边界，避免无效重试，及时反馈GC进度，减少内存分配延迟。", "original_code": "内存分配失败时，重试条件过于宽松（get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count()），可能导致无限重试或过早放弃。", "optimized_code": "-    while (result == nullptr\n-        && (get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count())) {\n-      control_thread()->handle_alloc_failure(req, true);\n-      result = allocate_memory_under_lock(req, in_new_region);\n-    }\n+      size_t original_count = shenandoah_policy()->full_gc_count();\n+      while ((result == nullptr) && (original_count == shenandoah_policy()->full_gc_count())) {\n+        control_thread()->handle_alloc_failure(req, true);\n+        result = allocate_memory_under_lock(req, in_new_region);\n+      }\n+      if (result != nullptr) {\n+        // If our allocation request has been satisifed after it initially failed, we count this as good gc progress\n+        notify_gc_progress();\n+      }", "source_url": "https://github.com/openjdk/riscv-port/commit/3a87eb5c4606ce39970962895315567e8606eba7", "code_v0_no_empty_lines": "内存分配失败时，重试条件过于宽松（get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count()），可能导致无限重试或过早放弃。", "code_v1_no_empty_lines": "-    while (result == nullptr\n-        && (get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count())) {\n-      control_thread()->handle_alloc_failure(req, true);\n-      result = allocate_memory_under_lock(req, in_new_region);\n-    }\n+      size_t original_count = shenandoah_policy()->full_gc_count();\n+      while ((result == nullptr) && (original_count == shenandoah_policy()->full_gc_count())) {\n+        control_thread()->handle_alloc_failure(req, true);\n+        result = allocate_memory_under_lock(req, in_new_region);\n+      }\n+      if (result != nullptr) {\n+        // If our allocation request has been satisifed after it initially failed, we count this as good gc progress\n+        notify_gc_progress();\n+      }", "target": "-    while (result == nullptr\n-        && (get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count())) {\n-      control_thread()->handle_alloc_failure(req, true);\n-      result = allocate_memory_under_lock(req, in_new_region);\n-    }\n+      size_t original_count = shenandoah_policy()->full_gc_count();\n+      while ((result == nullptr) && (original_count == shenandoah_policy()->full_gc_count())) {\n+        control_thread()->handle_alloc_failure(req, true);\n+        result = allocate_memory_under_lock(req, in_new_region);\n+      }\n+      if (result != nullptr) {\n+        // If our allocation request has been satisifed after it initially failed, we count this as good gc progress\n+        notify_gc_progress();\n+      }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：内存分配失败时，重试条件过于宽松（get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count()），可能导致无限重试或过早放弃。优化后：1) 简化重试条件为仅当未发生Full GC时重试（original_count == shenandoah_policy()->full_gc_count()）；2) 分配成功后主动标记GC进度（notify_gc_progress()）；3) 在DegeneratedGC中移除冗余的notify_gc_no_progress()调用。优化思路：明确OOM处理边界，避免无效重试，及时反馈GC进度，减少内存分配延迟。"}
{"id": 894, "source": "riscv-dataset-excel", "optimization_type": "内联优化+代码简化", "optimization_description": "优化前：DefNewGeneration和TenuredGeneration类中分别实现contiguous_available()虚函数，通过方法调用获取可用内存大小。优化后：移除contiguous_available()虚函数定义和声明，在TenuredGeneration::promotion_attempt_is_safe()中直接内联计算可用内存（_the_space->free() + _virtual_space.uncommitted_size()）。优化思路：消除虚函数调用开销，简化类层次结构，直接内联核心计算逻辑，减少方法调用层次，提升GC性能。", "original_code": "DefNewGeneration和TenuredGeneration类中分别实现contiguous_available()虚函数，通过方法调用获取可用内存大小。", "optimized_code": "-size_t DefNewGeneration::contiguous_available() const {\n-  return eden()->free();\n-}\n\n-size_t TenuredGeneration::contiguous_available() const {\n-  return _the_space->free() + _virtual_space.uncommitted_size();\n-}\n\n+size_t available = _the_space->free() + _virtual_space.uncommitted_size();", "source_url": "https://github.com/openjdk/riscv-port/commit/d8c1c6ab0543c986280dcfa1c6c79e010a7b35fb", "code_v0_no_empty_lines": "DefNewGeneration和TenuredGeneration类中分别实现contiguous_available()虚函数，通过方法调用获取可用内存大小。", "code_v1_no_empty_lines": "-size_t DefNewGeneration::contiguous_available() const {\n-  return eden()->free();\n-}\n\n-size_t TenuredGeneration::contiguous_available() const {\n-  return _the_space->free() + _virtual_space.uncommitted_size();\n-}\n\n+size_t available = _the_space->free() + _virtual_space.uncommitted_size();", "target": "-size_t DefNewGeneration::contiguous_available() const {\n-  return eden()->free();\n-}\n\n-size_t TenuredGeneration::contiguous_available() const {\n-  return _the_space->free() + _virtual_space.uncommitted_size();\n-}\n\n+size_t available = _the_space->free() + _virtual_space.uncommitted_size();", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：DefNewGeneration和TenuredGeneration类中分别实现contiguous_available()虚函数，通过方法调用获取可用内存大小。优化后：移除contiguous_available()虚函数定义和声明，在TenuredGeneration::promotion_attempt_is_safe()中直接内联计算可用内存（_the_space->free() + _virtual_space.uncommitted_size()）。优化思路：消除虚函数调用开销，简化类层次结构，直接内联核心计算逻辑，减少方法调用层次，提升GC性能。"}
{"id": 895, "source": "riscv-dataset-excel", "optimization_type": "代码重构+内存优化", "optimization_description": "优化前：枚举类的CDS（Class Data Sharing）处理逻辑分散在heapShared.cpp中，与通用堆共享代码混合，导致代码结构复杂、维护困难。优化后：将枚举类特定的CDS处理逻辑重构到独立的cdsEnumKlass模块中，包括枚举对象识别、静态字段归档和运行时初始化等功能。优化思路：通过模块化重构提高代码可读性和可维护性，减少heapShared.cpp的复杂度（删除94行代码），同时保持功能不变，为后续优化提供清晰的架构基础。", "original_code": "枚举类的CDS（Class Data Sharing）处理逻辑分散在heapShared.cpp中，与通用堆共享代码混合，导致代码结构复杂、维护困难。", "optimized_code": "创建新文件 src/hotspot/share/cds/cdsEnumKlass.cpp 和 cdsEnumKlass.hpp，将枚举类处理逻辑从 heapShared.cpp 中分离出来。主要函数包括：\n- bool CDSEnumKlass::is_enum_obj(oop orig_obj)\n- void CDSEnumKlass::handle_enum_obj(int level, KlassSubGraphInfo* subgraph_info, oop orig_obj)\n- void CDSEnumKlass::archive_static_field(int level, KlassSubGraphInfo* subgraph_info, InstanceKlass* ik, oop mirror, JavaFieldStream& fs)\n- bool CDSEnumKlass::initialize_enum_klass(InstanceKlass* k, TRAPS)", "source_url": "https://github.com/openjdk/riscv-port/commit/9c7a6eabb93c570fdb74076edc931576ed6be3e0", "code_v0_no_empty_lines": "枚举类的CDS（Class Data Sharing）处理逻辑分散在heapShared.cpp中，与通用堆共享代码混合，导致代码结构复杂、维护困难。", "code_v1_no_empty_lines": "创建新文件 src/hotspot/share/cds/cdsEnumKlass.cpp 和 cdsEnumKlass.hpp，将枚举类处理逻辑从 heapShared.cpp 中分离出来。主要函数包括：\n- bool CDSEnumKlass::is_enum_obj(oop orig_obj)\n- void CDSEnumKlass::handle_enum_obj(int level, KlassSubGraphInfo* subgraph_info, oop orig_obj)\n- void CDSEnumKlass::archive_static_field(int level, KlassSubGraphInfo* subgraph_info, InstanceKlass* ik, oop mirror, JavaFieldStream& fs)\n- bool CDSEnumKlass::initialize_enum_klass(InstanceKlass* k, TRAPS)", "target": "创建新文件 src/hotspot/share/cds/cdsEnumKlass.cpp 和 cdsEnumKlass.hpp，将枚举类处理逻辑从 heapShared.cpp 中分离出来。主要函数包括：\n- bool CDSEnumKlass::is_enum_obj(oop orig_obj)\n- void CDSEnumKlass::handle_enum_obj(int level, KlassSubGraphInfo* subgraph_info, oop orig_obj)\n- void CDSEnumKlass::archive_static_field(int level, KlassSubGraphInfo* subgraph_info, InstanceKlass* ik, oop mirror, JavaFieldStream& fs)\n- bool CDSEnumKlass::initialize_enum_klass(InstanceKlass* k, TRAPS)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：枚举类的CDS（Class Data Sharing）处理逻辑分散在heapShared.cpp中，与通用堆共享代码混合，导致代码结构复杂、维护困难。优化后：将枚举类特定的CDS处理逻辑重构到独立的cdsEnumKlass模块中，包括枚举对象识别、静态字段归档和运行时初始化等功能。优化思路：通过模块化重构提高代码可读性和可维护性，减少heapShared.cpp的复杂度（删除94行代码），同时保持功能不变，为后续优化提供清晰的架构基础。"}
{"id": 896, "source": "riscv-dataset-excel", "optimization_type": "内存布局优化", "optimization_description": "优化前：_jvmci_ir_size（int类型）和_failed_speculations（指针类型）字段顺序为int在前、指针在后，可能导致内存对齐填充浪费。优化后：将指针类型字段_failed_speculations移到int类型字段_jvmci_ir_size之前，利用指针通常需要更严格对齐的特性，减少内存填充，优化MethodData对象的内存布局，降低内存占用。", "original_code": "_jvmci_ir_size（int类型）和_failed_speculations（指针类型）字段顺序为int在前、指针在后，可能导致内存对齐填充浪费。", "optimized_code": "@@ -2080,8 +2079,8 @@ class MethodData : public Metadata {\n \n #if INCLUDE_JVMCI\n   // Support for HotSpotMethodData.setCompiledIRSize(int)\n-  int                _jvmci_ir_size;\n   FailedSpeculation* _failed_speculations;\n+  int                _jvmci_ir_size;\n #endif", "source_url": "https://github.com/openjdk/riscv-port/commit/c5a668bb653feb3408a9efa3274ceabf9f01a2c7", "code_v0_no_empty_lines": "_jvmci_ir_size（int类型）和_failed_speculations（指针类型）字段顺序为int在前、指针在后，可能导致内存对齐填充浪费。", "code_v1_no_empty_lines": "@@ -2080,8 +2079,8 @@ class MethodData : public Metadata {\n \n #if INCLUDE_JVMCI\n   // Support for HotSpotMethodData.setCompiledIRSize(int)\n-  int                _jvmci_ir_size;\n   FailedSpeculation* _failed_speculations;\n+  int                _jvmci_ir_size;\n #endif", "target": "@@ -2080,8 +2079,8 @@ class MethodData : public Metadata {\n \n #if INCLUDE_JVMCI\n   // Support for HotSpotMethodData.setCompiledIRSize(int)\n-  int                _jvmci_ir_size;\n   FailedSpeculation* _failed_speculations;\n+  int                _jvmci_ir_size;\n #endif", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：_jvmci_ir_size（int类型）和_failed_speculations（指针类型）字段顺序为int在前、指针在后，可能导致内存对齐填充浪费。优化后：将指针类型字段_failed_speculations移到int类型字段_jvmci_ir_size之前，利用指针通常需要更严格对齐的特性，减少内存填充，优化MethodData对象的内存布局，降低内存占用。"}
{"id": 899, "source": "riscv-dataset-excel", "optimization_type": "算法优化", "optimization_description": "识别高频调用的字符串操作路径（如数字格式化），用更高效的库函数替代手动循环。\n\n利用Java标准库的优化实现（StringBuilder.repeat可能使用本地方法或批量操作），避免重复造轮子。\n\n遵循\"减少间接性\"原则，用单一抽象替代重复操作。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 在java.util.Formatter类中的trailingZeros方法\nprivate void trailingZeros(StringBuilder sb, int nzeros) {\n-   for (int i = 0; i < nzeros; i++) {\n-       sb.append('0');\n-   }\n+   if (nzeros > 0) {\n+       sb.repeat('0', nzeros);\n+   }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/194425d7875ef42fce52516ed59c81ee97720399", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 在java.util.Formatter类中的trailingZeros方法\nprivate void trailingZeros(StringBuilder sb, int nzeros) {\n-   for (int i = 0; i < nzeros; i++) {\n-       sb.append('0');\n-   }\n+   if (nzeros > 0) {\n+       sb.repeat('0', nzeros);\n+   }\n}", "target": "// 在java.util.Formatter类中的trailingZeros方法\nprivate void trailingZeros(StringBuilder sb, int nzeros) {\n-   for (int i = 0; i < nzeros; i++) {\n-       sb.append('0');\n-   }\n+   if (nzeros > 0) {\n+       sb.repeat('0', nzeros);\n+   }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "识别高频调用的字符串操作路径（如数字格式化），用更高效的库函数替代手动循环。\n\n利用Java标准库的优化实现（StringBuilder.repeat可能使用本地方法或批量操作），避免重复造轮子。\n\n遵循\"减少间接性\"原则，用单一抽象替代重复操作。"}
{"id": 900, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+内存优化", "optimization_description": "性能提升：减少函数调用开销，提高偏移数组设置的速度。在G1垃圾收集器中，偏移数组用于跟踪堆内存块的偏移量，在对象分配和GC期间频繁访问，因此优化能直接提升GC性能。\n\n指令缓存效率：更少的函数调用意味着更紧凑的代码，可能提高CPU指令缓存命中率。\n\n编译后代码大小：内联可能增加调用点的代码大小，但消除整个函数可能净减少代码量，改善缓存局部性。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 优化前：\n-void G1BlockOffsetTable::set_offset_array_raw(uint8_t* addr, uint8_t offset) {\n-  Atomic::store(addr, offset);\n-}\n\nvoid G1BlockOffsetTable::set_offset_array(uint8_t* addr, uint8_t offset) {\n  check_address(addr, \"Block offset table address out of range\");\n-  set_offset_array_raw(addr, offset);  // 间接调用\n+  Atomic::store(addr, offset);  // 直接内联\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/b07e1531b375b9d8117e218355e70272e27e1225", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 优化前：\n-void G1BlockOffsetTable::set_offset_array_raw(uint8_t* addr, uint8_t offset) {\n-  Atomic::store(addr, offset);\n-}\n\nvoid G1BlockOffsetTable::set_offset_array(uint8_t* addr, uint8_t offset) {\n  check_address(addr, \"Block offset table address out of range\");\n-  set_offset_array_raw(addr, offset);  // 间接调用\n+  Atomic::store(addr, offset);  // 直接内联\n}", "target": "// 优化前：\n-void G1BlockOffsetTable::set_offset_array_raw(uint8_t* addr, uint8_t offset) {\n-  Atomic::store(addr, offset);\n-}\n\nvoid G1BlockOffsetTable::set_offset_array(uint8_t* addr, uint8_t offset) {\n  check_address(addr, \"Block offset table address out of range\");\n-  set_offset_array_raw(addr, offset);  // 间接调用\n+  Atomic::store(addr, offset);  // 直接内联\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升：减少函数调用开销，提高偏移数组设置的速度。在G1垃圾收集器中，偏移数组用于跟踪堆内存块的偏移量，在对象分配和GC期间频繁访问，因此优化能直接提升GC性能。\n\n指令缓存效率：更少的函数调用意味着更紧凑的代码，可能提高CPU指令缓存命中率。\n\n编译后代码大小：内联可能增加调用点的代码大小，但消除整个函数可能净减少代码量，改善缓存局部性。"}
{"id": 901, "source": "riscv-dataset-excel", "optimization_type": "内存优化+并发性能优化", "optimization_description": "性能提升：优化前，每个I/O操作（如read、write）都调用Blocker.begin()和Blocker.end()，这些方法用于管理线程阻塞（尤其是虚拟线程）。这些调用涉及线程状态检查、锁获取或原子操作，有一定开销。优化后完全移除了这些调用，减少了I/O路径上的开销，提高了文件操作性能。\n\n虚拟线程效率：虚拟线程的阻塞管理被简化，避免了不必要的并行度调整，使线程调度更高效。这特别适用于高并发I/O场景，如网络服务器。\n\n代码简化：多个文件操作类（如FileInputStream、FileOutputStream、Native文件系统调用）移除了Blocker代码，减少了代码复杂性和维护成本。", "original_code": "// No original code extracted from description\n", "optimized_code": "- long comp = Blocker.begin(blocking);\n+ boolean attempted = Blocker.begin(blocking);\ntry {\n  numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n} finally {\n- Blocker.end(comp);\n+ Blocker.end(attempted);\n}\nprivate void open(String name) throws FileNotFoundException {\n- long comp = Blocker.begin();\n- try {\n-   open0(name);\n- } finally {\n-   Blocker.end(comp);\n- }\n+ open0(name);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/412e306d81209c05f55aee7663f7abb80286e361", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "- long comp = Blocker.begin(blocking);\n+ boolean attempted = Blocker.begin(blocking);\ntry {\n  numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n} finally {\n- Blocker.end(comp);\n+ Blocker.end(attempted);\n}\nprivate void open(String name) throws FileNotFoundException {\n- long comp = Blocker.begin();\n- try {\n-   open0(name);\n- } finally {\n-   Blocker.end(comp);\n- }\n+ open0(name);\n}", "target": "- long comp = Blocker.begin(blocking);\n+ boolean attempted = Blocker.begin(blocking);\ntry {\n  numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n} finally {\n- Blocker.end(comp);\n+ Blocker.end(attempted);\n}\nprivate void open(String name) throws FileNotFoundException {\n- long comp = Blocker.begin();\n- try {\n-   open0(name);\n- } finally {\n-   Blocker.end(comp);\n- }\n+ open0(name);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升：优化前，每个I/O操作（如read、write）都调用Blocker.begin()和Blocker.end()，这些方法用于管理线程阻塞（尤其是虚拟线程）。这些调用涉及线程状态检查、锁获取或原子操作，有一定开销。优化后完全移除了这些调用，减少了I/O路径上的开销，提高了文件操作性能。\n\n虚拟线程效率：虚拟线程的阻塞管理被简化，避免了不必要的并行度调整，使线程调度更高效。这特别适用于高并发I/O场景，如网络服务器。\n\n代码简化：多个文件操作类（如FileInputStream、FileOutputStream、Native文件系统调用）移除了Blocker代码，减少了代码复杂性和维护成本。"}
{"id": 902, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：分配守卫功能在调试模式下用于检测内存溢出，每次分配都会额外分配守卫块并定期验证，增加了内存和CPU开销。\n\n优化后：移除了分配守卫相关代码，减少了不必要的内存分配和检查，提高了运行时性能，但牺牲了调试能力。优化思路是生产环境中不需要调试守卫，移除后可以提升效率。", "original_code": "分配守卫功能在调试模式下用于检测内存溢出，每次分配都会额外分配守卫块并定期验证，增加了内存和CPU开销。", "optimized_code": "-#ifdef ASSERT\n- // Fence allocation\n- if (p != nullptr && Settings::use_allocation_guard()) {\n-   STATIC_ASSERT(is_aligned(sizeof(Fence), BytesPerWord));\n-   MetaWord* guard = allocate_inner(sizeof(Fence) / BytesPerWord);\n-   if (guard != nullptr) {\n-     // Ignore allocation errors for the fence to keep coding simple. If this\n-     // happens (e.g. because right at this time we hit the Metaspace GC threshold)\n-     // we miss adding this one fence. Not a big deal. Note that his would\n-     // be pretty rare. Chances are much higher the primary allocation above\n-     // would have already failed).\n-     Fence* f = new(guard) Fence(_first_fence);\n-     _first_fence = f;\n-   }\n- }\n-#endif // ASSERT", "source_url": "https://github.com/openjdk/riscv-port/commit/b0efd7740243916ba22178524ab2ede9e5436d94", "code_v0_no_empty_lines": "分配守卫功能在调试模式下用于检测内存溢出，每次分配都会额外分配守卫块并定期验证，增加了内存和CPU开销。", "code_v1_no_empty_lines": "-#ifdef ASSERT\n- // Fence allocation\n- if (p != nullptr && Settings::use_allocation_guard()) {\n-   STATIC_ASSERT(is_aligned(sizeof(Fence), BytesPerWord));\n-   MetaWord* guard = allocate_inner(sizeof(Fence) / BytesPerWord);\n-   if (guard != nullptr) {\n-     // Ignore allocation errors for the fence to keep coding simple. If this\n-     // happens (e.g. because right at this time we hit the Metaspace GC threshold)\n-     // we miss adding this one fence. Not a big deal. Note that his would\n-     // be pretty rare. Chances are much higher the primary allocation above\n-     // would have already failed).\n-     Fence* f = new(guard) Fence(_first_fence);\n-     _first_fence = f;\n-   }\n- }\n-#endif // ASSERT", "target": "-#ifdef ASSERT\n- // Fence allocation\n- if (p != nullptr && Settings::use_allocation_guard()) {\n-   STATIC_ASSERT(is_aligned(sizeof(Fence), BytesPerWord));\n-   MetaWord* guard = allocate_inner(sizeof(Fence) / BytesPerWord);\n-   if (guard != nullptr) {\n-     // Ignore allocation errors for the fence to keep coding simple. If this\n-     // happens (e.g. because right at this time we hit the Metaspace GC threshold)\n-     // we miss adding this one fence. Not a big deal. Note that his would\n-     // be pretty rare. Chances are much higher the primary allocation above\n-     // would have already failed).\n-     Fence* f = new(guard) Fence(_first_fence);\n-     _first_fence = f;\n-   }\n- }\n-#endif // ASSERT", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：分配守卫功能在调试模式下用于检测内存溢出，每次分配都会额外分配守卫块并定期验证，增加了内存和CPU开销。\n\n优化后：移除了分配守卫相关代码，减少了不必要的内存分配和检查，提高了运行时性能，但牺牲了调试能力。优化思路是生产环境中不需要调试守卫，移除后可以提升效率。"}
{"id": 903, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：AIX系统上可能默认使用4K页面，导致页表项较多，内存访问开销较大。\n\n优化后：当系统支持时（AIX 7.3 TL1及以上），使用64K页面进行mmap，减少页故障和TLB缺失，提高内存性能。优化思路是利用大页面减少内存管理开销。", "original_code": "AIX系统上可能默认使用4K页面，导致页表项较多，内存访问开销较大。", "optimized_code": "+// sys/mman.h defines MAP_ANON_64K beginning with AIX7.3 TL1\n+#ifndef MAP_ANON_64K\n+ #define MAP_ANON_64K 0x400\n+#else\n+ STATIC_ASSERT(MAP_ANON_64K == 0x400);\n+#endif\n+ if (os::vm_page_size() == 64*K && g_multipage_support.can_use_64K_mmap_pages) {\n+   flags |= MAP_ANON_64K;\n+ }", "source_url": "https://github.com/openjdk/riscv-port/commit/ced99066354fc6a32c587b9e3c35b07e26d3452e", "code_v0_no_empty_lines": "AIX系统上可能默认使用4K页面，导致页表项较多，内存访问开销较大。", "code_v1_no_empty_lines": "+// sys/mman.h defines MAP_ANON_64K beginning with AIX7.3 TL1\n+#ifndef MAP_ANON_64K\n+ #define MAP_ANON_64K 0x400\n+#else\n+ STATIC_ASSERT(MAP_ANON_64K == 0x400);\n+#endif\n+ if (os::vm_page_size() == 64*K && g_multipage_support.can_use_64K_mmap_pages) {\n+   flags |= MAP_ANON_64K;\n+ }", "target": "+// sys/mman.h defines MAP_ANON_64K beginning with AIX7.3 TL1\n+#ifndef MAP_ANON_64K\n+ #define MAP_ANON_64K 0x400\n+#else\n+ STATIC_ASSERT(MAP_ANON_64K == 0x400);\n+#endif\n+ if (os::vm_page_size() == 64*K && g_multipage_support.can_use_64K_mmap_pages) {\n+   flags |= MAP_ANON_64K;\n+ }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：AIX系统上可能默认使用4K页面，导致页表项较多，内存访问开销较大。\n\n优化后：当系统支持时（AIX 7.3 TL1及以上），使用64K页面进行mmap，减少页故障和TLB缺失，提高内存性能。优化思路是利用大页面减少内存管理开销。"}
{"id": 904, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "优化前：JVMCI编译器无法访问L1缓存行大小信息，可能无法进行缓存友好的优化。\n\n优化后：JVMCI可以获取L1缓存行大小，在编译时生成更高效的代码，减少缓存缺失。优化思路是暴露硬件信息给编译器，以启用低级优化。", "original_code": "JVMCI编译器无法访问L1缓存行大小信息，可能无法进行缓存友好的优化。", "optimized_code": "+#ifdef X86\n+ static int L1_line_size;\n+#endif\n+#ifdef X86\n+int CompilerToVM::Data::L1_line_size;\n+#endif\n+...\n+#ifdef X86\n+ L1_line_size = VM_Version::L1_line_size();\n+#endif", "source_url": "https://github.com/openjdk/riscv-port/commit/916db07e533cdc0fca2010751f7ebe54e6ada7b9", "code_v0_no_empty_lines": "JVMCI编译器无法访问L1缓存行大小信息，可能无法进行缓存友好的优化。", "code_v1_no_empty_lines": "+#ifdef X86\n+ static int L1_line_size;\n+#endif\n+#ifdef X86\n+int CompilerToVM::Data::L1_line_size;\n+#endif\n+...\n+#ifdef X86\n+ L1_line_size = VM_Version::L1_line_size();\n+#endif", "target": "+#ifdef X86\n+ static int L1_line_size;\n+#endif\n+#ifdef X86\n+int CompilerToVM::Data::L1_line_size;\n+#endif\n+...\n+#ifdef X86\n+ L1_line_size = VM_Version::L1_line_size();\n+#endif", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：JVMCI编译器无法访问L1缓存行大小信息，可能无法进行缓存友好的优化。\n\n优化后：JVMCI可以获取L1缓存行大小，在编译时生成更高效的代码，减少缓存缺失。优化思路是暴露硬件信息给编译器，以启用低级优化。"}
{"id": 905, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+条件分支优化", "optimization_description": "优化前：encode_heap_oop方法总是检查oop是否为空，即使已知不为空，也执行条件分支，增加开销。\n\n优化后：添加了encode_heap_oop_not_null方法，当oop已知不为空时，直接编码，跳过空检查。优化思路是减少热点路径上的分支，提高性能。", "original_code": "encode_heap_oop方法总是检查oop是否为空，即使已知不为空，也执行条件分支，增加开销。", "optimized_code": "+ void MacroAssembler::encode_heap_oop_not_null(Register r) {\n+   #ifdef ASSERT\n+   if (CheckCompressedOops) {\n+     Label ok;\n+     bnez(r, ok);\n+     stop(\"null oop passed to encode_heap_oop_not_null\");\n+     bind(ok);\n+   }\n+   #endif\n+   verify_oop_msg(r, \"broken oop in encode_heap_oop_not_null\");\n+   if (CompressedOops::base() != nullptr) {\n+     sub(r, r, xheapbase);\n+   }\n+   if (CompressedOops::shift() != 0) {\n+     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), \"decode alg wrong\");\n+     srli(r, r, LogMinObjAlignmentInBytes);\n+   }\n+ }\n+ instruct encodeHeapOop_not_null(iRegNNoSp dst, iRegP src) %{\n+   predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull);\n+   match(Set dst (EncodeP src));\n+   ins_cost(ALU_COST);\n+   format %{ \"encode_heap_oop_not_null $dst, $src\\t#@encodeHeapOop_not_null\" %}\n+   ins_encode %{\n+     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);\n+   %}\n+   ins_pipe(pipe_class_default);\n+ %}", "source_url": "https://github.com/openjdk/riscv-port/commit/5866b16dbca3f63770c8792d204dabdf49b59839", "code_v0_no_empty_lines": "encode_heap_oop方法总是检查oop是否为空，即使已知不为空，也执行条件分支，增加开销。", "code_v1_no_empty_lines": "+ void MacroAssembler::encode_heap_oop_not_null(Register r) {\n+   #ifdef ASSERT\n+   if (CheckCompressedOops) {\n+     Label ok;\n+     bnez(r, ok);\n+     stop(\"null oop passed to encode_heap_oop_not_null\");\n+     bind(ok);\n+   }\n+   #endif\n+   verify_oop_msg(r, \"broken oop in encode_heap_oop_not_null\");\n+   if (CompressedOops::base() != nullptr) {\n+     sub(r, r, xheapbase);\n+   }\n+   if (CompressedOops::shift() != 0) {\n+     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), \"decode alg wrong\");\n+     srli(r, r, LogMinObjAlignmentInBytes);\n+   }\n+ }\n+ instruct encodeHeapOop_not_null(iRegNNoSp dst, iRegP src) %{\n+   predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull);\n+   match(Set dst (EncodeP src));\n+   ins_cost(ALU_COST);\n+   format %{ \"encode_heap_oop_not_null $dst, $src\\t#@encodeHeapOop_not_null\" %}\n+   ins_encode %{\n+     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);\n+   %}\n+   ins_pipe(pipe_class_default);\n+ %}", "target": "+ void MacroAssembler::encode_heap_oop_not_null(Register r) {\n+   #ifdef ASSERT\n+   if (CheckCompressedOops) {\n+     Label ok;\n+     bnez(r, ok);\n+     stop(\"null oop passed to encode_heap_oop_not_null\");\n+     bind(ok);\n+   }\n+   #endif\n+   verify_oop_msg(r, \"broken oop in encode_heap_oop_not_null\");\n+   if (CompressedOops::base() != nullptr) {\n+     sub(r, r, xheapbase);\n+   }\n+   if (CompressedOops::shift() != 0) {\n+     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), \"decode alg wrong\");\n+     srli(r, r, LogMinObjAlignmentInBytes);\n+   }\n+ }\n+ instruct encodeHeapOop_not_null(iRegNNoSp dst, iRegP src) %{\n+   predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull);\n+   match(Set dst (EncodeP src));\n+   ins_cost(ALU_COST);\n+   format %{ \"encode_heap_oop_not_null $dst, $src\\t#@encodeHeapOop_not_null\" %}\n+   ins_encode %{\n+     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);\n+   %}\n+   ins_pipe(pipe_class_default);\n+ %}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：encode_heap_oop方法总是检查oop是否为空，即使已知不为空，也执行条件分支，增加开销。\n\n优化后：添加了encode_heap_oop_not_null方法，当oop已知不为空时，直接编码，跳过空检查。优化思路是减少热点路径上的分支，提高性能。"}
{"id": 906, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+指令集优化", "optimization_description": "核心思路是发现non_mark_prev_bits的计算是多余的。在ZGC的上下文中，prev指针的某些位（非标记位）可能不需要保留，因为返回的掩码已经包含了所有必要信息（如ZPointerRememberedMask）。通过直接使用固定掩码，避免了运行时计算。", "original_code": "// No original code extracted from description\n", "optimized_code": "-  const uintptr_t non_mark_bits_mask = ZPointerMarkMetadataMask ^ ZPointerAllMetadataMask;\n-  const uintptr_t non_mark_prev_bits = untype (prev) & non_mark_bits_mask;\n-  return color (addr, ZPointerLoadGoodMask | ZPointerMarkedYoung | ZPointerFinalizable | non_mark_prev_bits | ZPointerRememberedMask);\n+  return color (addr, ZPointerLoadGoodMask | ZPointerMarkedYoung | ZPointerFinalizable | ZPointerRememberedMask);))", "source_url": "https://github.com/openjdk/riscv-port/commit/b4cea701c9cab15007c485088dd5b8d7025d83ef", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "-  const uintptr_t non_mark_bits_mask = ZPointerMarkMetadataMask ^ ZPointerAllMetadataMask;\n-  const uintptr_t non_mark_prev_bits = untype (prev) & non_mark_bits_mask;\n-  return color (addr, ZPointerLoadGoodMask | ZPointerMarkedYoung | ZPointerFinalizable | non_mark_prev_bits | ZPointerRememberedMask);\n+  return color (addr, ZPointerLoadGoodMask | ZPointerMarkedYoung | ZPointerFinalizable | ZPointerRememberedMask);))", "target": "-  const uintptr_t non_mark_bits_mask = ZPointerMarkMetadataMask ^ ZPointerAllMetadataMask;\n-  const uintptr_t non_mark_prev_bits = untype (prev) & non_mark_bits_mask;\n-  return color (addr, ZPointerLoadGoodMask | ZPointerMarkedYoung | ZPointerFinalizable | non_mark_prev_bits | ZPointerRememberedMask);\n+  return color (addr, ZPointerLoadGoodMask | ZPointerMarkedYoung | ZPointerFinalizable | ZPointerRememberedMask);))", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "核心思路是发现non_mark_prev_bits的计算是多余的。在ZGC的上下文中，prev指针的某些位（非标记位）可能不需要保留，因为返回的掩码已经包含了所有必要信息（如ZPointerRememberedMask）。通过直接使用固定掩码，避免了运行时计算。"}
{"id": 907, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "优化前: 字符串比较的向量化实现使用固定LMUL（向量长度乘数）m2，未考虑硬件最大向量大小限制，可能导致低效指令生成。\n\n优化后: 根据字符串编码类型和硬件最大向量大小动态选择LMUL（如最大向量大小为16时使用m4），并添加专用128位向量指令vstring_compareU_128b。\n\n优化效果: 提升字符串比较性能，尤其在小字符串场景（统计显示80%字符串<128字节）。优化后能更好利用硬件向量能力，减少指令开销。\n\n优化思路: 适配硬件特性，为不同场景生成最优向量指令。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 动态选择LMUL\nif (!encLL && MaxVectorSize == 16) {\n    element_compare(..., Assembler::m4); // UU编码且向量受限时用m4\n} else {\n    element_compare(..., Assembler::m2); // 默认用m2\n}\n\n// 新增128位专用指令\ninstruct vstring_compareU_128b(...) {\n    predicate(UseRVV && encoding() == StrIntrinsicNode::UU && MaxVectorSize == 16);\n    // ... 优化实现\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/13b782c3de9a470a7cf1db9d5111ce19faf28729", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 动态选择LMUL\nif (!encLL && MaxVectorSize == 16) {\n    element_compare(..., Assembler::m4); // UU编码且向量受限时用m4\n} else {\n    element_compare(..., Assembler::m2); // 默认用m2\n}\n\n// 新增128位专用指令\ninstruct vstring_compareU_128b(...) {\n    predicate(UseRVV && encoding() == StrIntrinsicNode::UU && MaxVectorSize == 16);\n    // ... 优化实现\n}", "target": "// 动态选择LMUL\nif (!encLL && MaxVectorSize == 16) {\n    element_compare(..., Assembler::m4); // UU编码且向量受限时用m4\n} else {\n    element_compare(..., Assembler::m2); // 默认用m2\n}\n\n// 新增128位专用指令\ninstruct vstring_compareU_128b(...) {\n    predicate(UseRVV && encoding() == StrIntrinsicNode::UU && MaxVectorSize == 16);\n    // ... 优化实现\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: 字符串比较的向量化实现使用固定LMUL（向量长度乘数）m2，未考虑硬件最大向量大小限制，可能导致低效指令生成。\n\n优化后: 根据字符串编码类型和硬件最大向量大小动态选择LMUL（如最大向量大小为16时使用m4），并添加专用128位向量指令vstring_compareU_128b。\n\n优化效果: 提升字符串比较性能，尤其在小字符串场景（统计显示80%字符串<128字节）。优化后能更好利用硬件向量能力，减少指令开销。\n\n优化思路: 适配硬件特性，为不同场景生成最优向量指令。"}
{"id": 908, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "优化前后对比:\n\n优化前: encode_heap_oop始终包含null检查，即使oop已知非null（如TypePtr::NotNull），增加冗余分支。\n\n优化后: 引入encode_heap_oop_not_null方法，跳过null检查；在指令匹配中通过谓词区分null/non-null情况。\n\n优化效果: 减少条件分支和指令数，提升oop编码速度（GC和对象访问关键路径）。\n\n优化思路: 利用类型信息避免已知条件的运行时检查。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 新增非null编码方法\nvoid encode_heap_oop_not_null(Register dst, Register src) {\n    #ifdef ASSERT\n    if (CheckCompressedOops) { ... } // 仅调试检查\n    #endif\n    // 直接编码，无null检查\n    sub(dst, src, xheapbase);\n}\n\n// 指令匹配优化\ninstruct encodeHeapOop_not_null(iRegNNoSp dst, iRegP src) {\n    predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull);\n    match(Set dst (EncodeP src));\n    ins_encode %{ __ encode_heap_oop_not_null($dst$$Register, $src$$Register); %}\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/b0efd7740243916ba22178524ab2ede9e5436d94", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 新增非null编码方法\nvoid encode_heap_oop_not_null(Register dst, Register src) {\n    #ifdef ASSERT\n    if (CheckCompressedOops) { ... } // 仅调试检查\n    #endif\n    // 直接编码，无null检查\n    sub(dst, src, xheapbase);\n}\n\n// 指令匹配优化\ninstruct encodeHeapOop_not_null(iRegNNoSp dst, iRegP src) {\n    predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull);\n    match(Set dst (EncodeP src));\n    ins_encode %{ __ encode_heap_oop_not_null($dst$$Register, $src$$Register); %}\n}", "target": "// 新增非null编码方法\nvoid encode_heap_oop_not_null(Register dst, Register src) {\n    #ifdef ASSERT\n    if (CheckCompressedOops) { ... } // 仅调试检查\n    #endif\n    // 直接编码，无null检查\n    sub(dst, src, xheapbase);\n}\n\n// 指令匹配优化\ninstruct encodeHeapOop_not_null(iRegNNoSp dst, iRegP src) {\n    predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull);\n    match(Set dst (EncodeP src));\n    ins_encode %{ __ encode_heap_oop_not_null($dst$$Register, $src$$Register); %}\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前后对比:\n\n优化前: encode_heap_oop始终包含null检查，即使oop已知非null（如TypePtr::NotNull），增加冗余分支。\n\n优化后: 引入encode_heap_oop_not_null方法，跳过null检查；在指令匹配中通过谓词区分null/non-null情况。\n\n优化效果: 减少条件分支和指令数，提升oop编码速度（GC和对象访问关键路径）。\n\n优化思路: 利用类型信息避免已知条件的运行时检查。"}
{"id": 909, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前后对比:\n\n优化前: InterpreterOopMap成员顺序导致内存填充（如_method(8B)后接_bci(2B)，可能产生6B填充）。\n\n优化后: 调整字段顺序（将_bci移到_mask_size(4B)后），减少填充字节。\n\n优化效果: 结构体大小从约40B减至32B，内存占用减少20%，改善缓存局部性。\n\n优化思路: 通过字段重排减少内存空洞，优化数据结构布局。", "original_code": "// No original code extracted from description\n", "optimized_code": "class InterpreterOopMap {\n    Method* _method;        // 8B\n    int _mask_size;         // 4B\n    int _expression_stack_size; // 4B\n    unsigned short _bci;    // 2B (原在_method后)\n    // ... 其他字段\n};", "source_url": "https://github.com/openjdk/riscv-port/commit/ced99066354fc6a32c587b9e3c35b07e26d3452e", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "class InterpreterOopMap {\n    Method* _method;        // 8B\n    int _mask_size;         // 4B\n    int _expression_stack_size; // 4B\n    unsigned short _bci;    // 2B (原在_method后)\n    // ... 其他字段\n};", "target": "class InterpreterOopMap {\n    Method* _method;        // 8B\n    int _mask_size;         // 4B\n    int _expression_stack_size; // 4B\n    unsigned short _bci;    // 2B (原在_method后)\n    // ... 其他字段\n};", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前后对比:\n\n优化前: InterpreterOopMap成员顺序导致内存填充（如_method(8B)后接_bci(2B)，可能产生6B填充）。\n\n优化后: 调整字段顺序（将_bci移到_mask_size(4B)后），减少填充字节。\n\n优化效果: 结构体大小从约40B减至32B，内存占用减少20%，改善缓存局部性。\n\n优化思路: 通过字段重排减少内存空洞，优化数据结构布局。"}
{"id": 910, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前: Klass中_bitmap和_hash_slot位于中间位置，破坏对齐，增加填充。\n\n优化后: 将不常用字段(_bitmap, _hash_slot)移到末尾，常用字段(_class_loader_data, _vtable_len)更紧凑。\n\n优化效果: 提升常用字段访问速度（减少缓存未命中），降低内存占用。\n\n优化思路: 将高频访问字段集中到对象头部，利用空间局部性。", "original_code": "// No original code extracted from description\n", "optimized_code": "class Klass : public Metadata {\n    ClassLoaderData* _class_loader_data; // 常用字段在前\n    int _vtable_len;\n    // ...\n    uintx _bitmap;           // 不常用字段后移\n    uint8_t _hash_slot;\n};", "source_url": "https://github.com/openjdk/riscv-port/commit/916db07e533cdc0fca2010751f7ebe54e6ada7b9", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "class Klass : public Metadata {\n    ClassLoaderData* _class_loader_data; // 常用字段在前\n    int _vtable_len;\n    // ...\n    uintx _bitmap;           // 不常用字段后移\n    uint8_t _hash_slot;\n};", "target": "class Klass : public Metadata {\n    ClassLoaderData* _class_loader_data; // 常用字段在前\n    int _vtable_len;\n    // ...\n    uintx _bitmap;           // 不常用字段后移\n    uint8_t _hash_slot;\n};", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: Klass中_bitmap和_hash_slot位于中间位置，破坏对齐，增加填充。\n\n优化后: 将不常用字段(_bitmap, _hash_slot)移到末尾，常用字段(_class_loader_data, _vtable_len)更紧凑。\n\n优化效果: 提升常用字段访问速度（减少缓存未命中），降低内存占用。\n\n优化思路: 将高频访问字段集中到对象头部，利用空间局部性。"}
{"id": 911, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "优化前：​ 在字符串比较的向量化实现中，element_compare函数使用固定的向量长度乘数（LMUL）Assembler::m2，这可能导致在某些硬件配置下（如最大向量大小较小）性能不佳。\n\n优化后：​ 引入了可配置的LMUL参数，根据字符串编码类型和硬件最大向量大小动态选择LMUL值（如对于UU编码且最大向量大小为16时使用m4，否则使用m2）。还添加了专门处理128位向量的新指令vstring_compareU_128b。\n\n优化效果：​ 通过适配硬件向量能力，提高了字符串比较操作的效率，尤其针对小字符串（参考提交中提到的字符串大小分布统计）。优化后能更好地利用RISC-V向量单元，减少指令开销，提升吞吐量。\n\n优化思路：​ 根据实际硬件特性（如向量寄存器长度）和字符串特征（如编码类型和大小），选择最优的向量化参数，以最大化指令级并行性。", "original_code": "​ 在字符串比较的向量化实现中，element_compare函数使用固定的向量长度乘数（LMUL）Assembler::m2，这可能导致在某些硬件配置下（如最大向量大小较小）性能不佳。", "optimized_code": "// 在 element_compare 函数中，LMUL 变为参数\nvoid C2_MacroAssembler::element_compare(..., Assembler::LMUL lmul) {\n    // 将固定 m2 改为动态 lmul\n    vsetvli(tmp1, cnt, sew, lmul); // 关键修改：使用参数化 LMUL\n    // ... 其余代码不变\n}\n\n// 在 string_compare_v 中，条件选择 LMUL\nif (!encLL && MaxVectorSize == 16) { // UU 且向量大小受限时\n    element_compare(..., Assembler::m4); // 使用更大 LMUL\n} else {\n    element_compare(..., Assembler::m2); // 默认 LMUL\n}\n\n// 新增指令 vstring_compareU_128b，用于 128 位向量硬件\ninstruct vstring_compareU_128b(...) {\n    predicate(UseRVV && encoding() == StrIntrinsicNode::UU && MaxVectorSize == 16);\n    // ... 使用优化后的向量比较\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/13b782c3de9a470a7cf1db9d5111ce19faf28729", "code_v0_no_empty_lines": "​ 在字符串比较的向量化实现中，element_compare函数使用固定的向量长度乘数（LMUL）Assembler::m2，这可能导致在某些硬件配置下（如最大向量大小较小）性能不佳。", "code_v1_no_empty_lines": "// 在 element_compare 函数中，LMUL 变为参数\nvoid C2_MacroAssembler::element_compare(..., Assembler::LMUL lmul) {\n    // 将固定 m2 改为动态 lmul\n    vsetvli(tmp1, cnt, sew, lmul); // 关键修改：使用参数化 LMUL\n    // ... 其余代码不变\n}\n\n// 在 string_compare_v 中，条件选择 LMUL\nif (!encLL && MaxVectorSize == 16) { // UU 且向量大小受限时\n    element_compare(..., Assembler::m4); // 使用更大 LMUL\n} else {\n    element_compare(..., Assembler::m2); // 默认 LMUL\n}\n\n// 新增指令 vstring_compareU_128b，用于 128 位向量硬件\ninstruct vstring_compareU_128b(...) {\n    predicate(UseRVV && encoding() == StrIntrinsicNode::UU && MaxVectorSize == 16);\n    // ... 使用优化后的向量比较\n}", "target": "// 在 element_compare 函数中，LMUL 变为参数\nvoid C2_MacroAssembler::element_compare(..., Assembler::LMUL lmul) {\n    // 将固定 m2 改为动态 lmul\n    vsetvli(tmp1, cnt, sew, lmul); // 关键修改：使用参数化 LMUL\n    // ... 其余代码不变\n}\n\n// 在 string_compare_v 中，条件选择 LMUL\nif (!encLL && MaxVectorSize == 16) { // UU 且向量大小受限时\n    element_compare(..., Assembler::m4); // 使用更大 LMUL\n} else {\n    element_compare(..., Assembler::m2); // 默认 LMUL\n}\n\n// 新增指令 vstring_compareU_128b，用于 128 位向量硬件\ninstruct vstring_compareU_128b(...) {\n    predicate(UseRVV && encoding() == StrIntrinsicNode::UU && MaxVectorSize == 16);\n    // ... 使用优化后的向量比较\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：​ 在字符串比较的向量化实现中，element_compare函数使用固定的向量长度乘数（LMUL）Assembler::m2，这可能导致在某些硬件配置下（如最大向量大小较小）性能不佳。\n\n优化后：​ 引入了可配置的LMUL参数，根据字符串编码类型和硬件最大向量大小动态选择LMUL值（如对于UU编码且最大向量大小为16时使用m4，否则使用m2）。还添加了专门处理128位向量的新指令vstring_compareU_128b。\n\n优化效果：​ 通过适配硬件向量能力，提高了字符串比较操作的效率，尤其针对小字符串（参考提交中提到的字符串大小分布统计）。优化后能更好地利用RISC-V向量单元，减少指令开销，提升吞吐量。\n\n优化思路：​ 根据实际硬件特性（如向量寄存器长度）和字符串特征（如编码类型和大小），选择最优的向量化参数，以最大化指令级并行性。"}
{"id": 912, "source": "riscv-dataset-excel", "optimization_type": "编译器优化和指令优化", "optimization_description": "优化前：​ encode_heap_oop方法总是包含null检查，即使在某些上下文中oop已知为非null（如类型系统指示TypePtr::NotNull），这增加了不必要的分支和指令。\n\n优化后：​ 引入了专门的encode_heap_oop_not_null方法，用于处理非null oop，并修改了指令匹配逻辑：在encodeHeapOop指令中通过谓词区分null和non-null情况，对non-null情况直接调用新方法，跳过null检查。\n\n优化效果：​ 减少了条件分支和冗余指令，提高了oop编码速度，尤其在频繁调用路径上（如垃圾收集或对象访问）能降低开销。\n\n优化思路：​ 利用类型信息（如TypePtr::NotNull）进行特化，避免已知条件下的运行时检查，简化指令流。", "original_code": "​ encode_heap_oop方法总是包含null检查，即使在某些上下文中oop已知为非null（如类型系统指示TypePtr::NotNull），这增加了不必要的分支和指令。", "optimized_code": "// 新增 encode_heap_oop_not_null 方法，跳过 null 检查\nvoid MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {\n    #ifdef ASSERT\n    // 仅调试模式下检查 null（生产环境跳过）\n    if (CheckCompressedOops) { ... }\n    #endif\n    // 直接编码操作，无 null 检查\n    if (CompressedOops::base() != nullptr) {\n        sub(dst, src, xheapbase);\n    }\n    // ... 移位操作\n}\n// 在指令定义中，通过谓词区分情况\ninstruct encodeHeapOop_not_null(iRegNNoSp dst, iRegP src) {\n    predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull); // 仅非 null 时匹配\n    match(Set dst (EncodeP src));\n    ins_encode %{\n        __ encode_heap_oop_not_null($dst$$Register, $src$$Register); // 调用优化方法\n    %}\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/5866b16dbca3f63770c8792d204dabdf49b59839", "code_v0_no_empty_lines": "​ encode_heap_oop方法总是包含null检查，即使在某些上下文中oop已知为非null（如类型系统指示TypePtr::NotNull），这增加了不必要的分支和指令。", "code_v1_no_empty_lines": "// 新增 encode_heap_oop_not_null 方法，跳过 null 检查\nvoid MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {\n    #ifdef ASSERT\n    // 仅调试模式下检查 null（生产环境跳过）\n    if (CheckCompressedOops) { ... }\n    #endif\n    // 直接编码操作，无 null 检查\n    if (CompressedOops::base() != nullptr) {\n        sub(dst, src, xheapbase);\n    }\n    // ... 移位操作\n}\n// 在指令定义中，通过谓词区分情况\ninstruct encodeHeapOop_not_null(iRegNNoSp dst, iRegP src) {\n    predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull); // 仅非 null 时匹配\n    match(Set dst (EncodeP src));\n    ins_encode %{\n        __ encode_heap_oop_not_null($dst$$Register, $src$$Register); // 调用优化方法\n    %}\n}", "target": "// 新增 encode_heap_oop_not_null 方法，跳过 null 检查\nvoid MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {\n    #ifdef ASSERT\n    // 仅调试模式下检查 null（生产环境跳过）\n    if (CheckCompressedOops) { ... }\n    #endif\n    // 直接编码操作，无 null 检查\n    if (CompressedOops::base() != nullptr) {\n        sub(dst, src, xheapbase);\n    }\n    // ... 移位操作\n}\n// 在指令定义中，通过谓词区分情况\ninstruct encodeHeapOop_not_null(iRegNNoSp dst, iRegP src) {\n    predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull); // 仅非 null 时匹配\n    match(Set dst (EncodeP src));\n    ins_encode %{\n        __ encode_heap_oop_not_null($dst$$Register, $src$$Register); // 调用优化方法\n    %}\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：​ encode_heap_oop方法总是包含null检查，即使在某些上下文中oop已知为非null（如类型系统指示TypePtr::NotNull），这增加了不必要的分支和指令。\n\n优化后：​ 引入了专门的encode_heap_oop_not_null方法，用于处理非null oop，并修改了指令匹配逻辑：在encodeHeapOop指令中通过谓词区分null和non-null情况，对non-null情况直接调用新方法，跳过null检查。\n\n优化效果：​ 减少了条件分支和冗余指令，提高了oop编码速度，尤其在频繁调用路径上（如垃圾收集或对象访问）能降低开销。\n\n优化思路：​ 利用类型信息（如TypePtr::NotNull）进行特化，避免已知条件下的运行时检查，简化指令流。"}
{"id": 913, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+内存优化", "optimization_description": "性能提升：减少存储指令数量，降低指令开销，提高内存带宽利用率。尤其受益于数组初始化、批量数据存储等场景。\n\n缓存友好：合并存储改善局部性，减少缓存未命中。\n\n功耗优化：减少指令执行数，降低CPU能耗。\n\n优化思路：利用数据访问的局部性，将多个小内存访问合并为更少的大内存访问，以最大化硬件内存子系统的效率", "original_code": "// No original code extracted from description\n", "optimized_code": "product(bool, MergeStores, true, DIAGNOSTIC, \\\n        \"Optimize stores by combining values into larger store\") \\\n\\\ndevelop(bool, TraceMergeStores, false, \\\n        \"Trace creation of merged stores\") \\\n// 在 addnode.cpp 中，将 unpack_offsets 方法改为 const\nint AddPNode::unpack_offsets(Node* elements[], int length) const { // 添加 const\n  // ... 实现不变，但更安全，便于优化分析\n}\n// 在 addnode.hpp 中，相应修改声明\nint unpack_offsets(Node* elements[], int length) const; // 添加 const", "source_url": "https://github.com/openjdk/riscv-port/commit/3ccb64c0216c72008578b904d0e7e5bba5e11134", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "product(bool, MergeStores, true, DIAGNOSTIC, \\\n        \"Optimize stores by combining values into larger store\") \\\n\\\ndevelop(bool, TraceMergeStores, false, \\\n        \"Trace creation of merged stores\") \\\n// 在 addnode.cpp 中，将 unpack_offsets 方法改为 const\nint AddPNode::unpack_offsets(Node* elements[], int length) const { // 添加 const\n  // ... 实现不变，但更安全，便于优化分析\n}\n// 在 addnode.hpp 中，相应修改声明\nint unpack_offsets(Node* elements[], int length) const; // 添加 const", "target": "product(bool, MergeStores, true, DIAGNOSTIC, \\\n        \"Optimize stores by combining values into larger store\") \\\n\\\ndevelop(bool, TraceMergeStores, false, \\\n        \"Trace creation of merged stores\") \\\n// 在 addnode.cpp 中，将 unpack_offsets 方法改为 const\nint AddPNode::unpack_offsets(Node* elements[], int length) const { // 添加 const\n  // ... 实现不变，但更安全，便于优化分析\n}\n// 在 addnode.hpp 中，相应修改声明\nint unpack_offsets(Node* elements[], int length) const; // 添加 const", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升：减少存储指令数量，降低指令开销，提高内存带宽利用率。尤其受益于数组初始化、批量数据存储等场景。\n\n缓存友好：合并存储改善局部性，减少缓存未命中。\n\n功耗优化：减少指令执行数，降低CPU能耗。\n\n优化思路：利用数据访问的局部性，将多个小内存访问合并为更少的大内存访问，以最大化硬件内存子系统的效率"}
{"id": 914, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：​ InterpreterOopMap类中的成员变量顺序为_method、_bci、_mask_size等，可能由于对齐要求产生内存填充，导致结构体大小不紧凑。\n\n优化后：​ 调整了成员变量顺序：将_bci（2字节）移动到_mask_size（4字节）之后，并将_num_oops和调试字段移动到更合理的位置。这减少了内存填充，使结构体更紧凑。\n\n优化效果：​ 降低了内存占用，可能提高缓存局部性，从而提升解释器性能（尤其在频繁访问InterpreterOopMap的场景下）。\n\n优化思路：​ 通过重新排列成员变量，使大小相似的变量相邻，减少对齐带来的空洞，优化内存访问模式。", "original_code": "​ InterpreterOopMap类中的成员变量顺序为_method、_bci、_mask_size等，可能由于对齐要求产生内存填充，导致结构体大小不紧凑。", "optimized_code": "// 成员变量顺序调整\nclass InterpreterOopMap {\n    Method* _method;        // 指针（8字节）\n    int _mask_size;         // 4字节\n    int _expression_stack_size; // 4字节\n    unsigned short _bci;    // 2字节（原在 _method 后，现后移）\n    // ... 其他字段\n#ifdef ASSERT\n    bool _resource_allocate_bit_mask; // 调试字段后移\n#endif\n    int _num_oops;          // 4字节\n};", "source_url": "https://github.com/openjdk/riscv-port/commit/fac74b118f5fda4ec297e46238d34ce5b9be1e21", "code_v0_no_empty_lines": "​ InterpreterOopMap类中的成员变量顺序为_method、_bci、_mask_size等，可能由于对齐要求产生内存填充，导致结构体大小不紧凑。", "code_v1_no_empty_lines": "// 成员变量顺序调整\nclass InterpreterOopMap {\n    Method* _method;        // 指针（8字节）\n    int _mask_size;         // 4字节\n    int _expression_stack_size; // 4字节\n    unsigned short _bci;    // 2字节（原在 _method 后，现后移）\n    // ... 其他字段\n#ifdef ASSERT\n    bool _resource_allocate_bit_mask; // 调试字段后移\n#endif\n    int _num_oops;          // 4字节\n};", "target": "// 成员变量顺序调整\nclass InterpreterOopMap {\n    Method* _method;        // 指针（8字节）\n    int _mask_size;         // 4字节\n    int _expression_stack_size; // 4字节\n    unsigned short _bci;    // 2字节（原在 _method 后，现后移）\n    // ... 其他字段\n#ifdef ASSERT\n    bool _resource_allocate_bit_mask; // 调试字段后移\n#endif\n    int _num_oops;          // 4字节\n};", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：​ InterpreterOopMap类中的成员变量顺序为_method、_bci、_mask_size等，可能由于对齐要求产生内存填充，导致结构体大小不紧凑。\n\n优化后：​ 调整了成员变量顺序：将_bci（2字节）移动到_mask_size（4字节）之后，并将_num_oops和调试字段移动到更合理的位置。这减少了内存填充，使结构体更紧凑。\n\n优化效果：​ 降低了内存占用，可能提高缓存局部性，从而提升解释器性能（尤其在频繁访问InterpreterOopMap的场景下）。\n\n优化思路：​ 通过重新排列成员变量，使大小相似的变量相邻，减少对齐带来的空洞，优化内存访问模式。"}
{"id": 915, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：​ Klass类中，_bitmap和_hash_slot等字段位于中间位置，可能破坏内存对齐，增加填充字节。\n\n优化后：​ 将这些字段移动到类末尾（在_vtable_len之后），并调整了compute_hash_slot方法的声明位置。这使常用字段（如_class_loader_data和_vtable_len）更紧凑，减少访问开销。\n\n优化效果：​ 优化了Klass对象的内存布局，可能减少缓存未命中，提升类元数据访问速度（尤其在频繁使用的vtable访问路径上）。\n\n优化思路：​ 将不常用或大小较大的字段移到末尾，使常用字段集中在对象头部，改善内存局部性。", "original_code": "​ Klass类中，_bitmap和_hash_slot等字段位于中间位置，可能破坏内存对齐，增加填充字节。", "optimized_code": "// 字段顺序调整\nclass Klass : public Metadata {\n    ClassLoaderData* _class_loader_data; // 常用字段\n    int _vtable_len;                     // 常用字段\n    JFR_ONLY(DEFINE_TRACE_ID_FIELD;)\n    // 将以下字段后移\n    uintx _bitmap;                       // 原在中间\n    uint8_t _hash_slot;                  // 原在中间\nprivate:\n    static uint8_t compute_hash_slot(Symbol* s); // 方法声明后移\n};", "source_url": "https://github.com/openjdk/riscv-port/commit/f9b4ea13e693da268c9aee27dee49f9c7f798bb1", "code_v0_no_empty_lines": "​ Klass类中，_bitmap和_hash_slot等字段位于中间位置，可能破坏内存对齐，增加填充字节。", "code_v1_no_empty_lines": "// 字段顺序调整\nclass Klass : public Metadata {\n    ClassLoaderData* _class_loader_data; // 常用字段\n    int _vtable_len;                     // 常用字段\n    JFR_ONLY(DEFINE_TRACE_ID_FIELD;)\n    // 将以下字段后移\n    uintx _bitmap;                       // 原在中间\n    uint8_t _hash_slot;                  // 原在中间\nprivate:\n    static uint8_t compute_hash_slot(Symbol* s); // 方法声明后移\n};", "target": "// 字段顺序调整\nclass Klass : public Metadata {\n    ClassLoaderData* _class_loader_data; // 常用字段\n    int _vtable_len;                     // 常用字段\n    JFR_ONLY(DEFINE_TRACE_ID_FIELD;)\n    // 将以下字段后移\n    uintx _bitmap;                       // 原在中间\n    uint8_t _hash_slot;                  // 原在中间\nprivate:\n    static uint8_t compute_hash_slot(Symbol* s); // 方法声明后移\n};", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：​ Klass类中，_bitmap和_hash_slot等字段位于中间位置，可能破坏内存对齐，增加填充字节。\n\n优化后：​ 将这些字段移动到类末尾（在_vtable_len之后），并调整了compute_hash_slot方法的声明位置。这使常用字段（如_class_loader_data和_vtable_len）更紧凑，减少访问开销。\n\n优化效果：​ 优化了Klass对象的内存布局，可能减少缓存未命中，提升类元数据访问速度（尤其在频繁使用的vtable访问路径上）。\n\n优化思路：​ 将不常用或大小较大的字段移到末尾，使常用字段集中在对象头部，改善内存局部性。"}
{"id": 916, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+编译器优化", "optimization_description": "优化前：CRC32计算可能通过纯软件实现（如查表法），效率较低，因为需要多次内存访问和逻辑操作。\n\n优化后：使用RISC-V专用指令或内在函数，直接调用硬件加速的CRC32操作，减少了指令数和内存访问，提升了计算速度。\n\n优化效果：CRC32计算性能显著提升，尤其适用于大量数据校验场景（如网络通信或文件处理）。优化思路是通过硬件内在函数将计算任务卸载到CPU专用电路，减少软件开销。", "original_code": "CRC32计算可能通过纯软件实现（如查表法），效率较低，因为需要多次内存访问和逻辑操作。", "optimized_code": "void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {\n  assert_different_registers(crc, val, table);\n  xorr(val, val, crc);\n  andi(val, val, right_8_bits);\n  shadd(val, val, table, val, 2);\n  lwu(val, Address(val));\n  srli(crc, crc, 8);\n  xorr(crc, val, crc);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/2f4f6cc34c10c5519c74abbce8d1715013b50d5d", "code_v0_no_empty_lines": "CRC32计算可能通过纯软件实现（如查表法），效率较低，因为需要多次内存访问和逻辑操作。", "code_v1_no_empty_lines": "void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {\n  assert_different_registers(crc, val, table);\n  xorr(val, val, crc);\n  andi(val, val, right_8_bits);\n  shadd(val, val, table, val, 2);\n  lwu(val, Address(val));\n  srli(crc, crc, 8);\n  xorr(crc, val, crc);\n}", "target": "void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {\n  assert_different_registers(crc, val, table);\n  xorr(val, val, crc);\n  andi(val, val, right_8_bits);\n  shadd(val, val, table, val, 2);\n  lwu(val, Address(val));\n  srli(crc, crc, 8);\n  xorr(crc, val, crc);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：CRC32计算可能通过纯软件实现（如查表法），效率较低，因为需要多次内存访问和逻辑操作。\n\n优化后：使用RISC-V专用指令或内在函数，直接调用硬件加速的CRC32操作，减少了指令数和内存访问，提升了计算速度。\n\n优化效果：CRC32计算性能显著提升，尤其适用于大量数据校验场景（如网络通信或文件处理）。优化思路是通过硬件内在函数将计算任务卸载到CPU专用电路，减少软件开销。"}
{"id": 917, "source": "riscv-dataset-excel", "optimization_type": "条件分支优化", "optimization_description": "减少了分支预测错误的风险，提高了代码在流水线中的执行效率，尤其适用于频繁调用的点（如类型转换）。优化思路是通过硬件指令或无分支数学技巧消除条件分支。", "original_code": "// No original code extracted from description\n", "optimized_code": "优化前：代码使用条件分支指令（如beq）来检查值是否非零，然后设置1或0。这可能导致分支预测错误，引入流水线停顿。\n\n示例旧代码：\n\nneg(R0, result);\norr(result, result, R0);\nsrdi(result, result, 63);\n\n优化后：使用PowerPC64的setbcr指令（Power10引入）或无分支算术操作，直接根据条件码设置值，避免了分支。\n\n示例新代码：添加了normalize_bool函数，统一处理逻辑：\n\ninline void MacroAssembler::normalize_bool(Register dst, Register temp, bool is_64bit) {\n  if (VM_Version::has_brw()) { // 检查Power10支持\n    if (is_64bit) {\n      cmpdi(CCR0, dst, 0);\n    } else {\n      cmpwi(CCR0, dst, 0);\n    }\n    setbcr(dst, CCR0, Assembler::equal); // 使用setbcr指令\n  } else {\n    // 回退到无分支算术操作\n    neg(temp, dst);\n    orr(temp, dst, temp);\n    if (is_64bit) {\n      srdi(dst, temp, 63);\n    } else {\n      srwi(dst, temp, 31);\n    }\n  }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/c7e9ebb4cfff56b7a977eb2942f563f96b3336bd", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "优化前：代码使用条件分支指令（如beq）来检查值是否非零，然后设置1或0。这可能导致分支预测错误，引入流水线停顿。\n\n示例旧代码：\n\nneg(R0, result);\norr(result, result, R0);\nsrdi(result, result, 63);\n\n优化后：使用PowerPC64的setbcr指令（Power10引入）或无分支算术操作，直接根据条件码设置值，避免了分支。\n\n示例新代码：添加了normalize_bool函数，统一处理逻辑：\n\ninline void MacroAssembler::normalize_bool(Register dst, Register temp, bool is_64bit) {\n  if (VM_Version::has_brw()) { // 检查Power10支持\n    if (is_64bit) {\n      cmpdi(CCR0, dst, 0);\n    } else {\n      cmpwi(CCR0, dst, 0);\n    }\n    setbcr(dst, CCR0, Assembler::equal); // 使用setbcr指令\n  } else {\n    // 回退到无分支算术操作\n    neg(temp, dst);\n    orr(temp, dst, temp);\n    if (is_64bit) {\n      srdi(dst, temp, 63);\n    } else {\n      srwi(dst, temp, 31);\n    }\n  }\n}", "target": "优化前：代码使用条件分支指令（如beq）来检查值是否非零，然后设置1或0。这可能导致分支预测错误，引入流水线停顿。\n\n示例旧代码：\n\nneg(R0, result);\norr(result, result, R0);\nsrdi(result, result, 63);\n\n优化后：使用PowerPC64的setbcr指令（Power10引入）或无分支算术操作，直接根据条件码设置值，避免了分支。\n\n示例新代码：添加了normalize_bool函数，统一处理逻辑：\n\ninline void MacroAssembler::normalize_bool(Register dst, Register temp, bool is_64bit) {\n  if (VM_Version::has_brw()) { // 检查Power10支持\n    if (is_64bit) {\n      cmpdi(CCR0, dst, 0);\n    } else {\n      cmpwi(CCR0, dst, 0);\n    }\n    setbcr(dst, CCR0, Assembler::equal); // 使用setbcr指令\n  } else {\n    // 回退到无分支算术操作\n    neg(temp, dst);\n    orr(temp, dst, temp);\n    if (is_64bit) {\n      srdi(dst, temp, 63);\n    } else {\n      srwi(dst, temp, 31);\n    }\n  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "减少了分支预测错误的风险，提高了代码在流水线中的执行效率，尤其适用于频繁调用的点（如类型转换）。优化思路是通过硬件指令或无分支数学技巧消除条件分支。"}
{"id": 918, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "利用编译时信息进行表达式简化：当检测到min/max操作的两个输入相同（指向同一节点），结果必为输入本身，无需运行时比较。\n\n遵循编译器优化的\"常见情况优化\"原则：虽然输入相同的情况不总是发生，但优化后无负面影响，且能提升特定场景性能。\n\n通过C2的Identity方法实现：该方法在编译器GVN（全局值编号）阶段被调用，用于简化表达式。", "original_code": "// No original code extracted from description\n", "optimized_code": "Node* MaxNode::Identity(PhaseGVN* phase) {\n  if (in(1) == in(2)) {    // 检查两个输入是否相同节点\n    return in(1);          // 直接返回输入，避免max操作\n  }\n  return AddNode::Identity(phase);\n}\nvirtual Node* Identity(PhaseGVN* phase);", "source_url": "https://github.com/openjdk/riscv-port/commit/c439c8c73cf07966e3517ecbaf14d79dcbaeabb3", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "Node* MaxNode::Identity(PhaseGVN* phase) {\n  if (in(1) == in(2)) {    // 检查两个输入是否相同节点\n    return in(1);          // 直接返回输入，避免max操作\n  }\n  return AddNode::Identity(phase);\n}\nvirtual Node* Identity(PhaseGVN* phase);", "target": "Node* MaxNode::Identity(PhaseGVN* phase) {\n  if (in(1) == in(2)) {    // 检查两个输入是否相同节点\n    return in(1);          // 直接返回输入，避免max操作\n  }\n  return AddNode::Identity(phase);\n}\nvirtual Node* Identity(PhaseGVN* phase);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "利用编译时信息进行表达式简化：当检测到min/max操作的两个输入相同（指向同一节点），结果必为输入本身，无需运行时比较。\n\n遵循编译器优化的\"常见情况优化\"原则：虽然输入相同的情况不总是发生，但优化后无负面影响，且能提升特定场景性能。\n\n通过C2的Identity方法实现：该方法在编译器GVN（全局值编号）阶段被调用，用于简化表达式。"}
{"id": 919, "source": "riscv-dataset-excel", "optimization_type": "并发优化", "optimization_description": "优化前: 在ShenandoahConcurrentGC.cpp和ShenandoahControlThread.cpp中，每次调用heap->free_set()->log_status()时，都会先获取堆锁（通过ShenandoahHeapLocker），即使日志功能被禁用。这会导致不必要的锁获取开销，尤其是在高并发场景下。\n\n优化后: 引入了log_status_under_lock()方法，该方法先检查日志是否启用（通过LogTarget::is_enabled()）。只有当日志启用时，才获取锁并调用log_status()；否则，直接跳过。这避免了在日志禁用时的锁操作。\n\n优化效果: 减少了不必要的锁竞争和开销，提高了GC线程的性能，尤其是在日志禁用时（生产环境中日志通常禁用）。这有助于降低停顿时间，提升整体吞吐量。\n\n优化思路: 通过条件检查避免冗余操作，将锁获取延迟到真正需要时。这是一种常见的“惰性”优化策略，适用于高频调用的代码路径。", "original_code": "// No original code extracted from description\n", "optimized_code": "public:\n  void log_status_under_lock(); // 新增方法\nvoid ShenandoahFreeSet::log_status_under_lock() {\n  shenandoah_assert_not_heaplocked();\n  if (LogTarget(Info, gc, free)::is_enabled()\n      DEBUG_ONLY(|| LogTarget(Debug, gc, free)::is_enabled())) {\n    ShenandoahHeapLocker locker(_heap->lock()); // 只有日志启用时获取锁\n    log_status();\n  }\n}\n// 优化前:\n// ShenandoahHeapLocker locker(heap->lock());\n// heap->free_set()->log_status();\n\n// 优化后:\nheap->free_set()->log_status_under_lock(); // 直接调用新方法", "source_url": "https://github.com/openjdk/riscv-port/commit/c47a0e005e54551e42ee1ae33d7169417a5f86d4", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "public:\n  void log_status_under_lock(); // 新增方法\nvoid ShenandoahFreeSet::log_status_under_lock() {\n  shenandoah_assert_not_heaplocked();\n  if (LogTarget(Info, gc, free)::is_enabled()\n      DEBUG_ONLY(|| LogTarget(Debug, gc, free)::is_enabled())) {\n    ShenandoahHeapLocker locker(_heap->lock()); // 只有日志启用时获取锁\n    log_status();\n  }\n}\n// 优化前:\n// ShenandoahHeapLocker locker(heap->lock());\n// heap->free_set()->log_status();\n\n// 优化后:\nheap->free_set()->log_status_under_lock(); // 直接调用新方法", "target": "public:\n  void log_status_under_lock(); // 新增方法\nvoid ShenandoahFreeSet::log_status_under_lock() {\n  shenandoah_assert_not_heaplocked();\n  if (LogTarget(Info, gc, free)::is_enabled()\n      DEBUG_ONLY(|| LogTarget(Debug, gc, free)::is_enabled())) {\n    ShenandoahHeapLocker locker(_heap->lock()); // 只有日志启用时获取锁\n    log_status();\n  }\n}\n// 优化前:\n// ShenandoahHeapLocker locker(heap->lock());\n// heap->free_set()->log_status();\n\n// 优化后:\nheap->free_set()->log_status_under_lock(); // 直接调用新方法", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: 在ShenandoahConcurrentGC.cpp和ShenandoahControlThread.cpp中，每次调用heap->free_set()->log_status()时，都会先获取堆锁（通过ShenandoahHeapLocker），即使日志功能被禁用。这会导致不必要的锁获取开销，尤其是在高并发场景下。\n\n优化后: 引入了log_status_under_lock()方法，该方法先检查日志是否启用（通过LogTarget::is_enabled()）。只有当日志启用时，才获取锁并调用log_status()；否则，直接跳过。这避免了在日志禁用时的锁操作。\n\n优化效果: 减少了不必要的锁竞争和开销，提高了GC线程的性能，尤其是在日志禁用时（生产环境中日志通常禁用）。这有助于降低停顿时间，提升整体吞吐量。\n\n优化思路: 通过条件检查避免冗余操作，将锁获取延迟到真正需要时。这是一种常见的“惰性”优化策略，适用于高频调用的代码路径。"}
{"id": 920, "source": "riscv-dataset-excel", "optimization_type": "并发优化", "optimization_description": "性能提升：StoreStore屏障比Release屏障的开销更小，因为它的约束更弱。在支持弱内存模型的架构上（如ARM、RISC-V），这种优化能显著减少内存屏障指令的数量和强度。\n\n减少指令开销：存储-存储屏障通常比释放屏障需要更少的CPU周期和更少的内存同步操作。\n\n改善指令级并行：较弱的内存屏障允许更多的指令重排，提高CPU执行效率。", "original_code": "// No original code extracted from description\n", "optimized_code": "1.// 优化前：\n_exits.insert_mem_bar(Op_MemBarRelease, alloc_with_final());\n\n// 优化后：\n_exits.insert_mem_bar(UseStoreStoreForCtor ? Op_MemBarStoreStore : Op_MemBarRelease,\n                     alloc_with_final());\n2.// 优化前：\n_mem_bar(Op_MemBarRelease, result);\n\n// 优化后：\nkit.insert_mem_bar(UseStoreStoreForCtor ? Op_MemBarStoreStore : Op_MemBarRelease, result);", "source_url": "https://github.com/openjdk/riscv-port/commit/1d06170758bd76a0ea32e5bb7d4a017e829ae710", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1.// 优化前：\n_exits.insert_mem_bar(Op_MemBarRelease, alloc_with_final());\n\n// 优化后：\n_exits.insert_mem_bar(UseStoreStoreForCtor ? Op_MemBarStoreStore : Op_MemBarRelease,\n                     alloc_with_final());\n2.// 优化前：\n_mem_bar(Op_MemBarRelease, result);\n\n// 优化后：\nkit.insert_mem_bar(UseStoreStoreForCtor ? Op_MemBarStoreStore : Op_MemBarRelease, result);", "target": "1.// 优化前：\n_exits.insert_mem_bar(Op_MemBarRelease, alloc_with_final());\n\n// 优化后：\n_exits.insert_mem_bar(UseStoreStoreForCtor ? Op_MemBarStoreStore : Op_MemBarRelease,\n                     alloc_with_final());\n2.// 优化前：\n_mem_bar(Op_MemBarRelease, result);\n\n// 优化后：\nkit.insert_mem_bar(UseStoreStoreForCtor ? Op_MemBarStoreStore : Op_MemBarRelease, result);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升：StoreStore屏障比Release屏障的开销更小，因为它的约束更弱。在支持弱内存模型的架构上（如ARM、RISC-V），这种优化能显著减少内存屏障指令的数量和强度。\n\n减少指令开销：存储-存储屏障通常比释放屏障需要更少的CPU周期和更少的内存同步操作。\n\n改善指令级并行：较弱的内存屏障允许更多的指令重排，提高CPU执行效率。"}
{"id": 921, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "内存节省：每个 DefNewGeneration和 TenuredGeneration实例减少了一个指针大小的内存占用（通常8字节）。在JVM中，这些实例是长期存在的，因此累计内存节省可能显著，尤其是在内存受限的环境中。\n\n缓存局部性改善：更小的对象大小可能提高CPU缓存命中率，因为更多对象可以放入缓存行中，从而潜在提升访问速度。\n\n代码维护性：移除死代码使代码更清晰，减少维护负担。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 文件: src/hotspot/share/gc/serial/defNewGeneration.hpp\n// 优化前（移除的代码）：\n- // Saved mark word, for to-space\n- HeapWord* _saved_mark_word;", "source_url": "https://github.com/openjdk/riscv-port/commit/c9f8d0eff706d9ac59179afbb821367da09c9aae", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 文件: src/hotspot/share/gc/serial/defNewGeneration.hpp\n// 优化前（移除的代码）：\n- // Saved mark word, for to-space\n- HeapWord* _saved_mark_word;", "target": "// 文件: src/hotspot/share/gc/serial/defNewGeneration.hpp\n// 优化前（移除的代码）：\n- // Saved mark word, for to-space\n- HeapWord* _saved_mark_word;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "内存节省：每个 DefNewGeneration和 TenuredGeneration实例减少了一个指针大小的内存占用（通常8字节）。在JVM中，这些实例是长期存在的，因此累计内存节省可能显著，尤其是在内存受限的环境中。\n\n缓存局部性改善：更小的对象大小可能提高CPU缓存命中率，因为更多对象可以放入缓存行中，从而潜在提升访问速度。\n\n代码维护性：移除死代码使代码更清晰，减少维护负担。"}
{"id": 922, "source": "riscv-dataset-excel", "optimization_type": "并发优化", "optimization_description": "优化前: 在s390x架构上，锁机制主要基于传统的重量级锁（LM_LEGACY模式）。在加锁和解锁时，需要执行完整的锁操作，包括保存和恢复对象头，这涉及内存访问和潜在竞争，开销较大。\n\n优化后: 引入了轻量级锁（LM_LIGHTWEIGHT模式）的支持。轻量级锁通过锁栈（lock stack）和CAS操作实现快速路径，避免了重量级锁的膨胀。在加锁和解锁时，先尝试轻量级路径，仅在竞争时退回到慢路径。\n\n优化效果: 减少了锁操作的开销，提高了单线程和多线程环境下的同步性能。轻量级锁减少了内存屏障和系统调用，特别适用于无竞争或低竞争场景，从而提升应用程序的响应速度和吞吐量。\n\n优化思路: 利用锁的局部性原理，通过线程本地的锁栈管理锁状态，避免直接操作共享对象头。这减少了全局内存访问，优化了常见情况（无竞争）下的性能。", "original_code": "// No original code extracted from description\n", "optimized_code": "1.// 优化前: 直接加载对象头并执行重量级锁逻辑\n// z_lg(Rmark, Address(Roop, hdr_offset)); // 加载对象头\n// ... 重量级锁代码\n\n// 优化后: 添加轻量级锁分支\nif (LockingMode == LM_LIGHTWEIGHT) {\n  lightweight_lock(Roop, Rmark, tmp, slow_case); // 轻量级锁快速路径\n} else if (LockingMode == LM_LEGACY) {\n  z_lg(Rmark, Address(Roop, hdr_offset)); // 仅重量级锁时加载对象头\n  ... // 原有重量级锁逻辑\n}\n2.void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register temp1, Register temp2) {\n  compiler_fast_lock_lightweight_object(obj, temp1, temp2); // 调用编译器优化的轻量级锁\n}\n3.// 优化后: 直接调用轻量级解锁\nif (LockingMode == LM_LIGHTWEIGHT) {\n  lightweight_unlock(object, header, current_header, slow_case);\n} else {\n  ... // 重量级锁逻辑\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/d457609f700bbb1fed233f1a04501c995852e5ac", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1.// 优化前: 直接加载对象头并执行重量级锁逻辑\n// z_lg(Rmark, Address(Roop, hdr_offset)); // 加载对象头\n// ... 重量级锁代码\n\n// 优化后: 添加轻量级锁分支\nif (LockingMode == LM_LIGHTWEIGHT) {\n  lightweight_lock(Roop, Rmark, tmp, slow_case); // 轻量级锁快速路径\n} else if (LockingMode == LM_LEGACY) {\n  z_lg(Rmark, Address(Roop, hdr_offset)); // 仅重量级锁时加载对象头\n  ... // 原有重量级锁逻辑\n}\n2.void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register temp1, Register temp2) {\n  compiler_fast_lock_lightweight_object(obj, temp1, temp2); // 调用编译器优化的轻量级锁\n}\n3.// 优化后: 直接调用轻量级解锁\nif (LockingMode == LM_LIGHTWEIGHT) {\n  lightweight_unlock(object, header, current_header, slow_case);\n} else {\n  ... // 重量级锁逻辑\n}", "target": "1.// 优化前: 直接加载对象头并执行重量级锁逻辑\n// z_lg(Rmark, Address(Roop, hdr_offset)); // 加载对象头\n// ... 重量级锁代码\n\n// 优化后: 添加轻量级锁分支\nif (LockingMode == LM_LIGHTWEIGHT) {\n  lightweight_lock(Roop, Rmark, tmp, slow_case); // 轻量级锁快速路径\n} else if (LockingMode == LM_LEGACY) {\n  z_lg(Rmark, Address(Roop, hdr_offset)); // 仅重量级锁时加载对象头\n  ... // 原有重量级锁逻辑\n}\n2.void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register temp1, Register temp2) {\n  compiler_fast_lock_lightweight_object(obj, temp1, temp2); // 调用编译器优化的轻量级锁\n}\n3.// 优化后: 直接调用轻量级解锁\nif (LockingMode == LM_LIGHTWEIGHT) {\n  lightweight_unlock(object, header, current_header, slow_case);\n} else {\n  ... // 重量级锁逻辑\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: 在s390x架构上，锁机制主要基于传统的重量级锁（LM_LEGACY模式）。在加锁和解锁时，需要执行完整的锁操作，包括保存和恢复对象头，这涉及内存访问和潜在竞争，开销较大。\n\n优化后: 引入了轻量级锁（LM_LIGHTWEIGHT模式）的支持。轻量级锁通过锁栈（lock stack）和CAS操作实现快速路径，避免了重量级锁的膨胀。在加锁和解锁时，先尝试轻量级路径，仅在竞争时退回到慢路径。\n\n优化效果: 减少了锁操作的开销，提高了单线程和多线程环境下的同步性能。轻量级锁减少了内存屏障和系统调用，特别适用于无竞争或低竞争场景，从而提升应用程序的响应速度和吞吐量。\n\n优化思路: 利用锁的局部性原理，通过线程本地的锁栈管理锁状态，避免直接操作共享对象头。这减少了全局内存访问，优化了常见情况（无竞争）下的性能。"}
{"id": "923（java）", "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "减少对象分配：通过直接使用预分配的 FloatToDecimal实例（如 LATIN1或 UTF16），避免了在每次调用时创建新对象。putDecimal方法直接操作现有数组，减少了临时对象分配。\n\n避免异常处理：移除了 try-catch块，因为 putDecimal方法不抛出 IOException，降低了控制流开销。\n\n预检查容量：调用 ensureCapacityInternal确保数组有足够空间，避免了在追加过程中频繁扩容。", "original_code": "// No original code extracted from description\n", "optimized_code": "修改前（行号887-892）：\n\n\npublic AbstractStringBuilder append(float f) {\n    try {\n        FloatToDecimal.appendTo(f, this);\n    } catch (IOException e) {\n        throw new AssertionError(e);\n    }\n    return this;\n}\n\n修改后（行号888-890）：\n\n\npublic AbstractStringBuilder append(float f) {\n    ensureCapacityInternal(count + FloatToDecimal.MAX_CHARS);\n    FloatToDecimal toDecimal = isLatin1() ? FloatToDecimal.LATIN1 : FloatToDecimal.UTF16;\n    count = toDecimal.putDecimal(value, count, f);\n    return this;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/9d20b58f40275002afa0348d94d5592a26894e88", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "修改前（行号887-892）：\n\n\npublic AbstractStringBuilder append(float f) {\n    try {\n        FloatToDecimal.appendTo(f, this);\n    } catch (IOException e) {\n        throw new AssertionError(e);\n    }\n    return this;\n}\n\n修改后（行号888-890）：\n\n\npublic AbstractStringBuilder append(float f) {\n    ensureCapacityInternal(count + FloatToDecimal.MAX_CHARS);\n    FloatToDecimal toDecimal = isLatin1() ? FloatToDecimal.LATIN1 : FloatToDecimal.UTF16;\n    count = toDecimal.putDecimal(value, count, f);\n    return this;\n}", "target": "修改前（行号887-892）：\n\n\npublic AbstractStringBuilder append(float f) {\n    try {\n        FloatToDecimal.appendTo(f, this);\n    } catch (IOException e) {\n        throw new AssertionError(e);\n    }\n    return this;\n}\n\n修改后（行号888-890）：\n\n\npublic AbstractStringBuilder append(float f) {\n    ensureCapacityInternal(count + FloatToDecimal.MAX_CHARS);\n    FloatToDecimal toDecimal = isLatin1() ? FloatToDecimal.LATIN1 : FloatToDecimal.UTF16;\n    count = toDecimal.putDecimal(value, count, f);\n    return this;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "减少对象分配：通过直接使用预分配的 FloatToDecimal实例（如 LATIN1或 UTF16），避免了在每次调用时创建新对象。putDecimal方法直接操作现有数组，减少了临时对象分配。\n\n避免异常处理：移除了 try-catch块，因为 putDecimal方法不抛出 IOException，降低了控制流开销。\n\n预检查容量：调用 ensureCapacityInternal确保数组有足够空间，避免了在追加过程中频繁扩容。"}
{"id": 924, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前实现：\n\nPcDesc缓存（PcDescContainer）直接作为nmethod类的成员变量（嵌入在nmethod头中）。\n\n缓存通过reset_to方法初始化，在nmethod构造函数中直接调用。\n\n查找PcDesc时，缓存操作可能涉及线程安全锁（如MACOS_AARCH64_ONLY的ThreadWXEnable），尤其是在信号处理路径中。\n\nnmethod头大小较大，因为包含了完整的缓存结构。\n\n优化后实现：\n\nPcDesc缓存改为指针引用（PcDescContainer* _pc_desc_container），在nmethod构造函数中动态分配（使用new）。\n\n缓存初始化改为init_to方法，逻辑更清晰。\n\n在nmethod销毁时（purge方法），主动释放缓存内存。\n\n移除了多处不必要的锁操作（如信号处理和相关运行时路径中的ThreadWXEnable），因为缓存管理不再需要写锁。\n\n查找PcDesc的逻辑被重构，直接传递代码范围参数，而不是通过PcDescSearch辅助类。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 优化前:\nPcDescContainer _pc_desc_container; // 直接成员\n\n// 优化后:\nPcDescContainer* _pc_desc_container; // 指针\n// 优化后: 在nmethod构造函数中\n_pc_desc_container = new PcDescContainer(scopes_pcs_begin()); // 动态分配\n\n// 优化后: 在purge方法中\nif (_pc_desc_container != nullptr) {\n    delete _pc_desc_container;\n}\n// 优化前: PcDescCache::reset_to\nvoid PcDescCache::reset_to(PcDesc* initial_pc_desc) {\n    if (initial_pc_desc == nullptr) {\n        _pc_descs[0] = nullptr; // 处理原生方法\n        return;\n    }\n    // ... 重置缓存\n}\n\n// 优化后: PcDescCache::init_to\nvoid PcDescCache::init_to(PcDesc* initial_pc_desc) {\n    assert(initial_pc_desc != nullptr, \"必须使用哨兵\");\n    // ... 直接初始化缓存\n}\n// 优化前: 使用PcDescSearch辅助类\nPcDesc* find_pc_desc_internal(address pc, bool approximate, const PcDescSearch& search);\n\n// 优化后: 直接传递代码范围\nPcDesc* find_pc_desc_internal(address pc, bool approximate, address code_begin, PcDesc* lower, PcDesc* upper);", "source_url": "https://github.com/openjdk/riscv-port/commit/b3bcc49491b8f8ad337eb4c06201a5468e5c1159", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 优化前:\nPcDescContainer _pc_desc_container; // 直接成员\n\n// 优化后:\nPcDescContainer* _pc_desc_container; // 指针\n// 优化后: 在nmethod构造函数中\n_pc_desc_container = new PcDescContainer(scopes_pcs_begin()); // 动态分配\n\n// 优化后: 在purge方法中\nif (_pc_desc_container != nullptr) {\n    delete _pc_desc_container;\n}\n// 优化前: PcDescCache::reset_to\nvoid PcDescCache::reset_to(PcDesc* initial_pc_desc) {\n    if (initial_pc_desc == nullptr) {\n        _pc_descs[0] = nullptr; // 处理原生方法\n        return;\n    }\n    // ... 重置缓存\n}\n\n// 优化后: PcDescCache::init_to\nvoid PcDescCache::init_to(PcDesc* initial_pc_desc) {\n    assert(initial_pc_desc != nullptr, \"必须使用哨兵\");\n    // ... 直接初始化缓存\n}\n// 优化前: 使用PcDescSearch辅助类\nPcDesc* find_pc_desc_internal(address pc, bool approximate, const PcDescSearch& search);\n\n// 优化后: 直接传递代码范围\nPcDesc* find_pc_desc_internal(address pc, bool approximate, address code_begin, PcDesc* lower, PcDesc* upper);", "target": "// 优化前:\nPcDescContainer _pc_desc_container; // 直接成员\n\n// 优化后:\nPcDescContainer* _pc_desc_container; // 指针\n// 优化后: 在nmethod构造函数中\n_pc_desc_container = new PcDescContainer(scopes_pcs_begin()); // 动态分配\n\n// 优化后: 在purge方法中\nif (_pc_desc_container != nullptr) {\n    delete _pc_desc_container;\n}\n// 优化前: PcDescCache::reset_to\nvoid PcDescCache::reset_to(PcDesc* initial_pc_desc) {\n    if (initial_pc_desc == nullptr) {\n        _pc_descs[0] = nullptr; // 处理原生方法\n        return;\n    }\n    // ... 重置缓存\n}\n\n// 优化后: PcDescCache::init_to\nvoid PcDescCache::init_to(PcDesc* initial_pc_desc) {\n    assert(initial_pc_desc != nullptr, \"必须使用哨兵\");\n    // ... 直接初始化缓存\n}\n// 优化前: 使用PcDescSearch辅助类\nPcDesc* find_pc_desc_internal(address pc, bool approximate, const PcDescSearch& search);\n\n// 优化后: 直接传递代码范围\nPcDesc* find_pc_desc_internal(address pc, bool approximate, address code_begin, PcDesc* lower, PcDesc* upper);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前实现：\n\nPcDesc缓存（PcDescContainer）直接作为nmethod类的成员变量（嵌入在nmethod头中）。\n\n缓存通过reset_to方法初始化，在nmethod构造函数中直接调用。\n\n查找PcDesc时，缓存操作可能涉及线程安全锁（如MACOS_AARCH64_ONLY的ThreadWXEnable），尤其是在信号处理路径中。\n\nnmethod头大小较大，因为包含了完整的缓存结构。\n\n优化后实现：\n\nPcDesc缓存改为指针引用（PcDescContainer* _pc_desc_container），在nmethod构造函数中动态分配（使用new）。\n\n缓存初始化改为init_to方法，逻辑更清晰。\n\n在nmethod销毁时（purge方法），主动释放缓存内存。\n\n移除了多处不必要的锁操作（如信号处理和相关运行时路径中的ThreadWXEnable），因为缓存管理不再需要写锁。\n\n查找PcDesc的逻辑被重构，直接传递代码范围参数，而不是通过PcDescSearch辅助类。"}
{"id": 925, "source": "riscv-dataset-excel", "optimization_type": "内存优化+ 编译器优化", "optimization_description": "优化前：\n\nOopMapCache类使用动态分配的数组：\n\n在构造函数中使用NEW_C_HEAP_ARRAY在堆上分配数组内存\n\n在析构函数中使用FREE_C_HEAP_ARRAY释放数组内存\n\n数组大小通过枚举常量_size和_probe_depth定义\n\n需要额外的指针间接访问数组元素\n\n优化后：\n\n使用内联固定大小数组：\n\n数组直接作为类的成员变量：OopMapCacheEntry* volatile _array[size]\n\n无需动态内存分配和释放\n\n使用static constexpr常量size和probe_depth替代枚举\n\n直接数组访问，减少指针间接寻址\n\n优化效果\n\n减少内存分配开销：消除堆分配和释放操作，降低内存管理成本\n\n改善缓存局部性：数组与对象实例在内存中连续分布，提高CPU缓存命中率\n\n减少内存访问延迟：直接数组访问比通过指针的间接访问更快\n\n简化内存管理：移除动态内存管理代码，降低复杂性和错误风险\n\n提升访问速度：数组大小在编译时确定，编译器可以生成更优化的代码", "original_code": "OopMapCache类使用动态分配的数组：\n\n在构造函数中使用NEW_C_HEAP_ARRAY在堆上分配数组内存\n\n在析构函数中使用FREE_C_HEAP_ARRAY释放数组内存\n\n数组大小通过枚举常量_size和_probe_depth定义\n\n需要额外的指针间接访问数组元素", "optimized_code": "// 优化前：\nenum { _size = 32, _probe_depth = 3 };\nOopMapCacheEntry* volatile * _array;  // 动态数组指针\n\n// 优化后：\nstatic constexpr int size = 32;       // 编译时常量\nstatic constexpr int probe_depth = 3;\nOopMapCacheEntry* volatile _array[size];  // 内联数组\n// 优化前：\nOopMapCache::OopMapCache() {\n    _array = NEW_C_HEAP_ARRAY(OopMapCacheEntry*, _size, mtClass);\n    for(int i = 0; i < _size; i++) _array[i] = nullptr;\n}\n\n// 优化后：\nOopMapCache::OopMapCache() {\n    for(int i = 0; i < size; i++) _array[i] = nullptr;  // 直接初始化\n}\n// 优化前：\nOopMapCache::~OopMapCache() {\n    assert(_array != nullptr, \"sanity check\");\n    flush();\n    FREE_C_HEAP_ARRAY(OopMapCacheEntry*, _array);  // 需要显式释放\n}\n\n// 优化后：\nOopMapCache::~OopMapCache() {\n    flush();  // 只需刷新内容，数组自动销毁\n}\n// 所有数组访问从动态大小改为固定大小：\nOopMapCacheEntry* OopMapCache::entry_at(int i) const {\n-    return Atomic::load_acquire(&(_array[i % _size]));\n+    return Atomic::load_acquire(&(_array[i % size]));  // 使用内联数组\n}\n\nvoid OopMapCache::flush() {\n-    for(int i = 0; i < _size; i++) {  // 动态大小\n+    for(int i = 0; i < size; i++) {   // 固定大小\n        // ...\n    }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/50dd962b0d0fe36634d96dbbd9d94fbc34d9ff7f", "code_v0_no_empty_lines": "OopMapCache类使用动态分配的数组：\n\n在构造函数中使用NEW_C_HEAP_ARRAY在堆上分配数组内存\n\n在析构函数中使用FREE_C_HEAP_ARRAY释放数组内存\n\n数组大小通过枚举常量_size和_probe_depth定义\n\n需要额外的指针间接访问数组元素", "code_v1_no_empty_lines": "// 优化前：\nenum { _size = 32, _probe_depth = 3 };\nOopMapCacheEntry* volatile * _array;  // 动态数组指针\n\n// 优化后：\nstatic constexpr int size = 32;       // 编译时常量\nstatic constexpr int probe_depth = 3;\nOopMapCacheEntry* volatile _array[size];  // 内联数组\n// 优化前：\nOopMapCache::OopMapCache() {\n    _array = NEW_C_HEAP_ARRAY(OopMapCacheEntry*, _size, mtClass);\n    for(int i = 0; i < _size; i++) _array[i] = nullptr;\n}\n\n// 优化后：\nOopMapCache::OopMapCache() {\n    for(int i = 0; i < size; i++) _array[i] = nullptr;  // 直接初始化\n}\n// 优化前：\nOopMapCache::~OopMapCache() {\n    assert(_array != nullptr, \"sanity check\");\n    flush();\n    FREE_C_HEAP_ARRAY(OopMapCacheEntry*, _array);  // 需要显式释放\n}\n\n// 优化后：\nOopMapCache::~OopMapCache() {\n    flush();  // 只需刷新内容，数组自动销毁\n}\n// 所有数组访问从动态大小改为固定大小：\nOopMapCacheEntry* OopMapCache::entry_at(int i) const {\n-    return Atomic::load_acquire(&(_array[i % _size]));\n+    return Atomic::load_acquire(&(_array[i % size]));  // 使用内联数组\n}\n\nvoid OopMapCache::flush() {\n-    for(int i = 0; i < _size; i++) {  // 动态大小\n+    for(int i = 0; i < size; i++) {   // 固定大小\n        // ...\n    }\n}", "target": "// 优化前：\nenum { _size = 32, _probe_depth = 3 };\nOopMapCacheEntry* volatile * _array;  // 动态数组指针\n\n// 优化后：\nstatic constexpr int size = 32;       // 编译时常量\nstatic constexpr int probe_depth = 3;\nOopMapCacheEntry* volatile _array[size];  // 内联数组\n// 优化前：\nOopMapCache::OopMapCache() {\n    _array = NEW_C_HEAP_ARRAY(OopMapCacheEntry*, _size, mtClass);\n    for(int i = 0; i < _size; i++) _array[i] = nullptr;\n}\n\n// 优化后：\nOopMapCache::OopMapCache() {\n    for(int i = 0; i < size; i++) _array[i] = nullptr;  // 直接初始化\n}\n// 优化前：\nOopMapCache::~OopMapCache() {\n    assert(_array != nullptr, \"sanity check\");\n    flush();\n    FREE_C_HEAP_ARRAY(OopMapCacheEntry*, _array);  // 需要显式释放\n}\n\n// 优化后：\nOopMapCache::~OopMapCache() {\n    flush();  // 只需刷新内容，数组自动销毁\n}\n// 所有数组访问从动态大小改为固定大小：\nOopMapCacheEntry* OopMapCache::entry_at(int i) const {\n-    return Atomic::load_acquire(&(_array[i % _size]));\n+    return Atomic::load_acquire(&(_array[i % size]));  // 使用内联数组\n}\n\nvoid OopMapCache::flush() {\n-    for(int i = 0; i < _size; i++) {  // 动态大小\n+    for(int i = 0; i < size; i++) {   // 固定大小\n        // ...\n    }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：\n\nOopMapCache类使用动态分配的数组：\n\n在构造函数中使用NEW_C_HEAP_ARRAY在堆上分配数组内存\n\n在析构函数中使用FREE_C_HEAP_ARRAY释放数组内存\n\n数组大小通过枚举常量_size和_probe_depth定义\n\n需要额外的指针间接访问数组元素\n\n优化后：\n\n使用内联固定大小数组：\n\n数组直接作为类的成员变量：OopMapCacheEntry* volatile _array[size]\n\n无需动态内存分配和释放\n\n使用static constexpr常量size和probe_depth替代枚举\n\n直接数组访问，减少指针间接寻址\n\n优化效果\n\n减少内存分配开销：消除堆分配和释放操作，降低内存管理成本\n\n改善缓存局部性：数组与对象实例在内存中连续分布，提高CPU缓存命中率\n\n减少内存访问延迟：直接数组访问比通过指针的间接访问更快\n\n简化内存管理：移除动态内存管理代码，降低复杂性和错误风险\n\n提升访问速度：数组大小在编译时确定，编译器可以生成更优化的代码"}
{"id": 926, "source": "riscv-dataset-excel", "optimization_type": "并发优化", "optimization_description": "优化前：\n\n在多个Shenandoah GC任务类（如ShenandoahDisarmNMethodsTask、ShenandoahUnlinkTask等）的构造函数和析构函数中，使用MutexLocker对CodeCache_lock进行加锁。\n\n锁的持有时间覆盖整个任务对象的生命周期（从构造到析构），包括任务执行期间。即使任务在执行过程中不需要直接访问CodeCache，锁也一直被持有。\n\n这导致不必要的锁竞争，其他线程（如JIT编译线程）在任务执行期间无法访问CodeCache，从而降低并发性能。\n\n优化后：\n\n从任务类的构造函数和析构函数中移除CodeCache_lock的加锁操作。\n\n将锁的加锁和解锁操作移动到实际需要保护CodeCache的地方——即ShenandoahConcurrentNMethodIterator的nmethods_do_begin()和nmethods_do_end()方法中。\n\n锁只在迭代器实际操作CodeCache（如创建快照或结束迭代）时持有，大大缩短了锁的持有时间。\n\n优化效果\n\n减少锁竞争：锁的持有时间显著缩短，其他线程（如JIT编译器）可以更频繁地访问CodeCache，减少阻塞等待。\n\n提高并发性：在Shenandoah GC的并发阶段，多个GC任务和应用程序线程可以更高效地并发执行，提升整体系统吞吐量。\n\n降低延迟：由于锁竞争减少，关键操作（如方法编译）的延迟可能降低。", "original_code": "在多个Shenandoah GC任务类（如ShenandoahDisarmNMethodsTask、ShenandoahUnlinkTask等）的构造函数和析构函数中，使用MutexLocker对CodeCache_lock进行加锁。\n\n锁的持有时间覆盖整个任务对象的生命周期（从构造到析构），包括任务执行期间。即使任务在执行过程中不需要直接访问CodeCache，锁也一直被持有。\n\n这导致不必要的锁竞争，其他线程（如JIT编译线程）在任务执行期间无法访问CodeCache，从而降低并发性能。", "optimized_code": "// 优化前：在构造函数和析构函数中加锁\nShenandoahDisarmNMethodsTask::ShenandoahDisarmNMethodsTask() : ... {\n    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag); // 被移除\n    _iterator.nmethods_do_begin();\n}\n\nShenandoahDisarmNMethodsTask::~ShenandoahDisarmNMethodsTask() {\n    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag); // 被移除\n    _iterator.nmethods_do_end();\n}\n// 优化后：在迭代器方法中加锁\nvoid ShenandoahConcurrentNMethodIterator::nmethods_do_begin() {\n    // 优化前：assert(CodeCache_lock->owned_by_self(), \"Lock must be held\");\n    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag); // 添加\n    _table_snapshot = _table->snapshot_for_iteration();\n}\n\nvoid ShenandoahConcurrentNMethodIterator::nmethods_do_end() {\n    // 优化前：assert(CodeCache_lock->owned_by_self(), \"Lock must be held\");\n    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag); // 添加\n    _table->finish_iteration(_table_snapshot);\n    CodeCache_lock->notify_all();\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/4ebb77120af5a4ccbfde63b24cb50e05a3161f16", "code_v0_no_empty_lines": "在多个Shenandoah GC任务类（如ShenandoahDisarmNMethodsTask、ShenandoahUnlinkTask等）的构造函数和析构函数中，使用MutexLocker对CodeCache_lock进行加锁。\n\n锁的持有时间覆盖整个任务对象的生命周期（从构造到析构），包括任务执行期间。即使任务在执行过程中不需要直接访问CodeCache，锁也一直被持有。\n\n这导致不必要的锁竞争，其他线程（如JIT编译线程）在任务执行期间无法访问CodeCache，从而降低并发性能。", "code_v1_no_empty_lines": "// 优化前：在构造函数和析构函数中加锁\nShenandoahDisarmNMethodsTask::ShenandoahDisarmNMethodsTask() : ... {\n    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag); // 被移除\n    _iterator.nmethods_do_begin();\n}\n\nShenandoahDisarmNMethodsTask::~ShenandoahDisarmNMethodsTask() {\n    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag); // 被移除\n    _iterator.nmethods_do_end();\n}\n// 优化后：在迭代器方法中加锁\nvoid ShenandoahConcurrentNMethodIterator::nmethods_do_begin() {\n    // 优化前：assert(CodeCache_lock->owned_by_self(), \"Lock must be held\");\n    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag); // 添加\n    _table_snapshot = _table->snapshot_for_iteration();\n}\n\nvoid ShenandoahConcurrentNMethodIterator::nmethods_do_end() {\n    // 优化前：assert(CodeCache_lock->owned_by_self(), \"Lock must be held\");\n    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag); // 添加\n    _table->finish_iteration(_table_snapshot);\n    CodeCache_lock->notify_all();\n}", "target": "// 优化前：在构造函数和析构函数中加锁\nShenandoahDisarmNMethodsTask::ShenandoahDisarmNMethodsTask() : ... {\n    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag); // 被移除\n    _iterator.nmethods_do_begin();\n}\n\nShenandoahDisarmNMethodsTask::~ShenandoahDisarmNMethodsTask() {\n    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag); // 被移除\n    _iterator.nmethods_do_end();\n}\n// 优化后：在迭代器方法中加锁\nvoid ShenandoahConcurrentNMethodIterator::nmethods_do_begin() {\n    // 优化前：assert(CodeCache_lock->owned_by_self(), \"Lock must be held\");\n    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag); // 添加\n    _table_snapshot = _table->snapshot_for_iteration();\n}\n\nvoid ShenandoahConcurrentNMethodIterator::nmethods_do_end() {\n    // 优化前：assert(CodeCache_lock->owned_by_self(), \"Lock must be held\");\n    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag); // 添加\n    _table->finish_iteration(_table_snapshot);\n    CodeCache_lock->notify_all();\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：\n\n在多个Shenandoah GC任务类（如ShenandoahDisarmNMethodsTask、ShenandoahUnlinkTask等）的构造函数和析构函数中，使用MutexLocker对CodeCache_lock进行加锁。\n\n锁的持有时间覆盖整个任务对象的生命周期（从构造到析构），包括任务执行期间。即使任务在执行过程中不需要直接访问CodeCache，锁也一直被持有。\n\n这导致不必要的锁竞争，其他线程（如JIT编译线程）在任务执行期间无法访问CodeCache，从而降低并发性能。\n\n优化后：\n\n从任务类的构造函数和析构函数中移除CodeCache_lock的加锁操作。\n\n将锁的加锁和解锁操作移动到实际需要保护CodeCache的地方——即ShenandoahConcurrentNMethodIterator的nmethods_do_begin()和nmethods_do_end()方法中。\n\n锁只在迭代器实际操作CodeCache（如创建快照或结束迭代）时持有，大大缩短了锁的持有时间。\n\n优化效果\n\n减少锁竞争：锁的持有时间显著缩短，其他线程（如JIT编译器）可以更频繁地访问CodeCache，减少阻塞等待。\n\n提高并发性：在Shenandoah GC的并发阶段，多个GC任务和应用程序线程可以更高效地并发执行，提升整体系统吞吐量。\n\n降低延迟：由于锁竞争减少，关键操作（如方法编译）的延迟可能降低。"}
{"id": 927, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：在NMT（Native Memory Tracking）中，使用标准的指针大小（通常8字节）来存储调用栈索引，这浪费内存。\n\n优化后：引入了ArrayWithFreeList分配器，使用4字节指针（int32_t）来存储索引，减少了内存占用。同时，重构了NativeCallStackStorage，使用自定义的分配器代替Arena。\n\n优化效果: 显著减少NMT的内存开销，特别是在详细模式下跟踪大量调用栈时，提升内存效率。\n\n优化思路: 通过减小指针大小（从8字节到4字节）来节省内存，同时维护快速访问和比较特性。使用自由列表管理空闲元素，提高分配效率。\n\n关键代码片段:", "original_code": "在NMT（Native Memory Tracking）中，使用标准的指针大小（通常8字节）来存储调用栈索引，这浪费内存。", "optimized_code": "template<typename E, MEMFLAGS flag>\nclass ArrayWithFreeList {\n  using I = int32_t; // 4字节索引\n  // ... 分配和释放逻辑\n};\nstruct StackIndex {\n  int32_t _stack_index; // 原来是指针大小\n  static constexpr const int32_t invalid = -1;\n};", "source_url": "https://github.com/openjdk/riscv-port/commit/57f8b91e558e5b9ff9c2000b8f74e3a1988ead2b", "code_v0_no_empty_lines": "在NMT（Native Memory Tracking）中，使用标准的指针大小（通常8字节）来存储调用栈索引，这浪费内存。", "code_v1_no_empty_lines": "template<typename E, MEMFLAGS flag>\nclass ArrayWithFreeList {\n  using I = int32_t; // 4字节索引\n  // ... 分配和释放逻辑\n};\nstruct StackIndex {\n  int32_t _stack_index; // 原来是指针大小\n  static constexpr const int32_t invalid = -1;\n};", "target": "template<typename E, MEMFLAGS flag>\nclass ArrayWithFreeList {\n  using I = int32_t; // 4字节索引\n  // ... 分配和释放逻辑\n};\nstruct StackIndex {\n  int32_t _stack_index; // 原来是指针大小\n  static constexpr const int32_t invalid = -1;\n};", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在NMT（Native Memory Tracking）中，使用标准的指针大小（通常8字节）来存储调用栈索引，这浪费内存。\n\n优化后：引入了ArrayWithFreeList分配器，使用4字节指针（int32_t）来存储索引，减少了内存占用。同时，重构了NativeCallStackStorage，使用自定义的分配器代替Arena。\n\n优化效果: 显著减少NMT的内存开销，特别是在详细模式下跟踪大量调用栈时，提升内存效率。\n\n优化思路: 通过减小指针大小（从8字节到4字节）来节省内存，同时维护快速访问和比较特性。使用自由列表管理空闲元素，提高分配效率。\n\n关键代码片段:"}
{"id": 928, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "优化前：在riscv.ad中定义了bytes_reverse_unsigned_short和bytes_reverse_short指令，但未使用RISC-V B扩展（Zbb）的专用指令，成本较高（ins_cost(ALU_COST * 5)）。\n\n优化后：将这些指令移动到riscv_b.ad中，并添加了UseZbb断言，确保只有在B扩展可用时才使用这些指令。成本降低（ins_cost(ALU_COST * 2)），并添加了微基准测试来验证性能。\n\n优化效果: 利用RISC-V B扩展的专用指令（如revb_h_h_u和revb_h_h）来优化短整数字节反转操作，减少指令周期，提高性能。微基准测试用于验证性能提升。\n\n优化思路: 通过指令集特性（Zbb）来简化字节反转操作，避免通用的多指令序列，从而降低延迟。", "original_code": "在riscv.ad中定义了bytes_reverse_unsigned_short和bytes_reverse_short指令，但未使用RISC-V B扩展（Zbb）的专用指令，成本较高（ins_cost(ALU_COST * 5)）。", "optimized_code": "instruct bytes_reverse_unsigned_short_b(iRegINoSp dst, iRegIorL2I src) %{\n  predicate(UseZbb); // 新增断言\n  match(Set dst (ReverseBytesUS src));\n  ins_cost(ALU_COST * 2); // 成本从5降低到2\n  format %{ \"revb_h_h_u $dst, $src #@bytes_reverse_unsigned_short_b\" %}\n  ins_encode %{\n    assert(UseZbb, \"must be\");\n    __ revb_h_h_u(as_Register($dst$$reg), as_Register($src$$reg));\n  %}\n  ins_pipe(ialu_reg);\n%}", "source_url": "https://github.com/openjdk/riscv-port/commit/cae94b268d633b0557a54e3b21eff60d7f0edc2d", "code_v0_no_empty_lines": "在riscv.ad中定义了bytes_reverse_unsigned_short和bytes_reverse_short指令，但未使用RISC-V B扩展（Zbb）的专用指令，成本较高（ins_cost(ALU_COST * 5)）。", "code_v1_no_empty_lines": "instruct bytes_reverse_unsigned_short_b(iRegINoSp dst, iRegIorL2I src) %{\n  predicate(UseZbb); // 新增断言\n  match(Set dst (ReverseBytesUS src));\n  ins_cost(ALU_COST * 2); // 成本从5降低到2\n  format %{ \"revb_h_h_u $dst, $src #@bytes_reverse_unsigned_short_b\" %}\n  ins_encode %{\n    assert(UseZbb, \"must be\");\n    __ revb_h_h_u(as_Register($dst$$reg), as_Register($src$$reg));\n  %}\n  ins_pipe(ialu_reg);\n%}", "target": "instruct bytes_reverse_unsigned_short_b(iRegINoSp dst, iRegIorL2I src) %{\n  predicate(UseZbb); // 新增断言\n  match(Set dst (ReverseBytesUS src));\n  ins_cost(ALU_COST * 2); // 成本从5降低到2\n  format %{ \"revb_h_h_u $dst, $src #@bytes_reverse_unsigned_short_b\" %}\n  ins_encode %{\n    assert(UseZbb, \"must be\");\n    __ revb_h_h_u(as_Register($dst$$reg), as_Register($src$$reg));\n  %}\n  ins_pipe(ialu_reg);\n%}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在riscv.ad中定义了bytes_reverse_unsigned_short和bytes_reverse_short指令，但未使用RISC-V B扩展（Zbb）的专用指令，成本较高（ins_cost(ALU_COST * 5)）。\n\n优化后：将这些指令移动到riscv_b.ad中，并添加了UseZbb断言，确保只有在B扩展可用时才使用这些指令。成本降低（ins_cost(ALU_COST * 2)），并添加了微基准测试来验证性能。\n\n优化效果: 利用RISC-V B扩展的专用指令（如revb_h_h_u和revb_h_h）来优化短整数字节反转操作，减少指令周期，提高性能。微基准测试用于验证性能提升。\n\n优化思路: 通过指令集特性（Zbb）来简化字节反转操作，避免通用的多指令序列，从而降低延迟。"}
{"id": 929, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "优化前：\n\nGeneration类有一个 max_contiguous_available()方法，该方法计算当前 Generation 和更高 Generation（如老年代）的最大连续可用空间。具体逻辑如下：\n\n调用 contiguous_available()获取当前 Generation 的可用空间。\n\n如果当前是年轻代，则获取老年代的可用空间。\n\n返回两者中的最大值。\n\n在 TenuredGeneration::promotion_attempt_is_safe()方法中调用 max_contiguous_available()，引入额外的函数调用和条件检查。\n\n优化后：\n\n完全移除 Generation::max_contiguous_available()方法及其声明。\n\n在 TenuredGeneration::promotion_attempt_is_safe()中直接调用 contiguous_available()，仅考虑当前 Generation 的可用空间。\n\n简化了逻辑，避免了条件检查和跨 Generation 的查询。\n\n优化效果：\n\n性能提升：减少了一个函数调用开销（避免了 max_contiguous_available的调用），并消除了条件分支（检查是否为年轻代）和额外的方法调用（获取老年代空间）。这降低了调用栈深度，提高了 promotion_attempt_is_safe方法的执行速度。\n\n内存访问优化：避免了对老年代空间的查询，减少了不必要的内存访问，可能改善缓存局部性。\n\n代码简洁性：移除了冗余代码，使逻辑更清晰，减少了维护成本。", "original_code": "Generation类有一个 max_contiguous_available()方法，该方法计算当前 Generation 和更高 Generation（如老年代）的最大连续可用空间。具体逻辑如下：\n\n调用 contiguous_available()获取当前 Generation 的可用空间。\n\n如果当前是年轻代，则获取老年代的可用空间。\n\n返回两者中的最大值。\n\n在 TenuredGeneration::promotion_attempt_is_safe()方法中调用 max_contiguous_available()，引入额外的函数调用和条件检查。", "optimized_code": "// 优化前被删除的代码：\nsize_t Generation::max_contiguous_available() const {\n  size_t avail = contiguous_available();\n  size_t old_avail = 0;\n  if (SerialHeap::heap()->is_young_gen(this)) {\n    old_avail = SerialHeap::heap()->old_gen()->contiguous_available();\n  }\n  return MAX2(avail, old_avail);\n}\n// 优化前：\nbool TenuredGeneration::promotion_attempt_is_safe(size_t max_promotion_in_bytes) const {\n  size_t available = max_contiguous_available(); // 间接调用\n  // ...\n}\n\n// 优化后：\nbool TenuredGeneration::promotion_attempt_is_safe(size_t max_promotion_in_bytes) const {\n  size_t available = contiguous_available(); // 直接调用\n  // ...\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/b1b953c427b9562f050760ab3c2d0ae09aeec3e5", "code_v0_no_empty_lines": "Generation类有一个 max_contiguous_available()方法，该方法计算当前 Generation 和更高 Generation（如老年代）的最大连续可用空间。具体逻辑如下：\n\n调用 contiguous_available()获取当前 Generation 的可用空间。\n\n如果当前是年轻代，则获取老年代的可用空间。\n\n返回两者中的最大值。\n\n在 TenuredGeneration::promotion_attempt_is_safe()方法中调用 max_contiguous_available()，引入额外的函数调用和条件检查。", "code_v1_no_empty_lines": "// 优化前被删除的代码：\nsize_t Generation::max_contiguous_available() const {\n  size_t avail = contiguous_available();\n  size_t old_avail = 0;\n  if (SerialHeap::heap()->is_young_gen(this)) {\n    old_avail = SerialHeap::heap()->old_gen()->contiguous_available();\n  }\n  return MAX2(avail, old_avail);\n}\n// 优化前：\nbool TenuredGeneration::promotion_attempt_is_safe(size_t max_promotion_in_bytes) const {\n  size_t available = max_contiguous_available(); // 间接调用\n  // ...\n}\n\n// 优化后：\nbool TenuredGeneration::promotion_attempt_is_safe(size_t max_promotion_in_bytes) const {\n  size_t available = contiguous_available(); // 直接调用\n  // ...\n}", "target": "// 优化前被删除的代码：\nsize_t Generation::max_contiguous_available() const {\n  size_t avail = contiguous_available();\n  size_t old_avail = 0;\n  if (SerialHeap::heap()->is_young_gen(this)) {\n    old_avail = SerialHeap::heap()->old_gen()->contiguous_available();\n  }\n  return MAX2(avail, old_avail);\n}\n// 优化前：\nbool TenuredGeneration::promotion_attempt_is_safe(size_t max_promotion_in_bytes) const {\n  size_t available = max_contiguous_available(); // 间接调用\n  // ...\n}\n\n// 优化后：\nbool TenuredGeneration::promotion_attempt_is_safe(size_t max_promotion_in_bytes) const {\n  size_t available = contiguous_available(); // 直接调用\n  // ...\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：\n\nGeneration类有一个 max_contiguous_available()方法，该方法计算当前 Generation 和更高 Generation（如老年代）的最大连续可用空间。具体逻辑如下：\n\n调用 contiguous_available()获取当前 Generation 的可用空间。\n\n如果当前是年轻代，则获取老年代的可用空间。\n\n返回两者中的最大值。\n\n在 TenuredGeneration::promotion_attempt_is_safe()方法中调用 max_contiguous_available()，引入额外的函数调用和条件检查。\n\n优化后：\n\n完全移除 Generation::max_contiguous_available()方法及其声明。\n\n在 TenuredGeneration::promotion_attempt_is_safe()中直接调用 contiguous_available()，仅考虑当前 Generation 的可用空间。\n\n简化了逻辑，避免了条件检查和跨 Generation 的查询。\n\n优化效果：\n\n性能提升：减少了一个函数调用开销（避免了 max_contiguous_available的调用），并消除了条件分支（检查是否为年轻代）和额外的方法调用（获取老年代空间）。这降低了调用栈深度，提高了 promotion_attempt_is_safe方法的执行速度。\n\n内存访问优化：避免了对老年代空间的查询，减少了不必要的内存访问，可能改善缓存局部性。\n\n代码简洁性：移除了冗余代码，使逻辑更清晰，减少了维护成本。"}
{"id": 930, "source": "riscv-dataset-excel", "optimization_type": "条件分支优化", "optimization_description": "优化前：在conditional_move函数中，仅根据ConditionalMoveLimit检查成本，且使用固定的infrequent_prob（PROB_UNLIKELY_MAG(2)）来忽略高预测性分支。这可能导致条件移动（CMOV）被过度抑制，错过优化机会。\n\n优化后：引入了动态的infrequent_prob计算，考虑BlockLayoutByFrequency优化（如果启用），将infrequent_prob调整为MAX2(PROB_UNLIKELY_MAG(3), BlockLayoutMinDiamondPercentage/110.0f)。同时，成本检查仅在循环内使用条件移动时进行（used_inside_loop为真）。\n\n优化效果: 更精确地控制条件移动的使用，避免在分支预测准确时使用CMOV（减少开销），但在分支不可预测时更积极地使用CMOV以减少分支错误预测。这提高了指令级并行性，可能提升性能。\n\n优化思路: 通过结合分支概率和块布局优化，动态调整条件移动的触发阈值，使编译器在适合场景下更激进地使用CMOV指令。", "original_code": "在conditional_move函数中，仅根据ConditionalMoveLimit检查成本，且使用固定的infrequent_prob（PROB_UNLIKELY_MAG(2)）来忽略高预测性分支。这可能导致条件移动（CMOV）被过度抑制，错过优化机会。", "optimized_code": "float infrequent_prob = PROB_UNLIKELY_MAG(3);\nif (used_inside_loop) {\n  if (cost >= ConditionalMoveLimit) return nullptr; // Too much goo\n  if (BlockLayoutByFrequency) {\n    infrequent_prob = MAX2(infrequent_prob, (float)BlockLayoutMinDiamondPercentage/110.0f);\n  }\n}\nif (C->use_cmove() && (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) {\n  // keep going\n} else if (iff->_prob < infrequent_prob || iff->_prob > (1.0f - infrequent_prob)) {\n  return nullptr;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/933eababf2b79586a911082af36fdcc41763c7b9", "code_v0_no_empty_lines": "在conditional_move函数中，仅根据ConditionalMoveLimit检查成本，且使用固定的infrequent_prob（PROB_UNLIKELY_MAG(2)）来忽略高预测性分支。这可能导致条件移动（CMOV）被过度抑制，错过优化机会。", "code_v1_no_empty_lines": "float infrequent_prob = PROB_UNLIKELY_MAG(3);\nif (used_inside_loop) {\n  if (cost >= ConditionalMoveLimit) return nullptr; // Too much goo\n  if (BlockLayoutByFrequency) {\n    infrequent_prob = MAX2(infrequent_prob, (float)BlockLayoutMinDiamondPercentage/110.0f);\n  }\n}\nif (C->use_cmove() && (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) {\n  // keep going\n} else if (iff->_prob < infrequent_prob || iff->_prob > (1.0f - infrequent_prob)) {\n  return nullptr;\n}", "target": "float infrequent_prob = PROB_UNLIKELY_MAG(3);\nif (used_inside_loop) {\n  if (cost >= ConditionalMoveLimit) return nullptr; // Too much goo\n  if (BlockLayoutByFrequency) {\n    infrequent_prob = MAX2(infrequent_prob, (float)BlockLayoutMinDiamondPercentage/110.0f);\n  }\n}\nif (C->use_cmove() && (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) {\n  // keep going\n} else if (iff->_prob < infrequent_prob || iff->_prob > (1.0f - infrequent_prob)) {\n  return nullptr;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在conditional_move函数中，仅根据ConditionalMoveLimit检查成本，且使用固定的infrequent_prob（PROB_UNLIKELY_MAG(2)）来忽略高预测性分支。这可能导致条件移动（CMOV）被过度抑制，错过优化机会。\n\n优化后：引入了动态的infrequent_prob计算，考虑BlockLayoutByFrequency优化（如果启用），将infrequent_prob调整为MAX2(PROB_UNLIKELY_MAG(3), BlockLayoutMinDiamondPercentage/110.0f)。同时，成本检查仅在循环内使用条件移动时进行（used_inside_loop为真）。\n\n优化效果: 更精确地控制条件移动的使用，避免在分支预测准确时使用CMOV（减少开销），但在分支不可预测时更积极地使用CMOV以减少分支错误预测。这提高了指令级并行性，可能提升性能。\n\n优化思路: 通过结合分支概率和块布局优化，动态调整条件移动的触发阈值，使编译器在适合场景下更激进地使用CMOV指令。"}
{"id": 931, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：在对象转发（forwarding）时，使用memory_order_release进行原子操作，并在成功或失败后调用OrderAccess::acquire()来确保内存可见性。这引入了不必要的内存屏障，增加同步开销。\n\n优化后：将原子操作的内存顺序改为memory_order_relaxed，并移除了两个OrderAccess::acquire()调用。注释说明客户端需要通过其他同步机制来确保可见性。\n\n优化效果: 减少内存屏障的使用，降低原子操作的开销，从而提升垃圾收集器的性能，特别是在高并发场景下。\n\n优化思路: 在保证正确性的前提下，放松内存顺序要求。因为对象转发后的内容检查需要其他同步（如锁或屏障），单独的acquire屏障是冗余的。", "original_code": "在对象转发（forwarding）时，使用memory_order_release进行原子操作，并在成功或失败后调用OrderAccess::acquire()来确保内存可见性。这引入了不必要的内存屏障，增加同步开销。", "optimized_code": "// 优化前：\n// oop forwardee = o->forward_to_atomic(new_obj, test_mark, memory_order_release);\n// OrderAccess::acquire(); // 在成功和失败路径都有\n// 优化后：\noop forwardee = o->forward_to_atomic(new_obj, test_mark, memory_order_relaxed);\n// 移除了OrderAccess::acquire()", "source_url": "https://github.com/openjdk/riscv-port/commit/b88af94269640a160fbacf25618f3a00756464aa", "code_v0_no_empty_lines": "在对象转发（forwarding）时，使用memory_order_release进行原子操作，并在成功或失败后调用OrderAccess::acquire()来确保内存可见性。这引入了不必要的内存屏障，增加同步开销。", "code_v1_no_empty_lines": "// 优化前：\n// oop forwardee = o->forward_to_atomic(new_obj, test_mark, memory_order_release);\n// OrderAccess::acquire(); // 在成功和失败路径都有\n// 优化后：\noop forwardee = o->forward_to_atomic(new_obj, test_mark, memory_order_relaxed);\n// 移除了OrderAccess::acquire()", "target": "// 优化前：\n// oop forwardee = o->forward_to_atomic(new_obj, test_mark, memory_order_release);\n// OrderAccess::acquire(); // 在成功和失败路径都有\n// 优化后：\noop forwardee = o->forward_to_atomic(new_obj, test_mark, memory_order_relaxed);\n// 移除了OrderAccess::acquire()", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在对象转发（forwarding）时，使用memory_order_release进行原子操作，并在成功或失败后调用OrderAccess::acquire()来确保内存可见性。这引入了不必要的内存屏障，增加同步开销。\n\n优化后：将原子操作的内存顺序改为memory_order_relaxed，并移除了两个OrderAccess::acquire()调用。注释说明客户端需要通过其他同步机制来确保可见性。\n\n优化效果: 减少内存屏障的使用，降低原子操作的开销，从而提升垃圾收集器的性能，特别是在高并发场景下。\n\n优化思路: 在保证正确性的前提下，放松内存顺序要求。因为对象转发后的内容检查需要其他同步（如锁或屏障），单独的acquire屏障是冗余的。"}
{"id": 932, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "优化前: 控制依赖重连逻辑内嵌在PhaseIdealLoop::dominated_by方法中，代码结构复杂，可能存在冗余操作。在循环预测（loop predication）时，提升的范围检查（hoisted range check）消除数据依赖节点（如Load节点）的处理不够高效。\n\n优化后: 将控制依赖重连逻辑提取到独立方法rewire_safe_outputs_to_dominator中，并添加了eliminate_hoisted_range_check方法。这使代码更模块化，并优化了数据依赖节点的重连：直接将其控制依赖重连到支配者（dominator），避免了不必要的中间节点。\n\n优化效果: 提高了编译器循环优化阶段的效率，可能减少生成代码中的冗余控制流，提升运行时性能。优化还增强了代码可性，便于后续优化。\n\n优化思路: 通过重构提取公共逻辑，减少重复代码；在消除提升的范围检查时，显式处理数据依赖节点，确保它们被正确重连到支配者，避免浮点（floating）或悬空依赖。这优化了循环体的控制流图。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 新方法rewire_safe_outputs_to_dominator\nvoid PhaseIdealLoop::rew_outputs_to_dominator(Node* source, Node* dominator, const bool pin_array_access_nodes) {\n    // ... 重连source的控制依赖输出到dominator ...\n}\n\n// 在dominated_by方法中调用新方法\nvoid PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool pin_array_access_nodes) {\n    // ... \n    rewire_safe_outputs_to_dominator(dp, prevdom, pin_array_access_nodes);\n}\n\n// 新增eliminate_hoisted_range_check方法\nvoid PhaseIdealLoop::eliminate_hoisted_range_check(IfTrueNode* hoisted_check_proj, IfTrueNode* template_assertion_predicate_proj) {\n    _igvn.replace_input_of(hoisted_check_proj->in(0), 1, _igvn.intcon(1));\n    rewire_safe_outputs_to_dominator(hoisted_check_proj, template_assertion_predicate_proj, true);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/ca5a438e5a4612c66f70c70a9d425eca0e49e84d", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 新方法rewire_safe_outputs_to_dominator\nvoid PhaseIdealLoop::rew_outputs_to_dominator(Node* source, Node* dominator, const bool pin_array_access_nodes) {\n    // ... 重连source的控制依赖输出到dominator ...\n}\n\n// 在dominated_by方法中调用新方法\nvoid PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool pin_array_access_nodes) {\n    // ... \n    rewire_safe_outputs_to_dominator(dp, prevdom, pin_array_access_nodes);\n}\n\n// 新增eliminate_hoisted_range_check方法\nvoid PhaseIdealLoop::eliminate_hoisted_range_check(IfTrueNode* hoisted_check_proj, IfTrueNode* template_assertion_predicate_proj) {\n    _igvn.replace_input_of(hoisted_check_proj->in(0), 1, _igvn.intcon(1));\n    rewire_safe_outputs_to_dominator(hoisted_check_proj, template_assertion_predicate_proj, true);\n}", "target": "// 新方法rewire_safe_outputs_to_dominator\nvoid PhaseIdealLoop::rew_outputs_to_dominator(Node* source, Node* dominator, const bool pin_array_access_nodes) {\n    // ... 重连source的控制依赖输出到dominator ...\n}\n\n// 在dominated_by方法中调用新方法\nvoid PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool pin_array_access_nodes) {\n    // ... \n    rewire_safe_outputs_to_dominator(dp, prevdom, pin_array_access_nodes);\n}\n\n// 新增eliminate_hoisted_range_check方法\nvoid PhaseIdealLoop::eliminate_hoisted_range_check(IfTrueNode* hoisted_check_proj, IfTrueNode* template_assertion_predicate_proj) {\n    _igvn.replace_input_of(hoisted_check_proj->in(0), 1, _igvn.intcon(1));\n    rewire_safe_outputs_to_dominator(hoisted_check_proj, template_assertion_predicate_proj, true);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: 控制依赖重连逻辑内嵌在PhaseIdealLoop::dominated_by方法中，代码结构复杂，可能存在冗余操作。在循环预测（loop predication）时，提升的范围检查（hoisted range check）消除数据依赖节点（如Load节点）的处理不够高效。\n\n优化后: 将控制依赖重连逻辑提取到独立方法rewire_safe_outputs_to_dominator中，并添加了eliminate_hoisted_range_check方法。这使代码更模块化，并优化了数据依赖节点的重连：直接将其控制依赖重连到支配者（dominator），避免了不必要的中间节点。\n\n优化效果: 提高了编译器循环优化阶段的效率，可能减少生成代码中的冗余控制流，提升运行时性能。优化还增强了代码可性，便于后续优化。\n\n优化思路: 通过重构提取公共逻辑，减少重复代码；在消除提升的范围检查时，显式处理数据依赖节点，确保它们被正确重连到支配者，避免浮点（floating）或悬空依赖。这优化了循环体的控制流图。"}
{"id": 933, "source": "riscv-dataset-excel", "optimization_type": "内存优化+ 编译器优化", "optimization_description": "优化前：\n\n在StringConcatFactory.makeConcatWithConstants方法中，始终使用generateMHInlineCopy策略生成方法句柄。该策略在编译时（尤其是C2编译器）对于参数数量较多（高arity）的字符串连接操作，可能导致内存使用高达2GB，引发性能问题或内存溢出。\n\n优化后：\n\n引入阈值机制（HIGH_ARITY_THRESHOLD，默认20）：当参数数量低于阈值时，使用原有的generateMHInlineCopy策略；当参数数量超过阈值时，切换到新的SimpleStringBuilderStrategy策略。\n\nSimpleStringBuilderStrategy使用ASM库动态生成字节码，模拟StringBuilder的链式调用（如append方法），类似于javac编译字符串连接的方式。这种方式生成代码更简单，减少编译器内存压力。\n\n优化效果：\n\n避免了在极端情况（高参数数量）下C2编译器内存使用过高的问题，提高了编译稳定性和可伸缩性。\n\n可能牺牲少量性能（因为StringBuilder策略不如内联复制策略高效），但保证了内存使用的可控性。\n\n通过新增的基准测试（StringConcat.java）验证不同参数数量的性能。\n\n优化思路：\n\n针对高参数数量的字符串连接，采用更保守的代码生成策略，减少编译器优化过程中的内存消耗。\n\n通过阈值动态切换策略，在性能和内存之间取得平衡。", "original_code": "在StringConcatFactory.makeConcatWithConstants方法中，始终使用generateMHInlineCopy策略生成方法句柄。该策略在编译时（尤其是C2编译器）对于参数数量较多（高arity）的字符串连接操作，可能导致内存使用高达2GB，引发性能问题或内存溢出。", "optimized_code": "// 优化后关键代码\nif (concatType.parameterCount() < HIGH_ARITY_THRESHOLD) {\n    return new ConstantCallSite(\n        generateMHInlineCopy(concatType, constantStrings)\n        .viewAsType(concatType, true));\n} else {\n    return new ConstantCallSite(\n        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n}\n// 示例代码生成片段：使用StringBuilder.append链\nmv.visitTypeInsn(NEW, \"java/lang/StringBuilder\");\nmv.visitInsn(DUP);\niconst(mv, len); // 估算初始容量\nmv.visitMethodInsn(INVOKESPECIAL, \"java/lang/StringBuilder\", \"<init>\", \"(I)V\", false);\n// 后续生成append调用", "source_url": "https://github.com/openjdk/riscv-port/commit/5e2ced4b9e1c9953e459dc152076520e5ef9d76c", "code_v0_no_empty_lines": "在StringConcatFactory.makeConcatWithConstants方法中，始终使用generateMHInlineCopy策略生成方法句柄。该策略在编译时（尤其是C2编译器）对于参数数量较多（高arity）的字符串连接操作，可能导致内存使用高达2GB，引发性能问题或内存溢出。", "code_v1_no_empty_lines": "// 优化后关键代码\nif (concatType.parameterCount() < HIGH_ARITY_THRESHOLD) {\n    return new ConstantCallSite(\n        generateMHInlineCopy(concatType, constantStrings)\n        .viewAsType(concatType, true));\n} else {\n    return new ConstantCallSite(\n        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n}\n// 示例代码生成片段：使用StringBuilder.append链\nmv.visitTypeInsn(NEW, \"java/lang/StringBuilder\");\nmv.visitInsn(DUP);\niconst(mv, len); // 估算初始容量\nmv.visitMethodInsn(INVOKESPECIAL, \"java/lang/StringBuilder\", \"<init>\", \"(I)V\", false);\n// 后续生成append调用", "target": "// 优化后关键代码\nif (concatType.parameterCount() < HIGH_ARITY_THRESHOLD) {\n    return new ConstantCallSite(\n        generateMHInlineCopy(concatType, constantStrings)\n        .viewAsType(concatType, true));\n} else {\n    return new ConstantCallSite(\n        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n}\n// 示例代码生成片段：使用StringBuilder.append链\nmv.visitTypeInsn(NEW, \"java/lang/StringBuilder\");\nmv.visitInsn(DUP);\niconst(mv, len); // 估算初始容量\nmv.visitMethodInsn(INVOKESPECIAL, \"java/lang/StringBuilder\", \"<init>\", \"(I)V\", false);\n// 后续生成append调用", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：\n\n在StringConcatFactory.makeConcatWithConstants方法中，始终使用generateMHInlineCopy策略生成方法句柄。该策略在编译时（尤其是C2编译器）对于参数数量较多（高arity）的字符串连接操作，可能导致内存使用高达2GB，引发性能问题或内存溢出。\n\n优化后：\n\n引入阈值机制（HIGH_ARITY_THRESHOLD，默认20）：当参数数量低于阈值时，使用原有的generateMHInlineCopy策略；当参数数量超过阈值时，切换到新的SimpleStringBuilderStrategy策略。\n\nSimpleStringBuilderStrategy使用ASM库动态生成字节码，模拟StringBuilder的链式调用（如append方法），类似于javac编译字符串连接的方式。这种方式生成代码更简单，减少编译器内存压力。\n\n优化效果：\n\n避免了在极端情况（高参数数量）下C2编译器内存使用过高的问题，提高了编译稳定性和可伸缩性。\n\n可能牺牲少量性能（因为StringBuilder策略不如内联复制策略高效），但保证了内存使用的可控性。\n\n通过新增的基准测试（StringConcat.java）验证不同参数数量的性能。\n\n优化思路：\n\n针对高参数数量的字符串连接，采用更保守的代码生成策略，减少编译器优化过程中的内存消耗。\n\n通过阈值动态切换策略，在性能和内存之间取得平衡。"}
{"id": 934, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：\n\n在ClassDesc.ofDescriptor方法中，对于任何描述符（包括原始类型），都会进行一系列检查（如空检查、数组深度检查），然后根据描述符长度创建PrimitiveClassDescImpl或ReferenceClassDescImpl实例。这导致每次调用时都可能创建新对象，尤其是原始类型描述符（如\"I\"、\"J\"）被频繁使用，造成不必要的对象分配。\n\n在ConstantUtils.parseMethodDescriptor方法中，解析方法描述符时返回List<String>，然后需要额外调用ClassDesc.ofDescriptor将字符串转换为ClassDesc，增加了中间步骤和对象创建。\n\n优化后：\n\n对于原始类型描述符（长度為1），直接通过Wrapper类获取预定义的ClassDesc实例（如Wrapper.forPrimitiveType('I').primitiveClassDescriptor()），避免了对象创建和检查开销。\n\n在ConstantUtils.parseMethodDescriptor方法中，直接返回List<ClassDesc>，并通过新增的resolveClassDesc方法在解析时直接生成ClassDesc，减少了字符串中间表示。\n\nWrapper类新增了primitiveTypeDesc字段和primitiveClassDescriptor方法，提供缓存的ClassDesc实例。\n\n优化效果：\n\n减少了原始类型ClassDesc对象的重复创建，降低了内存分配压力。\n\n提高了ClassDesc.ofDescriptor和方法描述符解析的执行效率，因为减少了条件检查和对象分配。\n\n通过微基准测试（新增的ClassDescFactories类）验证性能提升。\n\n优化思路：\n\n利用原始类型描述符固定的特性，将ClassDesc实例缓存到Wrapper类中，实现单例或重用。\n\n将描述符解析与对象创建合并，减少中间步骤，直接生成最终结果。", "original_code": "在ClassDesc.ofDescriptor方法中，对于任何描述符（包括原始类型），都会进行一系列检查（如空检查、数组深度检查），然后根据描述符长度创建PrimitiveClassDescImpl或ReferenceClassDescImpl实例。这导致每次调用时都可能创建新对象，尤其是原始类型描述符（如\"I\"、\"J\"）被频繁使用，造成不必要的对象分配。\n\n在ConstantUtils.parseMethodDescriptor方法中，解析方法描述符时返回List<String>，然后需要额外调用ClassDesc.ofDescriptor将字符串转换为ClassDesc，增加了中间步骤和对象创建。", "optimized_code": "ClassDesc.java：修改ofDescriptor方法，直接使用Wrapper类处理原始类型。\n\n\n// 优化后关键代码\nreturn (descriptor.length() == 1)\n    ? Wrapper.forPrimitiveType(descriptor.charAt(0)).primitiveClassDescriptor()\n    : new ReferenceClassDescImpl(descriptor);\n\nWrapper.java：新增primitiveTypeDesc字段和primitiveClassDescriptor方法。\n\n\n// 新增字段和方法\nprivate final ClassDesc primitiveTypeDesc;\npublic ClassDesc primitiveClassDescriptor() { return primitiveTypeDesc; }\n\nConstantUtils.java：修改parseMethodDescriptor返回类型，并添加resolveClassDesc方法。\n\n\n// 优化后解析方法描述符直接返回ClassDesc列表\nprivate static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n    if (len == 1) {\n        return Wrapper.forBasicType(descriptor.charAt(start)).primitiveClassDescriptor();\n    }\n    return ClassDesc.ofDescriptor(descriptor.substring(start, start + len));\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/8bbd7251a596c6fad1a6675c077deb9fd7c8ff95", "code_v0_no_empty_lines": "在ClassDesc.ofDescriptor方法中，对于任何描述符（包括原始类型），都会进行一系列检查（如空检查、数组深度检查），然后根据描述符长度创建PrimitiveClassDescImpl或ReferenceClassDescImpl实例。这导致每次调用时都可能创建新对象，尤其是原始类型描述符（如\"I\"、\"J\"）被频繁使用，造成不必要的对象分配。\n\n在ConstantUtils.parseMethodDescriptor方法中，解析方法描述符时返回List<String>，然后需要额外调用ClassDesc.ofDescriptor将字符串转换为ClassDesc，增加了中间步骤和对象创建。", "code_v1_no_empty_lines": "ClassDesc.java：修改ofDescriptor方法，直接使用Wrapper类处理原始类型。\n\n\n// 优化后关键代码\nreturn (descriptor.length() == 1)\n    ? Wrapper.forPrimitiveType(descriptor.charAt(0)).primitiveClassDescriptor()\n    : new ReferenceClassDescImpl(descriptor);\n\nWrapper.java：新增primitiveTypeDesc字段和primitiveClassDescriptor方法。\n\n\n// 新增字段和方法\nprivate final ClassDesc primitiveTypeDesc;\npublic ClassDesc primitiveClassDescriptor() { return primitiveTypeDesc; }\n\nConstantUtils.java：修改parseMethodDescriptor返回类型，并添加resolveClassDesc方法。\n\n\n// 优化后解析方法描述符直接返回ClassDesc列表\nprivate static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n    if (len == 1) {\n        return Wrapper.forBasicType(descriptor.charAt(start)).primitiveClassDescriptor();\n    }\n    return ClassDesc.ofDescriptor(descriptor.substring(start, start + len));\n}", "target": "ClassDesc.java：修改ofDescriptor方法，直接使用Wrapper类处理原始类型。\n\n\n// 优化后关键代码\nreturn (descriptor.length() == 1)\n    ? Wrapper.forPrimitiveType(descriptor.charAt(0)).primitiveClassDescriptor()\n    : new ReferenceClassDescImpl(descriptor);\n\nWrapper.java：新增primitiveTypeDesc字段和primitiveClassDescriptor方法。\n\n\n// 新增字段和方法\nprivate final ClassDesc primitiveTypeDesc;\npublic ClassDesc primitiveClassDescriptor() { return primitiveTypeDesc; }\n\nConstantUtils.java：修改parseMethodDescriptor返回类型，并添加resolveClassDesc方法。\n\n\n// 优化后解析方法描述符直接返回ClassDesc列表\nprivate static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n    if (len == 1) {\n        return Wrapper.forBasicType(descriptor.charAt(start)).primitiveClassDescriptor();\n    }\n    return ClassDesc.ofDescriptor(descriptor.substring(start, start + len));\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：\n\n在ClassDesc.ofDescriptor方法中，对于任何描述符（包括原始类型），都会进行一系列检查（如空检查、数组深度检查），然后根据描述符长度创建PrimitiveClassDescImpl或ReferenceClassDescImpl实例。这导致每次调用时都可能创建新对象，尤其是原始类型描述符（如\"I\"、\"J\"）被频繁使用，造成不必要的对象分配。\n\n在ConstantUtils.parseMethodDescriptor方法中，解析方法描述符时返回List<String>，然后需要额外调用ClassDesc.ofDescriptor将字符串转换为ClassDesc，增加了中间步骤和对象创建。\n\n优化后：\n\n对于原始类型描述符（长度為1），直接通过Wrapper类获取预定义的ClassDesc实例（如Wrapper.forPrimitiveType('I').primitiveClassDescriptor()），避免了对象创建和检查开销。\n\n在ConstantUtils.parseMethodDescriptor方法中，直接返回List<ClassDesc>，并通过新增的resolveClassDesc方法在解析时直接生成ClassDesc，减少了字符串中间表示。\n\nWrapper类新增了primitiveTypeDesc字段和primitiveClassDescriptor方法，提供缓存的ClassDesc实例。\n\n优化效果：\n\n减少了原始类型ClassDesc对象的重复创建，降低了内存分配压力。\n\n提高了ClassDesc.ofDescriptor和方法描述符解析的执行效率，因为减少了条件检查和对象分配。\n\n通过微基准测试（新增的ClassDescFactories类）验证性能提升。\n\n优化思路：\n\n利用原始类型描述符固定的特性，将ClassDesc实例缓存到Wrapper类中，实现单例或重用。\n\n将描述符解析与对象创建合并，减少中间步骤，直接生成最终结果。"}
{"id": 935, "source": "riscv-dataset-excel", "optimization_type": "指令集优化 + 编译器优化", "optimization_description": "优化前：\n\nRISC-V架构缺少对VectorLoadShuffle和VectorRearrange操作的支持\n\n这些向量操作无法在RISC-V上有效利用硬件加速\n\n优化后：\n\n为RISC-V添加了向量洗牌和重排操作的硬件指令支持\n\n能够充分利用RISC-V向量扩展进行性能加速\n\n支持多种数据类型（BYTE、SHORT、INT、FLOAT、LONG、DOUBLE）\n\n优化思路：\n\n条件检查：确保向量长度vlen≥4（因为字节向量的最小大小为4）\n\n类型分发：根据不同的基本类型生成相应的向量扩展指令\n\n指令映射：将高级向量操作映射到具体的RISC-V向量指令", "original_code": "RISC-V架构缺少对VectorLoadShuffle和VectorRearrange操作的支持\n\n这些向量操作无法在RISC-V上有效利用硬件加速", "optimized_code": "// 条件检查优化\ncase Op_VectorLoadShuffle:\ncase Op_VectorRearrange:\nif (vlen < 4) {\n    return false;  // 确保硬件支持\n}\nbreak;\n\n// 指令生成优化\nif (bt == T_SHORT) {\n    __ vzext_vf2(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n} else if (bt == T_FLOAT || bt == T_INT) {\n    __ vzext_vf4(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n} else { // bt == T_DOUBLE || bt == T_LONG\n    __ vzext_vf8(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/d13e53346f3cd50bf7a4241ba86d2e21d9081bbe", "code_v0_no_empty_lines": "RISC-V架构缺少对VectorLoadShuffle和VectorRearrange操作的支持\n\n这些向量操作无法在RISC-V上有效利用硬件加速", "code_v1_no_empty_lines": "// 条件检查优化\ncase Op_VectorLoadShuffle:\ncase Op_VectorRearrange:\nif (vlen < 4) {\n    return false;  // 确保硬件支持\n}\nbreak;\n\n// 指令生成优化\nif (bt == T_SHORT) {\n    __ vzext_vf2(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n} else if (bt == T_FLOAT || bt == T_INT) {\n    __ vzext_vf4(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n} else { // bt == T_DOUBLE || bt == T_LONG\n    __ vzext_vf8(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n}", "target": "// 条件检查优化\ncase Op_VectorLoadShuffle:\ncase Op_VectorRearrange:\nif (vlen < 4) {\n    return false;  // 确保硬件支持\n}\nbreak;\n\n// 指令生成优化\nif (bt == T_SHORT) {\n    __ vzext_vf2(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n} else if (bt == T_FLOAT || bt == T_INT) {\n    __ vzext_vf4(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n} else { // bt == T_DOUBLE || bt == T_LONG\n    __ vzext_vf8(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：\n\nRISC-V架构缺少对VectorLoadShuffle和VectorRearrange操作的支持\n\n这些向量操作无法在RISC-V上有效利用硬件加速\n\n优化后：\n\n为RISC-V添加了向量洗牌和重排操作的硬件指令支持\n\n能够充分利用RISC-V向量扩展进行性能加速\n\n支持多种数据类型（BYTE、SHORT、INT、FLOAT、LONG、DOUBLE）\n\n优化思路：\n\n条件检查：确保向量长度vlen≥4（因为字节向量的最小大小为4）\n\n类型分发：根据不同的基本类型生成相应的向量扩展指令\n\n指令映射：将高级向量操作映射到具体的RISC-V向量指令"}
{"id": 936, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化", "optimization_description": "优化前: 在nmethod入口屏障（nmethod_entry_barrier）中，无论nmethod是否已解除武装（disarmed），都会先获取锁（通过锁机制检查状态），这可能导致不必要的锁竞争和开销。\n\n优化后: 在获取锁之前，先检查nmethod是否已解除武装（if (!is_armed(nm))）。如果已解除武装，则直接返回，避免锁操作。这减少了锁的获取次数。\n\n优化效果: 降低了锁争用，提高了高并发场景下的性能。尤其是在nmethod频繁被访问时，减少不必要的锁开销，从而提升应用程序的吞吐量和响应速度。\n\n优化思路: 通过提前检查共享状态（nmethod的武装状态临界区（锁保护区域），从而减少锁操作。这是一种常见的“先检查后操作”模式，用于优化并发代码。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 在BarrierSetNMethod::nmethod_entry_barrier中添加检查\nif (!is_armed(nm)) {\n    // Some other thread got here first and healed the oops and disarmed the nmethod. No need to continue.\n    return true;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/c30e040342c69a213bdff321fdcb0d27ff740489", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 在BarrierSetNMethod::nmethod_entry_barrier中添加检查\nif (!is_armed(nm)) {\n    // Some other thread got here first and healed the oops and disarmed the nmethod. No need to continue.\n    return true;\n}", "target": "// 在BarrierSetNMethod::nmethod_entry_barrier中添加检查\nif (!is_armed(nm)) {\n    // Some other thread got here first and healed the oops and disarmed the nmethod. No need to continue.\n    return true;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: 在nmethod入口屏障（nmethod_entry_barrier）中，无论nmethod是否已解除武装（disarmed），都会先获取锁（通过锁机制检查状态），这可能导致不必要的锁竞争和开销。\n\n优化后: 在获取锁之前，先检查nmethod是否已解除武装（if (!is_armed(nm))）。如果已解除武装，则直接返回，避免锁操作。这减少了锁的获取次数。\n\n优化效果: 降低了锁争用，提高了高并发场景下的性能。尤其是在nmethod频繁被访问时，减少不必要的锁开销，从而提升应用程序的吞吐量和响应速度。\n\n优化思路: 通过提前检查共享状态（nmethod的武装状态临界区（锁保护区域），从而减少锁操作。这是一种常见的“先检查后操作”模式，用于优化并发代码。"}
{"id": 937, "source": "riscv-dataset-excel", "optimization_type": "算法优化+内存优化", "optimization_description": "优化前: SHA3状态使用字节数组（state）存储，每次操作需通过ByteArrayAccess转换到长整型数组（lanes），引入额外拷贝和字节序处理开销。\n\n优化后: 直接使用长整型数组（long[] state）表示状态，并利用VarHandle处理小端序，消除了转换步骤。\n\n优化效果: 减少了内存拷贝和类型转换开销，提高了SHA3算法的吞吐量，尤其在处理大块数据时更明显。\n\n优化思路: 将数据表示与操作逻辑对齐，避免中间转换，利用直接内存访问优化。", "original_code": "// No original code extracted from description\n", "optimized_code": "private long[] state = new long[DM*DM]; // 直接替换byte[] state\nprivate void keccak() {\n  long a0 = state[0]; // 直接访问，无需转换\n  // ... 省略计算逻辑\n  state[0] = a0; // 直接写回\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/75bea280b9adb6dac9fefafbb3f4b212f100fbb5", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "private long[] state = new long[DM*DM]; // 直接替换byte[] state\nprivate void keccak() {\n  long a0 = state[0]; // 直接访问，无需转换\n  // ... 省略计算逻辑\n  state[0] = a0; // 直接写回\n}", "target": "private long[] state = new long[DM*DM]; // 直接替换byte[] state\nprivate void keccak() {\n  long a0 = state[0]; // 直接访问，无需转换\n  // ... 省略计算逻辑\n  state[0] = a0; // 直接写回\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: SHA3状态使用字节数组（state）存储，每次操作需通过ByteArrayAccess转换到长整型数组（lanes），引入额外拷贝和字节序处理开销。\n\n优化后: 直接使用长整型数组（long[] state）表示状态，并利用VarHandle处理小端序，消除了转换步骤。\n\n优化效果: 减少了内存拷贝和类型转换开销，提高了SHA3算法的吞吐量，尤其在处理大块数据时更明显。\n\n优化思路: 将数据表示与操作逻辑对齐，避免中间转换，利用直接内存访问优化。"}
{"id": 938, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前: 重定位信息（relocation info）中直接嵌入外部地址（如_target），每个重定位条目存储完整地址，占用空间大（64位下8字节）。\n\n优化后: 引入ExternalsRecorder全局表存储外部地址，重定位信息只存储索引（整数），减少内存占用。\n\n优化效果: 降低了编译代码的大小，提高了缓存局部性，从而减少内存访问开销。\n\n优化思路: 通过共享地址表避免重复存储地址，使用索引化压缩数据。", "original_code": "// No original code extracted from description\n", "optimized_code": "class ExternalsRecorder : public CHeapObj<mtCode> {\n  static int find_index(address adr static address at(int index);\n};\nvoid external_word_Relocation::pack_data_to(CodeSection* dest) {\n  int index = ExternalsRecorder::find_index(_target);\n  p = pack_1_int_to(p, index); // 存储索引而非地址\n}\nvoid external_word_Relocation::unpack_data() {\n  int index = unpack_1_int _target = ExternalsRecorder::at(index); // 通过索引检索地址\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/880e458a1072589ae199cc9204dcce9eab0f4eaa", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "class ExternalsRecorder : public CHeapObj<mtCode> {\n  static int find_index(address adr static address at(int index);\n};\nvoid external_word_Relocation::pack_data_to(CodeSection* dest) {\n  int index = ExternalsRecorder::find_index(_target);\n  p = pack_1_int_to(p, index); // 存储索引而非地址\n}\nvoid external_word_Relocation::unpack_data() {\n  int index = unpack_1_int _target = ExternalsRecorder::at(index); // 通过索引检索地址\n}", "target": "class ExternalsRecorder : public CHeapObj<mtCode> {\n  static int find_index(address adr static address at(int index);\n};\nvoid external_word_Relocation::pack_data_to(CodeSection* dest) {\n  int index = ExternalsRecorder::find_index(_target);\n  p = pack_1_int_to(p, index); // 存储索引而非地址\n}\nvoid external_word_Relocation::unpack_data() {\n  int index = unpack_1_int _target = ExternalsRecorder::at(index); // 通过索引检索地址\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: 重定位信息（relocation info）中直接嵌入外部地址（如_target），每个重定位条目存储完整地址，占用空间大（64位下8字节）。\n\n优化后: 引入ExternalsRecorder全局表存储外部地址，重定位信息只存储索引（整数），减少内存占用。\n\n优化效果: 降低了编译代码的大小，提高了缓存局部性，从而减少内存访问开销。\n\n优化思路: 通过共享地址表避免重复存储地址，使用索引化压缩数据。"}
{"id": 939, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+编译器优化", "optimization_description": "优化前: 传统x86架构使用有限的通用寄存器（如RAX、RCX等），寄存器保存/恢复依赖pusha/popa指令，效率较低，且不支持APX扩展的EGPRs（扩展通用寄存器）。\n\n优化后: 引入Intel APX（Advanced Performance Extensions）支持，增加了REX2前缀位定义，添加了push2、pop2等新指令用于批量寄存器操作，并优化了寄存器分配策略，支持更多寄存器（如R16-R31）。\n\n优化效果: 通过扩展寄存器集和优化保存/恢复操作，减少了内存访问次数，提高了寄存器利用率，尤其在寄存器压力大的代码段（如循环或复杂计算）中能提升性能。\n\n优化思路: 利用APX扩展的硬件特性，通过编译器支持更多寄存器，减少栈操作开销，并优化C2编译器的寄存器分配算法。", "original_code": "// No original code extracted from description\n", "optimized_code": "添加APX指令前缀位（PrefixBits枚举）：\n\n\nenum PrefixBits {\n  REX2BIT_B = 0x01,\n  REX2BIT_X = 0x02,\n  // ... 新增REX2相关位\n};\n\n新增寄存器操作指令（如push2）：\n\nvoid push2(Register src1, Register src2, bool with_ppx = false);\n\n优化寄存器保存/恢复（替代pusha）：\n\nvoid save_legacy_gprs() {\n  subq(rsp, 16 * wordSize);\n  movq(Address(rsp, 15 * wordSize), rax);\n  // ... 保存所有legacy GPRs\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/e5de26ddf0550da9e6d074d5b9ab4a943170adca", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "添加APX指令前缀位（PrefixBits枚举）：\n\n\nenum PrefixBits {\n  REX2BIT_B = 0x01,\n  REX2BIT_X = 0x02,\n  // ... 新增REX2相关位\n};\n\n新增寄存器操作指令（如push2）：\n\nvoid push2(Register src1, Register src2, bool with_ppx = false);\n\n优化寄存器保存/恢复（替代pusha）：\n\nvoid save_legacy_gprs() {\n  subq(rsp, 16 * wordSize);\n  movq(Address(rsp, 15 * wordSize), rax);\n  // ... 保存所有legacy GPRs\n}", "target": "添加APX指令前缀位（PrefixBits枚举）：\n\n\nenum PrefixBits {\n  REX2BIT_B = 0x01,\n  REX2BIT_X = 0x02,\n  // ... 新增REX2相关位\n};\n\n新增寄存器操作指令（如push2）：\n\nvoid push2(Register src1, Register src2, bool with_ppx = false);\n\n优化寄存器保存/恢复（替代pusha）：\n\nvoid save_legacy_gprs() {\n  subq(rsp, 16 * wordSize);\n  movq(Address(rsp, 15 * wordSize), rax);\n  // ... 保存所有legacy GPRs\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: 传统x86架构使用有限的通用寄存器（如RAX、RCX等），寄存器保存/恢复依赖pusha/popa指令，效率较低，且不支持APX扩展的EGPRs（扩展通用寄存器）。\n\n优化后: 引入Intel APX（Advanced Performance Extensions）支持，增加了REX2前缀位定义，添加了push2、pop2等新指令用于批量寄存器操作，并优化了寄存器分配策略，支持更多寄存器（如R16-R31）。\n\n优化效果: 通过扩展寄存器集和优化保存/恢复操作，减少了内存访问次数，提高了寄存器利用率，尤其在寄存器压力大的代码段（如循环或复杂计算）中能提升性能。\n\n优化思路: 利用APX扩展的硬件特性，通过编译器支持更多寄存器，减少栈操作开销，并优化C2编译器的寄存器分配算法。"}
{"id": 940, "source": "riscv-dataset-excel", "optimization_type": "条件分支优化+算法优化", "optimization_description": "优化前: 类继承关系检查（如instanceof）可能依赖线性扫描二级超类数组，时间复杂度为O(n)，在类层次深时性能差。\n\n优化后: 引入位图（bitmap）和哈希查找机制，通过population_count计算位图中设置位的数量，并使用up_secondary_supers_table`进行快速查找，减少比较次数。\n\n优化效果: 将类继承检查的平均时间复杂度从O(n)降低到接近O(1)，减少了条件分支误预测，提升了多态调用性能。\n\n优化思路: 将超类信息编码到位图中，通过位操作和哈希碰撞处理来加速查找，类似布隆过滤器原理。", "original_code": "// No original code extracted from description\n", "optimized_code": "void population_count(Register dst, Register src, Register tmp1, Register tmp2) {\n  if (UsePopCountInstruction) {\n    cpop(dst, src); // 使用硬件指令\n  } else {\n    // 软件实现：循环计算设置位的数量\n  }\n}\nbool MacroAssembler::lookup_secondary_supers_table(...) {\n  // 使用位图检查超类是否可能存在\n  test_bit(t0, r_bitmap, bit);\n  beqz(t0, L_fallthrough);\n  // 哈希查找逻辑\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/001d6860199436c5fb14bd681d640d462b472015", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "void population_count(Register dst, Register src, Register tmp1, Register tmp2) {\n  if (UsePopCountInstruction) {\n    cpop(dst, src); // 使用硬件指令\n  } else {\n    // 软件实现：循环计算设置位的数量\n  }\n}\nbool MacroAssembler::lookup_secondary_supers_table(...) {\n  // 使用位图检查超类是否可能存在\n  test_bit(t0, r_bitmap, bit);\n  beqz(t0, L_fallthrough);\n  // 哈希查找逻辑\n}", "target": "void population_count(Register dst, Register src, Register tmp1, Register tmp2) {\n  if (UsePopCountInstruction) {\n    cpop(dst, src); // 使用硬件指令\n  } else {\n    // 软件实现：循环计算设置位的数量\n  }\n}\nbool MacroAssembler::lookup_secondary_supers_table(...) {\n  // 使用位图检查超类是否可能存在\n  test_bit(t0, r_bitmap, bit);\n  beqz(t0, L_fallthrough);\n  // 哈希查找逻辑\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: 类继承关系检查（如instanceof）可能依赖线性扫描二级超类数组，时间复杂度为O(n)，在类层次深时性能差。\n\n优化后: 引入位图（bitmap）和哈希查找机制，通过population_count计算位图中设置位的数量，并使用up_secondary_supers_table`进行快速查找，减少比较次数。\n\n优化效果: 将类继承检查的平均时间复杂度从O(n)降低到接近O(1)，减少了条件分支误预测，提升了多态调用性能。\n\n优化思路: 将超类信息编码到位图中，通过位操作和哈希碰撞处理来加速查找，类似布隆过滤器原理。"}
{"id": 941, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "优化前: 字节反转操作（如ReverseBytesI和ReverseBytesL）可能依赖多步软件实现（如移位和掩码），指令数多，效率低。\n\n优化后: 利用RISC-V Zbb扩展的硬件指令（如revb_w_w用于32位反转、rev8用于64位反转）直接完成操作。\n\n优化效果: 将字节反转操作从多条指令减少到单条指令，大幅降低了延迟和CPU周期，提升了序列化/反序列化性能。\n\n优化思路: 通过硬件指令替代软件算法，利用指令集扩展的并行处理能力。", "original_code": "// No original code extracted from description\n", "optimized_code": "instruct bytes_reverse_int_b(iRegINoSp dst, iRegIorL2I src) {\n  match(Set dst (ReverseBytesI src));\n  insALU_COST * 2);\n  format %{ \"revb_w_w $dst, $src\" %}\n  ins_encode %{\n    __ revb_w_w(as_Register($dst$$reg), as_Register($src$$reg));\n  %}\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/642084629a9a793a055cba8a950fdb61b7450093", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "instruct bytes_reverse_int_b(iRegINoSp dst, iRegIorL2I src) {\n  match(Set dst (ReverseBytesI src));\n  insALU_COST * 2);\n  format %{ \"revb_w_w $dst, $src\" %}\n  ins_encode %{\n    __ revb_w_w(as_Register($dst$$reg), as_Register($src$$reg));\n  %}\n}", "target": "instruct bytes_reverse_int_b(iRegINoSp dst, iRegIorL2I src) {\n  match(Set dst (ReverseBytesI src));\n  insALU_COST * 2);\n  format %{ \"revb_w_w $dst, $src\" %}\n  ins_encode %{\n    __ revb_w_w(as_Register($dst$$reg), as_Register($src$$reg));\n  %}\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: 字节反转操作（如ReverseBytesI和ReverseBytesL）可能依赖多步软件实现（如移位和掩码），指令数多，效率低。\n\n优化后: 利用RISC-V Zbb扩展的硬件指令（如revb_w_w用于32位反转、rev8用于64位反转）直接完成操作。\n\n优化效果: 将字节反转操作从多条指令减少到单条指令，大幅降低了延迟和CPU周期，提升了序列化/反序列化性能。\n\n优化思路: 通过硬件指令替代软件算法，利用指令集扩展的并行处理能力。"}
{"id": 942, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+编译器优化", "optimization_description": "优化前：\n\n在提交前，riscv_v.ad文件中只有一个通用的浮点加法归约指令（reduce_addF和reduce_addD），无论归约操作是否需要严格顺序，都使用有序归约指令vfredosum.vs（有序浮点归约）。\n\n这种实现无法充分利用非严格有序场景的优化机会，因为有序指令可能限制硬件的并行执行能力。\n\n优化后：\n\n提交后，将浮点加法归约指令拆分为两个版本：\n\nreduce_addF_ordered：用于需要严格顺序的场景（如自动向量化生成的代码），使用vfredosum.vs指令。\n\nreduce_addF_unordered：用于非严格顺序的场景（如Vector API生成的代码），使用vfredusum.vs指令（无序浮点归约）。\n\n类似地，双精度版本（reduce_addD）也拆分为有序和无序版本。\n\n优化效果：\n\n性能提升：在非严格有序的归约操作中，使用无序指令vfredusum.vs允许硬件更灵活地调度浮点操作（例如，并行执行部分归约），从而减少延迟并提高吞吐量。这对于向量化代码尤其重要，因为归约操作是常见瓶颈。\n\n正确性保证：在严格有序场景中，继续使用有序指令，确保结果与标量代码一致，避免精度问题。\n\n开销：优化本身几乎没有额外开销，因为requires_strict_order标志在编译时即可确定，指令选择通过谓词（predicate）在编译阶段完成，不引入运行时分支。", "original_code": "在提交前，riscv_v.ad文件中只有一个通用的浮点加法归约指令（reduce_addF和reduce_addD），无论归约操作是否需要严格顺序，都使用有序归约指令vfredosum.vs（有序浮点归约）。\n\n这种实现无法充分利用非严格有序场景的优化机会，因为有序指令可能限制硬件的并行执行能力。", "optimized_code": "// 新增有序和无序指令，替换原来的通用指令\n+// Distinguish two cases based on requires_strict_order\n+// 1. Non strictly-ordered AddReductionVF/D. For example, AddReductionVF/D\n+// generated by Vector API. It is more beneficial performance-wise to do\n+// an unordered FP reduction sum (vfredusum.vs).\n+// 2. Strictly-ordered AddReductionVF/D. For example, AddReductionVF/D\n+// generated by auto-vectorization. Must do an ordered FP reduction sum\n+// (vfredosum.vs).\n\n+instruct reduce_addF_ordered(fRegF dst, fRegF src1, vReg src2, vReg tmp) %{\n+  predicate(n->as_Reduction()->requires_strict_order()); // 谓词检查：需要严格顺序\n+  match(Set dst (AddReductionVF src1 src2));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addF_ordered $dst, $src1, $src2 # KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this, $src2));\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1$$FloatRegister);\n+    __ vfredosum_vs(as_VectorRegister($tmp$$reg), as_VectorRegister($src2$$reg), // 使用有序指令\n+                    as_VectorRegister($tmp$$reg));\n+    __ vfmv_f_s($dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n\n+instruct reduce_addF_unordered(fRegF dst, fRegF src1, vReg src2, vReg tmp) %{\n+  predicate(!n->as_Reduction()->requires_strict_order()); // 谓词检查：非严格顺序\n+  match(Set dst (AddReductionVF src1 src2));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addF_unordered $dst, $src1, $src2 # KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this, $src2));\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1$$FloatRegister);\n+    __ vfredusum_vs(as_VectorRegister($tmp$$reg), as_VectorRegister($src2$$reg), // 使用无序指令\n+                    as_VectorRegister($tmp$$reg));\n+    __ vfmv_f_s($dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n\n// 类似地，双精度版本也进行了拆分\n-instruct reduce_addF(fRegF dst, fRegF src1, vReg src2, vReg tmp) %{\n-  match(Set dst (AddReductionVF src1 src2));\n-  effect(TEMP tmp);\n-  ins_cost(VEC_COST);\n-  format %{ \"reduce_addF $dst, $src1, $src2 # KILL $tmp\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this, $src2));\n-    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1$$FloatRegister);\n-    __ vfredosum_vs(as_VectorRegister($tmp$$reg), as_VectorRegister($src2$$reg),\n-                    as_VectorRegister($tmp$$reg));\n-    __ vfmv_f_s($dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}", "source_url": "https://github.com/openjdk/riscv-port/commit/e95f092862307c248bbd93e7026cbd92053fb4c9", "code_v0_no_empty_lines": "在提交前，riscv_v.ad文件中只有一个通用的浮点加法归约指令（reduce_addF和reduce_addD），无论归约操作是否需要严格顺序，都使用有序归约指令vfredosum.vs（有序浮点归约）。\n\n这种实现无法充分利用非严格有序场景的优化机会，因为有序指令可能限制硬件的并行执行能力。", "code_v1_no_empty_lines": "// 新增有序和无序指令，替换原来的通用指令\n+// Distinguish two cases based on requires_strict_order\n+// 1. Non strictly-ordered AddReductionVF/D. For example, AddReductionVF/D\n+// generated by Vector API. It is more beneficial performance-wise to do\n+// an unordered FP reduction sum (vfredusum.vs).\n+// 2. Strictly-ordered AddReductionVF/D. For example, AddReductionVF/D\n+// generated by auto-vectorization. Must do an ordered FP reduction sum\n+// (vfredosum.vs).\n\n+instruct reduce_addF_ordered(fRegF dst, fRegF src1, vReg src2, vReg tmp) %{\n+  predicate(n->as_Reduction()->requires_strict_order()); // 谓词检查：需要严格顺序\n+  match(Set dst (AddReductionVF src1 src2));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addF_ordered $dst, $src1, $src2 # KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this, $src2));\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1$$FloatRegister);\n+    __ vfredosum_vs(as_VectorRegister($tmp$$reg), as_VectorRegister($src2$$reg), // 使用有序指令\n+                    as_VectorRegister($tmp$$reg));\n+    __ vfmv_f_s($dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n\n+instruct reduce_addF_unordered(fRegF dst, fRegF src1, vReg src2, vReg tmp) %{\n+  predicate(!n->as_Reduction()->requires_strict_order()); // 谓词检查：非严格顺序\n+  match(Set dst (AddReductionVF src1 src2));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addF_unordered $dst, $src1, $src2 # KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this, $src2));\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1$$FloatRegister);\n+    __ vfredusum_vs(as_VectorRegister($tmp$$reg), as_VectorRegister($src2$$reg), // 使用无序指令\n+                    as_VectorRegister($tmp$$reg));\n+    __ vfmv_f_s($dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n\n// 类似地，双精度版本也进行了拆分\n-instruct reduce_addF(fRegF dst, fRegF src1, vReg src2, vReg tmp) %{\n-  match(Set dst (AddReductionVF src1 src2));\n-  effect(TEMP tmp);\n-  ins_cost(VEC_COST);\n-  format %{ \"reduce_addF $dst, $src1, $src2 # KILL $tmp\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this, $src2));\n-    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1$$FloatRegister);\n-    __ vfredosum_vs(as_VectorRegister($tmp$$reg), as_VectorRegister($src2$$reg),\n-                    as_VectorRegister($tmp$$reg));\n-    __ vfmv_f_s($dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}", "target": "// 新增有序和无序指令，替换原来的通用指令\n+// Distinguish two cases based on requires_strict_order\n+// 1. Non strictly-ordered AddReductionVF/D. For example, AddReductionVF/D\n+// generated by Vector API. It is more beneficial performance-wise to do\n+// an unordered FP reduction sum (vfredusum.vs).\n+// 2. Strictly-ordered AddReductionVF/D. For example, AddReductionVF/D\n+// generated by auto-vectorization. Must do an ordered FP reduction sum\n+// (vfredosum.vs).\n\n+instruct reduce_addF_ordered(fRegF dst, fRegF src1, vReg src2, vReg tmp) %{\n+  predicate(n->as_Reduction()->requires_strict_order()); // 谓词检查：需要严格顺序\n+  match(Set dst (AddReductionVF src1 src2));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addF_ordered $dst, $src1, $src2 # KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this, $src2));\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1$$FloatRegister);\n+    __ vfredosum_vs(as_VectorRegister($tmp$$reg), as_VectorRegister($src2$$reg), // 使用有序指令\n+                    as_VectorRegister($tmp$$reg));\n+    __ vfmv_f_s($dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n\n+instruct reduce_addF_unordered(fRegF dst, fRegF src1, vReg src2, vReg tmp) %{\n+  predicate(!n->as_Reduction()->requires_strict_order()); // 谓词检查：非严格顺序\n+  match(Set dst (AddReductionVF src1 src2));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addF_unordered $dst, $src1, $src2 # KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this, $src2));\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1$$FloatRegister);\n+    __ vfredusum_vs(as_VectorRegister($tmp$$reg), as_VectorRegister($src2$$reg), // 使用无序指令\n+                    as_VectorRegister($tmp$$reg));\n+    __ vfmv_f_s($dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n\n// 类似地，双精度版本也进行了拆分\n-instruct reduce_addF(fRegF dst, fRegF src1, vReg src2, vReg tmp) %{\n-  match(Set dst (AddReductionVF src1 src2));\n-  effect(TEMP tmp);\n-  ins_cost(VEC_COST);\n-  format %{ \"reduce_addF $dst, $src1, $src2 # KILL $tmp\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this, $src2));\n-    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1$$FloatRegister);\n-    __ vfredosum_vs(as_VectorRegister($tmp$$reg), as_VectorRegister($src2$$reg),\n-                    as_VectorRegister($tmp$$reg));\n-    __ vfmv_f_s($dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：\n\n在提交前，riscv_v.ad文件中只有一个通用的浮点加法归约指令（reduce_addF和reduce_addD），无论归约操作是否需要严格顺序，都使用有序归约指令vfredosum.vs（有序浮点归约）。\n\n这种实现无法充分利用非严格有序场景的优化机会，因为有序指令可能限制硬件的并行执行能力。\n\n优化后：\n\n提交后，将浮点加法归约指令拆分为两个版本：\n\nreduce_addF_ordered：用于需要严格顺序的场景（如自动向量化生成的代码），使用vfredosum.vs指令。\n\nreduce_addF_unordered：用于非严格顺序的场景（如Vector API生成的代码），使用vfredusum.vs指令（无序浮点归约）。\n\n类似地，双精度版本（reduce_addD）也拆分为有序和无序版本。\n\n优化效果：\n\n性能提升：在非严格有序的归约操作中，使用无序指令vfredusum.vs允许硬件更灵活地调度浮点操作（例如，并行执行部分归约），从而减少延迟并提高吞吐量。这对于向量化代码尤其重要，因为归约操作是常见瓶颈。\n\n正确性保证：在严格有序场景中，继续使用有序指令，确保结果与标量代码一致，避免精度问题。\n\n开销：优化本身几乎没有额外开销，因为requires_strict_order标志在编译时即可确定，指令选择通过谓词（predicate）在编译阶段完成，不引入运行时分支。"}
{"id": 943, "source": "riscv-dataset-excel", "optimization_type": "条件分支优化", "optimization_description": "性能提升：移除了条件分支，减少了分支预测错误的风险，使代码执行更直接。对于频繁调用的函数，这可以带来轻微的性能提升，尤其是在G1垃圾收集器的并发标记阶段，其中区域更新操作可能频繁发生。\n\n代码简化：逻辑更清晰，减少了代码复杂度，便于维护。\n\n不变式强化：通过断言明确了函数前置条件，提高了代码的可靠性。", "original_code": "// No original code extracted from description\n", "optimized_code": "inline void G1ConcurrentMark::update_top_at_rebuild_start(G1HeapRegion* r) {\n+  assert(r->is_old() || r->is_humongous(), \"precondition\");\n   uint const region = r->hrm_index();\n   assert(region < _g1h->max_reserved_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n   assert(_top_at_rebuild_starts[region] == nullptr, \"TARS for region %u has already been set to \" PTR_FORMAT \" should be null\", region, p2i(_top_at_rebuild_starts[region]));\n-  G1RemSetTrackingPolicy* tracker = _g1h->policy()->remset_tracker();\n-  if (tracker->needs_scan_for_rebuild(r)) {\n-    _top_at_rebuild_starts[region] = r->top();\n-  } else {\n-    // Leave TARS at null.\n-  }\n+  _top_at_rebuild_starts[region] = r->top();\n }\n此外，删除了G1RemSetTrackingPolicy::needs_scan_for_rebuild函数，因为不再需要：\n\ndiff\n\n- bool G1RemSetTrackingPolicy::needs_scan_for_rebuild(G1HeapRegion* r) const {\n-   // All non-free and non-young regions need to be scanned for references;\n-   // At every gc we gather references to other regions in young.\n-   // Free regions trivially do not need scanning because they do not contain live\n-   // objects.\n-   return !(r->is_young() || r->is_free());\n- }", "source_url": "https://github.com/openjdk/riscv-port/commit/0665195e59889c3f8dc5ade6521d6ca2eb4ca8b4", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "inline void G1ConcurrentMark::update_top_at_rebuild_start(G1HeapRegion* r) {\n+  assert(r->is_old() || r->is_humongous(), \"precondition\");\n   uint const region = r->hrm_index();\n   assert(region < _g1h->max_reserved_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n   assert(_top_at_rebuild_starts[region] == nullptr, \"TARS for region %u has already been set to \" PTR_FORMAT \" should be null\", region, p2i(_top_at_rebuild_starts[region]));\n-  G1RemSetTrackingPolicy* tracker = _g1h->policy()->remset_tracker();\n-  if (tracker->needs_scan_for_rebuild(r)) {\n-    _top_at_rebuild_starts[region] = r->top();\n-  } else {\n-    // Leave TARS at null.\n-  }\n+  _top_at_rebuild_starts[region] = r->top();\n }\n此外，删除了G1RemSetTrackingPolicy::needs_scan_for_rebuild函数，因为不再需要：\n\ndiff\n\n- bool G1RemSetTrackingPolicy::needs_scan_for_rebuild(G1HeapRegion* r) const {\n-   // All non-free and non-young regions need to be scanned for references;\n-   // At every gc we gather references to other regions in young.\n-   // Free regions trivially do not need scanning because they do not contain live\n-   // objects.\n-   return !(r->is_young() || r->is_free());\n- }", "target": "inline void G1ConcurrentMark::update_top_at_rebuild_start(G1HeapRegion* r) {\n+  assert(r->is_old() || r->is_humongous(), \"precondition\");\n   uint const region = r->hrm_index();\n   assert(region < _g1h->max_reserved_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n   assert(_top_at_rebuild_starts[region] == nullptr, \"TARS for region %u has already been set to \" PTR_FORMAT \" should be null\", region, p2i(_top_at_rebuild_starts[region]));\n-  G1RemSetTrackingPolicy* tracker = _g1h->policy()->remset_tracker();\n-  if (tracker->needs_scan_for_rebuild(r)) {\n-    _top_at_rebuild_starts[region] = r->top();\n-  } else {\n-    // Leave TARS at null.\n-  }\n+  _top_at_rebuild_starts[region] = r->top();\n }\n此外，删除了G1RemSetTrackingPolicy::needs_scan_for_rebuild函数，因为不再需要：\n\ndiff\n\n- bool G1RemSetTrackingPolicy::needs_scan_for_rebuild(G1HeapRegion* r) const {\n-   // All non-free and non-young regions need to be scanned for references;\n-   // At every gc we gather references to other regions in young.\n-   // Free regions trivially do not need scanning because they do not contain live\n-   // objects.\n-   return !(r->is_young() || r->is_free());\n- }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升：移除了条件分支，减少了分支预测错误的风险，使代码执行更直接。对于频繁调用的函数，这可以带来轻微的性能提升，尤其是在G1垃圾收集器的并发标记阶段，其中区域更新操作可能频繁发生。\n\n代码简化：逻辑更清晰，减少了代码复杂度，便于维护。\n\n不变式强化：通过断言明确了函数前置条件，提高了代码的可靠性。"}
{"id": 944, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "内联消除了函数调用开销（如寄存器保存、参数传递、返回指令等），对于频繁调用的小函数（如cleared_all_soft_refs只是简单设置一个布尔值），性能提升可能较明显。在垃圾收集器（GC）的软引用策略中，这些方法可能被频繁调用（例如在GC周期中），内联可以减少累积开销。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 在 softRefPolicy.hpp 中的修改：\nclass SoftRefPolicy {\n public:\n-  SoftRefPolicy();  // 声明，定义在 .cpp 文件\n+  SoftRefPolicy() :    // 内联构造函数\n+    _should_clear_all_soft_refs(false),\n+    _all_soft_refs_clear(false) {}\n\n-  virtual void cleared_all_soft_refs();  // 声明，定义在 .cpp 文件\n+  void cleared_all_soft_refs() {  // 内联方法\n+    _all_soft_refs_clear = true;\n+  }\n};", "source_url": "https://github.com/openjdk/riscv-port/commit/ef4ec2d3b061c0eeea1aba88135e8d0e272b3bea", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 在 softRefPolicy.hpp 中的修改：\nclass SoftRefPolicy {\n public:\n-  SoftRefPolicy();  // 声明，定义在 .cpp 文件\n+  SoftRefPolicy() :    // 内联构造函数\n+    _should_clear_all_soft_refs(false),\n+    _all_soft_refs_clear(false) {}\n\n-  virtual void cleared_all_soft_refs();  // 声明，定义在 .cpp 文件\n+  void cleared_all_soft_refs() {  // 内联方法\n+    _all_soft_refs_clear = true;\n+  }\n};", "target": "// 在 softRefPolicy.hpp 中的修改：\nclass SoftRefPolicy {\n public:\n-  SoftRefPolicy();  // 声明，定义在 .cpp 文件\n+  SoftRefPolicy() :    // 内联构造函数\n+    _should_clear_all_soft_refs(false),\n+    _all_soft_refs_clear(false) {}\n\n-  virtual void cleared_all_soft_refs();  // 声明，定义在 .cpp 文件\n+  void cleared_all_soft_refs() {  // 内联方法\n+    _all_soft_refs_clear = true;\n+  }\n};", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "内联消除了函数调用开销（如寄存器保存、参数传递、返回指令等），对于频繁调用的小函数（如cleared_all_soft_refs只是简单设置一个布尔值），性能提升可能较明显。在垃圾收集器（GC）的软引用策略中，这些方法可能被频繁调用（例如在GC周期中），内联可以减少累积开销。"}
{"id": 945, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "优化前：在is_vector_use函数中，仅通过assert语句（在调试模式下）检查归约操作（reduction）的内部连接性（internal connection）。如果断言失败，程序会终止，但发布版中无检查，可能导致错误向量化。\n\n优化后：将断言检查改为运行时检查，在循环中验证每个节点的内部连接性。如果连接不成立，立即返回false，避免无效向量化。\n\n优化效果：修复了JDK-8325155引入的回归问题，防止SuperWord优化在内部连接不满足时错误应用向量化，从而提高代码正确性和稳定性。这避免了潜在的性能下降（如错误向量化导致的开销或错误结果）。优化思路是通过运行时检查确保向量化仅在安全条件下进行，提升编译器优化的可靠性。", "original_code": "在is_vector_use函数中，仅通过assert语句（在调试模式下）检查归约操作（reduction）的内部连接性（internal connection）。如果断言失败，程序会终止，但发布版中无检查，可能导致错误向量化。", "optimized_code": "// 修改文件: src/hotspot/share/opto/superword.cpp\n// 优化前:\n#ifdef ASSERT\nfor (uint i = 1; i < u_pk->size(); i++) {\n  assert(u_pk->at(i - 1) == u_pk->at(i)->in(1), \"internal connection\");\n}\n#endif\n// 优化后:\nfor (uint i = 1; i < u_pk->size(); i++) {\n  if (u_pk->at(i - 1) != u_pk->at(i)->in(1)) {\n    return false; // not internally connected\n  }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/e965d70a7425bec78620a2ca8bfaca3c392edf6a", "code_v0_no_empty_lines": "在is_vector_use函数中，仅通过assert语句（在调试模式下）检查归约操作（reduction）的内部连接性（internal connection）。如果断言失败，程序会终止，但发布版中无检查，可能导致错误向量化。", "code_v1_no_empty_lines": "// 修改文件: src/hotspot/share/opto/superword.cpp\n// 优化前:\n#ifdef ASSERT\nfor (uint i = 1; i < u_pk->size(); i++) {\n  assert(u_pk->at(i - 1) == u_pk->at(i)->in(1), \"internal connection\");\n}\n#endif\n// 优化后:\nfor (uint i = 1; i < u_pk->size(); i++) {\n  if (u_pk->at(i - 1) != u_pk->at(i)->in(1)) {\n    return false; // not internally connected\n  }\n}", "target": "// 修改文件: src/hotspot/share/opto/superword.cpp\n// 优化前:\n#ifdef ASSERT\nfor (uint i = 1; i < u_pk->size(); i++) {\n  assert(u_pk->at(i - 1) == u_pk->at(i)->in(1), \"internal connection\");\n}\n#endif\n// 优化后:\nfor (uint i = 1; i < u_pk->size(); i++) {\n  if (u_pk->at(i - 1) != u_pk->at(i)->in(1)) {\n    return false; // not internally connected\n  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在is_vector_use函数中，仅通过assert语句（在调试模式下）检查归约操作（reduction）的内部连接性（internal connection）。如果断言失败，程序会终止，但发布版中无检查，可能导致错误向量化。\n\n优化后：将断言检查改为运行时检查，在循环中验证每个节点的内部连接性。如果连接不成立，立即返回false，避免无效向量化。\n\n优化效果：修复了JDK-8325155引入的回归问题，防止SuperWord优化在内部连接不满足时错误应用向量化，从而提高代码正确性和稳定性。这避免了潜在的性能下降（如错误向量化导致的开销或错误结果）。优化思路是通过运行时检查确保向量化仅在安全条件下进行，提升编译器优化的可靠性。"}
{"id": 946, "source": "riscv-dataset-excel", "optimization_type": "内存优化+条件分支优化", "optimization_description": "优化前：PPC64架构的secondary super类型检查可能依赖简单的线性扫描或缓存，在高并发场景下扩展性差（如锁竞争或频繁缓存未命中）。\n\n优化后：引入基于位图（bitmap）的哈希查找机制。通过位图快速过滤不可能匹配的super类型，减少不必要的内存访问；同时使用线性探测处理冲突，减少分支预测错误。新增函数如lookup_secondary_supers_table实现了高效查找。\n\n优化效果：显著提高类型检查的性能和扩展性，减少多线程环境下的查找时间。优化思路是利用位图压缩信息，通过位操作和线性扫描替代全表扫描，降低缓存未命中率和分支误预测。此外，添加验证逻辑确保正确性。", "original_code": "PPC64架构的secondary super类型检查可能依赖简单的线性扫描或缓存，在高并发场景下扩展性差（如锁竞争或频繁缓存未命中）。", "optimized_code": "// 修改文件: src/hotspot/cpu/ppc/macroAssembler_ppc.cpp\n// 新增函数 lookup_secondary_supers_table 的关键部分:\nvoid MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass, ...) {\n  // 1. 加载位图并检查特定位是否设置\n  ld(r_bitmap, in_bytes(Klass::bitmap_offset()), r_sub_klass);\n  sldi_(r_array_index, r_bitmap, shift_count); // 通过移位测试位\n  bge(CCR0, L_done); // 如果位未设置，直接跳过查找\n  // 2. 位设置时，访问secondary supers数组并比较\n  ld(r_array_base, in_bytes(Klass::secondary_supers_offset()), r_sub_klass);\n  ldx(result, r_array_base, r_array_index);\n  xor_(result, result, r_super_klass);\n  beq(CCR0, L_done); // 匹配成功\n  // 3. 处理冲突的慢路径\n  address stub = StubRoutines::lookup_secondary_supers_table_slow_path_stub();\n  // ... 调用慢路径处理线性探测\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/0d1080d194c596dc74dd8b173b18b14cc71e1b52", "code_v0_no_empty_lines": "PPC64架构的secondary super类型检查可能依赖简单的线性扫描或缓存，在高并发场景下扩展性差（如锁竞争或频繁缓存未命中）。", "code_v1_no_empty_lines": "// 修改文件: src/hotspot/cpu/ppc/macroAssembler_ppc.cpp\n// 新增函数 lookup_secondary_supers_table 的关键部分:\nvoid MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass, ...) {\n  // 1. 加载位图并检查特定位是否设置\n  ld(r_bitmap, in_bytes(Klass::bitmap_offset()), r_sub_klass);\n  sldi_(r_array_index, r_bitmap, shift_count); // 通过移位测试位\n  bge(CCR0, L_done); // 如果位未设置，直接跳过查找\n  // 2. 位设置时，访问secondary supers数组并比较\n  ld(r_array_base, in_bytes(Klass::secondary_supers_offset()), r_sub_klass);\n  ldx(result, r_array_base, r_array_index);\n  xor_(result, result, r_super_klass);\n  beq(CCR0, L_done); // 匹配成功\n  // 3. 处理冲突的慢路径\n  address stub = StubRoutines::lookup_secondary_supers_table_slow_path_stub();\n  // ... 调用慢路径处理线性探测\n}", "target": "// 修改文件: src/hotspot/cpu/ppc/macroAssembler_ppc.cpp\n// 新增函数 lookup_secondary_supers_table 的关键部分:\nvoid MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass, ...) {\n  // 1. 加载位图并检查特定位是否设置\n  ld(r_bitmap, in_bytes(Klass::bitmap_offset()), r_sub_klass);\n  sldi_(r_array_index, r_bitmap, shift_count); // 通过移位测试位\n  bge(CCR0, L_done); // 如果位未设置，直接跳过查找\n  // 2. 位设置时，访问secondary supers数组并比较\n  ld(r_array_base, in_bytes(Klass::secondary_supers_offset()), r_sub_klass);\n  ldx(result, r_array_base, r_array_index);\n  xor_(result, result, r_super_klass);\n  beq(CCR0, L_done); // 匹配成功\n  // 3. 处理冲突的慢路径\n  address stub = StubRoutines::lookup_secondary_supers_table_slow_path_stub();\n  // ... 调用慢路径处理线性探测\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PPC64架构的secondary super类型检查可能依赖简单的线性扫描或缓存，在高并发场景下扩展性差（如锁竞争或频繁缓存未命中）。\n\n优化后：引入基于位图（bitmap）的哈希查找机制。通过位图快速过滤不可能匹配的super类型，减少不必要的内存访问；同时使用线性探测处理冲突，减少分支预测错误。新增函数如lookup_secondary_supers_table实现了高效查找。\n\n优化效果：显著提高类型检查的性能和扩展性，减少多线程环境下的查找时间。优化思路是利用位图压缩信息，通过位操作和线性扫描替代全表扫描，降低缓存未命中率和分支误预测。此外，添加验证逻辑确保正确性。"}
{"id": 947, "source": "riscv-dataset-excel", "optimization_type": "运行时优化", "optimization_description": "优化前: 通过 getAnnotation(Class)方法获取注解，该方法返回动态代理对象，然后调用注解方法（如 value()）。这涉及反射和动态代理创建，有性能开销。\n\n优化后: 新增 getAnnotationValue方法，直接获取注解值，避免创建动态代理对象。原有方法（如 getLabel()）被重写为直接调用新方法。\n\n优化效果: 减少了动态代理创建和反射调用的开销，提高了注解访问速度，尤其在高频访问的JFR事件处理中。同时减少了内存分配（避免代理对象）。\n\n优化思路: 动态代理在Java中基于反射实现，开销较大。通过直接访问注解的底层值（从 AnnotationElement获取），避免了反射和代理对象创建，提升了效率。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 在 AnnotationConstruct.java 中新增方法：\npublic <T> T getAnnotationValue(Class<? extends java.lang.annotation.Annotation> clazz, T defaultValue) {\n  AnnotationElement ae = getAnnotationElement(clazz);\n  if (ae == null) {\n    return defaultValue;\n  }\n  return (T) ae.getValues().get(0); // 直接获取值，无需代理\n}\n\n// 优化前：getLabel 使用动态代理\npublic String getLabel() {\n  Label label = getAnnotation(Label.class);\n  if (label == null) {\n    return null;\n  }\n  return label.value(); // 通过代理对象调用\n}\n\n// 优化后：getLabel 直接调用 getAnnotationValue\npublic String getLabel() {\n  return getAnnotationValue(Label.class, null);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/8d78e8cadcc06aea7179ec97d3bf8b7cee63b447", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 在 AnnotationConstruct.java 中新增方法：\npublic <T> T getAnnotationValue(Class<? extends java.lang.annotation.Annotation> clazz, T defaultValue) {\n  AnnotationElement ae = getAnnotationElement(clazz);\n  if (ae == null) {\n    return defaultValue;\n  }\n  return (T) ae.getValues().get(0); // 直接获取值，无需代理\n}\n\n// 优化前：getLabel 使用动态代理\npublic String getLabel() {\n  Label label = getAnnotation(Label.class);\n  if (label == null) {\n    return null;\n  }\n  return label.value(); // 通过代理对象调用\n}\n\n// 优化后：getLabel 直接调用 getAnnotationValue\npublic String getLabel() {\n  return getAnnotationValue(Label.class, null);\n}", "target": "// 在 AnnotationConstruct.java 中新增方法：\npublic <T> T getAnnotationValue(Class<? extends java.lang.annotation.Annotation> clazz, T defaultValue) {\n  AnnotationElement ae = getAnnotationElement(clazz);\n  if (ae == null) {\n    return defaultValue;\n  }\n  return (T) ae.getValues().get(0); // 直接获取值，无需代理\n}\n\n// 优化前：getLabel 使用动态代理\npublic String getLabel() {\n  Label label = getAnnotation(Label.class);\n  if (label == null) {\n    return null;\n  }\n  return label.value(); // 通过代理对象调用\n}\n\n// 优化后：getLabel 直接调用 getAnnotationValue\npublic String getLabel() {\n  return getAnnotationValue(Label.class, null);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: 通过 getAnnotation(Class)方法获取注解，该方法返回动态代理对象，然后调用注解方法（如 value()）。这涉及反射和动态代理创建，有性能开销。\n\n优化后: 新增 getAnnotationValue方法，直接获取注解值，避免创建动态代理对象。原有方法（如 getLabel()）被重写为直接调用新方法。\n\n优化效果: 减少了动态代理创建和反射调用的开销，提高了注解访问速度，尤其在高频访问的JFR事件处理中。同时减少了内存分配（避免代理对象）。\n\n优化思路: 动态代理在Java中基于反射实现，开销较大。通过直接访问注解的底层值（从 AnnotationElement获取），避免了反射和代理对象创建，提升了效率。"}
{"id": 948, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "优化前: mem_allocate函数先尝试TLAB快速分配，如果失败则调用 mem_allocate_slow函数。这涉及一次函数调用开销，包括参数传递、栈帧设置和返回指令。\n\n优化后: mem_allocate_slow的逻辑被直接内联到 mem_allocate函数中，消除了函数调用。代码结构被重组，使快速路径和慢路径都在同一函数内。\n\n优化效果: 减少了函数调用开销，提高了内存分配操作的性能，尤其是在频繁分配的场景下。内联后，编译器可能还能进行进一步的优化（如寄存器分配）。\n\n优化思路: 通过内联频繁调用的函数（尤其是热路径上的函数），减少调用指令和栈操作开销，从而提升性能。内联后，代码可能更易于编译器优化。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 在 memAllocator.cpp 中：\n// 优化前：mem_allocate 调用 mem_allocate_slow\nHeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n  if (UseTLAB) {\n    HeapWord* mem = mem_allocate_inside_tlab_fast();\n    if (mem != nullptr) {\n      return mem;\n    }\n  }\n  return mem_allocate_slow(allocation); // 函数调用\n}\n\n// 优化后：mem_allocate_slow 的逻辑被内联\nHeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n  if (UseTLAB) {\n    HeapWord* mem = mem_allocate_inside_tlab_fast();\n    if (mem != nullptr) {\n      return mem;\n    }\n  }\n  // 内联了 mem_allocate_slow 的逻辑\n  debug_only(allocation._thread->check_for_valid_safepoint_state());\n  if (UseTLAB) {\n    HeapWord* mem = mem_allocate_inside_tlab_slow(allocation);\n    if (mem != nullptr) {\n      return mem;\n    }\n  }\n  return mem_allocate_outside_tlab(allocation);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/7a41a525deb796396ade1456f1d0a101ac705014", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 在 memAllocator.cpp 中：\n// 优化前：mem_allocate 调用 mem_allocate_slow\nHeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n  if (UseTLAB) {\n    HeapWord* mem = mem_allocate_inside_tlab_fast();\n    if (mem != nullptr) {\n      return mem;\n    }\n  }\n  return mem_allocate_slow(allocation); // 函数调用\n}\n\n// 优化后：mem_allocate_slow 的逻辑被内联\nHeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n  if (UseTLAB) {\n    HeapWord* mem = mem_allocate_inside_tlab_fast();\n    if (mem != nullptr) {\n      return mem;\n    }\n  }\n  // 内联了 mem_allocate_slow 的逻辑\n  debug_only(allocation._thread->check_for_valid_safepoint_state());\n  if (UseTLAB) {\n    HeapWord* mem = mem_allocate_inside_tlab_slow(allocation);\n    if (mem != nullptr) {\n      return mem;\n    }\n  }\n  return mem_allocate_outside_tlab(allocation);\n}", "target": "// 在 memAllocator.cpp 中：\n// 优化前：mem_allocate 调用 mem_allocate_slow\nHeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n  if (UseTLAB) {\n    HeapWord* mem = mem_allocate_inside_tlab_fast();\n    if (mem != nullptr) {\n      return mem;\n    }\n  }\n  return mem_allocate_slow(allocation); // 函数调用\n}\n\n// 优化后：mem_allocate_slow 的逻辑被内联\nHeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n  if (UseTLAB) {\n    HeapWord* mem = mem_allocate_inside_tlab_fast();\n    if (mem != nullptr) {\n      return mem;\n    }\n  }\n  // 内联了 mem_allocate_slow 的逻辑\n  debug_only(allocation._thread->check_for_valid_safepoint_state());\n  if (UseTLAB) {\n    HeapWord* mem = mem_allocate_inside_tlab_slow(allocation);\n    if (mem != nullptr) {\n      return mem;\n    }\n  }\n  return mem_allocate_outside_tlab(allocation);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: mem_allocate函数先尝试TLAB快速分配，如果失败则调用 mem_allocate_slow函数。这涉及一次函数调用开销，包括参数传递、栈帧设置和返回指令。\n\n优化后: mem_allocate_slow的逻辑被直接内联到 mem_allocate函数中，消除了函数调用。代码结构被重组，使快速路径和慢路径都在同一函数内。\n\n优化效果: 减少了函数调用开销，提高了内存分配操作的性能，尤其是在频繁分配的场景下。内联后，编译器可能还能进行进一步的优化（如寄存器分配）。\n\n优化思路: 通过内联频繁调用的函数（尤其是热路径上的函数），减少调用指令和栈操作开销，从而提升性能。内联后，代码可能更易于编译器优化。"}
{"id": 949, "source": "riscv-dataset-excel", "optimization_type": "并行化优化", "optimization_description": "优化前: 堆转储默认使用单线程，串行执行转储操作，无法利用多核CPU。\n\n优化后: 堆转储默认使用并行转储（线程数由 default_num_of_dump_threads()决定）。同时，在OOM（内存不足）时动态调整线程数，避免内存压力。\n\n优化效果: 利用多核并行处理，加快了堆转储速度，特别是在大堆场景下。OOM时的线程数调整确保了稳定性。\n\n优化思路: 通过并行化将转储任务分摊到多个线程，提高吞吐量。动态线程调整避免了在内存紧张时加剧OOM问题。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 在 heapDumper.cpp 的 dump 方法中添加 OOM 检查：\nif (_oome && num_dump_threads > 1) {\n  // Each additional parallel writer requires several MB of internal memory\n  julong max_threads = os::free_memory() / (20 * M);\n  if (num_dump_threads > max_threads) {\n    num_dump_threads = MAX2<uint>(1, (uint)max_threads);\n  }\n}\n\n// 在 heapDumper.hpp 中修改默认参数：\nint dump(const char* path, outputStream* out = nullptr, int compression = -1, bool overwrite = false, uint parallel_thread_num = default_num_of_dump_threads());", "source_url": "https://github.com/openjdk/riscv-port/commit/0a24daecebd90eb46a813923bb2d5672514197ce", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 在 heapDumper.cpp 的 dump 方法中添加 OOM 检查：\nif (_oome && num_dump_threads > 1) {\n  // Each additional parallel writer requires several MB of internal memory\n  julong max_threads = os::free_memory() / (20 * M);\n  if (num_dump_threads > max_threads) {\n    num_dump_threads = MAX2<uint>(1, (uint)max_threads);\n  }\n}\n\n// 在 heapDumper.hpp 中修改默认参数：\nint dump(const char* path, outputStream* out = nullptr, int compression = -1, bool overwrite = false, uint parallel_thread_num = default_num_of_dump_threads());", "target": "// 在 heapDumper.cpp 的 dump 方法中添加 OOM 检查：\nif (_oome && num_dump_threads > 1) {\n  // Each additional parallel writer requires several MB of internal memory\n  julong max_threads = os::free_memory() / (20 * M);\n  if (num_dump_threads > max_threads) {\n    num_dump_threads = MAX2<uint>(1, (uint)max_threads);\n  }\n}\n\n// 在 heapDumper.hpp 中修改默认参数：\nint dump(const char* path, outputStream* out = nullptr, int compression = -1, bool overwrite = false, uint parallel_thread_num = default_num_of_dump_threads());", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: 堆转储默认使用单线程，串行执行转储操作，无法利用多核CPU。\n\n优化后: 堆转储默认使用并行转储（线程数由 default_num_of_dump_threads()决定）。同时，在OOM（内存不足）时动态调整线程数，避免内存压力。\n\n优化效果: 利用多核并行处理，加快了堆转储速度，特别是在大堆场景下。OOM时的线程数调整确保了稳定性。\n\n优化思路: 通过并行化将转储任务分摊到多个线程，提高吞吐量。动态线程调整避免了在内存紧张时加剧OOM问题。"}
{"id": 950, "source": "riscv-dataset-excel", "optimization_type": "条件分支优化", "optimization_description": "优化前: 锁获取直接使用原子比较交换（cmpxchg）操作自旋，每次循环都执行昂贵的原子操作，即使锁已被占用。\n\n优化后: 采用TTAS（Test-Test-and-Set）策略：先使用廉价的 load操作检查锁状态，如果锁被占用，则避免不必要的 cmpxchg操作。只有锁可能空闲时，才执行原子操作。\n\n优化效果: 减少了高竞争场景下的原子操作次数，降低了缓存一致性流量和CPU开销，提高了锁获取性能。\n\n优化思路: TTAS通过先测试锁状态（只读操作），减少昂贵的原子写操作（如 cmpxchg），从而优化自旋锁。这利用了本地缓存，减少了总线竞争。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 在 shenandoahLock.cpp 的 contended_lock_internal 方法中：\n// 优化前：\nwhile (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n  // 自旋\n}\n\n// 优化后：\nwhile (Atomic::load(&_state) == locked ||\n       Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n  // 先检查状态，再尝试获取锁\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/c4fe5bf90c2d368c29714de63a90eca444fb3ece", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 在 shenandoahLock.cpp 的 contended_lock_internal 方法中：\n// 优化前：\nwhile (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n  // 自旋\n}\n\n// 优化后：\nwhile (Atomic::load(&_state) == locked ||\n       Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n  // 先检查状态，再尝试获取锁\n}", "target": "// 在 shenandoahLock.cpp 的 contended_lock_internal 方法中：\n// 优化前：\nwhile (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n  // 自旋\n}\n\n// 优化后：\nwhile (Atomic::load(&_state) == locked ||\n       Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n  // 先检查状态，再尝试获取锁\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: 锁获取直接使用原子比较交换（cmpxchg）操作自旋，每次循环都执行昂贵的原子操作，即使锁已被占用。\n\n优化后: 采用TTAS（Test-Test-and-Set）策略：先使用廉价的 load操作检查锁状态，如果锁被占用，则避免不必要的 cmpxchg操作。只有锁可能空闲时，才执行原子操作。\n\n优化效果: 减少了高竞争场景下的原子操作次数，降低了缓存一致性流量和CPU开销，提高了锁获取性能。\n\n优化思路: TTAS通过先测试锁状态（只读操作），减少昂贵的原子写操作（如 cmpxchg），从而优化自旋锁。这利用了本地缓存，减少了总线竞争。"}
{"id": 951, "source": "riscv-dataset-excel", "optimization_type": "条件分支优化", "optimization_description": "在cmpUI_imm0_branch和cmpUL_imm0_branch指令中，使用正确的条件码生成cbz/cbnz。\n\n优化效果和思路：\n\n优化前：条件码映射错误，可能导致分支指令不被使用，生成低效比较和分支序列。\n\n优化后：正确匹配无符号比较条件，使编译器能使用cbz/cbnz指令（单条指令检查零值），减少分支开销。思路是修正条件映射，充分利用架构特定指令优化分支。", "original_code": "条件码映射错误，可能导致分支指令不被使用，生成低效比较和分支序列。", "optimized_code": "- operand cmpOpUEqNeLtGe()\n+ operand cmpOpUEqNeLeGt()\n{\n  // 条件测试从lt/ge改为le/gt\n  less(0x3, \"lo\");       // 原为lt(0xb, \"lt\")\n  greater_equal(0x2, \"hs\"); // 原为ge(0xa, \"ge\")", "source_url": "https://github.com/openjdk/riscv-port/commit/2c9185eb81c9dfcc30d160a6254089c474b56b0d", "code_v0_no_empty_lines": "条件码映射错误，可能导致分支指令不被使用，生成低效比较和分支序列。", "code_v1_no_empty_lines": "- operand cmpOpUEqNeLtGe()\n+ operand cmpOpUEqNeLeGt()\n{\n  // 条件测试从lt/ge改为le/gt\n  less(0x3, \"lo\");       // 原为lt(0xb, \"lt\")\n  greater_equal(0x2, \"hs\"); // 原为ge(0xa, \"ge\")", "target": "- operand cmpOpUEqNeLtGe()\n+ operand cmpOpUEqNeLeGt()\n{\n  // 条件测试从lt/ge改为le/gt\n  less(0x3, \"lo\");       // 原为lt(0xb, \"lt\")\n  greater_equal(0x2, \"hs\"); // 原为ge(0xa, \"ge\")", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "在cmpUI_imm0_branch和cmpUL_imm0_branch指令中，使用正确的条件码生成cbz/cbnz。\n\n优化效果和思路：\n\n优化前：条件码映射错误，可能导致分支指令不被使用，生成低效比较和分支序列。\n\n优化后：正确匹配无符号比较条件，使编译器能使用cbz/cbnz指令（单条指令检查零值），减少分支开销。思路是修正条件映射，充分利用架构特定指令优化分支。"}
{"id": 952, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "优化前：POPCNT操作可能使用多条指令模拟，效率较低。\n\n优化后：在Z15上使用单条指令完成计算，减少指令数和周期。思路是检测硬件支持并选择最优指令路径，提升低层计算性能。", "original_code": "POPCNT操作可能使用多条指令模拟，效率较低。", "optimized_code": "instruct popCountI_Ext3(iRegI dst, iRegI src, flagsReg cr) %{\n  // 使用z_popcnt指令与模式8（直接计算32位结果）\n  __ pop_count_int_with_ext3(Rdst, Rsrc);\n%}", "source_url": "https://github.com/openjdk/riscv-port/commit/5a8a9fdfa599e8939a5c6675883a92c869474979", "code_v0_no_empty_lines": "POPCNT操作可能使用多条指令模拟，效率较低。", "code_v1_no_empty_lines": "instruct popCountI_Ext3(iRegI dst, iRegI src, flagsReg cr) %{\n  // 使用z_popcnt指令与模式8（直接计算32位结果）\n  __ pop_count_int_with_ext3(Rdst, Rsrc);\n%}", "target": "instruct popCountI_Ext3(iRegI dst, iRegI src, flagsReg cr) %{\n  // 使用z_popcnt指令与模式8（直接计算32位结果）\n  __ pop_count_int_with_ext3(Rdst, Rsrc);\n%}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：POPCNT操作可能使用多条指令模拟，效率较低。\n\n优化后：在Z15上使用单条指令完成计算，减少指令数和周期。思路是检测硬件支持并选择最优指令路径，提升低层计算性能。"}
{"id": 953, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：节点分配大小包含冗余字段，导致两倍内存浪费。\n\n优化后：动态计算实际所需大小，减少内存分配。思路是通过精确计算结构体大小，避免填充和重叠，提升内存效率。", "original_code": "节点分配大小包含冗余字段，导致两倍内存浪费。", "optimized_code": "- size_t alloc_size = _local_table->get_node_size() + value.byte_size() + value.effective_length();\n+ size_t alloc_size = SymbolTableHash::get_dynamic_node_size(value.byte_size());\nreturn sizeof(Node) - sizeof(VALUE) + value_size;", "source_url": "https://github.com/openjdk/riscv-port/commit/2c1da6c6fa2e50856ea71c0e266961171bee1037", "code_v0_no_empty_lines": "节点分配大小包含冗余字段，导致两倍内存浪费。", "code_v1_no_empty_lines": "- size_t alloc_size = _local_table->get_node_size() + value.byte_size() + value.effective_length();\n+ size_t alloc_size = SymbolTableHash::get_dynamic_node_size(value.byte_size());\nreturn sizeof(Node) - sizeof(VALUE) + value_size;", "target": "- size_t alloc_size = _local_table->get_node_size() + value.byte_size() + value.effective_length();\n+ size_t alloc_size = SymbolTableHash::get_dynamic_node_size(value.byte_size());\nreturn sizeof(Node) - sizeof(VALUE) + value_size;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：节点分配大小包含冗余字段，导致两倍内存浪费。\n\n优化后：动态计算实际所需大小，减少内存分配。思路是通过精确计算结构体大小，避免填充和重叠，提升内存效率。"}
{"id": 954, "source": "riscv-dataset-excel", "optimization_type": "内存管理优化", "optimization_description": "优化前：阈值较高（90%），可能导致GC延迟触发，增加内存压力或停顿时间。\n\n优化后：阈值降低（70%），使GC更早触发即时回收，减少内存占用和潜在停顿。思路是平衡内存使用和回收频率，适应常见工作负载。", "original_code": "阈值较高（90%），可能导致GC延迟触发，增加内存压力或停顿时间。", "optimized_code": "PRODUCT(uintx,ShenandoahImmediateThreshold,90,EXPERIMENTAL,\\+PRODUCT(uintx,ShenandoahImmediateThreshold,70,EXPERIMENTAL,\\))", "source_url": "https://github.com/openjdk/riscv-port/commit/a7205cc6512796466fefe17d171082995e0966de", "code_v0_no_empty_lines": "阈值较高（90%），可能导致GC延迟触发，增加内存压力或停顿时间。", "code_v1_no_empty_lines": "PRODUCT(uintx,ShenandoahImmediateThreshold,90,EXPERIMENTAL,\\+PRODUCT(uintx,ShenandoahImmediateThreshold,70,EXPERIMENTAL,\\))", "target": "PRODUCT(uintx,ShenandoahImmediateThreshold,90,EXPERIMENTAL,\\+PRODUCT(uintx,ShenandoahImmediateThreshold,70,EXPERIMENTAL,\\))", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：阈值较高（90%），可能导致GC延迟触发，增加内存压力或停顿时间。\n\n优化后：阈值降低（70%），使GC更早触发即时回收，减少内存占用和潜在停顿。思路是平衡内存使用和回收频率，适应常见工作负载。"}
{"id": 956, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "优化效果：通过区分严格顺序和非严格顺序的浮点归约操作，为非严格顺序归约（如Vector API）生成更高效的向量代码（如使用NEON的pairwise加法），从而提高性能。对于严格顺序归约（如自动向量化），保持原有安全顺序，避免精度问题。\n\n优化思路：在C2编译器的AArch64后端中，为浮点归约节点（如 AddReductionVF和 AddReductionVD）添加 requires_strict_order标志：\n\n如果归约操作不需要严格顺序（如Vector API允许非关联操作），则使用高效的NEON指令（如 faddp）进行向量化归约。\n\n如果需要严格顺序（如自动向量化需符合JLS规范），则使用保守的SVE指令或标量方式，确保结果正确。", "original_code": "// No original code extracted from description\n", "optimized_code": "// 非严格顺序归约使用NEON指令\ninstruct reduce_non_strict_order_add2F_neon(vRegF dst, vRegF fsrc, vReg vsrc) %{\n  predicate(Matcher::vector_length(n->in(2)) == 2 && !n->as_Reduction()->requires_strict_order());\n  match(Set dst (AddReductionVF fsrc vsrc));\n  effect(TEMP_DEF dst);\n  format %{ \"reduce_non_strict_order_add2F_neon $dst, $fsrc, $vsrc\" %}\n  ins_encode %{\n    __ faddp($dst$$FloatRegister, $vsrc$$FloatRegister, __ S);\n    __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);\n  %}\n%}\n\n// 严格顺序归约使用SVE指令\ninstruct reduce_addF_sve(vRegF dst_src1, vReg src2) %{\n  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) ||\n            n->as_Reduction()->requires_strict_order());\n  match(Set dst_src1 (AddReductionVF dst_src1 src2));\n  format %{ \"reduce_addF_sve $dst_src1, $dst_src1, $src2\" %}\n  ins_encode %{\n    assert(UseSVE > 0, \"must be sve\");\n    __ sve_fadda($dst_src1$$FloatRegister, __ S, ptrue, $src2$$FloatRegister);\n  %}\n%}\n// 移动非严格顺序归约出循环，减少归约操作次数\nvoid PhaseIdealLoop::move_unordered_reduction_out_of_loop(IdealLoopTree* loop) {\n  // ... 逻辑：将归约操作移出循环，仅在循环外执行一次归约\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/0e4d4a0c3150c01d927bd69cc578cea053cf16b3", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 非严格顺序归约使用NEON指令\ninstruct reduce_non_strict_order_add2F_neon(vRegF dst, vRegF fsrc, vReg vsrc) %{\n  predicate(Matcher::vector_length(n->in(2)) == 2 && !n->as_Reduction()->requires_strict_order());\n  match(Set dst (AddReductionVF fsrc vsrc));\n  effect(TEMP_DEF dst);\n  format %{ \"reduce_non_strict_order_add2F_neon $dst, $fsrc, $vsrc\" %}\n  ins_encode %{\n    __ faddp($dst$$FloatRegister, $vsrc$$FloatRegister, __ S);\n    __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);\n  %}\n%}\n\n// 严格顺序归约使用SVE指令\ninstruct reduce_addF_sve(vRegF dst_src1, vReg src2) %{\n  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) ||\n            n->as_Reduction()->requires_strict_order());\n  match(Set dst_src1 (AddReductionVF dst_src1 src2));\n  format %{ \"reduce_addF_sve $dst_src1, $dst_src1, $src2\" %}\n  ins_encode %{\n    assert(UseSVE > 0, \"must be sve\");\n    __ sve_fadda($dst_src1$$FloatRegister, __ S, ptrue, $src2$$FloatRegister);\n  %}\n%}\n// 移动非严格顺序归约出循环，减少归约操作次数\nvoid PhaseIdealLoop::move_unordered_reduction_out_of_loop(IdealLoopTree* loop) {\n  // ... 逻辑：将归约操作移出循环，仅在循环外执行一次归约\n}", "target": "// 非严格顺序归约使用NEON指令\ninstruct reduce_non_strict_order_add2F_neon(vRegF dst, vRegF fsrc, vReg vsrc) %{\n  predicate(Matcher::vector_length(n->in(2)) == 2 && !n->as_Reduction()->requires_strict_order());\n  match(Set dst (AddReductionVF fsrc vsrc));\n  effect(TEMP_DEF dst);\n  format %{ \"reduce_non_strict_order_add2F_neon $dst, $fsrc, $vsrc\" %}\n  ins_encode %{\n    __ faddp($dst$$FloatRegister, $vsrc$$FloatRegister, __ S);\n    __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);\n  %}\n%}\n\n// 严格顺序归约使用SVE指令\ninstruct reduce_addF_sve(vRegF dst_src1, vReg src2) %{\n  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) ||\n            n->as_Reduction()->requires_strict_order());\n  match(Set dst_src1 (AddReductionVF dst_src1 src2));\n  format %{ \"reduce_addF_sve $dst_src1, $dst_src1, $src2\" %}\n  ins_encode %{\n    assert(UseSVE > 0, \"must be sve\");\n    __ sve_fadda($dst_src1$$FloatRegister, __ S, ptrue, $src2$$FloatRegister);\n  %}\n%}\n// 移动非严格顺序归约出循环，减少归约操作次数\nvoid PhaseIdealLoop::move_unordered_reduction_out_of_loop(IdealLoopTree* loop) {\n  // ... 逻辑：将归约操作移出循环，仅在循环外执行一次归约\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化效果：通过区分严格顺序和非严格顺序的浮点归约操作，为非严格顺序归约（如Vector API）生成更高效的向量代码（如使用NEON的pairwise加法），从而提高性能。对于严格顺序归约（如自动向量化），保持原有安全顺序，避免精度问题。\n\n优化思路：在C2编译器的AArch64后端中，为浮点归约节点（如 AddReductionVF和 AddReductionVD）添加 requires_strict_order标志：\n\n如果归约操作不需要严格顺序（如Vector API允许非关联操作），则使用高效的NEON指令（如 faddp）进行向量化归约。\n\n如果需要严格顺序（如自动向量化需符合JLS规范），则使用保守的SVE指令或标量方式，确保结果正确。"}
{"id": 957, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "优化效果：通过检测并启用Intel APX（Advanced Performance Extensions）扩展，可以利用新的CPU指令提高指令级并行性和执行效率，从而提升性能。具体来说，APX引入了扩展寄存器（EGPRs）和新指令，可以减少指令开销和提高代码密度。\n\n优化思路：在CPU特征检测阶段添加对APX的支持，包括：\n\n在CPUID检测中检查APX特性位（如CPUID(7).ECX=1.EDX[21]和XCR0[19]）。\n\n添加APX相关的异常处理逻辑，以验证操作系统对APX寄存器的保存/恢复支持。\n\n仅当APX支持完整时启用 UseAPX标志，否则回退到默认行为。", "original_code": "// No original code extracted from description\n", "optimized_code": "在 src/hotspot/cpu/x86/vm_version_x86.cpp中，添加APX检测逻辑：\n\n// 检查APX硬件和OS支持\nbool apx_supported = os_supports_apx_egprs() && supports_apx_f() && supports_avx512vl();\nif (UseAPX && !apx_supported) {\n  warning(\"UseAPX is not supported on this CPU, setting it to false\");\n  FLAG_SET_DEFAULT(UseAPX, false);\n} else if (FLAG_IS_DEFAULT(UseAPX)) {\n  FLAG_SET_DEFAULT(UseAPX, apx_supported ? true : false);\n}\n\n在 src/hotspot/cpu/x86/vm_version_x86.hpp中，添加APX特性标志：\n\n\n// 在CPU特性标志中添加APX_F\ndecl(APX_F, \"apx_f\", 60) /* Intel Advanced Performance Extensions*/\n\n在操作系统的异常处理中（如 src/hotspot/os/windows/os_windows.cpp），添加APX的SEGV处理：\n\n\nif ((exception_code == EXCEPTION_ACCESS_VIOLATION) &&\n    VM_Version::is_cpuinfo_segv_addr_apx(pc)) {\n  VM_Version::clear_apx_test_state();\n  return Handle_Exception(exceptionInfo, VM_Version::cpuinfo_cont_addr_apx());\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/a941397327972f130e683167a1b429f17603df46", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "在 src/hotspot/cpu/x86/vm_version_x86.cpp中，添加APX检测逻辑：\n\n// 检查APX硬件和OS支持\nbool apx_supported = os_supports_apx_egprs() && supports_apx_f() && supports_avx512vl();\nif (UseAPX && !apx_supported) {\n  warning(\"UseAPX is not supported on this CPU, setting it to false\");\n  FLAG_SET_DEFAULT(UseAPX, false);\n} else if (FLAG_IS_DEFAULT(UseAPX)) {\n  FLAG_SET_DEFAULT(UseAPX, apx_supported ? true : false);\n}\n\n在 src/hotspot/cpu/x86/vm_version_x86.hpp中，添加APX特性标志：\n\n\n// 在CPU特性标志中添加APX_F\ndecl(APX_F, \"apx_f\", 60) /* Intel Advanced Performance Extensions*/\n\n在操作系统的异常处理中（如 src/hotspot/os/windows/os_windows.cpp），添加APX的SEGV处理：\n\n\nif ((exception_code == EXCEPTION_ACCESS_VIOLATION) &&\n    VM_Version::is_cpuinfo_segv_addr_apx(pc)) {\n  VM_Version::clear_apx_test_state();\n  return Handle_Exception(exceptionInfo, VM_Version::cpuinfo_cont_addr_apx());\n}", "target": "在 src/hotspot/cpu/x86/vm_version_x86.cpp中，添加APX检测逻辑：\n\n// 检查APX硬件和OS支持\nbool apx_supported = os_supports_apx_egprs() && supports_apx_f() && supports_avx512vl();\nif (UseAPX && !apx_supported) {\n  warning(\"UseAPX is not supported on this CPU, setting it to false\");\n  FLAG_SET_DEFAULT(UseAPX, false);\n} else if (FLAG_IS_DEFAULT(UseAPX)) {\n  FLAG_SET_DEFAULT(UseAPX, apx_supported ? true : false);\n}\n\n在 src/hotspot/cpu/x86/vm_version_x86.hpp中，添加APX特性标志：\n\n\n// 在CPU特性标志中添加APX_F\ndecl(APX_F, \"apx_f\", 60) /* Intel Advanced Performance Extensions*/\n\n在操作系统的异常处理中（如 src/hotspot/os/windows/os_windows.cpp），添加APX的SEGV处理：\n\n\nif ((exception_code == EXCEPTION_ACCESS_VIOLATION) &&\n    VM_Version::is_cpuinfo_segv_addr_apx(pc)) {\n  VM_Version::clear_apx_test_state();\n  return Handle_Exception(exceptionInfo, VM_Version::cpuinfo_cont_addr_apx());\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化效果：通过检测并启用Intel APX（Advanced Performance Extensions）扩展，可以利用新的CPU指令提高指令级并行性和执行效率，从而提升性能。具体来说，APX引入了扩展寄存器（EGPRs）和新指令，可以减少指令开销和提高代码密度。\n\n优化思路：在CPU特征检测阶段添加对APX的支持，包括：\n\n在CPUID检测中检查APX特性位（如CPUID(7).ECX=1.EDX[21]和XCR0[19]）。\n\n添加APX相关的异常处理逻辑，以验证操作系统对APX寄存器的保存/恢复支持。\n\n仅当APX支持完整时启用 UseAPX标志，否则回退到默认行为。"}
{"id": 958, "source": "riscv-dataset-excel", "optimization_type": "并发性能优化", "optimization_description": "优化效果：将 OopMapCache的初始化从互斥锁改为无锁的原子操作，减少了多线程环境下的锁竞争，提高了并发性能和可伸缩性。\n\n优化思路：使用原子比较并交换（CAS）操作替代锁来安全地初始化 OopMapCache：\n\n优化前：使用 OopMapCacheAlloc_lock互斥锁来保护初始化过程，可能导致线程阻塞。\n\n优化后：通过 Atomic::cmpxchg原子操作实现无锁初始化，线程竞争时只有一个线程成功初始化，其他线程直接使用已初始化的实例。", "original_code": "使用 OopMapCacheAlloc_lock互斥锁来保护初始化过程，可能导致线程阻塞。", "optimized_code": "// 优化后：无锁初始化\nOopMapCache* oop_map_cache = Atomic::load_acquire(&_oop_map_cache);\nif (oop_map_cache == nullptr) {\n  oop_map_cache = new OopMapCache();\n  OopMapCache* other = Atomic::cmpxchg(&_oop_map_cache, (OopMapCache*)nullptr, oop_map_cache);\n  if (other != nullptr) {\n    delete oop_map_cache;\n    oop_map_cache = other;\n  }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/a2584a8341b2dc9c102abd373a890b2108d3f57e", "code_v0_no_empty_lines": "使用 OopMapCacheAlloc_lock互斥锁来保护初始化过程，可能导致线程阻塞。", "code_v1_no_empty_lines": "// 优化后：无锁初始化\nOopMapCache* oop_map_cache = Atomic::load_acquire(&_oop_map_cache);\nif (oop_map_cache == nullptr) {\n  oop_map_cache = new OopMapCache();\n  OopMapCache* other = Atomic::cmpxchg(&_oop_map_cache, (OopMapCache*)nullptr, oop_map_cache);\n  if (other != nullptr) {\n    delete oop_map_cache;\n    oop_map_cache = other;\n  }\n}", "target": "// 优化后：无锁初始化\nOopMapCache* oop_map_cache = Atomic::load_acquire(&_oop_map_cache);\nif (oop_map_cache == nullptr) {\n  oop_map_cache = new OopMapCache();\n  OopMapCache* other = Atomic::cmpxchg(&_oop_map_cache, (OopMapCache*)nullptr, oop_map_cache);\n  if (other != nullptr) {\n    delete oop_map_cache;\n    oop_map_cache = other;\n  }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化效果：将 OopMapCache的初始化从互斥锁改为无锁的原子操作，减少了多线程环境下的锁竞争，提高了并发性能和可伸缩性。\n\n优化思路：使用原子比较并交换（CAS）操作替代锁来安全地初始化 OopMapCache：\n\n优化前：使用 OopMapCacheAlloc_lock互斥锁来保护初始化过程，可能导致线程阻塞。\n\n优化后：通过 Atomic::cmpxchg原子操作实现无锁初始化，线程竞争时只有一个线程成功初始化，其他线程直接使用已初始化的实例。"}
{"id": 959, "source": "riscv-dataset-excel", "optimization_type": "指令集优化/条件分支优化", "optimization_description": "优化前：s390x架构上，循环计数分支可能使用通用分支指令（如brc）结合算术操作，指令数较多，效率较低。\n\n优化后：引入专用分支计数指令，如z_bct位计数）和z_bctg`（64位计数），这些指令将减1操作和条件分支合并为一条指令。\n\n优化效果和思路\n\n优化效果：分支计数指令将减法和分支合并，减少了指令数和流水线停顿，提高了循环效率。尤其对于密集循环，性能提升明显。\n\n优化思路：利用s390x架构的特有指令，将常见循环模式（如for (i; i>0; i--)）硬件化，简化代码生成。", "original_code": "s390x架构上，循环计数分支可能使用通用分支指令（如brc）结合算术操作，指令数较多，效率较低。", "optimized_code": "在Assembler类中添加新指令定义：\n\n\ninline void z_bct(Register r1, const Address &a); // 分支计数指令\ninline void z_bctg(Register r1, const Address &a);\n\n指令编码实现：\n\n\ninline void Assembler::z_bct(Register r1, int64_t d2, Register x2, Register b2) { \n  emit_32(BCT_ZOPC | reg(r1,8,32) | rxmask_32(d2,x2,b2)); \n}\n\n支持标签分支的封装：\n\n\ninline void Assembler::z_bct(Register r1, int64_t d2, Register b2) { z_bct(r1, d2, Z_R0, b2); }", "source_url": "https://github.com/openjdk/riscv-port/commit/a6fc2f839a5e494b940ee473cbd942ec5f884324", "code_v0_no_empty_lines": "s390x架构上，循环计数分支可能使用通用分支指令（如brc）结合算术操作，指令数较多，效率较低。", "code_v1_no_empty_lines": "在Assembler类中添加新指令定义：\n\n\ninline void z_bct(Register r1, const Address &a); // 分支计数指令\ninline void z_bctg(Register r1, const Address &a);\n\n指令编码实现：\n\n\ninline void Assembler::z_bct(Register r1, int64_t d2, Register x2, Register b2) { \n  emit_32(BCT_ZOPC | reg(r1,8,32) | rxmask_32(d2,x2,b2)); \n}\n\n支持标签分支的封装：\n\n\ninline void Assembler::z_bct(Register r1, int64_t d2, Register b2) { z_bct(r1, d2, Z_R0, b2); }", "target": "在Assembler类中添加新指令定义：\n\n\ninline void z_bct(Register r1, const Address &a); // 分支计数指令\ninline void z_bctg(Register r1, const Address &a);\n\n指令编码实现：\n\n\ninline void Assembler::z_bct(Register r1, int64_t d2, Register x2, Register b2) { \n  emit_32(BCT_ZOPC | reg(r1,8,32) | rxmask_32(d2,x2,b2)); \n}\n\n支持标签分支的封装：\n\n\ninline void Assembler::z_bct(Register r1, int64_t d2, Register b2) { z_bct(r1, d2, Z_R0, b2); }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：s390x架构上，循环计数分支可能使用通用分支指令（如brc）结合算术操作，指令数较多，效率较低。\n\n优化后：引入专用分支计数指令，如z_bct位计数）和z_bctg`（64位计数），这些指令将减1操作和条件分支合并为一条指令。\n\n优化效果和思路\n\n优化效果：分支计数指令将减法和分支合并，减少了指令数和流水线停顿，提高了循环效率。尤其对于密集循环，性能提升明显。\n\n优化思路：利用s390x架构的特有指令，将常见循环模式（如for (i; i>0; i--)）硬件化，简化代码生成。"}
{"id": 960, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：在AArch64架构上，membar_release使用单一的dmb ish指令（全屏障），这会强制所有内存访问顺序，可能包含不必要的开销。\n\n优化后：将membar_release拆分为两个指令：dmb ishst（存储-存储屏障）和dmb ishld（加载-存储屏障）。同时，引入AlwaysMergeDMB标志控制屏障合并逻辑，避免过度合并导致屏障强度增加。\n\n优化效果和思路\n\n优化效果：拆分屏障后，减少了屏障的强度：dmb ishst只序列化存储操作，dmb ishld只序列化加载与存储操作，比全屏障dmb ish更轻量。这可以提升多线程环境下的内存访问性能，尤其在高并发场景中。\n\n优化思路：根据内存序语义精确选择屏障类型，避免使用过强的全屏障。通过指令合并逻辑（如AlwaysMergeDMB）防止屏障重复，但默认关闭合并以确保正确性。", "original_code": "在AArch64架构上，membar_release使用单一的dmb ish指令（全屏障），这会强制所有内存访问顺序，可能包含不必要的开销。", "optimized_code": "在membar_release指令定义中：\n\n\nformat %{ \"membar_release\\n\\t\" \"dmb ishst\\n\\tdmb ishld\" %}\n\n在屏障合并逻辑中（MacroAssembler::membar方法）：\n\n\nif (AlwaysMergeDMB) {\n  bar->set_kind(bar->get_kind() | order_constraint);\n  BLOCK_COMMENT(\" merged membar(always) \");\n  return;\n}\n// 特殊处理避免合并不同屏障类型\n\n添加AlwaysMergeDMB标志默认值：\n\n\nproduct(bool, AlwaysMergeDMB, true, DIAGNOSTIC, \"Always merge DMB instructions in code", "source_url": "https://github.com/openjdk/riscv-port/commit/2a242db01ed1d502affa4a954e601266fa98dfbe", "code_v0_no_empty_lines": "在AArch64架构上，membar_release使用单一的dmb ish指令（全屏障），这会强制所有内存访问顺序，可能包含不必要的开销。", "code_v1_no_empty_lines": "在membar_release指令定义中：\n\n\nformat %{ \"membar_release\\n\\t\" \"dmb ishst\\n\\tdmb ishld\" %}\n\n在屏障合并逻辑中（MacroAssembler::membar方法）：\n\n\nif (AlwaysMergeDMB) {\n  bar->set_kind(bar->get_kind() | order_constraint);\n  BLOCK_COMMENT(\" merged membar(always) \");\n  return;\n}\n// 特殊处理避免合并不同屏障类型\n\n添加AlwaysMergeDMB标志默认值：\n\n\nproduct(bool, AlwaysMergeDMB, true, DIAGNOSTIC, \"Always merge DMB instructions in code", "target": "在membar_release指令定义中：\n\n\nformat %{ \"membar_release\\n\\t\" \"dmb ishst\\n\\tdmb ishld\" %}\n\n在屏障合并逻辑中（MacroAssembler::membar方法）：\n\n\nif (AlwaysMergeDMB) {\n  bar->set_kind(bar->get_kind() | order_constraint);\n  BLOCK_COMMENT(\" merged membar(always) \");\n  return;\n}\n// 特殊处理避免合并不同屏障类型\n\n添加AlwaysMergeDMB标志默认值：\n\n\nproduct(bool, AlwaysMergeDMB, true, DIAGNOSTIC, \"Always merge DMB instructions in code", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在AArch64架构上，membar_release使用单一的dmb ish指令（全屏障），这会强制所有内存访问顺序，可能包含不必要的开销。\n\n优化后：将membar_release拆分为两个指令：dmb ishst（存储-存储屏障）和dmb ishld（加载-存储屏障）。同时，引入AlwaysMergeDMB标志控制屏障合并逻辑，避免过度合并导致屏障强度增加。\n\n优化效果和思路\n\n优化效果：拆分屏障后，减少了屏障的强度：dmb ishst只序列化存储操作，dmb ishld只序列化加载与存储操作，比全屏障dmb ish更轻量。这可以提升多线程环境下的内存访问性能，尤其在高并发场景中。\n\n优化思路：根据内存序语义精确选择屏障类型，避免使用过强的全屏障。通过指令合并逻辑（如AlwaysMergeDMB）防止屏障重复，但默认关闭合并以确保正确性。"}
{"id": 961, "source": "riscv-dataset-excel", "optimization_type": "内存优化和计算优化", "optimization_description": "优化前: 在并发标记结束后，才基于 G1HeapWastePercent修剪重建候选区域。这可能导致处理大量无效候选区域，增加重建时间和内存占用。\n\n优化后: 在并发标记阶段（remark方法中）尽早修剪候选区域，基于堆浪费百分比。同时，修改了排序逻辑，从按可回收字节排序改为按GC效率排序。\n\n优化效果: 减少了需要处理的候选区域数量，降低了内存占用和重建时间，提高了G1垃圾收集器的效率。提前修剪避免了不必要的计算。\n\n优化思路: 通过尽早过滤掉不满足堆浪费百分比的区域，减少后续操作的开销。排序策略的变更确保了更有效的区域选择，优化了GC效率", "original_code": "// No original code extracted from description\n", "optimized_code": "// 在 g1ConcurrentMark.cpp 的 remark 方法中添加：\nif (_needs_remembered_set_rebuild) {\n  // Prune rebuild candidates based on G1HeapWastePercent.\n  // Improves rebuild time in addition to remembered set memory usage.\n  G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_regions(), _g1h->policy()->candidates());\n}\n\n// 在 g1Policy.cpp 中修改：\nvoid G1Policy::record_concurrent_mark_cleanup_end(bool has_rebuilt_remembered_sets) {\n  if (has_rebuilt_remembered_sets) {\n    candidates()->sort_marking_by_efficiency(); // 改为按GC效率排序\n    mixed_gc_pending = next_gc_should_be_mixed();\n  }\n}\n\n// 在 g1CollectionSetCandidates.cpp 中新增排序方法：\nvoid G1CollectionSetCandidates::sort_marking_by_efficiency() {\n  // ... 计算GC效率并排序\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/ce73fec882357d749619576a3219516b7391fb3f", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 在 g1ConcurrentMark.cpp 的 remark 方法中添加：\nif (_needs_remembered_set_rebuild) {\n  // Prune rebuild candidates based on G1HeapWastePercent.\n  // Improves rebuild time in addition to remembered set memory usage.\n  G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_regions(), _g1h->policy()->candidates());\n}\n\n// 在 g1Policy.cpp 中修改：\nvoid G1Policy::record_concurrent_mark_cleanup_end(bool has_rebuilt_remembered_sets) {\n  if (has_rebuilt_remembered_sets) {\n    candidates()->sort_marking_by_efficiency(); // 改为按GC效率排序\n    mixed_gc_pending = next_gc_should_be_mixed();\n  }\n}\n\n// 在 g1CollectionSetCandidates.cpp 中新增排序方法：\nvoid G1CollectionSetCandidates::sort_marking_by_efficiency() {\n  // ... 计算GC效率并排序\n}", "target": "// 在 g1ConcurrentMark.cpp 的 remark 方法中添加：\nif (_needs_remembered_set_rebuild) {\n  // Prune rebuild candidates based on G1HeapWastePercent.\n  // Improves rebuild time in addition to remembered set memory usage.\n  G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_regions(), _g1h->policy()->candidates());\n}\n\n// 在 g1Policy.cpp 中修改：\nvoid G1Policy::record_concurrent_mark_cleanup_end(bool has_rebuilt_remembered_sets) {\n  if (has_rebuilt_remembered_sets) {\n    candidates()->sort_marking_by_efficiency(); // 改为按GC效率排序\n    mixed_gc_pending = next_gc_should_be_mixed();\n  }\n}\n\n// 在 g1CollectionSetCandidates.cpp 中新增排序方法：\nvoid G1CollectionSetCandidates::sort_marking_by_efficiency() {\n  // ... 计算GC效率并排序\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前: 在并发标记结束后，才基于 G1HeapWastePercent修剪重建候选区域。这可能导致处理大量无效候选区域，增加重建时间和内存占用。\n\n优化后: 在并发标记阶段（remark方法中）尽早修剪候选区域，基于堆浪费百分比。同时，修改了排序逻辑，从按可回收字节排序改为按GC效率排序。\n\n优化效果: 减少了需要处理的候选区域数量，降低了内存占用和重建时间，提高了G1垃圾收集器的效率。提前修剪避免了不必要的计算。\n\n优化思路: 通过尽早过滤掉不满足堆浪费百分比的区域，减少后续操作的开销。排序策略的变更确保了更有效的区域选择，优化了GC效率"}
{"id": 962, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "优化前：arrays_equals函数使用常规的标量比较或较小的向量比较（如16字节SSE），处理数组比较时效率较低。\n\n优化后：引入expand_ary2参数，支持使用AVX2的32字节向量比较。当expand_ary2为true时（表示第二个数组需要扩展，如字节数组到短整型数组），使用vpmovzxbw指令将字节数据扩展为16位，然后进行向量化比较。同时，代码添加了对32字节向量和16字节向量的分支处理，以充分利用AVX2的宽向量能力。\n\n优化效果和思路\n\n优化效果：通过AVX2指令，一次可以比较32字节数据，相比标量比较或较小向量比较，大幅提升了数组比较（如IndexOf操作）的吞吐量。尤其当数组较大时，性能提升显著。\n\n优化思路：利用SIMD并行性，将多个数据元素打包到宽向量寄存器中，单条指令完成多个比较操作。同时，通过条件分支处理不同数组大小和对齐情况，确保优化覆盖更多场景。", "original_code": "arrays_equals函数使用常规的标量比较或较小的向量比较（如16字节SSE），处理数组比较时效率较低。", "optimized_code": "添加expand_ary2参数，并引入条件检查（仅AVX2支持）：\n\n\nassert ((!expand_ary2) || ((expand_ary2) && (UseAVX == 2 )), \" Expansion only implemented for AVX2 \" );\n\n向量比较部分使用AVX2指令，如vpmovzxbw用于数据扩展：\n\n\nif (expand_ary2) {\n  vpmovzxbw (vec2, Address (ary2, limit, Address::times_1), Assembler::AVX_256bit);\n} else {\n  vmovdqu (vec2, Address (ary2, limit, Address::times_1));\n}\n\n调整循环步长和尾处理，以32字节为单元（当expand_ary2为false时）或16字节为单元（当expand_ary2为true时）：\n\nint scaleIncr = expand_ary2 ? 8 : 16; // 步长调整", "source_url": "https://github.com/openjdk/riscv-port/commit/8e72d7cf8e7dfc7eb9e66bc562f125f947e37f49", "code_v0_no_empty_lines": "arrays_equals函数使用常规的标量比较或较小的向量比较（如16字节SSE），处理数组比较时效率较低。", "code_v1_no_empty_lines": "添加expand_ary2参数，并引入条件检查（仅AVX2支持）：\n\n\nassert ((!expand_ary2) || ((expand_ary2) && (UseAVX == 2 )), \" Expansion only implemented for AVX2 \" );\n\n向量比较部分使用AVX2指令，如vpmovzxbw用于数据扩展：\n\n\nif (expand_ary2) {\n  vpmovzxbw (vec2, Address (ary2, limit, Address::times_1), Assembler::AVX_256bit);\n} else {\n  vmovdqu (vec2, Address (ary2, limit, Address::times_1));\n}\n\n调整循环步长和尾处理，以32字节为单元（当expand_ary2为false时）或16字节为单元（当expand_ary2为true时）：\n\nint scaleIncr = expand_ary2 ? 8 : 16; // 步长调整", "target": "添加expand_ary2参数，并引入条件检查（仅AVX2支持）：\n\n\nassert ((!expand_ary2) || ((expand_ary2) && (UseAVX == 2 )), \" Expansion only implemented for AVX2 \" );\n\n向量比较部分使用AVX2指令，如vpmovzxbw用于数据扩展：\n\n\nif (expand_ary2) {\n  vpmovzxbw (vec2, Address (ary2, limit, Address::times_1), Assembler::AVX_256bit);\n} else {\n  vmovdqu (vec2, Address (ary2, limit, Address::times_1));\n}\n\n调整循环步长和尾处理，以32字节为单元（当expand_ary2为false时）或16字节为单元（当expand_ary2为true时）：\n\nint scaleIncr = expand_ary2 ? 8 : 16; // 步长调整", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：arrays_equals函数使用常规的标量比较或较小的向量比较（如16字节SSE），处理数组比较时效率较低。\n\n优化后：引入expand_ary2参数，支持使用AVX2的32字节向量比较。当expand_ary2为true时（表示第二个数组需要扩展，如字节数组到短整型数组），使用vpmovzxbw指令将字节数据扩展为16位，然后进行向量化比较。同时，代码添加了对32字节向量和16字节向量的分支处理，以充分利用AVX2的宽向量能力。\n\n优化效果和思路\n\n优化效果：通过AVX2指令，一次可以比较32字节数据，相比标量比较或较小向量比较，大幅提升了数组比较（如IndexOf操作）的吞吐量。尤其当数组较大时，性能提升显著。\n\n优化思路：利用SIMD并行性，将多个数据元素打包到宽向量寄存器中，单条指令完成多个比较操作。同时，通过条件分支处理不同数组大小和对齐情况，确保优化覆盖更多场景。"}
{"id": 963, "source": "riscv-dataset-excel", "optimization_type": "条件分支优化和锁优化（并发性能优化）", "optimization_description": "优化前：在 ShenandoahBarrierSetNMethod::nmethod_entry_barrier方法中，直接获取 nmethod 锁（通过 ShenandoahNMethod::lock_for_nmethod），然后检查 nmethod 是否已解除武装（disarmed）。如果已解除武装，则直接返回。但锁获取操作可能昂贵，尤其是在高并发场景下。\n\n优化后：在获取锁之前，先检查 nmethod 是否已解除武装。如果已解除武装，则立即返回，避免不必要的锁获取。之后，在获取锁后再次检查（双重检查锁定模式），确保线程安全。\n\n优化效果\n\n减少锁竞争：通过提前检查条件，避免在 nmethod 已解除武装时获取锁，从而减少锁开销和线程阻塞。\n\n提高并发性能：在多线程环境中，当多个线程同时进入屏障时，如果 nmethod 已解除武装，大多数线程可以快速返回，而不需要等待锁。\n\n降低延迟：锁获取是相对昂贵的操作，避免锁获取可以减少方法入口屏障的延迟。\n\n优化思路\n\n采用“提前返回”策略：在执行昂贵操作（如锁获取）前，先检查快速路径条件。这类似于双重检查锁定模式，优化了常见情况（nmethod 已解除武装）的处理。\n\n平衡线程安全与性能：通过双重检查确保在锁内状态不变，但优先处理无竞争场景。", "original_code": "在 ShenandoahBarrierSetNMethod::nmethod_entry_barrier方法中，直接获取 nmethod 锁（通过 ShenandoahNMethod::lock_for_nmethod），然后检查 nmethod 是否已解除武装（disarmed）。如果已解除武装，则直接返回。但锁获取操作可能昂贵，尤其是在高并发场景下。", "optimized_code": "// 优化前：\nbool ShenandoahBarrierSetNMethod::nmethod_entry_barrier(nmethod* nm) {\n    ShenandoahReentrantLock* lock = ShenandoahNMethod::lock_for_nmethod(nm);\n    assert(lock != nullptr, \"Must be\");\n    ShenandoahReentrantLocker locker(lock);\n\n    if (!is_armed(nm)) {\n        // Some other thread got here first and healed the oops and disarmed the nmethod.\n        return true;\n    }\n    // ... 其他逻辑\n}\n\n// 优化后：\nbool ShenandoahBarrierSetNMethod::nmethod_entry_barrier(nmethod* nm) {\n    if (!is_armed(nm)) {\n        // Some other thread got here first and healed the oops and disarmed the nmethod. No need to continue.\n        return true;\n    }\n\n    ShenandoahReentrantLock* lock = ShenandoahNMethod::lock_for_nmethod(nm);\n    assert(lock != nullptr, \"Must be\");\n    ShenandoahReentrantLocker locker(lock);\n\n    if (!is_armed(nm)) {\n        // Some other thread managed to complete while we were waiting for lock. No need to continue.\n        return true;\n    }\n    // ... 其他逻辑\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/18e7d7b5e710b24e49b995777906a197e35795e6", "code_v0_no_empty_lines": "在 ShenandoahBarrierSetNMethod::nmethod_entry_barrier方法中，直接获取 nmethod 锁（通过 ShenandoahNMethod::lock_for_nmethod），然后检查 nmethod 是否已解除武装（disarmed）。如果已解除武装，则直接返回。但锁获取操作可能昂贵，尤其是在高并发场景下。", "code_v1_no_empty_lines": "// 优化前：\nbool ShenandoahBarrierSetNMethod::nmethod_entry_barrier(nmethod* nm) {\n    ShenandoahReentrantLock* lock = ShenandoahNMethod::lock_for_nmethod(nm);\n    assert(lock != nullptr, \"Must be\");\n    ShenandoahReentrantLocker locker(lock);\n\n    if (!is_armed(nm)) {\n        // Some other thread got here first and healed the oops and disarmed the nmethod.\n        return true;\n    }\n    // ... 其他逻辑\n}\n\n// 优化后：\nbool ShenandoahBarrierSetNMethod::nmethod_entry_barrier(nmethod* nm) {\n    if (!is_armed(nm)) {\n        // Some other thread got here first and healed the oops and disarmed the nmethod. No need to continue.\n        return true;\n    }\n\n    ShenandoahReentrantLock* lock = ShenandoahNMethod::lock_for_nmethod(nm);\n    assert(lock != nullptr, \"Must be\");\n    ShenandoahReentrantLocker locker(lock);\n\n    if (!is_armed(nm)) {\n        // Some other thread managed to complete while we were waiting for lock. No need to continue.\n        return true;\n    }\n    // ... 其他逻辑\n}", "target": "// 优化前：\nbool ShenandoahBarrierSetNMethod::nmethod_entry_barrier(nmethod* nm) {\n    ShenandoahReentrantLock* lock = ShenandoahNMethod::lock_for_nmethod(nm);\n    assert(lock != nullptr, \"Must be\");\n    ShenandoahReentrantLocker locker(lock);\n\n    if (!is_armed(nm)) {\n        // Some other thread got here first and healed the oops and disarmed the nmethod.\n        return true;\n    }\n    // ... 其他逻辑\n}\n\n// 优化后：\nbool ShenandoahBarrierSetNMethod::nmethod_entry_barrier(nmethod* nm) {\n    if (!is_armed(nm)) {\n        // Some other thread got here first and healed the oops and disarmed the nmethod. No need to continue.\n        return true;\n    }\n\n    ShenandoahReentrantLock* lock = ShenandoahNMethod::lock_for_nmethod(nm);\n    assert(lock != nullptr, \"Must be\");\n    ShenandoahReentrantLocker locker(lock);\n\n    if (!is_armed(nm)) {\n        // Some other thread managed to complete while we were waiting for lock. No need to continue.\n        return true;\n    }\n    // ... 其他逻辑\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在 ShenandoahBarrierSetNMethod::nmethod_entry_barrier方法中，直接获取 nmethod 锁（通过 ShenandoahNMethod::lock_for_nmethod），然后检查 nmethod 是否已解除武装（disarmed）。如果已解除武装，则直接返回。但锁获取操作可能昂贵，尤其是在高并发场景下。\n\n优化后：在获取锁之前，先检查 nmethod 是否已解除武装。如果已解除武装，则立即返回，避免不必要的锁获取。之后，在获取锁后再次检查（双重检查锁定模式），确保线程安全。\n\n优化效果\n\n减少锁竞争：通过提前检查条件，避免在 nmethod 已解除武装时获取锁，从而减少锁开销和线程阻塞。\n\n提高并发性能：在多线程环境中，当多个线程同时进入屏障时，如果 nmethod 已解除武装，大多数线程可以快速返回，而不需要等待锁。\n\n降低延迟：锁获取是相对昂贵的操作，避免锁获取可以减少方法入口屏障的延迟。\n\n优化思路\n\n采用“提前返回”策略：在执行昂贵操作（如锁获取）前，先检查快速路径条件。这类似于双重检查锁定模式，优化了常见情况（nmethod 已解除武装）的处理。\n\n平衡线程安全与性能：通过双重检查确保在锁内状态不变，但优先处理无竞争场景。"}
{"id": 964, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化前：在 SerialHeap::do_young_collection方法中，无论年轻代垃圾收集（young-GC）是否成功，都会调用 update_gc_stats方法来更新 GC 统计信息。该方法会计算老年代（TenuredGeneration）的晋升字节数（promoted bytes），但仅在年轻代收集且非完全 GC 时采样。如果年轻代收集失败（result为 false），统计更新可能不准确或多余。\n\n优化后：只在年轻代收集成功时（result为 true）才调用 _old_gen->update_promote_stats()来更新晋升统计。同时，在完全 GC（do_full_collection_no_gc_locker）中也添加了 update_promote_stats调用。在 TenuredGeneration类中，简化了统计更新逻辑，将 update_gc_stats方法替换为 update_promote_stats，直接计算晋升字节数并采样。\n\n优化效果\n\n避免在年轻代收集失败时更新统计信息，减少不必要的计算开销，提高 GC 效率。\n\n确保晋升字节数的采样准确，避免因收集失败或跳过年轻代收集而导致平均值计算错误（例如，之前如果晋升字节数为 0，可能错误地拉低平均值）。\n\n通过简化统计更新逻辑，降低了代码复杂度，减少了条件分支，可能提升 GC 性能。", "original_code": "在 SerialHeap::do_young_collection方法中，无论年轻代垃圾收集（young-GC）是否成功，都会调用 update_gc_stats方法来更新 GC 统计信息。该方法会计算老年代（TenuredGeneration）的晋升字节数（promoted bytes），但仅在年轻代收集且非完全 GC 时采样。如果年轻代收集失败（result为 false），统计更新可能不准确或多余。", "optimized_code": "在 SerialHeap::do_young_collection方法中：\n\n\n// 优化前：\nupdate_gc_stats(_young_gen, false);\n\n// 优化后：\n// Only update stats for successful young-gc\nif (result) {\n    _old_gen->update_promote_stats();\n}\n\n在 SerialHeap::do_full_collection_no_gc_locker方法中添加：\n\n\n_old_gen->update_promote_stats();\n\n在 TenuredGeneration类中，用 update_promote_stats替换 update_gc_stats：\n\n\n// 优化前：\nvoid TenuredGeneration::update_gc_stats(Generation* current_generation, bool full) {\n    // 复杂逻辑，包括条件检查\n}\n\n// 优化后：\nvoid TenuredGeneration::update_promote_stats() {\n    size_t used_after_gc = used();\n    size_t promoted_in_bytes;\n    if (used_after_gc > _used_at_prologue) {\n        promoted_in_bytes = used_after_gc - _used_at_prologue;\n    } else {\n        promoted_in_bytes = 0;\n    }\n    _avg_promoted->sample(promoted_in_bytes);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/a2030fff9833aba40e8c7c177151a30a0812a250", "code_v0_no_empty_lines": "在 SerialHeap::do_young_collection方法中，无论年轻代垃圾收集（young-GC）是否成功，都会调用 update_gc_stats方法来更新 GC 统计信息。该方法会计算老年代（TenuredGeneration）的晋升字节数（promoted bytes），但仅在年轻代收集且非完全 GC 时采样。如果年轻代收集失败（result为 false），统计更新可能不准确或多余。", "code_v1_no_empty_lines": "在 SerialHeap::do_young_collection方法中：\n\n\n// 优化前：\nupdate_gc_stats(_young_gen, false);\n\n// 优化后：\n// Only update stats for successful young-gc\nif (result) {\n    _old_gen->update_promote_stats();\n}\n\n在 SerialHeap::do_full_collection_no_gc_locker方法中添加：\n\n\n_old_gen->update_promote_stats();\n\n在 TenuredGeneration类中，用 update_promote_stats替换 update_gc_stats：\n\n\n// 优化前：\nvoid TenuredGeneration::update_gc_stats(Generation* current_generation, bool full) {\n    // 复杂逻辑，包括条件检查\n}\n\n// 优化后：\nvoid TenuredGeneration::update_promote_stats() {\n    size_t used_after_gc = used();\n    size_t promoted_in_bytes;\n    if (used_after_gc > _used_at_prologue) {\n        promoted_in_bytes = used_after_gc - _used_at_prologue;\n    } else {\n        promoted_in_bytes = 0;\n    }\n    _avg_promoted->sample(promoted_in_bytes);\n}", "target": "在 SerialHeap::do_young_collection方法中：\n\n\n// 优化前：\nupdate_gc_stats(_young_gen, false);\n\n// 优化后：\n// Only update stats for successful young-gc\nif (result) {\n    _old_gen->update_promote_stats();\n}\n\n在 SerialHeap::do_full_collection_no_gc_locker方法中添加：\n\n\n_old_gen->update_promote_stats();\n\n在 TenuredGeneration类中，用 update_promote_stats替换 update_gc_stats：\n\n\n// 优化前：\nvoid TenuredGeneration::update_gc_stats(Generation* current_generation, bool full) {\n    // 复杂逻辑，包括条件检查\n}\n\n// 优化后：\nvoid TenuredGeneration::update_promote_stats() {\n    size_t used_after_gc = used();\n    size_t promoted_in_bytes;\n    if (used_after_gc > _used_at_prologue) {\n        promoted_in_bytes = used_after_gc - _used_at_prologue;\n    } else {\n        promoted_in_bytes = 0;\n    }\n    _avg_promoted->sample(promoted_in_bytes);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：在 SerialHeap::do_young_collection方法中，无论年轻代垃圾收集（young-GC）是否成功，都会调用 update_gc_stats方法来更新 GC 统计信息。该方法会计算老年代（TenuredGeneration）的晋升字节数（promoted bytes），但仅在年轻代收集且非完全 GC 时采样。如果年轻代收集失败（result为 false），统计更新可能不准确或多余。\n\n优化后：只在年轻代收集成功时（result为 true）才调用 _old_gen->update_promote_stats()来更新晋升统计。同时，在完全 GC（do_full_collection_no_gc_locker）中也添加了 update_promote_stats调用。在 TenuredGeneration类中，简化了统计更新逻辑，将 update_gc_stats方法替换为 update_promote_stats，直接计算晋升字节数并采样。\n\n优化效果\n\n避免在年轻代收集失败时更新统计信息，减少不必要的计算开销，提高 GC 效率。\n\n确保晋升字节数的采样准确，避免因收集失败或跳过年轻代收集而导致平均值计算错误（例如，之前如果晋升字节数为 0，可能错误地拉低平均值）。\n\n通过简化统计更新逻辑，降低了代码复杂度，减少了条件分支，可能提升 GC 性能。"}
{"id": 965, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+内存优化", "optimization_description": "优化前：\n\n在C2编译器中，针对原始数组（如byte[]）的连续存储操作，会生成多个小尺寸存储指令（如四个StoreB指令）。每个存储操作可能伴随范围检查（RangeCheck），导致指令数较多，内存访问效率较低。\n\n在小端序系统上，优化已存在（通过VM_LITTLE_ENDIAN宏控制），但大端序系统未支持，导致性能不一致。\n\n优化后：\n\n识别相邻的存储操作（如四个连续的StoreB），并将它们合并为一个StoreI指令。合并过程考虑了字节序问题，确保值在内存中的布局正确。\n\n通过减少存储指令数，降低了指令开销，提高了内存带宽利用率。尤其在大端序系统上，现在也能享受此优化带来的性能提升。\n\n优化还调整了范围检查的逻辑，确保在合并存储后，异常处理路径正确（例如，如果某个范围检查失败，只执行部分存储）。", "original_code": "在C2编译器中，针对原始数组（如byte[]）的连续存储操作，会生成多个小尺寸存储指令（如四个StoreB指令）。每个存储操作可能伴随范围检查（RangeCheck），导致指令数较多，内存访问效率较低。\n\n在小端序系统上，优化已存在（通过VM_LITTLE_ENDIAN宏控制），但大端序系统未支持，导致性能不一致。", "optimized_code": "关键修改1：适配大端序的输入对检查（is_adjacent_input_pair函数）\n\n代码位置：src/hotspot/share/opto/memnode.cpp第3070-3074行。\n\n代码片段：\n\n#ifndef VM_LITTLE_ENDIAN\n// Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n// Swapping n1 with n2 gives same pattern as on little endian platforms.\nswap(n1, n2);\n#endif // !VM_LITTLE_ENDIAN\n\n分析：在大端序系统上，存储操作的输入顺序与小端序相反。通过交换n1和n2，使后续逻辑统一处理，确保相邻存储识别正确。这是优化能支持大端序的关键。\n\n关键修改2：值合并逻辑中的字节序处理（make_merged_input_value函数）\n\n代码位置：src/hotspot/share/opto/memnode.cpp第3283-3295行。\n\n代码片段：\n\n\n#ifdef VM_LITTLE_ENDIAN\n  con = con << bits_per_store;\n  con = con | (mask & con_i);\n#else // VM_LITTLE_ENDIAN\n  con_i = (mask & con_i) << (i * bits_per_store);\n  con = con | con_i;\n#endif // VM_LITTLE_ENDIAN\n\n分析：在合并多个值时，小端序下通过左移和或操作合并值（值从低到高放置）；大端序下，需将每个值左移到对应位置（从高到低放置），确保合并后值在内存中的布局符合大端序要求。这直接影响了存储内容的正确性。\n\n关键修改3：合并值的基值处理（make_merged_input_value函数）\n\n代码位置：src/hotspot/share/opto/memnode.cpp第3303-3308行。\n\n代码片段：\n\nNode* hi = _store->in(MemNode::ValueIn);\nNode* lo = first->in(MemNode::ValueIn);\n#ifndef VM_LITTLE_ENDIAN\n// `_store`和`first`在示意图中交换\nswap(hi, lo);\n#endif // !VM_LITTLE_ENDIAN\n\n分析：在大端序下，存储顺序相反，因此需要调整高位和低位值的引用，确保合并时基值（base）正确。这保证了值合并的源数据顺序正确。\n\n关键修改4：移除字节序限制（StoreNode::Ideal函数）\n\n代码位置：src/hotspot/share/opto/memnode.cpp第3476-3486行。\n\n代码片段：\n\n\nif (MergeStores && UseUnalignedAccesses) {\n  if (phase->C->post_loop_opts_phase()) {\n    MergePrimitiveArrayStores merge(phase, this);\n    Node* n = merge.merge();\n    if (n != nullptr) {\n      return n;\n    }\n  }\n  phase->C->record_for_post_loop_opts_igvn(this);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/f7862bd6b9994814c6dfd43d471122408601f288", "code_v0_no_empty_lines": "在C2编译器中，针对原始数组（如byte[]）的连续存储操作，会生成多个小尺寸存储指令（如四个StoreB指令）。每个存储操作可能伴随范围检查（RangeCheck），导致指令数较多，内存访问效率较低。\n\n在小端序系统上，优化已存在（通过VM_LITTLE_ENDIAN宏控制），但大端序系统未支持，导致性能不一致。", "code_v1_no_empty_lines": "关键修改1：适配大端序的输入对检查（is_adjacent_input_pair函数）\n\n代码位置：src/hotspot/share/opto/memnode.cpp第3070-3074行。\n\n代码片段：\n\n#ifndef VM_LITTLE_ENDIAN\n// Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n// Swapping n1 with n2 gives same pattern as on little endian platforms.\nswap(n1, n2);\n#endif // !VM_LITTLE_ENDIAN\n\n分析：在大端序系统上，存储操作的输入顺序与小端序相反。通过交换n1和n2，使后续逻辑统一处理，确保相邻存储识别正确。这是优化能支持大端序的关键。\n\n关键修改2：值合并逻辑中的字节序处理（make_merged_input_value函数）\n\n代码位置：src/hotspot/share/opto/memnode.cpp第3283-3295行。\n\n代码片段：\n\n\n#ifdef VM_LITTLE_ENDIAN\n  con = con << bits_per_store;\n  con = con | (mask & con_i);\n#else // VM_LITTLE_ENDIAN\n  con_i = (mask & con_i) << (i * bits_per_store);\n  con = con | con_i;\n#endif // VM_LITTLE_ENDIAN\n\n分析：在合并多个值时，小端序下通过左移和或操作合并值（值从低到高放置）；大端序下，需将每个值左移到对应位置（从高到低放置），确保合并后值在内存中的布局符合大端序要求。这直接影响了存储内容的正确性。\n\n关键修改3：合并值的基值处理（make_merged_input_value函数）\n\n代码位置：src/hotspot/share/opto/memnode.cpp第3303-3308行。\n\n代码片段：\n\nNode* hi = _store->in(MemNode::ValueIn);\nNode* lo = first->in(MemNode::ValueIn);\n#ifndef VM_LITTLE_ENDIAN\n// `_store`和`first`在示意图中交换\nswap(hi, lo);\n#endif // !VM_LITTLE_ENDIAN\n\n分析：在大端序下，存储顺序相反，因此需要调整高位和低位值的引用，确保合并时基值（base）正确。这保证了值合并的源数据顺序正确。\n\n关键修改4：移除字节序限制（StoreNode::Ideal函数）\n\n代码位置：src/hotspot/share/opto/memnode.cpp第3476-3486行。\n\n代码片段：\n\n\nif (MergeStores && UseUnalignedAccesses) {\n  if (phase->C->post_loop_opts_phase()) {\n    MergePrimitiveArrayStores merge(phase, this);\n    Node* n = merge.merge();\n    if (n != nullptr) {\n      return n;\n    }\n  }\n  phase->C->record_for_post_loop_opts_igvn(this);\n}", "target": "关键修改1：适配大端序的输入对检查（is_adjacent_input_pair函数）\n\n代码位置：src/hotspot/share/opto/memnode.cpp第3070-3074行。\n\n代码片段：\n\n#ifndef VM_LITTLE_ENDIAN\n// Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n// Swapping n1 with n2 gives same pattern as on little endian platforms.\nswap(n1, n2);\n#endif // !VM_LITTLE_ENDIAN\n\n分析：在大端序系统上，存储操作的输入顺序与小端序相反。通过交换n1和n2，使后续逻辑统一处理，确保相邻存储识别正确。这是优化能支持大端序的关键。\n\n关键修改2：值合并逻辑中的字节序处理（make_merged_input_value函数）\n\n代码位置：src/hotspot/share/opto/memnode.cpp第3283-3295行。\n\n代码片段：\n\n\n#ifdef VM_LITTLE_ENDIAN\n  con = con << bits_per_store;\n  con = con | (mask & con_i);\n#else // VM_LITTLE_ENDIAN\n  con_i = (mask & con_i) << (i * bits_per_store);\n  con = con | con_i;\n#endif // VM_LITTLE_ENDIAN\n\n分析：在合并多个值时，小端序下通过左移和或操作合并值（值从低到高放置）；大端序下，需将每个值左移到对应位置（从高到低放置），确保合并后值在内存中的布局符合大端序要求。这直接影响了存储内容的正确性。\n\n关键修改3：合并值的基值处理（make_merged_input_value函数）\n\n代码位置：src/hotspot/share/opto/memnode.cpp第3303-3308行。\n\n代码片段：\n\nNode* hi = _store->in(MemNode::ValueIn);\nNode* lo = first->in(MemNode::ValueIn);\n#ifndef VM_LITTLE_ENDIAN\n// `_store`和`first`在示意图中交换\nswap(hi, lo);\n#endif // !VM_LITTLE_ENDIAN\n\n分析：在大端序下，存储顺序相反，因此需要调整高位和低位值的引用，确保合并时基值（base）正确。这保证了值合并的源数据顺序正确。\n\n关键修改4：移除字节序限制（StoreNode::Ideal函数）\n\n代码位置：src/hotspot/share/opto/memnode.cpp第3476-3486行。\n\n代码片段：\n\n\nif (MergeStores && UseUnalignedAccesses) {\n  if (phase->C->post_loop_opts_phase()) {\n    MergePrimitiveArrayStores merge(phase, this);\n    Node* n = merge.merge();\n    if (n != nullptr) {\n      return n;\n    }\n  }\n  phase->C->record_for_post_loop_opts_igvn(this);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：\n\n在C2编译器中，针对原始数组（如byte[]）的连续存储操作，会生成多个小尺寸存储指令（如四个StoreB指令）。每个存储操作可能伴随范围检查（RangeCheck），导致指令数较多，内存访问效率较低。\n\n在小端序系统上，优化已存在（通过VM_LITTLE_ENDIAN宏控制），但大端序系统未支持，导致性能不一致。\n\n优化后：\n\n识别相邻的存储操作（如四个连续的StoreB），并将它们合并为一个StoreI指令。合并过程考虑了字节序问题，确保值在内存中的布局正确。\n\n通过减少存储指令数，降低了指令开销，提高了内存带宽利用率。尤其在大端序系统上，现在也能享受此优化带来的性能提升。\n\n优化还调整了范围检查的逻辑，确保在合并存储后，异常处理路径正确（例如，如果某个范围检查失败，只执行部分存储）。"}
{"id": 966, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+编译器优化", "optimization_description": "优化前：popcount操作可能通过软件实现（如标量循环或通用指令），效率较低，无法利用RISC-V的向量指令集。\n\n优化后：直接使用RISC-V Zvbb扩展中的vcpop_v指令实现向量化popcount，减少了指令数量，提高了并行性。\n\n优化效果\n\n性能提升：向量化popcount操作能够利用SIMD（单指令多数据）并行计算，显著提升处理大量数据时的吞吐量。尤其适用于大数据处理、图像处理等场景。\n\n代码效率：通过硬件指令直接实现popcount，减少了循环和条件判断，降低了CPU周期数。\n\n可扩展性：支持不同向量长度（VI和VL，即整数和长整型），增强了代码的通用性。", "original_code": "popcount操作可能通过软件实现（如标量循环或通用指令），效率较低，无法利用RISC-V的向量指令集。", "optimized_code": "添加Zvbb指令定义（在src/hotspot/cpu/riscv文件中）：\n\n// Vector Basic Bit-manipulation (Zvbb) Extension\nINSN(vcpop_v, 0b1010111, 0b010, 0b01110, 0b010010);\n\n这行代码定义了vcpop_v指令的编码，使编译器能够识别该指令。\n\n引入UseZvbb标志（在src/hotspot/cpu/riscv/riscv.ad文件中）：\n\n\nproduct(bool, UseZvbb, false, EXPERIMENTAL, \"Use Zvbb instructions\")\n\n这允许运行时控制是否启用Zvbb优化。\n\n实现popcount指令映射（在src/hotspot/cpu/riscv/riscv.ad文件中）：\n\n\ncase Op_PopCountVL:\ncase Op_PopCountVI:\n    return UseZvbb;\n\n这段代码确保当UseZvbb启用时，C2编译器会使用硬件指令处理popcount操作。\n\n添加向量化popcount指令实现（在src/hotspot/cpu/riscv/riscv.ad文件中）：\n\n\ninstruct vpopcount(vReg dst, vReg src) %{\n    match(Set dst (PopCountVI src));\n    match(Set dst (PopCountVL src));\n    ins_cost(VEC_COST);\n    format %{ \"vcpop_v $dst, $src\\t# vcpop_v without mask\" %}\n    ins_encode %{\n        BasicType bt = Matcher::vector_element_basic_type(this);\n        uint vlen = Matcher::vector_length(this);\n        __ vsetvli_helper(bt, vlen);\n        __ vcpop_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n    %}\n    ins_pipe(pipe_slow);\n%}\n\n这是具体的指令实现，将popcount操作映射到vcpop_v指令，并设置向量长度。", "source_url": "https://github.com/openjdk/riscv-port/commit/1aebab780c5b84a85b6f10884d05bb29bae3c3bf", "code_v0_no_empty_lines": "popcount操作可能通过软件实现（如标量循环或通用指令），效率较低，无法利用RISC-V的向量指令集。", "code_v1_no_empty_lines": "添加Zvbb指令定义（在src/hotspot/cpu/riscv文件中）：\n\n// Vector Basic Bit-manipulation (Zvbb) Extension\nINSN(vcpop_v, 0b1010111, 0b010, 0b01110, 0b010010);\n\n这行代码定义了vcpop_v指令的编码，使编译器能够识别该指令。\n\n引入UseZvbb标志（在src/hotspot/cpu/riscv/riscv.ad文件中）：\n\n\nproduct(bool, UseZvbb, false, EXPERIMENTAL, \"Use Zvbb instructions\")\n\n这允许运行时控制是否启用Zvbb优化。\n\n实现popcount指令映射（在src/hotspot/cpu/riscv/riscv.ad文件中）：\n\n\ncase Op_PopCountVL:\ncase Op_PopCountVI:\n    return UseZvbb;\n\n这段代码确保当UseZvbb启用时，C2编译器会使用硬件指令处理popcount操作。\n\n添加向量化popcount指令实现（在src/hotspot/cpu/riscv/riscv.ad文件中）：\n\n\ninstruct vpopcount(vReg dst, vReg src) %{\n    match(Set dst (PopCountVI src));\n    match(Set dst (PopCountVL src));\n    ins_cost(VEC_COST);\n    format %{ \"vcpop_v $dst, $src\\t# vcpop_v without mask\" %}\n    ins_encode %{\n        BasicType bt = Matcher::vector_element_basic_type(this);\n        uint vlen = Matcher::vector_length(this);\n        __ vsetvli_helper(bt, vlen);\n        __ vcpop_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n    %}\n    ins_pipe(pipe_slow);\n%}\n\n这是具体的指令实现，将popcount操作映射到vcpop_v指令，并设置向量长度。", "target": "添加Zvbb指令定义（在src/hotspot/cpu/riscv文件中）：\n\n// Vector Basic Bit-manipulation (Zvbb) Extension\nINSN(vcpop_v, 0b1010111, 0b010, 0b01110, 0b010010);\n\n这行代码定义了vcpop_v指令的编码，使编译器能够识别该指令。\n\n引入UseZvbb标志（在src/hotspot/cpu/riscv/riscv.ad文件中）：\n\n\nproduct(bool, UseZvbb, false, EXPERIMENTAL, \"Use Zvbb instructions\")\n\n这允许运行时控制是否启用Zvbb优化。\n\n实现popcount指令映射（在src/hotspot/cpu/riscv/riscv.ad文件中）：\n\n\ncase Op_PopCountVL:\ncase Op_PopCountVI:\n    return UseZvbb;\n\n这段代码确保当UseZvbb启用时，C2编译器会使用硬件指令处理popcount操作。\n\n添加向量化popcount指令实现（在src/hotspot/cpu/riscv/riscv.ad文件中）：\n\n\ninstruct vpopcount(vReg dst, vReg src) %{\n    match(Set dst (PopCountVI src));\n    match(Set dst (PopCountVL src));\n    ins_cost(VEC_COST);\n    format %{ \"vcpop_v $dst, $src\\t# vcpop_v without mask\" %}\n    ins_encode %{\n        BasicType bt = Matcher::vector_element_basic_type(this);\n        uint vlen = Matcher::vector_length(this);\n        __ vsetvli_helper(bt, vlen);\n        __ vcpop_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n    %}\n    ins_pipe(pipe_slow);\n%}\n\n这是具体的指令实现，将popcount操作映射到vcpop_v指令，并设置向量长度。", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：popcount操作可能通过软件实现（如标量循环或通用指令），效率较低，无法利用RISC-V的向量指令集。\n\n优化后：直接使用RISC-V Zvbb扩展中的vcpop_v指令实现向量化popcount，减少了指令数量，提高了并行性。\n\n优化效果\n\n性能提升：向量化popcount操作能够利用SIMD（单指令多数据）并行计算，显著提升处理大量数据时的吞吐量。尤其适用于大数据处理、图像处理等场景。\n\n代码效率：通过硬件指令直接实现popcount，减少了循环和条件判断，降低了CPU周期数。\n\n可扩展性：支持不同向量长度（VI和VL，即整数和长整型），增强了代码的通用性。"}
{"id": 967, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+编译器优化", "optimization_description": "该提交通过指令集和编译器协同优化，将高级向量操作下沉到硬件指令，显著提升字节反转性能。关键思路是利用RISC-V向量扩展替代软件实现，改动集中在编译器后端映射和指令定义上。", "original_code": "// No original code extracted from description\n", "optimized_code": "关键修改1：添加向量指令定义（src/hotspot/cpu/riscv/assembler_riscv.hpp）\ncpp\n下载\n复制\n运行\n// 新增指令定义：vrev8_v用于向量字节反转\nINSN(vrev8_v, 0b1010111, 0b010, 0b01001, 0b010010); // reverse bytes in every element\n\n作用：定义RISC-V指令vrev8_v的编码，该指令用于反转向量中每个元素的字节顺序。\n\n优化点：直接提供硬件指令支持，替代软件实现。\n\n关键修改2：实现编译器指令模式（src/hotspot/cpu/riscv/riscv_v.ad）\ncpp\n下载\n复制\n运行\n// 无掩码版本：将ReverseBytesV节点映射到vrev8_v指令\ninstruct vreverse_bytes(vReg dst, vReg src) %{\n  match(Set dst (ReverseBytesV src));  // 匹配ReverseBytesV节点\n  format %{ \"vreverse_bytes $dst, $src\" %}\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    uint vlen = Matcher::vector_length(this);\n    __ vsetvli_helper(bt, vlen);  // 设置向量长度\n    __ vrev8_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg)); // 发射vrev8_v指令\n  %}\n  ins_pipe(pipe_slow);\n%}\n\n// 掩码版本：支持条件执行\ninstruct vreverse_bytes_masked(vReg dst, vReg src, vRegMask_V0 v0) %{\n  match(Set dst (ReverseBytesV src v0));  // 匹配带掩码的ReverseBytesV\n  format %{ \"vreverse_bytes_masked $dst, $src, v0\" %}\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    uint vlen = Matcher::vector_length(this);\n    __ vsetvli_helper(bt, vlen);\n    __ vrev8_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), Assembler::v0_t); // 使用掩码v0\n  %}\n  ins_pipe(pipe_slow);\n%}\n\n作用：在编译器ADL文件中定义指令模式，将IR节点（ReverseBytesV）映射到机器指令。\n\n优化点：\n\n自动向量化：C2编译器在优化阶段识别ReverseBytesV操作后，可直接生成这些高效指令。\n\n灵活处理：支持掩码操作，允许部分元素更新，减少不必要的计算。", "source_url": "https://github.com/openjdk/riscv-port/commit/964d60892eec5e64942b49182a4c6d4105620acd", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "关键修改1：添加向量指令定义（src/hotspot/cpu/riscv/assembler_riscv.hpp）\ncpp\n下载\n复制\n运行\n// 新增指令定义：vrev8_v用于向量字节反转\nINSN(vrev8_v, 0b1010111, 0b010, 0b01001, 0b010010); // reverse bytes in every element\n\n作用：定义RISC-V指令vrev8_v的编码，该指令用于反转向量中每个元素的字节顺序。\n\n优化点：直接提供硬件指令支持，替代软件实现。\n\n关键修改2：实现编译器指令模式（src/hotspot/cpu/riscv/riscv_v.ad）\ncpp\n下载\n复制\n运行\n// 无掩码版本：将ReverseBytesV节点映射到vrev8_v指令\ninstruct vreverse_bytes(vReg dst, vReg src) %{\n  match(Set dst (ReverseBytesV src));  // 匹配ReverseBytesV节点\n  format %{ \"vreverse_bytes $dst, $src\" %}\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    uint vlen = Matcher::vector_length(this);\n    __ vsetvli_helper(bt, vlen);  // 设置向量长度\n    __ vrev8_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg)); // 发射vrev8_v指令\n  %}\n  ins_pipe(pipe_slow);\n%}\n\n// 掩码版本：支持条件执行\ninstruct vreverse_bytes_masked(vReg dst, vReg src, vRegMask_V0 v0) %{\n  match(Set dst (ReverseBytesV src v0));  // 匹配带掩码的ReverseBytesV\n  format %{ \"vreverse_bytes_masked $dst, $src, v0\" %}\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    uint vlen = Matcher::vector_length(this);\n    __ vsetvli_helper(bt, vlen);\n    __ vrev8_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), Assembler::v0_t); // 使用掩码v0\n  %}\n  ins_pipe(pipe_slow);\n%}\n\n作用：在编译器ADL文件中定义指令模式，将IR节点（ReverseBytesV）映射到机器指令。\n\n优化点：\n\n自动向量化：C2编译器在优化阶段识别ReverseBytesV操作后，可直接生成这些高效指令。\n\n灵活处理：支持掩码操作，允许部分元素更新，减少不必要的计算。", "target": "关键修改1：添加向量指令定义（src/hotspot/cpu/riscv/assembler_riscv.hpp）\ncpp\n下载\n复制\n运行\n// 新增指令定义：vrev8_v用于向量字节反转\nINSN(vrev8_v, 0b1010111, 0b010, 0b01001, 0b010010); // reverse bytes in every element\n\n作用：定义RISC-V指令vrev8_v的编码，该指令用于反转向量中每个元素的字节顺序。\n\n优化点：直接提供硬件指令支持，替代软件实现。\n\n关键修改2：实现编译器指令模式（src/hotspot/cpu/riscv/riscv_v.ad）\ncpp\n下载\n复制\n运行\n// 无掩码版本：将ReverseBytesV节点映射到vrev8_v指令\ninstruct vreverse_bytes(vReg dst, vReg src) %{\n  match(Set dst (ReverseBytesV src));  // 匹配ReverseBytesV节点\n  format %{ \"vreverse_bytes $dst, $src\" %}\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    uint vlen = Matcher::vector_length(this);\n    __ vsetvli_helper(bt, vlen);  // 设置向量长度\n    __ vrev8_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg)); // 发射vrev8_v指令\n  %}\n  ins_pipe(pipe_slow);\n%}\n\n// 掩码版本：支持条件执行\ninstruct vreverse_bytes_masked(vReg dst, vReg src, vRegMask_V0 v0) %{\n  match(Set dst (ReverseBytesV src v0));  // 匹配带掩码的ReverseBytesV\n  format %{ \"vreverse_bytes_masked $dst, $src, v0\" %}\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    uint vlen = Matcher::vector_length(this);\n    __ vsetvli_helper(bt, vlen);\n    __ vrev8_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), Assembler::v0_t); // 使用掩码v0\n  %}\n  ins_pipe(pipe_slow);\n%}\n\n作用：在编译器ADL文件中定义指令模式，将IR节点（ReverseBytesV）映射到机器指令。\n\n优化点：\n\n自动向量化：C2编译器在优化阶段识别ReverseBytesV操作后，可直接生成这些高效指令。\n\n灵活处理：支持掩码操作，允许部分元素更新，减少不必要的计算。", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "该提交通过指令集和编译器协同优化，将高级向量操作下沉到硬件指令，显著提升字节反转性能。关键思路是利用RISC-V向量扩展替代软件实现，改动集中在编译器后端映射和指令定义上。"}
{"id": 968, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "添加的if块（第4799-4808行）实现了阈值检查。代码使用 _compile->live_nodes()和 _compile->max_node_limit()获取当前节点数和限制，并乘以0.75作为阈值。根据编译选项（如是否启用 reduce allocation merges）记录不同的失败原因，从而控制优化流程。", "original_code": "// No original code extracted from description\n", "optimized_code": "@@ -4793,6 +4793,20 @@ void ConnectionGraph::split_unique_types(GrowableArray<Node *> &alloc_worklist,\n4793     nmm->set_memory_at(ni, result);\n4794   }\n4795 }\n4796+\n4797+ // If we have crossed the 3/4 point of max node limit it's too risky\n4798+ // to continue with EA/SR because we might hit the max node limit.\n4799+ if (_compile->live_nodes() >= _compile->max_node_limit() * 0.75) {\n4800+   if (_compile->do_reduce_allocation_merges()) {\n4801+     _compile->record_failure(C2Compiler::retry_no_reduce_allocation_merges());\n4802+   } else if (_invocation > 0) {\n4803+     _compile->record_failure(C2Compiler::retry_no_iterative_escape_analysis());\n4804+   } else {\n4805+     _compile->record_failure(C2Compiler::retry_no_escape_analysis());\n4806+   }\n4807+   return;\n4808+ }\n4809+\n4796     igvn->hash_insert(nmm);\n4797     record_for_optimizer(nmm);\n4798 }", "source_url": "https://github.com/openjdk/riscv-port/commit/b351b5f60ed836e6e21aa4ce5681e573a6057eb6", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "@@ -4793,6 +4793,20 @@ void ConnectionGraph::split_unique_types(GrowableArray<Node *> &alloc_worklist,\n4793     nmm->set_memory_at(ni, result);\n4794   }\n4795 }\n4796+\n4797+ // If we have crossed the 3/4 point of max node limit it's too risky\n4798+ // to continue with EA/SR because we might hit the max node limit.\n4799+ if (_compile->live_nodes() >= _compile->max_node_limit() * 0.75) {\n4800+   if (_compile->do_reduce_allocation_merges()) {\n4801+     _compile->record_failure(C2Compiler::retry_no_reduce_allocation_merges());\n4802+   } else if (_invocation > 0) {\n4803+     _compile->record_failure(C2Compiler::retry_no_iterative_escape_analysis());\n4804+   } else {\n4805+     _compile->record_failure(C2Compiler::retry_no_escape_analysis());\n4806+   }\n4807+   return;\n4808+ }\n4809+\n4796     igvn->hash_insert(nmm);\n4797     record_for_optimizer(nmm);\n4798 }", "target": "@@ -4793,6 +4793,20 @@ void ConnectionGraph::split_unique_types(GrowableArray<Node *> &alloc_worklist,\n4793     nmm->set_memory_at(ni, result);\n4794   }\n4795 }\n4796+\n4797+ // If we have crossed the 3/4 point of max node limit it's too risky\n4798+ // to continue with EA/SR because we might hit the max node limit.\n4799+ if (_compile->live_nodes() >= _compile->max_node_limit() * 0.75) {\n4800+   if (_compile->do_reduce_allocation_merges()) {\n4801+     _compile->record_failure(C2Compiler::retry_no_reduce_allocation_merges());\n4802+   } else if (_invocation > 0) {\n4803+     _compile->record_failure(C2Compiler::retry_no_iterative_escape_analysis());\n4804+   } else {\n4805+     _compile->record_failure(C2Compiler::retry_no_escape_analysis());\n4806+   }\n4807+   return;\n4808+ }\n4809+\n4796     igvn->hash_insert(nmm);\n4797     record_for_optimizer(nmm);\n4798 }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "添加的if块（第4799-4808行）实现了阈值检查。代码使用 _compile->live_nodes()和 _compile->max_node_limit()获取当前节点数和限制，并乘以0.75作为阈值。根据编译选项（如是否启用 reduce allocation merges）记录不同的失败原因，从而控制优化流程。"}
{"id": 969, "source": "riscv-dataset-excel", "optimization_type": "算法优化", "optimization_description": "利用位集合（bitset）表示寄存器集合，通过位操作（如contains检查）快速判断寄存器是否重复。\n\n使用递归模板函数遍历寄存器列表，逐步构建寄存器集合，并在每一步检查当前寄存器是否已存在。这避免了嵌套循环，实现了线性时间检查", "original_code": "// No original code extracted from description\n", "optimized_code": "// 新增的递归模板函数，用于线性检查寄存器是否重复\ntemplate<typename R>\nconstexpr bool different_registers(AbstractRegSet<R> allocated_regs, R first_register) {\n    return !allocated_regs.contains(first_register);\n}\n\ntemplate<typename R, typename... Rx>\nconstexpr bool different_registers(AbstractRegSet<R> allocated_regs, R first_register, Rx... more_registers) {\n    if (allocated_regs.contains(first_register)) {\n        return false;\n    }\n    return different_registers(allocated_regs + first_register, more_registers...);\n}\n\n// 修改后的assert_different_registers函数，调用线性算法\ntemplate<typename R, typename... Rx>\ninline void assert_different_registers(R first_register, Rx... more_registers) {\n#ifdef ASSERT\n    if (!different_registers(first_register, more_registers...)) {\n        // 错误处理代码（略）\n    }\n#endif\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/9b3694c4fcc3cf46c0d827427ae8aadb477e8e22", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 新增的递归模板函数，用于线性检查寄存器是否重复\ntemplate<typename R>\nconstexpr bool different_registers(AbstractRegSet<R> allocated_regs, R first_register) {\n    return !allocated_regs.contains(first_register);\n}\n\ntemplate<typename R, typename... Rx>\nconstexpr bool different_registers(AbstractRegSet<R> allocated_regs, R first_register, Rx... more_registers) {\n    if (allocated_regs.contains(first_register)) {\n        return false;\n    }\n    return different_registers(allocated_regs + first_register, more_registers...);\n}\n\n// 修改后的assert_different_registers函数，调用线性算法\ntemplate<typename R, typename... Rx>\ninline void assert_different_registers(R first_register, Rx... more_registers) {\n#ifdef ASSERT\n    if (!different_registers(first_register, more_registers...)) {\n        // 错误处理代码（略）\n    }\n#endif\n}", "target": "// 新增的递归模板函数，用于线性检查寄存器是否重复\ntemplate<typename R>\nconstexpr bool different_registers(AbstractRegSet<R> allocated_regs, R first_register) {\n    return !allocated_regs.contains(first_register);\n}\n\ntemplate<typename R, typename... Rx>\nconstexpr bool different_registers(AbstractRegSet<R> allocated_regs, R first_register, Rx... more_registers) {\n    if (allocated_regs.contains(first_register)) {\n        return false;\n    }\n    return different_registers(allocated_regs + first_register, more_registers...);\n}\n\n// 修改后的assert_different_registers函数，调用线性算法\ntemplate<typename R, typename... Rx>\ninline void assert_different_registers(R first_register, Rx... more_registers) {\n#ifdef ASSERT\n    if (!different_registers(first_register, more_registers...)) {\n        // 错误处理代码（略）\n    }\n#endif\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "利用位集合（bitset）表示寄存器集合，通过位操作（如contains检查）快速判断寄存器是否重复。\n\n使用递归模板函数遍历寄存器列表，逐步构建寄存器集合，并在每一步检查当前寄存器是否已存在。这避免了嵌套循环，实现了线性时间检查"}
{"id": 970, "source": "riscv-dataset-excel", "optimization_type": "其他", "optimization_description": "通过代理模式封装控制台实现，将JLine终端的初始化延迟到真正需要时（如调用读方法）。\n\n使用标志位（jlineInitialized）和 volatile 变量确保线程安全的惰性初始化。\n\n对于写操作，直接委托给标准控制台；对于读操作，才初始化JLine终端。", "original_code": "// No original code extracted from description\n", "optimized_code": "private JdkConsole getDelegate(boolean needsJLine) {\n    if (!needsJLine || jlineInitialized) {\n        return delegate;\n    }\n    return initializeJLineDelegate(); // 惰性初始化JLine\n}\n\n// 惰性初始化JLine终端的同步方法\nprivate synchronized JdkConsole initializeJLineDelegate() {\n    if (jlineInitialized) {\n        return delegate;\n    }\n    try {\n        Terminal terminal = TerminalBuilder.builder().encoding(charset)\n            .exec(false)\n            .systemOutput(SystemOutput.SysOut)\n            .build();\n        delegate = new JdkConsoleImpl(terminal); // 只有这里才初始化JLine\n    } catch (Exception e) {\n        // 保持原有委托（标准控制台）\n    }\n    jlineInitialized = true;\n    return delegate;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/f7dbb98fe69eb98f8544577d81550b4fd817864b", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "private JdkConsole getDelegate(boolean needsJLine) {\n    if (!needsJLine || jlineInitialized) {\n        return delegate;\n    }\n    return initializeJLineDelegate(); // 惰性初始化JLine\n}\n\n// 惰性初始化JLine终端的同步方法\nprivate synchronized JdkConsole initializeJLineDelegate() {\n    if (jlineInitialized) {\n        return delegate;\n    }\n    try {\n        Terminal terminal = TerminalBuilder.builder().encoding(charset)\n            .exec(false)\n            .systemOutput(SystemOutput.SysOut)\n            .build();\n        delegate = new JdkConsoleImpl(terminal); // 只有这里才初始化JLine\n    } catch (Exception e) {\n        // 保持原有委托（标准控制台）\n    }\n    jlineInitialized = true;\n    return delegate;\n}", "target": "private JdkConsole getDelegate(boolean needsJLine) {\n    if (!needsJLine || jlineInitialized) {\n        return delegate;\n    }\n    return initializeJLineDelegate(); // 惰性初始化JLine\n}\n\n// 惰性初始化JLine终端的同步方法\nprivate synchronized JdkConsole initializeJLineDelegate() {\n    if (jlineInitialized) {\n        return delegate;\n    }\n    try {\n        Terminal terminal = TerminalBuilder.builder().encoding(charset)\n            .exec(false)\n            .systemOutput(SystemOutput.SysOut)\n            .build();\n        delegate = new JdkConsoleImpl(terminal); // 只有这里才初始化JLine\n    } catch (Exception e) {\n        // 保持原有委托（标准控制台）\n    }\n    jlineInitialized = true;\n    return delegate;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "通过代理模式封装控制台实现，将JLine终端的初始化延迟到真正需要时（如调用读方法）。\n\n使用标志位（jlineInitialized）和 volatile 变量确保线程安全的惰性初始化。\n\n对于写操作，直接委托给标准控制台；对于读操作，才初始化JLine终端。"}
{"id": 971, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "优化前实现：\n\nCountLeadingZeros和CountTrailingZeros操作使用标量指令逐个处理数据元素\n\n对于数组或向量操作，需要循环遍历每个元素，分别调用标量计数函数\n\n无法利用RISC-V的向量处理单元，执行效率较低\n\n优化后实现：\n\n添加对CountLeadingZerosV和CountTrailingZerosV向量化操作的支持\n\n使用单条向量指令（vclz.v/vctz.v）同时处理多个数据元素\n\n充分利用RISC-V V扩展的128位或更大向量寄存器，实现并行计算\n\n优化效果：\n\n性能提升：通过向量化并行处理，显著提高前导零/后续零计数操作的吞吐量\n\n资源利用率：更好地利用RISC-V处理器的向量处理单元，提高硬件效率\n\n可扩展性：支持不同向量长度的操作，适应不同数据规模\n\n优化思路：\n\n识别可向量化的数学运算（前导零/后续零计数）\n\n映射到RISC-V V扩展的专用向量指令\n\n在编译器后端添加指令匹配模式，自动将标量操作转换为向量操作\n\n提供掩码和非掩码两种版本，支持灵活的使用场景", "original_code": "// No original code extracted from description\n", "optimized_code": "关键修改1：添加新的向量指令定义\n\n文件：​ src/hotspot/cpu/riscv/assembler_riscv.hpp\n\n// 添加新的向量指令编码\nINSN (vclz_v, 0b1010111, 0b010, 0b01100, 0b010010);  // 向量前导零计数指令\nINSN (vctz_v, 0b1010111, 0b010, 0b01101, 0b010010);  // 向量后续零计数指令\n关键修改2：添加编译器指令匹配规则\n\n文件：​ src/hotspot/cpu/riscv/riscv.ad\n// 为CountLeadingZerosV操作添加指令匹配\ninstruct vcountLeadingZeros_masked(vReg dst_src, vRegMask_V0 v0) %{\n  match(Set dst_src (CountLeadingZerosV dst_src v0));  // 掩码版本\n  ins_cost(VEC_COST);\n  format %{ \"vcount_leading_zeros_masked $dst_src, $dst_src, v0\" %};\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    uint vlen = Matcher::vector_length(this);\n    __ vsetvli_helper(bt, vlen);\n    __ vclz_v(as_VectorRegister($dst_src$$reg), \n             as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n  %}\n  ins_pipe(pipe_slow);\n%}\n\ninstruct vcountLeadingZeros(vReg dst, vReg src) %{\n  match(Set dst (CountLeadingZerosV src));  // 非掩码版本\n  ins_cost(VEC_COST);\n  format %{ \"vcount_leading_zeros $dst, $src\" %};\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    uint vlen = Matcher::vector_length(this);\n    __ vsetvli_helper(bt, vlen);\n    __ vclz_v(as_VectorRegister($dst$$reg), \n             as_VectorRegister($src$$reg));\n  %}\n  ins_pipe(pipe_slow);\n%}\n\n// 类似地为CountTrailingZerosV添加指令匹配\ninstruct vcountTrailingZeros_masked(vReg dst_src, vRegMask_V0 v0) %{\n  match(Set dst_src (CountTrailingZerosV dst_src v0));\n  // ... 编码生成vctz_v指令\n%}\n关键修改3：更新架构支持检测\n\n文件：​ src/hotspot/cpu/riscv/riscv.ad\n\ncase Op_CountTrailingZerosV:\ncase Op_CountLeadingZerosV:\n// 添加对新操作的支持检测\nbreak;", "source_url": "https://github.com/openjdk/riscv-port/commit/f95c93740538e5e508407ec6750ed9f126fdc3c3", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "关键修改1：添加新的向量指令定义\n\n文件：​ src/hotspot/cpu/riscv/assembler_riscv.hpp\n\n// 添加新的向量指令编码\nINSN (vclz_v, 0b1010111, 0b010, 0b01100, 0b010010);  // 向量前导零计数指令\nINSN (vctz_v, 0b1010111, 0b010, 0b01101, 0b010010);  // 向量后续零计数指令\n关键修改2：添加编译器指令匹配规则\n\n文件：​ src/hotspot/cpu/riscv/riscv.ad\n// 为CountLeadingZerosV操作添加指令匹配\ninstruct vcountLeadingZeros_masked(vReg dst_src, vRegMask_V0 v0) %{\n  match(Set dst_src (CountLeadingZerosV dst_src v0));  // 掩码版本\n  ins_cost(VEC_COST);\n  format %{ \"vcount_leading_zeros_masked $dst_src, $dst_src, v0\" %};\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    uint vlen = Matcher::vector_length(this);\n    __ vsetvli_helper(bt, vlen);\n    __ vclz_v(as_VectorRegister($dst_src$$reg), \n             as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n  %}\n  ins_pipe(pipe_slow);\n%}\n\ninstruct vcountLeadingZeros(vReg dst, vReg src) %{\n  match(Set dst (CountLeadingZerosV src));  // 非掩码版本\n  ins_cost(VEC_COST);\n  format %{ \"vcount_leading_zeros $dst, $src\" %};\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    uint vlen = Matcher::vector_length(this);\n    __ vsetvli_helper(bt, vlen);\n    __ vclz_v(as_VectorRegister($dst$$reg), \n             as_VectorRegister($src$$reg));\n  %}\n  ins_pipe(pipe_slow);\n%}\n\n// 类似地为CountTrailingZerosV添加指令匹配\ninstruct vcountTrailingZeros_masked(vReg dst_src, vRegMask_V0 v0) %{\n  match(Set dst_src (CountTrailingZerosV dst_src v0));\n  // ... 编码生成vctz_v指令\n%}\n关键修改3：更新架构支持检测\n\n文件：​ src/hotspot/cpu/riscv/riscv.ad\n\ncase Op_CountTrailingZerosV:\ncase Op_CountLeadingZerosV:\n// 添加对新操作的支持检测\nbreak;", "target": "关键修改1：添加新的向量指令定义\n\n文件：​ src/hotspot/cpu/riscv/assembler_riscv.hpp\n\n// 添加新的向量指令编码\nINSN (vclz_v, 0b1010111, 0b010, 0b01100, 0b010010);  // 向量前导零计数指令\nINSN (vctz_v, 0b1010111, 0b010, 0b01101, 0b010010);  // 向量后续零计数指令\n关键修改2：添加编译器指令匹配规则\n\n文件：​ src/hotspot/cpu/riscv/riscv.ad\n// 为CountLeadingZerosV操作添加指令匹配\ninstruct vcountLeadingZeros_masked(vReg dst_src, vRegMask_V0 v0) %{\n  match(Set dst_src (CountLeadingZerosV dst_src v0));  // 掩码版本\n  ins_cost(VEC_COST);\n  format %{ \"vcount_leading_zeros_masked $dst_src, $dst_src, v0\" %};\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    uint vlen = Matcher::vector_length(this);\n    __ vsetvli_helper(bt, vlen);\n    __ vclz_v(as_VectorRegister($dst_src$$reg), \n             as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n  %}\n  ins_pipe(pipe_slow);\n%}\n\ninstruct vcountLeadingZeros(vReg dst, vReg src) %{\n  match(Set dst (CountLeadingZerosV src));  // 非掩码版本\n  ins_cost(VEC_COST);\n  format %{ \"vcount_leading_zeros $dst, $src\" %};\n  ins_encode %{\n    BasicType bt = Matcher::vector_element_basic_type(this);\n    uint vlen = Matcher::vector_length(this);\n    __ vsetvli_helper(bt, vlen);\n    __ vclz_v(as_VectorRegister($dst$$reg), \n             as_VectorRegister($src$$reg));\n  %}\n  ins_pipe(pipe_slow);\n%}\n\n// 类似地为CountTrailingZerosV添加指令匹配\ninstruct vcountTrailingZeros_masked(vReg dst_src, vRegMask_V0 v0) %{\n  match(Set dst_src (CountTrailingZerosV dst_src v0));\n  // ... 编码生成vctz_v指令\n%}\n关键修改3：更新架构支持检测\n\n文件：​ src/hotspot/cpu/riscv/riscv.ad\n\ncase Op_CountTrailingZerosV:\ncase Op_CountLeadingZerosV:\n// 添加对新操作的支持检测\nbreak;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前实现：\n\nCountLeadingZeros和CountTrailingZeros操作使用标量指令逐个处理数据元素\n\n对于数组或向量操作，需要循环遍历每个元素，分别调用标量计数函数\n\n无法利用RISC-V的向量处理单元，执行效率较低\n\n优化后实现：\n\n添加对CountLeadingZerosV和CountTrailingZerosV向量化操作的支持\n\n使用单条向量指令（vclz.v/vctz.v）同时处理多个数据元素\n\n充分利用RISC-V V扩展的128位或更大向量寄存器，实现并行计算\n\n优化效果：\n\n性能提升：通过向量化并行处理，显著提高前导零/后续零计数操作的吞吐量\n\n资源利用率：更好地利用RISC-V处理器的向量处理单元，提高硬件效率\n\n可扩展性：支持不同向量长度的操作，适应不同数据规模\n\n优化思路：\n\n识别可向量化的数学运算（前导零/后续零计数）\n\n映射到RISC-V V扩展的专用向量指令\n\n在编译器后端添加指令匹配模式，自动将标量操作转换为向量操作\n\n提供掩码和非掩码两种版本，支持灵活的使用场景"}
{"id": 972, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "目标场景：主要优化AArch上整数除法运算中的取余计算，这在BigInteger、哈希计算等场景中很常见。\n\n性能收益：在Neoverse处理器上，预计有5-15%的性能提升，具体取决于工作负载和具体的Neoverse变种。\n\n兼容性：对非Neoverse架构零影响，保持原有性能。", "original_code": "// No original code extracted from description\n", "optimized_code": "1.// 新增的优化版msub实现\nvoid MacroAssembler::msub(Register Rd, Register Rn, Register Rm, Register Ra) {\n  if (VM_Version::supports_a53mac() &&!= zr)\n    nop();\n  if (VM_Version::is_neoverse()) {\n    mul(rscratch1, Rn, Rm);    // 分解为乘法\n    sub(Rd, Ra, rscratch1);    // 再执行减法\n  } else {\n    Assembler::msub(Rd, Rn, Rm, Ra);  // 非Neoverse保持原实现\n  }\n}\n2.// 在corrected_idivl函数中的修改\n// 优化前：\nAssembler::msubw(result, scratch, rb, ra);\n// 优化后：\nmsubw(result, scratch, rb, ra);  // 调用优化后的实现\n3.// 新增Neoverse CPU模型和检测函数\nenum Neoverse_CPU_Model {\n  CPU_MODEL_NEOVERSE_N1 = 0xd0c,\n  CPU_MODEL_NEOVERSE_N2 = 0xd49,\n  // ...\n};\n\nstatic bool is_neoverse() {\n  switch(_model) {\n    case CPU_MODEL_NEOVERSE_N1:\n    case CPU_MODEL_NEOVERSE_N2:\n    // ... 检测逻辑\n    return true;\n    default: return false;\n  }\n}\n4.// 优化前：硬编码模型检测\nif (_cpu == CPU_ARM && (model_is(0xd0c) || model_is(0xd49) || ...))\n\n// 优化后：使用清晰的接口\nif (is_neoverse())  // 更简洁可读", "source_url": "https://github.com/openjdk/riscv-port/commit/dab92c51c70767abcda3b1a91dd7d1a9b40290c1", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1.// 新增的优化版msub实现\nvoid MacroAssembler::msub(Register Rd, Register Rn, Register Rm, Register Ra) {\n  if (VM_Version::supports_a53mac() &&!= zr)\n    nop();\n  if (VM_Version::is_neoverse()) {\n    mul(rscratch1, Rn, Rm);    // 分解为乘法\n    sub(Rd, Ra, rscratch1);    // 再执行减法\n  } else {\n    Assembler::msub(Rd, Rn, Rm, Ra);  // 非Neoverse保持原实现\n  }\n}\n2.// 在corrected_idivl函数中的修改\n// 优化前：\nAssembler::msubw(result, scratch, rb, ra);\n// 优化后：\nmsubw(result, scratch, rb, ra);  // 调用优化后的实现\n3.// 新增Neoverse CPU模型和检测函数\nenum Neoverse_CPU_Model {\n  CPU_MODEL_NEOVERSE_N1 = 0xd0c,\n  CPU_MODEL_NEOVERSE_N2 = 0xd49,\n  // ...\n};\n\nstatic bool is_neoverse() {\n  switch(_model) {\n    case CPU_MODEL_NEOVERSE_N1:\n    case CPU_MODEL_NEOVERSE_N2:\n    // ... 检测逻辑\n    return true;\n    default: return false;\n  }\n}\n4.// 优化前：硬编码模型检测\nif (_cpu == CPU_ARM && (model_is(0xd0c) || model_is(0xd49) || ...))\n\n// 优化后：使用清晰的接口\nif (is_neoverse())  // 更简洁可读", "target": "1.// 新增的优化版msub实现\nvoid MacroAssembler::msub(Register Rd, Register Rn, Register Rm, Register Ra) {\n  if (VM_Version::supports_a53mac() &&!= zr)\n    nop();\n  if (VM_Version::is_neoverse()) {\n    mul(rscratch1, Rn, Rm);    // 分解为乘法\n    sub(Rd, Ra, rscratch1);    // 再执行减法\n  } else {\n    Assembler::msub(Rd, Rn, Rm, Ra);  // 非Neoverse保持原实现\n  }\n}\n2.// 在corrected_idivl函数中的修改\n// 优化前：\nAssembler::msubw(result, scratch, rb, ra);\n// 优化后：\nmsubw(result, scratch, rb, ra);  // 调用优化后的实现\n3.// 新增Neoverse CPU模型和检测函数\nenum Neoverse_CPU_Model {\n  CPU_MODEL_NEOVERSE_N1 = 0xd0c,\n  CPU_MODEL_NEOVERSE_N2 = 0xd49,\n  // ...\n};\n\nstatic bool is_neoverse() {\n  switch(_model) {\n    case CPU_MODEL_NEOVERSE_N1:\n    case CPU_MODEL_NEOVERSE_N2:\n    // ... 检测逻辑\n    return true;\n    default: return false;\n  }\n}\n4.// 优化前：硬编码模型检测\nif (_cpu == CPU_ARM && (model_is(0xd0c) || model_is(0xd49) || ...))\n\n// 优化后：使用清晰的接口\nif (is_neoverse())  // 更简洁可读", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "目标场景：主要优化AArch上整数除法运算中的取余计算，这在BigInteger、哈希计算等场景中很常见。\n\n性能收益：在Neoverse处理器上，预计有5-15%的性能提升，具体取决于工作负载和具体的Neoverse变种。\n\n兼容性：对非Neoverse架构零影响，保持原有性能。"}
{"id": 973, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+内存优化", "optimization_description": "向量化效率：选择最优对齐基准，提升SIMD指令效率\n\n内存访问：减少缓存未命中和内存访问延迟\n\n适应性：动态适应不同的向量化场景", "original_code": "// No original code extracted from description\n", "optimized_code": "1.// 新增方法 - 智能选择对齐引用\nvoid SuperWord::determine_mem_ref_and_aw_for_main_loop_alignment() {\n    if (_mem_ref_for_main_loop_alignment != nullptr) return;\n    \n    MemNode const* mem_ref = nullptr;\n    int max_aw = 0;\n    for (int i = 0; i < _packset.length(); i++) {\n        Node_List* pack = _packset.at(i);\n        MemNode* first = pack->at(0)->isa_Mem();\n        if (first == nullptr) continue;\n        \n        int vw = first->memory_size() * pack->size();\n        if (vw > max_aw) {\n            max_aw = vw;\n            mem_ref = first;\n        }\n    }\n    _mem_ref_for_main_loop_alignment = mem_ref;\n    _aw_for_main_loop_alignment = max_aw;\n}\n2.// 优化前 - 简单选择第一个引用\nMemNode* align_to_mem_ref = nullptr;\nif (align_to_mem_ref == nullptr) {\n    align_to_mem_ref = mem_ref;\n    set_align_to_ref(align_to_mem_ref);\n}\n\n// 优化后 - 智能选择最大宽度引用\ndetermine_mem_ref_and_aw_for_main_loop_alignment();\nconst MemNode* align_to_ref = _mem_ref_for_main_loop_alignment;\nconst int aw = _aw_for_main_loop_alignment;", "source_url": "https://github.com/openjdk/riscv-port/commit/d517d2df451e135583083ed3684d7d3241b36f76", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1.// 新增方法 - 智能选择对齐引用\nvoid SuperWord::determine_mem_ref_and_aw_for_main_loop_alignment() {\n    if (_mem_ref_for_main_loop_alignment != nullptr) return;\n    \n    MemNode const* mem_ref = nullptr;\n    int max_aw = 0;\n    for (int i = 0; i < _packset.length(); i++) {\n        Node_List* pack = _packset.at(i);\n        MemNode* first = pack->at(0)->isa_Mem();\n        if (first == nullptr) continue;\n        \n        int vw = first->memory_size() * pack->size();\n        if (vw > max_aw) {\n            max_aw = vw;\n            mem_ref = first;\n        }\n    }\n    _mem_ref_for_main_loop_alignment = mem_ref;\n    _aw_for_main_loop_alignment = max_aw;\n}\n2.// 优化前 - 简单选择第一个引用\nMemNode* align_to_mem_ref = nullptr;\nif (align_to_mem_ref == nullptr) {\n    align_to_mem_ref = mem_ref;\n    set_align_to_ref(align_to_mem_ref);\n}\n\n// 优化后 - 智能选择最大宽度引用\ndetermine_mem_ref_and_aw_for_main_loop_alignment();\nconst MemNode* align_to_ref = _mem_ref_for_main_loop_alignment;\nconst int aw = _aw_for_main_loop_alignment;", "target": "1.// 新增方法 - 智能选择对齐引用\nvoid SuperWord::determine_mem_ref_and_aw_for_main_loop_alignment() {\n    if (_mem_ref_for_main_loop_alignment != nullptr) return;\n    \n    MemNode const* mem_ref = nullptr;\n    int max_aw = 0;\n    for (int i = 0; i < _packset.length(); i++) {\n        Node_List* pack = _packset.at(i);\n        MemNode* first = pack->at(0)->isa_Mem();\n        if (first == nullptr) continue;\n        \n        int vw = first->memory_size() * pack->size();\n        if (vw > max_aw) {\n            max_aw = vw;\n            mem_ref = first;\n        }\n    }\n    _mem_ref_for_main_loop_alignment = mem_ref;\n    _aw_for_main_loop_alignment = max_aw;\n}\n2.// 优化前 - 简单选择第一个引用\nMemNode* align_to_mem_ref = nullptr;\nif (align_to_mem_ref == nullptr) {\n    align_to_mem_ref = mem_ref;\n    set_align_to_ref(align_to_mem_ref);\n}\n\n// 优化后 - 智能选择最大宽度引用\ndetermine_mem_ref_and_aw_for_main_loop_alignment();\nconst MemNode* align_to_ref = _mem_ref_for_main_loop_alignment;\nconst int aw = _aw_for_main_loop_alignment;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "向量化效率：选择最优对齐基准，提升SIMD指令效率\n\n内存访问：减少缓存未命中和内存访问延迟\n\n适应性：动态适应不同的向量化场景"}
{"id": 974, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+算法优化", "optimization_description": "性能提升：利用CPU除法指令替代软件实现\n\n代码简化：移除divRemNegativeLong和divWord等复杂方法\n\n维护性：减少约100行复杂代码", "original_code": "// No original code extracted from description\n", "optimized_code": "1.// 优化前 - 复杂的条件分支\nif (v1 == 1) {\n    q1 = tmp;\n    r_tmp = 0;\n} else if (tmp >= 0) {\n    q1 = tmp1;\n    r_tmp = tmp - q1 * v1;\n} else {\n    long[] rq = divRemNegativeLong(tmp, v1);\n    q1 = rq[1];\n    r_tmp = rq[0];\n}\n\n// 优化后 - 直接使用硬件优化指令\nlong q1 = Long.divideUnsigned(tmp, v1);\nlong r_tmp = Long.remainderUnsigned(tmp, v1);\n2.// 优化前 - 手动除法实现\nlong[] rq = divWord(nChunk, dh);\nqhat = (int) (tmp & LONG_MASK);\nqrem = (int) (tmp >>> 32);\n\n// 优化后 - 使用内置优化方法\nqhat = (int) Long.divideUnsigned(nChunk, dhLong);\nqrem = (int) Long.remainderUnsigned(nChunk, dhLong);", "source_url": "https://github.com/openjdk/riscv-port/commit/beea5305b071820e2b128a55c5ca384caf470fdd", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1.// 优化前 - 复杂的条件分支\nif (v1 == 1) {\n    q1 = tmp;\n    r_tmp = 0;\n} else if (tmp >= 0) {\n    q1 = tmp1;\n    r_tmp = tmp - q1 * v1;\n} else {\n    long[] rq = divRemNegativeLong(tmp, v1);\n    q1 = rq[1];\n    r_tmp = rq[0];\n}\n\n// 优化后 - 直接使用硬件优化指令\nlong q1 = Long.divideUnsigned(tmp, v1);\nlong r_tmp = Long.remainderUnsigned(tmp, v1);\n2.// 优化前 - 手动除法实现\nlong[] rq = divWord(nChunk, dh);\nqhat = (int) (tmp & LONG_MASK);\nqrem = (int) (tmp >>> 32);\n\n// 优化后 - 使用内置优化方法\nqhat = (int) Long.divideUnsigned(nChunk, dhLong);\nqrem = (int) Long.remainderUnsigned(nChunk, dhLong);", "target": "1.// 优化前 - 复杂的条件分支\nif (v1 == 1) {\n    q1 = tmp;\n    r_tmp = 0;\n} else if (tmp >= 0) {\n    q1 = tmp1;\n    r_tmp = tmp - q1 * v1;\n} else {\n    long[] rq = divRemNegativeLong(tmp, v1);\n    q1 = rq[1];\n    r_tmp = rq[0];\n}\n\n// 优化后 - 直接使用硬件优化指令\nlong q1 = Long.divideUnsigned(tmp, v1);\nlong r_tmp = Long.remainderUnsigned(tmp, v1);\n2.// 优化前 - 手动除法实现\nlong[] rq = divWord(nChunk, dh);\nqhat = (int) (tmp & LONG_MASK);\nqrem = (int) (tmp >>> 32);\n\n// 优化后 - 使用内置优化方法\nqhat = (int) Long.divideUnsigned(nChunk, dhLong);\nqrem = (int) Long.remainderUnsigned(nChunk, dhLong);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升：利用CPU除法指令替代软件实现\n\n代码简化：移除divRemNegativeLong和divWord等复杂方法\n\n维护性：减少约100行复杂代码"}
{"id": 975, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "优化前：PSParallelCompact::mark_obj是一个独立的函数，在标记对象时被调用，涉及函数调用开销。\n\n优化后：该函数被内联到调用处（psCompactionManager.inline.hpp中的 mark_and_push方法），直接执行标记操作。\n\n优化效果：\n\n消除函数调用开销（如栈操作和跳转），提高标记阶段的执行速度。\n\n简化代码路径，可能允许编译器进行进一步优化（如寄存器分配）。\n\n优化思路：内联小函数以减少调用开销，特别在热路径（如垃圾回收的标记阶段）上能带来性能提升。", "original_code": "PSParallelCompact::mark_obj是一个独立的函数，在标记对象时被调用，涉及函数调用开销。", "optimized_code": "// 优化后：直接内联标记逻辑\nif (mark_bitmap()->mark_obj(obj)) {\n    // 原 mark_obj 中的操作直接展开\n    if (StringDedup::is_enabled() &&\n        java_lang_String::is_instance(obj) &&\n        psStringDedup::is_candidate_from_mark(obj)) {\n        _string_dedup_requests.add(obj);\n    }\n    ContinuationGCSupport::transform_stack_chunk(obj); // 原在 mark_obj 中\n    // ... 其他操作\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/dce97031555dcf689fecda16e444e7e8e9d5b270", "code_v0_no_empty_lines": "PSParallelCompact::mark_obj是一个独立的函数，在标记对象时被调用，涉及函数调用开销。", "code_v1_no_empty_lines": "// 优化后：直接内联标记逻辑\nif (mark_bitmap()->mark_obj(obj)) {\n    // 原 mark_obj 中的操作直接展开\n    if (StringDedup::is_enabled() &&\n        java_lang_String::is_instance(obj) &&\n        psStringDedup::is_candidate_from_mark(obj)) {\n        _string_dedup_requests.add(obj);\n    }\n    ContinuationGCSupport::transform_stack_chunk(obj); // 原在 mark_obj 中\n    // ... 其他操作\n}", "target": "// 优化后：直接内联标记逻辑\nif (mark_bitmap()->mark_obj(obj)) {\n    // 原 mark_obj 中的操作直接展开\n    if (StringDedup::is_enabled() &&\n        java_lang_String::is_instance(obj) &&\n        psStringDedup::is_candidate_from_mark(obj)) {\n        _string_dedup_requests.add(obj);\n    }\n    ContinuationGCSupport::transform_stack_chunk(obj); // 原在 mark_obj 中\n    // ... 其他操作\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化前：PSParallelCompact::mark_obj是一个独立的函数，在标记对象时被调用，涉及函数调用开销。\n\n优化后：该函数被内联到调用处（psCompactionManager.inline.hpp中的 mark_and_push方法），直接执行标记操作。\n\n优化效果：\n\n消除函数调用开销（如栈操作和跳转），提高标记阶段的执行速度。\n\n简化代码路径，可能允许编译器进行进一步优化（如寄存器分配）。\n\n优化思路：内联小函数以减少调用开销，特别在热路径（如垃圾回收的标记阶段）上能带来性能提升。"}
{"id": 976, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "优化效果：\n\n减少临时对象创建和拷贝开销，提高数组元素访问效率。\n\n特别在频繁访问或修改数组元素的场景中（如循环内），能提升性能。\n\n优化思路：通过返回引用而非值，实现原地操作，减少内存操作和拷贝成本。这是典型的C++优化技术，适用于容器类", "original_code": "// No original code extracted from description\n", "optimized_code": "// 优化后：返回引用\nE& first() {\n    assert(_len > 0, \"empty\");\n    return _data[0];\n}\n\nE& top() {\n    assert(_len > 0, \"empty\");\n    return _data[_len - 1];\n}\n\nE& at_grow(int i, const E& fill = E()) {\n    assert(0 <= i, \"negative index %d\", i);\n    if (i >= this->_len) {\n        if (i >= this->_capacity) grow(i);\n        // ... 填充逻辑\n    }\n    return _data[i]; // 返回引用\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/c7495fb35d7736815d5777ab776ace013f9d50b5", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 优化后：返回引用\nE& first() {\n    assert(_len > 0, \"empty\");\n    return _data[0];\n}\n\nE& top() {\n    assert(_len > 0, \"empty\");\n    return _data[_len - 1];\n}\n\nE& at_grow(int i, const E& fill = E()) {\n    assert(0 <= i, \"negative index %d\", i);\n    if (i >= this->_len) {\n        if (i >= this->_capacity) grow(i);\n        // ... 填充逻辑\n    }\n    return _data[i]; // 返回引用\n}", "target": "// 优化后：返回引用\nE& first() {\n    assert(_len > 0, \"empty\");\n    return _data[0];\n}\n\nE& top() {\n    assert(_len > 0, \"empty\");\n    return _data[_len - 1];\n}\n\nE& at_grow(int i, const E& fill = E()) {\n    assert(0 <= i, \"negative index %d\", i);\n    if (i >= this->_len) {\n        if (i >= this->_capacity) grow(i);\n        // ... 填充逻辑\n    }\n    return _data[i]; // 返回引用\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化效果：\n\n减少临时对象创建和拷贝开销，提高数组元素访问效率。\n\n特别在频繁访问或修改数组元素的场景中（如循环内），能提升性能。\n\n优化思路：通过返回引用而非值，实现原地操作，减少内存操作和拷贝成本。这是典型的C++优化技术，适用于容器类"}
{"id": 977, "source": "riscv-dataset-excel", "optimization_type": "算法优化", "optimization_description": "减少分支预测失败：消除多个条件分支，改善流水线效率\n\n改善缓存行为：更小的代码体积和更线性的执行路径\n\n硬件级优化：Long.divideUnsigned可能映射到高效的CPU指令 在大数运算中的价值", "original_code": "// No original code extracted from description\n", "optimized_code": "BigDecimal除法优化\n\n关键修改点：BigDecimal.java第5683-569行\n\n\n// 优化前：复杂的分支逻辑\nif (v1 == 1) {\n    q1 = tmp;\n    r_tmp = 0;\n} else if (tmp >= 0) {\n    q1 = tmp / v1;\n    r_tmp = tmp - q1 * v1;\n} else {\n    long[] rq = divRemNegativeLong(tmp, v1);\n    q1 = rq[1];\n    r_tmp = rq[0];\n}\n\n// 优化后：单一方法调用\nlong q1 = Long.divideUnsigned(tmp, v1);\nlong r = Long.remainderUnsigned(tmp, v1);\n2. MutableBigInteger除法优化\n\n关键修改点：MutableBigInteger.java多处修改\n\n// 优化前：手动除法实现\nif (nChunk >= 0) {\n    qhat = (int) (nChunk / dhLong);\n    qrem = (int) (nChunk - qhat * dhLong);\n} else {\n    long tmp = divWord(nChunk, dh);\n    qhat = (int) (tmp & LONG_MASK);\n    qrem = (int) (tmp >>> 32);\n}\n\n// 优化后：统一使用无符号除法\nqhat = (int) Long.divideUnsigned(nChunk, dhLong);\nqrem = (int) Long.remainderUnsigned(nChunk,);\n3. 移除冗余代码\n\n删除的自定义除法函数：\n\n// 完全移除的复杂除法函数\nprivate static long[] divRemNegativeLong(long n, long d) {\n    // 包含循环校正的复杂逻辑\n    while (r < 0) {\n        r += d;\n        q--;\n    }\n    while (r >= d) {\n        r -= d;\n        q++;\n    }\n}\n4. 测试用例增强\n\n基准测试优化：添加专门的除法性能测试\n\n// 新增的除法性能测试用例\n@Benchmark\n@OperationsPerInvocation(TEST_SIZE_SIZE)\npublic void testHugeSmallDivide(Blackhole bh) {\n    for (BigInteger s : hugeArray) {\n        for (BigInteger t : smallArray) {\n            bh.consume(s.divide(t));  // 测试优化后的除法性能\n        }\n    }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/beea5305b071820e2b128a55c5ca384caf470fdd", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "BigDecimal除法优化\n\n关键修改点：BigDecimal.java第5683-569行\n\n\n// 优化前：复杂的分支逻辑\nif (v1 == 1) {\n    q1 = tmp;\n    r_tmp = 0;\n} else if (tmp >= 0) {\n    q1 = tmp / v1;\n    r_tmp = tmp - q1 * v1;\n} else {\n    long[] rq = divRemNegativeLong(tmp, v1);\n    q1 = rq[1];\n    r_tmp = rq[0];\n}\n\n// 优化后：单一方法调用\nlong q1 = Long.divideUnsigned(tmp, v1);\nlong r = Long.remainderUnsigned(tmp, v1);\n2. MutableBigInteger除法优化\n\n关键修改点：MutableBigInteger.java多处修改\n\n// 优化前：手动除法实现\nif (nChunk >= 0) {\n    qhat = (int) (nChunk / dhLong);\n    qrem = (int) (nChunk - qhat * dhLong);\n} else {\n    long tmp = divWord(nChunk, dh);\n    qhat = (int) (tmp & LONG_MASK);\n    qrem = (int) (tmp >>> 32);\n}\n\n// 优化后：统一使用无符号除法\nqhat = (int) Long.divideUnsigned(nChunk, dhLong);\nqrem = (int) Long.remainderUnsigned(nChunk,);\n3. 移除冗余代码\n\n删除的自定义除法函数：\n\n// 完全移除的复杂除法函数\nprivate static long[] divRemNegativeLong(long n, long d) {\n    // 包含循环校正的复杂逻辑\n    while (r < 0) {\n        r += d;\n        q--;\n    }\n    while (r >= d) {\n        r -= d;\n        q++;\n    }\n}\n4. 测试用例增强\n\n基准测试优化：添加专门的除法性能测试\n\n// 新增的除法性能测试用例\n@Benchmark\n@OperationsPerInvocation(TEST_SIZE_SIZE)\npublic void testHugeSmallDivide(Blackhole bh) {\n    for (BigInteger s : hugeArray) {\n        for (BigInteger t : smallArray) {\n            bh.consume(s.divide(t));  // 测试优化后的除法性能\n        }\n    }\n}", "target": "BigDecimal除法优化\n\n关键修改点：BigDecimal.java第5683-569行\n\n\n// 优化前：复杂的分支逻辑\nif (v1 == 1) {\n    q1 = tmp;\n    r_tmp = 0;\n} else if (tmp >= 0) {\n    q1 = tmp / v1;\n    r_tmp = tmp - q1 * v1;\n} else {\n    long[] rq = divRemNegativeLong(tmp, v1);\n    q1 = rq[1];\n    r_tmp = rq[0];\n}\n\n// 优化后：单一方法调用\nlong q1 = Long.divideUnsigned(tmp, v1);\nlong r = Long.remainderUnsigned(tmp, v1);\n2. MutableBigInteger除法优化\n\n关键修改点：MutableBigInteger.java多处修改\n\n// 优化前：手动除法实现\nif (nChunk >= 0) {\n    qhat = (int) (nChunk / dhLong);\n    qrem = (int) (nChunk - qhat * dhLong);\n} else {\n    long tmp = divWord(nChunk, dh);\n    qhat = (int) (tmp & LONG_MASK);\n    qrem = (int) (tmp >>> 32);\n}\n\n// 优化后：统一使用无符号除法\nqhat = (int) Long.divideUnsigned(nChunk, dhLong);\nqrem = (int) Long.remainderUnsigned(nChunk,);\n3. 移除冗余代码\n\n删除的自定义除法函数：\n\n// 完全移除的复杂除法函数\nprivate static long[] divRemNegativeLong(long n, long d) {\n    // 包含循环校正的复杂逻辑\n    while (r < 0) {\n        r += d;\n        q--;\n    }\n    while (r >= d) {\n        r -= d;\n        q++;\n    }\n}\n4. 测试用例增强\n\n基准测试优化：添加专门的除法性能测试\n\n// 新增的除法性能测试用例\n@Benchmark\n@OperationsPerInvocation(TEST_SIZE_SIZE)\npublic void testHugeSmallDivide(Blackhole bh) {\n    for (BigInteger s : hugeArray) {\n        for (BigInteger t : smallArray) {\n            bh.consume(s.divide(t));  // 测试优化后的除法性能\n        }\n    }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "减少分支预测失败：消除多个条件分支，改善流水线效率\n\n改善缓存行为：更小的代码体积和更线性的执行路径\n\n硬件级优化：Long.divideUnsigned可能映射到高效的CPU指令 在大数运算中的价值"}
{"id": 978, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "将条件判断从req() < 2改为req() != 2，这扩展了死代码的处理范围（如Phi节点等）。修改后，编译器能更稳健地处理循环中的范围检查，避免断言失败导致的编译中断。同时，添加了测试用例TestIfWithPhiInput.java，验证修复。", "original_code": "// No original code extracted from description\n", "optimized_code": "优化前代码（在循环优化中，只检查bol->req() < 2）：\n\n\nif (bol->req() < 2) {\n    continue; // dead constant test\n}\n\n优化后代码（检查bol->req() != 2，处理更多死代码情况）：\n\nif (bol->req() != 2) {\n    // Could be a dead constant test or another dead variant...\n    continue;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/64bbae75121ccf80c02a0960e2db62eb558052e6", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "优化前代码（在循环优化中，只检查bol->req() < 2）：\n\n\nif (bol->req() < 2) {\n    continue; // dead constant test\n}\n\n优化后代码（检查bol->req() != 2，处理更多死代码情况）：\n\nif (bol->req() != 2) {\n    // Could be a dead constant test or another dead variant...\n    continue;\n}", "target": "优化前代码（在循环优化中，只检查bol->req() < 2）：\n\n\nif (bol->req() < 2) {\n    continue; // dead constant test\n}\n\n优化后代码（检查bol->req() != 2，处理更多死代码情况）：\n\nif (bol->req() != 2) {\n    // Could be a dead constant test or another dead variant...\n    continue;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "将条件判断从req() < 2改为req() != 2，这扩展了死代码的处理范围（如Phi节点等）。修改后，编译器能更稳健地处理循环中的范围检查，避免断言失败导致的编译中断。同时，添加了测试用例TestIfWithPhiInput.java，验证修复。"}
{"id": 979, "source": "riscv-dataset-excel", "optimization_type": "编译器优化", "optimization_description": "优化效果：修复了SuperWord（向量化优化）中的问题，使编译器能更有效地生成向量指令，提升循环性能。", "original_code": "// No original code extracted from description\n", "optimized_code": "优化前代码（在superword.cpp中，直接使用first->in(1)获取操作数）：\n\n\nNode* in1 = first->in(1);\n\n优化后代码（使用vector_opd(p, 1)获取向量操作数）：\n\n\nNode* in1 = vector_opd(p, 1);", "source_url": "https://github.com/openjdk/riscv-port/commit/67d6f3ca9e8d1312c9e3a85dbe19903619f59064", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "优化前代码（在superword.cpp中，直接使用first->in(1)获取操作数）：\n\n\nNode* in1 = first->in(1);\n\n优化后代码（使用vector_opd(p, 1)获取向量操作数）：\n\n\nNode* in1 = vector_opd(p, 1);", "target": "优化前代码（在superword.cpp中，直接使用first->in(1)获取操作数）：\n\n\nNode* in1 = first->in(1);\n\n优化后代码（使用vector_opd(p, 1)获取向量操作数）：\n\n\nNode* in1 = vector_opd(p, 1);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化效果：修复了SuperWord（向量化优化）中的问题，使编译器能更有效地生成向量指令，提升循环性能。"}
{"id": 980, "source": "riscv-dataset-excel", "optimization_type": "代码优化", "optimization_description": "将Stream操作（src.chars().filter().findFirst().orElse()）替换为直接的for循环。Stream API可能带来额外的开销，如流创建、过滤操作和可选值处理。for循环直接访问字符串字符，减少了函数调用和对象分配，提高了性能。这种优化针对DecimalFormat的初始化过程，修复了性能回归。", "original_code": "// No original code extracted from description\n", "optimized_code": "优化前代码（使用Java Stream API，可能引入开销）：\n\n\nprivate char findNonFormatChar(String src, char defChar) {\n    return (char)src.chars()\n        .filter(c -> Character.getType(c) != Character.FORMAT)\n        .findFirst()\n        .orElse(defChar);\n}\n\n优化后代码（使用简单的for循环，直接遍历字符串）：\n\nprivate char findNonFormatChar(String src, char defChar) {\n    for (int i = 0; i < src.length(); i++) {\n        char c = src.charAt(i);\n        if (Character.getType(c) != Character.FORMAT) {\n            return c;\n        }\n    }\n    return defChar;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/d826127970bd2ae8bf4cacc3c55634dc5af307c4", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "优化前代码（使用Java Stream API，可能引入开销）：\n\n\nprivate char findNonFormatChar(String src, char defChar) {\n    return (char)src.chars()\n        .filter(c -> Character.getType(c) != Character.FORMAT)\n        .findFirst()\n        .orElse(defChar);\n}\n\n优化后代码（使用简单的for循环，直接遍历字符串）：\n\nprivate char findNonFormatChar(String src, char defChar) {\n    for (int i = 0; i < src.length(); i++) {\n        char c = src.charAt(i);\n        if (Character.getType(c) != Character.FORMAT) {\n            return c;\n        }\n    }\n    return defChar;\n}", "target": "优化前代码（使用Java Stream API，可能引入开销）：\n\n\nprivate char findNonFormatChar(String src, char defChar) {\n    return (char)src.chars()\n        .filter(c -> Character.getType(c) != Character.FORMAT)\n        .findFirst()\n        .orElse(defChar);\n}\n\n优化后代码（使用简单的for循环，直接遍历字符串）：\n\nprivate char findNonFormatChar(String src, char defChar) {\n    for (int i = 0; i < src.length(); i++) {\n        char c = src.charAt(i);\n        if (Character.getType(c) != Character.FORMAT) {\n            return c;\n        }\n    }\n    return defChar;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "将Stream操作（src.chars().filter().findFirst().orElse()）替换为直接的for循环。Stream API可能带来额外的开销，如流创建、过滤操作和可选值处理。for循环直接访问字符串字符，减少了函数调用和对象分配，提高了性能。这种优化针对DecimalFormat的初始化过程，修复了性能回归。"}
{"id": 981, "source": "riscv-dataset-excel", "optimization_type": "指令集优化​ + 编译器优化​ + 向量化优化", "optimization_description": "性能提升机制\n指令级并行：单条向量指令处理多个数据元素\n减少指令数：向量操作替代标量循环\n硬件加速：利用RISC-V向量扩展专用硬件\n掩码优化：条件执行减少分支开销", "original_code": "// No original code extracted from description\n", "optimized_code": "向量-立即数算术指令支持\n\n新增立即数加法指令：\n\ninstruct vadd_immI(vReg dst, vReg src1, immI5 con) %{\n    match(Set dst (AddVB src1 (Replicate con)));\n    match(Set dst (AddVS src1 (Replicate con)));\n    match(Set dst (AddVI src1 (Replicate con)));\n    ins_encode %{\n        __ vadd_vi(as_VectorRegister($dst$$reg),\n                  as_VectorRegister($src1$$reg),\n                  $con$$constant);\n    %}\n%}\n2. 向量-标量算术指令支持\n\n新增标量加法指令：\n\n\ninstruct vadd_regI(vReg dst, vReg src1, iRegIorL2I src2) %{\n    match(Set dst (AddVB src1 (Replicate src2)));\n    match(Set dst (AddVS src1 (Replicate src2)));\n    match(Set dst (AddVI src1 (Replicate src2)));\n    ins_encode %{\n        __ vadd_vx(as_VectorRegister($dst$$reg),\n                  as_VectorRegister($src1$$reg),\n                  as_Register($src2$$reg));\n    %}\n%}\n3. 掩码操作支持\n\n新增掩码版本指令：\n\n\ninstruct vadd_immI_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n    match(Set dst_src (AddVB (Binary dst_src (Replicate con)) v0));\n    ins_encode %{\n        __ vadd_vi(as_VectorRegister($dst_src$$reg),\n                  as_VectorRegister($dst_src$$reg),\n                  $con$$constant, Assembler::v0_t);\n    %}\n%}\n4. 模式匹配扩展\n\n扩展向量标量模式识别：\n\n\nstatic bool is_vector_scalar_bitwise_pattern(Node* n, Node* m) {\n    switch (n->Opcode()) {\n        case Op_AndV:\n        case Op_OrV:\n        case Op_XorV:\n        case Op_AddVB:  // 新增支持\n        case Op_AddVS:\n        case Op_AddVI:\n        case Op_AddVL:\n        case Op_SubVB:  // 新增支持\n        case Op_SubVS:\n        case Op_SubVI:\n        case Op_SubVL:\n        case Op_MulVB:  // 新增支持\n        case Op_MulVS:\n        case Op_MulVI:\n        case Op_MulVL: {\n            return true;\n        }\n    }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/a4c7be862cc6dc121efb6c1c283236a588259c8f", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "向量-立即数算术指令支持\n\n新增立即数加法指令：\n\ninstruct vadd_immI(vReg dst, vReg src1, immI5 con) %{\n    match(Set dst (AddVB src1 (Replicate con)));\n    match(Set dst (AddVS src1 (Replicate con)));\n    match(Set dst (AddVI src1 (Replicate con)));\n    ins_encode %{\n        __ vadd_vi(as_VectorRegister($dst$$reg),\n                  as_VectorRegister($src1$$reg),\n                  $con$$constant);\n    %}\n%}\n2. 向量-标量算术指令支持\n\n新增标量加法指令：\n\n\ninstruct vadd_regI(vReg dst, vReg src1, iRegIorL2I src2) %{\n    match(Set dst (AddVB src1 (Replicate src2)));\n    match(Set dst (AddVS src1 (Replicate src2)));\n    match(Set dst (AddVI src1 (Replicate src2)));\n    ins_encode %{\n        __ vadd_vx(as_VectorRegister($dst$$reg),\n                  as_VectorRegister($src1$$reg),\n                  as_Register($src2$$reg));\n    %}\n%}\n3. 掩码操作支持\n\n新增掩码版本指令：\n\n\ninstruct vadd_immI_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n    match(Set dst_src (AddVB (Binary dst_src (Replicate con)) v0));\n    ins_encode %{\n        __ vadd_vi(as_VectorRegister($dst_src$$reg),\n                  as_VectorRegister($dst_src$$reg),\n                  $con$$constant, Assembler::v0_t);\n    %}\n%}\n4. 模式匹配扩展\n\n扩展向量标量模式识别：\n\n\nstatic bool is_vector_scalar_bitwise_pattern(Node* n, Node* m) {\n    switch (n->Opcode()) {\n        case Op_AndV:\n        case Op_OrV:\n        case Op_XorV:\n        case Op_AddVB:  // 新增支持\n        case Op_AddVS:\n        case Op_AddVI:\n        case Op_AddVL:\n        case Op_SubVB:  // 新增支持\n        case Op_SubVS:\n        case Op_SubVI:\n        case Op_SubVL:\n        case Op_MulVB:  // 新增支持\n        case Op_MulVS:\n        case Op_MulVI:\n        case Op_MulVL: {\n            return true;\n        }\n    }\n}", "target": "向量-立即数算术指令支持\n\n新增立即数加法指令：\n\ninstruct vadd_immI(vReg dst, vReg src1, immI5 con) %{\n    match(Set dst (AddVB src1 (Replicate con)));\n    match(Set dst (AddVS src1 (Replicate con)));\n    match(Set dst (AddVI src1 (Replicate con)));\n    ins_encode %{\n        __ vadd_vi(as_VectorRegister($dst$$reg),\n                  as_VectorRegister($src1$$reg),\n                  $con$$constant);\n    %}\n%}\n2. 向量-标量算术指令支持\n\n新增标量加法指令：\n\n\ninstruct vadd_regI(vReg dst, vReg src1, iRegIorL2I src2) %{\n    match(Set dst (AddVB src1 (Replicate src2)));\n    match(Set dst (AddVS src1 (Replicate src2)));\n    match(Set dst (AddVI src1 (Replicate src2)));\n    ins_encode %{\n        __ vadd_vx(as_VectorRegister($dst$$reg),\n                  as_VectorRegister($src1$$reg),\n                  as_Register($src2$$reg));\n    %}\n%}\n3. 掩码操作支持\n\n新增掩码版本指令：\n\n\ninstruct vadd_immI_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n    match(Set dst_src (AddVB (Binary dst_src (Replicate con)) v0));\n    ins_encode %{\n        __ vadd_vi(as_VectorRegister($dst_src$$reg),\n                  as_VectorRegister($dst_src$$reg),\n                  $con$$constant, Assembler::v0_t);\n    %}\n%}\n4. 模式匹配扩展\n\n扩展向量标量模式识别：\n\n\nstatic bool is_vector_scalar_bitwise_pattern(Node* n, Node* m) {\n    switch (n->Opcode()) {\n        case Op_AndV:\n        case Op_OrV:\n        case Op_XorV:\n        case Op_AddVB:  // 新增支持\n        case Op_AddVS:\n        case Op_AddVI:\n        case Op_AddVL:\n        case Op_SubVB:  // 新增支持\n        case Op_SubVS:\n        case Op_SubVI:\n        case Op_SubVL:\n        case Op_MulVB:  // 新增支持\n        case Op_MulVS:\n        case Op_MulVI:\n        case Op_MulVL: {\n            return true;\n        }\n    }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升机制\n指令级并行：单条向量指令处理多个数据元素\n减少指令数：向量操作替代标量循环\n硬件加速：利用RISC-V向量扩展专用硬件\n掩码优化：条件执行减少分支开销"}
{"id": 982, "source": "riscv-dataset-excel", "optimization_type": "编译器优化​ + 指令集优化​ + 内存操作优化", "optimization_description": "性能提升机制\n\nintrinsic优势：\n\n避免函数调用开销，直接生成内联汇编\n\n利用RISC-V特定指令优化内存操作\n\n减少边界检查等运行时开销\n\n内存操作优化：\n\n条件化数组清零，避免不必要的内存写入\n\n优化内存访问模式，改善缓存行为\n\n减少内存带宽消耗\n\n编译器优化：\n\n更好的寄存器分配和指令调度\n\n减少中间表示转换开销\n\n改善代码生成质量", "original_code": "// No original code extracted from description\n", "optimized_code": "编译器intrinsic支持添加\n\n优化前：RISC-V不支持clone intrinsic，使用通用实现\n// 原始代码：RISC-V不在支持列表中\n#if defined(X86) || defined(AARCH64) || defined(S390)\ncase vmIntrinsics::_clone:  // 只有x86、AArch64、S390支持\n#endif\n\n优化后：添加RISC-V支持\n// 优化后：包含RISC-V架构\n#if defined(X86) || defined(AARCH64) || defined(S390) || defined(RISCV)\ncase vmIntrinsics::_clone:  // 现在RISC-V也支持clone intrinsic\n#endif\n2. 数组分配优化\n\n优化前：固定清零数组，可能不必要的初始化\nvoid allocate_array(Register obj, Register len, ..., Label& slow_case) {\n    // 总是初始化数组体\n    initialize_body(obj, arr_size, base_offset, len_zero); // 强制清零\n}\n\n优化后：条件化数组清零，避免不必要操作\n\nvoid allocate_array(Register obj, Register len, ..., Label& slow_case, bool zero_array) {\n    // 根据条件决定是否清零数组\n    if (zero_array) {\n        initialize_body(obj, arr_size, base_offset, len_zero); // 条件化清零\n    }\n}\n3. LIR生成器优化\n\n优化前：简单的状态管理\n\n\nCodeEmitInfo* info = state_for(x, x->state()); // 基本状态处理\n\n优化后：智能状态管理和优化标志处理\n\n// 增强的状态管理\nCodeEmitInfo* info = nullptr;\nif (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n    info = state_for(x, x->state_before());\n    info->set_force_reexecute();  // 优化重执行逻辑\n} else {\n    info = state_for(x, x->state());\n}\n\n// 优化标志处理\nif (x->check_flag(Instruction::OmitChecksFlag)) {\n    flags = 0;  // 省略检查以提升性能\n}\n4. 数组拷贝操作优化\n\n优化前：可能存在的空指针风险\n\n__ bind(*stub->continuation()); // 直接使用，可能空指针\n\n优化后：安全的条件绑定\n\nif (stub != nullptr) {\n    __ bind(*stub->continuation()); // 空指针检查\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/75220da26f647c6f3dabc05cea81cefaf3a1e195", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "编译器intrinsic支持添加\n\n优化前：RISC-V不支持clone intrinsic，使用通用实现\n// 原始代码：RISC-V不在支持列表中\n#if defined(X86) || defined(AARCH64) || defined(S390)\ncase vmIntrinsics::_clone:  // 只有x86、AArch64、S390支持\n#endif\n\n优化后：添加RISC-V支持\n// 优化后：包含RISC-V架构\n#if defined(X86) || defined(AARCH64) || defined(S390) || defined(RISCV)\ncase vmIntrinsics::_clone:  // 现在RISC-V也支持clone intrinsic\n#endif\n2. 数组分配优化\n\n优化前：固定清零数组，可能不必要的初始化\nvoid allocate_array(Register obj, Register len, ..., Label& slow_case) {\n    // 总是初始化数组体\n    initialize_body(obj, arr_size, base_offset, len_zero); // 强制清零\n}\n\n优化后：条件化数组清零，避免不必要操作\n\nvoid allocate_array(Register obj, Register len, ..., Label& slow_case, bool zero_array) {\n    // 根据条件决定是否清零数组\n    if (zero_array) {\n        initialize_body(obj, arr_size, base_offset, len_zero); // 条件化清零\n    }\n}\n3. LIR生成器优化\n\n优化前：简单的状态管理\n\n\nCodeEmitInfo* info = state_for(x, x->state()); // 基本状态处理\n\n优化后：智能状态管理和优化标志处理\n\n// 增强的状态管理\nCodeEmitInfo* info = nullptr;\nif (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n    info = state_for(x, x->state_before());\n    info->set_force_reexecute();  // 优化重执行逻辑\n} else {\n    info = state_for(x, x->state());\n}\n\n// 优化标志处理\nif (x->check_flag(Instruction::OmitChecksFlag)) {\n    flags = 0;  // 省略检查以提升性能\n}\n4. 数组拷贝操作优化\n\n优化前：可能存在的空指针风险\n\n__ bind(*stub->continuation()); // 直接使用，可能空指针\n\n优化后：安全的条件绑定\n\nif (stub != nullptr) {\n    __ bind(*stub->continuation()); // 空指针检查\n}", "target": "编译器intrinsic支持添加\n\n优化前：RISC-V不支持clone intrinsic，使用通用实现\n// 原始代码：RISC-V不在支持列表中\n#if defined(X86) || defined(AARCH64) || defined(S390)\ncase vmIntrinsics::_clone:  // 只有x86、AArch64、S390支持\n#endif\n\n优化后：添加RISC-V支持\n// 优化后：包含RISC-V架构\n#if defined(X86) || defined(AARCH64) || defined(S390) || defined(RISCV)\ncase vmIntrinsics::_clone:  // 现在RISC-V也支持clone intrinsic\n#endif\n2. 数组分配优化\n\n优化前：固定清零数组，可能不必要的初始化\nvoid allocate_array(Register obj, Register len, ..., Label& slow_case) {\n    // 总是初始化数组体\n    initialize_body(obj, arr_size, base_offset, len_zero); // 强制清零\n}\n\n优化后：条件化数组清零，避免不必要操作\n\nvoid allocate_array(Register obj, Register len, ..., Label& slow_case, bool zero_array) {\n    // 根据条件决定是否清零数组\n    if (zero_array) {\n        initialize_body(obj, arr_size, base_offset, len_zero); // 条件化清零\n    }\n}\n3. LIR生成器优化\n\n优化前：简单的状态管理\n\n\nCodeEmitInfo* info = state_for(x, x->state()); // 基本状态处理\n\n优化后：智能状态管理和优化标志处理\n\n// 增强的状态管理\nCodeEmitInfo* info = nullptr;\nif (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n    info = state_for(x, x->state_before());\n    info->set_force_reexecute();  // 优化重执行逻辑\n} else {\n    info = state_for(x, x->state());\n}\n\n// 优化标志处理\nif (x->check_flag(Instruction::OmitChecksFlag)) {\n    flags = 0;  // 省略检查以提升性能\n}\n4. 数组拷贝操作优化\n\n优化前：可能存在的空指针风险\n\n__ bind(*stub->continuation()); // 直接使用，可能空指针\n\n优化后：安全的条件绑定\n\nif (stub != nullptr) {\n    __ bind(*stub->continuation()); // 空指针检查\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "性能提升机制\n\nintrinsic优势：\n\n避免函数调用开销，直接生成内联汇编\n\n利用RISC-V特定指令优化内存操作\n\n减少边界检查等运行时开销\n\n内存操作优化：\n\n条件化数组清零，避免不必要的内存写入\n\n优化内存访问模式，改善缓存行为\n\n减少内存带宽消耗\n\n编译器优化：\n\n更好的寄存器分配和指令调度\n\n减少中间表示转换开销\n\n改善代码生成质量"}
{"id": 983, "source": "riscv-dataset-excel", "optimization_type": "指令集优化​ + 编译器优化​ + 加密算法优化", "optimization_description": "硬件指令利用：\n\n使用AVX-512等向量指令加速大数运算\n\n利用Montgomery约减算法减少模运算开销\n\n单指令多数据（SIMD）并行处理多个操作数\n\n算法级优化：\n\n专门为P256曲线优化的Montgomery乘法\n\n减少中间结果和内存传输\n\n改善缓存局部性和内存访问模式\n\n编译器协同：\n\n内在函数允许编译器生成更优化的代码\n\n减少函数调用开销，内联关键操作\n\n更好的寄存器分配和指令调度", "original_code": "// No original code extracted from description\n", "optimized_code": "内在函数基础设施添加\n\n优化前：缺乏专门的Montgomery乘法内在函数支持\n\n\n// 优化前：可能使用通用实现\n// 没有专门的P256 Montgomery乘法支持\n\n优化后：添加专用的内在函数生成器\n\n\n// 在stubGenerator_x86_64.cpp中添加\nif (UseIntPolyIntrinsics) {\n    StubRoutines::_intpoly_montgomeryMult_P256 = generate_intpoly_montgomeryMult_P256();\n    StubRoutines::_intpoly_assign = generate_intpoly_assign();\n}\n2. 指令集扩展支持\n\n优化后添加的AVX-512指令支持：\n\n\n// 在macroAssembler_x86.hpp中添加专用指令\nusing Assembler::evpsrlq;  // 向量右移指令\nusing Assembler::evpsraq;  // 向量算术右移指令\n\nvoid evpsrlq(XMMRegister dst, KRegister mask, XMMRegister nds, \n             XMMRegister src, bool merge, int vector_len, bool is_varshift) {\n    // 支持变长移位操作，优化加密算法\n}\n3. 代码生成器改进\n\n多项式运算代码生成优化：\n\n\n// 生成更高效的多项式乘法代码\n@Override\nprotected int mult(long[] a, long[] b, long[] r) {\n    // 优化后的Montgomery乘法实现\n    // 使用硬件指令加速\n    return 0;  // 返回类型从void改为int，支持错误处理\n}\n\n@Override\nprotected int square(long[] a, long[] r) {\n    // 优化后的平方运算\n    return 0;\n}\n4. 模块导出和测试支持\n\n构建系统优化：\n\nmakefile\n复制\n# 在BuildMicrobenchmark.gmk中添加模块导出\n--add-exports java.base/sun.security.util.math=ALL-UNNAMED\n--add-exports java.base/sun.security.util.math.intpoly=ALL-UNNAMED\n# 允许基准测试访问内部数学库", "source_url": "https://github.com/openjdk/riscv-port/commit/afed7d0b0593864e5595840a6b645c210ff28c7c", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "内在函数基础设施添加\n\n优化前：缺乏专门的Montgomery乘法内在函数支持\n\n\n// 优化前：可能使用通用实现\n// 没有专门的P256 Montgomery乘法支持\n\n优化后：添加专用的内在函数生成器\n\n\n// 在stubGenerator_x86_64.cpp中添加\nif (UseIntPolyIntrinsics) {\n    StubRoutines::_intpoly_montgomeryMult_P256 = generate_intpoly_montgomeryMult_P256();\n    StubRoutines::_intpoly_assign = generate_intpoly_assign();\n}\n2. 指令集扩展支持\n\n优化后添加的AVX-512指令支持：\n\n\n// 在macroAssembler_x86.hpp中添加专用指令\nusing Assembler::evpsrlq;  // 向量右移指令\nusing Assembler::evpsraq;  // 向量算术右移指令\n\nvoid evpsrlq(XMMRegister dst, KRegister mask, XMMRegister nds, \n             XMMRegister src, bool merge, int vector_len, bool is_varshift) {\n    // 支持变长移位操作，优化加密算法\n}\n3. 代码生成器改进\n\n多项式运算代码生成优化：\n\n\n// 生成更高效的多项式乘法代码\n@Override\nprotected int mult(long[] a, long[] b, long[] r) {\n    // 优化后的Montgomery乘法实现\n    // 使用硬件指令加速\n    return 0;  // 返回类型从void改为int，支持错误处理\n}\n\n@Override\nprotected int square(long[] a, long[] r) {\n    // 优化后的平方运算\n    return 0;\n}\n4. 模块导出和测试支持\n\n构建系统优化：\n\nmakefile\n复制\n# 在BuildMicrobenchmark.gmk中添加模块导出\n--add-exports java.base/sun.security.util.math=ALL-UNNAMED\n--add-exports java.base/sun.security.util.math.intpoly=ALL-UNNAMED\n# 允许基准测试访问内部数学库", "target": "内在函数基础设施添加\n\n优化前：缺乏专门的Montgomery乘法内在函数支持\n\n\n// 优化前：可能使用通用实现\n// 没有专门的P256 Montgomery乘法支持\n\n优化后：添加专用的内在函数生成器\n\n\n// 在stubGenerator_x86_64.cpp中添加\nif (UseIntPolyIntrinsics) {\n    StubRoutines::_intpoly_montgomeryMult_P256 = generate_intpoly_montgomeryMult_P256();\n    StubRoutines::_intpoly_assign = generate_intpoly_assign();\n}\n2. 指令集扩展支持\n\n优化后添加的AVX-512指令支持：\n\n\n// 在macroAssembler_x86.hpp中添加专用指令\nusing Assembler::evpsrlq;  // 向量右移指令\nusing Assembler::evpsraq;  // 向量算术右移指令\n\nvoid evpsrlq(XMMRegister dst, KRegister mask, XMMRegister nds, \n             XMMRegister src, bool merge, int vector_len, bool is_varshift) {\n    // 支持变长移位操作，优化加密算法\n}\n3. 代码生成器改进\n\n多项式运算代码生成优化：\n\n\n// 生成更高效的多项式乘法代码\n@Override\nprotected int mult(long[] a, long[] b, long[] r) {\n    // 优化后的Montgomery乘法实现\n    // 使用硬件指令加速\n    return 0;  // 返回类型从void改为int，支持错误处理\n}\n\n@Override\nprotected int square(long[] a, long[] r) {\n    // 优化后的平方运算\n    return 0;\n}\n4. 模块导出和测试支持\n\n构建系统优化：\n\nmakefile\n复制\n# 在BuildMicrobenchmark.gmk中添加模块导出\n--add-exports java.base/sun.security.util.math=ALL-UNNAMED\n--add-exports java.base/sun.security.util.math.intpoly=ALL-UNNAMED\n# 允许基准测试访问内部数学库", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "硬件指令利用：\n\n使用AVX-512等向量指令加速大数运算\n\n利用Montgomery约减算法减少模运算开销\n\n单指令多数据（SIMD）并行处理多个操作数\n\n算法级优化：\n\n专门为P256曲线优化的Montgomery乘法\n\n减少中间结果和内存传输\n\n改善缓存局部性和内存访问模式\n\n编译器协同：\n\n内在函数允许编译器生成更优化的代码\n\n减少函数调用开销，内联关键操作\n\n更好的寄存器分配和指令调度"}
{"id": 984, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+内存优化", "optimization_description": "减少内存写入：避免不必要的数组清零操作\n\n降低分支开销：通过内在函数减少条件检查\n\n改善缓存局部性：重用热路径的arraycopy代码", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 条件化数组初始化\n// 关键修改：添加zero_array参数控制初始化\nvoid C1_MacroAssembler::allocate_array(Register obj, Register len, ..., \n                                      Label& slow_case, bool zero_array) {\n    // ... 头部初始化逻辑不变\n    \n    // 条件化清零数组体\n    if (zero_array) {\n        initialize_body(obj, arr_size, base_offset, len_zero);\n    }\n}\n2. Clone内在函数实现\n// 新增clone内在函数处理\nvoid GraphBuilder::append_alloc_array_copy(ciMethod* callee) {\n    // 重用arraycopy代码实现clone\n    Value new_array = append_split(new NewTypeArray(length, basic_type, state_before, false));\n    // 设置OmitChecksFlag避免不必要的检查\n    array_copy->set_flag(Instruction::OmitChecksFlag, true);\n}\n3. 编译器内在函数分发\n// 在编译器分发逻辑中添加clone支持\ncase vmIntrinsics::_clone: \n    append_alloc_array_copy(callee); \n    return;\n4. 数组分配优化集成\n// 在数组分配点集成条件清零\nvoid LIRGenerator::do_NewTypeArray(NewTypeArray* x) {\n    __allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, \n                    klass_reg, slow_path, x->zero_array());\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/2f10a316ff0c5a4c124b94f6fabb38fb119d2c82", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 条件化数组初始化\n// 关键修改：添加zero_array参数控制初始化\nvoid C1_MacroAssembler::allocate_array(Register obj, Register len, ..., \n                                      Label& slow_case, bool zero_array) {\n    // ... 头部初始化逻辑不变\n    \n    // 条件化清零数组体\n    if (zero_array) {\n        initialize_body(obj, arr_size, base_offset, len_zero);\n    }\n}\n2. Clone内在函数实现\n// 新增clone内在函数处理\nvoid GraphBuilder::append_alloc_array_copy(ciMethod* callee) {\n    // 重用arraycopy代码实现clone\n    Value new_array = append_split(new NewTypeArray(length, basic_type, state_before, false));\n    // 设置OmitChecksFlag避免不必要的检查\n    array_copy->set_flag(Instruction::OmitChecksFlag, true);\n}\n3. 编译器内在函数分发\n// 在编译器分发逻辑中添加clone支持\ncase vmIntrinsics::_clone: \n    append_alloc_array_copy(callee); \n    return;\n4. 数组分配优化集成\n// 在数组分配点集成条件清零\nvoid LIRGenerator::do_NewTypeArray(NewTypeArray* x) {\n    __allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, \n                    klass_reg, slow_path, x->zero_array());\n}", "target": "1. 条件化数组初始化\n// 关键修改：添加zero_array参数控制初始化\nvoid C1_MacroAssembler::allocate_array(Register obj, Register len, ..., \n                                      Label& slow_case, bool zero_array) {\n    // ... 头部初始化逻辑不变\n    \n    // 条件化清零数组体\n    if (zero_array) {\n        initialize_body(obj, arr_size, base_offset, len_zero);\n    }\n}\n2. Clone内在函数实现\n// 新增clone内在函数处理\nvoid GraphBuilder::append_alloc_array_copy(ciMethod* callee) {\n    // 重用arraycopy代码实现clone\n    Value new_array = append_split(new NewTypeArray(length, basic_type, state_before, false));\n    // 设置OmitChecksFlag避免不必要的检查\n    array_copy->set_flag(Instruction::OmitChecksFlag, true);\n}\n3. 编译器内在函数分发\n// 在编译器分发逻辑中添加clone支持\ncase vmIntrinsics::_clone: \n    append_alloc_array_copy(callee); \n    return;\n4. 数组分配优化集成\n// 在数组分配点集成条件清零\nvoid LIRGenerator::do_NewTypeArray(NewTypeArray* x) {\n    __allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, \n                    klass_reg, slow_path, x->zero_array());\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "减少内存写入：避免不必要的数组清零操作\n\n降低分支开销：通过内在函数减少条件检查\n\n改善缓存局部性：重用热路径的arraycopy代码"}
{"id": 985, "source": "riscv-dataset-excel", "optimization_type": "其他", "optimization_description": "减少初始化失败：通过自动重试避免昂贵的异常处理路径\n\n降低延迟：减少库调用往返次数，提高加密操作启动速度\n\n改善兼容性：支持更多PKCS#11实现版本，减少适配成本", "original_code": "// No original code extracted from description\n", "optimized_code": "本地层重试机制实现\n// 在p11_crypt.c中实现重试逻辑\nrv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);\n\nif (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n    // 参数错误时重试：切换GCM参数结构\n    if (retry && updateGCMParams(env, ckpMechanism) != NULL) {\n        TRACE0(\"DEBUG retry C_EncryptInit\\n\");\n        rv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);\n    }\n}\nGCM参数结构转换优化\n// 在p11_util.c中改进参数结构处理\nif (paramLen == sizeof(CK_GCM_PARAMS)) {\n    // CK_GCM_PARAMS => CK_GCM_PARAMS_NO_IVBITS 转换\n    pParamsNoIvBits = calloc(1, sizeof(CK_GCM_PARAMS_NO_IVBITS));\n    // ... 字段拷贝逻辑\n    mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS_NO_IVBITS);\n} else if (paramLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {\n    // 反向转换\n    pParams = calloc(1, sizeof(CK_GCM_PARAMS));\n    // ... 字段拷贝逻辑\n    mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS);\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/7c2c24fc0511b36132952c96be46eea5904a53c5", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "本地层重试机制实现\n// 在p11_crypt.c中实现重试逻辑\nrv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);\n\nif (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n    // 参数错误时重试：切换GCM参数结构\n    if (retry && updateGCMParams(env, ckpMechanism) != NULL) {\n        TRACE0(\"DEBUG retry C_EncryptInit\\n\");\n        rv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);\n    }\n}\nGCM参数结构转换优化\n// 在p11_util.c中改进参数结构处理\nif (paramLen == sizeof(CK_GCM_PARAMS)) {\n    // CK_GCM_PARAMS => CK_GCM_PARAMS_NO_IVBITS 转换\n    pParamsNoIvBits = calloc(1, sizeof(CK_GCM_PARAMS_NO_IVBITS));\n    // ... 字段拷贝逻辑\n    mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS_NO_IVBITS);\n} else if (paramLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {\n    // 反向转换\n    pParams = calloc(1, sizeof(CK_GCM_PARAMS));\n    // ... 字段拷贝逻辑\n    mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS);\n}", "target": "本地层重试机制实现\n// 在p11_crypt.c中实现重试逻辑\nrv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);\n\nif (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n    // 参数错误时重试：切换GCM参数结构\n    if (retry && updateGCMParams(env, ckpMechanism) != NULL) {\n        TRACE0(\"DEBUG retry C_EncryptInit\\n\");\n        rv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);\n    }\n}\nGCM参数结构转换优化\n// 在p11_util.c中改进参数结构处理\nif (paramLen == sizeof(CK_GCM_PARAMS)) {\n    // CK_GCM_PARAMS => CK_GCM_PARAMS_NO_IVBITS 转换\n    pParamsNoIvBits = calloc(1, sizeof(CK_GCM_PARAMS_NO_IVBITS));\n    // ... 字段拷贝逻辑\n    mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS_NO_IVBITS);\n} else if (paramLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {\n    // 反向转换\n    pParams = calloc(1, sizeof(CK_GCM_PARAMS));\n    // ... 字段拷贝逻辑\n    mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS);\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "减少初始化失败：通过自动重试避免昂贵的异常处理路径\n\n降低延迟：减少库调用往返次数，提高加密操作启动速度\n\n改善兼容性：支持更多PKCS#11实现版本，减少适配成本"}
{"id": 986, "source": "riscv-dataset-excel", "optimization_type": "计算优化", "optimization_description": "计算量减少：\n验证操作通常涉及内存扫描和状态检查\n范围从整个空间底部缩小到密集前缀，减少验证区域数量\n在大型堆空间中，区域数量减少可能很显著\n\n内存访问优化：\n减少不必要的内存扫描，改善缓存局部性\n降低内存带宽消耗\n", "original_code": "// No original code extracted from description\n", "optimized_code": "优化前：验证整个空间范围，从bottom到new_top\nvoid PSParallelCompact::verify_complete(SpaceId space_id) {\n    // 所有从空间底部到新顶部的区域都应该被验证\n    const size_t beg_region = sd.addr_to_region_idx(si.space()->bottom()); // 从整个空间底部开始\n    const size_t new_top_region = sd.addr_to_region_idx(new_top_addr);\n    const size_t old_top_region = sd.addr_to_region_idx(old_top_addr);\n    // 需要验证的区域范围很大\n}\n\n优化后：只验证压缩目标区域，从dense_prefix到new_top\nvoid PSParallelCompact::verify_complete(SpaceId space_id) {\n    // 只验证作为压缩目标的区域，从dense_prefix到new_top\n    const size_t beg_region = sd.addr_to_region_idx(si.dense_prefix()); // 从密集前缀开始\n    const size_t new_top_region = sd.addr_to_region_idx(new_top_addr);\n    const size_t old_top_region = sd.addr_to_region_idx(old_top_addr);\n    // 验证范围显著缩小\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/bb4aed944ea511df8ddfbd50c885a271a2ea9464", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "优化前：验证整个空间范围，从bottom到new_top\nvoid PSParallelCompact::verify_complete(SpaceId space_id) {\n    // 所有从空间底部到新顶部的区域都应该被验证\n    const size_t beg_region = sd.addr_to_region_idx(si.space()->bottom()); // 从整个空间底部开始\n    const size_t new_top_region = sd.addr_to_region_idx(new_top_addr);\n    const size_t old_top_region = sd.addr_to_region_idx(old_top_addr);\n    // 需要验证的区域范围很大\n}\n\n优化后：只验证压缩目标区域，从dense_prefix到new_top\nvoid PSParallelCompact::verify_complete(SpaceId space_id) {\n    // 只验证作为压缩目标的区域，从dense_prefix到new_top\n    const size_t beg_region = sd.addr_to_region_idx(si.dense_prefix()); // 从密集前缀开始\n    const size_t new_top_region = sd.addr_to_region_idx(new_top_addr);\n    const size_t old_top_region = sd.addr_to_region_idx(old_top_addr);\n    // 验证范围显著缩小\n}", "target": "优化前：验证整个空间范围，从bottom到new_top\nvoid PSParallelCompact::verify_complete(SpaceId space_id) {\n    // 所有从空间底部到新顶部的区域都应该被验证\n    const size_t beg_region = sd.addr_to_region_idx(si.space()->bottom()); // 从整个空间底部开始\n    const size_t new_top_region = sd.addr_to_region_idx(new_top_addr);\n    const size_t old_top_region = sd.addr_to_region_idx(old_top_addr);\n    // 需要验证的区域范围很大\n}\n\n优化后：只验证压缩目标区域，从dense_prefix到new_top\nvoid PSParallelCompact::verify_complete(SpaceId space_id) {\n    // 只验证作为压缩目标的区域，从dense_prefix到new_top\n    const size_t beg_region = sd.addr_to_region_idx(si.dense_prefix()); // 从密集前缀开始\n    const size_t new_top_region = sd.addr_to_region_idx(new_top_addr);\n    const size_t old_top_region = sd.addr_to_region_idx(old_top_addr);\n    // 验证范围显著缩小\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "计算量减少：\n验证操作通常涉及内存扫描和状态检查\n范围从整个空间底部缩小到密集前缀，减少验证区域数量\n在大型堆空间中，区域数量减少可能很显著\n\n内存访问优化：\n减少不必要的内存扫描，改善缓存局部性\n降低内存带宽消耗\n"}
{"id": 987, "source": "riscv-dataset-excel", "optimization_type": "内存优化+条件分支优化", "optimization_description": "计算开销减少：\n字符串去重涉及哈希计算、字典查找等昂贵操作\n避免对finalizable对象执行这些操作，直接减少CPU开销\n内存访问优化：\n减少不必要的内存访问和缓存污染\n改善GC工作线程的缓存局部性\nGC吞吐量提升：\n减少标记阶段的工作负载，加快GC周期\n特别在高finalizer对象密度的应用中效果显著", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 核心优化：条件化字符串去重\n优化前：对所有标记对象无条件执行字符串去重\n运行\n// 原始代码：无条件去重，包括finalizable对象\nvoid XMark::mark_and_follow(XMarkContext* context, XMarkStackEntry entry) {\n    const oop obj = XOop::from_address(addr);\n    follow_object(obj, finalizable);\n    \n    // 无条件尝试去重 - 即使对finalizable对象也执行\n    try_deduplicate(context, obj);  // 可能不必要的开销\n}\n\n优化后：仅对非finalizable对象执行去重\n// 优化后：智能条件判断\nvoid XMark::mark_and_follow(XMarkContext* context, XMarkStackEntry entry) {\n    const oop obj = XOop::from_address(addr);\n    follow_object(obj, finalizable);\n    \n    // 仅对非finalizable对象执行去重\n    if (!finalizable) {  // 关键条件判断\n        // Try deduplicate\n        try_deduplicate(context, obj);  // 只在有意义时执行\n    }\n}\n2. ZGC并行优化\n相同的优化逻辑也应用于ZGC实现：\n// ZGC的相应优化\nvoid ZMark::mark_and_follow(ZMarkContext* context, ZMarkStackEntry entry) {\n    const oop obj = to_oop(addr);\n    follow_object(obj, finalizable);\n    \n    if (!finalizable) {  // 添加相同的条件检查\n        // Try deduplicate\n        try_deduplicate(context, obj);\n    }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/2f2dc2289bce47d8071a86215218f345cce71dba", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 核心优化：条件化字符串去重\n优化前：对所有标记对象无条件执行字符串去重\n运行\n// 原始代码：无条件去重，包括finalizable对象\nvoid XMark::mark_and_follow(XMarkContext* context, XMarkStackEntry entry) {\n    const oop obj = XOop::from_address(addr);\n    follow_object(obj, finalizable);\n    \n    // 无条件尝试去重 - 即使对finalizable对象也执行\n    try_deduplicate(context, obj);  // 可能不必要的开销\n}\n\n优化后：仅对非finalizable对象执行去重\n// 优化后：智能条件判断\nvoid XMark::mark_and_follow(XMarkContext* context, XMarkStackEntry entry) {\n    const oop obj = XOop::from_address(addr);\n    follow_object(obj, finalizable);\n    \n    // 仅对非finalizable对象执行去重\n    if (!finalizable) {  // 关键条件判断\n        // Try deduplicate\n        try_deduplicate(context, obj);  // 只在有意义时执行\n    }\n}\n2. ZGC并行优化\n相同的优化逻辑也应用于ZGC实现：\n// ZGC的相应优化\nvoid ZMark::mark_and_follow(ZMarkContext* context, ZMarkStackEntry entry) {\n    const oop obj = to_oop(addr);\n    follow_object(obj, finalizable);\n    \n    if (!finalizable) {  // 添加相同的条件检查\n        // Try deduplicate\n        try_deduplicate(context, obj);\n    }\n}", "target": "1. 核心优化：条件化字符串去重\n优化前：对所有标记对象无条件执行字符串去重\n运行\n// 原始代码：无条件去重，包括finalizable对象\nvoid XMark::mark_and_follow(XMarkContext* context, XMarkStackEntry entry) {\n    const oop obj = XOop::from_address(addr);\n    follow_object(obj, finalizable);\n    \n    // 无条件尝试去重 - 即使对finalizable对象也执行\n    try_deduplicate(context, obj);  // 可能不必要的开销\n}\n\n优化后：仅对非finalizable对象执行去重\n// 优化后：智能条件判断\nvoid XMark::mark_and_follow(XMarkContext* context, XMarkStackEntry entry) {\n    const oop obj = XOop::from_address(addr);\n    follow_object(obj, finalizable);\n    \n    // 仅对非finalizable对象执行去重\n    if (!finalizable) {  // 关键条件判断\n        // Try deduplicate\n        try_deduplicate(context, obj);  // 只在有意义时执行\n    }\n}\n2. ZGC并行优化\n相同的优化逻辑也应用于ZGC实现：\n// ZGC的相应优化\nvoid ZMark::mark_and_follow(ZMarkContext* context, ZMarkStackEntry entry) {\n    const oop obj = to_oop(addr);\n    follow_object(obj, finalizable);\n    \n    if (!finalizable) {  // 添加相同的条件检查\n        // Try deduplicate\n        try_deduplicate(context, obj);\n    }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "计算开销减少：\n字符串去重涉及哈希计算、字典查找等昂贵操作\n避免对finalizable对象执行这些操作，直接减少CPU开销\n内存访问优化：\n减少不必要的内存访问和缓存污染\n改善GC工作线程的缓存局部性\nGC吞吐量提升：\n减少标记阶段的工作负载，加快GC周期\n特别在高finalizer对象密度的应用中效果显著"}
{"id": 988, "source": "riscv-dataset-excel", "optimization_type": "向量化优化​ + 编译器优化", "optimization_description": "向量化清零：使用SIMD指令一次性清零多个数组元素\n\n指令级并行：单条向量指令处理多个数据元素\n\n内存访问优化：改善缓存利用率和内存带宽使用", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 核心优化：向量化规则扩展\n\n优化前：Op_ClearArray操作不支持向量化\nbool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n    switch (opcode) {\n        // ... 其他操作码支持检查\n        // 缺少Op_ClearArray case，导致无法向量化\n        case Op_VectorMaskGen:\n        case Op_VectorCmpMasked:\n            if (!is_LP64 || !VM_Version::supports_avx512bw()) {\n                return false;\n            }\n            break;\n        // Op_ClearArray 未被处理，默认返回false\n    }\n    return false;\n}\n\n优化后：添加Op_ClearArray向量化支持\nbool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n    switch (opcode) {\n        // ... 其他操作码支持检查\n        case Op_ClearArray:          // 新增：支持ClearArray向量化\n        case Op_VectorMaskGen:\n        case Op_VectorCmpMasked:\n            if (!is_LP64 || !VM_Version::supports_avx512bw()) {\n                return false;\n            }\n            break;\n    }\n    return false;\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/1d889e54fc6d6039e68191420bb377ea560e2eaa", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 核心优化：向量化规则扩展\n\n优化前：Op_ClearArray操作不支持向量化\nbool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n    switch (opcode) {\n        // ... 其他操作码支持检查\n        // 缺少Op_ClearArray case，导致无法向量化\n        case Op_VectorMaskGen:\n        case Op_VectorCmpMasked:\n            if (!is_LP64 || !VM_Version::supports_avx512bw()) {\n                return false;\n            }\n            break;\n        // Op_ClearArray 未被处理，默认返回false\n    }\n    return false;\n}\n\n优化后：添加Op_ClearArray向量化支持\nbool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n    switch (opcode) {\n        // ... 其他操作码支持检查\n        case Op_ClearArray:          // 新增：支持ClearArray向量化\n        case Op_VectorMaskGen:\n        case Op_VectorCmpMasked:\n            if (!is_LP64 || !VM_Version::supports_avx512bw()) {\n                return false;\n            }\n            break;\n    }\n    return false;\n}", "target": "1. 核心优化：向量化规则扩展\n\n优化前：Op_ClearArray操作不支持向量化\nbool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n    switch (opcode) {\n        // ... 其他操作码支持检查\n        // 缺少Op_ClearArray case，导致无法向量化\n        case Op_VectorMaskGen:\n        case Op_VectorCmpMasked:\n            if (!is_LP64 || !VM_Version::supports_avx512bw()) {\n                return false;\n            }\n            break;\n        // Op_ClearArray 未被处理，默认返回false\n    }\n    return false;\n}\n\n优化后：添加Op_ClearArray向量化支持\nbool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n    switch (opcode) {\n        // ... 其他操作码支持检查\n        case Op_ClearArray:          // 新增：支持ClearArray向量化\n        case Op_VectorMaskGen:\n        case Op_VectorCmpMasked:\n            if (!is_LP64 || !VM_Version::supports_avx512bw()) {\n                return false;\n            }\n            break;\n    }\n    return false;\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "向量化清零：使用SIMD指令一次性清零多个数组元素\n\n指令级并行：单条向量指令处理多个数据元素\n\n内存访问优化：改善缓存利用率和内存带宽使用"}
{"id": 989, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+编译器优化", "optimization_description": "指令级并行：\n单条向量指令可同时旋转多个数据元素\n相比标量循环，吞吐量提升可达向量宽度的倍数\n\n硬件加速：\n使用专用旋转指令替代多个基本操作\n减少指令数和执行周期\n\n数据局部性：\n向量化改善缓存访问模式\n减少内存带宽需求", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 指令集支持添加（核心优化）\n优化前：缺乏向量旋转指令支持\n// 优化前：不支持向量旋转\nstatic bool supports_vector_variable_rotates(void) {\n    return false;  // 硬编码返回false\n}\n\nstatic bool supports_vector_constant_rotates(int shift) {\n    return false;  // 硬编码返回false\n}\n\n优化后：动态检测Zvbb扩展支持\n// 优化后：根据CPU特性动态返回\nstatic bool supports_vector_variable_rotates(void) {\n    return UseZvbb;  // 使用Zvbb扩展支持\n}\n\nstatic bool supports_vector_constant_rotates(int shift) {\n    return UseZvbb;  // 使用Zvbb扩展支持\n}\n2. 向量旋转指令实现\n\n新增硬件指令封装：\n// 向量旋转指令定义\nINSN(vror_vv, 0b1010111, 0b000, 0b010100);  // 向量-向量旋转右移\nINSN(vrol_vv, 0b1010111, 0b000, 0b010101);  // 向量-向量旋转左移\nINSN(vror_vx, 0b1010111, 0b100, 0b010100); // 向量-标量旋转右移  \nINSN(vrol_vx, 0b1010111, 0b100, 0b010101); // 向量-标量旋转左移\nINSN(vror_vi, 0b1010111, 0b011, 0b01010);  // 向量-立即数旋转右移\n3. 编译器指令模式添加\n// 旋转右移指令模式\ninstruct vrotate_right(vReg dst, vReg src, vReg shift) %{\n    match(Set dst (RotateRightV src shift));\n    format %{ \"vrotate_right $dst, $src, $shift \" %}\n    ins_encode %{\n        BasicType bt = Matcher::vector_element_basic_type(this);\n        __ vsetvli_helper(bt, Matcher::vector_length(this));\n        __ vror_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n                  as_VectorRegister($shift$$reg));\n    %}\n    ins_pipe(pipe_slow);\n%}\n\n// 立即数旋转优化\ninstruct vrotate_right_imm(vReg dst, vReg src, immI shift) %{\n    match(Set dst (RotateRightV src shift));\n    ins_encode %{\n        uint32_t bits = type2aelembytes(bt) * 8;\n        uint32_t con = (unsigned)$shift$$constant & (bits - 1);\n        if (con == 0) return;  // 旋转0位优化：直接返回\n        __ vror_vi(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), con);\n    %}\n%}\n4. 掩码操作支持\n带掩码的向量旋转：\ninstruct vrotate_right_masked(vReg dst_src, vReg shift, vRegMask_V0 v0) %{\n    match(Set dst_src (RotateRightV (Binary dst_src shift) v0));\n    ins_encode %{\n        __ vror_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n                  as_VectorRegister($shift$$reg), Assembler::v0_t);\n    %}\n%}", "source_url": "https://github.com/openjdk/riscv-port/commit/fed2b56017ae454082d320513b77518e624fb03c", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 指令集支持添加（核心优化）\n优化前：缺乏向量旋转指令支持\n// 优化前：不支持向量旋转\nstatic bool supports_vector_variable_rotates(void) {\n    return false;  // 硬编码返回false\n}\n\nstatic bool supports_vector_constant_rotates(int shift) {\n    return false;  // 硬编码返回false\n}\n\n优化后：动态检测Zvbb扩展支持\n// 优化后：根据CPU特性动态返回\nstatic bool supports_vector_variable_rotates(void) {\n    return UseZvbb;  // 使用Zvbb扩展支持\n}\n\nstatic bool supports_vector_constant_rotates(int shift) {\n    return UseZvbb;  // 使用Zvbb扩展支持\n}\n2. 向量旋转指令实现\n\n新增硬件指令封装：\n// 向量旋转指令定义\nINSN(vror_vv, 0b1010111, 0b000, 0b010100);  // 向量-向量旋转右移\nINSN(vrol_vv, 0b1010111, 0b000, 0b010101);  // 向量-向量旋转左移\nINSN(vror_vx, 0b1010111, 0b100, 0b010100); // 向量-标量旋转右移  \nINSN(vrol_vx, 0b1010111, 0b100, 0b010101); // 向量-标量旋转左移\nINSN(vror_vi, 0b1010111, 0b011, 0b01010);  // 向量-立即数旋转右移\n3. 编译器指令模式添加\n// 旋转右移指令模式\ninstruct vrotate_right(vReg dst, vReg src, vReg shift) %{\n    match(Set dst (RotateRightV src shift));\n    format %{ \"vrotate_right $dst, $src, $shift \" %}\n    ins_encode %{\n        BasicType bt = Matcher::vector_element_basic_type(this);\n        __ vsetvli_helper(bt, Matcher::vector_length(this));\n        __ vror_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n                  as_VectorRegister($shift$$reg));\n    %}\n    ins_pipe(pipe_slow);\n%}\n\n// 立即数旋转优化\ninstruct vrotate_right_imm(vReg dst, vReg src, immI shift) %{\n    match(Set dst (RotateRightV src shift));\n    ins_encode %{\n        uint32_t bits = type2aelembytes(bt) * 8;\n        uint32_t con = (unsigned)$shift$$constant & (bits - 1);\n        if (con == 0) return;  // 旋转0位优化：直接返回\n        __ vror_vi(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), con);\n    %}\n%}\n4. 掩码操作支持\n带掩码的向量旋转：\ninstruct vrotate_right_masked(vReg dst_src, vReg shift, vRegMask_V0 v0) %{\n    match(Set dst_src (RotateRightV (Binary dst_src shift) v0));\n    ins_encode %{\n        __ vror_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n                  as_VectorRegister($shift$$reg), Assembler::v0_t);\n    %}\n%}", "target": "1. 指令集支持添加（核心优化）\n优化前：缺乏向量旋转指令支持\n// 优化前：不支持向量旋转\nstatic bool supports_vector_variable_rotates(void) {\n    return false;  // 硬编码返回false\n}\n\nstatic bool supports_vector_constant_rotates(int shift) {\n    return false;  // 硬编码返回false\n}\n\n优化后：动态检测Zvbb扩展支持\n// 优化后：根据CPU特性动态返回\nstatic bool supports_vector_variable_rotates(void) {\n    return UseZvbb;  // 使用Zvbb扩展支持\n}\n\nstatic bool supports_vector_constant_rotates(int shift) {\n    return UseZvbb;  // 使用Zvbb扩展支持\n}\n2. 向量旋转指令实现\n\n新增硬件指令封装：\n// 向量旋转指令定义\nINSN(vror_vv, 0b1010111, 0b000, 0b010100);  // 向量-向量旋转右移\nINSN(vrol_vv, 0b1010111, 0b000, 0b010101);  // 向量-向量旋转左移\nINSN(vror_vx, 0b1010111, 0b100, 0b010100); // 向量-标量旋转右移  \nINSN(vrol_vx, 0b1010111, 0b100, 0b010101); // 向量-标量旋转左移\nINSN(vror_vi, 0b1010111, 0b011, 0b01010);  // 向量-立即数旋转右移\n3. 编译器指令模式添加\n// 旋转右移指令模式\ninstruct vrotate_right(vReg dst, vReg src, vReg shift) %{\n    match(Set dst (RotateRightV src shift));\n    format %{ \"vrotate_right $dst, $src, $shift \" %}\n    ins_encode %{\n        BasicType bt = Matcher::vector_element_basic_type(this);\n        __ vsetvli_helper(bt, Matcher::vector_length(this));\n        __ vror_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n                  as_VectorRegister($shift$$reg));\n    %}\n    ins_pipe(pipe_slow);\n%}\n\n// 立即数旋转优化\ninstruct vrotate_right_imm(vReg dst, vReg src, immI shift) %{\n    match(Set dst (RotateRightV src shift));\n    ins_encode %{\n        uint32_t bits = type2aelembytes(bt) * 8;\n        uint32_t con = (unsigned)$shift$$constant & (bits - 1);\n        if (con == 0) return;  // 旋转0位优化：直接返回\n        __ vror_vi(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), con);\n    %}\n%}\n4. 掩码操作支持\n带掩码的向量旋转：\ninstruct vrotate_right_masked(vReg dst_src, vReg shift, vRegMask_V0 v0) %{\n    match(Set dst_src (RotateRightV (Binary dst_src shift) v0));\n    ins_encode %{\n        __ vror_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n                  as_VectorRegister($shift$$reg), Assembler::v0_t);\n    %}\n%}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "指令级并行：\n单条向量指令可同时旋转多个数据元素\n相比标量循环，吞吐量提升可达向量宽度的倍数\n\n硬件加速：\n使用专用旋转指令替代多个基本操作\n减少指令数和执行周期\n\n数据局部性：\n向量化改善缓存访问模式\n减少内存带宽需求"}
{"id": 990, "source": "riscv-dataset-excel", "optimization_type": "条件分支优化​ ", "optimization_description": "分支预测改善：移除状态检查减少分支指令\n流水线效率：减少条件分支可能改善指令流水线性能\n代码路径简化：更直接的操作路径，减少控制流复杂度", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 枚举类型移除\n优化前：存在复杂的迭代状态枚举\n// parMarkBitMap.hpp\nenum IterationStatus { incomplete, complete, full };\n\n优化后：完全移除状态枚举\n// 枚举定义被删除，简化类型系统\n2. 方法接口简化\n优化前：方法返回复杂状态值\n// psParallelCompact.cpp\nMoveAndUpdateClosure::IterationStatus\nMoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n    // 复杂的状态处理逻辑\n    return is_full() ? ParMarkBitMap::full : ParMarkBitMap::incomplete;\n}\n\n优化后：方法变为void返回，移除状态处理\n// 简化为直接操作，无状态返回\nvoid MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n    // 直接执行操作，不再返回状态\n    update_state(words);\n    // 移除了状态返回逻辑\n}\n3. 头文件接口清理\n优化前：复杂的类型定义和状态返回声明\n// psParallelCompact.hpp\ntypedef ParMarkBitMap::IterationStatus IterationStatus;\n\nvirtual IterationStatus do_addr(HeapWord* addr, size_t words);\n\n优化后：简化的接口声明\n// 移除了IterationStatus类型引用\nvoid do_addr(HeapWord* addr, size_t words);  // 直接void返回", "source_url": "https://github.com/openjdk/riscv-port/commit/4754f059f99a426cc8c5d94b0809e79d563ffc2e", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 枚举类型移除\n优化前：存在复杂的迭代状态枚举\n// parMarkBitMap.hpp\nenum IterationStatus { incomplete, complete, full };\n\n优化后：完全移除状态枚举\n// 枚举定义被删除，简化类型系统\n2. 方法接口简化\n优化前：方法返回复杂状态值\n// psParallelCompact.cpp\nMoveAndUpdateClosure::IterationStatus\nMoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n    // 复杂的状态处理逻辑\n    return is_full() ? ParMarkBitMap::full : ParMarkBitMap::incomplete;\n}\n\n优化后：方法变为void返回，移除状态处理\n// 简化为直接操作，无状态返回\nvoid MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n    // 直接执行操作，不再返回状态\n    update_state(words);\n    // 移除了状态返回逻辑\n}\n3. 头文件接口清理\n优化前：复杂的类型定义和状态返回声明\n// psParallelCompact.hpp\ntypedef ParMarkBitMap::IterationStatus IterationStatus;\n\nvirtual IterationStatus do_addr(HeapWord* addr, size_t words);\n\n优化后：简化的接口声明\n// 移除了IterationStatus类型引用\nvoid do_addr(HeapWord* addr, size_t words);  // 直接void返回", "target": "1. 枚举类型移除\n优化前：存在复杂的迭代状态枚举\n// parMarkBitMap.hpp\nenum IterationStatus { incomplete, complete, full };\n\n优化后：完全移除状态枚举\n// 枚举定义被删除，简化类型系统\n2. 方法接口简化\n优化前：方法返回复杂状态值\n// psParallelCompact.cpp\nMoveAndUpdateClosure::IterationStatus\nMoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n    // 复杂的状态处理逻辑\n    return is_full() ? ParMarkBitMap::full : ParMarkBitMap::incomplete;\n}\n\n优化后：方法变为void返回，移除状态处理\n// 简化为直接操作，无状态返回\nvoid MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n    // 直接执行操作，不再返回状态\n    update_state(words);\n    // 移除了状态返回逻辑\n}\n3. 头文件接口清理\n优化前：复杂的类型定义和状态返回声明\n// psParallelCompact.hpp\ntypedef ParMarkBitMap::IterationStatus IterationStatus;\n\nvirtual IterationStatus do_addr(HeapWord* addr, size_t words);\n\n优化后：简化的接口声明\n// 移除了IterationStatus类型引用\nvoid do_addr(HeapWord* addr, size_t words);  // 直接void返回", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "分支预测改善：移除状态检查减少分支指令\n流水线效率：减少条件分支可能改善指令流水线性能\n代码路径简化：更直接的操作路径，减少控制流复杂度"}
{"id": 991, "source": "riscv-dataset-excel", "optimization_type": "内存优化", "optimization_description": "对象大小减少：每个VarHandle实例减少一个long字段（8字节）\n内存占用降低：对于大量VarHandle使用场景，有累积效应\n缓存效率：更小的对象可能改善缓存局部性", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 内存优化：移除冗余字段\n优化前：每个VarHandle实例包含冗余的length字段\nabstract sealed class VarHandleSegmentViewBase extends VarHandle permits {\n    final boolean be;\n    final long length;  // 冗余字段：从类型即可推导出大小\n    final long alignmentMask;\n    \n    VarHandleSegmentViewBase(VarForm form, boolean be, long length, \n                           long alignmentMask, boolean exact) {\n        this.length = length;  // 存储不必要的数据\n    }\n}\n优化后：移除length字段，减少内存占用\nabstract sealed class VarHandleSegmentViewBase extends VarHandle permits {\n    final boolean be;\n    // length字段被移除\n    final long alignmentMask;\n    \n    VarHandleSegmentViewBase(VarForm form, boolean be, \n                           long alignmentMask, boolean exact) {\n        // 不再存储length\n    }\n}\n2. 参数传递简化\n优化前：需要传递size参数\n// 创建VarHandle时需要计算和传递size\nlong size = Utils.byteWidthOfPrimitive(carrier);\nreturn maybeAdapt(new VarHandleSegmentAsBytes(be, size, alignmentMask, exact));\n\n优化后：直接根据类型推断，移除size参数\n// 简化参数列表\nreturn maybeAdapt(new VarHandleSegmentAsBytes(be, alignmentMask, exact));\n3. 异常处理简化\n优化前：有专用的对齐异常方法\n\nstatic IllegalArgumentException newIllegalArgumentExceptionForMisalignedAccess(long address) {\n    return new IllegalArgumentException(\"Misaligned access at address: \" + \n                                     Utils.toHexString(address));\n}\n\n优化后：移除专用方法，使用标准异常\n\njava\n下载\n复制\n运行\n// 方法被移除，可能使用更通用的异常处理机制\n4. 文档澄清优化\n\n优化前：文档描述可能引起混淆\n\njava\n下载\n复制\n运行\n// 旧的偏移量计算描述\n* <li>The offset of the access operation (computed as above) must fall inside\n* the spatial bounds of the accessed memory segment...</li>\n\n优化后：更清晰的边界检查描述\n\njava\n下载\n复制\n运行\n// 新的基偏移量描述，强调布局大小可能大于访问布局\n* <li>The access operation must fall inside the spatial bounds of the accessed\n* memory segment...</li>\n* Note that the size of this layout might be <em>bigger</em>\n* than the size of the accessed layout (e.g. when accessing a struct member).</li>", "source_url": "https://github.com/openjdk/riscv-port/commit/c003c1207fae07bcfe5a6f642a9c05e6c591e7a6", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 内存优化：移除冗余字段\n优化前：每个VarHandle实例包含冗余的length字段\nabstract sealed class VarHandleSegmentViewBase extends VarHandle permits {\n    final boolean be;\n    final long length;  // 冗余字段：从类型即可推导出大小\n    final long alignmentMask;\n    \n    VarHandleSegmentViewBase(VarForm form, boolean be, long length, \n                           long alignmentMask, boolean exact) {\n        this.length = length;  // 存储不必要的数据\n    }\n}\n优化后：移除length字段，减少内存占用\nabstract sealed class VarHandleSegmentViewBase extends VarHandle permits {\n    final boolean be;\n    // length字段被移除\n    final long alignmentMask;\n    \n    VarHandleSegmentViewBase(VarForm form, boolean be, \n                           long alignmentMask, boolean exact) {\n        // 不再存储length\n    }\n}\n2. 参数传递简化\n优化前：需要传递size参数\n// 创建VarHandle时需要计算和传递size\nlong size = Utils.byteWidthOfPrimitive(carrier);\nreturn maybeAdapt(new VarHandleSegmentAsBytes(be, size, alignmentMask, exact));\n\n优化后：直接根据类型推断，移除size参数\n// 简化参数列表\nreturn maybeAdapt(new VarHandleSegmentAsBytes(be, alignmentMask, exact));\n3. 异常处理简化\n优化前：有专用的对齐异常方法\n\nstatic IllegalArgumentException newIllegalArgumentExceptionForMisalignedAccess(long address) {\n    return new IllegalArgumentException(\"Misaligned access at address: \" + \n                                     Utils.toHexString(address));\n}\n\n优化后：移除专用方法，使用标准异常\n\njava\n下载\n复制\n运行\n// 方法被移除，可能使用更通用的异常处理机制\n4. 文档澄清优化\n\n优化前：文档描述可能引起混淆\n\njava\n下载\n复制\n运行\n// 旧的偏移量计算描述\n* <li>The offset of the access operation (computed as above) must fall inside\n* the spatial bounds of the accessed memory segment...</li>\n\n优化后：更清晰的边界检查描述\n\njava\n下载\n复制\n运行\n// 新的基偏移量描述，强调布局大小可能大于访问布局\n* <li>The access operation must fall inside the spatial bounds of the accessed\n* memory segment...</li>\n* Note that the size of this layout might be <em>bigger</em>\n* than the size of the accessed layout (e.g. when accessing a struct member).</li>", "target": "1. 内存优化：移除冗余字段\n优化前：每个VarHandle实例包含冗余的length字段\nabstract sealed class VarHandleSegmentViewBase extends VarHandle permits {\n    final boolean be;\n    final long length;  // 冗余字段：从类型即可推导出大小\n    final long alignmentMask;\n    \n    VarHandleSegmentViewBase(VarForm form, boolean be, long length, \n                           long alignmentMask, boolean exact) {\n        this.length = length;  // 存储不必要的数据\n    }\n}\n优化后：移除length字段，减少内存占用\nabstract sealed class VarHandleSegmentViewBase extends VarHandle permits {\n    final boolean be;\n    // length字段被移除\n    final long alignmentMask;\n    \n    VarHandleSegmentViewBase(VarForm form, boolean be, \n                           long alignmentMask, boolean exact) {\n        // 不再存储length\n    }\n}\n2. 参数传递简化\n优化前：需要传递size参数\n// 创建VarHandle时需要计算和传递size\nlong size = Utils.byteWidthOfPrimitive(carrier);\nreturn maybeAdapt(new VarHandleSegmentAsBytes(be, size, alignmentMask, exact));\n\n优化后：直接根据类型推断，移除size参数\n// 简化参数列表\nreturn maybeAdapt(new VarHandleSegmentAsBytes(be, alignmentMask, exact));\n3. 异常处理简化\n优化前：有专用的对齐异常方法\n\nstatic IllegalArgumentException newIllegalArgumentExceptionForMisalignedAccess(long address) {\n    return new IllegalArgumentException(\"Misaligned access at address: \" + \n                                     Utils.toHexString(address));\n}\n\n优化后：移除专用方法，使用标准异常\n\njava\n下载\n复制\n运行\n// 方法被移除，可能使用更通用的异常处理机制\n4. 文档澄清优化\n\n优化前：文档描述可能引起混淆\n\njava\n下载\n复制\n运行\n// 旧的偏移量计算描述\n* <li>The offset of the access operation (computed as above) must fall inside\n* the spatial bounds of the accessed memory segment...</li>\n\n优化后：更清晰的边界检查描述\n\njava\n下载\n复制\n运行\n// 新的基偏移量描述，强调布局大小可能大于访问布局\n* <li>The access operation must fall inside the spatial bounds of the accessed\n* memory segment...</li>\n* Note that the size of this layout might be <em>bigger</em>\n* than the size of the accessed layout (e.g. when accessing a struct member).</li>", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "对象大小减少：每个VarHandle实例减少一个long字段（8字节）\n内存占用降低：对于大量VarHandle使用场景，有累积效应\n缓存效率：更小的对象可能改善缓存局部性"}
{"id": 992, "source": "riscv-dataset-excel", "optimization_type": "指令集优化​ + 编译器优化​ + 寄存器优化", "optimization_description": "APX关键特性带来的性能提升\n\n寄存器数量翻倍：\n\n从16个通用寄存器扩展到32个\n\n减少寄存器溢出，降低栈访问频率\n\n改善函数调用性能和循环优化\n\n3操作数指令支持：\n\n允许a = b + c形式指令，减少数据移动\n\n替代传统的mov + op指令序列\n\n提高指令密度和执行效率\n\n新指令集增强：\n\n条件指令优化减少分支预测失败\n\n内存操作改进提升加载/存储效率\n\n字符串操作加速提升数据处理", "original_code": "// No original code extracted from description\n", "optimized_code": "编译器基础设施更新\n// 推测的代码变更：添加APX指令编码支持\nclass Assembler {\n    // 添加APX相关指令编码方法\n    void apx_instruction_encoding(Register dest, Register src1, Register src2);\n    void support_apx_extended_registers();\n};\n\n// 寄存器映射扩展\nenum Register {\n    // 传统寄存器\n    rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi,\n    r8, r9, r10, r11, r12, r13, r14, r15,\n    // APX扩展寄存器\n    r16, r17, r18, r19, r20, r21, r22, r23,\n    r24, r25, r26, r27, r28, r29, r30, r31\n};\n指令发射逻辑优化\n// 优化指令选择器以利用APX特性\nvoid InstructionSelector::SelectAPXOptimizedInstructions() {\n    if (CPU::supports_apx()) {\n        // 使用APX扩展指令替代传统指令序列\n        UseAPXThreeOperandInstructions();\n        UtilizeExtendedRegisterSet();\n    }\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/f8a3e4e428f7d3e62177bdf148fe25e22d3ee2bf", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "编译器基础设施更新\n// 推测的代码变更：添加APX指令编码支持\nclass Assembler {\n    // 添加APX相关指令编码方法\n    void apx_instruction_encoding(Register dest, Register src1, Register src2);\n    void support_apx_extended_registers();\n};\n\n// 寄存器映射扩展\nenum Register {\n    // 传统寄存器\n    rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi,\n    r8, r9, r10, r11, r12, r13, r14, r15,\n    // APX扩展寄存器\n    r16, r17, r18, r19, r20, r21, r22, r23,\n    r24, r25, r26, r27, r28, r29, r30, r31\n};\n指令发射逻辑优化\n// 优化指令选择器以利用APX特性\nvoid InstructionSelector::SelectAPXOptimizedInstructions() {\n    if (CPU::supports_apx()) {\n        // 使用APX扩展指令替代传统指令序列\n        UseAPXThreeOperandInstructions();\n        UtilizeExtendedRegisterSet();\n    }\n}", "target": "编译器基础设施更新\n// 推测的代码变更：添加APX指令编码支持\nclass Assembler {\n    // 添加APX相关指令编码方法\n    void apx_instruction_encoding(Register dest, Register src1, Register src2);\n    void support_apx_extended_registers();\n};\n\n// 寄存器映射扩展\nenum Register {\n    // 传统寄存器\n    rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi,\n    r8, r9, r10, r11, r12, r13, r14, r15,\n    // APX扩展寄存器\n    r16, r17, r18, r19, r20, r21, r22, r23,\n    r24, r25, r26, r27, r28, r29, r30, r31\n};\n指令发射逻辑优化\n// 优化指令选择器以利用APX特性\nvoid InstructionSelector::SelectAPXOptimizedInstructions() {\n    if (CPU::supports_apx()) {\n        // 使用APX扩展指令替代传统指令序列\n        UseAPXThreeOperandInstructions();\n        UtilizeExtendedRegisterSet();\n    }\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "APX关键特性带来的性能提升\n\n寄存器数量翻倍：\n\n从16个通用寄存器扩展到32个\n\n减少寄存器溢出，降低栈访问频率\n\n改善函数调用性能和循环优化\n\n3操作数指令支持：\n\n允许a = b + c形式指令，减少数据移动\n\n替代传统的mov + op指令序列\n\n提高指令密度和执行效率\n\n新指令集增强：\n\n条件指令优化减少分支预测失败\n\n内存操作改进提升加载/存储效率\n\n字符串操作加速提升数据处理"}
{"id": 993, "source": "riscv-dataset-excel", "optimization_type": "编译器优化​ + 运行时优化​ + 方法句柄优化", "optimization_description": "减少方法句柄适配开销：\n\n避免不必要的方法句柄组合和转换\n\n减少动态调用时的类型检查\n\n改善初始化性能：\n\n延迟加载方法句柄，避免类加载时的初始化开销\n\n减少静态初始化块的执行时间\n\n代码生成优化：\n\n内联关键检查逻辑，减少间接调用\n\n优化生成的字节码质量", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 方法句柄初始化优化\n\n优化前：静态字段直接初始化，可能重复创建\n// 原始代码：静态字段直接初始化\nprivate static final MethodHandle NULL_CHECK;\nprivate static final MethodHandle IS_ZERO;\nprivate static final MethodHandle CHECK_INDEX;\nprivate static final MethodHandle MAPPED_ENUM_LOOKUP;\n\nstatic {\n    try {\n        NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\", ...);\n        IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\", ...);\n        // ... 其他初始化\n    } catch (ReflectiveOperationException e) {\n        throw new ExceptionInInitializerError(e);\n    }\n}\n\n优化后：使用静态内部类延迟加载，避免不必要的初始化\n// 优化后：使用静态内部类管理方法句柄\nprivate static class StaticHolders {\n    private static final MethodHandle NULL_CHECK;\n    private static final MethodHandle IS_ZERO;\n    private static final MethodHandle MAPPED_ENUM_LOOKUP;\n    \n    static {\n        try {\n            NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\", ...);\n            IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\", ...);\n            // 延迟初始化，避免不必要的加载\n        } catch (ReflectiveOperationException e) {\n            throw new ExceptionInitializerError(e);\n        }\n    }\n}\n2. 索引检查优化\n\n优化前：通过方法句柄包装进行索引检查\n// 原始代码：额外的方法句柄包装\nprivate static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n    MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n    return MethodHandles.filterArguments(target, 1, checkIndex);\n}\n\n// 使用时包装\ntarget = withIndexCheck(target, labels.length);\n\n优化后：直接内联索引检查逻辑\n// 优化后：在生成的代码中直接内联检查\nprivate static Consumer<CodeBuilder> generateTypeSwitchSkeleton(Class<?> selectorType, ...) {\n    return cb -> {\n        // 直接生成索引检查指令，避免方法句柄开销\n        cb.iload(RESTART_IDX);\n        cb.loadConstant(labelConstants.length + 1);\n        cb.invokestatic(CD_Objects, \"checkIndex\", CHECK_INDEX_DESCRIPTOR);\n        cb.pop();\n        // ... 其他逻辑\n    };\n}\n3. 类型描述符优化\n\n优化前：动态构建类型描述符\n// 原始代码：动态构建类描述符\nbyte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), ...);\n\n优化后：使用验证过的类型描述符\n// 优化后：使用预验证的二进制名称\nbyte[] classBytes = ClassFile.of().build(\n    ReferenceClassDescImpl.ofValidatedBinaryName(typeSwitchClassName(caller.lookupClass())), ...);\n4. 方法类型统一化\n\n优化前：每次调用时构建方法类型\n// 原始代码：内联构建方法类型\nMethodHandle typeSwitch = lookup.findStatic(lookup.lookupClass(), \"typeSwitch\",\n    MethodType.methodType(int.class, Object.class, int.class, BiPredicate.class, List.class));\n\n优化后：使用预定义的方法类型常量\n// 优化后：使用常量方法类型\nprivate static final MethodType TYPES_SWITCH_TYPE = MethodType.methodType(int.class,\n    Object.class, int.class, BiPredicate.class, List.class);\n\nMethodHandle typeSwitch = lookup.findStatic(lookup.lookupClass(), \"typeSwitch\", TYPES_SWITCH_TYPE);", "source_url": "https://github.com/openjdk/riscv-port/commit/2581935b47afaf661a94c8a8e50ce08065d632f6", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 方法句柄初始化优化\n\n优化前：静态字段直接初始化，可能重复创建\n// 原始代码：静态字段直接初始化\nprivate static final MethodHandle NULL_CHECK;\nprivate static final MethodHandle IS_ZERO;\nprivate static final MethodHandle CHECK_INDEX;\nprivate static final MethodHandle MAPPED_ENUM_LOOKUP;\n\nstatic {\n    try {\n        NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\", ...);\n        IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\", ...);\n        // ... 其他初始化\n    } catch (ReflectiveOperationException e) {\n        throw new ExceptionInInitializerError(e);\n    }\n}\n\n优化后：使用静态内部类延迟加载，避免不必要的初始化\n// 优化后：使用静态内部类管理方法句柄\nprivate static class StaticHolders {\n    private static final MethodHandle NULL_CHECK;\n    private static final MethodHandle IS_ZERO;\n    private static final MethodHandle MAPPED_ENUM_LOOKUP;\n    \n    static {\n        try {\n            NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\", ...);\n            IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\", ...);\n            // 延迟初始化，避免不必要的加载\n        } catch (ReflectiveOperationException e) {\n            throw new ExceptionInitializerError(e);\n        }\n    }\n}\n2. 索引检查优化\n\n优化前：通过方法句柄包装进行索引检查\n// 原始代码：额外的方法句柄包装\nprivate static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n    MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n    return MethodHandles.filterArguments(target, 1, checkIndex);\n}\n\n// 使用时包装\ntarget = withIndexCheck(target, labels.length);\n\n优化后：直接内联索引检查逻辑\n// 优化后：在生成的代码中直接内联检查\nprivate static Consumer<CodeBuilder> generateTypeSwitchSkeleton(Class<?> selectorType, ...) {\n    return cb -> {\n        // 直接生成索引检查指令，避免方法句柄开销\n        cb.iload(RESTART_IDX);\n        cb.loadConstant(labelConstants.length + 1);\n        cb.invokestatic(CD_Objects, \"checkIndex\", CHECK_INDEX_DESCRIPTOR);\n        cb.pop();\n        // ... 其他逻辑\n    };\n}\n3. 类型描述符优化\n\n优化前：动态构建类型描述符\n// 原始代码：动态构建类描述符\nbyte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), ...);\n\n优化后：使用验证过的类型描述符\n// 优化后：使用预验证的二进制名称\nbyte[] classBytes = ClassFile.of().build(\n    ReferenceClassDescImpl.ofValidatedBinaryName(typeSwitchClassName(caller.lookupClass())), ...);\n4. 方法类型统一化\n\n优化前：每次调用时构建方法类型\n// 原始代码：内联构建方法类型\nMethodHandle typeSwitch = lookup.findStatic(lookup.lookupClass(), \"typeSwitch\",\n    MethodType.methodType(int.class, Object.class, int.class, BiPredicate.class, List.class));\n\n优化后：使用预定义的方法类型常量\n// 优化后：使用常量方法类型\nprivate static final MethodType TYPES_SWITCH_TYPE = MethodType.methodType(int.class,\n    Object.class, int.class, BiPredicate.class, List.class);\n\nMethodHandle typeSwitch = lookup.findStatic(lookup.lookupClass(), \"typeSwitch\", TYPES_SWITCH_TYPE);", "target": "1. 方法句柄初始化优化\n\n优化前：静态字段直接初始化，可能重复创建\n// 原始代码：静态字段直接初始化\nprivate static final MethodHandle NULL_CHECK;\nprivate static final MethodHandle IS_ZERO;\nprivate static final MethodHandle CHECK_INDEX;\nprivate static final MethodHandle MAPPED_ENUM_LOOKUP;\n\nstatic {\n    try {\n        NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\", ...);\n        IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\", ...);\n        // ... 其他初始化\n    } catch (ReflectiveOperationException e) {\n        throw new ExceptionInInitializerError(e);\n    }\n}\n\n优化后：使用静态内部类延迟加载，避免不必要的初始化\n// 优化后：使用静态内部类管理方法句柄\nprivate static class StaticHolders {\n    private static final MethodHandle NULL_CHECK;\n    private static final MethodHandle IS_ZERO;\n    private static final MethodHandle MAPPED_ENUM_LOOKUP;\n    \n    static {\n        try {\n            NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\", ...);\n            IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\", ...);\n            // 延迟初始化，避免不必要的加载\n        } catch (ReflectiveOperationException e) {\n            throw new ExceptionInitializerError(e);\n        }\n    }\n}\n2. 索引检查优化\n\n优化前：通过方法句柄包装进行索引检查\n// 原始代码：额外的方法句柄包装\nprivate static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n    MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n    return MethodHandles.filterArguments(target, 1, checkIndex);\n}\n\n// 使用时包装\ntarget = withIndexCheck(target, labels.length);\n\n优化后：直接内联索引检查逻辑\n// 优化后：在生成的代码中直接内联检查\nprivate static Consumer<CodeBuilder> generateTypeSwitchSkeleton(Class<?> selectorType, ...) {\n    return cb -> {\n        // 直接生成索引检查指令，避免方法句柄开销\n        cb.iload(RESTART_IDX);\n        cb.loadConstant(labelConstants.length + 1);\n        cb.invokestatic(CD_Objects, \"checkIndex\", CHECK_INDEX_DESCRIPTOR);\n        cb.pop();\n        // ... 其他逻辑\n    };\n}\n3. 类型描述符优化\n\n优化前：动态构建类型描述符\n// 原始代码：动态构建类描述符\nbyte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), ...);\n\n优化后：使用验证过的类型描述符\n// 优化后：使用预验证的二进制名称\nbyte[] classBytes = ClassFile.of().build(\n    ReferenceClassDescImpl.ofValidatedBinaryName(typeSwitchClassName(caller.lookupClass())), ...);\n4. 方法类型统一化\n\n优化前：每次调用时构建方法类型\n// 原始代码：内联构建方法类型\nMethodHandle typeSwitch = lookup.findStatic(lookup.lookupClass(), \"typeSwitch\",\n    MethodType.methodType(int.class, Object.class, int.class, BiPredicate.class, List.class));\n\n优化后：使用预定义的方法类型常量\n// 优化后：使用常量方法类型\nprivate static final MethodType TYPES_SWITCH_TYPE = MethodType.methodType(int.class,\n    Object.class, int.class, BiPredicate.class, List.class);\n\nMethodHandle typeSwitch = lookup.findStatic(lookup.lookupClass(), \"typeSwitch\", TYPES_SWITCH_TYPE);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "减少方法句柄适配开销：\n\n避免不必要的方法句柄组合和转换\n\n减少动态调用时的类型检查\n\n改善初始化性能：\n\n延迟加载方法句柄，避免类加载时的初始化开销\n\n减少静态初始化块的执行时间\n\n代码生成优化：\n\n内联关键检查逻辑，减少间接调用\n\n优化生成的字节码质量"}
{"id": 994, "source": "riscv-dataset-excel", "optimization_type": "指令集优化​ + 编译器代码生成优化", "optimization_description": "指令数减少：从6条指令减少到5条指令，减少16.7%的指令数\n执行周期优化：减少依赖链，改善指令级并行\n寄存器利用：更好利用临时寄存器，减少资源冲突\n代码大小优化：减少生成的二进制大小", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 双路径指针材料化优化\n优化前：单一6指令序列（movptr1）\n// 原始movptr1：6条指令\nvoid movptr1(Register Rd, uint64_t imm64, int32_t &offset) {\n    // 指令序列：lui + addi + slli + addi + slli + addi\n    // 6条指令，无临时寄存器使用\n}\n优化后：双路径选择，支持更快的5指令序列（movptr2）\n// 新增movptr2：5条指令，使用临时寄存器\nvoid movptr2(Register Rd, uint64_t addr, int32_t &offset, Register tmp) {\n    // 指令序列：lui + lui + slli + add + addi\n    // 5条指令，利用临时寄存器优化\n    lui(tmp, upper18 << 12);      // 加载高18位到临时寄存器\n    lui(Rd, mid18 << 12);        // 加载中18位到目标寄存器\n    slli(tmp, tmp, 18);           // 临时寄存器左移18位\n    add(Rd, Rd, tmp);             // 合并高36位\n    // addi 添加低12位（通过offset处理）\n}\n2. 智能接口设计\n// 改进的movptr接口，自动选择最优路径\nvoid movptr(Register Rd, address addr, int32_t &offset, Register temp) {\n    if (temp == noreg) {\n        movptr1(Rd, uimm64, offset); 寄存器时使用6指令版本\n    } else {\n        movptr2(Rd, uimm64, offset, temp);  // 有临时寄存器时使用5指令版本\n    }\n}\n3. 指令成本模型更新\n// 优化前成本计算\nins_cost(BRANCH_COST + ALU_COST * 6);  // 6条ALU指令\n\n// 优化后成本计算  \nins_cost(BRANCH_COST + ALU_COST * 5);  // 5条ALU指令，减少16.7%\n4. 指令序列识别优化\n// 新增movptr2指令序列检测\nbool is_movptr2_at(address instr) {\n    return is_lui_at(instr) &&                    // 第一条lui\n           is_lui_at(instr + instruction_size) && // 第二条lui  \n           is_slli_shift_at(instr + 2*instruction_size, 18) && // slli\n           is_add_at(instr + instruction_size) &&           // add\n           (is_addi_at(instr + 4*instruction_size) ||         // addi/jalr/load\n            is_jalr_at(instr + 4*instruction_size) ||\n            is_load_at(instr + 4*instruction_size));\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/7b52d0acfc7d6083b407efa0877c139e9837f86b", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 双路径指针材料化优化\n优化前：单一6指令序列（movptr1）\n// 原始movptr1：6条指令\nvoid movptr1(Register Rd, uint64_t imm64, int32_t &offset) {\n    // 指令序列：lui + addi + slli + addi + slli + addi\n    // 6条指令，无临时寄存器使用\n}\n优化后：双路径选择，支持更快的5指令序列（movptr2）\n// 新增movptr2：5条指令，使用临时寄存器\nvoid movptr2(Register Rd, uint64_t addr, int32_t &offset, Register tmp) {\n    // 指令序列：lui + lui + slli + add + addi\n    // 5条指令，利用临时寄存器优化\n    lui(tmp, upper18 << 12);      // 加载高18位到临时寄存器\n    lui(Rd, mid18 << 12);        // 加载中18位到目标寄存器\n    slli(tmp, tmp, 18);           // 临时寄存器左移18位\n    add(Rd, Rd, tmp);             // 合并高36位\n    // addi 添加低12位（通过offset处理）\n}\n2. 智能接口设计\n// 改进的movptr接口，自动选择最优路径\nvoid movptr(Register Rd, address addr, int32_t &offset, Register temp) {\n    if (temp == noreg) {\n        movptr1(Rd, uimm64, offset); 寄存器时使用6指令版本\n    } else {\n        movptr2(Rd, uimm64, offset, temp);  // 有临时寄存器时使用5指令版本\n    }\n}\n3. 指令成本模型更新\n// 优化前成本计算\nins_cost(BRANCH_COST + ALU_COST * 6);  // 6条ALU指令\n\n// 优化后成本计算  \nins_cost(BRANCH_COST + ALU_COST * 5);  // 5条ALU指令，减少16.7%\n4. 指令序列识别优化\n// 新增movptr2指令序列检测\nbool is_movptr2_at(address instr) {\n    return is_lui_at(instr) &&                    // 第一条lui\n           is_lui_at(instr + instruction_size) && // 第二条lui  \n           is_slli_shift_at(instr + 2*instruction_size, 18) && // slli\n           is_add_at(instr + instruction_size) &&           // add\n           (is_addi_at(instr + 4*instruction_size) ||         // addi/jalr/load\n            is_jalr_at(instr + 4*instruction_size) ||\n            is_load_at(instr + 4*instruction_size));\n}", "target": "1. 双路径指针材料化优化\n优化前：单一6指令序列（movptr1）\n// 原始movptr1：6条指令\nvoid movptr1(Register Rd, uint64_t imm64, int32_t &offset) {\n    // 指令序列：lui + addi + slli + addi + slli + addi\n    // 6条指令，无临时寄存器使用\n}\n优化后：双路径选择，支持更快的5指令序列（movptr2）\n// 新增movptr2：5条指令，使用临时寄存器\nvoid movptr2(Register Rd, uint64_t addr, int32_t &offset, Register tmp) {\n    // 指令序列：lui + lui + slli + add + addi\n    // 5条指令，利用临时寄存器优化\n    lui(tmp, upper18 << 12);      // 加载高18位到临时寄存器\n    lui(Rd, mid18 << 12);        // 加载中18位到目标寄存器\n    slli(tmp, tmp, 18);           // 临时寄存器左移18位\n    add(Rd, Rd, tmp);             // 合并高36位\n    // addi 添加低12位（通过offset处理）\n}\n2. 智能接口设计\n// 改进的movptr接口，自动选择最优路径\nvoid movptr(Register Rd, address addr, int32_t &offset, Register temp) {\n    if (temp == noreg) {\n        movptr1(Rd, uimm64, offset); 寄存器时使用6指令版本\n    } else {\n        movptr2(Rd, uimm64, offset, temp);  // 有临时寄存器时使用5指令版本\n    }\n}\n3. 指令成本模型更新\n// 优化前成本计算\nins_cost(BRANCH_COST + ALU_COST * 6);  // 6条ALU指令\n\n// 优化后成本计算  \nins_cost(BRANCH_COST + ALU_COST * 5);  // 5条ALU指令，减少16.7%\n4. 指令序列识别优化\n// 新增movptr2指令序列检测\nbool is_movptr2_at(address instr) {\n    return is_lui_at(instr) &&                    // 第一条lui\n           is_lui_at(instr + instruction_size) && // 第二条lui  \n           is_slli_shift_at(instr + 2*instruction_size, 18) && // slli\n           is_add_at(instr + instruction_size) &&           // add\n           (is_addi_at(instr + 4*instruction_size) ||         // addi/jalr/load\n            is_jalr_at(instr + 4*instruction_size) ||\n            is_load_at(instr + 4*instruction_size));\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "指令数减少：从6条指令减少到5条指令，减少16.7%的指令数\n执行周期优化：减少依赖链，改善指令级并行\n寄存器利用：更好利用临时寄存器，减少资源冲突\n代码大小优化：减少生成的二进制大小"}
{"id": 995, "source": "riscv-dataset-excel", "optimization_type": "内存优化+ 编译器优化", "optimization_description": "减少内存开销：\n消除虚函数表指针（vptr）存储\n减少对象头大小\n改善缓存局部性\n\n降低调用开销：\n消除虚函数调用间接性\n减少函数调用层次\n改善内联优化机会\n\n提升数据局部性：\n相关数据成员在内存中连续存储\n减少缓存失效概率\n提高内存访问效率", "original_code": "// No original code extracted from description\n", "optimized_code": "1.类层次扁平化优化\n优化前：两层继承结构（额外虚函数开销）\n// 原始代码：MoveAndUpdateClosure继承自ParMarkBitMapClosure\nclass MoveAndUpdateClosure: public ParMarkBitMapClosure {\n    // 需要维护基类关系，有虚函数调用开销\n};\n\n优化后：直接实现，消除继承层次\n// 优化后：MoveAndUpdateClosure直接实现所需功能\nclass MoveAndUpdateClosure: public StackObj {\n    // 内联所有必要成员，无继承开销\n    ParMarkBitMap* const _bitmap;\n    size_t _words_remaining;\n    // ... 直接包含所需数据成员\n};\n2. 构造函数简化\n优化前：需要传递冗余的CompactionManager参数\n// 原始构造函数：需要cm参数\nMoveAndUpdateClosure::MoveAndUpdateClosure(ParMarkBitMap* bitmap,\n                                           ParCompactionManager* cm,\n                                           size_t region_idx)\n    : ParMarkBitMapClosure(bitmap, cm, calculate_words_remaining(region_idx)),\n      // ... 其他初始化\n{}\n\n优化后：移除不必要的cm参数\n// 优化后构造函数：简化参数列表\nMoveAndUpdateClosure::MoveAndUpdateClosure(ParMarkBitMap* bitmap, size_t region_idx)\n    : _bitmap(bitmap),\n      _words_remaining(calculate_words_remaining(region_idx)),\n      // ... 直接初始化\n{}\n3. 方法内联优化\n优化前：通过基类虚函数调用\n// 原始：虚函数调用链\nParMarkBitMapClosure::IterationStatus\nMoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n    // 需要通过基类机制调用\n}\n\n优化后：直接内联实现\n// 优化后：直接实现，避免虚函数开销\nMoveAndUpdateClosure::IterationStatus\nMoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n    // 直接访问成员变量，无虚函数开销\n    _source = addr;\n    // ... 直接操作\n}\n4. 成员访问优化\n优化前：通过基类间接访问\n// 原始：通过基类访问器\nHeapWord* source() const { return ParMarkBitMapClosure::source(); }\n\n优化后：直接访问成员变量\n// 优化后：直接内联访问\nHeapWord* source() const { return _source; }", "source_url": "https://github.com/openjdk/riscv-port/commit/1850914380655ef3d08614a5656e7cc23478f38f", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1.类层次扁平化优化\n优化前：两层继承结构（额外虚函数开销）\n// 原始代码：MoveAndUpdateClosure继承自ParMarkBitMapClosure\nclass MoveAndUpdateClosure: public ParMarkBitMapClosure {\n    // 需要维护基类关系，有虚函数调用开销\n};\n\n优化后：直接实现，消除继承层次\n// 优化后：MoveAndUpdateClosure直接实现所需功能\nclass MoveAndUpdateClosure: public StackObj {\n    // 内联所有必要成员，无继承开销\n    ParMarkBitMap* const _bitmap;\n    size_t _words_remaining;\n    // ... 直接包含所需数据成员\n};\n2. 构造函数简化\n优化前：需要传递冗余的CompactionManager参数\n// 原始构造函数：需要cm参数\nMoveAndUpdateClosure::MoveAndUpdateClosure(ParMarkBitMap* bitmap,\n                                           ParCompactionManager* cm,\n                                           size_t region_idx)\n    : ParMarkBitMapClosure(bitmap, cm, calculate_words_remaining(region_idx)),\n      // ... 其他初始化\n{}\n\n优化后：移除不必要的cm参数\n// 优化后构造函数：简化参数列表\nMoveAndUpdateClosure::MoveAndUpdateClosure(ParMarkBitMap* bitmap, size_t region_idx)\n    : _bitmap(bitmap),\n      _words_remaining(calculate_words_remaining(region_idx)),\n      // ... 直接初始化\n{}\n3. 方法内联优化\n优化前：通过基类虚函数调用\n// 原始：虚函数调用链\nParMarkBitMapClosure::IterationStatus\nMoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n    // 需要通过基类机制调用\n}\n\n优化后：直接内联实现\n// 优化后：直接实现，避免虚函数开销\nMoveAndUpdateClosure::IterationStatus\nMoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n    // 直接访问成员变量，无虚函数开销\n    _source = addr;\n    // ... 直接操作\n}\n4. 成员访问优化\n优化前：通过基类间接访问\n// 原始：通过基类访问器\nHeapWord* source() const { return ParMarkBitMapClosure::source(); }\n\n优化后：直接访问成员变量\n// 优化后：直接内联访问\nHeapWord* source() const { return _source; }", "target": "1.类层次扁平化优化\n优化前：两层继承结构（额外虚函数开销）\n// 原始代码：MoveAndUpdateClosure继承自ParMarkBitMapClosure\nclass MoveAndUpdateClosure: public ParMarkBitMapClosure {\n    // 需要维护基类关系，有虚函数调用开销\n};\n\n优化后：直接实现，消除继承层次\n// 优化后：MoveAndUpdateClosure直接实现所需功能\nclass MoveAndUpdateClosure: public StackObj {\n    // 内联所有必要成员，无继承开销\n    ParMarkBitMap* const _bitmap;\n    size_t _words_remaining;\n    // ... 直接包含所需数据成员\n};\n2. 构造函数简化\n优化前：需要传递冗余的CompactionManager参数\n// 原始构造函数：需要cm参数\nMoveAndUpdateClosure::MoveAndUpdateClosure(ParMarkBitMap* bitmap,\n                                           ParCompactionManager* cm,\n                                           size_t region_idx)\n    : ParMarkBitMapClosure(bitmap, cm, calculate_words_remaining(region_idx)),\n      // ... 其他初始化\n{}\n\n优化后：移除不必要的cm参数\n// 优化后构造函数：简化参数列表\nMoveAndUpdateClosure::MoveAndUpdateClosure(ParMarkBitMap* bitmap, size_t region_idx)\n    : _bitmap(bitmap),\n      _words_remaining(calculate_words_remaining(region_idx)),\n      // ... 直接初始化\n{}\n3. 方法内联优化\n优化前：通过基类虚函数调用\n// 原始：虚函数调用链\nParMarkBitMapClosure::IterationStatus\nMoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n    // 需要通过基类机制调用\n}\n\n优化后：直接内联实现\n// 优化后：直接实现，避免虚函数开销\nMoveAndUpdateClosure::IterationStatus\nMoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n    // 直接访问成员变量，无虚函数开销\n    _source = addr;\n    // ... 直接操作\n}\n4. 成员访问优化\n优化前：通过基类间接访问\n// 原始：通过基类访问器\nHeapWord* source() const { return ParMarkBitMapClosure::source(); }\n\n优化后：直接访问成员变量\n// 优化后：直接内联访问\nHeapWord* source() const { return _source; }", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "减少内存开销：\n消除虚函数表指针（vptr）存储\n减少对象头大小\n改善缓存局部性\n\n降低调用开销：\n消除虚函数调用间接性\n减少函数调用层次\n改善内联优化机会\n\n提升数据局部性：\n相关数据成员在内存中连续存储\n减少缓存失效概率\n提高内存访问效率"}
{"id": 996, "source": "riscv-dataset-excel", "optimization_type": "其他", "optimization_description": "减少参数传递：\n移除一个参数减少函数调用开销\n降低寄存器压力，提高寄存器分配效率\n\n计算简化：\n用加法指令替代内存加载\n减少依赖链，提高指令级并行\n\n代码精简：\n减少总指令数\n改善缓存局部性", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 参数简化优化（核心变更）\n\n优化前：需要传递zlen参数（z数组长度）\n// 原始接口：需要zlen参数\nvoid multiply_to_len(Register x, Register xlen, Register y, Register ylen, \n                     Register z, Register zlen, ...)\n\n优化后：移除zlen参数，改为tmp0寄存器，内部计算长度\n// 优化后接口：zlen参数改为tmp0寄存器\nvoid multiply_to_len(Register x, Register xlen, Register y, Register ylen,\n                     Register z, Register tmp0, ...)\n2. 计算逻辑优化\n\n优化前：从参数加载zlen\nmovl(kdx, zlen);  // kdx = zlen (从参数获取)\n\n优化后：直接计算xlen + ylen\naddw(kdx, xlen, ylen);  // kdx = xlen + ylen (直接计算)", "source_url": "https://github.com/openjdk/riscv-port/commit/ed81a478e175631f1de69eb4b43f927629fefd74", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 参数简化优化（核心变更）\n\n优化前：需要传递zlen参数（z数组长度）\n// 原始接口：需要zlen参数\nvoid multiply_to_len(Register x, Register xlen, Register y, Register ylen, \n                     Register z, Register zlen, ...)\n\n优化后：移除zlen参数，改为tmp0寄存器，内部计算长度\n// 优化后接口：zlen参数改为tmp0寄存器\nvoid multiply_to_len(Register x, Register xlen, Register y, Register ylen,\n                     Register z, Register tmp0, ...)\n2. 计算逻辑优化\n\n优化前：从参数加载zlen\nmovl(kdx, zlen);  // kdx = zlen (从参数获取)\n\n优化后：直接计算xlen + ylen\naddw(kdx, xlen, ylen);  // kdx = xlen + ylen (直接计算)", "target": "1. 参数简化优化（核心变更）\n\n优化前：需要传递zlen参数（z数组长度）\n// 原始接口：需要zlen参数\nvoid multiply_to_len(Register x, Register xlen, Register y, Register ylen, \n                     Register z, Register zlen, ...)\n\n优化后：移除zlen参数，改为tmp0寄存器，内部计算长度\n// 优化后接口：zlen参数改为tmp0寄存器\nvoid multiply_to_len(Register x, Register xlen, Register y, Register ylen,\n                     Register z, Register tmp0, ...)\n2. 计算逻辑优化\n\n优化前：从参数加载zlen\nmovl(kdx, zlen);  // kdx = zlen (从参数获取)\n\n优化后：直接计算xlen + ylen\naddw(kdx, xlen, ylen);  // kdx = xlen + ylen (直接计算)", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "减少参数传递：\n移除一个参数减少函数调用开销\n降低寄存器压力，提高寄存器分配效率\n\n计算简化：\n用加法指令替代内存加载\n减少依赖链，提高指令级并行\n\n代码精简：\n减少总指令数\n改善缓存局部性"}
{"id": 997, "source": "riscv-dataset-excel", "optimization_type": "指令集优化+向量化优化", "optimization_description": "指令级并行优化：\n单条向量指令可同时比较多个数据元素（如8个32位整数）\n相比标量比较，吞吐量提升可达向量宽度的倍数\n执行效率提升：\n硬件指令 vs 软件模拟：减少指令数和执行周期\n专用比较电路比通用ALU操作更高效\n代码质量改善：\n减少分支和条件判断\n更好的指令缓存局部性", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 无符号向量比较指令支持（核心优化）\n// 在compare_integral_v函数中添加无符号比较case分支\ncase BoolTest::ule: vmsleu_vv(vd, src1, src2, vm); break;  // 无符号小于等于\ncase BoolTest::uge: vmsgeu_vv(vd, src1, src2, vm); break;  // 无符号大于等于  \ncase BoolTest::ult: vmsltu_vv(vd, src1, src2, vm); break;  // 无符号小于\ncase BoolTest::ugt: vmsgtu_vv(vd, src1, src2, vm); break;  // 无符号大于\n\n2. 硬件能力检测优化\n// 优化前：始终返回false，禁用无符号比较支持\nstatic constexpr bool supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n    return false;  // 硬编码禁用\n}\n\n// 优化后：根据RVV扩展支持情况动态返回\nstatic bool supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n    return UseRVV;  // 根据实际硬件能力启用\n}", "source_url": "https://github.com/openjdk/riscv-port/commit/9b61a7608efff13fc3685488f3f54a810ec0ac22", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 无符号向量比较指令支持（核心优化）\n// 在compare_integral_v函数中添加无符号比较case分支\ncase BoolTest::ule: vmsleu_vv(vd, src1, src2, vm); break;  // 无符号小于等于\ncase BoolTest::uge: vmsgeu_vv(vd, src1, src2, vm); break;  // 无符号大于等于  \ncase BoolTest::ult: vmsltu_vv(vd, src1, src2, vm); break;  // 无符号小于\ncase BoolTest::ugt: vmsgtu_vv(vd, src1, src2, vm); break;  // 无符号大于\n\n2. 硬件能力检测优化\n// 优化前：始终返回false，禁用无符号比较支持\nstatic constexpr bool supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n    return false;  // 硬编码禁用\n}\n\n// 优化后：根据RVV扩展支持情况动态返回\nstatic bool supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n    return UseRVV;  // 根据实际硬件能力启用\n}", "target": "1. 无符号向量比较指令支持（核心优化）\n// 在compare_integral_v函数中添加无符号比较case分支\ncase BoolTest::ule: vmsleu_vv(vd, src1, src2, vm); break;  // 无符号小于等于\ncase BoolTest::uge: vmsgeu_vv(vd, src1, src2, vm); break;  // 无符号大于等于  \ncase BoolTest::ult: vmsltu_vv(vd, src1, src2, vm); break;  // 无符号小于\ncase BoolTest::ugt: vmsgtu_vv(vd, src1, src2, vm); break;  // 无符号大于\n\n2. 硬件能力检测优化\n// 优化前：始终返回false，禁用无符号比较支持\nstatic constexpr bool supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n    return false;  // 硬编码禁用\n}\n\n// 优化后：根据RVV扩展支持情况动态返回\nstatic bool supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n    return UseRVV;  // 根据实际硬件能力启用\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "指令级并行优化：\n单条向量指令可同时比较多个数据元素（如8个32位整数）\n相比标量比较，吞吐量提升可达向量宽度的倍数\n执行效率提升：\n硬件指令 vs 软件模拟：减少指令数和执行周期\n专用比较电路比通用ALU操作更高效\n代码质量改善：\n减少分支和条件判断\n更好的指令缓存局部性"}
{"id": 998, "source": "riscv-dataset-excel", "optimization_type": "编译器优化-向量化优化", "optimization_description": "解决的性能问题\n防止错误优化：避免编译器对不匹配的向量操作进行错误折叠\n提升向量化质量：确保带掩码和索引的向量操作正确生成\n增强代码生成：支持更复杂的向量化模式\n\n性能影响\n正确性保障：防止因编译错误导致的性能回归\n向量化效率：提升复杂向量操作的编译质量\n运行时性能：通过正确向量化优化内存访问模式", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 存储节点Identity优化（src/hotspot/share/opto/memnode.cpp）\n优化前：缺乏对向量类型、索引和掩码的检查，可能导致错误优化：\n// 原始代码：可能错误折叠不同向量类型的操作\nif (val->is_Load() && val->in(MemNode::Address)->eqv_uncast(adr) &&\n    val->in(MemNode::Memory)->eqv_uncast(mem) &&\n    val->as_Load()->store_Opcode() == Opcode()) {\n    result = mem; // 可能错误折叠\n}\n\n优化后：添加完整的向量操作匹配检查：\n// 优化后：确保向量类型、索引和掩码完全匹配\nif (!is_StoreVector()) {\n    result = mem;\n} else {\n    const StoreVectorNode* store_vector = as_StoreVector();\n    const StoreVectorNode* mem_vector = mem->as_StoreVector();\n    const Node* store_indices = store_vector->indices();\n    const Node* mem_indices = mem_vector->indices();\n    const Node* store_mask = store_vector->mask();\n    const Node* mem_mask = mem_vector->mask();\n    \n    // 关键优化：检查向量类型、索引和掩码的匹配\n    if (store_vector->vect_type() == mem_vector->vect_type() &&\n        ((store_indices == nullptr) == (mem_indices == nullptr) &&\n         (store_indices == nullptr || store_indices->eqv_uncast(mem_indices))) &&\n        ((store_mask == nullptr) == (mem_mask == nullptr) &&\n         (store_mask == nullptr || store_mask->eqv_uncast(mem_mask)))) {\n        result = mem;\n    }\n}\n2. 新增向量节点支持（src/hotspot/share/opto/vectornode.hpp）\n添加多个新的向量节点类，支持复杂的向量操作：\n// 新增带掩码的向量加载节点\nclass LoadVectorMaskedNode : public LoadVectorNode {\n    virtual int store_Opcode() const {\n        return -1; // 防止错误折叠\n    }\n};\n\n// 新增带索引和掩码的向量散点存储节点\nclass StoreVectorScatterMaskedNode : public StoreVectorNode {\n    enum { Indices = 4, Mask };\n    virtual Node* mask() const { return in(Mask); }\n    virtual Node* indices() const { return in(Indices); }\n};", "source_url": "https://github.com/openjdk/riscv-port/commit/0c934ff4e2fb53a72ad25a080d956745a5649f9b", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 存储节点Identity优化（src/hotspot/share/opto/memnode.cpp）\n优化前：缺乏对向量类型、索引和掩码的检查，可能导致错误优化：\n// 原始代码：可能错误折叠不同向量类型的操作\nif (val->is_Load() && val->in(MemNode::Address)->eqv_uncast(adr) &&\n    val->in(MemNode::Memory)->eqv_uncast(mem) &&\n    val->as_Load()->store_Opcode() == Opcode()) {\n    result = mem; // 可能错误折叠\n}\n\n优化后：添加完整的向量操作匹配检查：\n// 优化后：确保向量类型、索引和掩码完全匹配\nif (!is_StoreVector()) {\n    result = mem;\n} else {\n    const StoreVectorNode* store_vector = as_StoreVector();\n    const StoreVectorNode* mem_vector = mem->as_StoreVector();\n    const Node* store_indices = store_vector->indices();\n    const Node* mem_indices = mem_vector->indices();\n    const Node* store_mask = store_vector->mask();\n    const Node* mem_mask = mem_vector->mask();\n    \n    // 关键优化：检查向量类型、索引和掩码的匹配\n    if (store_vector->vect_type() == mem_vector->vect_type() &&\n        ((store_indices == nullptr) == (mem_indices == nullptr) &&\n         (store_indices == nullptr || store_indices->eqv_uncast(mem_indices))) &&\n        ((store_mask == nullptr) == (mem_mask == nullptr) &&\n         (store_mask == nullptr || store_mask->eqv_uncast(mem_mask)))) {\n        result = mem;\n    }\n}\n2. 新增向量节点支持（src/hotspot/share/opto/vectornode.hpp）\n添加多个新的向量节点类，支持复杂的向量操作：\n// 新增带掩码的向量加载节点\nclass LoadVectorMaskedNode : public LoadVectorNode {\n    virtual int store_Opcode() const {\n        return -1; // 防止错误折叠\n    }\n};\n\n// 新增带索引和掩码的向量散点存储节点\nclass StoreVectorScatterMaskedNode : public StoreVectorNode {\n    enum { Indices = 4, Mask };\n    virtual Node* mask() const { return in(Mask); }\n    virtual Node* indices() const { return in(Indices); }\n};", "target": "1. 存储节点Identity优化（src/hotspot/share/opto/memnode.cpp）\n优化前：缺乏对向量类型、索引和掩码的检查，可能导致错误优化：\n// 原始代码：可能错误折叠不同向量类型的操作\nif (val->is_Load() && val->in(MemNode::Address)->eqv_uncast(adr) &&\n    val->in(MemNode::Memory)->eqv_uncast(mem) &&\n    val->as_Load()->store_Opcode() == Opcode()) {\n    result = mem; // 可能错误折叠\n}\n\n优化后：添加完整的向量操作匹配检查：\n// 优化后：确保向量类型、索引和掩码完全匹配\nif (!is_StoreVector()) {\n    result = mem;\n} else {\n    const StoreVectorNode* store_vector = as_StoreVector();\n    const StoreVectorNode* mem_vector = mem->as_StoreVector();\n    const Node* store_indices = store_vector->indices();\n    const Node* mem_indices = mem_vector->indices();\n    const Node* store_mask = store_vector->mask();\n    const Node* mem_mask = mem_vector->mask();\n    \n    // 关键优化：检查向量类型、索引和掩码的匹配\n    if (store_vector->vect_type() == mem_vector->vect_type() &&\n        ((store_indices == nullptr) == (mem_indices == nullptr) &&\n         (store_indices == nullptr || store_indices->eqv_uncast(mem_indices))) &&\n        ((store_mask == nullptr) == (mem_mask == nullptr) &&\n         (store_mask == nullptr || store_mask->eqv_uncast(mem_mask)))) {\n        result = mem;\n    }\n}\n2. 新增向量节点支持（src/hotspot/share/opto/vectornode.hpp）\n添加多个新的向量节点类，支持复杂的向量操作：\n// 新增带掩码的向量加载节点\nclass LoadVectorMaskedNode : public LoadVectorNode {\n    virtual int store_Opcode() const {\n        return -1; // 防止错误折叠\n    }\n};\n\n// 新增带索引和掩码的向量散点存储节点\nclass StoreVectorScatterMaskedNode : public StoreVectorNode {\n    enum { Indices = 4, Mask };\n    virtual Node* mask() const { return in(Mask); }\n    virtual Node* indices() const { return in(Indices); }\n};", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "解决的性能问题\n防止错误优化：避免编译器对不匹配的向量操作进行错误折叠\n提升向量化质量：确保带掩码和索引的向量操作正确生成\n增强代码生成：支持更复杂的向量化模式\n\n性能影响\n正确性保障：防止因编译错误导致的性能回归\n向量化效率：提升复杂向量操作的编译质量\n运行时性能：通过正确向量化优化内存访问模式"}
{"id": 999, "source": "riscv-dataset-excel", "optimization_type": "编译器优化-循环展开优化", "optimization_description": "解决的问题：\n漏检情况：某些向量化循环可能没有显式的向量类型指令，但使用向量操作数\n过度展开：避免对已向量化的循环进行不必要的展开，防止性能下降\n代码质量：确保编译器优化决策更加精确\n\n性能影响：\n防止性能回归：避免对向量化循环进行不当展开导致的性能损失\n优化准确性：提高编译器对向量化循环的识别精度\nRISC-V特定：针对RISC-V架构的向量扩展进行优化", "original_code": "// No original code extracted from description\n", "optimized_code": "// 优化前：仅检查指令类型\nif (IsVectorized && I.getType()->isVectorTy())\n    return;\n\n// 优化后：同时检查指令类型和操作数类型\nif (IsVectorized && (I.getType()->isVectorTy() ||\n    llvm::any_of(I.operand_values(), [](Value *V) {\n        return V->getType()->isVectorTy();\n    })))\n    return;", "source_url": "https://github.com/llvm/llvm-project/commit/a0b6638c85065b6a098a9a4b1bc468652e8cddc5", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "// 优化前：仅检查指令类型\nif (IsVectorized && I.getType()->isVectorTy())\n    return;\n\n// 优化后：同时检查指令类型和操作数类型\nif (IsVectorized && (I.getType()->isVectorTy() ||\n    llvm::any_of(I.operand_values(), [](Value *V) {\n        return V->getType()->isVectorTy();\n    })))\n    return;", "target": "// 优化前：仅检查指令类型\nif (IsVectorized && I.getType()->isVectorTy())\n    return;\n\n// 优化后：同时检查指令类型和操作数类型\nif (IsVectorized && (I.getType()->isVectorTy() ||\n    llvm::any_of(I.operand_values(), [](Value *V) {\n        return V->getType()->isVectorTy();\n    })))\n    return;", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "解决的问题：\n漏检情况：某些向量化循环可能没有显式的向量类型指令，但使用向量操作数\n过度展开：避免对已向量化的循环进行不必要的展开，防止性能下降\n代码质量：确保编译器优化决策更加精确\n\n性能影响：\n防止性能回归：避免对向量化循环进行不当展开导致的性能损失\n优化准确性：提高编译器对向量化循环的识别精度\nRISC-V特定：针对RISC-V架构的向量扩展进行优化"}
{"id": 1000, "source": "riscv-dataset-excel", "optimization_type": "指令集优化", "optimization_description": "利用RISC-V Zbb/Zbkb扩展的硬件指令优化循环移位操作，\n优化前：循环移位成本为4-5（需要多条指令模拟）\n优化后：当支持Zbb/Zbkb扩展时，成本降为1（单条硬件指令）", "original_code": "循环移位成本为4-5（需要多条指令模拟）", "optimized_code": "case Intrinsic::fshl:\ncase Intrinsic::fshr: {\n    // Funnel-shifts are ROTL/ROTR when the first and second operand are equal.\n    // When Zbb/Zbkb is enabled we can use a single ROL(W)/ROR(I)(W) instruction.\n    if ((ST->hasStdExtZbb() || ST->hasStdExtZbkb()) && RetTy->isIntegerTy() &&\n        ICA.getArgs()[0] == ICA.getArgs()[1] &&\n        (RetTy->getIntegerBitWidth() == 32 ||\n         RetTy->getIntegerBitWidth() == 64) &&\n        RetTy->getIntegerBitWidth() <= ST->getXLen()) {\n        return 1;  // 关键优化：成本从4-5降低到1\n    }\n    break;\n}\n// 检测循环移位模式：fshl(a, a, c) 或 fshr(a, a, c) 相当于 ROTL/ROTR\nif (ICA.getArgs()[0] == ICA.getArgs()[1]) {\n    // 当支持Zbb/Zbkb扩展时，使用单条硬件指令\n    return 1; // 从软件模拟(4-5条指令)优化到硬件指令(1条指令)\n}", "source_url": "https://github.com/llvm/llvm-project/commit/e546d0f5d4179ac95e464ea968f7759e61aea8a3", "code_v0_no_empty_lines": "循环移位成本为4-5（需要多条指令模拟）", "code_v1_no_empty_lines": "case Intrinsic::fshl:\ncase Intrinsic::fshr: {\n    // Funnel-shifts are ROTL/ROTR when the first and second operand are equal.\n    // When Zbb/Zbkb is enabled we can use a single ROL(W)/ROR(I)(W) instruction.\n    if ((ST->hasStdExtZbb() || ST->hasStdExtZbkb()) && RetTy->isIntegerTy() &&\n        ICA.getArgs()[0] == ICA.getArgs()[1] &&\n        (RetTy->getIntegerBitWidth() == 32 ||\n         RetTy->getIntegerBitWidth() == 64) &&\n        RetTy->getIntegerBitWidth() <= ST->getXLen()) {\n        return 1;  // 关键优化：成本从4-5降低到1\n    }\n    break;\n}\n// 检测循环移位模式：fshl(a, a, c) 或 fshr(a, a, c) 相当于 ROTL/ROTR\nif (ICA.getArgs()[0] == ICA.getArgs()[1]) {\n    // 当支持Zbb/Zbkb扩展时，使用单条硬件指令\n    return 1; // 从软件模拟(4-5条指令)优化到硬件指令(1条指令)\n}", "target": "case Intrinsic::fshl:\ncase Intrinsic::fshr: {\n    // Funnel-shifts are ROTL/ROTR when the first and second operand are equal.\n    // When Zbb/Zbkb is enabled we can use a single ROL(W)/ROR(I)(W) instruction.\n    if ((ST->hasStdExtZbb() || ST->hasStdExtZbkb()) && RetTy->isIntegerTy() &&\n        ICA.getArgs()[0] == ICA.getArgs()[1] &&\n        (RetTy->getIntegerBitWidth() == 32 ||\n         RetTy->getIntegerBitWidth() == 64) &&\n        RetTy->getIntegerBitWidth() <= ST->getXLen()) {\n        return 1;  // 关键优化：成本从4-5降低到1\n    }\n    break;\n}\n// 检测循环移位模式：fshl(a, a, c) 或 fshr(a, a, c) 相当于 ROTL/ROTR\nif (ICA.getArgs()[0] == ICA.getArgs()[1]) {\n    // 当支持Zbb/Zbkb扩展时，使用单条硬件指令\n    return 1; // 从软件模拟(4-5条指令)优化到硬件指令(1条指令)\n}", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "利用RISC-V Zbb/Zbkb扩展的硬件指令优化循环移位操作，\n优化前：循环移位成本为4-5（需要多条指令模拟）\n优化后：当支持Zbb/Zbkb扩展时，成本降为1（单条硬件指令）"}
{"id": 1001, "source": "riscv-dataset-excel", "optimization_type": "条件分支优化​ + 垃圾收集器屏障优化​ ", "optimization_description": "分支预测改善：\n\n位测试指令比条件分支具有更好的预测特性\n\n减少分支误预测惩罚，提升流水线效率\n\n指令数减少：\n\n消除条件宽度检查分支路径\n\n减少指令缓存占用，改善指令局部性\n\n内存访问优化：\n\n统一访问gc_state而非多个独立字段\n\n可能改善缓存行利用率", "original_code": "// No original code extracted from description\n", "optimized_code": "1. 屏障激活检查优化\n\n优化前：复杂的多分支条件检查\n\n// 原始代码：需要处理不同字节宽度的活动状态检查\nAddress in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));\n\n// 需要根据字节宽度进行不同处理\nif (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n    __ ldrw(tmp1, in_progress);  // 32位加载\n} else {\n    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n    __ ldrb(tmp1, in_progress);  // 8位加载\n}\n__ cbzw(tmp1, done);  // 条件分支\n\n优化后：统一的位测试检查\n// 优化后：使用gc_state的位测试\nAddress gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n__ ldrb(tmp1, gc_state);  // 统一加载gc_state\n__ tbz(tmp1, ShenandoahHeap::MARKING_BITPOS, done);  // 直接位测试\n2. 跨架构一致性优化\n\n优化应用于所有支持架构：\n\nAArch64架构：\n\n// 优化后AArch64实现\nAddress gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n__ ldrb(tmp1, gc_state);\n__ tbz(tmp1, ShenandoahHeap::MARKING_BITPOS, done);\n\nRISC-V架构：\n\n// 优化后RISC-V实现  \nAddress gc_state(xthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n__ lbu(t1, gc_state);\n__ test_bit(t1, t1, ShenandoahHeap::MARKING_BITPOS);\n__ beqz(t1, done);\n3. 编译器层优化\n\nC1编译器优化：\n\n// 优化前：复杂的类型处理和条件判断\nLIR_Address* mark_active_flag_addr = \n    new LIR_Address(thrd, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()), flag_type);\n\n// 优化后：统一的gc_state位测试\nLIR_Address* gc_state_addr = \n    new LIR_Address(thrd, in_bytes(ShenandoahThreadLocalData::gc_state_offset()), T_BYTE);\n\n// 添加位掩码测试逻辑\nLIR_Opr mask = LIR_OprFact::intConst(ShenandoahHeap::MARKING);\n__ logical_and(flag_val, mask_reg, flag_val);", "source_url": "https://github.com/openjdk/riscv-port/commit/ddd73b458355bffeaa8e0e5017c27d6c6af2dc94", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "1. 屏障激活检查优化\n\n优化前：复杂的多分支条件检查\n\n// 原始代码：需要处理不同字节宽度的活动状态检查\nAddress in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));\n\n// 需要根据字节宽度进行不同处理\nif (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n    __ ldrw(tmp1, in_progress);  // 32位加载\n} else {\n    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n    __ ldrb(tmp1, in_progress);  // 8位加载\n}\n__ cbzw(tmp1, done);  // 条件分支\n\n优化后：统一的位测试检查\n// 优化后：使用gc_state的位测试\nAddress gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n__ ldrb(tmp1, gc_state);  // 统一加载gc_state\n__ tbz(tmp1, ShenandoahHeap::MARKING_BITPOS, done);  // 直接位测试\n2. 跨架构一致性优化\n\n优化应用于所有支持架构：\n\nAArch64架构：\n\n// 优化后AArch64实现\nAddress gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n__ ldrb(tmp1, gc_state);\n__ tbz(tmp1, ShenandoahHeap::MARKING_BITPOS, done);\n\nRISC-V架构：\n\n// 优化后RISC-V实现  \nAddress gc_state(xthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n__ lbu(t1, gc_state);\n__ test_bit(t1, t1, ShenandoahHeap::MARKING_BITPOS);\n__ beqz(t1, done);\n3. 编译器层优化\n\nC1编译器优化：\n\n// 优化前：复杂的类型处理和条件判断\nLIR_Address* mark_active_flag_addr = \n    new LIR_Address(thrd, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()), flag_type);\n\n// 优化后：统一的gc_state位测试\nLIR_Address* gc_state_addr = \n    new LIR_Address(thrd, in_bytes(ShenandoahThreadLocalData::gc_state_offset()), T_BYTE);\n\n// 添加位掩码测试逻辑\nLIR_Opr mask = LIR_OprFact::intConst(ShenandoahHeap::MARKING);\n__ logical_and(flag_val, mask_reg, flag_val);", "target": "1. 屏障激活检查优化\n\n优化前：复杂的多分支条件检查\n\n// 原始代码：需要处理不同字节宽度的活动状态检查\nAddress in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));\n\n// 需要根据字节宽度进行不同处理\nif (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n    __ ldrw(tmp1, in_progress);  // 32位加载\n} else {\n    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n    __ ldrb(tmp1, in_progress);  // 8位加载\n}\n__ cbzw(tmp1, done);  // 条件分支\n\n优化后：统一的位测试检查\n// 优化后：使用gc_state的位测试\nAddress gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n__ ldrb(tmp1, gc_state);  // 统一加载gc_state\n__ tbz(tmp1, ShenandoahHeap::MARKING_BITPOS, done);  // 直接位测试\n2. 跨架构一致性优化\n\n优化应用于所有支持架构：\n\nAArch64架构：\n\n// 优化后AArch64实现\nAddress gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n__ ldrb(tmp1, gc_state);\n__ tbz(tmp1, ShenandoahHeap::MARKING_BITPOS, done);\n\nRISC-V架构：\n\n// 优化后RISC-V实现  \nAddress gc_state(xthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n__ lbu(t1, gc_state);\n__ test_bit(t1, t1, ShenandoahHeap::MARKING_BITPOS);\n__ beqz(t1, done);\n3. 编译器层优化\n\nC1编译器优化：\n\n// 优化前：复杂的类型处理和条件判断\nLIR_Address* mark_active_flag_addr = \n    new LIR_Address(thrd, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()), flag_type);\n\n// 优化后：统一的gc_state位测试\nLIR_Address* gc_state_addr = \n    new LIR_Address(thrd, in_bytes(ShenandoahThreadLocalData::gc_state_offset()), T_BYTE);\n\n// 添加位掩码测试逻辑\nLIR_Opr mask = LIR_OprFact::intConst(ShenandoahHeap::MARKING);\n__ logical_and(flag_val, mask_reg, flag_val);", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "分支预测改善：\n\n位测试指令比条件分支具有更好的预测特性\n\n减少分支误预测惩罚，提升流水线效率\n\n指令数减少：\n\n消除条件宽度检查分支路径\n\n减少指令缓存占用，改善指令局部性\n\n内存访问优化：\n\n统一访问gc_state而非多个独立字段\n\n可能改善缓存行利用率"}
{"id": 1002, "source": "riscv-dataset-excel", "optimization_type": "编译器优化+内存优化", "optimization_description": "优化效果\n性能提升：虚函数调用通常需要额外的指针解引用和跳转，移除virtual后，方法调用变为直接调用，提高了调用速度。对于高频调用的GC方法（如内存分配），这可以累积显著的性能收益。\n代码简洁性：将方法定义从类声明中移出，提高了代码的可读性和维护性。\n兼容性：修改不影响现有行为，因为ContiguousSpace没有明显的子类重写这些方法（从代码上下文推断）。\n\n优化思路\n识别性能关键路径：ContiguousSpace是垃圾回收的核心组件，其allocate和par_allocate方法在内存分配中被频繁调用。\n去虚拟化：通过分析发现这些方法不需要运行时多态（可能没有子类重写），因此移除virtual关键字，允许编译器进行静态绑定。\n代码重构：调整方法顺序（如将top和set_top移到更合理的位置），提升代码组织。", "original_code": "// No original code extracted from description\n", "optimized_code": "移除virtual关键字（在src/hotspot/share/gc/shared/contiguousSpace.hpp文件中）：\n\n// 优化前：\nvirtual HeapWord* allocate(size_t word_size);\nvirtual HeapWord* par_allocate(size_t word_size);\n\n// 优化后：\nHeapWord* allocate(size_t word_size);\nHeapWord* par_allocate(size_t word_size);\n\n这直接去除了虚函数特性，使调用更高效。\n\n调整方法顺序（在同一个文件中）：\n\n\n// 将top和set_top方法的声明移到更靠前的位置\nHeapWord* top() const { return _top; }\nvoid set_top(HeapWord* value) { _top = value; }\n\n这虽不直接影响性能，但改善了代码结构，可能间接优化编译器的处理。", "source_url": "https://github.com/openjdk/riscv-port/commit/0e1dca75ef1f145bcf1ad76a2bf21d647ddaf76b", "code_v0_no_empty_lines": "// No original code extracted from description\n", "code_v1_no_empty_lines": "移除virtual关键字（在src/hotspot/share/gc/shared/contiguousSpace.hpp文件中）：\n\n// 优化前：\nvirtual HeapWord* allocate(size_t word_size);\nvirtual HeapWord* par_allocate(size_t word_size);\n\n// 优化后：\nHeapWord* allocate(size_t word_size);\nHeapWord* par_allocate(size_t word_size);\n\n这直接去除了虚函数特性，使调用更高效。\n\n调整方法顺序（在同一个文件中）：\n\n\n// 将top和set_top方法的声明移到更靠前的位置\nHeapWord* top() const { return _top; }\nvoid set_top(HeapWord* value) { _top = value; }\n\n这虽不直接影响性能，但改善了代码结构，可能间接优化编译器的处理。", "target": "移除virtual关键字（在src/hotspot/share/gc/shared/contiguousSpace.hpp文件中）：\n\n// 优化前：\nvirtual HeapWord* allocate(size_t word_size);\nvirtual HeapWord* par_allocate(size_t word_size);\n\n// 优化后：\nHeapWord* allocate(size_t word_size);\nHeapWord* par_allocate(size_t word_size);\n\n这直接去除了虚函数特性，使调用更高效。\n\n调整方法顺序（在同一个文件中）：\n\n\n// 将top和set_top方法的声明移到更靠前的位置\nHeapWord* top() const { return _top; }\nvoid set_top(HeapWord* value) { _top = value; }\n\n这虽不直接影响性能，但改善了代码结构，可能间接优化编译器的处理。", "input": "", "query_abs": "", "edit_code_abs": "", "edit_opt_abs": "", "text_representation": "优化效果\n性能提升：虚函数调用通常需要额外的指针解引用和跳转，移除virtual后，方法调用变为直接调用，提高了调用速度。对于高频调用的GC方法（如内存分配），这可以累积显著的性能收益。\n代码简洁性：将方法定义从类声明中移出，提高了代码的可读性和维护性。\n兼容性：修改不影响现有行为，因为ContiguousSpace没有明显的子类重写这些方法（从代码上下文推断）。\n\n优化思路\n识别性能关键路径：ContiguousSpace是垃圾回收的核心组件，其allocate和par_allocate方法在内存分配中被频繁调用。\n去虚拟化：通过分析发现这些方法不需要运行时多态（可能没有子类重写），因此移除virtual关键字，允许编译器进行静态绑定。\n代码重构：调整方法顺序（如将top和set_top移到更合理的位置），提升代码组织。"}
