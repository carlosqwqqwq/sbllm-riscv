{"query_idx": 20001, "query_desc": "absval", "code_v0_no_empty_lines": "void absval(float* data, int channels, int size) { for (int q = 0; q < channels; q++) { float* ptr = data + q * size; for (int i = 0; i < size; i++) { if (ptr[i] < 0) ptr[i] = -ptr[i]; } } }", "input_time_mean": 0.000126698, "input_acc": 1, "baseline_size": 1210919, "model_generated_potentially_faster_code_col": "#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid absval(float* data, int channels, int size) {\n    // Process each channel\n    for (int q = 0; q < channels; q++) {\n        float* ptr = data + q * size;\n        int i = 0;\n        \n        // Vectorized processing using RVV\n        size_t vl;\n        for (; i < size; i += vl) {\n            // Set vector length for remaining elements\n            vl = __riscv_vsetvl_e32m8(size - i);\n            \n            // Load vector of floats\n            vfloat32m8_t v_data = __riscv_vle32_v_f32m8(ptr + i, vl);\n            \n            // Compute absolute value: vfsgnjx.vv vd, vs2, vs2\n            vfloat32m8_t v_abs = __riscv_vfsgnjx_vv_f32m8(v_data, v_data, vl);\n            \n            // Store result back\n            __riscv_vse32_v_f32m8(ptr + i, v_abs, vl);\n        }\n    }\n}", "model_generated_potentially_faster_code_col_acc": 1, "model_generated_potentially_faster_code_col_time_mean": 0.000166112, "size": 1210931, "is_fallback": false, "debug_output": "[VERIFY] Checksum: 409336\n[TIME] Average Execution Time: 0.166112 ms", "candidate_0_time": 0.000174816, "candidate_0_correct": true, "candidate_0_score": -0.2658524733353911, "candidate_1_time": 0.000170804, "candidate_1_correct": true, "candidate_1_score": -0.2436863775801306, "candidate_2_time": 0.000175372, "candidate_2_correct": true, "candidate_2_score": -0.26892434503028756, "candidate_3_time": 0.000166112, "candidate_3_correct": true, "candidate_3_score": -0.21776331644262248, "candidate_4_time": 0.00017977799999999999, "candidate_4_correct": true, "candidate_4_score": -0.2932672707276151, "codebleu": 0.5144100338627698, "codebleu_detail": {"codebleu": 0.5144100338627698, "ngram": 0.26808387140652123, "weighted_ngram": 0.2680838714065212, "syntax": 0.5214723926380368, "dataflow": 1.0}}
{"query_idx": 20003, "query_desc": "innerproduct", "code_v0_no_empty_lines": "void innerproduct(float* in_data, float* weight_data, float* bias_data, float* out_data, int num_output, int size) { for (int p = 0; p < num_output; p++) { float sum = bias_data[p]; const float* w = (const float*)weight_data + size * p; const float* m = (const float*)in_data; for (int i = 0; i < size; i++) { sum += m[i] * w[i]; } out_data[p] = sum; } }", "input_time_mean": 0.000303014, "input_acc": 1, "baseline_size": 1211107, "model_generated_potentially_faster_code_col": "#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid innerproduct(float* __restrict in_data,\n                  float* __restrict weight_data,\n                  float* __restrict bias_data,\n                  float* __restrict out_data,\n                  int num_output,\n                  int size) {\n    // Set maximum vector length for initialization\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    \n    for (int p = 0; p < num_output; p++) {\n        float sum = bias_data[p];\n        const float* w = weight_data + size * p;\n        const float* m = in_data;\n        \n        // Vector accumulator\n        vfloat32m1_t v_sum = __riscv_vfmv_v_f_f32m1(0.0f, vlmax);\n        \n        // Main vectorized loop\n        long i = 0;\n        long n = size;\n        while (i < n) {\n            // Set vector length for this iteration\n            size_t vl = __riscv_vsetvl_e32m1(n - i);\n            \n            // Load input and weight vectors\n            vfloat32m1_t v_m = __riscv_vle32_v_f32m1(&m[i], vl);\n            vfloat32m1_t v_w = __riscv_vle32_v_f32m1(&w[i], vl);\n            \n            // Fused multiply-add\n            v_sum = __riscv_vfmacc_vv_f32m1(v_sum, v_m, v_w, vl);\n            \n            i += vl;\n        }\n        \n        // Reduce vector sum to scalar\n        vfloat32m1_t v_zero = __riscv_vfmv_v_f_f32m1(0.0f, vlmax);\n        vfloat32m1_t v_reduced = __riscv_vfredusum_vs_f32m1_f32m1(v_sum, v_zero, vlmax);\n        sum += __riscv_vfmv_f_s_f32m1_f32(v_reduced);\n        \n        out_data[p] = sum;\n    }\n}", "model_generated_potentially_faster_code_col_acc": 1, "model_generated_potentially_faster_code_col_time_mean": 0.000163019, "size": 1211279, "is_fallback": false, "debug_output": "[VERIFY] Checksum: 4102.4\n[TIME] Average Execution Time: 0.163019 ms", "candidate_0_time": 0.4032066399988253, "candidate_0_correct": false, "candidate_0_score": -930.7574963862762, "candidate_1_time": 0.00016515199999999998, "candidate_1_correct": true, "candidate_1_score": 0.3184347576571892, "candidate_2_time": 0.4455187799962005, "candidate_2_correct": false, "candidate_2_score": -1028.5037965496101, "candidate_3_time": 0.000163019, "candidate_3_correct": true, "candidate_3_score": 0.32336324358547697, "candidate_4_time": 99999.0, "candidate_4_correct": false, "candidate_4_score": -Infinity, "codebleu": 0.47446706837280367, "codebleu_detail": {"codebleu": 0.47446706837280367, "ngram": 0.23764381416496214, "weighted_ngram": 0.23764381416496214, "syntax": 0.42258064516129035, "dataflow": 1.0}}
{"query_idx": 20002, "query_desc": "eltwise", "code_v0_no_empty_lines": "void eltwise(vector<float*> data_vec, float* out_data, int channels, int size, int op_type, float* alpha) { if (op_type == 1) { for (int q = 0; q < channels; q++) { float* ptr = data_vec[0] + q * size; float* ptr1 = data_vec[1] + q * size; float* outptr = out_data + q * size; for (int i = 0; i < size; i++) { outptr[i] = ptr[i] * alpha[0] + ptr1[i] * alpha[1]; } } } }", "input_time_mean": 0.00276312, "input_acc": 1, "baseline_size": 1211763, "model_generated_potentially_faster_code_col": "#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid eltwise(float** data_vec, float* out_data, int channels, int size, int op_type, float* alpha) {\n    if (op_type == 1) {\n        float alpha0 = alpha[0];\n        float alpha1 = alpha[1];\n        \n        for (int q = 0; q < channels; q++) {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n            \n            size_t vl;\n            for (size_t i = 0; i < size; i += vl) {\n                vl = __riscv_vsetvl_e32m8(size - i);\n                \n                vfloat32m8_t v_ptr = __riscv_vle32_v_f32m8(&ptr[i], vl);\n                vfloat32m8_t v_ptr1 = __riscv_vle32_v_f32m8(&ptr1[i], vl);\n                \n                vfloat32m8_t v_tmp0 = __riscv_vfmul_vf_f32m8(v_ptr, alpha0, vl);\n                vfloat32m8_t v_tmp1 = __riscv_vfmul_vf_f32m8(v_ptr1, alpha1, vl);\n                vfloat32m8_t v_result = __riscv_vfadd_vv_f32m8(v_tmp0, v_tmp1, vl);\n                \n                __riscv_vse32_v_f32m8(&outptr[i], v_result, vl);\n            }\n        }\n    }\n}", "model_generated_potentially_faster_code_col_acc": 1, "model_generated_potentially_faster_code_col_time_mean": 0.00206775, "size": 1211711, "is_fallback": false, "debug_output": "[VERIFY] Checksum: 90315.2\n[TIME] Average Execution Time: 2.06775 ms", "candidate_0_time": 0.00227006, "candidate_0_correct": true, "candidate_0_score": 0.12492312019267199, "candidate_1_time": 0.00206775, "candidate_1_correct": true, "candidate_1_score": 0.17617568975172115, "candidate_2_time": 0.00219905, "candidate_2_correct": true, "candidate_2_score": 0.14291751836836522, "candidate_3_time": 0.00212156, "candidate_3_correct": true, "candidate_3_score": 0.16254363613117626, "candidate_4_time": 0.00214411, "candidate_4_correct": true, "candidate_4_score": 0.15683089111829232, "codebleu": 0.6245724060031969, "codebleu_detail": {"codebleu": 0.6245724060031969, "ngram": 0.47583291490028434, "weighted_ngram": 0.47583291490028434, "syntax": 0.5466237942122186, "dataflow": 1.0}}
