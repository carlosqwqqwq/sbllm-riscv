{"query_idx": 10001, "query_desc": "memcpy", "code_v0_no_empty_lines": "void memcpy_scalar(void* dest, const void* src, size_t n) { char* d = (char*)dest; const char* s = (const char*)src; while (n--) *d++ = *s++; }", "input_time_mean": 0.0005691100000000001, "input_acc": 1, "baseline_size": 1210859, "model_generated_potentially_faster_code_col": "#include <stdint.h>\n#include <stddef.h>\n\n// Optimized memcpy for RISC-V with word-sized copies and optional vectorization\nvoid memcpy_opt(void* restrict dest, const void* restrict src, size_t n) {\n    uint8_t* d = (uint8_t*)dest;\n    const uint8_t* s = (const uint8_t*)src;\n\n    // Handle small copies branchlessly\n    if (n <= 8) {\n        if (n & 0x4) { *(uint32_t*)d = *(uint32_t*)s; d += 4; s += 4; }\n        if (n & 0x2) { *(uint16_t*)d = *(uint16_t*)s; d += 2; s += 2; }\n        if (n & 0x1) { *d = *s; }\n        return;\n    }\n\n    // Align destination to 8 bytes\n    size_t align = (uintptr_t)d & 0x7;\n    if (align) {\n        align = 8 - align;\n        n -= align;\n        while (align--) *d++ = *s++;\n    }\n\n    // Word copy using 64-bit operations\n    size_t words = n >> 3;\n    uint64_t* d64 = (uint64_t*)d;\n    const uint64_t* s64 = (const uint64_t*)s;\n    \n    // Unrolled loop for better pipeline utilization\n    while (words >= 4) {\n        *d64++ = *s64++;\n        *d64++ = *s64++;\n        *d64++ = *s64++;\n        *d64++ = *s64++;\n        words -= 4;\n    }\n    \n    // Remaining words\n    while (words--) {\n        *d64++ = *s64++;\n    }\n\n    // Tail bytes\n    size_t tail = n & 0x7;\n    d = (uint8_t*)d64;\n    s = (const uint8_t*)s64;\n    if (tail & 0x4) { *(uint32_t*)d = *(uint32_t*)s; d += 4; s += 4; }\n    if (tail & 0x2) { *(uint16_t*)d = *(uint16_t*)s; d += 2; s += 2; }\n    if (tail & 0x1) { *d = *s; }\n}\n\n// Vectorized version for RISC-V with V extension\n#ifdef __riscv_v\n\n#include <riscv_vector.h>\n\nvoid memcpy_vector(void* restrict dest, const void* restrict src, size_t n) {\n    size_t vl;\n    uint8_t* d = (uint8_t*)dest;\n    const uint8_t* s = (const uint8_t*)src;\n    \n    // Use maximum vector length (m8) for best throughput\n    for (; n > 0; n -= vl) {\n        vl = __riscv_vsetvl_e8m8(n);\n        vint8m8_t v = __riscv_vle8_v_i8m8(s, vl);\n        __riscv_vse8_v_i8m8(d, v, vl);\n        s += vl;\n        d += vl;\n    }\n}\n\n#endif", "model_generated_potentially_faster_code_col_acc": 1, "model_generated_potentially_faster_code_col_time_mean": 3.9399999999999995e-06, "size": 1211315, "is_fallback": false, "debug_output": "[VERIFY] Checksum: 1.11411e+07\n[TIME] Average Execution Time: 0.00394 ms", "candidate_0_time": 0.00057889, "candidate_0_correct": true, "candidate_0_score": -0.012121474895680218, "candidate_1_time": 3.9399999999999995e-06, "candidate_1_correct": true, "candidate_1_score": 0.6950408590459316, "candidate_2_time": 0.00058357, "candidate_2_correct": true, "candidate_2_score": -0.017897651951566673, "candidate_3_time": 4.69e-06, "candidate_3_correct": true, "candidate_3_score": 0.6941114288066169, "candidate_4_time": 99999.0, "candidate_4_correct": false, "candidate_4_score": -Infinity, "codebleu": 0.2889373343108195, "codebleu_detail": {"codebleu": 0.2889373343108195, "ngram": 0.023317185858892593, "weighted_ngram": 0.02301386883590912, "syntax": 0.10941828254847645, "dataflow": 1.0}}
