{"id": "test_vec_1", "idx": 20001, "query": "void absval(float* data, int channels, int size) { for (int q = 0; q < channels; q++) { float* ptr = data + q * size; for (int i = 0; i < size; i++) { if (ptr[i] < 0) ptr[i] = -ptr[i]; } } }", "code_v0_no_empty_lines": "void absval(float* data, int channels, int size) { for (int q = 0; q < channels; q++) { float* ptr = data + q * size; for (int i = 0; i < size; i++) { if (ptr[i] < 0) ptr[i] = -ptr[i]; } } }", "lang": "cpp", "benchmark_name": "absval", "filename": "absval.cpp", "prediction": ["```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid absval(float* data, int channels, int size) {\n    // Set vector length based on maximum available LMUL=8\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    \n    for (int q = 0; q < channels; q++) {\n        float* ptr = data + q * size;\n        int i = 0;\n        \n        // Process using RVV vector instructions\n        for (; i < size; i += vlmax) {\n            vlmax = __riscv_vsetvl_e32m8(size - i);\n            \n            // Load vector of floats\n            vfloat32m8_t vec = __riscv_vle32_v_f32m8(ptr + i, vlmax);\n            \n            // Compute absolute value: vfsgnjx.vv vd, vs2, vs2\n            vec = __riscv_vfsgnjx_vv_f32m8(vec, vec, vlmax);\n            \n            // Store back to memory\n            __riscv_vse32_v_f32m8(ptr + i, vec, vlmax);\n        }\n    }\n}\n```", "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid absval_optimized(float* data, int channels, int size) {\n    // Determine maximum vector length for float32\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    \n    for (int q = 0; q < channels; q++) {\n        float* ptr = data + q * size;\n        int processed = 0;\n        \n        // Vectorized processing\n        while (processed < size) {\n            // Set actual vector length for this iteration\n            size_t vl = __riscv_vsetvl_e32m8(size - processed);\n            \n            // Load vector data\n            vfloat32m8_t vec_data = __riscv_vle32_v_f32m8(ptr + processed, vl);\n            \n            // Compute absolute value using vfsgnjx.vv\n            vfloat32m8_t abs_data = __riscv_vfsgnjx_vv_f32m8(vec_data, vec_data, vl);\n            \n            // Store result back\n            __riscv_vse32_v_f32m8(ptr + processed, abs_data, vl);\n            \n            processed += vl;\n        }\n    }\n}\n```", "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid absval_optimized(float* data, int channels, int size) {\n    // Process each channel\n    for (int q = 0; q < channels; q++) {\n        float* ptr = data + q * size;\n        \n        // Get available vector length for this size\n        size_t vl = __riscv_vsetvl_e32m8(size);\n        \n        // Vectorized processing\n        for (int i = 0; i < size; i += vl) {\n            vl = __riscv_vsetvl_e32m8(size - i);\n            \n            // Load vector of floats\n            vfloat32m8_t vec = __riscv_vle32_v_f32m8(ptr + i, vl);\n            \n            // Compute absolute value using vfsgnjx.vv\n            vec = __riscv_vfsgnjx_vv_f32m8(vec, vec, vl);\n            \n            // Store back to memory\n            __riscv_vse32_v_f32m8(ptr + i, vec, vl);\n        }\n    }\n}\n```", "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid absval(float* data, int channels, int size) {\n    // Process each channel\n    for (int q = 0; q < channels; q++) {\n        float* ptr = data + q * size;\n        int i = 0;\n        \n        // Vectorized processing using RVV\n        size_t vl;\n        for (; i < size; i += vl) {\n            // Set vector length for remaining elements\n            vl = __riscv_vsetvl_e32m8(size - i);\n            \n            // Load vector of floats\n            vfloat32m8_t v_data = __riscv_vle32_v_f32m8(ptr + i, vl);\n            \n            // Compute absolute value: vfsgnjx.vv vd, vs2, vs2\n            vfloat32m8_t v_abs = __riscv_vfsgnjx_vv_f32m8(v_data, v_data, vl);\n            \n            // Store result back\n            __riscv_vse32_v_f32m8(ptr + i, v_abs, vl);\n        }\n    }\n}\n```", "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid absval_optimized(float* data, int channels, int size) {\n    // Process using RISC-V Vector Extension (RVV 1.0)\n    for (int q = 0; q < channels; q++) {\n        float* ptr = data + q * size;\n        \n        // Set initial vector length\n        size_t vl = __riscv_vsetvl_e32m8(size);\n        \n        for (int i = 0; i < size; i += vl) {\n            // Update vector length for remaining elements\n            vl = __riscv_vsetvl_e32m8(size - i);\n            \n            // Load vector elements\n            vfloat32m8_t vec = __riscv_vle32_v_f32m8(ptr + i, vl);\n            \n            // Compute absolute value using vfsgnjx.vv (vector floating-point sign injection)\n            // vfsgnjx.vv vd, vs2, vs1: vd[i] = copysign(vs2[i], vs1[i]) * vs2[i]\n            // For absolute: vd = fsgnjx(vs2, vs2) = |vs2|\n            vec = __riscv_vfsgnjx_vv_f32m8(vec, vec, vl);\n            \n            // Store back to memory\n            __riscv_vse32_v_f32m8(ptr + i, vec, vl);\n        }\n    }\n}\n```"], "detailed_prediction": [{"message": {"content": "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid absval(float* data, int channels, int size) {\n    // Set vector length based on maximum available LMUL=8\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    \n    for (int q = 0; q < channels; q++) {\n        float* ptr = data + q * size;\n        int i = 0;\n        \n        // Process using RVV vector instructions\n        for (; i < size; i += vlmax) {\n            vlmax = __riscv_vsetvl_e32m8(size - i);\n            \n            // Load vector of floats\n            vfloat32m8_t vec = __riscv_vle32_v_f32m8(ptr + i, vlmax);\n            \n            // Compute absolute value: vfsgnjx.vv vd, vs2, vs2\n            vec = __riscv_vfsgnjx_vv_f32m8(vec, vec, vlmax);\n            \n            // Store back to memory\n            __riscv_vse32_v_f32m8(ptr + i, vec, vlmax);\n        }\n    }\n}\n```"}}, {"message": {"content": "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid absval_optimized(float* data, int channels, int size) {\n    // Determine maximum vector length for float32\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    \n    for (int q = 0; q < channels; q++) {\n        float* ptr = data + q * size;\n        int processed = 0;\n        \n        // Vectorized processing\n        while (processed < size) {\n            // Set actual vector length for this iteration\n            size_t vl = __riscv_vsetvl_e32m8(size - processed);\n            \n            // Load vector data\n            vfloat32m8_t vec_data = __riscv_vle32_v_f32m8(ptr + processed, vl);\n            \n            // Compute absolute value using vfsgnjx.vv\n            vfloat32m8_t abs_data = __riscv_vfsgnjx_vv_f32m8(vec_data, vec_data, vl);\n            \n            // Store result back\n            __riscv_vse32_v_f32m8(ptr + processed, abs_data, vl);\n            \n            processed += vl;\n        }\n    }\n}\n```"}}, {"message": {"content": "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid absval_optimized(float* data, int channels, int size) {\n    // Process each channel\n    for (int q = 0; q < channels; q++) {\n        float* ptr = data + q * size;\n        \n        // Get available vector length for this size\n        size_t vl = __riscv_vsetvl_e32m8(size);\n        \n        // Vectorized processing\n        for (int i = 0; i < size; i += vl) {\n            vl = __riscv_vsetvl_e32m8(size - i);\n            \n            // Load vector of floats\n            vfloat32m8_t vec = __riscv_vle32_v_f32m8(ptr + i, vl);\n            \n            // Compute absolute value using vfsgnjx.vv\n            vec = __riscv_vfsgnjx_vv_f32m8(vec, vec, vl);\n            \n            // Store back to memory\n            __riscv_vse32_v_f32m8(ptr + i, vec, vl);\n        }\n    }\n}\n```"}}, {"message": {"content": "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid absval(float* data, int channels, int size) {\n    // Process each channel\n    for (int q = 0; q < channels; q++) {\n        float* ptr = data + q * size;\n        int i = 0;\n        \n        // Vectorized processing using RVV\n        size_t vl;\n        for (; i < size; i += vl) {\n            // Set vector length for remaining elements\n            vl = __riscv_vsetvl_e32m8(size - i);\n            \n            // Load vector of floats\n            vfloat32m8_t v_data = __riscv_vle32_v_f32m8(ptr + i, vl);\n            \n            // Compute absolute value: vfsgnjx.vv vd, vs2, vs2\n            vfloat32m8_t v_abs = __riscv_vfsgnjx_vv_f32m8(v_data, v_data, vl);\n            \n            // Store result back\n            __riscv_vse32_v_f32m8(ptr + i, v_abs, vl);\n        }\n    }\n}\n```"}}, {"message": {"content": "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid absval_optimized(float* data, int channels, int size) {\n    // Process using RISC-V Vector Extension (RVV 1.0)\n    for (int q = 0; q < channels; q++) {\n        float* ptr = data + q * size;\n        \n        // Set initial vector length\n        size_t vl = __riscv_vsetvl_e32m8(size);\n        \n        for (int i = 0; i < size; i += vl) {\n            // Update vector length for remaining elements\n            vl = __riscv_vsetvl_e32m8(size - i);\n            \n            // Load vector elements\n            vfloat32m8_t vec = __riscv_vle32_v_f32m8(ptr + i, vl);\n            \n            // Compute absolute value using vfsgnjx.vv (vector floating-point sign injection)\n            // vfsgnjx.vv vd, vs2, vs1: vd[i] = copysign(vs2[i], vs1[i]) * vs2[i]\n            // For absolute: vd = fsgnjx(vs2, vs2) = |vs2|\n            vec = __riscv_vfsgnjx_vv_f32m8(vec, vec, vl);\n            \n            // Store back to memory\n            __riscv_vse32_v_f32m8(ptr + i, vec, vl);\n        }\n    }\n}\n```"}}]}
{"id": "test_vec_2", "idx": 20002, "query": "void eltwise(vector<float*> data_vec, float* out_data, int channels, int size, int op_type, float* alpha) { if (op_type == 1) { for (int q = 0; q < channels; q++) { float* ptr = data_vec[0] + q * size; float* ptr1 = data_vec[1] + q * size; float* outptr = out_data + q * size; for (int i = 0; i < size; i++) { outptr[i] = ptr[i] * alpha[0] + ptr1[i] * alpha[1]; } } } }", "code_v0_no_empty_lines": "void eltwise(vector<float*> data_vec, float* out_data, int channels, int size, int op_type, float* alpha) { if (op_type == 1) { for (int q = 0; q < channels; q++) { float* ptr = data_vec[0] + q * size; float* ptr1 = data_vec[1] + q * size; float* outptr = out_data + q * size; for (int i = 0; i < size; i++) { outptr[i] = ptr[i] * alpha[0] + ptr1[i] * alpha[1]; } } } }", "lang": "cpp", "benchmark_name": "eltwise", "filename": "eltwise.cpp", "prediction": ["```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid eltwise(float** data_vec, float* out_data, int channels, int size, int op_type, float* alpha) {\n    if (op_type == 1) {\n        float alpha0 = alpha[0];\n        float alpha1 = alpha[1];\n        \n        for (int q = 0; q < channels; q++) {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n            \n            size_t vl;\n            for (size_t i = 0; i < size; i += vl) {\n                vl = __riscv_vsetvl_e32m8(size - i);\n                \n                vfloat32m8_t v_ptr = __riscv_vle32_v_f32m8(&ptr[i], vl);\n                vfloat32m8_t v_ptr1 = __riscv_vle32_v_f32m8(&ptr1[i], vl);\n                \n                vfloat32m8_t v_tmp0 = __riscv_vfmul_vf_f32m8(v_ptr, alpha0, vl);\n                vfloat32m8_t v_tmp1 = __riscv_vfmul_vf_f32m8(v_ptr1, alpha1, vl);\n                vfloat32m8_t v_result = __riscv_vfadd_vv_f32m8(v_tmp0, v_tmp1, vl);\n                \n                __riscv_vse32_v_f32m8(&outptr[i], v_result, vl);\n            }\n        }\n    }\n}\n```", "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid eltwise(float** data_vec, float* out_data, int channels, int size, int op_type, float* alpha) {\n    if (op_type == 1) {\n        float alpha0 = alpha[0];\n        float alpha1 = alpha[1];\n        \n        for (int q = 0; q < channels; q++) {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n            \n            size_t vl;\n            for (size_t i = 0; i < size; i += vl) {\n                vl = __riscv_vsetvl_e32m8(size - i);\n                \n                vfloat32m8_t v_ptr = __riscv_vle32_v_f32m8(&ptr[i], vl);\n                vfloat32m8_t v_ptr1 = __riscv_vle32_v_f32m8(&ptr1[i], vl);\n                \n                vfloat32m8_t v_tmp0 = __riscv_vfmul_vf_f32m8(v_ptr, alpha0, vl);\n                vfloat32m8_t v_tmp1 = __riscv_vfmul_vf_f32m8(v_ptr1, alpha1, vl);\n                vfloat32m8_t v_result = __riscv_vfadd_vv_f32m8(v_tmp0, v_tmp1, vl);\n                \n                __riscv_vse32_v_f32m8(&outptr[i], v_result, vl);\n            }\n        }\n    }\n}\n```", "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid eltwise(float** data_vec, float* out_data, int channels, int size, int op_type, float* alpha) {\n    if (op_type == 1) {\n        // Broadcast alpha values to scalar registers for reuse\n        float alpha0 = alpha[0];\n        float alpha1 = alpha[1];\n        \n        for (int q = 0; q < channels; q++) {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n            \n            size_t vl;\n            for (size_t i = 0; i < size; i += vl) {\n                // Dynamically set vector length based on remaining elements\n                vl = __riscv_vsetvl_e32m4(size - i);\n                \n                // Load input vectors\n                vfloat32m4_t v_ptr = __riscv_vle32_v_f32m4(&ptr[i], vl);\n                vfloat32m4_t v_ptr1 = __riscv_vle32_v_f32m4(&ptr1[i], vl);\n                \n                // Perform fused multiply-add: out = ptr * alpha0 + ptr1 * alpha1\n                vfloat32m4_t v_tmp = __riscv_vfmul_vf_f32m4(v_ptr, alpha0, vl);\n                vfloat32m4_t v_result = __riscv_vfmacc_vf_f32m4(v_tmp, alpha1, v_ptr1, vl);\n                \n                // Store result\n                __riscv_vse32_v_f32m4(&outptr[i], v_result, vl);\n            }\n        }\n    }\n    // Handle other op_type values if needed\n}\n```", "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid eltwise(float** data_vec, float* out_data, int channels, int size, int op_type, float* alpha) {\n    if (op_type == 1) {\n        float alpha0 = alpha[0];\n        float alpha1 = alpha[1];\n        \n        for (int q = 0; q < channels; q++) {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n            \n            size_t vl;\n            for (size_t i = 0; i < size; i += vl) {\n                vl = __riscv_vsetvl_e32m8(size - i);\n                \n                vfloat32m8_t v_ptr = __riscv_vle32_v_f32m8(&ptr[i], vl);\n                vfloat32m8_t v_ptr1 = __riscv_vle32_v_f32m8(&ptr1[i], vl);\n                \n                vfloat32m8_t v_tmp0 = __riscv_vfmul_vf_f32m8(v_ptr, alpha0, vl);\n                vfloat32m8_t v_tmp1 = __riscv_vfmul_vf_f32m8(v_ptr1, alpha1, vl);\n                vfloat32m8_t v_result = __riscv_vfadd_vv_f32m8(v_tmp0, v_tmp1, vl);\n                \n                __riscv_vse32_v_f32m8(&outptr[i], v_result, vl);\n            }\n        }\n    }\n}\n```", "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid eltwise(float** data_vec, float* out_data, int channels, int size, int op_type, float* alpha) {\n    if (op_type == 1) {\n        float alpha0 = alpha[0];\n        float alpha1 = alpha[1];\n        \n        for (int q = 0; q < channels; q++) {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n            \n            size_t vl;\n            for (size_t i = 0; i < size; i += vl) {\n                vl = __riscv_vsetvl_e32m4(size - i);\n                \n                vfloat32m4_t v_ptr = __riscv_vle32_v_f32m4(&ptr[i], vl);\n                vfloat32m4_t v_ptr1 = __riscv_vle32_v_f32m4(&ptr1[i], vl);\n                \n                vfloat32m4_t v_tmp0 = __riscv_vfmul_vf_f32m4(v_ptr, alpha0, vl);\n                vfloat32m4_t v_tmp1 = __riscv_vfmul_vf_f32m4(v_ptr1, alpha1, vl);\n                vfloat32m4_t v_result = __riscv_vfadd_vv_f32m4(v_tmp0, v_tmp1, vl);\n                \n                __riscv_vse32_v_f32m4(&outptr[i], v_result, vl);\n            }\n        }\n    }\n}\n```"], "detailed_prediction": [{"message": {"content": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid eltwise(float** data_vec, float* out_data, int channels, int size, int op_type, float* alpha) {\n    if (op_type == 1) {\n        float alpha0 = alpha[0];\n        float alpha1 = alpha[1];\n        \n        for (int q = 0; q < channels; q++) {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n            \n            size_t vl;\n            for (size_t i = 0; i < size; i += vl) {\n                vl = __riscv_vsetvl_e32m8(size - i);\n                \n                vfloat32m8_t v_ptr = __riscv_vle32_v_f32m8(&ptr[i], vl);\n                vfloat32m8_t v_ptr1 = __riscv_vle32_v_f32m8(&ptr1[i], vl);\n                \n                vfloat32m8_t v_tmp0 = __riscv_vfmul_vf_f32m8(v_ptr, alpha0, vl);\n                vfloat32m8_t v_tmp1 = __riscv_vfmul_vf_f32m8(v_ptr1, alpha1, vl);\n                vfloat32m8_t v_result = __riscv_vfadd_vv_f32m8(v_tmp0, v_tmp1, vl);\n                \n                __riscv_vse32_v_f32m8(&outptr[i], v_result, vl);\n            }\n        }\n    }\n}\n```"}}, {"message": {"content": "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid eltwise(float** data_vec, float* out_data, int channels, int size, int op_type, float* alpha) {\n    if (op_type == 1) {\n        float alpha0 = alpha[0];\n        float alpha1 = alpha[1];\n        \n        for (int q = 0; q < channels; q++) {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n            \n            size_t vl;\n            for (size_t i = 0; i < size; i += vl) {\n                vl = __riscv_vsetvl_e32m8(size - i);\n                \n                vfloat32m8_t v_ptr = __riscv_vle32_v_f32m8(&ptr[i], vl);\n                vfloat32m8_t v_ptr1 = __riscv_vle32_v_f32m8(&ptr1[i], vl);\n                \n                vfloat32m8_t v_tmp0 = __riscv_vfmul_vf_f32m8(v_ptr, alpha0, vl);\n                vfloat32m8_t v_tmp1 = __riscv_vfmul_vf_f32m8(v_ptr1, alpha1, vl);\n                vfloat32m8_t v_result = __riscv_vfadd_vv_f32m8(v_tmp0, v_tmp1, vl);\n                \n                __riscv_vse32_v_f32m8(&outptr[i], v_result, vl);\n            }\n        }\n    }\n}\n```"}}, {"message": {"content": "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid eltwise(float** data_vec, float* out_data, int channels, int size, int op_type, float* alpha) {\n    if (op_type == 1) {\n        // Broadcast alpha values to scalar registers for reuse\n        float alpha0 = alpha[0];\n        float alpha1 = alpha[1];\n        \n        for (int q = 0; q < channels; q++) {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n            \n            size_t vl;\n            for (size_t i = 0; i < size; i += vl) {\n                // Dynamically set vector length based on remaining elements\n                vl = __riscv_vsetvl_e32m4(size - i);\n                \n                // Load input vectors\n                vfloat32m4_t v_ptr = __riscv_vle32_v_f32m4(&ptr[i], vl);\n                vfloat32m4_t v_ptr1 = __riscv_vle32_v_f32m4(&ptr1[i], vl);\n                \n                // Perform fused multiply-add: out = ptr * alpha0 + ptr1 * alpha1\n                vfloat32m4_t v_tmp = __riscv_vfmul_vf_f32m4(v_ptr, alpha0, vl);\n                vfloat32m4_t v_result = __riscv_vfmacc_vf_f32m4(v_tmp, alpha1, v_ptr1, vl);\n                \n                // Store result\n                __riscv_vse32_v_f32m4(&outptr[i], v_result, vl);\n            }\n        }\n    }\n    // Handle other op_type values if needed\n}\n```"}}, {"message": {"content": "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid eltwise(float** data_vec, float* out_data, int channels, int size, int op_type, float* alpha) {\n    if (op_type == 1) {\n        float alpha0 = alpha[0];\n        float alpha1 = alpha[1];\n        \n        for (int q = 0; q < channels; q++) {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n            \n            size_t vl;\n            for (size_t i = 0; i < size; i += vl) {\n                vl = __riscv_vsetvl_e32m8(size - i);\n                \n                vfloat32m8_t v_ptr = __riscv_vle32_v_f32m8(&ptr[i], vl);\n                vfloat32m8_t v_ptr1 = __riscv_vle32_v_f32m8(&ptr1[i], vl);\n                \n                vfloat32m8_t v_tmp0 = __riscv_vfmul_vf_f32m8(v_ptr, alpha0, vl);\n                vfloat32m8_t v_tmp1 = __riscv_vfmul_vf_f32m8(v_ptr1, alpha1, vl);\n                vfloat32m8_t v_result = __riscv_vfadd_vv_f32m8(v_tmp0, v_tmp1, vl);\n                \n                __riscv_vse32_v_f32m8(&outptr[i], v_result, vl);\n            }\n        }\n    }\n}\n```"}}, {"message": {"content": "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid eltwise(float** data_vec, float* out_data, int channels, int size, int op_type, float* alpha) {\n    if (op_type == 1) {\n        float alpha0 = alpha[0];\n        float alpha1 = alpha[1];\n        \n        for (int q = 0; q < channels; q++) {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n            \n            size_t vl;\n            for (size_t i = 0; i < size; i += vl) {\n                vl = __riscv_vsetvl_e32m4(size - i);\n                \n                vfloat32m4_t v_ptr = __riscv_vle32_v_f32m4(&ptr[i], vl);\n                vfloat32m4_t v_ptr1 = __riscv_vle32_v_f32m4(&ptr1[i], vl);\n                \n                vfloat32m4_t v_tmp0 = __riscv_vfmul_vf_f32m4(v_ptr, alpha0, vl);\n                vfloat32m4_t v_tmp1 = __riscv_vfmul_vf_f32m4(v_ptr1, alpha1, vl);\n                vfloat32m4_t v_result = __riscv_vfadd_vv_f32m4(v_tmp0, v_tmp1, vl);\n                \n                __riscv_vse32_v_f32m4(&outptr[i], v_result, vl);\n            }\n        }\n    }\n}\n```"}}]}
{"id": "test_vec_3", "idx": 20003, "query": "void innerproduct(float* in_data, float* weight_data, float* bias_data, float* out_data, int num_output, int size) { for (int p = 0; p < num_output; p++) { float sum = bias_data[p]; const float* w = (const float*)weight_data + size * p; const float* m = (const float*)in_data; for (int i = 0; i < size; i++) { sum += m[i] * w[i]; } out_data[p] = sum; } }", "code_v0_no_empty_lines": "void innerproduct(float* in_data, float* weight_data, float* bias_data, float* out_data, int num_output, int size) { for (int p = 0; p < num_output; p++) { float sum = bias_data[p]; const float* w = (const float*)weight_data + size * p; const float* m = (const float*)in_data; for (int i = 0; i < size; i++) { sum += m[i] * w[i]; } out_data[p] = sum; } }", "lang": "cpp", "benchmark_name": "innerproduct", "filename": "innerproduct.cpp", "prediction": ["```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid innerproduct(float* __restrict in_data,\n                  float* __restrict weight_data,\n                  float* __restrict bias_data,\n                  float* __restrict out_data,\n                  int num_output,\n                  int size) {\n    for (int p = 0; p < num_output; p++) {\n        float sum = bias_data[p];\n        const float* w = weight_data + size * p;\n        const float* m = in_data;\n        \n        size_t vl;\n        vfloat32m1_t v_sum = vfmv_v_f_f32m1(0.0f, __riscv_vsetvlmax_e32m1());\n        \n        long i = 0;\n        long n = size;\n        while (i < n) {\n            vl = __riscv_vsetvl_e32m1(n - i);\n            vfloat32m1_t v_m = __riscv_vle32_v_f32m1(&m[i], vl);\n            vfloat32m1_t v_w = __riscv_vle32_v_f32m1(&w[i], vl);\n            v_sum = __riscv_vfmacc_vv_f32m1(v_sum, v_m, v_w, vl);\n            i += vl;\n        }\n        \n        vfloat32m1_t v_red = __riscv_vfredusum_vs_f32m1_f32m1(v_sum, v_sum, vl);\n        sum += __riscv_vfmv_f_s_f32m1_f32(v_red);\n        out_data[p] = sum;\n    }\n}\n```", "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid innerproduct(float* __restrict in_data,\n                  float* __restrict weight_data,\n                  float* __restrict bias_data,\n                  float* __restrict out_data,\n                  int num_output,\n                  int size) {\n    // Vectorized version using RVV 1.0 intrinsics\n    for (int p = 0; p < num_output; p++) {\n        float sum = bias_data[p];\n        const float* w = weight_data + size * p;\n        const float* m = in_data;\n        \n        size_t vl;\n        // Set maximum vector length for initialization\n        vfloat32m1_t v_sum = vfmv_v_f_f32m1(0.0, __riscv_vsetvlmax_e32m1());\n        \n        // Main vector loop\n        long i = 0;\n        long n = size;\n        while (i < n) {\n            vl = __riscv_vsetvl_e32m1(n - i);\n            vfloat32m1_t v_m = __riscv_vle32_v_f32m1(&m[i], vl);\n            vfloat32m1_t v_w = __riscv_vle32_v_f32m1(&w[i], vl);\n            v_sum = __riscv_vfmacc_vv_f32m1(v_sum, v_m, v_w, vl);\n            i += vl;\n        }\n        \n        // Reduce vector sum to scalar\n        vfloat32m1_t v_zero = vfmv_v_f_f32m1(0.0, vl);\n        vfloat32m1_t v_red = __riscv_vfredusum_vs_f32m1_f32m1(v_sum, v_zero, vl);\n        sum += __riscv_vfmv_f_s_f32m1_f32(v_red);\n        \n        out_data[p] = sum;\n    }\n}\n```", "```c\n#include <riscv_vector.h>\n\nvoid innerproduct(float* __restrict in_data,\n                  float* __restrict weight_data,\n                  float* __restrict bias_data,\n                  float* __restrict out_data,\n                  int num_output,\n                  int size) {\n    // Pre-calculate maximum vector length for this hardware\n    size_t max_vl = __riscv_vsetvlmax_e32m1();\n    \n    for (int p = 0; p < num_output; p++) {\n        float sum = bias_data[p];\n        const float* w = weight_data + size * p;\n        const float* m = in_data;\n        \n        // Initialize vector accumulator\n        vfloat32m1_t v_sum = __riscv_vfmv_v_f_f32m1(0.0f, max_vl);\n        \n        // Main vectorized inner loop\n        int i = 0;\n        while (i < size) {\n            size_t vl = __riscv_vsetvl_e32m1(size - i);\n            \n            // Load input and weight vectors\n            vfloat32m1_t v_m = __riscv_vle32_v_f32m1(&m[i], vl);\n            vfloat32m1_t v_w = __riscv_vle32_v_f32m1(&w[i], vl);\n            \n            // Fused multiply-accumulate\n            v_sum = __riscv_vfmacc_vv_f32m1(v_sum, v_m, v_w, vl);\n            \n            i += vl;\n        }\n        \n        // Reduce vector accumulator to scalar\n        vfloat32m1_t v_reduced = __riscv_vfredusum_vs_f32m1_f32m1(v_sum, v_sum, max_vl);\n        sum += __riscv_vfmv_f_s_f32m1_f32(v_reduced);\n        \n        out_data[p] = sum;\n    }\n}\n```", "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid innerproduct(float* __restrict in_data,\n                  float* __restrict weight_data,\n                  float* __restrict bias_data,\n                  float* __restrict out_data,\n                  int num_output,\n                  int size) {\n    // Set maximum vector length for initialization\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    \n    for (int p = 0; p < num_output; p++) {\n        float sum = bias_data[p];\n        const float* w = weight_data + size * p;\n        const float* m = in_data;\n        \n        // Vector accumulator\n        vfloat32m1_t v_sum = __riscv_vfmv_v_f_f32m1(0.0f, vlmax);\n        \n        // Main vectorized loop\n        long i = 0;\n        long n = size;\n        while (i < n) {\n            // Set vector length for this iteration\n            size_t vl = __riscv_vsetvl_e32m1(n - i);\n            \n            // Load input and weight vectors\n            vfloat32m1_t v_m = __riscv_vle32_v_f32m1(&m[i], vl);\n            vfloat32m1_t v_w = __riscv_vle32_v_f32m1(&w[i], vl);\n            \n            // Fused multiply-add\n            v_sum = __riscv_vfmacc_vv_f32m1(v_sum, v_m, v_w, vl);\n            \n            i += vl;\n        }\n        \n        // Reduce vector sum to scalar\n        vfloat32m1_t v_zero = __riscv_vfmv_v_f_f32m1(0.0f, vlmax);\n        vfloat32m1_t v_reduced = __riscv_vfredusum_vs_f32m1_f32m1(v_sum, v_zero, vlmax);\n        sum += __riscv_vfmv_f_s_f32m1_f32(v_reduced);\n        \n        out_data[p] = sum;\n    }\n}\n```", "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid innerproduct(float* __restrict in_data,\n                  float* __restrict weight_data,\n                  float* __restrict bias_data,\n                  float* __restrict out_data,\n                  int num_output,\n                  int size) {\n    // Prefetch hint for input data (cache line size assumed 64 bytes)\n    const uintptr_t in_prefetch = (uintptr_t)in_data;\n    asm volatile (\"prefetch.i 0(%0)\" :: \"r\"(in_prefetch));\n    \n    for (int p = 0; p < num_output; p++) {\n        float sum = bias_data[p];\n        const float* w = weight_data + size * p;\n        const float* m = in_data;\n        \n        // Prefetch next weight row\n        if (p + 1 < num_output) {\n            const uintptr_t w_next = (uintptr_t)(weight_data + size * (p + 1));\n            asm volatile (\"prefetch.r 0(%0)\" :: \"r\"(w_next));\n        }\n        \n        // Vectorized inner loop\n        size_t vl;\n        vfloat32m1_t v_sum = vfmv_v_f_f32m1(0.0f, __riscv_vsetvlmax_e32m1());\n        \n        long i = 0;\n        long n = size;\n        while (i < n) {\n            vl = __riscv_vsetvl_e32m1(n - i);\n            vfloat32m1_t v_m = __riscv_vle32_v_f32m1(&m[i], vl);\n            vfloat32m1_t v_w = __riscv_vle32_v_f32m1(&w[i], vl);\n            v_sum = __riscv_vfmacc_vv_f32m1(v_sum, v_m, v_w, vl);\n            i += vl;\n        }\n        \n        // Vector reduction\n        vfloat32m1_t v_red = vfmv_v_f_f32m1(0.0f, __riscv_vsetvlmax_e32m1());\n        v_red = __riscv_vfredusum_vs_f32m1_f32m1(v_sum, v_red, __riscv_vsetvlmax_e32m1());\n        sum += __riscv_vfmv_f_s_f32m1_f32(v_red);\n        \n        out_data[p] = sum;\n    }\n}\n```"], "detailed_prediction": [{"message": {"content": "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid innerproduct(float* __restrict in_data,\n                  float* __restrict weight_data,\n                  float* __restrict bias_data,\n                  float* __restrict out_data,\n                  int num_output,\n                  int size) {\n    for (int p = 0; p < num_output; p++) {\n        float sum = bias_data[p];\n        const float* w = weight_data + size * p;\n        const float* m = in_data;\n        \n        size_t vl;\n        vfloat32m1_t v_sum = vfmv_v_f_f32m1(0.0f, __riscv_vsetvlmax_e32m1());\n        \n        long i = 0;\n        long n = size;\n        while (i < n) {\n            vl = __riscv_vsetvl_e32m1(n - i);\n            vfloat32m1_t v_m = __riscv_vle32_v_f32m1(&m[i], vl);\n            vfloat32m1_t v_w = __riscv_vle32_v_f32m1(&w[i], vl);\n            v_sum = __riscv_vfmacc_vv_f32m1(v_sum, v_m, v_w, vl);\n            i += vl;\n        }\n        \n        vfloat32m1_t v_red = __riscv_vfredusum_vs_f32m1_f32m1(v_sum, v_sum, vl);\n        sum += __riscv_vfmv_f_s_f32m1_f32(v_red);\n        out_data[p] = sum;\n    }\n}\n```"}}, {"message": {"content": "```c\n#include <stdint.h>\n#include <riscv_vector.h>\n\nvoid innerproduct(float* __restrict in_data,\n                  float* __restrict weight_data,\n                  float* __restrict bias_data,\n                  float* __restrict out_data,\n                  int num_output,\n                  int size) {\n    // Vectorized version using RVV 1.0 intrinsics\n    for (int p = 0; p < num_output; p++) {\n        float sum = bias_data[p];\n        const float* w = weight_data + size * p;\n        const float* m = in_data;\n        \n        size_t vl;\n        // Set maximum vector length for initialization\n        vfloat32m1_t v_sum = vfmv_v_f_f32m1(0.0, __riscv_vsetvlmax_e32m1());\n        \n        // Main vector loop\n        long i = 0;\n        long n = size;\n        while (i < n) {\n            vl = __riscv_vsetvl_e32m1(n - i);\n            vfloat32m1_t v_m = __riscv_vle32_v_f32m1(&m[i], vl);\n            vfloat32m1_t v_w = __riscv_vle32_v_f32m1(&w[i], vl);\n            v_sum = __riscv_vfmacc_vv_f32m1(v_sum, v_m, v_w, vl);\n            i += vl;\n        }\n        \n        // Reduce vector sum to scalar\n        vfloat32m1_t v_zero = vfmv_v_f_f32m1(0.0, vl);\n        vfloat32m1_t v_red = __riscv_vfredusum_vs_f32m1_f32m1(v_sum, v_zero, vl);\n        sum += __riscv_vfmv_f_s_f32m1_f32(v_red);\n        \n        out_data[p] = sum;\n    }\n}\n```"}}, {"message": {"content": "```c\n#include <riscv_vector.h>\n\nvoid innerproduct(float* __restrict in_data,\n                  float* __restrict weight_data,\n                  float* __restrict bias_data,\n                  float* __restrict out_data,\n                  int num_output,\n                  int size) {\n    // Pre-calculate maximum vector length for this hardware\n    size_t max_vl = __riscv_vsetvlmax_e32m1();\n    \n    for (int p = 0; p < num_output; p++) {\n        float sum = bias_data[p];\n        const float* w = weight_data + size * p;\n        const float* m = in_data;\n        \n        // Initialize vector accumulator\n        vfloat32m1_t v_sum = __riscv_vfmv_v_f_f32m1(0.0f, max_vl);\n        \n        // Main vectorized inner loop\n        int i = 0;\n        while (i < size) {\n            size_t vl = __riscv_vsetvl_e32m1(size - i);\n            \n            // Load input and weight vectors\n            vfloat32m1_t v_m = __riscv_vle32_v_f32m1(&m[i], vl);\n            vfloat32m1_t v_w = __riscv_vle32_v_f32m1(&w[i], vl);\n            \n            // Fused multiply-accumulate\n            v_sum = __riscv_vfmacc_vv_f32m1(v_sum, v_m, v_w, vl);\n            \n            i += vl;\n        }\n        \n        // Reduce vector accumulator to scalar\n        vfloat32m1_t v_reduced = __riscv_vfredusum_vs_f32m1_f32m1(v_sum, v_sum, max_vl);\n        sum += __riscv_vfmv_f_s_f32m1_f32(v_reduced);\n        \n        out_data[p] = sum;\n    }\n}\n```"}}, {"message": {"content": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid innerproduct(float* __restrict in_data,\n                  float* __restrict weight_data,\n                  float* __restrict bias_data,\n                  float* __restrict out_data,\n                  int num_output,\n                  int size) {\n    // Set maximum vector length for initialization\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    \n    for (int p = 0; p < num_output; p++) {\n        float sum = bias_data[p];\n        const float* w = weight_data + size * p;\n        const float* m = in_data;\n        \n        // Vector accumulator\n        vfloat32m1_t v_sum = __riscv_vfmv_v_f_f32m1(0.0f, vlmax);\n        \n        // Main vectorized loop\n        long i = 0;\n        long n = size;\n        while (i < n) {\n            // Set vector length for this iteration\n            size_t vl = __riscv_vsetvl_e32m1(n - i);\n            \n            // Load input and weight vectors\n            vfloat32m1_t v_m = __riscv_vle32_v_f32m1(&m[i], vl);\n            vfloat32m1_t v_w = __riscv_vle32_v_f32m1(&w[i], vl);\n            \n            // Fused multiply-add\n            v_sum = __riscv_vfmacc_vv_f32m1(v_sum, v_m, v_w, vl);\n            \n            i += vl;\n        }\n        \n        // Reduce vector sum to scalar\n        vfloat32m1_t v_zero = __riscv_vfmv_v_f_f32m1(0.0f, vlmax);\n        vfloat32m1_t v_reduced = __riscv_vfredusum_vs_f32m1_f32m1(v_sum, v_zero, vlmax);\n        sum += __riscv_vfmv_f_s_f32m1_f32(v_reduced);\n        \n        out_data[p] = sum;\n    }\n}\n```"}}, {"message": {"content": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid innerproduct(float* __restrict in_data,\n                  float* __restrict weight_data,\n                  float* __restrict bias_data,\n                  float* __restrict out_data,\n                  int num_output,\n                  int size) {\n    // Prefetch hint for input data (cache line size assumed 64 bytes)\n    const uintptr_t in_prefetch = (uintptr_t)in_data;\n    asm volatile (\"prefetch.i 0(%0)\" :: \"r\"(in_prefetch));\n    \n    for (int p = 0; p < num_output; p++) {\n        float sum = bias_data[p];\n        const float* w = weight_data + size * p;\n        const float* m = in_data;\n        \n        // Prefetch next weight row\n        if (p + 1 < num_output) {\n            const uintptr_t w_next = (uintptr_t)(weight_data + size * (p + 1));\n            asm volatile (\"prefetch.r 0(%0)\" :: \"r\"(w_next));\n        }\n        \n        // Vectorized inner loop\n        size_t vl;\n        vfloat32m1_t v_sum = vfmv_v_f_f32m1(0.0f, __riscv_vsetvlmax_e32m1());\n        \n        long i = 0;\n        long n = size;\n        while (i < n) {\n            vl = __riscv_vsetvl_e32m1(n - i);\n            vfloat32m1_t v_m = __riscv_vle32_v_f32m1(&m[i], vl);\n            vfloat32m1_t v_w = __riscv_vle32_v_f32m1(&w[i], vl);\n            v_sum = __riscv_vfmacc_vv_f32m1(v_sum, v_m, v_w, vl);\n            i += vl;\n        }\n        \n        // Vector reduction\n        vfloat32m1_t v_red = vfmv_v_f_f32m1(0.0f, __riscv_vsetvlmax_e32m1());\n        v_red = __riscv_vfredusum_vs_f32m1_f32m1(v_sum, v_red, __riscv_vsetvlmax_e32m1());\n        sum += __riscv_vfmv_f_s_f32m1_f32(v_red);\n        \n        out_data[p] = sum;\n    }\n}\n```"}}]}
