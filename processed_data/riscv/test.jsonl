{"idx": "1", "id": "1", "query": "// ChaCha20 Quarter Round\n// Optimization: Use Zbb 'rol' for rotation, RVV for vectorization\n#include <stdint.h>\n\nstatic inline uint32_t rotl32(uint32_t x, int n) {\n    return (x << n) | (x >> (32 - n));\n}\n\nvoid chacha20_quarter_round(uint32_t *x, int a, int b, int c, int d) {\n    x[a] += x[b]; x[d] ^= x[a]; x[d] = rotl32(x[d], 16);\n    x[c] += x[d]; x[b] ^= x[c]; x[b] = rotl32(x[b], 12);\n    x[a] += x[b]; x[d] ^= x[a]; x[d] = rotl32(x[d], 8);\n    x[c] += x[d]; x[b] ^= x[c]; x[b] = rotl32(x[b], 7);\n}\n\nvoid chacha20_block(uint32_t *state) {\n    // 10 internal loops (20 rounds)\n    for (int i = 0; i < 10; i++) {\n        chacha20_quarter_round(state, 0, 4, 8, 12);\n        chacha20_quarter_round(state, 1, 5, 9, 13);\n        chacha20_quarter_round(state, 2, 6, 10, 14);\n        chacha20_quarter_round(state, 3, 7, 11, 15);\n        chacha20_quarter_round(state, 0, 5, 10, 15);\n        chacha20_quarter_round(state, 1, 6, 11, 12);\n        chacha20_quarter_round(state, 2, 7, 8, 13);\n        chacha20_quarter_round(state, 3, 4, 9, 14);\n    }\n}\n", "code_v0_no_empty_lines": "// ChaCha20 Quarter Round\n// Optimization: Use Zbb 'rol' for rotation, RVV for vectorization\n#include <stdint.h>\n\nstatic inline uint32_t rotl32(uint32_t x, int n) {\n    return (x << n) | (x >> (32 - n));\n}\n\nvoid chacha20_quarter_round(uint32_t *x, int a, int b, int c, int d) {\n    x[a] += x[b]; x[d] ^= x[a]; x[d] = rotl32(x[d], 16);\n    x[c] += x[d]; x[b] ^= x[c]; x[b] = rotl32(x[b], 12);\n    x[a] += x[b]; x[d] ^= x[a]; x[d] = rotl32(x[d], 8);\n    x[c] += x[d]; x[b] ^= x[c]; x[b] = rotl32(x[b], 7);\n}\n\nvoid chacha20_block(uint32_t *state) {\n    for (int i = 0; i < 10; i++) {\n        chacha20_quarter_round(state, 0, 4, 8, 12);\n        chacha20_quarter_round(state, 1, 5, 9, 13);\n        chacha20_quarter_round(state, 2, 6, 10, 14);\n        chacha20_quarter_round(state, 3, 7, 11, 15);\n        chacha20_quarter_round(state, 0, 5, 10, 15);\n        chacha20_quarter_round(state, 1, 6, 11, 12);\n        chacha20_quarter_round(state, 2, 7, 8, 13);\n        chacha20_quarter_round(state, 3, 4, 9, 14);\n    }\n}\n", "reference": "", "input": "", "description": "ChaCha20 Block: Compute 20 rounds of ChaCha20 cipher. Key optim: Zbb rol, RVV.", "optimization_type": "Instruction Set Optimization"}
{"idx": "2", "id": "2", "query": "// Poly1305 Core Multiply\n// Optimization: Use wide multiply instructions (mulhu) and efficient carry handling\n#include <stdint.h>\n\ntypedef unsigned __int128 uint128_t;\n\nvoid poly1305_process_block(uint64_t *h, uint64_t *r, const uint8_t *msg) {\n    // Load 16 bytes from msg (simplified)\n    uint64_t m0 = ((uint64_t *)msg)[0];\n    uint64_t m1 = ((uint64_t *)msg)[1];\n    \n    // Add m to h\n    uint64_t t0 = h[0] + m0;\n    uint64_t t1 = h[1] + m1 + (t0 < m0);\n    \n    // r0, r1 are halves of r\n    uint64_t r0 = r[0];\n    uint64_t r1 = r[1];\n\n    // partial multiply (h * r)\n    uint128_t d0 = (uint128_t)t0 * r0;\n    uint128_t d1 = (uint128_t)t0 * r1 + (uint128_t)t1 * r0;\n    // Note: This is an incomplete Poly1305 step, focusing on the heavy MUL part for optimization\n\n    // Split results back to u64 for further processing (not shown fully)\n    h[0] = (uint64_t)d0;\n    h[1] = (uint64_t)d1 + (uint64_t)(d0 >> 64);\n}\n", "code_v0_no_empty_lines": "// Poly1305 Core Multiply\n// Optimization: Use wide multiply instructions (mulhu) and efficient carry handling\n#include <stdint.h>\n\ntypedef unsigned __int128 uint128_t;\n\nvoid poly1305_process_block(uint64_t *h, uint64_t *r, const uint8_t *msg) {\n    uint64_t m0 = ((uint64_t *)msg)[0];\n    uint64_t m1 = ((uint64_t *)msg)[1];\n    uint64_t t0 = h[0] + m0;\n    uint64_t t1 = h[1] + m1 + (t0 < m0);\n    uint64_t r0 = r[0];\n    uint64_t r1 = r[1];\n    uint128_t d0 = (uint128_t)t0 * r0;\n    uint128_t d1 = (uint128_t)t0 * r1 + (uint128_t)t1 * r0;\n    h[0] = (uint64_t)d0;\n    h[1] = (uint64_t)d1 + (uint64_t)(d0 >> 64);\n}\n", "reference": "", "input": "", "description": "Poly1305 Multiply: Big integer multiplication. Key optim: wide multiply (mulhu), carry chains.", "optimization_type": "Instruction Set Optimization"}
{"idx": "3", "id": "3", "query": "// Base64 Encoding Loop\n// Optimization: Vector Table Lookup (Gather) using RVV (vrgather)\n#include <stdint.h>\n\nstatic const char base64_chars[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nvoid base64_encode(const uint8_t *src, int len, char *dst) {\n    int i = 0, j = 0;\n    while (i < len - 2) {\n        uint32_t sextet_a = src[i] >> 2;\n        uint32_t sextet_b = ((src[i] & 0x03) << 4) | (src[i + 1] >> 4);\n        uint32_t sextet_c = ((src[i + 1] & 0x0f) << 2) | (src[i + 2] >> 6);\n        uint32_t sextet_d = src[i + 2] & 0x3f;\n\n        dst[j++] = base64_chars[sextet_a];\n        dst[j++] = base64_chars[sextet_b];\n        dst[j++] = base64_chars[sextet_c];\n        dst[j++] = base64_chars[sextet_d];\n        i += 3;\n    }\n}\n", "code_v0_no_empty_lines": "// Base64 Encoding Loop\n// Optimization: Vector Table Lookup (Gather) using RVV (vrgather)\n#include <stdint.h>\n\nstatic const char base64_chars[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nvoid base64_encode(const uint8_t *src, int len, char *dst) {\n    int i = 0, j = 0;\n    while (i < len - 2) {\n        uint32_t sextet_a = src[i] >> 2;\n        uint32_t sextet_b = ((src[i] & 0x03) << 4) | (src[i + 1] >> 4);\n        uint32_t sextet_c = ((src[i + 1] & 0x0f) << 2) | (src[i + 2] >> 6);\n        uint32_t sextet_d = src[i + 2] & 0x3f;\n\n        dst[j++] = base64_chars[sextet_a];\n        dst[j++] = base64_chars[sextet_b];\n        dst[j++] = base64_chars[sextet_c];\n        dst[j++] = base64_chars[sextet_d];\n        i += 3;\n    }\n}\n", "reference": "", "input": "", "description": "Base64 Encoding: Table lookup. Key optim: RVV gather instruction (vrgather).", "optimization_type": "Memory Optimization"}
{"idx": "4", "id": "4", "query": "// String IndexOf (Substring Search)\n// Optimization: Vectorized search (e.g. searching for the first char of target)\n#include <string.h>\n\nint string_index_of(const char *src, int src_len, const char *tgt, int tgt_len) {\n    if (tgt_len == 0) return 0;\n    if (src_len < tgt_len) return -1;\n\n    char first = tgt[0];\n    int max = src_len - tgt_len;\n\n    for (int i = 0; i <= max; i++) {\n        // Look for the first character\n        if (src[i] != first) {\n            while (++i <= max && src[i] != first);\n        }\n\n        // Found first character, check the rest\n        if (i <= max) {\n            int j = i + 1;\n            int end = j + tgt_len - 1;\n            for (int k = 1; j < end && src[j] == tgt[k]; j++, k++);\n\n            if (j == end) {\n                // Found whole string\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n", "code_v0_no_empty_lines": "// String IndexOf (Substring Search)\n// Optimization: Vectorized search (e.g. searching for the first char of target)\n#include <string.h>\n\nint string_index_of(const char *src, int src_len, const char *tgt, int tgt_len) {\n    if (tgt_len == 0) return 0;\n    if (src_len < tgt_len) return -1;\n\n    char first = tgt[0];\n    int max = src_len - tgt_len;\n\n    for (int i = 0; i <= max; i++) {\n        if (src[i] != first) {\n            while (++i <= max && src[i] != first);\n        }\n        if (i <= max) {\n            int j = i + 1;\n            int end = j + tgt_len - 1;\n            for (int k = 1; j < end && src[j] == tgt[k]; j++, k++);\n            if (j == end) return i;\n        }\n    }\n    return -1;\n}\n", "reference": "", "input": "", "description": "String IndexOf: Substring search. Key optim: Vectorized find-first-byte (vfirst/vmseq).", "optimization_type": "Conditional Branch Optimization"}
{"idx": "5", "id": "5", "query": "// Adler32 Checksum\n// Optimization: Vectorized accumulation with delayed modulo reduction\n#include <stdint.h>\n\nuint32_t adler32(uint8_t *buf, int len) {\n    uint32_t s1 = 1;\n    uint32_t s2 = 0;\n    uint32_t MOD_ADLER = 65521;\n\n    for (int i = 0; i < len; ++i) {\n        s1 = (s1 + buf[i]) % MOD_ADLER;\n        s2 = (s2 + s1) % MOD_ADLER;\n    }\n    return (s2 << 16) | s1;\n}\n", "code_v0_no_empty_lines": "// Adler32 Checksum\n// Optimization: Vectorized accumulation with delayed modulo reduction\n#include <stdint.h>\n\nuint32_t adler32(uint8_t *buf, int len) {\n    uint32_t s1 = 1;\n    uint32_t s2 = 0;\n    uint32_t MOD_ADLER = 65521;\n\n    for (int i = 0; i < len; ++i) {\n        s1 = (s1 + buf[i]) % MOD_ADLER;\n        s2 = (s2 + s1) % MOD_ADLER;\n    }\n    return (s2 << 16) | s1;\n}\n", "reference": "", "input": "", "description": "Adler32 Checksum: Serial dependency. Key optim: Loop unrolling & delayed modulo.", "optimization_type": "Instruction Set Optimization"}
