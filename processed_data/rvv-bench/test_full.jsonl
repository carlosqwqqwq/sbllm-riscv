{"idx": 0, "dataset": "rvv-bench", "filename": "ascii_to_utf16.c", "benchmark_name": "ascii_to_utf16", "code_v0_no_empty_lines": "void\nascii_to_utf16_scalar(uint16_t *restrict dest, uint8_t const *restrict src, size_t len)\n{\n\twhile (len--) BENCH_CLOBBER(), *dest++ = *src++;\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 1, "dataset": "rvv-bench", "filename": "ascii_to_utf32.c", "benchmark_name": "ascii_to_utf32", "code_v0_no_empty_lines": "void\nascii_to_utf32_scalar(uint32_t *restrict dest, uint8_t const *restrict src, size_t len)\n{\n\twhile (len--)  BENCH_CLOBBER(), *dest++ = *src++;\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 2, "dataset": "rvv-bench", "filename": "base64_encode.c", "benchmark_name": "base64_encode", "code_v0_no_empty_lines": "#include \"bench.h\"\n\nsize_t\nb64_encode_scalar(uint8_t *dst, const uint8_t *src, size_t length, const uint8_t LUTs[64+16])\n{\n\tuint8_t *dstBeg = dst;\n\tfor (; length >= 3; length -= 3, src += 3, dst += 4) {\n\t\tuint32_t u32 = src[0] << 16 | src[1] << 8 | src[2];\n\t\tdst[0] = LUTs[(u32 >> 18) & 63];\n\t\tdst[1] = LUTs[(u32 >> 12) & 63];\n\t\tdst[2] = LUTs[(u32 >>  6) & 63];\n\t\tdst[3] = LUTs[(u32 >>  0) & 63];\n\t}\n\tif (length > 0) {\n\t\tuint32_t u32 = src[0] << 8 | (length > 1 ? src[1] : 0);\n\t\t*dst++ =              LUTs[(u32 >> 10) & 63];\n\t\t*dst++ =              LUTs[(u32 >>  4) & 63];\n\t\t*dst++ = length > 1 ? LUTs[(u32 <<  2) & 63] : '=';\n\t\t*dst++ =                                       '=';\n\t}\n\treturn dst - dstBeg;\n}\n\nstatic uint8_t base64LUTs[64 + 16] =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\"abcdefghijklmnopqrstuvwxyz\"\n\t\"0123456789\"\n\t\"+/\"\n\t\"\\x47\\xfc\\xfc\\xfc\\xfc\\xfc\\xfc\\xfc\\xfc\\xfc\\xfc\\xed\\xf0\\x41\"\n\t// 'a'-26, 10x '0' - 52, '+' - 62, '/' - 63, 'A'\n;\n\n/* used to prevent GPR spill in vectorized implementations */\nsize_t\nb64_encode_scalar_tail(size_t prefix, uint8_t *dst, const uint8_t *src, size_t length)\n{\n\treturn prefix + b64_encode_scalar(dst, src, length, base64LUTs);\n}\n\n\n#define IMPLS(f) \\\n\tf(scalar) \\\n\tf(rvv_LUT64) f(rvv_LUT16) \\\n\tf(rvv_seg_LUT64) f(rvv_seg_LUT16)\n\ntypedef size_t Func(uint8_t *dst, const uint8_t *src, size_t length, const uint8_t LUTs[64+16]);\n\n#define DECLARE(f) extern Func b64_encode_##f;\nIMPLS(DECLARE)\n\n#define EXTRACT(f) { #f, &b64_encode_##f, 0 },\nImpl impls[] = { IMPLS(EXTRACT) };\n\nuint8_t *dest, *src;\nsize_t last;\n\nvoid init(void) { }\n\nux checksum(size_t n) {\n\tux sum = last;\n\tfor (size_t i = 0; i < last+9; ++i)\n\t\tsum = uhash(sum) + dest[i];\n\treturn sum;\n}\n\nBENCH_BEG(base) {\n\tsrc = mem;\n\tdest = mem + MAX_MEM/3;\n\tmemset(dest, 0, n*2+9);\n\tTIME last = f(dest, src, n, base64LUTs);\n} BENCH_END\n\nBench benches[] = {\n\tBENCH( impls, MAX_MEM/3, \"base64 encode\", bench_base ),\n}; BENCH_MAIN(benches)\n\n", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 3, "dataset": "rvv-bench", "filename": "byteswap.c", "benchmark_name": "byteswap", "code_v0_no_empty_lines": "#include \"bench.h\"\n\nvoid\nbyteswap32_scalar(uint32_t *ptr, size_t n)\n{\n\tfor (uint8_t *p = (uint8_t*)ptr; n--; p += 4) {\n\t\tuint8_t p0 = p[0], p1 = p[1], p2 = p[2], p3 = p[3];\n\t\tp[3] = p0; BENCH_CLOBBER();\n\t\tp[2] = p1; BENCH_CLOBBER();\n\t\tp[1] = p2; BENCH_CLOBBER();\n\t\tp[0] = p3; BENCH_CLOBBER();\n\t}\n}\n\nvoid\nbyteswap32_scalar_autovec(uint32_t *ptr, size_t n)\n{\n\tfor (uint8_t *p = (uint8_t*)ptr; n--; p += 4) {\n\t\tuint8_t p0 = p[0], p1 = p[1], p2 = p[2], p3 = p[3];\n\t\tp[3] = p0;\n\t\tp[2] = p1;\n\t\tp[1] = p2;\n\t\tp[0] = p3;\n\t}\n}\n\n#if __riscv_zbb\nvoid\nbyteswap32_SWAR_rev8(uint32_t *ptr, size_t n)\n{\n\twhile (n--) {\n\t\t*ptr = __builtin_bswap32(*ptr);\n\t\t++ptr;\n\t\tBENCH_CLOBBER();\n\t}\n}\n#define REV8(f) f(SWAR_rev8)\n#else\n#define REV8(f)\n#endif\n\n\n/* we don't support these on XTheadVector */\n#ifndef __riscv_vector\n#define IMPLS_RVV(f)\n#else\n#define IMPLS_RVV(f) \\\n\tf(rvv_seg4_m1) \\\n\tf(rvv_seg4_m2) \\\n\tf(rvv_vrgatherei16_m1) \\\n\tf(rvv_vrgatherei16_m2) \\\n\tf(rvv_vrgatherei16_m4) \\\n\tf(rvv_m1_vrgatherei16s_m2) \\\n\tf(rvv_m1_vrgatherei16s_m4) \\\n\tf(rvv_m1_vrgatherei16s_m8)\n#endif\n\n#if __riscv_zvbb\n#define IMPLS_ZVBB(f) MX(f,rvv_vrev8)\n#else\n#define IMPLS_ZVBB(f)\n#endif\n\n\n#define IMPLS(f) \\\n\tf(scalar) \\\n\tf(scalar_autovec) \\\n\tREV8(f) \\\n\tIMPLS_ZVBB(f) \\\n\tIMPLS_RVV(f)\n\ntypedef void Func(uint32_t *ptr, size_t n);\n\n#define DECLARE(f) extern Func byteswap32_##f;\nIMPLS(DECLARE)\n\n#define EXTRACT(f) { #f, &byteswap32_##f, 0 },\nImpl impls[] = { IMPLS(EXTRACT) };\n\nuint32_t *ptr;\n\nvoid init(void) { ptr = (uint32_t*)mem; }\n\nux checksum(size_t n) {\n\tux sum = 0;\n\tfor (size_t i = 0; i < n; ++i)\n\t\tsum = uhash(sum) + ptr[i];\n\treturn sum;\n}\n\nBENCH_BEG(base) {\n\tbench_memrand(ptr, n * sizeof *ptr);\n\tTIME f(ptr, n);\n} BENCH_END\n\nBench benches[] = {\n\tBENCH( impls, MAX_MEM/4, \"byteswap32\", bench_base )\n}; BENCH_MAIN(benches)\n\n", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 4, "dataset": "rvv-bench", "filename": "chacha20.c", "benchmark_name": "chacha20", "code_v0_no_empty_lines": "#include \"bench.h\"\n#if __riscv_xlen != 32\n#include \"../thirdparty/rvv-chacha-poly/boring.h\"\n\nuint8_t *dest, *src;\nuint8_t key[32], nonce[12];\nuint32_t counter;\n\n\nextern void vector_chacha20(\n\t\tuint8_t *out, const uint8_t *in,\n\t\tsize_t in_len, const uint8_t key[32],\n\t\tconst uint8_t nonce[12], uint32_t counter);\n\nstatic void\nchacha20_boring(void *restrict dest, void const *restrict src, size_t n) {\n\tboring_chacha20(dest, src, n, key, nonce, counter);\n}\n\nstatic void\nchacha20_rvv(void *restrict dest, void const *restrict src, size_t n) {\n\tvector_chacha20(dest, src, n, key, nonce, counter);\n}\n\ntypedef void *Func(void *restrict dest, void const *restrict src, size_t n);\n\nImpl impls[] = {\n\t{ \"boring\", &chacha20_boring, 0 },\n\t{ \"rvv\", &chacha20_rvv, 0 },\n};\n\nvoid init(void) {\n\tbench_memrand(key, sizeof key);\n\tbench_memrand(nonce, sizeof nonce);\n\tcounter = 0;\n}\n\nux checksum(size_t n) {\n\tux sum = 0;\n\tfor (size_t i = 0; i < n+16; ++i)\n\t\tsum = uhash(sum) + mem[i];\n\treturn sum;\n}\n\nBENCH_BEG(aligned) {\n\tmemset(mem, 0, n+16);\n\tTIME f(mem, mem + MAX_MEM/2 + 16, n);\n} BENCH_END\n\nBench benches[] = {\n\tBENCH( impls, MAX_MEM/2 - 16, \"chacha20 aligned\", bench_aligned )\n}; BENCH_MAIN(benches)\n\n\n#include \"../thirdparty/rvv-chacha-poly/boring.c\"\n#else\nvoid init(void) {}\nImpl impls[] = {};\nBench benches[] = {};\nBENCH_MAIN(benches)\n#endif\n", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 5, "dataset": "rvv-bench", "filename": "hist.c", "benchmark_name": "hist", "code_v0_no_empty_lines": "void\nhist_scalar(uint32_t *hist, float *x, float *y, size_t n)\n{\n\tfor (size_t i = 0; i < n; ++i) {\n\t\tfloat dist = x[i]*x[i] + y[i]*y[i];\n\t\t__asm__ (\"fsqrt.s %0, %0\\n\" : \"+f\"(dist));\n\t\tsize_t idx = dist;\n\t\tidx = idx > 100 ? 100 : dist;\n\t\t++hist[idx];\n\t}\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 6, "dataset": "rvv-bench", "filename": "LUT4.c", "benchmark_name": "LUT4", "code_v0_no_empty_lines": "void\nLUT4_scalar(uint8_t lut[16], uint8_t *ptr, size_t n)\n{\n\tfor (; n--; ++ptr)\n\t\t*ptr = lut[*ptr & 0xF], BENCH_CLOBBER();\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 7, "dataset": "rvv-bench", "filename": "LUT6.c", "benchmark_name": "LUT6", "code_v0_no_empty_lines": "void\nLUT6_scalar(uint8_t lut[64], uint8_t *ptr, size_t n)\n{\n\tfor (; n--; ++ptr)\n\t\t*ptr = lut[*ptr & 63], BENCH_CLOBBER();\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 8, "dataset": "rvv-bench", "filename": "mandelbrot.c", "benchmark_name": "mandelbrot", "code_v0_no_empty_lines": "void\nmandelbrot_scalar_f32(size_t width, size_t maxIter, uint32_t *res)\n{\n\tfor (size_t y = 0; y < width; ++y)\n\tfor (size_t x = 0; x < width; ++x) {\n\t\tfloat cx = x * 2.0f / width - 1.5;\n\t\tfloat cy = y * 2.0f / width - 1;\n\t\tsize_t iter = 0;\n\t\tfloat zx = 0, zy = 0, zxS = 0, zyS = 0;\n\n\t\tBENCH_VOLATILE_REG(cy);\n\t\twhile (zxS + zyS <= 4 && iter < maxIter) {\n\t\t\tzxS = zxS - zyS + cx;\n\t\t\tzy = 2 * zx * zy + cy;\n\t\t\tzx = zxS;\n\t\t\tzxS = zx*zx;\n\t\t\tzyS = zy*zy;\n\t\t\t++iter;\n\t\t}\n\t\t*res++ = iter;\n\t}\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 9, "dataset": "rvv-bench", "filename": "memcpy.c", "benchmark_name": "memcpy", "code_v0_no_empty_lines": "#include \"bench.h\"\n\nvoid *\nmemcpy_scalar(void *restrict dest, void const *restrict src, size_t n)\n{\n\tunsigned char *d = dest;\n\tunsigned char const *s = src;\n\twhile (n--) *d++ = *s++, BENCH_CLOBBER();\n\treturn dest;\n}\n\nvoid *\nmemcpy_scalar_autovec(void *restrict dest, void const *restrict src, size_t n)\n{\n\tunsigned char *d = dest;\n\tunsigned char const *s = src;\n\twhile (n--) *d++ = *s++;\n\treturn dest;\n}\n\n/* https://git.musl-libc.org/cgit/musl/tree/src/string/memcpy.c */\nvoid *\nmemcpy_musl(void *restrict dest, void const *restrict src, size_t n)\n{\n\tunsigned char *d = dest;\n\tunsigned char const *s = src;\n\n#ifdef __GNUC__\n\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n#define LS >>\n#define RS <<\n#else\n#define LS <<\n#define RS >>\n#endif\n\n\ttypedef uint32_t __attribute__((__may_alias__)) u32;\n\tuint32_t w, x;\n\n\tfor (; (uintptr_t)s % 4 && n; n--) *d++ = *s++;\n\n\tif ((uintptr_t)d % 4 == 0) {\n\t\tfor (; n>=16; s+=16, d+=16, n-=16) {\n\t\t\t*(u32 *)(d+0) = *(u32 *)(s+0);\n\t\t\t*(u32 *)(d+4) = *(u32 *)(s+4);\n\t\t\t*(u32 *)(d+8) = *(u32 *)(s+8);\n\t\t\t*(u32 *)(d+12) = *(u32 *)(s+12);\n\t\t}\n\t\tif (n&8) {\n\t\t\t*(u32 *)(d+0) = *(u32 *)(s+0);\n\t\t\t*(u32 *)(d+4) = *(u32 *)(s+4);\n\t\t\td += 8; s += 8;\n\t\t}\n\t\tif (n&4) {\n\t\t\t*(u32 *)(d+0) = *(u32 *)(s+0);\n\t\t\td += 4; s += 4;\n\t\t}\n\t\tif (n&2) {\n\t\t\t*d++ = *s++; *d++ = *s++;\n\t\t}\n\t\tif (n&1) {\n\t\t\t*d = *s;\n\t\t}\n\t\treturn dest;\n\t}\n\n\tif (n >= 32) switch ((uintptr_t)d % 4) {\n\tcase 1:\n\t\tw = *(u32 *)s;\n\t\t*d++ = *s++;\n\t\t*d++ = *s++;\n\t\t*d++ = *s++;\n\t\tn -= 3;\n\t\tfor (; n>=17; s+=16, d+=16, n-=16) {\n\t\t\tx = *(u32 *)(s+1);\n\t\t\t*(u32 *)(d+0) = (w LS 24) | (x RS 8);\n\t\t\tw = *(u32 *)(s+5);\n\t\t\t*(u32 *)(d+4) = (x LS 24) | (w RS 8);\n\t\t\tx = *(u32 *)(s+9);\n\t\t\t*(u32 *)(d+8) = (w LS 24) | (x RS 8);\n\t\t\tw = *(u32 *)(s+13);\n\t\t\t*(u32 *)(d+12) = (x LS 24) | (w RS 8);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tw = *(u32 *)s;\n\t\t*d++ = *s++;\n\t\t*d++ = *s++;\n\t\tn -= 2;\n\t\tfor (; n>=18; s+=16, d+=16, n-=16) {\n\t\t\tx = *(u32 *)(s+2);\n\t\t\t*(u32 *)(d+0) = (w LS 16) | (x RS 16);\n\t\t\tw = *(u32 *)(s+6);\n\t\t\t*(u32 *)(d+4) = (x LS 16) | (w RS 16);\n\t\t\tx = *(u32 *)(s+10);\n\t\t\t*(u32 *)(d+8) = (w LS 16) | (x RS 16);\n\t\t\tw = *(u32 *)(s+14);\n\t\t\t*(u32 *)(d+12) = (x LS 16) | (w RS 16);\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tw = *(u32 *)s;\n\t\t*d++ = *s++;\n\t\tn -= 1;\n\t\tfor (; n>=19; s+=16, d+=16, n-=16) {\n\t\t\tx = *(u32 *)(s+3);\n\t\t\t*(u32 *)(d+0) = (w LS 8) | (x RS 24);\n\t\t\tw = *(u32 *)(s+7);\n\t\t\t*(u32 *)(d+4) = (x LS 8) | (w RS 24);\n\t\t\tx = *(u32 *)(s+11);\n\t\t\t*(u32 *)(d+8) = (w LS 8) | (x RS 24);\n\t\t\tw = *(u32 *)(s+15);\n\t\t\t*(u32 *)(d+12) = (x LS 8) | (w RS 24);\n\t\t}\n\t\tbreak;\n\t}\n\tif (n&16) {\n\t\t*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;\n\t\t*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;\n\t\t*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;\n\t\t*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;\n\t}\n\tif (n&8) {\n\t\t*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;\n\t\t*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;\n\t}\n\tif (n&4) {\n\t\t*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;\n\t}\n\tif (n&2) {\n\t\t*d++ = *s++; *d++ = *s++;\n\t}\n\tif (n&1) {\n\t\t*d = *s;\n\t}\n\treturn dest;\n#endif\n\n\twhile (n--) { *d++ = *s++; BENCH_CLOBBER(); }\n\treturn dest;\n}\n\n#define memcpy_libc memcpy\n\n#define IMPLS(f) \\\n\tIFHOSTED(f(libc)) \\\n\tf(musl) \\\n\tf(scalar) \\\n\tf(scalar_autovec) \\\n\tMX(f, rvv) \\\n\tMX(f, rvv_align_dest) \\\n\tMX(f, rvv_align_src) \\\n\tMX(f, rvv_align_dest_hybrid) \\\n\tMX(f, rvv_vlmax) \\\n\tMX(f, rvv_tail) \\\n\tMX(f, rvv_128) \\\n\ntypedef void *Func(void *restrict dest, void const *restrict src, size_t n);\n\n#define DECLARE(f) extern Func memcpy_##f;\nIMPLS(DECLARE)\n\n#define EXTRACT(f) { #f, &memcpy_##f, 0 },\nImpl impls[] = { IMPLS(EXTRACT) };\n\nuint8_t *dest, *src;\nux last;\n\nvoid init(void) { }\n\nux checksum(size_t n) {\n\tux sum = last;\n\tfor (size_t i = 0; i < n+9; ++i)\n\t\tsum = uhash(sum) + dest[i];\n\treturn sum;\n}\n\nvoid common(size_t n, size_t dOff, size_t sOff) {\n\tdest = mem + dOff; src = dest + MAX_MEM/2 + sOff + 9;\n\tmemset(dest, 0, n+9);\n}\n\nBENCH_BEG(base) {\n\tcommon(n, bench_urand() & 255, bench_urand() & 255);\n\tTIME last = (uintptr_t)f(dest, src, n);\n} BENCH_END\n\nBENCH_BEG(aligned) {\n\tcommon(n, 0, 0);\n\tTIME last = (uintptr_t)f(dest, src, n);\n} BENCH_END\n\nBench benches[] = {\n\tBENCH( impls, MAX_MEM/2 - 521, \"memcpy\", bench_base ),\n\tBENCH( impls, MAX_MEM/2 - 521, \"memcpy aligned\", bench_aligned )\n}; BENCH_MAIN(benches)\n\n", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 10, "dataset": "rvv-bench", "filename": "memreverse.c", "benchmark_name": "memreverse", "code_v0_no_empty_lines": "void\nmemreverse_scalar(uint8_t *restrict dest, uint8_t const *restrict src, size_t n)\n{\n\tfor (size_t i = 0; i < n; ++i)\n\t\tdest[i] = src[n-i-1], BENCH_CLOBBER();\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 11, "dataset": "rvv-bench", "filename": "memset.c", "benchmark_name": "memset", "code_v0_no_empty_lines": "#include \"bench.h\"\n\nvoid *\nmemset_scalar(void *dest, int c, size_t n)\n{\n\tunsigned char *d = dest;\n\twhile (n--) *d++ = c, BENCH_CLOBBER();\n\treturn dest;\n}\n\nvoid *\nmemset_scalar_autovec(void *dest, int c, size_t n)\n{\n\tunsigned char *d = dest;\n\twhile (n--) *d++ = c;\n\treturn dest;\n}\n\n/* https://git.musl-libc.org/cgit/musl/tree/src/string/memset.c */\n#if __riscv_xlen != 32\nvoid *\nmemset_musl(void *dest, int c, size_t n)\n{\n\tunsigned char *s = dest;\n\tsize_t k;\n\n\t/* Fill head and tail with minimal branching. Each\n\t * conditional ensures that all the subsequently used\n\t * offsets are well-defined and in the dest region. */\n\n\tif (!n) return dest;\n\ts[0] = c;\n\ts[n-1] = c;\n\tif (n <= 2) return dest;\n\ts[1] = c;\n\ts[2] = c;\n\ts[n-2] = c;\n\ts[n-3] = c;\n\tif (n <= 6) return dest;\n\ts[3] = c;\n\ts[n-4] = c;\n\tif (n <= 8) return dest;\n\n\t/* Advance pointer to align it at a 4-byte boundary,\n\t * and truncate n to a multiple of 4. The previous code\n\t * already took care of any head/tail that get cut off\n\t * by the alignment. */\n\n\tk = -(uintptr_t)s & 3;\n\ts += k;\n\tn -= k;\n\tn &= -4;\n\n#ifdef __GNUC__\n\ttypedef uint32_t __attribute__((__may_alias__)) u32;\n\ttypedef uint64_t __attribute__((__may_alias__)) u64;\n\n\tu32 c32 = ((u32)-1)/255 * (unsigned char)c;\n\n\t/* In preparation to copy 32 bytes at a time, aligned on\n\t * an 8-byte bounary, fill head/tail up to 28 bytes each.\n\t * As in the initial byte-based head/tail fill, each\n\t * conditional below ensures that the subsequent offsets\n\t * are valid (e.g. !(n<=24) implies n>=28). */\n\n\t*(u32 *)(s+0) = c32;\n\t*(u32 *)(s+n-4) = c32;\n\tif (n <= 8) return dest;\n\t*(u32 *)(s+4) = c32;\n\t*(u32 *)(s+8) = c32;\n\t*(u32 *)(s+n-12) = c32;\n\t*(u32 *)(s+n-8) = c32;\n\tif (n <= 24) return dest;\n\t*(u32 *)(s+12) = c32;\n\t*(u32 *)(s+16) = c32;\n\t*(u32 *)(s+20) = c32;\n\t*(u32 *)(s+24) = c32;\n\t*(u32 *)(s+n-28) = c32;\n\t*(u32 *)(s+n-24) = c32;\n\t*(u32 *)(s+n-20) = c32;\n\t*(u32 *)(s+n-16) = c32;\n\n\t/* Align to a multiple of 8 so we can fill 64 bits at a time,\n\t * and avoid writing the same bytes twice as much as is\n\t * practical without introducing additional branching. */\n\n\tk = 24 + ((uintptr_t)s & 4);\n\ts += k;\n\tn -= k;\n\n\t/* If this loop is reached, 28 tail bytes have already been\n\t * filled, so any remainder when n drops below 32 can be\n\t * safely ignored. */\n\n\tu64 c64 = c32 | ((u64)c32 << 32);\n\tfor (; n >= 32; n-=32, s+=32) {\n\t\t*(u64 *)(s+0) = c64;\n\t\t*(u64 *)(s+8) = c64;\n\t\t*(u64 *)(s+16) = c64;\n\t\t*(u64 *)(s+24) = c64;\n\t}\n#else\n\t/* Pure C fallback with no aliasing violations. */\n\twhile (n--) *s++ = c;\n#endif\n\n\treturn dest;\n}\n#endif\n\n#define memset_libc memset\n\n#define IMPLS(f) \\\n\tIFHOSTED(f(libc)) \\\n\tIF64(f(musl)) \\\n\tf(scalar) \\\n\tf(scalar_autovec) \\\n\tMX(f, rvv) \\\n\tMX(f, rvv_align) \\\n\tMX(f, rvv_vlmax) \\\n\tMX(f, rvv_tail) \\\n\tMX(f, rvv_tail_4x) \\\n\ntypedef void *Func(void *dest, int c, size_t n);\n\n#define DECLARE(f) extern Func memset_##f;\nIMPLS(DECLARE)\n\n#define EXTRACT(f) { #f, &memset_##f, 0 },\nImpl impls[] = { IMPLS(EXTRACT) };\n\nuint8_t *dest;\nux last;\nchar c;\n\nvoid init(void) { c = bench_urand(); }\n\nux checksum(size_t n) {\n\tux sum = last;\n\tfor (size_t i = 0; i < n+9; ++i)\n\t\tsum = uhash(sum) + dest[i];\n\treturn sum;\n}\n\nvoid common(size_t n, size_t off) {\n\tdest = mem + off;\n\tmemset(dest, c+3, n+9);\n}\n\nBENCH_BEG(base) {\n\tcommon(n, bench_urand() & 511);\n\tTIME last = (uintptr_t)f(dest, c, n);\n} BENCH_END\n\nBENCH_BEG(aligned) {\n\tcommon(n, 0);\n\tTIME last = (uintptr_t)f(dest, c, n);\n} BENCH_END\n\nBench benches[] = {\n\tBENCH( impls, MAX_MEM - 521, \"memset\", bench_base ),\n\tBENCH( impls, MAX_MEM - 521, \"memset aligned\", bench_aligned )\n}; BENCH_MAIN(benches)\n\n", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 12, "dataset": "rvv-bench", "filename": "mergelines.c", "benchmark_name": "mergelines", "code_v0_no_empty_lines": "#include \"bench.h\"\n\nsize_t\nmergelines_scalar(char *str, size_t len)\n{\n\tchar *dest = str;\n\tchar *src = str;\n\n\twhile (len > 1) {\n\t\tif (src[0] == '\\\\' && src[1] == '\\n')\n\t\t\tsrc += 2, len -= 2;\n\t\telse\n\t\t\t*dest++ = *src++, --len;\n\t\tBENCH_CLOBBER();\n\t}\n\tif (len > 0)\n\t\t*dest++ = *src++;\n\treturn dest - str;\n}\n\n#define IMPLS(f) \\\n\tf(scalar) \\\n\tMX(f, rvv_vslide) \\\n\tMX(f, rvv_vslide_skip) \\\n\tMX(f, rvv_mshift) \\\n\tMX(f, rvv_mshift_skip) \\\n\ntypedef size_t Func(char *buf, size_t len);\n\n#define DECLARE(f) extern Func mergelines_##f;\nIMPLS(DECLARE)\n\n#define EXTRACT(f) { #f, &mergelines_##f, 0 },\nImpl impls[] = { IMPLS(EXTRACT) };\n\nchar *str;\nux last;\n\nvoid init(void) { }\nux checksum(size_t n) { return last; }\n\nvoid common(size_t n, char const *chars, size_t nChars) {\n\tstr = (char*)mem + (bench_urand() & 255);\n\tfor (size_t i = 0; i < n; ++i)\n\t\tstr[i] = chars[bench_urand() % nChars];\n}\n\nBENCH_BEG(2_3) {\n\tcommon(n, \"\\\\\\na\", 3);\n\tTIME last = (uintptr_t)f(str, n);\n} BENCH_END\n\nBENCH_BEG(2_16) {\n\tcommon(n, \"\\\\\\nabcdefgh\", 16);\n\tTIME last = (uintptr_t)f(str, n);\n} BENCH_END\n\nBENCH_BEG(2_32) {\n\tcommon(n, \"\\\\\\nabcdefgh123456789\", 32);\n\tTIME last = (uintptr_t)f(str, n);\n} BENCH_END\n\nBENCH_BEG(2_256) {\n\tstr = (char*)mem + (bench_urand() & 255);\n\tfor (size_t i = 0; i < n; ++i)\n\t\tstr[i] = bench_urand() & 0xff;\n\tTIME last = (uintptr_t)f(str, n);\n} BENCH_END\n\n#define COUNT SCALE_mergelines(MAX_MEM) - 256\nBench benches[] = {\n\tBENCH( impls, COUNT, \"mergelines 2/3\", bench_2_3 ),\n\tBENCH( impls, COUNT, \"mergelines 2/16\", bench_2_16 ),\n\tBENCH( impls, COUNT, \"mergelines 2/32\", bench_2_32 ),\n\tBENCH( impls, COUNT, \"mergelines 2/256\", bench_2_256 )\n}; BENCH_MAIN(benches)\n\n", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 13, "dataset": "rvv-bench", "filename": "poly1305.c", "benchmark_name": "poly1305", "code_v0_no_empty_lines": "#include \"bench.h\"\n#if __riscv_xlen != 32\n#include \"../thirdparty/rvv-chacha-poly/boring.h\"\n\nuint8_t *src;\nuint8_t key[32], sig[16];\n\nextern uint64_t\nvector_poly1305(const uint8_t* in, size_t len,\n                const uint8_t key[32], uint8_t sig[16]);\n\nstatic void\npoly1305_boring(void const *src, size_t n) {\n\tpoly1305_state state;\n\tboring_poly1305_init(&state, key);\n\tboring_poly1305_update(&state, src, n);\n\tboring_poly1305_finish(&state, sig);\n}\n\nstatic void\npoly1305_rvv(void const *src, size_t n) {\n\tvector_poly1305(src, n, key, sig);\n}\n\ntypedef void *Func(void const *src, size_t n);\n\nImpl impls[] = {\n\t{ \"boring\", &poly1305_boring, 0 },\n\tIF_VE64({ \"rvv\", &poly1305_rvv, 0 },)\n};\n\nvoid init(void) {\n\tbench_memrand(key, sizeof key);\n\tbench_memrand(sig, sizeof sig);\n}\n\nux checksum(size_t n) {\n\tux sum = 0;\n\tfor (size_t i = 0; i < ARR_LEN(sig); ++i)\n\t\tsum = uhash(sum) + sig[i];\n\treturn sum;\n}\n\nBENCH_BEG(aligned) {\n\tfor (size_t i = 0; i < 256; ++i)\n\t\tmem[bench_urand()%n] = bench_urand();\n\tn = (15+n) & -16;\n\tTIME f(mem, n);\n} BENCH_END\n\nBench benches[] = {\n\tBENCH( impls, MAX_MEM, \"poly1305 aligned\", bench_aligned )\n}; BENCH_MAIN(benches)\n\n\n#include \"../thirdparty/rvv-chacha-poly/boring.c\"\n#else\nvoid init(void) {}\nImpl impls[] = {};\nBench benches[] = {};\nBENCH_MAIN(benches)\n#endif\n", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 14, "dataset": "rvv-bench", "filename": "strlen.c", "benchmark_name": "strlen", "code_v0_no_empty_lines": "#include \"bench.h\"\n\nsize_t\nstrlen_scalar(char const *s)\n{\n\tchar const *a = s;\n\twhile (*s) ++s, BENCH_CLOBBER();\n\treturn s - a;\n}\n\nsize_t\nstrlen_scalar_autovec(char const *s)\n{\n\tchar const *a = s;\n\twhile (*s) ++s;\n\treturn s - a;\n}\n\n/* https://git.musl-libc.org/cgit/musl/tree/src/string/strlen.c */\n#define ONES ((size_t)-1/UCHAR_MAX)\n#define HIGHS (ONES * (UCHAR_MAX/2+1))\n#define HASZERO(x) (((x)-ONES) & ~(x) & HIGHS)\nsize_t\nstrlen_musl(char const *s)\n{\n\tchar const *a = s;\n#ifdef __GNUC__\n\ttypedef size_t __attribute__((__may_alias__)) word;\n\tword const *w;\n\tfor (; (uintptr_t)s % sizeof *w; s++) if (!*s) return s-a;\n\tfor (w = (void const*)s; !HASZERO(*w); w++);\n\ts = (void const*)w;\n#endif\n\tfor (; *s; s++);\n\treturn s-a;\n}\n\n#define strlen_libc strlen\n\n#define IMPLS(f) \\\n\tf(scalar) \\\n\tf(scalar_autovec) \\\n\tIFHOSTED(f(libc)) \\\n\tf(musl) \\\n\tMX(f, rvv_page_aligned) \\\n\tMX(f, rvv) \\\n\n\ntypedef size_t Func(char const *s);\n\n#define DECLARE(f) extern Func strlen_##f;\nIMPLS(DECLARE)\n\n#define EXTRACT(f) { #f, &strlen_##f, 0 },\nImpl impls[] = { IMPLS(EXTRACT) };\n\nux last;\n\nvoid init(void) {\n\tfor (size_t i = 0; i < MAX_MEM; ++i)\n\t\tmem[i] += !mem[i]; // remove null bytes\n}\n\nux checksum(size_t n) { return last; }\n\nBENCH_BEG(base) {\n\tchar *p = (char*)mem + (bench_urand() % 511);\n\tp[n] = 0;\n\tTIME last = f(p);\n\tp[n] = bench_urand() | 1;\n} BENCH_END\n\nBench benches[] = {\n\tBENCH( impls, MAX_MEM - 521, \"strlen\", bench_base ),\n}; BENCH_MAIN(benches)\n\n", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 15, "dataset": "rvv-bench", "filename": "trans8x8e16.c", "benchmark_name": "trans8x8e16", "code_v0_no_empty_lines": "#include \"bench.h\"\n\n#define IMPLS(f) \\\n\tf(seq_scalar,0) \\\n\tf(seq_scalar_autovec,0) \\\n\tf(zip_rvv_vrgather,0) \\\n\tIF_VF16(f(seq_rvv_vrgather,0)) \\\n\tf(zip_rvv_vslide,0) \\\n\tIF_VF16(f(seq_rvv_vslide,0)) \\\n\tf(seq_rvv_vslide_single,0) \\\n\tf(seq_rvv_vlseg8_single,0) \\\n\tf(seq_rvv_vsseg8_single,0) \\\n\tf(seq_rvv_vls_single,0) \\\n\tf(seq_rvv_vss_single,0) \\\n\tf(zip_rvv_vzip_fake,1) \\\n\tIF_VF16(f(seq_rvv_vzip_fake,1)) \\\n\tf(seq_rvv_vzip_fake_single,1) \\\n\n#define T uint16_t\n#include \"trans8x8.c.inc\"\n\nBench benches[] = {\n\tBENCH( impls, MAX_MEM/4-9-3, \"trans8x8e16\", bench_base ),\n}; BENCH_MAIN(benches)\n", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 16, "dataset": "rvv-bench", "filename": "trans8x8e8.c", "benchmark_name": "trans8x8e8", "code_v0_no_empty_lines": "#include \"bench.h\"\n\n#define IMPLS(f) \\\n\tf(seq_scalar,0) \\\n\tf(seq_scalar_autovec,0) \\\n\tf(zip_rvv_vslide,0) \\\n\tIF_VF16(f(seq_rvv_vslide,0)) \\\n\tf(seq_rvv_vslide_single,0) \\\n\tf(seq_rvv_vlseg8_single,0) \\\n\tf(seq_rvv_vsseg8_single,0) \\\n\tf(seq_rvv_vls_single,0) \\\n\tf(seq_rvv_vss_single,0) \\\n\tf(zip_rvv_vzip_fake,1) \\\n\tIF_VF16(f(seq_rvv_vzip_fake,1)) \\\n\tIF_VF16(f(seq_rvv_vzip_fake_single,1)) \\\n\n#define T uint8_t\n#include \"trans8x8.c.inc\"\n\nBench benches[] = {\n\tBENCH( impls, MAX_MEM/4-9-3, \"trans8x8e8\", bench_base ),\n}; BENCH_MAIN(benches)\n", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
{"idx": 17, "dataset": "rvv-bench", "filename": "utf8_count.c", "benchmark_name": "utf8_count", "code_v0_no_empty_lines": "#include \"bench.h\"\n\nsize_t\nutf8_count_scalar(char const *str, size_t len)\n{\n\tuint8_t const *p = (uint8_t const*)str;\n\tsize_t count = 0;\n\twhile (len--) count += (*p++ & 0xc0) != 0x80, BENCH_CLOBBER();\n\treturn count;\n}\n\nsize_t\nutf8_count_scalar_autovec(char const *str, size_t len)\n{\n\tuint8_t const *p = (uint8_t const*)str;\n\tsize_t count = 0;\n\twhile (len--) count += (*p++ & 0xc0) != 0x80;\n\treturn count;\n}\n\n#define GEN_SWAR(name, popc, clobber)  \\\n\tsize_t \\\n\tutf8_count_##name(char const *str, size_t len) \\\n\t{ \\\n\t\tux const BENCH_MAY_ALIAS *u; \\\n\t\tsize_t count = 0, tail = 0; \\\n\\\n\t\tuint8_t const *u8 = (uint8_t const*)str; \\\n\t\tif (len < sizeof *u) { \\\n\t\t\ttail = len; \\\n\t\t\tgoto skip; \\\n\t\t} \\\n\\\n\t\ttail = sizeof *u - (uintptr_t)str % sizeof *u; \\\n\\\n\t\tlen -= tail; \\\n\t\twhile (tail--) \\\n\t\t\tcount += (*u8++ & 0xC0) != 0x80, clobber; \\\n\\\n\t\tu = (ux const*)u8; \\\n\t\ttail = len % sizeof *u; \\\n\\\n\t\tfor (len /= sizeof *u; len--; ++u) { \\\n\t\t\tux b1 =  ~*u & (ux)0x8080808080808080; \\\n\t\t\tux b2 =  *u & (ux)0x4040404040404040; \\\n\t\t\tcount += popc((b1 >> 1) | b2); \\\n\t\t\tclobber; \\\n\t\t} \\\n\\\n\t\tu8 = (uint8_t const*)u; \\\n\tskip: \\\n\t\twhile (tail--) \\\n\t\t\tcount += (*u8++ & 0xC0) != 0x80, clobber; \\\n\t\treturn count; \\\n\t}\n\n#if __riscv_zbb\nGEN_SWAR(SWAR_popc,__builtin_popcountll,BENCH_CLOBBER())\nGEN_SWAR(SWAR_popc_autovec,__builtin_popcountll,(void)0)\n# define POPC(f) f(SWAR_popc) f(SWAR_popc_autovec)\n#else\n# define POPC(f)\n#endif\n\nstatic inline int\nupopcnt(ux x)\n{\n\t/* 2-bit sums */\n\tx -= (x >> 1) & (-(ux)1/3);\n\t/* 4-bit sums */\n\tx = (x & (-(ux)1/15*3)) + ((x >> 2) & (-(ux)1/15*3));\n\t/* 8-bit sums */\n\tx = (x + (x >> 4)) & (-(ux)1/255*15);\n\tBENCH_CLOBBER();\n\t/* now we can just add the sums together, because can't overflow,\n\t * since there can't be more than 255 bits set */\n\tx += (x >>  8); /* 16-bit sums */\n\tx += (x >> 16); /* sum 16-bit sums */\n\tIF64(x += (x >> 32)); /* sum 32-bit sums */\n\treturn x & 127;\n}\n\n\nGEN_SWAR(SWAR_popc_bithack,upopcnt,BENCH_CLOBBER())\nGEN_SWAR(SWAR_popc_bithack_autovec,upopcnt,(void)0)\n\n\n#define IMPLS(f) \\\n\tf(scalar) \\\n\tf(scalar_autovec) \\\n\tPOPC(f) \\\n\tf(SWAR_popc_bithack) \\\n\tf(SWAR_popc_bithack_autovec) \\\n\tMX(f, rvv) \\\n\tMX(f, rvv_align) \\\n\tMX(f, rvv_vlmax) \\\n\tMX(f, rvv_tail) \\\n\tMX(f, rvv_128) \\\n\tMX(f, rvv_4x) \\\n\tMX(f, rvv_4x_tail) \\\n\ntypedef size_t Func(char const *str, size_t len);\n\n#define DECLARE(f) extern Func utf8_count_##f;\nIMPLS(DECLARE)\n\n#define EXTRACT(f) { #f, &utf8_count_##f, 0 },\nImpl impls[] = { IMPLS(EXTRACT) };\n\nchar *str;\nux last;\n\nvoid init(void) { }\nux checksum(size_t n) { return last; }\n\nvoid common(size_t n, size_t off) {\n\tstr = (char*)mem + off;\n\tbench_memrand(str, n + 9);\n}\n\nBENCH_BEG(base) {\n\tcommon(n, bench_urand() & 511);\n\tTIME last = (uintptr_t)f(str, n);\n} BENCH_END\n\nBENCH_BEG(aligned) {\n\tcommon(n, 0);\n\tTIME last = (uintptr_t)f(str, n);\n} BENCH_END\n\nBench benches[] = {\n\tBENCH( impls, MAX_MEM - 521, \"utf8 count\", bench_base ),\n\tBENCH( impls, MAX_MEM - 521, \"utf8 count aligned\", bench_aligned )\n}; BENCH_MAIN(benches)\n\n\n", "code_v1_no_empty_lines": "", "input": "", "lang": "c"}
