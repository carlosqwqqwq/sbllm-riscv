{"idx": 0, "dataset": "vecintrin", "filename": "absval.cpp", "benchmark_name": "absval", "code_v0_no_empty_lines": "void absval(float* data, int channels, int size) \n{\n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n        for (int i = 0; i < size; i++)\n        {\n            if (ptr[i] < 0)\n                ptr[i] = -ptr[i];\n        }\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 1, "dataset": "vecintrin", "filename": "atan.cpp", "benchmark_name": "atan", "code_v0_no_empty_lines": "#include <cfloat>\n#include <cmath>\n\n#define CV_PI   3.1415926535897932384626433832795\n\nstatic const float atan2_p1 = 0.9997878412794807f*(float)(180/CV_PI);\nstatic const float atan2_p3 = -0.3258083974640975f*(float)(180/CV_PI);\nstatic const float atan2_p5 = 0.1555786518463281f*(float)(180/CV_PI);\nstatic const float atan2_p7 = -0.04432655554792128f*(float)(180/CV_PI);\n\nstatic inline float atan_f32(float y, float x)\n{\n    float ax = std::abs(x), ay = std::abs(y);\n    float a, c, c2;\n    if( ax >= ay )\n    {\n        c = ay/(ax + (float)DBL_EPSILON);\n        c2 = c*c;\n        a = (((atan2_p7*c2 + atan2_p5)*c2 + atan2_p3)*c2 + atan2_p1)*c;\n    }\n    else\n    {\n        c = ax/(ay + (float)DBL_EPSILON);\n        c2 = c*c;\n        a = 90.f - (((atan2_p7*c2 + atan2_p5)*c2 + atan2_p3)*c2 + atan2_p1)*c;\n    }\n    if( x < 0 )\n        a = 180.f - a;\n    if( y < 0 )\n        a = 360.f - a;\n    return a;\n}\n\nvoid fastAtan32f(const float* y, const float* x, float* dst, size_t n, bool angle_in_deg)\n{\n    float scale = angle_in_deg ? 1.f : (float)(CV_PI/180);\n    int i = 0;\n    for( ; i < n; i++ )\n        dst[i] = atan_f32(y[i], x[i])*scale;\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 2, "dataset": "vecintrin", "filename": "batchnorm.cpp", "benchmark_name": "batchnorm", "code_v0_no_empty_lines": "void batchnorm(float* data, float* a_data, float* b_data, int channels, int h, int w)\n{\n    \n    if (channels == 1 && h == 1)\n    {\n        float* ptr = data;\n        for (int i = 0; i < w; i++)\n        {\n            ptr[i] = b_data[i] * ptr[i] + a_data[i];\n        }\n    }\n\n    else if (channels == 1)\n    {\n        for (int i = 0; i < h; i++)\n        {\n            float* ptr = data + i * w;\n            float a = a_data[i];\n            float b = b_data[i];\n            for (int j = 0; j < w; j++)\n            {\n                ptr[j] = b * ptr[j] + a;\n            }\n        }\n    }\n\n    else\n    {\n        int size = w * h;\n        for (int q = 0; q < channels; q++)\n        {\n            float* ptr = data + q * size;\n            float a = a_data[q];\n            float b = b_data[q];\n\n            for (int i = 0; i < size; i++)\n            {\n                ptr[i] = b * ptr[i] + a;\n            }\n        }\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 3, "dataset": "vecintrin", "filename": "bias.cpp", "benchmark_name": "bias", "code_v0_no_empty_lines": "void bias(float* data, float* bias_data, int channels, int size) \n{\n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n        float bias = bias_data[q];\n\n        for (int i = 0; i < size; i++)\n        {\n            ptr[i] += bias;\n        }\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 4, "dataset": "vecintrin", "filename": "clip.cpp", "benchmark_name": "clip", "code_v0_no_empty_lines": "void clip(float* data, int channels, int size, float min, float max) \n{\n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n        for (int i = 0; i < size; i++)\n        {\n            if (ptr[i] < min)\n                ptr[i] = min;\n            if (ptr[i] > max)\n                ptr[i] = max;\n        }\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 5, "dataset": "vecintrin", "filename": "convsamp.cpp", "benchmark_name": "convsamp", "code_v0_no_empty_lines": "#include <stddef.h>\n#include <stddef.h>\n\n\ntypedef unsigned char JSAMPLE;\ntypedef short JCOEF;\ntypedef JCOEF *JCOEFPTR; \n\n\n#define DCTSIZE         8\n#define DCTSIZE2        64\n\n\n#define MAXJSAMPLE      255\n#define CENTERJSAMPLE   128\n\ntypedef short DCTELEM;\ntypedef unsigned short UDCTELEM;\ntypedef unsigned int JDIMENSION;\ntypedef unsigned int UDCTELEM2;\n\n\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\n\n/*\n * Load data into workspace, applying unsigned->signed conversion.\n * \n * This function converts sample data from unsigned (0..255) to signed \n * (-128..127) format by subtracting CENTERJSAMPLE (128), which is required\n * for DCT processing.\n *\n * Parameters:\n *   sample_data: 2D array of sample data (input image block)\n *   start_col: starting column in the sample data\n *   workspace: output workspace array (DCTSIZE2 elements)\n */\nvoid convsamp(JSAMPARRAY sample_data, JDIMENSION start_col, DCTELEM *workspace)\n{\n    DCTELEM *workspaceptr;\n    JSAMPROW elemptr;\n    int elemr;\n\n    workspaceptr = workspace;\n    \n\n    for (elemr = 0; elemr < DCTSIZE; elemr++) {\n        elemptr = sample_data[elemr] + start_col;\n\n        *workspaceptr++ = (*elemptr++) - CENTERJSAMPLE;\n        *workspaceptr++ = (*elemptr++) - CENTERJSAMPLE;\n        *workspaceptr++ = (*elemptr++) - CENTERJSAMPLE;\n        *workspaceptr++ = (*elemptr++) - CENTERJSAMPLE;\n        *workspaceptr++ = (*elemptr++) - CENTERJSAMPLE;\n        *workspaceptr++ = (*elemptr++) - CENTERJSAMPLE;\n        *workspaceptr++ = (*elemptr++) - CENTERJSAMPLE;\n        *workspaceptr++ = (*elemptr++) - CENTERJSAMPLE;\n    }\n}\n\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 6, "dataset": "vecintrin", "filename": "cvtBGRtoBGR.cpp", "benchmark_name": "cvtBGRtoBGR", "code_v0_no_empty_lines": "#include <string.h>\n#include <algorithm>\n\ntemplate<typename _Tp>\nstruct RGB2RGB_scalar\n{\n    typedef _Tp channel_type;\n\n    RGB2RGB_scalar(int _srccn, int _dstcn, int _blueIdx) :\n        srccn(_srccn), dstcn(_dstcn), blueIdx(_blueIdx)\n    {}\n\n    void operator()(const _Tp* src, _Tp* dst, int n) const\n    {\n        int scn = srccn, dcn = dstcn, bi = blueIdx;\n        int i = 0;\n        _Tp alphav = 255;\n\n\n        for ( ; i < n; i++, src += scn, dst += dcn )\n        {\n            _Tp t0 = src[0], t1 = src[1], t2 = src[2];\n            dst[bi  ] = t0;\n            dst[1]    = t1;\n            dst[bi^2] = t2;\n            if(dcn == 4)\n            {\n                _Tp d = scn == 4 ? src[3] : alphav;\n                dst[3] = d;\n            }\n        }\n    }\n\n    int srccn, dstcn, blueIdx;\n};\n\ntemplate<typename _Tp>\nstatic void cvtBGRtoBGR_impl(const _Tp* src_data, size_t src_step,\n                             _Tp* dst_data, size_t dst_step,\n                             int width, int height,\n                             int scn, int dcn, bool swapBlue)\n{\n    int blueIdx = swapBlue ? 2 : 0;\n\n    RGB2RGB_scalar<_Tp> converter(scn, dcn, blueIdx);\n    for (int y = 0; y < height; ++y) {\n        const _Tp* src_row = reinterpret_cast<const _Tp*>(\n            reinterpret_cast<const unsigned char*>(src_data) + y * src_step);\n        _Tp* dst_row = reinterpret_cast<_Tp*>(\n            reinterpret_cast<unsigned char*>(dst_data) + y * dst_step);\n\n        converter(src_row, dst_row, width);\n    }\n}\n\nint cvtBGRtoBGR(const unsigned char* src_data, size_t src_step,\n                unsigned char* dst_data, size_t dst_step,\n                int width, int height,\n                int depth, int scn, int dcn)\n{\n    if (depth != 0)\n        return 1;\n    if (!((scn == 3 && dcn == 4) || (scn == 4 && dcn == 3) || (scn == dcn)))\n        return 1;\n    if (scn == dcn) {\n        for (int i = 0; i < height; ++i) {\n            const unsigned char* src = src_data + src_step * i;\n            unsigned char* dst = dst_data + dst_step * i;\n            memcpy(dst, src, width * scn);\n        }\n        return 0;\n    }\n    cvtBGRtoBGR_impl<unsigned char>(src_data, src_step, dst_data, dst_step,\n                                    width, height, scn, dcn, false);\n\n    return 0;\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 7, "dataset": "vecintrin", "filename": "cvtBGRtoBGR5x5.cpp", "benchmark_name": "cvtBGRtoBGR5x5", "code_v0_no_empty_lines": "#include <cstdint>\n#include <cstddef>\n#include <algorithm>\n\nusing uchar = unsigned char;\nusing ushort = unsigned short;\nint cvtBGRtoBGR5x5(const unsigned char * src_data, size_t src_step,\n                   unsigned char * dst_data, size_t dst_step,\n                   int width, int height,\n                   int scn, bool swapBlue, int greenBits)\n{\n    if (!src_data || !dst_data || width <= 0 || height <= 0)\n        return 1;\n\n    if (scn != 3 && scn != 4)\n        return 1;\n\n    if (greenBits != 5 && greenBits != 6)\n        return 1;\n    int bidx = swapBlue ? 2 : 0;\n    for (int i = 0; i < height; i++)\n    {\n        const unsigned char * src = src_data + i * src_step;\n        unsigned char * dst = dst_data + i * dst_step;\n        for (int j = 0; j < width; j++, src += scn, dst += sizeof(ushort))\n        {\n            uchar r = src[bidx^2];\n            uchar g = src[1];\n            uchar b = src[bidx];\n            uchar a = scn == 4 ? src[3] : 0;\n\n            ushort d;\n            if (greenBits == 6)\n            {\n                d = (ushort)((b >> 3)|((g & ~3) << 3)|((r & ~7) << 8));\n            }\n            else\n            {\n                d = (ushort)((b >> 3)|((g & ~7) << 2)|((r & ~7) << 7)|(a ? 0x8000 : 0));\n            }\n            ((ushort*)dst)[0] = d;\n        }\n    }\n\n    return 0;\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 8, "dataset": "vecintrin", "filename": "cvtBGRtoGray.cpp", "benchmark_name": "cvtBGRtoGray", "code_v0_no_empty_lines": "#include <cstdint>\n#include <algorithm>\nenum\n{\n    SHIFT = 15,\n    SHIFT_DELTA = 1 << (SHIFT - 1),\n\n    R2Y_BT601   = 9798,\n    G2Y_BT601   = 19235,\n    B2Y_BT601   = 3735,\n\n    R2Y_BT709   = 3483,\n    G2Y_BT709   = 11718,\n    B2Y_BT709   = 1183,\n};\ntemplate<typename T>\ninline T saturate_cast(int val)\n{\n    return static_cast<T>(std::max(0, std::min(val, 255)));\n}\ntemplate<int scn>\nstatic void cvtBGRtoGray_(const unsigned char* src_data, size_t src_step,\n                         unsigned char* dst_data, size_t dst_step,\n                         int width, int height)\n{\n    const uint32_t R2Y = R2Y_BT601;\n    const uint32_t G2Y = G2Y_BT601;\n    const uint32_t B2Y = B2Y_BT601;\n\n    for (int i = 0; i < height; ++i)\n    {\n        const unsigned char* src = src_data + i * src_step;\n        unsigned char* dst = dst_data + i * dst_step;\n\n        int j = 0;\n\n        if (scn == 3) {\n            for (; j < width; ++j, src += 3)\n            {\n                uint32_t val = src[0] * B2Y + src[1] * G2Y + src[2] * R2Y;\n                dst[j] = saturate_cast<unsigned char>((val + SHIFT_DELTA) >> SHIFT);\n            }\n        }\n        else if (scn == 4) {\n            for (; j < width; ++j, src += 4)\n            {\n                uint32_t val = src[0] * B2Y + src[1] * G2Y + src[2] * R2Y;\n                dst[j] = saturate_cast<unsigned char>((val + SHIFT_DELTA) >> SHIFT);\n            }\n        }\n    }\n}\nint cvtBGRtoGray(const unsigned char* src_data, size_t src_step,\n                 unsigned char* dst_data, size_t dst_step,\n                 int width, int height,\n                 int depth, int scn)\n{\n    if (depth != 0)\n      return 1;\n    if (scn == 3) {\n        cvtBGRtoGray_<3>(src_data, src_step, dst_data, dst_step, width, height);\n    }\n    else if (scn == 4) {\n        cvtBGRtoGray_<4>(src_data, src_step, dst_data, dst_step, width, height);\n    }\n    else {\n      return 1;\n    }\n\n    return 0;\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 9, "dataset": "vecintrin", "filename": "cvtBGRtoHSV.cpp", "benchmark_name": "cvtBGRtoHSV", "code_v0_no_empty_lines": "#include <algorithm>\n#include <cstdint>\n#include <climits>\n#include <cfloat>\n#include <cstdlib>\n#include <cmath>\nenum\n{\n    hsv_shift = 12\n};\nstatic int sdiv_table[256];\nstatic int hdiv_table180[256];\nstatic int hdiv_table256[256];\nstatic bool tables_initialized = false;\n\nstatic void initializeTables()\n{\n    if (tables_initialized) return;\n    sdiv_table[0] = hdiv_table180[0] = hdiv_table256[0] = 0;\n    for (int i = 1; i < 256; i++)\n    {\n        sdiv_table[i] = (255 << hsv_shift) / i;\n        hdiv_table180[i] = (180 << hsv_shift) / (6 * i);\n        hdiv_table256[i] = (256 << hsv_shift) / (6 * i);\n    }\n    tables_initialized = true;\n}\n#define CV_CALC_MAX_8U(a, b) if((a) < (b)) (a) = (b)\n#define CV_CALC_MIN_8U(a, b) if((a) > (b)) (a) = (b)\nstatic inline int cvtBGRtoHSV_scalar_8u(int start, int end, const unsigned char * src, size_t src_step,\n                                        unsigned char * dst, size_t dst_step, int width, int scn,\n                                        bool swapBlue, bool isFullRange, bool isHSV)\n{\n    initializeTables();\n\n    int bidx = swapBlue ? 2 : 0;\n    int* hdiv_table = isFullRange ? hdiv_table256 : hdiv_table180;\n\n    for (int i = start; i < end; i++)\n    {\n        const unsigned char* src_row = src + i * src_step;\n        unsigned char* dst_row = dst + i * dst_step;\n\n        for (int j = 0; j < width; j++, src_row += scn, dst_row += 3)\n        {\n            int b = src_row[bidx], g = src_row[1], r = src_row[bidx^2];\n            int h, s, v = b;\n            int vmin = b;\n            int vr, vg;\n            CV_CALC_MAX_8U( v, g );\n            CV_CALC_MAX_8U( v, r );\n            CV_CALC_MIN_8U( vmin, g );\n            CV_CALC_MIN_8U( vmin, r );\n\n            unsigned char diff = (unsigned char)(v - vmin);\n            vr = v == r ? -1 : 0;\n            vg = v == g ? -1 : 0;\n            s = (diff * sdiv_table[v] + (1 << (hsv_shift-1))) >> hsv_shift;\n            h = (vr & (g - b)) +\n                (~vr & ((vg & (b - r + 2 * diff)) + ((~vg) & (r - g + 4 * diff))));\n            h = (h * hdiv_table[diff] + (1 << (hsv_shift-1))) >> hsv_shift;\n            dst_row[0] = (unsigned char)h;\n            dst_row[1] = (unsigned char)s;\n            dst_row[2] = (unsigned char)v;\n        }\n    }\n\n    return 0;\n}\nstatic inline int cvtBGRtoHSV_scalar_32f(int start, int end, const float * src, size_t src_step,\n                                         float * dst, size_t dst_step, int width, int scn,\n                                         bool swapBlue, bool)\n{\n    int bidx = swapBlue ? 2 : 0;\n    src_step /= sizeof(float);\n    dst_step /= sizeof(float);\n\n    for (int i = start; i < end; i++)\n    {\n        const float* src_row = src + i * src_step;\n        float* dst_row = dst + i * dst_step;\n\n        for (int j = 0; j < width; j++, src_row += scn, dst_row += 3)\n        {\n            float b = src_row[bidx], g = src_row[1], r = src_row[bidx^2];\n            float h, s, v;\n            float vmin, diff;\n            v = vmin = r;\n            if( v < g ) v = g;\n            if( v < b ) v = b;\n            if( vmin > g ) vmin = g;\n            if( vmin > b ) vmin = b;\n\n            diff = v - vmin;\n            s = diff/(float)(fabs(v) + FLT_EPSILON);\n            diff = (float)(60./(diff + FLT_EPSILON));\n            if( v == r )\n                h = (g - b)*diff;\n            else if( v == g )\n                h = (b - r)*diff + 120.f;\n            else\n                h = (r - g)*diff + 240.f;\n\n            if( h < 0 ) h += 360.f;\n            dst_row[0] = h;\n            dst_row[1] = s;\n            dst_row[2] = v;\n        }\n    }\n\n    return 0;\n}\nint cvtBGRtoHSV(int start, int end, const unsigned char * src, size_t src_step,\n                unsigned char * dst, size_t dst_step, int width, int scn,\n                bool swapBlue, bool isFullRange, bool isHSV)\n{\n    if (!src || !dst || width <= 0 || start < 0 || end <= start)\n        return 1;\n\n    if (scn != 3 && scn != 4)\n        return 1;\n\n    return cvtBGRtoHSV_scalar_8u(start, end, src, src_step, dst, dst_step, width, scn, swapBlue, isFullRange, isHSV);\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 10, "dataset": "vecintrin", "filename": "cvtBGRtoYUV.cpp", "benchmark_name": "cvtBGRtoYUV", "code_v0_no_empty_lines": "#include <cstdint>\n#include <algorithm>\ntemplate<typename T>\ninline T saturate_cast(int32_t val)\n{\n    if (val > 255) return 255;\n    if (val < 0) return 0;\n    return static_cast<T>(val);\n}\nstatic const int yuv_shift = 14;\nstatic const int R2Y = 4899;\nstatic const int G2Y = 9617;\nstatic const int B2Y = 1868;\nstatic const int YCRI = 11682;\nstatic const int YCBI = 9241;\nvoid cvtBGRtoYUV(const unsigned char* src_data, size_t src_step,\n                 unsigned char* dst_data, size_t dst_step,\n                 int width, int height, int depth, int scn)\n{\n    for (int i = 0; i < height; i++)\n    {\n        const unsigned char* src = src_data + i * src_step;\n        unsigned char* dst = dst_data + i * dst_step;\n        for (int j = 0; j < width; j++, src += scn, dst += 3)\n        {\n            int B = src[0];\n            int G = src[1];\n            int R = src[2];\n            int Y = (B * B2Y + G * G2Y + R * R2Y + (1 << (yuv_shift - 1))) >> yuv_shift;\n            int delta = 128 * (1 << yuv_shift);\n            int Cr = ((R - Y) * YCRI + delta + (1 << (yuv_shift - 1))) >> yuv_shift;\n            int Cb = ((B - Y) * YCBI + delta + (1 << (yuv_shift - 1))) >> yuv_shift;\n            dst[0] = saturate_cast<unsigned char>(Y);\n            dst[1] = saturate_cast<unsigned char>(Cr);\n            dst[2] = saturate_cast<unsigned char>(Cb);\n        }\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 11, "dataset": "vecintrin", "filename": "cvtGraytoBGR.cpp", "benchmark_name": "cvtGraytoBGR", "code_v0_no_empty_lines": "#include <cstdint>\n#include <algorithm>\nstatic void cvtGraytoBGR_3(const unsigned char* src_data, size_t src_step,\n                         unsigned char* dst_data, size_t dst_step,\n                         int width, int height)\n{\n    for (int i = 0; i < height; ++i)\n    {\n        const unsigned char* src = src_data + i * src_step;\n        unsigned char* dst = dst_data + i * dst_step;\n\n        int j = 0;\n        for (; j < width; ++j, dst += 3)\n        {\n            dst[0] = src[j];\n            dst[1] = src[j];\n            dst[2] = src[j];\n        }\n    }\n}\n\nstatic void cvtGraytoBGR_4(const unsigned char* src_data, size_t src_step,\n                         unsigned char* dst_data, size_t dst_step,\n                         int width, int height)\n{\n    for (int i = 0; i < height; ++i)\n    {\n        const unsigned char* src = src_data + i * src_step;\n        unsigned char* dst = dst_data + i * dst_step;\n\n        int j = 0;\n        for (; j < width; ++j, dst += 4)\n        {\n            dst[0] = src[j];\n            dst[1] = src[j];\n            dst[2] = src[j];\n            dst[3] = 255;\n        }\n    }\n}\nint cvtGraytoBGR(const unsigned char* src_data, size_t src_step,\n                 unsigned char* dst_data, size_t dst_step,\n                 int width, int height,\n                 int depth, int scn)\n{\n    if (depth != 0)\n        return 1;\n    if (scn == 3) {\n        cvtGraytoBGR_3(src_data, src_step, dst_data, dst_step, width, height);\n    }\n    else if (scn == 4) {\n        cvtGraytoBGR_4(src_data, src_step, dst_data, dst_step, width, height);\n    }\n    else {\n        return 1;\n    }\n\n    return 0;\n}\n\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 12, "dataset": "vecintrin", "filename": "dropout.cpp", "benchmark_name": "dropout", "code_v0_no_empty_lines": "void dropout(float* data, int channels, int size, float scale) \n{\n    if (scale == 1.f) {\n        return;\n    }\n    \n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n        for (int i = 0; i < size; i++)\n        {\n            ptr[i] = ptr[i] * scale;\n        }\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 13, "dataset": "vecintrin", "filename": "eltwise.cpp", "benchmark_name": "eltwise", "code_v0_no_empty_lines": "#include <vector>\n\n#define Operation_PROD 0\n#define Operation_SUM 1\n#define Operation_MAX 2\n\nusing namespace std;\nvoid eltwise(vector<float*> data_vec, float* out_data, int channels, int size, int op_type, float* alpha) \n{\n    if (op_type == Operation_PROD)\n    {\n        for (int q = 0; q < channels; q++)\n        {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n            for (int i = 0; i < size; i++)\n            {\n                outptr[i] = ptr[i] * ptr1[i];\n            }\n            \n        }\n\n        for (int b = 2; b < data_vec.size(); b++)\n        {\n            for (int q = 0; q < channels; q++)\n            {\n                float* ptr = data_vec[b] + q * size;            \n                float* outptr = out_data + q * size;\n                for (int i = 0; i < size; i++)\n                {\n                    outptr[i] *= ptr[i];\n                }\n            }\n        }\n    }\n    else if (op_type == Operation_SUM)\n    {\n        for (int q = 0; q < channels; q++)\n        {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n\n            for (int i = 0; i < size; i++)\n            {\n                outptr[i] = ptr[i] * alpha[0] + ptr1[i] * alpha[1];\n            }\n        }\n\n        for (int b = 2; b < data_vec.size(); b++)\n        {\n            for (int q = 0; q < channels; q++)\n            {\n                float* ptr = data_vec[b] + q * size;            \n                float* outptr = out_data + q * size;\n                for (int i = 0; i < size; i++)\n                {\n                    outptr[i] += ptr[i] * alpha[b];\n                }\n            }\n        }\n    }\n    else if (op_type == Operation_MAX)\n    {\n        for (int q = 0; q < channels; q++)\n        {\n            float* ptr = data_vec[0] + q * size;\n            float* ptr1 = data_vec[1] + q * size;\n            float* outptr = out_data + q * size;\n            for (int i = 0; i < size; i++)\n            {\n                outptr[i] = std::max(ptr[i], ptr1[i]);\n            }\n        }\n\n        for (int b = 2; b < data_vec.size(); b++)\n        {\n            for (int q = 0; q < channels; q++)\n            {\n                float* ptr = data_vec[b] + q * size;            \n                float* outptr = out_data + q * size;\n                for (int i = 0; i < size; i++)\n                {\n                    outptr[i] = std::max(outptr[i], ptr[i]);\n                }\n            }\n        }\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 14, "dataset": "vecintrin", "filename": "fdct_ifast.cpp", "benchmark_name": "fdct_ifast", "code_v0_no_empty_lines": "/*\n * Standalone fdct_ifast function\n * Extracted from libjpeg-turbo jfdctfst.c\n * \n * Fast integer forward DCT (Discrete Cosine Transform) implementation\n * based on Arai, Agui, and Nakajima's algorithm for scaled DCT.\n * \n * This is a fast, not-so-accurate integer implementation of the forward DCT.\n * The AA&N method leaves only 5 multiplies and 29 adds to be done in the DCT itself.\n */\n\n#include <stdint.h>\n\n/*\n * Type definitions\n */\ntypedef short DCTELEM;\ntypedef int32_t JLONG;\n\n/*\n * DCT size is fixed at 8x8\n */\n#define DCTSIZE 8\n\n/*\n * Scaling constants for fixed-point arithmetic\n * We use 8 fractional bits for the constants\n */\n#define CONST_BITS  8\n\n/*\n * Pre-calculated fixed-point constants\n * These represent cosine values scaled by 2^CONST_BITS\n */\n#define FIX_0_382683433  ((JLONG)98)\n#define FIX_0_541196100  ((JLONG)139)\n#define FIX_0_707106781  ((JLONG)181)\n#define FIX_1_306562965  ((JLONG)334)\n\n/*\n * Right shift with proper rounding\n * Assumes right shift rounds towards minus infinity\n */\n#define RIGHT_SHIFT(x, shft)  ((x) >> (shft))\n\n/*\n * Descale: divide by 2^n with rounding\n * We use fast non-rounding version for speed\n */\n#define DESCALE(x, n)  RIGHT_SHIFT(x, n)\n\n/*\n * Multiply a DCTELEM by a constant and descale\n */\n#define MULTIPLY(var, const)  ((DCTELEM)DESCALE((var) * (const), CONST_BITS))\n\n/*\n * Perform forward DCT on one 8x8 block of samples\n * \n * This function implements a fast integer forward DCT using the AA&N algorithm.\n * The DCT is performed in two passes:\n * - Pass 1: Process rows (1-D DCT on each row)\n * - Pass 2: Process columns (1-D DCT on each column)\n * \n * Input/Output:\n *   data - Pointer to 8x8 block of DCT elements\n *          Input: Sample data (range approximately +-128)\n *          Output: DCT coefficients scaled up by factor of 8\n * \n * The function modifies the data in-place. The input data should be\n * centered around zero (range +-CENTERJSAMPLE, typically +-128).\n * Output coefficients are scaled by 8, giving a range of +-8K for 8-bit data.\n */\nvoid fdct_ifast(DCTELEM *data)\n{\n    DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n    DCTELEM tmp10, tmp11, tmp12, tmp13;\n    DCTELEM z1, z2, z3, z4, z5, z11, z13;\n    DCTELEM *dataptr;\n    int ctr;\n    \n\n\n    \n    dataptr = data;\n    for (ctr = DCTSIZE - 1; ctr >= 0; ctr--) {\n\n        tmp0 = dataptr[0] + dataptr[7];\n        tmp7 = dataptr[0] - dataptr[7];\n        tmp1 = dataptr[1] + dataptr[6];\n        tmp6 = dataptr[1] - dataptr[6];\n        tmp2 = dataptr[2] + dataptr[5];\n        tmp5 = dataptr[2] - dataptr[5];\n        tmp3 = dataptr[3] + dataptr[4];\n        tmp4 = dataptr[3] - dataptr[4];\n        \n\n        \n        tmp10 = tmp0 + tmp3;\n        tmp13 = tmp0 - tmp3;\n        tmp11 = tmp1 + tmp2;\n        tmp12 = tmp1 - tmp2;\n        \n        dataptr[0] = tmp10 + tmp11;\n        dataptr[4] = tmp10 - tmp11;\n        \n        z1 = MULTIPLY(tmp12 + tmp13, FIX_0_707106781);\n        dataptr[2] = tmp13 + z1;\n        dataptr[6] = tmp13 - z1;\n        \n\n        \n        tmp10 = tmp4 + tmp5;\n        tmp11 = tmp5 + tmp6;\n        tmp12 = tmp6 + tmp7;\n        \n\n        z5 = MULTIPLY(tmp10 - tmp12, FIX_0_382683433);\n        z2 = MULTIPLY(tmp10, FIX_0_541196100) + z5;\n        z4 = MULTIPLY(tmp12, FIX_1_306562965) + z5;\n        z3 = MULTIPLY(tmp11, FIX_0_707106781);\n        \n        z11 = tmp7 + z3;\n        z13 = tmp7 - z3;\n        \n        dataptr[5] = z13 + z2;\n        dataptr[3] = z13 - z2;\n        dataptr[1] = z11 + z4;\n        dataptr[7] = z11 - z4;\n        \n        dataptr += DCTSIZE;\n    }\n    \n\n\n    \n    dataptr = data;\n    for (ctr = DCTSIZE - 1; ctr >= 0; ctr--) {\n\n        tmp0 = dataptr[DCTSIZE * 0] + dataptr[DCTSIZE * 7];\n        tmp7 = dataptr[DCTSIZE * 0] - dataptr[DCTSIZE * 7];\n        tmp1 = dataptr[DCTSIZE * 1] + dataptr[DCTSIZE * 6];\n        tmp6 = dataptr[DCTSIZE * 1] - dataptr[DCTSIZE * 6];\n        tmp2 = dataptr[DCTSIZE * 2] + dataptr[DCTSIZE * 5];\n        tmp5 = dataptr[DCTSIZE * 2] - dataptr[DCTSIZE * 5];\n        tmp3 = dataptr[DCTSIZE * 3] + dataptr[DCTSIZE * 4];\n        tmp4 = dataptr[DCTSIZE * 3] - dataptr[DCTSIZE * 4];\n        \n\n        \n        tmp10 = tmp0 + tmp3;\n        tmp13 = tmp0 - tmp3;\n        tmp11 = tmp1 + tmp2;\n        tmp12 = tmp1 - tmp2;\n        \n        dataptr[DCTSIZE * 0] = tmp10 + tmp11;\n        dataptr[DCTSIZE * 4] = tmp10 - tmp11;\n        \n        z1 = MULTIPLY(tmp12 + tmp13, FIX_0_707106781);\n        dataptr[DCTSIZE * 2] = tmp13 + z1;\n        dataptr[DCTSIZE * 6] = tmp13 - z1;\n        \n\n        \n        tmp10 = tmp4 + tmp5;\n        tmp11 = tmp5 + tmp6;\n        tmp12 = tmp6 + tmp7;\n        \n\n        z5 = MULTIPLY(tmp10 - tmp12, FIX_0_382683433);\n        z2 = MULTIPLY(tmp10, FIX_0_541196100) + z5;\n        z4 = MULTIPLY(tmp12, FIX_1_306562965) + z5;\n        z3 = MULTIPLY(tmp11, FIX_0_707106781);\n        \n        z11 = tmp7 + z3;\n        z13 = tmp7 - z3;\n        \n        dataptr[DCTSIZE * 5] = z13 + z2;\n        dataptr[DCTSIZE * 3] = z13 - z2;\n        dataptr[DCTSIZE * 1] = z11 + z4;\n        dataptr[DCTSIZE * 7] = z11 - z4;\n        \n        dataptr++;\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 15, "dataset": "vecintrin", "filename": "fdct_islow.cpp", "benchmark_name": "fdct_islow", "code_v0_no_empty_lines": "#include <stdint.h>\n\n/*\n * Type definitions\n */\ntypedef short DCTELEM;\ntypedef int32_t JLONG;\n\n/*\n * DCT size is fixed at 8x8\n */\n#define DCTSIZE 8\n\n/*\n * Scaling constants for fixed-point arithmetic\n * We use 13 fractional bits for better precision\n */\n#define CONST_BITS  13\n#define PASS1_BITS  2\n\n/*\n * Pre-calculated fixed-point constants for more accurate DCT\n * These represent cosine values scaled by 2^CONST_BITS\n */\n#define FIX_0_298631336  ((JLONG)2446)\n#define FIX_0_390180644  ((JLONG)3196)\n#define FIX_0_541196100  ((JLONG)4433)\n#define FIX_0_765366865  ((JLONG)6270)\n#define FIX_0_899976223  ((JLONG)7373)\n#define FIX_1_175875602  ((JLONG)9633)\n#define FIX_1_501321110  ((JLONG)12299)\n#define FIX_1_847759065  ((JLONG)15137)\n#define FIX_1_961570560  ((JLONG)16069)\n#define FIX_2_053119869  ((JLONG)16819)\n#define FIX_2_562915447  ((JLONG)20995)\n#define FIX_3_072711026  ((JLONG)25172)\n\n/*\n * Bit manipulation macros\n */\n#define LEFT_SHIFT(x, shft)   ((x) << (shft))\n#define RIGHT_SHIFT(x, shft)  ((x) >> (shft))\n\n/*\n * Descale: divide by 2^n with rounding\n */\n#define DESCALE(x, n)  RIGHT_SHIFT((x) + (1L << ((n) - 1)), n)\n\n/*\n * Multiply with 16x16->32 optimization for 8-bit samples\n */\n#define MULTIPLY16C16(var, const)  (((int16_t)(var)) * ((int16_t)(const)))\n#define MULTIPLY(var, const)  MULTIPLY16C16(var, const)\n\n/*\n * Perform slow but accurate forward DCT on one 8x8 block\n * \n * This function implements a more accurate integer forward DCT using the\n * Loeffler algorithm. It trades speed for precision, using more multiplies\n * and higher precision constants than the fast version.\n * \n * The algorithm performs two passes:\n * - Pass 1: Process rows with PASS1_BITS scaling\n * - Pass 2: Process columns and remove PASS1_BITS scaling\n * \n * Input/Output:\n *   data - Pointer to 8x8 block of DCT elements\n *          Input: Sample data centered around zero\n *          Output: DCT coefficients scaled by factor of 8\n * \n * This version provides better accuracy than fdct_ifast at the cost\n * of increased computational complexity.\n */\nvoid fdct_islow(DCTELEM *data)\n{\n    JLONG tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n    JLONG tmp10, tmp11, tmp12, tmp13;\n    JLONG z1, z2, z3, z4, z5;\n    DCTELEM *dataptr;\n    int ctr;\n    \n\n\n    \n    dataptr = data;\n    for (ctr = DCTSIZE - 1; ctr >= 0; ctr--) {\n\n        tmp0 = dataptr[0] + dataptr[7];\n        tmp7 = dataptr[0] - dataptr[7];\n        tmp1 = dataptr[1] + dataptr[6];\n        tmp6 = dataptr[1] - dataptr[6];\n        tmp2 = dataptr[2] + dataptr[5];\n        tmp5 = dataptr[2] - dataptr[5];\n        tmp3 = dataptr[3] + dataptr[4];\n        tmp4 = dataptr[3] - dataptr[4];\n        \n\n\n        \n        tmp10 = tmp0 + tmp3;\n        tmp13 = tmp0 - tmp3;\n        tmp11 = tmp1 + tmp2;\n        tmp12 = tmp1 - tmp2;\n        \n        dataptr[0] = (DCTELEM)LEFT_SHIFT(tmp10 + tmp11, PASS1_BITS);\n        dataptr[4] = (DCTELEM)LEFT_SHIFT(tmp10 - tmp11, PASS1_BITS);\n        \n        z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);\n        dataptr[2] = (DCTELEM)DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),\n                                      CONST_BITS - PASS1_BITS);\n        dataptr[6] = (DCTELEM)DESCALE(z1 + MULTIPLY(tmp12, -FIX_1_847759065),\n                                      CONST_BITS - PASS1_BITS);\n        \n\n\n\n        \n        z1 = tmp4 + tmp7;\n        z2 = tmp5 + tmp6;\n        z3 = tmp4 + tmp6;\n        z4 = tmp5 + tmp7;\n        z5 = MULTIPLY(z3 + z4, FIX_1_175875602);\n        \n        tmp4 = MULTIPLY(tmp4, FIX_0_298631336);\n        tmp5 = MULTIPLY(tmp5, FIX_2_053119869);\n        tmp6 = MULTIPLY(tmp6, FIX_3_072711026);\n        tmp7 = MULTIPLY(tmp7, FIX_1_501321110);\n        z1 = MULTIPLY(z1, -FIX_0_899976223);\n        z2 = MULTIPLY(z2, -FIX_2_562915447);\n        z3 = MULTIPLY(z3, -FIX_1_961570560);\n        z4 = MULTIPLY(z4, -FIX_0_390180644);\n        \n        z3 += z5;\n        z4 += z5;\n        \n        dataptr[7] = (DCTELEM)DESCALE(tmp4 + z1 + z3, CONST_BITS - PASS1_BITS);\n        dataptr[5] = (DCTELEM)DESCALE(tmp5 + z2 + z4, CONST_BITS - PASS1_BITS);\n        dataptr[3] = (DCTELEM)DESCALE(tmp6 + z2 + z3, CONST_BITS - PASS1_BITS);\n        dataptr[1] = (DCTELEM)DESCALE(tmp7 + z1 + z4, CONST_BITS - PASS1_BITS);\n        \n        dataptr += DCTSIZE;\n    }\n    \n\n\n    \n    dataptr = data;\n    for (ctr = DCTSIZE - 1; ctr >= 0; ctr--) {\n\n        tmp0 = dataptr[DCTSIZE * 0] + dataptr[DCTSIZE * 7];\n        tmp7 = dataptr[DCTSIZE * 0] - dataptr[DCTSIZE * 7];\n        tmp1 = dataptr[DCTSIZE * 1] + dataptr[DCTSIZE * 6];\n        tmp6 = dataptr[DCTSIZE * 1] - dataptr[DCTSIZE * 6];\n        tmp2 = dataptr[DCTSIZE * 2] + dataptr[DCTSIZE * 5];\n        tmp5 = dataptr[DCTSIZE * 2] - dataptr[DCTSIZE * 5];\n        tmp3 = dataptr[DCTSIZE * 3] + dataptr[DCTSIZE * 4];\n        tmp4 = dataptr[DCTSIZE * 3] - dataptr[DCTSIZE * 4];\n        \n\n        \n        tmp10 = tmp0 + tmp3;\n        tmp13 = tmp0 - tmp3;\n        tmp11 = tmp1 + tmp2;\n        tmp12 = tmp1 - tmp2;\n        \n        dataptr[DCTSIZE * 0] = (DCTELEM)DESCALE(tmp10 + tmp11, PASS1_BITS);\n        dataptr[DCTSIZE * 4] = (DCTELEM)DESCALE(tmp10 - tmp11, PASS1_BITS);\n        \n        z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);\n        dataptr[DCTSIZE * 2] =\n            (DCTELEM)DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),\n                             CONST_BITS + PASS1_BITS);\n        dataptr[DCTSIZE * 6] =\n            (DCTELEM)DESCALE(z1 + MULTIPLY(tmp12, -FIX_1_847759065),\n                             CONST_BITS + PASS1_BITS);\n        \n\n        \n        z1 = tmp4 + tmp7;\n        z2 = tmp5 + tmp6;\n        z3 = tmp4 + tmp6;\n        z4 = tmp5 + tmp7;\n        z5 = MULTIPLY(z3 + z4, FIX_1_175875602);\n        \n        tmp4 = MULTIPLY(tmp4, FIX_0_298631336);\n        tmp5 = MULTIPLY(tmp5, FIX_2_053119869);\n        tmp6 = MULTIPLY(tmp6, FIX_3_072711026);\n        tmp7 = MULTIPLY(tmp7, FIX_1_501321110);\n        z1 = MULTIPLY(z1, -FIX_0_899976223);\n        z2 = MULTIPLY(z2, -FIX_2_562915447);\n        z3 = MULTIPLY(z3, -FIX_1_961570560);\n        z4 = MULTIPLY(z4, -FIX_0_390180644);\n        \n        z3 += z5;\n        z4 += z5;\n        \n        dataptr[DCTSIZE * 7] = (DCTELEM)DESCALE(tmp4 + z1 + z3,\n                                                CONST_BITS + PASS1_BITS);\n        dataptr[DCTSIZE * 5] = (DCTELEM)DESCALE(tmp5 + z2 + z4,\n                                                CONST_BITS + PASS1_BITS);\n        dataptr[DCTSIZE * 3] = (DCTELEM)DESCALE(tmp6 + z2 + z3,\n                                                CONST_BITS + PASS1_BITS);\n        dataptr[DCTSIZE * 1] = (DCTELEM)DESCALE(tmp7 + z1 + z4,\n                                                CONST_BITS + PASS1_BITS);\n        \n        dataptr++;\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 16, "dataset": "vecintrin", "filename": "flatten.cpp", "benchmark_name": "flatten", "code_v0_no_empty_lines": "#include <string.h>\nvoid flatten(float* data, float* out_data, int size, int channels) \n{\n    for (int q = 0; q < channels; q++)\n    {\n        const unsigned char* ptr = (unsigned char*)data + q * size * sizeof(float);\n        unsigned char* outptr = (unsigned char*)out_data + q * size * sizeof(float);\n        memcpy(outptr, ptr, size * sizeof(float));\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 17, "dataset": "vecintrin", "filename": "gelu.cpp", "benchmark_name": "gelu", "code_v0_no_empty_lines": "#include <cmath>\n\nvoid gelu(float* data, int channels, int size, bool fast_gelu) \n{\n    if (fast_gelu)\n    {\n        for (int q = 0; q < channels; q++)\n        {\n            float* ptr = data + q * size;\n\n            for (int i = 0; i < size; i++)\n            {\n                ptr[i] = 0.5f * ptr[i] * (1.0f + tanhf(0.79788452f * (ptr[i] + 0.044715f * ptr[i] * ptr[i] * ptr[i])));\n            }\n        }\n    }\n    else\n    {\n        for (int q = 0; q < channels; q++)\n        {\n            float* ptr = data + q * size;\n\n            for (int i = 0; i < size; i++)\n            {\n                ptr[i] = 0.5f * ptr[i] * erfcf(-0.70710678f * ptr[i]);\n            }\n        }\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 18, "dataset": "vecintrin", "filename": "h2v1_downsample.cpp", "benchmark_name": "h2v1_downsample", "code_v0_no_empty_lines": "/*\n * Standalone downsampling functions\n * Extracted from libjpeg-turbo jcsample.c\n */\n\n#include <stdint.h>\n\ntypedef unsigned char JSAMPLE;\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\ntypedef unsigned int JDIMENSION;\n\n/*\n * Expand a component horizontally from width input_cols to width output_cols,\n * by duplicating the rightmost samples.\n * This is used to pad the input data to ensure all output samples can be generated.\n */\nstatic void expand_right_edge(JSAMPARRAY image_data, int num_rows, \n                             JDIMENSION input_cols, JDIMENSION output_cols)\n{\n    JSAMPROW ptr;\n    JSAMPLE pixval;\n    int count;\n    int row;\n    int numcols = (int)(output_cols - input_cols);\n\n    if (numcols > 0) {\n        for (row = 0; row < num_rows; row++) {\n            ptr = image_data[row] + input_cols;\n            pixval = ptr[-1];            for (count = numcols; count > 0; count--)\n                *ptr++ = pixval;        }\n    }\n}\n\n/*\n * Downsample pixel values with 2:1 horizontal and 1:1 vertical ratio.\n * This version handles the common case of 2:1 horizontal and 1:1 vertical,\n * without smoothing.\n *\n * A note about the \"bias\" calculations: when rounding fractional values to\n * integer, we do not want to always round 0.5 up to the next integer.\n * If we did that, we'd introduce a noticeable bias towards larger values.\n * Instead, this code is arranged so that 0.5 will be rounded up or down at\n * alternate pixel locations (a simple ordered dither pattern).\n *\n * Parameters:\n *   image_width       - Width of the input image in pixels  \n *   max_v_samp_factor - Maximum vertical sampling factor (typically 2)\n *   v_samp_factor     - Vertical sampling factor for this component \n *   width_in_blocks   - Width of output in DCT blocks (output_width = width_in_blocks * 8)\n *   input_data        - Array of pointers to input scanlines\n *   output_data       - Array of pointers to output scanlines\n */\nvoid h2v1_downsample(JDIMENSION image_width, int max_v_samp_factor,\n                     JDIMENSION v_samp_factor, JDIMENSION width_in_blocks,\n                     JSAMPARRAY input_data, JSAMPARRAY output_data)\n{\n    int outrow;\n    JDIMENSION outcol;\n    JDIMENSION output_cols = width_in_blocks * 8;    JSAMPROW inptr, outptr;\n    int bias;\n\n    /* Expand input data enough to let all the output samples be generated\n     * by the standard loop. Special-casing padded output would be more\n     * efficient.\n     */\n    expand_right_edge(input_data, max_v_samp_factor, image_width,\n                      output_cols * 2);\n\n    for (outrow = 0; outrow < (int)v_samp_factor; outrow++) {\n        outptr = output_data[outrow];\n        inptr = input_data[outrow];\n        bias = 0;\n        for (outcol = 0; outcol < output_cols; outcol++) {\n            *outptr++ = (JSAMPLE)((inptr[0] + inptr[1] + bias) >> 1);\n            bias ^= 1;            inptr += 2;\n        }\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 19, "dataset": "vecintrin", "filename": "h2v1_fancy_upsample.cpp", "benchmark_name": "h2v1_fancy_upsample", "code_v0_no_empty_lines": "/*\n * Standalone upsampling functions extracted from libjpeg-turbo\n * Original functions from src/jdsample.c\n *\n * These are the scalar (non-SIMD) versions of upsampling algorithms\n * used in JPEG decompression.\n */\n\n#include <stdint.h>\n#include <string.h>\n\n\ntypedef uint8_t JSAMPLE;\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\ntypedef uint32_t JDIMENSION;\n\n/*\n * Fancy processing for the common case of 2:1 horizontal and 1:1 vertical.\n *\n * The upsampling algorithm is linear interpolation between pixel centers,\n * also known as a \"triangle filter\".  This is a good compromise between\n * speed and visual quality.  The centers of the output pixels are 1/4 and 3/4\n * of the way between input pixel centers.\n *\n * A note about the \"bias\" calculations: when rounding fractional values to\n * integer, we do not want to always round 0.5 up to the next integer.\n * If we did that, we'd introduce a noticeable bias towards larger values.\n * Instead, this code is arranged so that 0.5 will be rounded up or down at\n * alternate pixel locations (a simple ordered dither pattern).\n */\nvoid h2v1_fancy_upsample(int max_v_samp_factor, JDIMENSION downsampled_width,\n                         JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)\n{\n  JSAMPARRAY output_data = *output_data_ptr;\n  JSAMPROW inptr, outptr;\n  int invalue;\n  JDIMENSION colctr;\n  int inrow;\n\n  for (inrow = 0; inrow < max_v_samp_factor; inrow++) {\n    inptr = input_data[inrow];\n    outptr = output_data[inrow];\n\n    invalue = *inptr++;\n    *outptr++ = (JSAMPLE)invalue;\n    *outptr++ = (JSAMPLE)((invalue * 3 + inptr[0] + 2) >> 2);\n\n    for (colctr = downsampled_width - 2; colctr > 0; colctr--) {\n\n      invalue = (*inptr++) * 3;\n      *outptr++ = (JSAMPLE)((invalue + inptr[-2] + 1) >> 2);\n      *outptr++ = (JSAMPLE)((invalue + inptr[0] + 2) >> 2);\n    }\n\n\n    invalue = *inptr;\n    *outptr++ = (JSAMPLE)((invalue * 3 + inptr[-1] + 1) >> 2);\n    *outptr++ = (JSAMPLE)invalue;\n  }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 20, "dataset": "vecintrin", "filename": "h2v1_merged_upsample.cpp", "benchmark_name": "h2v1_merged_upsample", "code_v0_no_empty_lines": "/*\n * Standalone h2v1_merged_upsample function\n * Extracted from libjpeg-turbo jdmrgext.c and jdmerge.c\n * \n * This function combines 2:1 horizontal upsampling with YCbCr to RGB color conversion\n * for improved performance by reusing chroma calculations for adjacent pixels.\n */\n\n#include <stdint.h>\n#include <stdlib.h>\n\ntypedef unsigned char JSAMPLE;\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\ntypedef JSAMPARRAY *JSAMPIMAGE;\ntypedef unsigned int JDIMENSION;\ntypedef long JLONG;\n\n#define RGB_RED     0\n#define RGB_GREEN   1\n#define RGB_BLUE    2\n#define RGB_PIXELSIZE 3\n\n#define SCALEBITS       16\n#define MAXJSAMPLE      255\n#define CENTERJSAMPLE   128\n#define ONE_HALF        ((JLONG)1 << (SCALEBITS - 1))\n#define FIX(x)          ((JLONG)((x) * (1L << SCALEBITS) + 0.5))\n\n#define RANGE_LIMIT(value)  ((value) < 0 ? 0 : ((value) > MAXJSAMPLE ? MAXJSAMPLE : (value)))\n\nstatic int Cr_r_tab[MAXJSAMPLE + 1];\nstatic int Cb_b_tab[MAXJSAMPLE + 1];\nstatic JLONG Cr_g_tab[MAXJSAMPLE + 1];\nstatic JLONG Cb_g_tab[MAXJSAMPLE + 1];\nstatic int tables_initialized = 0;\n\nstatic JSAMPLE range_limit_table[3 * (MAXJSAMPLE + 1)];\nstatic JSAMPLE *range_limit = NULL;\n\n/*\n * Initialize the YCbCr to RGB conversion tables.\n * This implements the CCIR 601-1 conversion equations:\n *      R = Y                + 1.40200 * Cr\n *      G = Y - 0.34414 * Cb - 0.71414 * Cr\n *      B = Y + 1.77200 * Cb\n *\n * where Cb and Cr represent the incoming values less CENTERJSAMPLE.\n */\nstatic void build_ycc_rgb_table(void)\n{\n    int i;\n    JLONG x;\n    \n    if (tables_initialized)\n        return;\n    \n    \n    for (i = 0; i <= MAXJSAMPLE; i++) {\n        range_limit_table[i] = 0;\n    }\n    for (i = 0; i <= MAXJSAMPLE; i++) {\n        range_limit_table[i + MAXJSAMPLE + 1] = (JSAMPLE)i;\n    }\n    for (i = 0; i <= MAXJSAMPLE; i++) {\n        range_limit_table[i + 2 * (MAXJSAMPLE + 1)] = MAXJSAMPLE;\n    }\n    range_limit = &range_limit_table[MAXJSAMPLE + 1];\n    \n    for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n\n\n        \n\n        Cr_r_tab[i] = (int)((FIX(1.40200) * x + ONE_HALF) >> SCALEBITS);\n        \n\n        Cb_b_tab[i] = (int)((FIX(1.77200) * x + ONE_HALF) >> SCALEBITS);\n        \n\n        Cr_g_tab[i] = (-FIX(0.71414)) * x;\n        \n\n\n        Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n    }\n    \n    tables_initialized = 1;\n}\n\n/*\n * Reset conversion tables state\n * Static arrays don't need to be freed, just reset the initialization flag\n */\nstatic void free_ycc_rgb_tables(void)\n{\n    if (tables_initialized) {\n        tables_initialized = 0;\n    }\n}\n\n/*\n * Merged upsampling and color conversion for 2:1 horizontal and 1:1 vertical.\n * \n * This function performs combined 2:1 horizontal upsampling and YCbCr to RGB \n * color conversion. It processes chroma components (Cb, Cr) at half resolution\n * and applies them to pairs of Y samples to produce RGB output.\n * \n * The optimization comes from calculating the chroma contribution once per \n * chroma sample pair, then applying it to two adjacent Y samples.\n *\n * Input format:\n *   - Y plane:  full resolution (output_width samples)\n *   - Cb plane: half resolution horizontally (output_width/2 samples)  \n *   - Cr plane: half resolution horizontally (output_width/2 samples)\n *\n * Output format:\n *   - RGB interleaved: full resolution (output_width * 3 bytes)\n *\n * Parameters:\n *   output_width     - Width of the output image in pixels\n *   input_buf        - Array of pointers to input planes [Y, Cb, Cr]\n *   in_row_group_ctr - Row index to process \n *   output_buf       - Pointer to output scanline (RGB format)\n */\nvoid h2v1_merged_upsample(JDIMENSION output_width, JSAMPIMAGE input_buf,\n                          JDIMENSION in_row_group_ctr,\n                          JSAMPARRAY output_buf)\n{\n    int y, cred, cgreen, cblue;\n    int cb, cr;\n    JSAMPROW outptr;\n    JSAMPROW inptr0, inptr1, inptr2;\n    JDIMENSION col;\n    \n    build_ycc_rgb_table();\n    \n    if (!tables_initialized) {\n        return;\n    }\n    \n    inptr0 = input_buf[0][in_row_group_ctr];    inptr1 = input_buf[1][in_row_group_ctr];    inptr2 = input_buf[2][in_row_group_ctr];    outptr = output_buf[0];    \n\n    for (col = output_width >> 1; col > 0; col--) {\n\n        cb = *inptr1++;\n        cr = *inptr2++;\n        cred = Cr_r_tab[cr];\n        cgreen = (int)((Cb_g_tab[cb] + Cr_g_tab[cr]) >> SCALEBITS);\n        cblue = Cb_b_tab[cb];\n        \n\n\n        y = *inptr0++;\n        outptr[RGB_RED] = range_limit[y + cred];\n        outptr[RGB_GREEN] = range_limit[y + cgreen];\n        outptr[RGB_BLUE] = range_limit[y + cblue];\n        outptr += RGB_PIXELSIZE;\n        \n\n        y = *inptr0++;\n        outptr[RGB_RED] = range_limit[y + cred];\n        outptr[RGB_GREEN] = range_limit[y + cgreen];\n        outptr[RGB_BLUE] = range_limit[y + cblue];\n        outptr += RGB_PIXELSIZE;\n    }\n    \n\n    if (output_width & 1) {\n        cb = *inptr1;\n        cr = *inptr2;\n        cred = Cr_r_tab[cr];\n        cgreen = (int)((Cb_g_tab[cb] + Cr_g_tab[cr]) >> SCALEBITS);\n        cblue = Cb_b_tab[cb];\n        y = *inptr0;\n        outptr[RGB_RED] = range_limit[y + cred];\n        outptr[RGB_GREEN] = range_limit[y + cgreen];\n        outptr[RGB_BLUE] = range_limit[y + cblue];\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 21, "dataset": "vecintrin", "filename": "h2v1_upsample.cpp", "benchmark_name": "h2v1_upsample", "code_v0_no_empty_lines": "/*\n * Standalone upsampling functions extracted from libjpeg-turbo\n * Original functions from src/jdsample.c\n *\n * These are the scalar (non-SIMD) versions of upsampling algorithms\n * used in JPEG decompression.\n */\n\n#include <stdint.h>\n#include <string.h>\n\n\ntypedef uint8_t JSAMPLE;\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\ntypedef uint32_t JDIMENSION;\n\n\nstatic void\njcopy_sample_rows(JSAMPARRAY input_array, int source_row,\n                  JSAMPARRAY output_array, int dest_row,\n                  int num_rows, JDIMENSION num_cols)\n{\n  JSAMPROW inptr, outptr;\n  JDIMENSION count;\n  int row;\n\n  for (row = 0; row < num_rows; row++) {\n    inptr = input_array[source_row + row];\n    outptr = output_array[dest_row + row];\n    for (count = 0; count < num_cols; count++) {\n      *outptr++ = *inptr++;\n    }\n  }\n}\n\n/*\n * Fast processing for the common case of 2:1 horizontal and 1:1 vertical.\n * It's still a box filter.\n */\nvoid h2v1_upsample(int max_v_samp_factor, JDIMENSION output_width,\n                   JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)\n{\n  JSAMPARRAY output_data = *output_data_ptr;\n  JSAMPROW inptr, outptr;\n  JSAMPLE invalue;\n  JSAMPROW outend;\n  int inrow;\n\n  for (inrow = 0; inrow < max_v_samp_factor; inrow++) {\n    inptr = input_data[inrow];\n    outptr = output_data[inrow];\n    outend = outptr + output_width;\n    while (outptr < outend) {\n      invalue = *inptr++;\n      *outptr++ = invalue;\n      *outptr++ = invalue;\n    }\n  }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 22, "dataset": "vecintrin", "filename": "h2v2_downsample.cpp", "benchmark_name": "h2v2_downsample", "code_v0_no_empty_lines": "/*\n * Standalone downsampling functions\n * Extracted from libjpeg-turbo jcsample.c\n */\n\n#include <stdint.h>\n\ntypedef unsigned char JSAMPLE;\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\ntypedef unsigned int JDIMENSION;\n\n/*\n * Expand a component horizontally from width input_cols to width output_cols,\n * by duplicating the rightmost samples.\n * This is used to pad the input data to ensure all output samples can be generated.\n */\nstatic void expand_right_edge(JSAMPARRAY image_data, int num_rows, \n                             JDIMENSION input_cols, JDIMENSION output_cols)\n{\n    JSAMPROW ptr;\n    JSAMPLE pixval;\n    int count;\n    int row;\n    int numcols = (int)(output_cols - input_cols);\n\n    if (numcols > 0) {\n        for (row = 0; row < num_rows; row++) {\n            ptr = image_data[row] + input_cols;\n            pixval = ptr[-1];            for (count = numcols; count > 0; count--)\n                *ptr++ = pixval;        }\n    }\n}\n\nvoid h2v2_downsample(JDIMENSION image_width, int max_v_samp_factor,\n                     JDIMENSION v_samp_factor, JDIMENSION width_in_blocks,\n                     JSAMPARRAY input_data, JSAMPARRAY output_data)\n{\n    int inrow, outrow;\n    JDIMENSION outcol;\n    JDIMENSION output_cols = width_in_blocks * 8;    JSAMPROW inptr0, inptr1, outptr;\n    int bias;\n\n    /* Expand input data enough to let all the output samples be generated\n     * by the standard loop. Special-casing padded output would be more\n     * efficient.\n     */\n    expand_right_edge(input_data, max_v_samp_factor, image_width,\n                      output_cols * 2);\n\n    inrow = 0;\n    for (outrow = 0; outrow < (int)v_samp_factor; outrow++) {\n        outptr = output_data[outrow];\n        inptr0 = input_data[inrow];        inptr1 = input_data[inrow + 1];        bias = 1;\n        for (outcol = 0; outcol < output_cols; outcol++) {\n            *outptr++ = (JSAMPLE)\n                ((inptr0[0] + inptr0[1] + inptr1[0] + inptr1[1] + bias) >> 2);\n            bias ^= 3;            inptr0 += 2;  \n            inptr1 += 2;\n        }\n        inrow += 2;    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 23, "dataset": "vecintrin", "filename": "h2v2_fancy_upsample.cpp", "benchmark_name": "h2v2_fancy_upsample", "code_v0_no_empty_lines": "/*\n * Standalone upsampling functions extracted from libjpeg-turbo\n * Original functions from src/jdsample.c\n *\n * These are the scalar (non-SIMD) versions of upsampling algorithms\n * used in JPEG decompression.\n */\n\n#include <stdint.h>\n#include <string.h>\n\n\ntypedef uint8_t JSAMPLE;\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\ntypedef uint32_t JDIMENSION;\n\n/*\n * Fancy processing for the common case of 2:1 horizontal and 2:1 vertical.\n * Again a triangle filter; see comments for h2v1 case, above.\n *\n * It is OK for us to reference the adjacent input rows because we demanded\n * context from the main buffer controller (see initialization code).\n */\nvoid h2v2_fancy_upsample(int max_v_samp_factor, JDIMENSION downsampled_width,\n                         JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)\n{\n  JSAMPARRAY output_data = *output_data_ptr;\n  JSAMPROW inptr0, inptr1, outptr;\n  int thiscolsum, lastcolsum, nextcolsum;\n  JDIMENSION colctr;\n  int inrow, outrow, v;\n\n  inrow = outrow = 0;\n  while (outrow < max_v_samp_factor) {\n    for (v = 0; v < 2; v++) {\n\n      inptr0 = input_data[inrow];\n      if (v == 0)\n        inptr1 = input_data[inrow - 1];\n      else\n        inptr1 = input_data[inrow + 1];\n      outptr = output_data[outrow++];\n\n\n      thiscolsum = (*inptr0++) * 3 + (*inptr1++);\n      nextcolsum = (*inptr0++) * 3 + (*inptr1++);\n      *outptr++ = (JSAMPLE)((thiscolsum * 4 + 8) >> 4);\n      *outptr++ = (JSAMPLE)((thiscolsum * 3 + nextcolsum + 7) >> 4);\n      lastcolsum = thiscolsum;  thiscolsum = nextcolsum;\n\n      for (colctr = downsampled_width - 2; colctr > 0; colctr--) {\n\n\n        nextcolsum = (*inptr0++) * 3 + (*inptr1++);\n        *outptr++ = (JSAMPLE)((thiscolsum * 3 + lastcolsum + 8) >> 4);\n        *outptr++ = (JSAMPLE)((thiscolsum * 3 + nextcolsum + 7) >> 4);\n        lastcolsum = thiscolsum;  thiscolsum = nextcolsum;\n      }\n\n\n      *outptr++ = (JSAMPLE)((thiscolsum * 3 + lastcolsum + 8) >> 4);\n      *outptr++ = (JSAMPLE)((thiscolsum * 4 + 7) >> 4);\n    }\n    inrow++;\n  }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 24, "dataset": "vecintrin", "filename": "h2v2_merged_upsample.cpp", "benchmark_name": "h2v2_merged_upsample", "code_v0_no_empty_lines": "/*\n * Standalone h2v1_merged_upsample function\n * Extracted from libjpeg-turbo jdmrgext.c and jdmerge.c\n * \n * This function combines 2:1 horizontal upsampling with YCbCr to RGB color conversion\n * for improved performance by reusing chroma calculations for adjacent pixels.\n */\n\n#include <stdint.h>\n#include <stdlib.h>\n\ntypedef unsigned char JSAMPLE;\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\ntypedef JSAMPARRAY *JSAMPIMAGE;\ntypedef unsigned int JDIMENSION;\ntypedef long JLONG;\n\n#define RGB_RED     0\n#define RGB_GREEN   1\n#define RGB_BLUE    2\n#define RGB_PIXELSIZE 3\n\n#define SCALEBITS       16\n#define MAXJSAMPLE      255\n#define CENTERJSAMPLE   128\n#define ONE_HALF        ((JLONG)1 << (SCALEBITS - 1))\n#define FIX(x)          ((JLONG)((x) * (1L << SCALEBITS) + 0.5))\n\n#define RANGE_LIMIT(value)  ((value) < 0 ? 0 : ((value) > MAXJSAMPLE ? MAXJSAMPLE : (value)))\n\nstatic int Cr_r_tab[MAXJSAMPLE + 1];\nstatic int Cb_b_tab[MAXJSAMPLE + 1];\nstatic JLONG Cr_g_tab[MAXJSAMPLE + 1];\nstatic JLONG Cb_g_tab[MAXJSAMPLE + 1];\nstatic int tables_initialized = 0;\n\nstatic JSAMPLE range_limit_table[3 * (MAXJSAMPLE + 1)];\nstatic JSAMPLE *range_limit = NULL;\n\n/*\n * Initialize the YCbCr to RGB conversion tables.\n * This implements the CCIR 601-1 conversion equations:\n *      R = Y                + 1.40200 * Cr\n *      G = Y - 0.34414 * Cb - 0.71414 * Cr\n *      B = Y + 1.77200 * Cb\n *\n * where Cb and Cr represent the incoming values less CENTERJSAMPLE.\n */\nstatic void build_ycc_rgb_table(void)\n{\n    int i;\n    JLONG x;\n    \n    if (tables_initialized)\n        return;\n    \n    \n    for (i = 0; i <= MAXJSAMPLE; i++) {\n        range_limit_table[i] = 0;\n    }\n    for (i = 0; i <= MAXJSAMPLE; i++) {\n        range_limit_table[i + MAXJSAMPLE + 1] = (JSAMPLE)i;\n    }\n    for (i = 0; i <= MAXJSAMPLE; i++) {\n        range_limit_table[i + 2 * (MAXJSAMPLE + 1)] = MAXJSAMPLE;\n    }\n    range_limit = &range_limit_table[MAXJSAMPLE + 1];\n    \n    for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n\n\n        \n\n        Cr_r_tab[i] = (int)((FIX(1.40200) * x + ONE_HALF) >> SCALEBITS);\n        \n\n        Cb_b_tab[i] = (int)((FIX(1.77200) * x + ONE_HALF) >> SCALEBITS);\n        \n\n        Cr_g_tab[i] = (-FIX(0.71414)) * x;\n        \n\n\n        Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n    }\n    \n    tables_initialized = 1;\n}\n\n/*\n * Reset conversion tables state\n * Static arrays don't need to be freed, just reset the initialization flag\n */\nstatic void free_ycc_rgb_tables(void)\n{\n    if (tables_initialized) {\n        tables_initialized = 0;\n    }\n}\n\n/*\n * Merged upsampling and color conversion for 2:1 horizontal and 1:1 vertical.\n * \n * This function performs combined 2:1 horizontal upsampling and YCbCr to RGB \n * color conversion. It processes chroma components (Cb, Cr) at half resolution\n * and applies them to pairs of Y samples to produce RGB output.\n * \n * The optimization comes from calculating the chroma contribution once per \n * chroma sample pair, then applying it to two adjacent Y samples.\n *\n * Input format:\n *   - Y plane:  full resolution (output_width samples)\n *   - Cb plane: half resolution horizontally (output_width/2 samples)  \n *   - Cr plane: half resolution horizontally (output_width/2 samples)\n *\n * Output format:\n *   - RGB interleaved: full resolution (output_width * 3 bytes)\n *\n * Parameters:\n *   output_width     - Width of the output image in pixels\n *   input_buf        - Array of pointers to input planes [Y, Cb, Cr]\n *   in_row_group_ctr - Row index to process \n *   output_buf       - Pointer to output scanline (RGB format)\n */\n\nvoid h2v2_merged_upsample(JDIMENSION output_width, JSAMPIMAGE input_buf,\n                          JDIMENSION in_row_group_ctr,\n                          JSAMPARRAY output_buf)\n{\n    int y, cred, cgreen, cblue;\n    int cb, cr;\n    JSAMPROW outptr0, outptr1;\n    JSAMPROW inptr00, inptr01, inptr1, inptr2;\n    JDIMENSION col;\n    \n    build_ycc_rgb_table();\n    \n    if (!tables_initialized) {\n        return;\n    }\n    \n    inptr00 = input_buf[0][in_row_group_ctr * 2];    inptr01 = input_buf[0][in_row_group_ctr * 2 + 1];    inptr1 = input_buf[1][in_row_group_ctr];    inptr2 = input_buf[2][in_row_group_ctr];    outptr0 = output_buf[0];    outptr1 = output_buf[1];    \n\n    for (col = output_width >> 1; col > 0; col--) {\n\n        cb = *inptr1++;\n        cr = *inptr2++;\n        cred = Cr_r_tab[cr];\n        cgreen = (int)((Cb_g_tab[cb] + Cr_g_tab[cr]) >> SCALEBITS);\n        cblue = Cb_b_tab[cb];\n        \n\n\n        y = *inptr00++;\n        outptr0[RGB_RED] = range_limit[y + cred];\n        outptr0[RGB_GREEN] = range_limit[y + cgreen];\n        outptr0[RGB_BLUE] = range_limit[y + cblue];\n        outptr0 += RGB_PIXELSIZE;\n        \n\n        y = *inptr00++;\n        outptr0[RGB_RED] = range_limit[y + cred];\n        outptr0[RGB_GREEN] = range_limit[y + cgreen];\n        outptr0[RGB_BLUE] = range_limit[y + cblue];\n        outptr0 += RGB_PIXELSIZE;\n        \n\n        y = *inptr01++;\n        outptr1[RGB_RED] = range_limit[y + cred];\n        outptr1[RGB_GREEN] = range_limit[y + cgreen];\n        outptr1[RGB_BLUE] = range_limit[y + cblue];\n        outptr1 += RGB_PIXELSIZE;\n        \n\n        y = *inptr01++;\n        outptr1[RGB_RED] = range_limit[y + cred];\n        outptr1[RGB_GREEN] = range_limit[y + cgreen];\n        outptr1[RGB_BLUE] = range_limit[y + cblue];\n        outptr1 += RGB_PIXELSIZE;\n    }\n    \n\n    if (output_width & 1) {\n        cb = *inptr1;\n        cr = *inptr2;\n        cred = Cr_r_tab[cr];\n        cgreen = (int)((Cb_g_tab[cb] + Cr_g_tab[cr]) >> SCALEBITS);\n        cblue = Cb_b_tab[cb];\n        \n\n        y = *inptr00;\n        outptr0[RGB_RED] = range_limit[y + cred];\n        outptr0[RGB_GREEN] = range_limit[y + cgreen];\n        outptr0[RGB_BLUE] = range_limit[y + cblue];\n        \n\n        y = *inptr01;\n        outptr1[RGB_RED] = range_limit[y + cred];\n        outptr1[RGB_GREEN] = range_limit[y + cgreen];\n        outptr1[RGB_BLUE] = range_limit[y + cblue];\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 25, "dataset": "vecintrin", "filename": "h2v2_upsample.cpp", "benchmark_name": "h2v2_upsample", "code_v0_no_empty_lines": "/*\n * Standalone upsampling functions extracted from libjpeg-turbo\n * Original functions from src/jdsample.c\n *\n * These are the scalar (non-SIMD) versions of upsampling algorithms\n * used in JPEG decompression.\n */\n\n#include <stdint.h>\n#include <string.h>\n\n\ntypedef uint8_t JSAMPLE;\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\ntypedef uint32_t JDIMENSION;\n\n\nstatic void\njcopy_sample_rows(JSAMPARRAY input_array, int source_row,\n                  JSAMPARRAY output_array, int dest_row,\n                  int num_rows, JDIMENSION num_cols)\n{\n  JSAMPROW inptr, outptr;\n  JDIMENSION count;\n  int row;\n\n  for (row = 0; row < num_rows; row++) {\n    inptr = input_array[source_row + row];\n    outptr = output_array[dest_row + row];\n    for (count = 0; count < num_cols; count++) {\n      *outptr++ = *inptr++;\n    }\n  }\n}\n\n/*\n * Fast processing for the common case of 2:1 horizontal and 2:1 vertical.\n * It's still a box filter.\n */\nvoid h2v2_upsample(int max_v_samp_factor, JDIMENSION output_width,\n                   JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)\n{\n  JSAMPARRAY output_data = *output_data_ptr;\n  JSAMPROW inptr, outptr;\n  JSAMPLE invalue;\n  JSAMPROW outend;\n  int inrow, outrow;\n\n  inrow = 0;\n  outrow = 0;\n  while (outrow < max_v_samp_factor) {\n    inptr = input_data[inrow];\n    outptr = output_data[outrow];\n    outend = outptr + output_width;\n    while (outptr < outend) {\n      invalue = *inptr++;\n      *outptr++ = invalue;\n      *outptr++ = invalue;\n    }\n    jcopy_sample_rows(output_data, outrow, output_data, outrow + 1, 1,\n                      output_width);\n    inrow++;\n    outrow += 2;\n  }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 26, "dataset": "vecintrin", "filename": "hardsigmoid.cpp", "benchmark_name": "hardsigmoid", "code_v0_no_empty_lines": "#include <cmath>\n\nvoid hardsigmoid(float* data, int channels, int size, float alpha, float beta) \n{\n    float lower = -beta / alpha;\n    float upper = (1.f / alpha) + lower;\n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n\n        for (int i = 0; i < size; i++)\n        {\n            if (ptr[i] < lower)\n                ptr[i] = 0.f;\n            else if (ptr[i] > upper)\n                ptr[i] = 1.f;\n            else\n                ptr[i] = ptr[i] * alpha + beta;\n        }\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 27, "dataset": "vecintrin", "filename": "hardswish.cpp", "benchmark_name": "hardswish", "code_v0_no_empty_lines": "void hardswish(float* data, int channels, int size, float alpha, float beta) \n{\n    float lower = -beta / alpha;\n    float upper = (1.f / alpha) + lower;\n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n\n        for (int i = 0; i < size; i++)\n        {\n            if (ptr[i] < lower)\n                ptr[i] = 0.f;\n            else if (ptr[i] > upper)\n                ;\n            else\n                ptr[i] = ptr[i] * (ptr[i] * alpha + beta);\n        }\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 28, "dataset": "vecintrin", "filename": "idct_ifast.cpp", "benchmark_name": "idct_ifast", "code_v0_no_empty_lines": "/*\n * Standalone idct_ifast function\n * Extracted from libjpeg-turbo jidctfst.c\n * \n * Fast integer inverse DCT implementation with dequantization\n * based on Arai, Agui, and Nakajima's algorithm for scaled DCT.\n * Uses 5 multiplies and 29 adds for speed optimization.\n */\n\n#include <stdint.h>\n#include <stddef.h>\n\n/*\n * Type definitions\n */\ntypedef short DCTELEM;\ntypedef int32_t JLONG;\ntypedef unsigned char JSAMPLE;\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\ntypedef short JCOEF;\ntypedef JCOEF *JCOEFPTR;\ntypedef unsigned int JDIMENSION;\ntypedef short IFAST_MULT_TYPE;\n\n/*\n * DCT size and related constants\n */\n#define DCTSIZE  8\n#define DCTSIZE2 64\n\n/*\n * Scaling constants for fixed-point arithmetic\n */\n#define CONST_BITS   8\n#define PASS1_BITS   2\n#define IFAST_SCALE_BITS  2\n#define MAXJSAMPLE   255\n#define CENTERJSAMPLE 128\n#define RANGE_MASK   (MAXJSAMPLE * 4 + 3)\n\n/*\n * Pre-calculated fixed-point constants for fast IDCT\n */\n#define FIX_1_082392200  ((JLONG)277)\n#define FIX_1_414213562  ((JLONG)362)\n#define FIX_1_847759065  ((JLONG)473)\n#define FIX_2_613125930  ((JLONG)669)\n\n/*\n * Bit manipulation macros\n */\n#define RIGHT_SHIFT(x, shft)  ((x) >> (shft))\n\n/*\n * Descale: divide by 2^n (fast version without rounding)\n */\n#define DESCALE(x, n)  RIGHT_SHIFT(x, n)\n\n/*\n * Integer descale for final output\n */\n#define IDESCALE(x, n)  ((int)RIGHT_SHIFT(x, n))\n\n/*\n * Multiply a DCTELEM by a constant and descale\n */\n#define MULTIPLY(var, const)  ((DCTELEM)DESCALE((var) * (const), CONST_BITS))\n\n/*\n * Dequantize a coefficient by multiplying with quantizer\n */\n#define DEQUANTIZE(coef, quantval)  (((IFAST_MULT_TYPE)(coef)) * (quantval))\n\n#define IDCT_range_limit(sample_range_limit) ((JSAMPLE *)(sample_range_limit) + 128)\n/*\n\n/*\n * Perform fast inverse DCT on one block of coefficients with dequantization\n * \n * This function combines dequantization and inverse DCT in a single pass for\n * efficiency. It uses the AA&N algorithm with optimizations for speed.\n * \n * Parameters:\n *   quantptr   - Pointer to quantization table (8x8 array of multipliers)\n *   coef_block - Pointer to 8x8 block of input DCT coefficients  \n *   output_buf - Array of pointers to 8 output sample rows\n *   output_col - Starting column index in output rows\n * \n * The function performs:\n * 1. Pass 1: Process columns, dequantize coefficients, store in workspace\n * 2. Pass 2: Process rows from workspace, output final samples with range limiting\n * \n * Output samples are clamped to valid range [0, 255] and written to output_buf.\n */\nvoid idct_ifast(void *dct_table, JCOEFPTR coef_block,\n                JSAMPARRAY output_buf, JDIMENSION output_col, JSAMPROW sample_range_limit)\n{\n    DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n    DCTELEM tmp10, tmp11, tmp12, tmp13;\n    DCTELEM z5, z10, z11, z12, z13;\n    JCOEFPTR inptr;\n    IFAST_MULT_TYPE *quantptr;\n    int *wsptr;\n    JSAMPROW outptr;\n    int ctr;\n    int workspace[DCTSIZE2];\n    \n   JSAMPLE *range_limit = IDCT_range_limit(sample_range_limit);\n\n    \n    inptr = coef_block;\n    quantptr = (IFAST_MULT_TYPE *)dct_table;\n    wsptr = workspace;\n    \n    for (ctr = DCTSIZE; ctr > 0; ctr--) {\n        /* Due to quantization, many AC coefficients are zero.\n         * We can short-circuit the IDCT calculation for columns with\n         * all AC terms zero - each output equals the DC coefficient.\n         */\n        \n        if (inptr[DCTSIZE * 1] == 0 && inptr[DCTSIZE * 2] == 0 &&\n            inptr[DCTSIZE * 3] == 0 && inptr[DCTSIZE * 4] == 0 &&\n            inptr[DCTSIZE * 5] == 0 && inptr[DCTSIZE * 6] == 0 &&\n            inptr[DCTSIZE * 7] == 0) {\n\n            int dcval = (int)DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n            \n            wsptr[DCTSIZE * 0] = dcval;\n            wsptr[DCTSIZE * 1] = dcval;\n            wsptr[DCTSIZE * 2] = dcval;\n            wsptr[DCTSIZE * 3] = dcval;\n            wsptr[DCTSIZE * 4] = dcval;\n            wsptr[DCTSIZE * 5] = dcval;\n            wsptr[DCTSIZE * 6] = dcval;\n            wsptr[DCTSIZE * 7] = dcval;\n            \n            inptr++;\n            quantptr++;\n            wsptr++;\n            continue;\n        }\n        \n\n        \n        tmp0 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n        tmp1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n        tmp2 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n        tmp3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n        \n        tmp10 = tmp0 + tmp2;\n        tmp11 = tmp0 - tmp2;\n        \n        tmp13 = tmp1 + tmp3;\n        tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13;\n        \n        tmp0 = tmp10 + tmp13;\n        tmp3 = tmp10 - tmp13;\n        tmp1 = tmp11 + tmp12;\n        tmp2 = tmp11 - tmp12;\n        \n\n        \n        tmp4 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n        tmp5 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n        tmp6 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n        tmp7 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n        \n        z13 = tmp6 + tmp5;\n        z10 = tmp6 - tmp5;\n        z11 = tmp4 + tmp7;\n        z12 = tmp4 - tmp7;\n        \n        tmp7 = z11 + z13;\n        tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562);\n        \n        z5 = MULTIPLY(z10 + z12, FIX_1_847759065);\n        tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5;\n        tmp12 = MULTIPLY(z10, -FIX_2_613125930) + z5;\n        \n        tmp6 = tmp12 - tmp7;\n        tmp5 = tmp11 - tmp6;\n        tmp4 = tmp10 + tmp5;\n        \n\n        wsptr[DCTSIZE * 0] = (int)(tmp0 + tmp7);\n        wsptr[DCTSIZE * 7] = (int)(tmp0 - tmp7);\n        wsptr[DCTSIZE * 1] = (int)(tmp1 + tmp6);\n        wsptr[DCTSIZE * 6] = (int)(tmp1 - tmp6);\n        wsptr[DCTSIZE * 2] = (int)(tmp2 + tmp5);\n        wsptr[DCTSIZE * 5] = (int)(tmp2 - tmp5);\n        wsptr[DCTSIZE * 4] = (int)(tmp3 + tmp4);\n        wsptr[DCTSIZE * 3] = (int)(tmp3 - tmp4);\n        \n        inptr++;\n        quantptr++;\n        wsptr++;\n    }\n    \n\n\n    \n    wsptr = workspace;\n    for (ctr = 0; ctr < DCTSIZE; ctr++) {\n        outptr = output_buf[ctr] + output_col;\n        \n\n        if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&\n            wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\n\n            JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS + 3) & RANGE_MASK];\n            \n            outptr[0] = dcval;\n            outptr[1] = dcval;\n            outptr[2] = dcval;\n            outptr[3] = dcval;\n            outptr[4] = dcval;\n            outptr[5] = dcval;\n            outptr[6] = dcval;\n            outptr[7] = dcval;\n            \n            wsptr += DCTSIZE;\n            continue;\n        }\n        \n\n        \n        tmp10 = ((DCTELEM)wsptr[0] + (DCTELEM)wsptr[4]);\n        tmp11 = ((DCTELEM)wsptr[0] - (DCTELEM)wsptr[4]);\n        \n        tmp13 = ((DCTELEM)wsptr[2] + (DCTELEM)wsptr[6]);\n        tmp12 = MULTIPLY((DCTELEM)wsptr[2] - (DCTELEM)wsptr[6], FIX_1_414213562) - tmp13;\n        \n        tmp0 = tmp10 + tmp13;\n        tmp3 = tmp10 - tmp13;\n        tmp1 = tmp11 + tmp12;\n        tmp2 = tmp11 - tmp12;\n        \n\n        \n        z13 = (DCTELEM)wsptr[5] + (DCTELEM)wsptr[3];\n        z10 = (DCTELEM)wsptr[5] - (DCTELEM)wsptr[3];\n        z11 = (DCTELEM)wsptr[1] + (DCTELEM)wsptr[7];\n        z12 = (DCTELEM)wsptr[1] - (DCTELEM)wsptr[7];\n        \n        tmp7 = z11 + z13;\n        tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562);\n        \n        z5 = MULTIPLY(z10 + z12, FIX_1_847759065);\n        tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5;\n        tmp12 = MULTIPLY(z10, -FIX_2_613125930) + z5;\n        \n        tmp6 = tmp12 - tmp7;\n        tmp5 = tmp11 - tmp6;\n        tmp4 = tmp10 + tmp5;\n        \n\n        \n        outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS + 3) & RANGE_MASK];\n        outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS + 3) & RANGE_MASK];\n        outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS + 3) & RANGE_MASK];\n        outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS + 3) & RANGE_MASK];\n        outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS + 3) & RANGE_MASK];\n        outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS + 3) & RANGE_MASK];\n        outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS + 3) & RANGE_MASK];\n        outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS + 3) & RANGE_MASK];\n\n        wsptr += DCTSIZE;\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 29, "dataset": "vecintrin", "filename": "idct_islow.cpp", "benchmark_name": "idct_islow", "code_v0_no_empty_lines": "/*\n * Standalone idct_islow function\n * Extracted from libjpeg-turbo jidctint.c\n * \n * Slower but more accurate integer inverse DCT implementation with dequantization\n * based on C. Loeffler, A. Ligtenberg and G. Moschytz algorithm.\n * Uses 12 multiplies and 32 adds for better precision than the fast version.\n */\n\n#include <stdint.h>\n#include <stddef.h>\n\n/*\n * Type definitions\n */\ntypedef short DCTELEM;\ntypedef int32_t JLONG;\ntypedef unsigned char JSAMPLE;\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\ntypedef short JCOEF;\ntypedef JCOEF *JCOEFPTR;\ntypedef unsigned int JDIMENSION;\ntypedef short ISLOW_MULT_TYPE;\n\n/*\n * DCT size and related constants\n */\n#define DCTSIZE  8\n#define DCTSIZE2 64\n\n/*\n * Scaling constants for fixed-point arithmetic\n * We use 13 fractional bits for maximum precision\n */\n#define CONST_BITS   13\n#define PASS1_BITS   2\n#define MAXJSAMPLE   255\n#define CENTERJSAMPLE 128\n#define RANGE_MASK   (MAXJSAMPLE * 4 + 3)\n\n/*\n * Pre-calculated fixed-point constants for accurate IDCT\n * These represent cosine values scaled by 2^CONST_BITS\n */\n#define FIX_0_298631336  ((JLONG)2446)\n#define FIX_0_390180644  ((JLONG)3196)\n#define FIX_0_541196100  ((JLONG)4433)\n#define FIX_0_765366865  ((JLONG)6270)\n#define FIX_0_899976223  ((JLONG)7373)\n#define FIX_1_175875602  ((JLONG)9633)\n#define FIX_1_501321110  ((JLONG)12299)\n#define FIX_1_847759065  ((JLONG)15137)\n#define FIX_1_961570560  ((JLONG)16069)\n#define FIX_2_053119869  ((JLONG)16819)\n#define FIX_2_562915447  ((JLONG)20995)\n#define FIX_3_072711026  ((JLONG)25172)\n\n/*\n * Bit manipulation macros\n */\n#define LEFT_SHIFT(x, shft)   ((x) << (shft))\n#define RIGHT_SHIFT(x, shft)  ((x) >> (shft))\n\n/*\n * Descale: divide by 2^n with rounding\n */\n#define DESCALE(x, n)  RIGHT_SHIFT((x) + (1L << ((n) - 1)), n)\n\n/*\n * Multiply with 16x16->32 optimization for 8-bit samples\n */\n#define MULTIPLY16C16(var, const)  (((int16_t)(var)) * ((int16_t)(const)))\n#define MULTIPLY(var, const)  MULTIPLY16C16(var, const)\n\n/*\n * Dequantize a coefficient by multiplying with quantizer\n */\n#define DEQUANTIZE(coef, quantval)  (((ISLOW_MULT_TYPE)(coef)) * (quantval))\n\n/*\n * Range limit table for clamping output to 0-255\n */\n\n#define IDCT_range_limit(sample_range_limit) ((JSAMPLE *)(sample_range_limit) + 128)\n/*\n * Perform slow but accurate inverse DCT on one block of coefficients with dequantization\n * \n * This function combines dequantization and inverse DCT using the Loeffler algorithm\n * for maximum accuracy. It trades speed for precision compared to the fast version.\n * \n * Parameters:\n *   quantptr   - Pointer to quantization table (8x8 array of multipliers)\n *   coef_block - Pointer to 8x8 block of input DCT coefficients  \n *   output_buf - Array of pointers to 8 output sample rows\n *   output_col - Starting column index in output rows\n * \n * The function performs:\n * 1. Pass 1: Process columns, dequantize coefficients, store in workspace with PASS1_BITS scaling\n * 2. Pass 2: Process rows from workspace, output final samples with range limiting\n * \n * This version provides better accuracy than idct_ifast at the cost of increased\n * computational complexity, using higher precision constants and more careful scaling.\n */\nvoid idct_islow(short *quantptr, JCOEFPTR coef_block, \n                JSAMPARRAY output_buf, JDIMENSION output_col, JSAMPROW sample_range_limit)\n{\n    JLONG tmp0, tmp1, tmp2, tmp3;\n    JLONG tmp10, tmp11, tmp12, tmp13;\n    JLONG z1, z2, z3, z4, z5;\n    JCOEFPTR inptr;\n    ISLOW_MULT_TYPE *quantptr_slow;\n    int *wsptr;\n    JSAMPROW outptr;\n    int ctr;\n    int workspace[DCTSIZE2];\n    \n\n    JSAMPLE *range_limit = IDCT_range_limit(sample_range_limit);\n\n\n    \n    inptr = coef_block;\n    wsptr = workspace;\n    for (ctr = DCTSIZE; ctr > 0; ctr--) {\n        /* Due to quantization, we will usually find that many of the input\n        * coefficients are zero, especially the AC terms.  We can exploit this\n        * by short-circuiting the IDCT calculation for any column in which all\n        * the AC terms are zero.  In that case each output is equal to the\n        * DC coefficient (with scale factor as needed).\n        * With typical images and quantization tables, half or more of the\n        * column DCT calculations can be simplified this way.\n        */\n\n        if (inptr[DCTSIZE * 1] == 0 && inptr[DCTSIZE * 2] == 0 &&\n            inptr[DCTSIZE * 3] == 0 && inptr[DCTSIZE * 4] == 0 &&\n            inptr[DCTSIZE * 5] == 0 && inptr[DCTSIZE * 6] == 0 &&\n            inptr[DCTSIZE * 7] == 0) {\n\n            int dcval = LEFT_SHIFT(DEQUANTIZE(inptr[DCTSIZE * 0],\n                                    quantptr[DCTSIZE * 0]), PASS1_BITS);\n            wsptr[DCTSIZE * 0] = dcval;\n            wsptr[DCTSIZE * 1] = dcval;\n            wsptr[DCTSIZE * 2] = dcval;\n            wsptr[DCTSIZE * 3] = dcval;\n            wsptr[DCTSIZE * 4] = dcval;\n            wsptr[DCTSIZE * 5] = dcval;\n            wsptr[DCTSIZE * 6] = dcval;\n            wsptr[DCTSIZE * 7] = dcval;\n            inptr++;\n            quantptr++;\n            wsptr++;\n            continue;\n        }\n\n\n\n\n        z2 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n        z3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);\n        tmp2 = z1 + MULTIPLY(z3, -FIX_1_847759065);\n        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);\n\n        z2 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n        z3 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n\n        tmp0 = LEFT_SHIFT(z2 + z3, CONST_BITS);\n        tmp1 = LEFT_SHIFT(z2 - z3, CONST_BITS);\n\n        tmp10 = tmp0 + tmp3;\n        tmp13 = tmp0 - tmp3;\n        tmp11 = tmp1 + tmp2;\n        tmp12 = tmp1 - tmp2;\n\n        /* Odd part per figure 8; the matrix is unitary and hence its\n        * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\n        */\n\n        tmp0 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n        tmp1 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n        tmp2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n        tmp3 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n\n        z1 = tmp0 + tmp3;\n        z2 = tmp1 + tmp2;\n        z3 = tmp0 + tmp2;\n        z4 = tmp1 + tmp3;\n        z5 = MULTIPLY(z3 + z4, FIX_1_175875602);\n\n        tmp0 = MULTIPLY(tmp0, FIX_0_298631336);\n        tmp1 = MULTIPLY(tmp1, FIX_2_053119869);\n        tmp2 = MULTIPLY(tmp2, FIX_3_072711026);\n        tmp3 = MULTIPLY(tmp3, FIX_1_501321110);\n        z1 = MULTIPLY(z1, -FIX_0_899976223);\n        z2 = MULTIPLY(z2, -FIX_2_562915447);\n        z3 = MULTIPLY(z3, -FIX_1_961570560);\n        z4 = MULTIPLY(z4, -FIX_0_390180644);\n\n        z3 += z5;\n        z4 += z5;\n\n        tmp0 += z1 + z3;\n        tmp1 += z2 + z4;\n        tmp2 += z2 + z3;\n        tmp3 += z1 + z4;\n\n\n\n        wsptr[DCTSIZE * 0] = (int)DESCALE(tmp10 + tmp3, CONST_BITS - PASS1_BITS);\n        wsptr[DCTSIZE * 7] = (int)DESCALE(tmp10 - tmp3, CONST_BITS - PASS1_BITS);\n        wsptr[DCTSIZE * 1] = (int)DESCALE(tmp11 + tmp2, CONST_BITS - PASS1_BITS);\n        wsptr[DCTSIZE * 6] = (int)DESCALE(tmp11 - tmp2, CONST_BITS - PASS1_BITS);\n        wsptr[DCTSIZE * 2] = (int)DESCALE(tmp12 + tmp1, CONST_BITS - PASS1_BITS);\n        wsptr[DCTSIZE * 5] = (int)DESCALE(tmp12 - tmp1, CONST_BITS - PASS1_BITS);\n        wsptr[DCTSIZE * 3] = (int)DESCALE(tmp13 + tmp0, CONST_BITS - PASS1_BITS);\n        wsptr[DCTSIZE * 4] = (int)DESCALE(tmp13 - tmp0, CONST_BITS - PASS1_BITS);\n\n        inptr++;\n        quantptr++;\n        wsptr++;\n    }\n\n\n\n\n\n    wsptr = workspace;\n    for (ctr = 0; ctr < DCTSIZE; ctr++) {\n        outptr = output_buf[ctr] + output_col;\n        /* Rows of zeroes can be exploited in the same way as we did with columns.\n        * However, the column calculation has created many nonzero AC terms, so\n        * the simplification applies less often (typically 5% to 10% of the time).\n        * On machines with very fast multiplication, it's possible that the\n        * test takes more time than it's worth.  In that case this section\n        * may be commented out.\n        */\n\n        if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&\n            wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\n\n        JSAMPLE dcval = range_limit[(int)DESCALE((JLONG)wsptr[0],\n                                                    PASS1_BITS + 3) & RANGE_MASK];\n\n        outptr[0] = dcval;\n        outptr[1] = dcval;\n        outptr[2] = dcval;\n        outptr[3] = dcval;\n        outptr[4] = dcval;\n        outptr[5] = dcval;\n        outptr[6] = dcval;\n        outptr[7] = dcval;\n\n        wsptr += DCTSIZE;\n        continue;\n        }\n\n\n\n\n        z2 = (JLONG)wsptr[2];\n        z3 = (JLONG)wsptr[6];\n\n        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);\n        tmp2 = z1 + MULTIPLY(z3, -FIX_1_847759065);\n        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);\n\n        tmp0 = LEFT_SHIFT((JLONG)wsptr[0] + (JLONG)wsptr[4], CONST_BITS);\n        tmp1 = LEFT_SHIFT((JLONG)wsptr[0] - (JLONG)wsptr[4], CONST_BITS);\n\n        tmp10 = tmp0 + tmp3;\n        tmp13 = tmp0 - tmp3;\n        tmp11 = tmp1 + tmp2;\n        tmp12 = tmp1 - tmp2;\n\n        /* Odd part per figure 8; the matrix is unitary and hence its\n        * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\n        */\n\n        tmp0 = (JLONG)wsptr[7];\n        tmp1 = (JLONG)wsptr[5];\n        tmp2 = (JLONG)wsptr[3];\n        tmp3 = (JLONG)wsptr[1];\n\n        z1 = tmp0 + tmp3;\n        z2 = tmp1 + tmp2;\n        z3 = tmp0 + tmp2;\n        z4 = tmp1 + tmp3;\n        z5 = MULTIPLY(z3 + z4, FIX_1_175875602);\n\n        tmp0 = MULTIPLY(tmp0, FIX_0_298631336);\n        tmp1 = MULTIPLY(tmp1, FIX_2_053119869);\n        tmp2 = MULTIPLY(tmp2, FIX_3_072711026);\n        tmp3 = MULTIPLY(tmp3, FIX_1_501321110);\n        z1 = MULTIPLY(z1, -FIX_0_899976223);\n        z2 = MULTIPLY(z2, -FIX_2_562915447);\n        z3 = MULTIPLY(z3, -FIX_1_961570560);\n        z4 = MULTIPLY(z4, -FIX_0_390180644);\n\n        z3 += z5;\n        z4 += z5;\n\n        tmp0 += z1 + z3;\n        tmp1 += z2 + z4;\n        tmp2 += z2 + z3;\n        tmp3 += z1 + z4;\n\n\n\n        outptr[0] = range_limit[(int)DESCALE(tmp10 + tmp3,\n                                            CONST_BITS + PASS1_BITS + 3) &\n                                RANGE_MASK];\n        outptr[7] = range_limit[(int)DESCALE(tmp10 - tmp3,\n                                            CONST_BITS + PASS1_BITS + 3) &\n                                RANGE_MASK];\n        outptr[1] = range_limit[(int)DESCALE(tmp11 + tmp2,\n                                            CONST_BITS + PASS1_BITS + 3) &\n                                RANGE_MASK];\n        outptr[6] = range_limit[(int)DESCALE(tmp11 - tmp2,\n                                            CONST_BITS + PASS1_BITS + 3) &\n                                RANGE_MASK];\n        outptr[2] = range_limit[(int)DESCALE(tmp12 + tmp1,\n                                            CONST_BITS + PASS1_BITS + 3) &\n                                RANGE_MASK];\n        outptr[5] = range_limit[(int)DESCALE(tmp12 - tmp1,\n                                            CONST_BITS + PASS1_BITS + 3) &\n                                RANGE_MASK];\n        outptr[3] = range_limit[(int)DESCALE(tmp13 + tmp0,\n                                            CONST_BITS + PASS1_BITS + 3) &\n                                RANGE_MASK];\n        outptr[4] = range_limit[(int)DESCALE(tmp13 - tmp0,\n                                            CONST_BITS + PASS1_BITS + 3) &\n                                RANGE_MASK];\n\n        wsptr += DCTSIZE;\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 30, "dataset": "vecintrin", "filename": "innerproduct.cpp", "benchmark_name": "innerproduct", "code_v0_no_empty_lines": "void innerproduct(float* in_data, float* weight_data, float* bias_data, float* out_data, int num_output, int size) \n{\n    for (int p = 0; p < num_output; p++)\n    {\n        float sum = bias_data[p];\n\n        const float* w = (const float*)weight_data + size * p;\n        const float* m = (const float*)in_data;\n        for (int i = 0; i < size; i++)\n        {\n            sum += m[i] * w[i];\n        }\n        out_data[p] = sum;\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 31, "dataset": "vecintrin", "filename": "instancenorm.cpp", "benchmark_name": "instancenorm", "code_v0_no_empty_lines": "#include <cmath>\nvoid instancenorm(float* data, int channels, int size, float* gamma_data = nullptr, float* beta_data = nullptr, bool affine = false, float eps = 0.001f)\n{\n\n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n\n        float sum = 0.f;\n        float sqsum = 0.f;\n        for (int i = 0; i < size; i++)\n        {\n            sum += ptr[i];\n            //sqsum += ptr[i] * ptr[i];\n        }\n        float mean = sum / size;\n        float tmp = 0.f;\n        for (int i = 0; i < size; i++)\n        {\n            tmp = ptr[i] - mean;\n            sqsum += tmp * tmp;\n        }\n        float var = sqsum / size;\n        //float var = sqsum / size - mean * mean;\n\n        float a;\n        float b;\n        if (affine)\n        {\n            float gamma = gamma_data[q];\n            float beta = beta_data[q];\n\n            a = gamma / (sqrtf(var + eps));\n            b = -mean * a + beta;\n        }\n        else\n        {\n            a = 1.f / (sqrtf(var + eps));\n            b = -mean * a;\n        }\n\n        for (int i = 0; i < size; i++)\n        {\n            ptr[i] = ptr[i] * a + b;\n        }\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 32, "dataset": "vecintrin", "filename": "magnitude.cpp", "benchmark_name": "magnitude", "code_v0_no_empty_lines": "#include <cmath>\n\nvoid magnitude32f(const float* x, const float* y, float* mag, int len)\n{\n    for(int i = 0 ; i < len; i++ )\n    {\n        float x0 = x[i], y0 = y[i];\n        mag[i] = std::sqrt(x0*x0 + y0*y0);\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 33, "dataset": "vecintrin", "filename": "merge.cpp", "benchmark_name": "merge", "code_v0_no_empty_lines": "template<typename T> static void\nmerge_( const T** src, T* dst, int len, int cn )\n{\n    int k = cn % 4 ? cn % 4 : 4;\n    int i, j;\n    if( k == 1 )\n    {\n        const T* src0 = src[0];\n        for( i = j = 0; i < len; i++, j += cn )\n            dst[j] = src0[i];\n    }\n    else if( k == 2 )\n    {\n        const T *src0 = src[0], *src1 = src[1];\n        i = j = 0;\n        for( ; i < len; i++, j += cn )\n        {\n            dst[j] = src0[i];\n            dst[j+1] = src1[i];\n        }\n    }\n    else if( k == 3 )\n    {\n        const T *src0 = src[0], *src1 = src[1], *src2 = src[2];\n        i = j = 0;\n        for( ; i < len; i++, j += cn )\n        {\n            dst[j] = src0[i];\n            dst[j+1] = src1[i];\n            dst[j+2] = src2[i];\n        }\n    }\n    else\n    {\n        const T *src0 = src[0], *src1 = src[1], *src2 = src[2], *src3 = src[3];\n        i = j = 0;\n        for( ; i < len; i++, j += cn )\n        {\n            dst[j] = src0[i]; dst[j+1] = src1[i];\n            dst[j+2] = src2[i]; dst[j+3] = src3[i];\n        }\n    }\n\n    for( ; k < cn; k += 4 )\n    {\n        const T *src0 = src[k], *src1 = src[k+1], *src2 = src[k+2], *src3 = src[k+3];\n        for( i = 0, j = k; i < len; i++, j += cn )\n        {\n            dst[j] = src0[i]; dst[j+1] = src1[i];\n            dst[j+2] = src2[i]; dst[j+3] = src3[i];\n        }\n    }\n}\n\nvoid merge8u(const unsigned char** src, unsigned char* dst, int len, int cn )\n{\n        merge_(src, dst, len, cn);\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 34, "dataset": "vecintrin", "filename": "mish.cpp", "benchmark_name": "mish", "code_v0_no_empty_lines": "#include <cmath>\n\nvoid mish(float* data, int channels, int size) \n{\n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n        for (int i = 0; i < size; i++)\n        {\n            const float MISH_THRESHOLD = 20;\n            float x = ptr[i], y;\n            if (x > MISH_THRESHOLD)\n                y = x;\n            else if (x < -MISH_THRESHOLD)\n                y = expf(x);\n            else\n                y = logf(expf(x) + 1);\n            ptr[i] = x * tanhf(y);\n        }\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 35, "dataset": "vecintrin", "filename": "morph.cpp", "benchmark_name": "morph", "code_v0_no_empty_lines": "#include <cstdint>\n#include <algorithm>\n#include <limits>\n#include <cstring>\n#include <cfloat>\n#include <iostream>\n#define CV_HAL_MORPH_ERODE   0\n#define CV_HAL_MORPH_DILATE  1\n#define CV_HAL_ERROR_OK      0\n#define CV_HAL_ERROR_NOT_IMPLEMENTED  1\n\n#define CV_8UC1  0\n#define CV_8UC4  4\n\ntemplate<typename T> struct MinOp\n{\n    T operator()(const T a, const T b) const { return std::min(a, b); }\n};\n\ntemplate<typename T> struct MaxOp\n{\n    T operator()(const T a, const T b) const { return std::max(a, b); }\n};\ntemplate<> inline uint8_t MinOp<uint8_t>::operator()(const uint8_t a, const uint8_t b) const {\n    return std::min(a, b);\n}\ntemplate<> inline uint8_t MaxOp<uint8_t>::operator()(const uint8_t a, const uint8_t b) const {\n    return std::max(a, b);\n}\n\nint morph_3x3_u8(int op,\n                 const uint8_t* src_data, size_t src_step,\n                 uint8_t* dst_data, size_t dst_step,\n                 int width, int height,\n                 const uint8_t* kernel_data,\n                 int anchor_x = 1, int anchor_y = 1,\n                 int borderType = 0, uint8_t borderValue = 0)\n{\n    if (op != CV_HAL_MORPH_ERODE && op != CV_HAL_MORPH_DILATE)\n        return CV_HAL_ERROR_NOT_IMPLEMENTED;\n\n    if (!src_data || !dst_data || !kernel_data)\n        return CV_HAL_ERROR_NOT_IMPLEMENTED;\n\n    if (width <= 0 || height <= 0)\n        return CV_HAL_ERROR_NOT_IMPLEMENTED;\n\n\n    for (int y = 0; y < height; y++)\n    {\n        for (int x = 0; x < width; x++)\n        {\n            uint8_t val = (op == CV_HAL_MORPH_ERODE) ? 255 : 0;\n            int pixel_count = 0;\n\n            for (int ky = 0; ky < 3; ky++)\n            {\n                for (int kx = 0; kx < 3; kx++)\n                {\n                    if (kernel_data[ky * 3 + kx])\n                    {\n                        int sy = y + ky - anchor_y;\n                        int sx = x + kx - anchor_x;\n                        uint8_t pixel;\n\n                        if (sy >= 0 && sy < height && sx >= 0 && sx < width)\n                        {\n                            pixel = src_data[sy * src_step + sx];\n                        }\n                        else\n                        {\n                            if (borderType == 0)\n                                pixel = borderValue;\n                            else\n                            {\n                                int csy = sy < 0 ? 0 : (sy >= height ? height - 1 : sy);\n                                int csx = sx < 0 ? 0 : (sx >= width ? width - 1 : sx);\n                                pixel = src_data[csy * src_step + csx];\n                            }\n                        }\n\n                        if (op == CV_HAL_MORPH_ERODE)\n                            val = MinOp<uint8_t>()(val, pixel);\n                        else\n                            val = MaxOp<uint8_t>()(val, pixel);\n\n                        pixel_count++;\n                    }\n                }\n            }\n\n            dst_data[y * dst_step + x] = val;\n        }\n    }\n    return CV_HAL_ERROR_OK;\n\n}\nint morph(int op, int src_type, int dst_type,\n          uint8_t* src_data, size_t src_step,\n          uint8_t* dst_data, size_t dst_step,\n          int width, int height,\n          int roi_width, int roi_height, int roi_x, int roi_y,\n          int roi_width2, int roi_height2, int roi_x2, int roi_y2,\n          int kernel_type, uint8_t* kernel_data, size_t kernel_step,\n          int kernel_width, int kernel_height, int anchor_x, int anchor_y,\n          int borderType, const double borderValue[4], int iterations, bool isSubmatrix)\n{\n    if (iterations != 1 || kernel_width != 3 || kernel_height != 3)\n        return CV_HAL_ERROR_NOT_IMPLEMENTED;\n\n    if (src_type != CV_8UC1 || dst_type != CV_8UC1)\n        return CV_HAL_ERROR_NOT_IMPLEMENTED;\n    if (anchor_x < 0) anchor_x = 1;\n    if (anchor_y < 0) anchor_y = 1;\n    uint8_t borderV = (uint8_t)std::max(0.0, std::min(255.0, borderValue[0]));\n    if (op == CV_HAL_MORPH_DILATE && borderValue[0] == DBL_MAX)\n        borderV = 0;\n    return morph_3x3_u8(op, src_data, src_step, dst_data, dst_step,\n                        width, height, kernel_data,\n                        anchor_x, anchor_y, borderType, borderV);\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 36, "dataset": "vecintrin", "filename": "packing.cpp", "benchmark_name": "packing", "code_v0_no_empty_lines": "#include <string.h>\nvoid packing(float* data, float* out_data, int w, int h, int channels, int d, int elempack, int out_elempack) \n{\n    if (channels == 1 && h == 1 && d == 1)    {\n        memcpy(out_data, data, sizeof(float) * w * elempack);\n        return;\n    }\n\n    else if (channels == 1 && d == 1)    {\n        int outh = (h * elempack + out_elempack - 1) / out_elempack;\n        size_t elemsize = elempack * sizeof(float);\n        size_t out_elemsize = out_elempack * sizeof(float);\n        size_t lane_size = out_elemsize / out_elempack;\n\n        for (int i = 0; i < outh; i++)\n        {\n            unsigned char* outptr = (unsigned char*)out_data + (size_t)i * w * out_elemsize;\n            for (int j = 0; j < w; j++)\n            {\n                unsigned char* out_elem_ptr = outptr + j * out_elemsize;\n                for (int k = 0; k < out_elempack; k++)\n                {\n                    int srcy = (i * out_elempack + k) / elempack;\n                    if (srcy >= h)\n                        break;\n\n                    int srck = (i * out_elempack + k) % elempack;\n\n                    const unsigned char* ptr = (const unsigned char*)data + (size_t)srcy * w * elemsize;\n                    const unsigned char* elem_ptr = ptr + j * elemsize;\n\n                    memcpy(out_elem_ptr + k * lane_size, elem_ptr + srck * lane_size, lane_size);\n                }\n            }\n        }\n        return;\n    }\n\n    else if (d == 1)    {\n        int outc = (channels * elempack + out_elempack - 1) / out_elempack;\n        size_t elemsize = elempack * sizeof(float);\n        size_t out_elemsize = out_elempack * sizeof(float);\n        size_t lane_size = out_elemsize / out_elempack;\n        for (int q = 0; q < outc; q++)\n        {\n            float* out = out_data + q * w * h * out_elempack;\n            for (int i = 0; i < h; i++)\n            {\n                unsigned char* outptr = (unsigned char*)out + (size_t)i * w * out_elemsize;\n                for (int j = 0; j < w; j++)\n                {\n                    unsigned char* out_elem_ptr = outptr + j * out_elemsize;\n\n                    for (int k = 0; k < out_elempack; k++)\n                    {\n                        int srcq = (q * out_elempack + k) / elempack;\n                        int srck = (q * out_elempack + k) % elempack;\n\n                        const float* m = data + srcq * w * h;\n                        const unsigned char* ptr = (const unsigned char*)m + (size_t)i * w * elemsize;\n                        const unsigned char* elem_ptr = ptr + j * elemsize;\n\n                        memcpy(out_elem_ptr + k * lane_size, elem_ptr + srck * lane_size, lane_size);\n                    }\n                }\n            }\n        }\n        return;\n    }\n\n    else    {\n        int outc = (channels * elempack + out_elempack - 1) / out_elempack;\n        size_t elemsize = sizeof(float) * elempack;\n        size_t out_elemsize = sizeof(float) * out_elempack;\n        size_t lane_size = out_elemsize / out_elempack;\n\n        for (int q = 0; q < outc; q++)\n        {\n            float* out = out_data + q * w * h * d * out_elempack;\n\n            for (int z = 0; z < d; z++)\n            {\n                for (int i = 0; i < h; i++)\n                {\n                    unsigned char* outptr = (unsigned char*)out + (size_t)(z * h + i) * w * out_elemsize;\n\n                    for (int j = 0; j < w; j++)\n                    {\n                        unsigned char* out_elem_ptr = outptr + j * out_elemsize;\n\n                        for (int k = 0; k < out_elempack; k++)\n                        {\n                            int srcq = (q * out_elempack + k) / elempack;\n                            int srck = (q * out_elempack + k) % elempack;\n\n                            const float* m = data + srcq * w * h * d;\n                            const unsigned char* ptr = (const unsigned char*)m + (size_t)(z * h + i) * w * elemsize;\n                            const unsigned char* elem_ptr = ptr + j * elemsize;\n\n                            memcpy(out_elem_ptr + k * lane_size, elem_ptr + srck * lane_size, lane_size);\n                        }\n                    }\n                }\n            }\n        }\n        return;\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 37, "dataset": "vecintrin", "filename": "pooling.cpp", "benchmark_name": "pooling", "code_v0_no_empty_lines": "#include <vector>\n#include <cfloat>\n\n#define PoolMethod_MAX 0\n#define PoolMethod_AVE 1\n\nvoid pooling(float* data, float* out_data,\n             int w, int h, int channels,\n             int kernel_w, int kernel_h,\n             int stride_w, int stride_h,\n             int pooling_type)\n{\n    const int elempack = 4;\n\n    int outw = (w - kernel_w) / stride_w + 1;\n    int outh = (h - kernel_h) / stride_h + 1;\n\n    for (int c = 0; c < channels; c++)\n    {\n        for (int ep = 0; ep < elempack; ep++)\n        {\n            const float* in_ptr = data + c * w * h * elempack + ep;\n            float* out_ptr = out_data + c * outw * outh * elempack + ep;\n\n            for (int i = 0; i < outh; i++)\n            {\n                for (int j = 0; j < outw; j++)\n                {\n                    float res = (pooling_type == PoolMethod_MAX) ? -FLT_MAX : 0.f;\n\n                    for (int ki = 0; ki < kernel_h; ki++)\n                    {\n                        for (int kj = 0; kj < kernel_w; kj++)\n                        {\n                            int ih = i * stride_h + ki;\n                            int iw = j * stride_w + kj;\n                            float val = in_ptr[(ih * w + iw) * elempack];\n                            if (pooling_type == PoolMethod_MAX)\n                                res = std::max(res, val);\n                            else\n                                res += val;\n                        }\n                    }\n\n                    if (pooling_type == PoolMethod_AVE)\n                        res /= (kernel_h * kernel_w);\n\n                    out_ptr[(i * outw + j) * elempack] = res;\n                }\n            }\n        }\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 38, "dataset": "vecintrin", "filename": "prelu.cpp", "benchmark_name": "prelu", "code_v0_no_empty_lines": "\nvoid prelu(float* data, float* slope_data, int channels, int size, int num_slope)\n{\n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n        float slope = num_slope > 1 ? slope_data[q] : slope_data[0];\n\n        for (int i = 0; i < size; i++)\n        {\n            if (ptr[i] < 0)\n                ptr[i] *= slope;\n        }\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 39, "dataset": "vecintrin", "filename": "quantize.cpp", "benchmark_name": "quantize", "code_v0_no_empty_lines": "#include <stddef.h>\n#include <stddef.h>\n\n\ntypedef unsigned char JSAMPLE;\ntypedef short JCOEF;\ntypedef JCOEF *JCOEFPTR; \n\n\n#define DCTSIZE         8\n#define DCTSIZE2        64\n\n\n#define MAXJSAMPLE      255\n#define CENTERJSAMPLE   128\n\ntypedef short DCTELEM;\ntypedef unsigned short UDCTELEM;\ntypedef unsigned int JDIMENSION;\ntypedef unsigned int UDCTELEM2;\n\n\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\n\nvoid quantize(JCOEFPTR coef_block, DCTELEM *divisors, DCTELEM *workspace)\n{\n    int i;\n    DCTELEM temp;\n    JCOEFPTR output_ptr = coef_block;\n\n    UDCTELEM recip, corr;\n    int shift;\n    UDCTELEM2 product;\n\n    for (i = 0; i < DCTSIZE2; i++) {\n        temp = workspace[i];\n        recip = divisors[i + DCTSIZE2 * 0];\n        corr =  divisors[i + DCTSIZE2 * 1];\n        shift = divisors[i + DCTSIZE2 * 3];\n\n        if (temp < 0) {\n            temp = -temp;\n            product = (UDCTELEM2)(temp + corr) * recip;\n            product >>= shift + sizeof(DCTELEM) * 8;\n            temp = (DCTELEM)product;\n            temp = -temp;\n        } else {\n            product = (UDCTELEM2)(temp + corr) * recip;\n            product >>= shift + sizeof(DCTELEM) * 8;\n            temp = (DCTELEM)product;\n        }\n        output_ptr[i] = (JCOEF)temp;\n    }\n}\n\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 40, "dataset": "vecintrin", "filename": "relu.cpp", "benchmark_name": "relu", "code_v0_no_empty_lines": "void relu(float* data, int channels, int size, float slope = 0.f)\n{\n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n        for (int i = 0; i < size; i++)\n        {\n            if (ptr[i] < 0)\n                ptr[i] = slope == 0.f ? 0.f : ptr[i] * slope;\n        }\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 41, "dataset": "vecintrin", "filename": "rgb_gray_convert.cpp", "benchmark_name": "rgb_gray_convert", "code_v0_no_empty_lines": "#include <stdint.h>\n\ntypedef unsigned char JSAMPLE;\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\ntypedef JSAMPARRAY *JSAMPIMAGE;\ntypedef unsigned int JDIMENSION;\ntypedef long JLONG;\n\n#define RGB_RED     0\n#define RGB_GREEN   1\n#define RGB_BLUE    2\n#define RGB_PIXELSIZE 3\n\n#define SCALEBITS       16\n#define MAXJSAMPLE      255\n#define ONE_HALF        ((JLONG)1 << (SCALEBITS - 1))\n#define FIX(x)          ((JLONG)((x) * (1L << SCALEBITS) + 0.5))\n\n#define R_Y_OFF         0\n#define G_Y_OFF         (1 * (MAXJSAMPLE + 1))\n#define B_Y_OFF         (2 * (MAXJSAMPLE + 1))\n#define GRAY_TABLE_SIZE (3 * (MAXJSAMPLE + 1))\n\n#define RANGE_LIMIT(value)  ((value) < 0 ? 0 : ((value) > MAXJSAMPLE ? MAXJSAMPLE : (value)))\n\nstatic JLONG rgb_gray_tab[GRAY_TABLE_SIZE];\nstatic int gray_table_initialized = 0;\n\n/*\n * Initialize the RGB to Grayscale conversion table\n * This implements the Y component of CCIR 601-1 conversion equations:\n *      Y (Grayscale) = 0.29900 * R + 0.58700 * G + 0.11400 * B\n * \n * These are the same coefficients used for the Y component in YCbCr conversion,\n * as grayscale is essentially the luminance (Y) component.\n */\nstatic void init_rgb_gray_table(void)\n{\n    JLONG i;\n    \n    if (gray_table_initialized)\n        return;\n    \n    for (i = 0; i <= MAXJSAMPLE; i++) {\n        rgb_gray_tab[i + R_Y_OFF] = FIX(0.29900) * i;\n        rgb_gray_tab[i + G_Y_OFF] = FIX(0.58700) * i;\n        rgb_gray_tab[i + B_Y_OFF] = FIX(0.11400) * i + ONE_HALF;\n    }\n    \n    gray_table_initialized = 1;\n}\n\n/*\n * Convert RGB samples to Grayscale.\n * \n * This function converts interleaved RGB pixel data to grayscale values.\n * The input buffer contains RGB pixels in interleaved format (RGBRGBRGB...).\n * The output buffer contains a single grayscale plane.\n *\n * The conversion uses the standard luminance formula:\n * Gray = 0.299*R + 0.587*G + 0.114*B\n *\n * Parameters:\n *   image_width  - Width of the image in pixels\n *   input_buf    - Array of pointers to input scanlines (RGB format)\n *   output_buf   - Array of pointers to output planes (only [0] used for grayscale)\n *   output_row   - Starting row in output buffers\n *   num_rows     - Number of rows to convert\n */\nvoid rgb_gray_convert(JDIMENSION image_width, JSAMPARRAY input_buf,\n                      JSAMPIMAGE output_buf, JDIMENSION output_row,\n                      int num_rows)\n{\n    int r, g, b;\n    JLONG *ctab;\n    JSAMPROW inptr;\n    JSAMPROW outptr;\n    JDIMENSION col;\n    JDIMENSION num_cols = image_width;\n    \n    init_rgb_gray_table();\n    ctab = rgb_gray_tab;\n    \n    while (--num_rows >= 0) {\n        inptr = *input_buf++;\n        outptr = output_buf[0][output_row];        output_row++;\n        \n        for (col = 0; col < num_cols; col++) {\n            r = RANGE_LIMIT(inptr[RGB_RED]);\n            g = RANGE_LIMIT(inptr[RGB_GREEN]);\n            b = RANGE_LIMIT(inptr[RGB_BLUE]);\n            inptr += RGB_PIXELSIZE;\n            \n            /* Convert to grayscale using luminance formula\n             * If the inputs are 0..MAXJSAMPLE, the output will be too;\n             * we do not need an explicit range-limiting operation.\n             * Hence the value being shifted is never negative, and we don't\n             * need the general RIGHT_SHIFT macro.\n             */\n            \n\n            outptr[col] = (JSAMPLE)((ctab[r + R_Y_OFF] + ctab[g + G_Y_OFF] +\n                                    ctab[b + B_Y_OFF]) >> SCALEBITS);\n        }\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 42, "dataset": "vecintrin", "filename": "rgb_ycc_convert.cpp", "benchmark_name": "rgb_ycc_convert", "code_v0_no_empty_lines": "#include <stdint.h>\n\ntypedef unsigned char JSAMPLE;\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\ntypedef JSAMPARRAY *JSAMPIMAGE;\ntypedef unsigned int JDIMENSION;\ntypedef long JLONG;\n\n#define RGB_RED     0\n#define RGB_GREEN   1\n#define RGB_BLUE    2\n#define RGB_PIXELSIZE 3\n\n#define SCALEBITS       16\n#define MAXJSAMPLE      255\n#define CENTERJSAMPLE   128\n#define CBCR_OFFSET     ((JLONG)CENTERJSAMPLE << SCALEBITS)\n#define ONE_HALF        ((JLONG)1 << (SCALEBITS - 1))\n#define FIX(x)          ((JLONG)((x) * (1L << SCALEBITS) + 0.5))\n\n#define R_Y_OFF         0\n#define G_Y_OFF         (1 * (MAXJSAMPLE + 1))\n#define B_Y_OFF         (2 * (MAXJSAMPLE + 1))\n#define R_CB_OFF        (3 * (MAXJSAMPLE + 1))\n#define G_CB_OFF        (4 * (MAXJSAMPLE + 1))\n#define B_CB_OFF        (5 * (MAXJSAMPLE + 1))\n#define R_CR_OFF        B_CB_OFF\n#define G_CR_OFF        (6 * (MAXJSAMPLE + 1))\n#define B_CR_OFF        (7 * (MAXJSAMPLE + 1))\n#define TABLE_SIZE      (8 * (MAXJSAMPLE + 1))\n\n#define RANGE_LIMIT(value)  ((value) < 0 ? 0 : ((value) > MAXJSAMPLE ? MAXJSAMPLE : (value)))\n\nstatic JLONG rgb_ycc_tab[TABLE_SIZE];\nstatic int table_initialized = 0;\n\n/*\n * Initialize the RGB to YCbCr conversion table\n * This implements the CCIR 601-1 conversion equations:\n *      Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B\n *      Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + CENTERJSAMPLE\n *      Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + CENTERJSAMPLE\n */\nstatic void init_rgb_ycc_table(void)\n{\n    JLONG i;\n    \n    if (table_initialized)\n        return;\n    \n    for (i = 0; i <= MAXJSAMPLE; i++) {\n        rgb_ycc_tab[i + R_Y_OFF] = FIX(0.29900) * i;\n        rgb_ycc_tab[i + G_Y_OFF] = FIX(0.58700) * i;\n        rgb_ycc_tab[i + B_Y_OFF] = FIX(0.11400) * i + ONE_HALF;\n        rgb_ycc_tab[i + R_CB_OFF] = (-FIX(0.16874)) * i;\n        rgb_ycc_tab[i + G_CB_OFF] = (-FIX(0.33126)) * i;\n        /* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.\n         * This ensures that the maximum output will round to MAXJSAMPLE\n         * not MAXJSAMPLE+1, and thus that we don't have to range-limit.\n         */\n        rgb_ycc_tab[i + B_CB_OFF] = FIX(0.50000) * i + CBCR_OFFSET + ONE_HALF - 1;\n        /* B=>Cb and R=>Cr tables are the same\n         * rgb_ycc_tab[i + R_CR_OFF] = FIX(0.50000) * i + CBCR_OFFSET + ONE_HALF - 1;\n         */\n        rgb_ycc_tab[i + G_CR_OFF] = (-FIX(0.41869)) * i;\n        rgb_ycc_tab[i + B_CR_OFF] = (-FIX(0.08131)) * i;\n    }\n    \n    table_initialized = 1;\n}\n\n/*\n * Convert RGB samples to YCbCr colorspace.\n * \n * This function converts interleaved RGB pixel data to separate Y, Cb, Cr planes.\n * The input buffer contains RGB pixels in interleaved format (RGBRGBRGB...).\n * The output buffers contain separate planes for Y, Cb, and Cr components.\n *\n * Parameters:\n *   image_width  - Width of the image in pixels\n *   input_buf    - Array of pointers to input scanlines (RGB format)\n *   output_buf   - Array of pointers to output planes [Y, Cb, Cr]\n *   output_row   - Starting row in output buffers\n *   num_rows     - Number of rows to convert\n */\nvoid rgb_ycc_convert(JDIMENSION image_width, JSAMPARRAY input_buf,\n                     JSAMPIMAGE output_buf, JDIMENSION output_row, int num_rows)\n{\n    int r, g, b;\n    JLONG *ctab;\n    JSAMPROW inptr;\n    JSAMPROW outptr0, outptr1, outptr2;\n    JDIMENSION col;\n    JDIMENSION num_cols = image_width;\n    \n    init_rgb_ycc_table();\n    ctab = rgb_ycc_tab;\n    \n    while (--num_rows >= 0) {\n        inptr = *input_buf++;\n        outptr0 = output_buf[0][output_row];        outptr1 = output_buf[1][output_row];        outptr2 = output_buf[2][output_row];        output_row++;\n        \n        for (col = 0; col < num_cols; col++) {\n            r = RANGE_LIMIT(inptr[RGB_RED]);\n            g = RANGE_LIMIT(inptr[RGB_GREEN]);\n            b = RANGE_LIMIT(inptr[RGB_BLUE]);\n            inptr += RGB_PIXELSIZE;\n            \n            /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations\n             * must be too; we do not need an explicit range-limiting operation.\n             * Hence the value being shifted is never negative, and we don't\n             * need the general RIGHT_SHIFT macro.\n             */\n            \n\n            outptr0[col] = (JSAMPLE)((ctab[r + R_Y_OFF] + ctab[g + G_Y_OFF] +\n                                     ctab[b + B_Y_OFF]) >> SCALEBITS);\n            \n\n            outptr1[col] = (JSAMPLE)((ctab[r + R_CB_OFF] + ctab[g + G_CB_OFF] +\n                                     ctab[b + B_CB_OFF]) >> SCALEBITS);\n            \n\n            outptr2[col] = (JSAMPLE)((ctab[r + R_CR_OFF] + ctab[g + G_CR_OFF] +\n                                     ctab[b + B_CR_OFF]) >> SCALEBITS);\n        }\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 43, "dataset": "vecintrin", "filename": "selu.cpp", "benchmark_name": "selu", "code_v0_no_empty_lines": "#include <cmath>\n\n\nvoid selu(float* data, int channels, int size, float alpha, float lambda) \n{\n    float alphaxlambda = alpha * lambda;\n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n\n        for (int i = 0; i < size; i++)\n        {\n            if (ptr[i] < 0.f)\n                ptr[i] = (expf(ptr[i]) - 1.f) * alphaxlambda;\n            else\n                ptr[i] *= lambda;\n        }\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 44, "dataset": "vecintrin", "filename": "sigmoid.cpp", "benchmark_name": "sigmoid", "code_v0_no_empty_lines": "#include <cmath>\n\nvoid sigmoid(float* data, int channels, int size) {\n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n        for (int i = 0; i < size; i++)\n        {\n            float v = ptr[i];\n            v = std::min(v, 88.3762626647949f);\n            v = std::max(v, -88.3762626647949f);\n            ptr[i] = 1.f / (1.f + expf(-v));\n        }\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 45, "dataset": "vecintrin", "filename": "softmax.cpp", "benchmark_name": "softmax", "code_v0_no_empty_lines": "#include <cmath>\n#include <float.h>\n\nstatic void softmax(float* _ptr, int size)\n{\n    float max = -FLT_MAX;\n    {\n        const float* ptr = _ptr;\n        for (int i = 0; i < size; i++)\n        {\n            max = std::max(max, *ptr++);\n        }\n    }\n\n    float sum = 0.f;\n    {\n        float* ptr = _ptr;\n        for (int i = 0; i < size; i++)\n        {\n            *ptr = expf(*ptr - max);\n            sum += *ptr;\n            ptr++;\n        }\n    }\n\n    {\n        float* ptr = _ptr;\n        for (int i = 0; i < size; i++)\n        {\n            *ptr++ /= sum;\n        }\n    }\n}\n\nstatic void softmax(float* _ptr, int size, int stride)\n{\n    float max = -FLT_MAX;\n    {\n        const float* ptr = _ptr;\n        for (int i = 0; i < size; i++)\n        {\n            max = std::max(max, *ptr);\n            ptr += stride;\n        }\n    }\n\n    float sum = 0.f;\n    {\n        float* ptr = _ptr;\n        for (int i = 0; i < size; i++)\n        {\n            *ptr = expf(*ptr - max);\n            sum += *ptr;\n            ptr += stride;\n        }\n    }\n\n    {\n        float* ptr = _ptr;\n        for (int i = 0; i < size; i++)\n        {\n            *ptr /= sum;\n            ptr += stride;\n        }\n    }\n}\n\nvoid softmax(float* data, int w, int h, int channels, int d, int positive_axis) \n{\n\n    if (channels == 1 && h == 1 && d == 1)    {\n        float* ptr = data;\n\n        softmax(ptr, w);\n    }\n\n    else if (channels == 1 && d == 1 && positive_axis == 0)\n    {\n        for (int i = 0; i < w; i++)\n        {\n            float* ptr = data + i;\n            softmax(ptr, h, w);\n        }\n    }\n\n    else if (channels == 1 && d == 1 && positive_axis == 1)\n    {\n        for (int i = 0; i < h; i++)\n        {\n            float* ptr = data + i * w;\n            softmax(ptr, w);\n        }\n    }\n\n    else if (d == 1 && positive_axis == 0)\n    {\n        const int size = w * h;\n        for (int i = 0; i < size; i++)\n        {\n            float* ptr = data + i;\n\n            softmax(ptr, channels, size);\n        }\n    }\n\n    else if (d == 1 && positive_axis == 1)\n    {\n        const int size = w * h;\n        for (int q = 0; q < channels; q++)\n        {\n            float* ptr = data + q * size;\n            for (int i = 0; i < w; i++)\n            {\n                softmax(ptr, h, w);\n                ptr += 1;\n            }\n        }\n    }\n\n    else if (d == 1 && positive_axis == 2)\n    {\n        for (int q = 0; q < channels; q++)\n        {\n            float* ptr = data + q * w * h;\n            for (int i = 0; i < h; i++)\n            {\n                softmax(ptr, w);\n                ptr += w;\n            }\n        }\n    }\n\n    else if (positive_axis == 0)\n    {\n        const int size = w * h * d;\n        for (int i = 0; i < size; i++)\n        {\n            float* ptr = data + i;\n            softmax(ptr, channels, size);\n        }\n    }\n\n    else if (positive_axis == 1)\n    {        \n        const int size = w * h * d;\n        for (int q = 0; q < channels; q++)\n        {\n            float* ptr = data + q * size;\n            for (int i = 0; i < w * h; i++)\n            {\n                softmax(ptr, d, w * h);\n                ptr += 1;\n            }\n        }\n    }\n\n    else if (positive_axis == 2)\n    {\n        for (int q = 0; q < channels; q++)\n        {\n            for (int i = 0; i < d; i++)\n            {\n                float* ptr = data + (q*d+i) * h * w;\n                for (int j = 0; j < w; j++)\n                {\n                    softmax(ptr, h, w);\n                    ptr += 1;\n                }\n            }\n        }\n    }\n\n    else if (positive_axis == 3)\n    {\n        for (int q = 0; q < channels; q++)\n        {\n            float* ptr = data + q * d * w * h;\n            for (int i = 0; i < d; i++)\n            {\n                for (int j = 0; j < h; j++)\n                {\n                    softmax(ptr, w);\n                    ptr += w;\n                }\n            }\n        }\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 46, "dataset": "vecintrin", "filename": "split.cpp", "benchmark_name": "split", "code_v0_no_empty_lines": "#include <cstring>\ntemplate<typename T> static void\nsplit_( const T* src, T** dst, int len, int cn )\n{\n    int k = cn % 4 ? cn % 4 : 4;\n    int i, j;\n    if( k == 1 )\n    {\n        T* dst0 = dst[0];\n\n        if(cn == 1)\n        {\n            memcpy(dst0, src, len * sizeof(T));\n        }\n        else\n        {\n            for( i = 0, j = 0 ; i < len; i++, j += cn )\n                dst0[i] = src[j];\n        }\n    }\n    else if( k == 2 )\n    {\n        T *dst0 = dst[0], *dst1 = dst[1];\n        i = j = 0;\n\n        for( ; i < len; i++, j += cn )\n        {\n            dst0[i] = src[j];\n            dst1[i] = src[j+1];\n        }\n    }\n    else if( k == 3 )\n    {\n        T *dst0 = dst[0], *dst1 = dst[1], *dst2 = dst[2];\n        i = j = 0;\n\n        for( ; i < len; i++, j += cn )\n        {\n            dst0[i] = src[j];\n            dst1[i] = src[j+1];\n            dst2[i] = src[j+2];\n        }\n    }\n    else\n    {\n        T *dst0 = dst[0], *dst1 = dst[1], *dst2 = dst[2], *dst3 = dst[3];\n        i = j = 0;\n\n        for( ; i < len; i++, j += cn )\n        {\n            dst0[i] = src[j]; dst1[i] = src[j+1];\n            dst2[i] = src[j+2]; dst3[i] = src[j+3];\n        }\n    }\n\n    for( ; k < cn; k += 4 )\n    {\n        T *dst0 = dst[k], *dst1 = dst[k+1], *dst2 = dst[k+2], *dst3 = dst[k+3];\n        for( i = 0, j = k; i < len; i++, j += cn )\n        {\n            dst0[i] = src[j]; dst1[i] = src[j+1];\n            dst2[i] = src[j+2]; dst3[i] = src[j+3];\n        }\n    }\n}\n\nvoid split8u(const unsigned char* src, unsigned char** dst, int len, int cn )\n{\n        split_(src, dst, len, cn);\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 47, "dataset": "vecintrin", "filename": "swish.cpp", "benchmark_name": "swish", "code_v0_no_empty_lines": "#include <cmath>\n\nvoid swish(float* data, int channels, int size) \n{\n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n\n        for (int i = 0; i < size; i++)\n        {\n            float x = ptr[i];\n            ptr[i] = x / (1.f + expf(-x));\n        }\n    }\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 48, "dataset": "vecintrin", "filename": "tanh.cpp", "benchmark_name": "tanh", "code_v0_no_empty_lines": "#include <cmath>\nvoid tanh(float* data, int channels, int size) \n{\n    for (int q = 0; q < channels; q++)\n    {\n        float* ptr = data + q * size;\n\n        for (int i = 0; i < size; i++)\n        {\n            ptr[i] = tanhf(ptr[i]);\n        }\n    }\n\n}", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
{"idx": 49, "dataset": "vecintrin", "filename": "ycc_rgb_convert.cpp", "benchmark_name": "ycc_rgb_convert", "code_v0_no_empty_lines": "/*\n * Standalone YCbCr to RGB conversion function\n * Extracted from libjpeg-turbo jdcolext.c and jdcolor.c\n */\n\n#include <stdint.h>\n#include <stdlib.h>\n\ntypedef unsigned char JSAMPLE;\ntypedef JSAMPLE *JSAMPROW;\ntypedef JSAMPROW *JSAMPARRAY;\ntypedef JSAMPARRAY *JSAMPIMAGE;\ntypedef unsigned int JDIMENSION;\ntypedef long JLONG;\n\n#define RGB_RED     0\n#define RGB_GREEN   1\n#define RGB_BLUE    2\n#define RGB_PIXELSIZE 3\n\n#define SCALEBITS       16\n#define MAXJSAMPLE      255\n#define CENTERJSAMPLE   128\n#define ONE_HALF        ((JLONG)1 << (SCALEBITS - 1))\n#define FIX(x)          ((JLONG)((x) * (1L << SCALEBITS) + 0.5))\n\n#define RANGE_LIMIT(value)  ((value) < 0 ? 0 : ((value) > MAXJSAMPLE ? MAXJSAMPLE : (value)))\n\nstatic int Cr_r_tab[MAXJSAMPLE + 1];\nstatic int Cb_b_tab[MAXJSAMPLE + 1];\nstatic JLONG Cr_g_tab[MAXJSAMPLE + 1];\nstatic JLONG Cb_g_tab[MAXJSAMPLE + 1];\nstatic int tables_initialized = 0;\n\nstatic JSAMPLE range_limit_table[3 * (MAXJSAMPLE + 1)];\nstatic JSAMPLE *range_limit = NULL;\n\n/*\n * Initialize the YCbCr to RGB conversion tables.\n * This implements the CCIR 601-1 conversion equations:\n *      R = Y                + 1.40200 * Cr\n *      G = Y - 0.34414 * Cb - 0.71414 * Cr\n *      B = Y + 1.77200 * Cb\n *\n * where Cb and Cr represent the incoming values less CENTERJSAMPLE.\n * To avoid floating-point arithmetic, we represent the fractional constants\n * as integers scaled up by 2^16, with appropriate rounding.\n */\nstatic void build_ycc_rgb_table(void)\n{\n    int i;\n    JLONG x;\n\n    for (i = 0; i <= MAXJSAMPLE; i++) {\n        range_limit_table[i + MAXJSAMPLE + 1] = (JSAMPLE)i;\n    }\n    for (i = 0; i <= MAXJSAMPLE; i++) {\n        range_limit_table[i + 2 * (MAXJSAMPLE + 1)] = MAXJSAMPLE;\n    }\n    range_limit = &range_limit_table[MAXJSAMPLE + 1];\n    \n    for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n\n\n        \n\n        Cr_r_tab[i] = (int)((FIX(1.40200) * x + ONE_HALF) >> SCALEBITS);\n        \n\n        Cb_b_tab[i] = (int)((FIX(1.77200) * x + ONE_HALF) >> SCALEBITS);\n        \n\n        Cr_g_tab[i] = (-FIX(0.71414)) * x;\n        \n\n\n        Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n    }\n    \n    tables_initialized = 1;\n}\n/*\n * Convert YCbCr samples to RGB colorspace.\n * \n * This function converts separate Y, Cb, Cr planes to interleaved RGB pixel data.\n * The input buffers contain separate planes for Y, Cb, and Cr components.\n * The output buffer contains RGB pixels in interleaved format (RGBRGBRGB...).\n *\n * Parameters:\n *   output_width - Width of the output image in pixels\n *   input_buf    - Array of pointers to input planes [Y, Cb, Cr]\n *   input_row    - Starting row in input buffers\n *   output_buf   - Array of pointers to output scanlines (RGB format)\n *   num_rows     - Number of rows to convert\n */\nvoid ycc_rgb_convert(JDIMENSION output_width, JSAMPIMAGE input_buf,\n                     JDIMENSION input_row, JSAMPARRAY output_buf,\n                     int num_rows)\n{\n    int y, cb, cr;\n    JSAMPROW outptr;\n    JSAMPROW inptr0, inptr1, inptr2;\n    JDIMENSION col;\n    JDIMENSION num_cols = output_width;\n    \n    build_ycc_rgb_table();\n    \n    while (--num_rows >= 0) {\n        inptr0 = input_buf[0][input_row];        inptr1 = input_buf[1][input_row];        inptr2 = input_buf[2][input_row];        input_row++;\n        outptr = *output_buf++;\n        \n        for (col = 0; col < num_cols; col++) {\n            y  = inptr0[col];\n            cb = inptr1[col];\n            cr = inptr2[col];\n            \n\n\n            \n\n            outptr[RGB_RED] = range_limit[y + Cr_r_tab[cr]];\n            \n\n            outptr[RGB_GREEN] = range_limit[y + ((int)(Cb_g_tab[cb] + Cr_g_tab[cr]) >> SCALEBITS)];\n            \n\n            outptr[RGB_BLUE] = range_limit[y + Cb_b_tab[cb]];\n            \n            outptr += RGB_PIXELSIZE;\n        }\n    }\n}\n", "code_v1_no_empty_lines": "", "input": "", "lang": "cpp"}
